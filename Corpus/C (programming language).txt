***C (programming language)***
C  ( , as in the letter  c ) is a general-purpose, procedural computer programming language supporting structured programming, lexical variable scope, and recursion, while a static type system prevents unintended operations. By design, C provides constructs that map efficiently to typical machine instructions and has found lasting use in applications previously coded in assembly language. Such applications include operating systems and various application software for computers, from supercomputers to embedded systems.
 C was originally developed at Bell Labs by Dennis Ritchie between 1972 and 1973 to make utilities running on Unix. Later, it was applied to re-implementing the kernel of the Unix operating system. During the 1980s, C gradually gained popularity.  It has become one of the most widely used programming languages, with C compilers from various vendors available for the majority of existing computer architectures and operating systems. C has been standardized by the ANSI since 1989 (see ANSI C) and by the International Organization for Standardization.
 C is an imperative procedural language. It was designed to be compiled using a relatively straightforward compiler to provide low-level access to memory and language constructs that map efficiently to machine instructions, all with minimal runtime support. Despite its low-level capabilities, the language was designed to encourage cross-platform programming. A standards-compliant C program written with portability in mind can be compiled for a wide variety of computer platforms and operating systems with few changes to its source code. The language is available on various platforms, from embedded microcontrollers to supercomputers.
 

 **Overview**

 Like most procedural languages in the ALGOL tradition, C has facilities for structured programming and allows lexical variable scope and recursion. Its static type system prevents unintended operations. In C, all executable code is contained within subroutines (also called "functions", though not strictly in the sense of functional programming). Function parameters are always passed by value. Pass-by-reference is simulated in C by explicitly passing pointer values. C program source text is free-format, using the semicolon as a statement terminator and curly braces for grouping blocks of statements.
 The C language also exhibits the following characteristics:
 
 There is a small, fixed number of keywords, including a full set of control flow primitives:  if/else ,  for ,  do/while ,  while , and  switch . User-defined names are not distinguished from keywords by any kind of sigil. 
 There are a large number of arithmetic, bitwise and logic operators:  + ,  += ,  ++ ,  & ,  || , etc. 
 More than one assignment may be performed in a single statement. 
 Function return values can be ignored when not needed. 
 Typing is static, but weakly enforced; all data has a type, but implicit conversions are possible. 
 Declaration syntax mimics usage context. C has no "define" keyword; instead, a statement beginning with the name of a type is taken as a declaration. There is no "function" keyword; instead, a function is indicated by the parentheses of an argument list. 
 User-defined ( typedef ) and compound types are possible.
 Heterogeneous aggregate data types ( struct ) allow related data elements to be accessed and assigned as a unit. 
 Union is a structure with overlapping members; only the last member stored is valid. 
 Array indexing is a secondary notation, defined in terms of pointer arithmetic. Unlike structs, arrays are not first-class objects: they cannot be assigned or compared using single built-in operators. There is no "array" keyword in use or definition; instead, square brackets indicate arrays syntactically, for example  month[11] . 
 Enumerated types are possible with the  enum  keyword. They are freely interconvertible with integers. 
 Strings are not a distinct data type, but are conventionally implemented as null-terminated character arrays. 
 Low-level access to computer memory is possible by converting machine addresses to typed pointers. 
 Procedures (subroutines not returning values) are a special case of function, with an untyped return type  void . 
 Functions may not be defined within the lexical scope of other functions. 
 Function and data pointers permit  ad hoc  run-time polymorphism. 
 A preprocessor performs macro definition, source code file inclusion, and conditional compilation. 
 There is a basic form of modularity: files can be compiled separately and linked together, with control over which functions and data objects are visible to other files via  static  and  extern  attributes. 
 Complex functionality such as I/O, string manipulation, and mathematical functions are consistently delegated to library routines. While C does not include certain features found in other languages (such as object orientation and garbage collection), these can be implemented or emulated, often through the use of external libraries (e.g., the GLib Object System or the Boehm garbage collector).
 

 **Relations to other languages**

 Many later languages have borrowed directly or indirectly from C, including C++, C#, Unix's C shell, D, Go, Java, JavaScript, Limbo, LPC, Objective-C, Perl, PHP, Python, Rust, Swift, Verilog and SystemVerilog (hardware description languages).  These languages have drawn many of their control structures and other basic features from C. Most of them (Python being a dramatic exception) also express highly similar syntax to C, and they tend to combine the recognizable expression and statement syntax of C with underlying type systems, data models, and semantics that can be radically different.
 

 **Syntax**

 C has a formal grammar specified by the C standard. Line endings are generally not significant in C; however, line boundaries do have significance during the preprocessing phase. Comments may appear either between the delimiters  /*  and  */ , or (since C99)  following  //  until the end of the line. Comments delimited by  /*  and  */  do not nest, and these sequences of characters are not interpreted as comment delimiters if they appear inside string or character literals. C source files contain declarations and function definitions. Function definitions, in turn, contain declarations and statements. Declarations either define new types using keywords such as  struct ,  union , and  enum , or assign types to and perhaps reserve storage for new variables, usually by writing the type followed by the variable name. Keywords such as  char  and  int  specify built-in types. Sections of code are enclosed in braces ( {  and  } , sometimes called "curly brackets") to limit the scope of declarations and to act as a single statement for control structures.
 As an imperative language, C uses  statements  to specify actions. The most common statement is an  expression statement , consisting of an expression to be evaluated, followed by a semicolon; as a side effect of the evaluation, functions may be called and variables may be assigned new values. To modify the normal sequential execution of statements, C provides several control-flow statements identified by reserved keywords. Structured programming is supported by  if (- else ) conditional execution and by  do - while ,  while , and  for  iterative execution (looping). The  for  statement has separate initialization, testing, and reinitialization expressions, any or all of which can be omitted.  break  and  continue  can be used to leave the innermost enclosing loop statement or skip to its reinitialization. There is also a non-structured  goto  statement which branches directly to the designated label within the function.  switch  selects a  case  to be executed based on the value of an integer expression.
 Expressions can use a variety of built-in operators and may contain function calls. The order in which arguments to functions and operands to most operators are evaluated is unspecified. The evaluations may even be interleaved. However, all side effects (including storage to variables) will occur before the next "sequence point"; sequence points include the end of each expression statement, and the entry to and return from each function call.  Sequence points also occur during evaluation of expressions containing certain operators ( && ,  || ,  ?:  and the comma operator). This permits a high degree of object code optimization by the compiler, but requires C programmers to take more care to obtain reliable results than is needed for other programming languages.
 Kernighan and Ritchie say in the Introduction of  The C Programming Language : "C, like any other language, has its blemishes. Some of the operators have the wrong precedence; some parts of the syntax could be better." The C standard did not attempt to correct many of these blemishes, because of the impact of such changes on already existing software.

 **"Hello, world" example**

 The "hello, world" example, which appeared in the first edition of  K&R , has become the model for an introductory program in most programming textbooks, regardless of programming language. The program prints "hello, world" to the standard output, which is usually a terminal or screen display.
 The original version was: 

 A standard-conforming "hello, world" program is: 

 The first line of the program contains a preprocessing directive, indicated by  #include .  This causes the compiler to replace that line with the entire text of the  stdio.h  standard header, which contains declarations for standard input and output functions such as  printf  and  scanf . The angle brackets surrounding  stdio.h  indicate that  stdio.h  is located using a search strategy that prefers headers provided with the compiler to other headers having the same name, as opposed to double quotes which typically include local or project-specific header files.
 The next line indicates that a function named  main  is being defined. The  main  function serves a special purpose in C programs; the run-time environment calls the  main  function to begin program execution. The type specifier  int  indicates that the value that is returned to the invoker (in this case the run-time environment) as a result of evaluating the  main  function, is an integer. The keyword  void  as a parameter list indicates that this function takes no arguments. The opening curly brace indicates the beginning of the definition of the  main  function.
 The next line  calls  (diverts execution to) a function named  printf , which in this case is supplied from a system library.  In this call, the  printf  function is  passed  (provided with) a single argument, the address of the first character in the string literal  "hello, world\n" . The string literal is an unnamed array with elements of type  char , set up automatically by the compiler with a final 0-valued character to mark the end of the array ( printf  needs to know this). The  \n  is an  escape sequence  that C translates to a  newline  character, which on output signifies the end of the current line.  The return value of the  printf  function is of type  int , but it is silently discarded since it is not used. (A more careful program might test the return value to determine whether or not the  printf  function succeeded.) The semicolon  ;  terminates the statement.
 The closing curly brace indicates the end of the code for the  main  function. According to the C99 specification and newer, the  main  function, unlike any other function, will implicitly return a value of  0  upon reaching the  }  that terminates the function. (Formerly an explicit  return 0;  statement was required.) This is interpreted by the run-time system as an exit code indicating successful execution. 

 **Data types**

 The type system in C is static and weakly typed, which makes it similar to the type system of ALGOL descendants such as Pascal.  There are built-in types for integers of various sizes, both signed and unsigned, floating-point numbers, and enumerated types ( enum ).  Integer type  char  is often used for single-byte characters.  C99 added a boolean datatype.  There are also derived types including arrays, pointers, records ( struct ), and unions ( union ).
 C is often used in low-level systems programming where escapes from the type system may be necessary.  The compiler attempts to ensure type correctness of most expressions, but the programmer can override the checks in various ways, either by using a  type cast  to explicitly convert a value from one type to another, or by using pointers or unions to reinterpret the underlying bits of a data object in some other way.
 Some find C's declaration syntax unintuitive, particularly for function pointers. (Ritchie's idea was to declare identifiers in contexts resembling their use: "declaration reflects use".) C's  usual arithmetic conversions  allow for efficient code to be generated, but can sometimes produce unexpected results.  For example, a comparison of signed and unsigned integers of equal width requires a conversion of the signed value to unsigned.  This can generate unexpected results if the signed value is negative.
 

 **Pointers**

 C supports the use of pointers, a type of reference that records the address or location of an object or function in memory.  Pointers can be  dereferenced  to access data stored at the address pointed to, or to invoke a pointed-to function.  Pointers can be manipulated using assignment or pointer arithmetic.  The run-time representation of a pointer value is typically a raw memory address (perhaps augmented by an offset-within-word field), but since a pointer's type includes the type of the thing pointed to, expressions including pointers can be type-checked at compile time.  Pointer arithmetic is automatically scaled by the size of the pointed-to data type. Pointers are used for many purposes in C.  Text strings are commonly manipulated using pointers into arrays of characters.  Dynamic memory allocation is performed using pointers.  Many data types, such as trees, are commonly implemented as dynamically allocated  struct  objects linked together using pointers.  Pointers to functions are useful for passing functions as arguments to higher-order functions (such as qsort or bsearch) or as callbacks to be invoked by event handlers. A  null pointer value  explicitly points to no valid location. Dereferencing a null pointer value is undefined, often resulting in a segmentation fault.  Null pointer values are useful for indicating special cases such as no "next" pointer in the final node of a linked list, or as an error indication from functions returning pointers.  In appropriate contexts in source code, such as for assigning to a pointer variable, a  null pointer constant  can be written as  0 , with or without explicit casting to a pointer type, or as the  NULL  macro defined by several standard headers.  In conditional contexts, null pointer values evaluate to false, while all other pointer values evaluate to true.
 Void pointers ( void * ) point to objects of unspecified type, and can therefore be used as "generic" data pointers. Since the size and type of the pointed-to object is not known, void pointers cannot be dereferenced, nor is pointer arithmetic on them allowed, although they can easily be (and in many contexts implicitly are) converted to and from any other object pointer type. Careless use of pointers is potentially dangerous.  Because they are typically unchecked, a pointer variable can be made to point to any arbitrary location, which can cause undesirable effects.  Although properly used pointers point to safe places, they can be made to point to unsafe places by using invalid pointer arithmetic; the objects they point to may continue to be used after deallocation (dangling pointers); they may be used without having been initialized (wild pointers); or they may be directly assigned an unsafe value using a cast, union, or through another corrupt pointer.  In general, C is permissive in allowing manipulation of and conversion between pointer types, although compilers typically provide options for various levels of checking. Some other programming languages address these problems by using more restrictive reference types.
 

 **Arrays**

 Array types in C are traditionally of a fixed, static size specified at compile time.  (The more recent C99 standard also allows a form of variable-length arrays.)  However, it is also possible to allocate a block of memory (of arbitrary size) at run-time, using the standard library's  malloc  function, and treat it as an array.  C's unification of arrays and pointers means that declared arrays and these dynamically allocated simulated arrays are virtually interchangeable.
 Since arrays are always accessed (in effect) via pointers, array accesses are typically  not  checked against the underlying array size, although some compilers may provide bounds checking as an option.  Array bounds violations are therefore possible and rather common in carelessly written code, and can lead to various repercussions, including illegal memory accesses, corruption of data, buffer overruns, and run-time exceptions.  If bounds checking is desired, it must be done manually.
 C does not have a special provision for declaring multi-dimensional arrays, but rather relies on recursion within the type system to declare arrays of arrays, which effectively accomplishes the same thing.  The index values of the resulting "multi-dimensional array" can be thought of as increasing in row-major order.
 Multi-dimensional arrays are commonly used in numerical algorithms (mainly from applied linear algebra) to store matrices. The structure of the C array is well suited to this particular task. However, since arrays are passed merely as pointers, the bounds of the array must be known fixed values or else explicitly passed to any subroutine that requires them, and dynamically sized arrays of arrays cannot be accessed using double indexing. (A workaround for this is to allocate the array with an additional "row vector" of pointers to the columns.)
 C99 introduced "variable-length arrays" which address some, but not all, of the issues with ordinary C arrays.
 

 **Array–pointer interchangeability**

 The subscript notation  x[i]  (where  x  designates a pointer) is syntactic sugar for  *(x+i) . Taking advantage of the compiler's knowledge of the pointer type, the address that  x + i  points to is not the base address (pointed to by  x ) incremented by  i  bytes, but rather is defined to be the base address incremented by  i  multiplied by the size of an element that  x  points to.  Thus,  x[i]  designates the  i+1 th element of the array.
 Furthermore, in most expression contexts (a notable exception is as operand of  sizeof ), the name of an array is automatically converted to a pointer to the array's first element. This implies that an array is never copied as a whole when named as an argument to a function, but rather only the address of its first element is passed. Therefore, although function calls in C use pass-by-value semantics, arrays are in effect passed by reference.
 The size of an element can be determined by applying the operator  sizeof  to any dereferenced element of  x , as in  n = sizeof *x  or  n = sizeof x[0] , and the number of elements in a declared array  A  can be determined as  sizeof A / sizeof A[0] . The latter only applies to array names: variables declared with subscripts ( int A[20] ). Due to the semantics of C, it is not possible to determine the entire size of arrays through pointers to arrays or those created by dynamic allocation ( malloc ); code such as  sizeof arr / sizeof arr[0]  (where  arr  designates a pointer) will not work since the compiler assumes the size of the pointer itself is being requested. Since array name arguments to  sizeof  are not converted to pointers, they do not exhibit such ambiguity. However, arrays created by dynamic allocation are accessed by pointers rather than true array variables, so they suffer from the same  sizeof  issues as array pointers.
 Thus, despite this apparent equivalence between array and pointer variables, there is still a distinction to be made between them. Even though the name of an array is, in most expression contexts, converted into a pointer (to its first element), this pointer does not itself occupy any storage; the array name is not an l-value, and its address is a constant, unlike a pointer variable. Consequently, what an array "points to" cannot be changed, and it is impossible to assign a new address to an array name. Array contents may be copied, however, by using the  memcpy  function, or by accessing the individual elements.
 

 **Memory management**

 One of the most important functions of a programming language is to provide facilities for managing memory and the objects that are stored in memory. C provides three distinct ways to allocate memory for objects: 
 Static memory allocation: space for the object is provided in the binary at compile-time; these objects have an extent (or lifetime) as long as the binary which contains them is loaded into memory. 
 Automatic memory allocation: temporary objects can be stored on the stack, and this space is automatically freed and reusable after the block in which they are declared is exited. 
 Dynamic memory allocation: blocks of memory of arbitrary size can be requested at run-time using library functions such as  malloc  from a region of memory called the heap; these blocks persist until subsequently freed for reuse by calling the library function  realloc  or  free These three approaches are appropriate in different situations and have various trade-offs. For example, static memory allocation has little allocation overhead, automatic allocation may involve slightly more overhead, and dynamic memory allocation can potentially have a great deal of overhead for both allocation and deallocation. The persistent nature of static objects is useful for maintaining state information across function calls, automatic allocation is easy to use but stack space is typically much more limited and transient than either static memory or heap space, and dynamic memory allocation allows convenient allocation of objects whose size is known only at run-time. Most C programs make extensive use of all three.
 Where possible, automatic or static allocation is usually simplest because the storage is managed by the compiler, freeing the programmer of the potentially error-prone chore of manually allocating and releasing storage. However, many data structures can change in size at runtime, and since static allocations (and automatic allocations before C99) must have a fixed size at compile-time, there are many situations in which dynamic allocation is necessary.  Prior to the C99 standard, variable-sized arrays were a common example of this. (See the article on  malloc  for an example of dynamically allocated arrays.) Unlike automatic allocation, which can fail at run time with uncontrolled consequences, the dynamic allocation functions return an indication (in the form of a null pointer value) when the required storage cannot be allocated.  (Static allocation that is too large is usually detected by the linker or loader, before the program can even begin execution.)
 Unless otherwise specified, static objects contain zero or null pointer values upon program startup. Automatically and dynamically allocated objects are initialized only if an initial value is explicitly specified; otherwise they initially have indeterminate values (typically, whatever bit pattern happens to be present in the storage, which might not even represent a valid value for that type). If the program attempts to access an uninitialized value, the results are undefined. Many modern compilers try to detect and warn about this problem, but both false positives and false negatives can occur.
 Another issue is that heap memory allocation has to be synchronized with its actual usage in any program in order for it to be reused as much as possible.  For example, if the only pointer to a heap memory allocation goes out of scope or has its value overwritten before  free()  is called, then that memory cannot be recovered for later reuse and is essentially lost to the program, a phenomenon known as a  memory leak.  Conversely, it is possible for memory to be freed but continue to be referenced, leading to unpredictable results. Typically, the symptoms will appear in a portion of the program far removed from the actual error, making it difficult to track down the problem. (Such issues are ameliorated in languages with automatic garbage collection.)
 

 **Libraries**

 The C programming language uses libraries as its primary method of extension. In C, a library is a set of functions contained within a single "archive" file.  Each library typically has a header file, which contains the prototypes of the functions contained within the library that may be used by a program, and declarations of special data types and macro symbols used with these functions. In order for a program to use a library, it must include the library's header file, and the library must be linked with the program, which in many cases requires compiler flags (e.g.,  -lm , shorthand for "link the math library"). The most common C library is the C standard library, which is specified by the ISO and ANSI C standards and comes with every C implementation (implementations which target limited environments such as embedded systems may provide only a subset of the standard library). This library supports stream input and output, memory allocation, mathematics, character strings, and time values.  Several separate standard headers (for example,  stdio.h ) specify the interfaces for these and other standard library facilities.
 Another common set of C library functions are those used by applications specifically targeted for Unix and Unix-like systems, especially functions which provide an interface to the kernel. These functions are detailed in various standards such as POSIX and the Single UNIX Specification.
 Since many programs have been written in C, there are a wide variety of other libraries available. Libraries are often written in C because C compilers generate efficient object code; programmers then create interfaces to the library so that the routines can be used from higher-level languages like Java, Perl, and Python. 

 **File handling and streams**

 File input and output (I/O) is not part of the C language itself but instead is handled by libraries (such as the C standard library) and their associated header files (e.g.  stdio.h ). File handling is generally implemented through high-level I/O which works through streams. A stream is from this perspective a data flow that is independent of devices, while a file is a concrete device. The high level I/O is done through the association of a stream to a file. In the C standard library, a buffer (a memory area or queue) is temporarily used to store data before it's sent to the final destination. This reduces the time spent waiting for slower devices, for example a hard drive or solid state drive. Low-level I/O functions are not part of the standard C library but are generally part of "bare metal" programming (programming that's independent of any operating system such as most but not all embedded programming). With few exceptions, implementations include low-level I/O.
 

 **Language tools**

 A number of tools have been developed to help C programmers find and fix statements with undefined behavior or possibly erroneous expressions, with greater rigor than that provided by the compiler.  The tool lint was the first such, leading to many others.
 Automated source code checking and auditing are beneficial in any language, and for C many such tools exist, such as Lint. A common practice is to use Lint to detect questionable code when a program is first written. Once a program passes Lint, it is then compiled using the C compiler. Also, many compilers can optionally warn about syntactically valid constructs that are likely to actually be errors. MISRA C is a proprietary set of guidelines to avoid such questionable code, developed for embedded systems. There are also compilers, libraries, and operating system level mechanisms for performing actions that are not a standard part of C, such as bounds checking for arrays, detection of buffer overflow, serialization, dynamic memory tracking, and automatic garbage collection.
 Tools such as Purify or Valgrind and linking with libraries containing special versions of the memory allocation functions can help uncover runtime errors in memory usage.
 

 **Uses**

 C is widely used for systems programming in implementing operating systems and embedded system applications, because C code, when written for portability, can be used for most purposes, yet when needed, system-specific code can be used to access specific hardware addresses and to perform type punning to match externally imposed interface requirements, with a low run-time demand on system resources.
 C can also be used for website programming using CGI as a "gateway" for information between the Web application, the server, and the browser. C is often chosen over interpreted languages because of its speed, stability, and near-universal availability. One consequence of C's wide availability and efficiency is that compilers, libraries and interpreters of other programming languages are often implemented in C. The reference implementations of Python, Perl and PHP, for example, are all written in C.
 Because the layer of abstraction is thin and the overhead is low, C enables programmers to create efficient implementations of algorithms and data structures, useful for computationally intense programs. For example, the GNU Multiple Precision Arithmetic Library, the GNU Scientific Library, Mathematica, and MATLAB are completely or partially written in C.
 C is sometimes used as an intermediate language by implementations of other languages. This approach may be used for portability or convenience; by using C as an intermediate language, additional machine-specific code generators are not necessary.  C has some features, such as line-number preprocessor directives and optional superfluous commas at the end of initializer lists, that support compilation of generated code. However, some of C's shortcomings have prompted the development of other C-based languages specifically designed for use as intermediate languages, such as C--.
 C has also been widely used to implement end-user applications. However, such applications can also be written in newer, higher-level languages.
 

 **Related languages**

 C has both directly and indirectly influenced many later languages such as C#, D, Go, Java, JavaScript, Limbo, LPC, Perl, PHP, Python, and Unix's C shell. The most pervasive influence has been syntactical, all of the languages mentioned combine the statement and (more or less recognizably) expression syntax of C with type systems, data models and/or large-scale program structures that differ from those of C, sometimes radically.
 Several C or near-C interpreters exist, including Ch and CINT, which can also be used for scripting.
 When object-oriented languages became popular, C++ and Objective-C were two different extensions of C that provided object-oriented capabilities. Both languages were originally implemented as source-to-source compilers; source code was translated into C, and then compiled with a C compiler. The C++ programming language was devised by Bjarne Stroustrup as an approach to providing object-oriented functionality with a C-like syntax. C++ adds greater typing strength, scoping, and other tools useful in object-oriented programming, and permits generic programming via templates. Nearly a superset of C, C++ now supports most of C, with a few exceptions.
 Objective-C was originally a very "thin" layer on top of C, and remains a strict superset of C that permits object-oriented programming using a hybrid dynamic/static typing paradigm. Objective-C derives its syntax from both C and Smalltalk: syntax that involves preprocessing, expressions, function declarations, and function calls is inherited from C, while the syntax for object-oriented features was originally taken from Smalltalk.
 In addition to C++ and Objective-C, Ch, Cilk and Unified Parallel C are nearly supersets of C.
 

 **Sources**

 Ritchie, Dennis M. (1993).  The Development of the C Language .  The second ACM SIGPLAN History of Programming Languages Conference (HOPL-II) . Cambridge, MA, USA — April 20–23, 1993: ACM. pp. 201–208. doi:10.1145/154766.155580. ISBN  0-89791-570-4 . Retrieved  2014-11-04 . 

 
