 
Linear Data Structure
 
 
Prof. Pradyumansinh
 
Jadeja (9879461848)  | 
2130702 

 
Data Structure
 
10
 
 
C  program for GCD using recursion
 
 
 
Write an algorithm to find factorial of given no using recursion
 
Algorithm: FACTORIAL
 
Given integer N, this algorithm computes factorial of N. Stack A is used to store an activation record assoc
iated 
with each recursive call. Each activation record contains the current value of N and the current return address 
RET_ADDE. TEMP_REC is also a record which contains two variables PARAM & ADDRESS.TOP is a pointer to the 
top element of stack A. Initially
 
return address is set to the main calling address. PARAM is set to initial value N.
 
#include<stdio.h>
 
int Find_GCD(int, int);
 
void main()
 
{
 
 
 
int n1, n2, gcd; 
 
 

 
 
 
gcd = Find_GCD(n1, &n2);
 
 
 

 
}
 
 
int 
Find_GCD(int m, int n)
 
{
 
 
 
int gcdVal;
 
 
 
if(n>m)
 
 
 
{
 
 
 
 
gcdVal = Find_GCD(n,m);
 
 
 
}
 
 
 
else if(n==0)
 
 
 
{
 
 
 
 
gcdVal = m;
 
 
 
}
 
 
 
else
 
 
 
{
 
 
 
 
gcdVal = Find_GCD(n, m%n);
 
 
 
}
 
 
 
return(gcdVal);
 
}
 

 
Linear Data Structure
 
 
Prof. Pradyumansinh
 
Jadeja (9879461848)  | 
2130702 

 
Data Structure
 
11
 
 
 
 
Give difference between recursion and iteration
 
Iteration
 
Recursion
 
In iteration, a problem is converted into a train of 
steps that are finished one at a time, one after 
another
 
Recursion is like piling all of those steps on 
top of 
each other and then quashing them all into the 
solution.
 
With iteration, each step clearly leads onto the 
next, like stepping stones across a river
 
I
n recursion, each step replicates itself at a smaller 
scale, so that all of them combined together 
eventually solve the problem.
 
Any iterative problem is solved recursively
 
Not all recursive problem can solved by iteration
 
It does not use Stack
 
It uses Stack
 
 
 
 
 
1.
 
[Save N and return Address]
 
CALL PUSH (A, TOP, TEMP_REC)
 
2.
 
[Is the base criterion found?]
 
If
 
N=0
 
then
 
FACTORIAL

 
1
 
 
GO TO Step 4
 
Else
 
PARAM

 
N
-
1
 
 
ADDRESS

 
Step 3
 
 
GO TO 
Step 1
 
3.
 
[Calculate N!]
 
FACTORIAL

 
N * FACTORIAL
 
4.
 
[Restore previous N and return address]
 
TEMP_REC

POP(A,TOP)
 
(i.e. PARAM

N, ADDRESS

RET_ADDR)
 
GO TO ADDRESS
 

 
Linear Data Structure
 
 
Prof. Pradyumansinh
 
Jadeja (9879461848)  | 
2130702 

 
Data Structure
 
12
 
 
Write an algorithm to co
nvert infix expression to postfix expression.
 
 
Symbol
 
Input precedence
 
function F
 
Stack precedence
 
function G
 
Rank function R
 
+, 
-
 
1
 
2
 
-
1
 
*, /
 
3
 
4
 
-
1
 
^
 
6
 
5
 
-
1
 
Variables
 
7
 
8
 
1
 
(
 
9
 
0
 
-
 
)
 
0
 
-
 
-
 
 
Algorithm : REVPOL
 

 
Given an input string INFIX containing an infix expression which has 


whose symbol have precedence value given by above table, a vector S used as a stack and a NEXTCHAR 
which when invoked returns the next character of i
ts argument. This algorithm converts INFIX into reverse 
polish and places the result in the string POLISH. The integer variable TOP denotes the top of the stack. 
Algorithm PUSH and POP are used for stack manipulation. The integer variable RANK accumulates 
the rank 
of expression. Finally the string variable TEMP is used for temporary storage purpose.
 

 
Linear Data Structure
 
 
Prof. Pradyumansinh
 
Jadeja (9879461848)  | 
2130702 

 
Data Structure
 
13
 
 
 
 
1.
 
[Initialize stack]
 
 
TOP 

 
1
 
S[TOP] 

 

 
2.
 
[Initialize output string and rank count ]
 
POLISH 

 

 
RANK 

 
0
 
3.
 
 
[Get first input symbol]
 
NEXT

NEXTCHAR (INFIX)
 
4.
 
[T
ranslate the infix expression ]
 

 
5.
 
[Remove symbols with greater precedence from stack]
 
IF
 
TOP < 1
 
Then
 

 
EXIT
 
Repeat while G (S[TOP]) > F(NEXT)
 
TEMP 

 
POP (S, TOP)
 
POLISH 

 
POLISH O TEMP
 
RANK 

 
RANK + R(TEM
P)
 
IF
 
RANK <1
 
Then
 

 
EXIT
 
6.
 
[Are there matching parentheses]
 
IF
 
G(S[TOP]) != F(NEXT)
 
Then
 
call PUSH (S,TOP, NEXT)
 
Else
 
POP (S,TOP)
 
7.
 
[Get next symbol]
 
NEXT 

 
NEXTCHAR(INFIX)
 
8.
 
 
[Is the expression valid]
 
IF
 
TOP != 0 OR RANK != 1
 
Then
 
write 

 
Else
 

 
 

 
Linear Data Structure
 
 
Prof. Pradyumansinh
 
Jadeja (9879461848)  | 
2130702 

 
Data Structure
 
14
 
 
Trace the conversion of infix to postfix form in tabular form.
 
(i)
 
( A + B * C / D 
-
 
E + F / G
 
/ ( H + I ) )
 
 
 
 
Input S
ymbol
 
Content of stack
 
Reverse polish
 
Rank
 
 
(
 
 
0
 
(
 
( (
 
 
0
 
A
 
( ( 
 
 
0
 
+
 
( ( +
 
A
 
1
 
B
 
( ( + B
 
A
 
1
 
*
 
( ( + *
 
A B
 
2
 
C
 
( ( + * C
 
A B
 
2
 
/
 
( ( + /
 
A B C *
 
2
 
D
 
( ( + / D
 
A B C *
 
2
 
-
 
( ( 
-
 
A B C * D / +
 
1
 
E
 
( ( 
-
 
E
 
A B C * D / +
 
1
 
+
 
( ( +
 
A B C * D / + E 
-
 
1
 
F
 
( ( + F
 
A B C * D / + E 
-
 
1
 
/
 
( ( + /
 
A B C * D / + E 

 
F
 
2
 
G
 
( ( + / G
 
A B C * D / + E 

 
F
 
2
 
/
 
( ( + /
 
A B C * D / + E 

 
F G /
 
2
 
(
 
( ( + / (
 
A B C * D / + E 

 
F G /
 
2
 
H
 
( ( + / ( H
 
A B C * D / + E 

 
F G /
 
2
 
+
 
( ( + /
 
( +
 
A B C * D / + E 

 
F G / H
 
3
 
I
 
( ( + / ( + I
 
A B C * D / + E 

 
F G / H
 
3
 
)
 
( ( + /
 
A B C * D / + E 

 
F G / H I +
 
3
 
)
 
(
 
A B C * D / + E 

 
F G / H I + / +
 
1
 
)
 
 
A B C * D / + E 

 
F G / H I + / +
 
1
 
 
 
 
 
Postfix expression is: 
A B C * D / + E 

 
F G /
 
H I + / +
 

 
Linear Data Structure
 
 
Prof. Pradyumansinh
 
Jadeja (9879461848)  | 
2130702 

 
Data Structure
 
15
 
 
(ii) ( A + B ) * C + D / ( B + A * C ) + D
 
 
 
Input S
ymbol
 
Content of stack
 
Reverse polish
 
Rank
 
 
(
 
 
0
 
(
 
( ( 
 
 
0
 
A
 
( ( A
 
 
0
 
+
 
((  +
 
A
 
1
 
B
 
( ( + B
 
A
 
1
 
)
 
(
 
A B +
 
1
 
*
 
( *
 
A B +
 
1
 
C
 
( * C
 
A B +
 
1
 
+
 
( +
 
A B + C *
 
1
 
D
 
( + D
 
A B + C *
 
1
 
/
 
( + /
 
A B + C * D
 
2
 
(
 
( + / (
 
A B + C * D
 
2
 
B
 
( + / ( B
 
A B + C * D
 
2
 
+
 
( + / ( +
 
A B + C * D B
 
3
 
A
 
( + / ( + A
 
A B + C * 
D B
 
3
 
*
 
( + / ( + *
 
A B + C * D B A
 
4
 
C
 
( + / ( + * C
 
A B + C * D B A
 
4
 
)
 
( + /
 
A B + C * D B A C * +
 
3
 
+
 
( +
 
A B + C * D B A C * + / +
 
1
 
D
 
( + D
 
A B + C * D B A C * + / +
 
1
 
)
 
 
A B + C * D B A C * + / + D +
 
1
 
 
 
 
 
Postfix expression is:
 
A B + C * D B A C * + / + D +
 

 
Linear Data Structure
 
 
Prof. Pradyumansinh
 
Jadeja (9879461848)  | 
2130702 

 
Data Structure
 
16
 
 
Convert the following string into 
prefix:
 
A
-
B/(C*D^E)
 
 
 
 
Step
-
1 : reverse infix expression
 
 
 
) E ^ ) D * C ( ( / B 
-
 
A
 
Step
-



 
 
 
( E ^ ( D * C ) ) / B 
-
 
A
 
Step
-
3 : Now convert this string to postfix
 
Input S
ymbol
 
Content of stack
 
Reverse polish
 
Rank
 
 
(
 
 
0
 
(
 
( (
 
 
0
 
E
 
( ( E
 
 
0
 
^
 
( ( ^
 
E
 
1
 
(
 
( ( ^ (
 
E
 
1
 
D
 
( ( ^ ( D
 
E
 
1
 
*
 
( ( ^ ( *
 
E D
 
2
 
C
 
( ( ^ ( * C
 
E D
 
2
 
)
 
( ( ^
 
E D C *
 
2
 
)
 
(
 
E D C * ^
 
1
 
/
 
( /
 
E D C
 
* ^
 
1
 
B
 
( / B
 
E D C * ^
 
1
 
-
 
( 
-
 
E D C * ^ B /
 
1
 
A
 
( 
-
 
A
 
E D C * ^ B /
 
1
 
)
 
 
E D C * ^ B / A 
-
 
1
 
 
Step 4
 
: 
Reverse this postfix expression
 
 
 
-
 
A / B ^ * C D E
 
 
 

 
Linear Data Structure
 
 
Prof. Pradyumansinh
 
Jadeja (9879461848)  | 
2130702 

 
Data Structure
 
17
 
 
Translate the following string into Polish notation and trace the content of 
stack:
 
(a + b ^ c ^ d) * ( e + f / d )
 
 
 
Step
-
1 : reverse infix expression
 
 
 
) d / f + e ( * ) d ^ c ^ b + a (
 
Step
-




 
 
( d / f + e ) * ( d ^ c ^ b + a ) )
 
Step
-
3 : Now convert this string to postfix
 
Input symbol
 
Content of stack
 
Reverse polish
 
Rank
 
 
(
 
 
0
 
(
 
( (
 
 
0
 
d
 
( ( d
 
 
0
 
/
 
( ( /
 
d
 
1
 
f
 
( ( / f
 
d
 
1
 
+
 
( ( +
 
d f /
 
1
 
e
 
( ( 
+ e
 
d f /
 
1
 
)
 
(
 
d   f / e +
 
1
 
*
 
( +
 
d f / e +
 
1
 
(
 
( * (
 
d f / e +
 
1
 
d
 
( * ( d
 
d f / e +
 
1
 
^
 
( * ( ^
 
d f / e + d
 
2
 
c
 
( * ( ^ c
 
d f / e + d
 
2
 
^
 
( * ( ^ ^
 
d f / e + d c
 
3
 
b
 
( * ( ^ ^ b
 
d f / e + d c
 
3
 
+
 
( * ( +
 
d f / e + d c b ^ ^
 
2
 
a
 
( * ( + a
 
d f 
/ e + d c b ^ ^
 
2
 
)
 
( *
 
d f / e + d c b ^ ^ a +
 
2
 
)
 
 
d f / e + d c b ^ ^ a + *
 
1
 
 
Step 4
 
: 
Reverse this postfix expression
 
 
 
* + a ^ ^ b c d + e / f d
 
 
 

 
Linear Data Structure
 
 
Prof. Pradyumansinh
 
Jadeja (9879461848)  | 
2130702 

 
Data Structure
 
18
 
 
Write an algorithm for evaluation of postfix expression and evaluation the 
following expression showing every status of stack in tabular form.
 
(i) 5 4 6 +
 
* 4 9 3 / + * (ii) 7 5 2 + * 4 1 1 + / 
-
 
Algorithm:
 
EVALUAE_POSTFIX
 

 
Given an input string 
POSTFIX
 
representing 
postfix
 
expression. This algorithm is going to 
evaluate 
postfix
 
expression and put the result into variable VALUE. A vector S is used as a stack
 
PUSH and POP are the function used for manipulation of stack. Operand2 and operand1 are 
temporary variable TEMP is used for temporary variable NEXTCHAR is a function which when 
invoked returns the next character. PERFORM_OPERATION is a function which perf
orms 
required operation on OPERAND1 AND OPERAND2.
 
 
 
1.
 
[Initialize stack and value]
 
TOP 

 
1
 
VALUE 

 
0
 
2.
 
[Evaluate the prefix expression]
 
Repeat until 
last
 
character
 
 
 
TEMP 

 
NEXTCHAR (
POSTFIX
)
 
If
 
TEMP is 
DIGIT
 
T
hen
 
PUSH (S, TOP, TEMP)
 
E
lse
 
OPERAND
2
 

 
POP (S,
 
TOP)
 
OPERAND1
 

 
POP (S,
 
TOP)
 
VALUE 

 
PERFORM_OPERATION
(OPERAND1, OPERAND2, TEMP)
 
PUSH (S, POP, VALUE)
 
3.
 
[Return answer from stack]
 
Return (POP (S, TOP))
 
 

 
Linear Data Structure
 
 
Prof. Pradyumansinh
 
Jadeja (9879461848)  | 
2130702 

 
Data Structure
 
19
 
 
Evaluate (i)
: 
 
5 4 6 + * 4 9 3 / + *
 
 
Evaluate (ii) 
: 
* 
7 5 2 + * 4 1 1 + / 
-
 
 
 
 
 
 
 
 
 
 
 
49
 
 
 
2
 
4
 
49
 
 
 
 
2
 
49
 
 
 
 
7
 
5
 
 
 
2
 
5
 
7
 
Empty Stack
 
Read and push 
operands 
7
, 
5
, 
2
 
Read Operator +, 
pop two values 
from 
stack opn2 = 
2, opn1 = 5, and 
push the answer 7
 
Read Operator 
*
, 
pop two values 
from stack opn2 = 
7
, opn1 = 
7, and 
push the answer 49
 
 
1
 
1
 
4
 
49
 
Read and 
push 
operands 
4
, 
1
, 
1
 
Read Operator 
+
, 
pop two values 
from stack opn2 = 
1
, opn1 = 
1, and 
push the answer 2
 
 
 
 
 
47
 
Read Operator 
/
, 
pop two values 
from stack opn2 = 
2
, opn1 = 
4, and 
push the answer 2
 
Read Operator 
-
 
, 
pop two values 
from stack opn2 = 
2
, opn1 = 
49, and 
push the answer 47
 
Poped  value   
47 
is the answer 
 
 
 
 
 
 
 
 
 
 
50
 
 
 
3
 
4
 
50
 
 
 
 
7
 
50
 
 
 
 
10
 
5
 
 
 
6
 
4
 
5
 
Empty Stack
 
Read and push 
operands
 
5, 4, 6
 
Read Operator +, 
pop two values 
from stack opn2 = 
6, opn1 = 4
, and 
push the answer 10
 
Read Operator 
*
, 
pop two values 
from stack opn2 = 
10
, opn1 = 
5, and 
push the answer 50
 
 
3
 
9
 
4
 
50
 
Read and 
push 
operands 
4
, 
9
, 
3
 
Read Operator 
/
, 
pop two values 
from stack opn2 = 
3
, opn1 = 
9, and 
push the answer 3
 
 
 
 
 
350
 
Read Operator 
+
, 
pop two values 
from stack opn2 = 
3
, opn1 = 
4, and 
push the answer 7
 
Read Operator 
*
, 
pop two values 
from stack opn2 = 
7
, opn1 = 
50, and 
push the answer 
350
 
Poped value 
350
 
is the answer
 

 
Linear Data Structure
 
 
Prof. Pradyumansinh
 
Jadeja (9879461848)  | 
2130702 

 
Data Structure
 
20
 
 
Consider the following arithmetic expression P, written in postfix notation. 
Translate it in infix notation and evaluate.
 
P: 12, 7, 3, 
-
, /, 2, 1, 5, +, *, +
 
Same Expression in infix notation is : 
(
 
12
 
/
 
(
 
7
 

 
3
 
)
 
)
 
+
 
(
 
(
 
5
 
+
 
1
 
)
 
*
 
2
 
)
 
 
Explain Difference between Stack and Queue.
 
Stack
 
Queue
 
A Linear List Which allows insertion or deletion of 
an element at one end only is called as Stack
 
A Linear List Which allows insertion 
at
 
one end and 
deletion at another end is called as Queue
 
Since insertion and deletion of an element are 
performed at one end of the stack, the elements 
can only be removed in the opposite order of 
insertion.
 
Since insertion and deletion of an element are
 
performed at opposite end of the queue, the 
elements can only be removed in the same order of 
insertion.
 
Stack is 
called as L
ast 
I
n 
F
irst 
O
ut
 
(LIFO) List.
 
Queue
 
is 
called as First In First Out (FIFO) List.
 
The most and least accessible elements are call
ed 
as TOP and BOTTOM of the stack
 
Insertion of element is performed at FRONT end 
and deletion is performed from REAR end
 
Example of stack is arranging plates in one above 
one.
 
Example is ordinary queue in provisional store.
 
Insertion operation is 
referred as PUSH and 
deletion operation is referred as POP
 
Insertion operation is referred as ENQUEUE and 
deletion operation is referred as DQUEUE
 
Function calling in any languages uses Stack
 
Task Schedul
ing by Operating System uses que
ue
 
 
 
 
 
 
 
 
 
 
3
 
 
 
6
 
2
 
3
 
 
 
 
12
 
3
 
 
 
 
4
 
12
 
 
 
3
 
7
 
12
 
Empty Stack
 
Read and push 
operands 
12
, 
7
, 
3
 
Read Operator 
-
, 
pop two values 
from 
stack opn2 = 
3, opn1 = 7, and 
push 
the answer 4
 
Read Operator 
/
, 
pop two values 
from stack opn2 = 
4
, opn1 = 
12, and 
push the answer 3
 
 
5
 
1
 
2
 
3
 
Read and 
push 
operands 
2
, 
1
, 
5
 
Read Operator 
+
, 
pop two values 
from stack opn2 = 
5
, opn1 = 
1, and 
push the answer 6
 
 
 
 
 
15
 
Read Operator 
*
, 
pop two values 
from stack opn2 = 
6
, opn1 = 
2, and 
push the answer 12
 
Read Operator 
+
, 
pop two values 
from stack opn2 = 
12
, opn1 = 
3, and 
push the answer 15
 
Poped  value   
15 
is the answer 
 

 
Linear Data Structure
 
 
Prof. Pradyumansinh
 
Jadeja (9879461848)  | 
2130702 

 
Data Structure
 
21
 
 
Explain followi
ng:
 
 
(i) Queue (ii) Circular Queue (iii) DQUEUE (iv) Priority Queue
 
(i) Queue
 
o
 
A linear list which permits deletion to be performed at one end of the list and insertion at th
e
 
other 
end is called queue.
 
o
 
The information in such a list is processed FIFO 
(first in first out) of FCFS (first come 
first served) pattern.
 
o
 
Front is the end of queue from that deletion is to be performed.
 
o
 
Rear is the end of queue at which new element is to be inserted.
 
o
 
The process to add an element i
nto queue is called 
Enqueue
 
 
o
 
T
he process of removal of an element from queue is called 
Dequeue
.
 
o
 
The familiar and traditional example of a queue is Checkout line at Supermarket Cash Register 
where the first person in line is usually the first to be checkedout.
 
 
(ii) Circular Queue
 
o
 
A more suitable method of representing simple queue which prevents an excessive use of memory 

n] in a circular fashion with Q[1] following Q[n], this is 
called circular queue
 
o
 
In a standard queue data structure re
-
buffering problem occurs for each  
dequeue
 
operation. To 
solve this problem by joining the front and rear  ends of a queue to make the qu
eue as a circular 
queue
 
o
 
Circular queue is a linear data structure. It follows FIFO principle. 
 
o
 
In  
circular queue the last node is connected back t
o the first node to make a  
circle.
 
o
 
Circular
 
linked list fallow the First In First Out principle
 
o
 
Elements   
a
re added at the rear end and the elements are deleted at front e
nd of the 
queue
 
o
 
Both 
the front and the rear pointers points to the beginning of the array.
 
o
 
It 
i

 
Ins
ertion
 
Rear
 
Deletion
 
Front
 

 
Linear Data Structure
 
 
Prof. Pradyumansinh
 
Jadeja (9879461848)  | 
2130702 

 
Data Structure
 
22
 
 
 
(iii) D
e
queue
 
o
 
A d
e
queue (double ended queue ) is a linear list in which insertion and deletion are performed from 
the either end of the structure.
 
o
 
There are two variations of Dqueue 
 

 
Input restricted dqueue
-
 
allows inser
tion at only one end
 

 
Output restricted dqueue
-
 
allows deletion from only one end
 
o
 
Such a structure can be represented by following fig.
 
 
(iv) Priority Queue
 
o
 
A queue in which we are able to insert remove items from any position based on some property 
(such as priority of the task to be processed) is often referred as priority queue.
 
o
 
Below fig. represent a 
priority queue of jobs waiting to use a computer.
 
o
 
Priorities of 1, 2, 3 have been attached with jobs of real time, online and batch respectively. 
Therefore if a job is initiated with priority  i,it is inserted immediately at the end of list of other jobs 
w
ith priorities i. Here jobs are always removed from the front of queue
 
Insertion
 
Rear
 
Deletion
 
Front
 
Deletion
 
Insertion
 

 
Linear Data Structure
 
 
Prof. Pradyumansinh
 
Jadeja (9879461848)  | 
2130702 

 
Data Structure
 
23
 
 
 
 
 
 
R
1
 
R
2
 

 
R
i
-
1
 
O
1
 
O
2
 

 
O
j
-
1
 
B
1
 
B
2
 

 
B
k
-
1
 

 
1
 
1
 

 
1
 
2
 
2
 

 
2
 
3
 
3
 

 
3
 

 
 
Task Identification
 
Priority
 
R
i
 
O
j
 
B
k
 
Fig (a) :
 
Priority Queue viewed as a single queue with insertion allowed at any position.
 
 
R
1
 
R
2
 

 
R
i
-
1
 

 
 
O
1
 
O
2
 

 
O
j
-
1
 

 
 
B
1
 
B
2
 

 
B
k
-
1
 

 
 
Priority  1
 
Priority  2
 
Priority  3
 
R
i
 
O
j
 
B
k
 
Fig (b) :
 
Priority Queue viewed as a Viewed as a set of queue
 
 

 
Linear Data Structure
 
 
Prof. Pradyumansinh
 
Jadeja (9879461848)  | 
2130702 

 
Data Structure
 
24
 
 
Write 
algorithms of
 
basic primitive operations 
for
 
Queue
 
Procedure
: 
QINSERT_REAR (Q, F, R, N,Y)
 

 
Given F and R pointers to the front and rear elements of a queue
 
respectively
. Queue Q 
consisting of N 
elements
. This 
procedure
 
inserts Y at rear end of Queue
.
 
 
Function
:
  
QDELETE_FRONT (Q, F, R)
 

 
Given F and R pointers to the front and rear elements of a queue respectively. Queue Q consisting of N 
elements. This 
function deleted and element from front end of the Queue.
 
 
1.
 
[Unde
rflow]
 
IF
 
F= 0
 
 
Then
 

 
 
 
Return(0) 
 
(0 denotes an empty Queue)
 
2.
 
[Decrement element]
 
Y 

 
Q[F]
 
3.
 
[Queue empty?]
 
IF 
 
F=R
 
Then 
 
F

 
R

 
0
 
Else
 
 
F

 
F+1 
 
(increment front pointer)
 
4.
 
[Return element]
 
Return (Y)
 
Then
 
F 

 
1
 
Return
 
 
1.
 
[Overflow]
 
IF
 
R >= N
 
 
Then
 

 
 
 
Return
 
2.
 
[Incremen
t REAR pointer]
 
R 

 
R + 1
 
3.
 
[Insert element ]
 
Q[R] 

 
Y
 
4.
 
[Is front pointer properly set]
 
IF 
 
F=0
 
Then
 
F 

 
1
 
Return
 
 

 
Linear Data Structure
 
 
Prof. Pradyumansinh
 
Jadeja (9879461848)  | 
2130702 

 
Data Structure
 
25
 
 
Write algorithms of basic primitive operations for Circular Queue
 
Procedure
:
 
CQINSERT (F, R, Q, N, Y)
 

 
Given F and R pointers to the front and rear elements of a circular queue respectively. Circular queue Q 
consisting of N elements. This procedure inserts Y at rear end of Circular queue.
 
 
Function CQDELETE (F, R, Q, N)
 

 
Given F and R pointers to the front and rear elements of a Circular queue respectively. Circular Queue Q 
consisting of N elements. Th
is function deleted and element from front end of the Circular Queue. Y is 
temporary pointer variable.
 
1.
 
[Reset Rear Pointer]
 
If
 
R = N
 
Then
 
R

 
1
 
Else 
 
R 

 
R + 1
 
2.
 
[Overflow]
 
If
 
F = R
 
Then 
 

 
 
Return
 
3.
 
[Insert element]
 
Q[R] 

 
Y
 
4.
 
[Is front pointer properly set?]
 
If
 
F = 0
 
Then 
 
F 

 
1
 
Return
 
 

 
Linear Data Structure
 
 
Prof. Pradyumansinh
 
Jadeja (9879461848)  | 
2130702 

 
Data Structure
 
26
 
 
 
Write algorithms of basic primitive operations for DQueue
 
Procedure DQINSERT_FRONT (Q, F, R, N,Y)
 

 
Given F and R pointers to the 
front and rear elements of a queue, a queue consisting of N elements and an 
element Y, this procedure inserts Y at the front of the queue.
 
 
Procedure DQDELETE_REAR (Q, F, R)
 

 
Given F and R pointers to the front and rear elements of a queue. And a queue Q to which they correspond, 
this function deletes and returns the last element from the front end of a queue
. And Y is temporary 
variable.
 
1.
 
[Overflow]
 
IF
 
F = 0
 
 
Then
 

 
 
 
Return
 
IF
 
F=1
 
Then 
 

 
 
Return
 
2.
 
[Decrement front 
pointer]
 
F 

 
F
-
1
 
3.
 
[Insert element ]
 
Q[F] 

 
Y
 
Return
 
1.
 
[Underflow?]
 
If F = 0
 
Then 
 

 
 
Return (0)
 
2.
 
[Delete Element]
 
Y 

 
Q[F]
 
3.
 
[Queue Empty?]
 
If
 
F = R
 
Then 
 
F 

 
R 

 
0
 
 
Return (Y) 
 
4.
 
[Increment
 
front pointer]
 
If
 
F = N
 
Then 
 
F 

 
1
 
Else
 
F 

 
F + 1
 
Return (Y)
 
 

 
Linear Data Structure
 
 
Prof. Pradyumansinh
 
Jadeja (9879461848)  | 
2130702 

 
Data Structure
 
27
 
 
 
 
 
1.
 
[Underflow]
 
IF
 
R= 0
 
 
Then
 

 
 
 
Return(0)
 
2.
 
[Delete element]
 
Y 

 
Q[R]
 
3.
 
[Queue empty?]
 
IF 
 
R=F
 
Then 
 
R

 
F

 
0
 
Else 
 
R

 
R
-
1 
 
(decrement front pointer)
 
4.
 
[Return element]
 
Return (Y)
 

 
Linear Data Structure
 
 
Prof. Pradyumansinh
 
Jadeja (9879461848)  | 
2130702 

 
Data Structure
 
28
 
 
PROCEDURE 
D
QUEUE_DISPLAY (F,R,Q)
 

 
Given F and 
Rare
 
pointers to the front and rear elements of a queue, a queue consist of N elements. This 
procedure display Queue contents
 
 
 
Consider the following queue, where queue is a circular queue having 6 
memory cells. Front=2, Rear=4
 
Queue: _, A, C, D, _, _
 
Describe queue as following o
peration take place:
 
F is added to the queue
 
Two letters are deleted
 
R is added to the queue
 
S is added to the queue
 
One letter is deleted
 
 
Positions
 
1
 
2
 
3
 
4
 
5
 
6
 
Initial Position of Queue, 
Front=2, Rear=4
 
 
A
 
C
 
D
 
 
 
F is added to queue
, 
Front=2, Rear=5
 
 
A
 
C
 
D
 
F
 
 
Two letters are deleted, 
Front=4, Rear=
5
 
 
 
 
D
 
F
 
 
R is added to the queue, 
Front=4, Rear=6
 
 
 
 
D
 
F
 
R
 
S is added to the queue, 
Front=4, Rear=1
 
S
 
 
 
D
 
F
 
R
 
One letter is deleted
,
 
Front=5, Rear=1
 
S
 
 
 
 
F
 
R
 
 
1.
 
[Check for empty]
 
IF
 
F >= R
 
 
Then
 


 
 
 
Return
 
2.
 
[Display content]
 
FOR
 
 
(I=FRONT; I<=REAER; I++)
 
 
 
Write (Q[I])
 
3.
 
[Return Statement]
 
Return
 
 

 
Linked List
 
 
Prof. Pradyumansinh Jadeja (9879461848)  | 
2130702 

 
Data Structure
 
1
 
 
1.
 
Linear Data Structure and their linked storage representation.
 
There are many applications where sequential allocation method is unacceptable because of following 
characteristics
 

 
Unpredictable storage requirement
 

 
Extensive manipulation of stored data
 
The linked allocation method of storage can result in both efficient use of computer storage and computer time.
 

 
A linked list is a non
-
sequential collection of data items.
 

 
The concept 
of a linked list is very simple, for every data item in the linked list, there is an associated 
pointer that would give the memory allocation of the next data item in the linked list.
 

 
The data items in the linked list are not in a consecutive memory locati
ons but they may be anywhere in 
memory.
 

 
Accessing of these data items is easier as each data item contains within itself the address of the next 
data item.
 
 
 
2.
 
What is linked list? What are different types of linked list?
 
OR
 
Write a short note on singly, circular and doubly linked 
list. OR
 
Advantages and disadvantages of singly, circular and doubly linked list.
 

 
A linked list is a collection of objects stored in a list form.
 

 
A linked list is a sequence of items (objects) where every item is linked to the next.
 

 
A linked list is a 
non
-
primitive
 
type of data structure in which each element is dynamically allocated and 
in which elements point to each other to define a linear relationship.
 

 
Elements of linked list are called nodes where each node contains two things, data and pointer to nex
t 
node. 
 

 
Linked list require more memory compared to array because along with value it stores pointer to next 
node.
 

 
Linked lists are among the simplest and most common data structures. They can be used to implement 
other data structures like stacks, queues

 
10
 
next
 
20
 
next
 
 
30
 
next
 
 
 
40
 
null
 
A Linked List
 

 
Linked List
 
 
Prof. Pradyumansinh Jadeja (9879461848)  | 
2130702 

 
Data Structure
 
2
 
 
 
Operations on linked list
 

 
Insert
 
o
 
Insert at first position
 
o
 
Insert at last position
 
o
 
Insert into ordered list
 

 
Delete
 

 
Traverse list (Print list)
 

 
Copy linked list
 
Types of linked list
 
Singly Linked List
 

 
It is basic type of li
nked list. 
 

 
Each node contains data and pointer to next node.  
 

 

 

 
Limitation of singly linked list is we can traverse only in one direction, forward direction. 
 
 
 
Circular Linked List
 

 
Circular linked list is a singly linked list where last node points to first node in the list. 
 

 
It does not contain null pointers like singly linked li
st.
 

 
We can traverse only in one direction that is forward direction.
 

 
It has the biggest advantage of time saving when we want to go from last node to first node, it 
directly points to first node.
 

 
A good example of an application where circular linked list 
should be used is a timesharing problem 
solved by the operating system.
 
A
 
next
 
B
 
next
 
 
C
 
next
 
 
 
D
 
null
 
Singly Linked List
 
Node
 
info
 
link
 
Data
 
Pointer to 
next node
 
// C Structure to represent a node
 
struct node
 
{
 
int info
 
struct node *link
 
};
 

 
Linked List
 
 
Prof. Pradyumansinh Jadeja (9879461848)  | 
2130702 

 
Data Structure
 
3
 
 
 
 
Doubly Linked list
 

 
Each node of doubly linked list contains data and two pointers to point previous
 
(LPTR)
 
and next
 
(RPTR)
 
node.
 
 
 
 

 
Main advantage of doubly linked list is we can traverse in any direction, forward or reverse.
 

 
Other advantage of doubly linked list is we can delete a node with little trouble, since we have 
pointers to the previous and
 
next nodes. A node on a singly linked list cannot be removed unless we 
have the pointer to its predecessor.
 

 
Drawback of doubly linked list is it requires more memory compared to singly linked list because we 
need an extra pointer to point previous node.
 

 
L
 
and R in image 
denote
 
left most and right most nodes in the list.
 

 
Left link of L node and right link of R node is NULL, indicating the end of list for each direction.
 
 
 
3.
 
Discuss advantages and disadvantages of linked list over array.
 
Advantages of an array
 
1.
 
We can access any
 
element of an array directly means random access is easy
 
2.
 
It can be used to create other useful data structures (queues, stacks)
 
A
 
next
 
B
 
next
 
 
C
 
null
 
Doubly Linked List
 
prev
 
 
 
prev
 
 
 
null
 
 
 
L
 
R
 
Node
 
Data
 
Pointer to 
next node
 
// C 
Structure to represent a node
 
struct node
 
{
 
int info
 
struct node *
lptr;
 
struct node *
rptr;
 
};
 
RPTR
 
LPTR
 
info
 
A
 
next
 
B
 
next
 
 
C
 
next
 
 
 
D
 
next
 
 
Circular Linked List
 
Pointer to 
previous node
 

 
Linked List
 
 
Prof. Pradyumansinh Jadeja (9879461848)  | 
2130702 

 
Data Structure
 
4
 
 
3.
 
It is light on memory usage compared to other structures
 
Disadvantages of an array
 
1.
 
Its size is fixed
 
2.
 
It cannot be dynamically r
esized in most languages
 
3.
 
It is hard to add/remove elements 
 
4.
 
Size of all elements must be same.
 
5.
 
Rigid structure (Rigid = Inflexible or not changeable)
 
Advantages of Linked List
 
1.
 
Linked lists are dynamic data structures:
 
That is, they can grow or shrink durin
g execution of a 
program.
 
2.
 
Efficient memory utilization:
 
Here memory is not pre
-
allocated. Memory is allocated whenever it is 
required. And it is deallocated (free) when it is no longer needed.
 
3.
 
Insertion and deletions are easier and efficient:
 
Linked list provide flexibility in inserting a data item 
at a specified position and deletion of a data item from the given position.
 
4.
 
Eleme
nts of linked list are flexible:
 
I
t can be primary data type or user defined data types
 
Disadvantages of Linked List
 
1.
 
Random access is not allowed. We have to access elements sequentially starting from the first node. 
So we cannot do binary search with linked lists.
 
2.
 
It cannot be easily sorted
 
3.
 
We must traverse 1/2 the list on average to access any element
 
4.
 
More complex to 
create than an array
 
5.
 
Extra memory space for a pointer is required with each element of the list
 
 
3.
 
What are the advantages and disadvantages of stack and queue 
implemented using linked list over array?
 
Advantages and disadvantages of stack & queue implemented using linked list over array is described below,
 
Insertion 
& Deletion Operation
 

 
Insertion and deletion operations are known as push and pop operation in stack and as insert and 
delete operation in queue.
 

 
In the case of an array, if we have n
-
elements list and it is required to insert a new element between 
the firs
t and second element then n
-
1 elements of the list must be moved so as to make room for 
the new element.
 

 
In case of linked
-
list, this can be accomplished by only interchanging pointers.
 

 
Thus, insertion and deletions are more efficient when performed in lin
ked list then array.
 

 
Linked List
 
 
Prof. Pradyumansinh Jadeja (9879461848)  | 
2130702 

 
Data Structure
 
5
 
 
Searching a node
 

 
If a particular node in a linked list is required, it is necessary to follow links from the first node 
onwards until the desired node is found.
 

 
Where as in the case of an array, directly we can access any node 
 
Join & 
Split
 

 
We can join two linked list by assigning pointer of second linked list in the last node of first linked 
list.
 

 
Just assign null address in the node from where we want to split one linked list in two parts.
 

 
Joining and splitting of two arrays is much m
ore difficult compared to linked list.
 
Memory
 

 
The pointers in linked list consume additional memory compared to an array
 
Size
 

 
Array is fixed sized so number of elements will be limited in stack and queue.
 

 
Size of linked list is dynamic and can be changed 
easily so it is flexible in number of elements
 
 
 
 
X
1
 
X
2
 
X
3
 
X
4
 
X
5
 
 
X
6
 
 
 
 
X
1
 
X
2
 
X
3
 
X
4
 
X
5
 
 
X
6
 
 
Y
 
 
Insert Y at location 2. You have to move X
2
, X
3

 
Array
 
X
1
 
 
 
X
2
 
 
 
X
3
 
 
 
X
4
 
 
 
X
1
 
 
 
X
2
 
 
 
X
3
 
 
 
X
4
 
 
 
Y
 
 
 
Linked
-
List
 
Insert Y at location 2. Just change two pointers
 
Insertion and deletion operations in Array and Linked
-
List
 

 
Linked List
 
 
Prof. Pradyumansinh Jadeja (9879461848)  | 
2130702 

 
Data Structure
 
6
 
 
4.
 
Write following algorithms for singly linked list.
 
1) Insert at first position
 
2) Insert at last position
 
3) Insert in Order
ed Linked list
 
4) Delete 
Element
 
5)
 
Copy Linked List
 
F
ew assumptions,
 

 
We
 
assume that a typical element or node consists of two fields namely; an information field 
called
 
INFO and pointer field denoted by LINK. The name of a typical element is denoted by NODE
.
 
 
 
 
 
Node
 
info
 
link
 
Data
 
Pointer to 
next node
 
// C Structure to represent a node
 
struct node
 
{
 
int info
 
struct node *link
 
};
 

 
Linked List
 
 
Prof. Pradyumansinh Jadeja (9879461848)  | 
2130702 

 
Data Structure
 
7
 
 
Function:
 
INSERT( X, First )
 
Given 
X
, a
 
new element
 
and FIRST
 
is
 
a pointer to the first element of a linked linear list
. Typical node contains 
INFO and LINK fields. AVAIL
 
is a pointer to the top element of the availab
ility s
tack; NEW is a temporary pointer 
variable. 
This function inserts a new node at the first position of linked list. This function returns address of 
FIRST node. 
 
 
 
 
1
 
[
Underflow?
]
 
IF 
 
AVAIL = NULL
 
Then
 

 
 
 
Return(FIRST)
 
 
2
 
[Obtain address of next free Node]
 
NEW

AVAIL
 
 
3
 
[Remove free node from Availability Stack]
 
AVAIL

LINK(AVAIL)
 
 
4
 
[Initialize fields of new node and its link to the list]
 
 
 
INFO (NEW) 

 
X
 
 
 
LINK (NEW) 

 
FIRST
 
5
 
[Return address of new node]
 
 
 
R
eturn 
(NEW)
 
When INSERT is invoked it returns a pointer value to the variable FIRST
 
FIRST 

 
INSERT (X, FIRST)
 
 

 
Linked List
 
 
Prof. Pradyumansinh Jadeja (9879461848)  | 
2130702 

 
Data Structure
 
8
 
 
Function
: 
 
INSEND( X, First ) (Insert at end)
 
Given 
X
, a
 
new element
 
and FIRST
 
is
 
a pointer to the first element of a linked linear list
. Typical node contains 
INFO and LINK fields. AVAIL
 
is a pointer to the top elemen
t of the availability s
tack; NEW is a temporary pointer 
variable. 
This function inserts a new node at the 
last
 
position of linked list. This function returns address of FIRST 
node.
 
 
 
 
1
 
[
Underflow?
]
 
IF 
 
AVAIL = NULL
 
Then
 


 
 
 
Return(FIRST)
 
 
2
 
[Obtain address of next free Node]
 
NEW

AVAIL
 
 
3
 
[Remove free node from Availability Stack]
 
AVAIL

LINK(AVAIL)
 
 
4
 
[Initialize field of NEW node]
 
INFO (NEW) 

 
X
 
LINK (NEW) 

 
NULL
 
 
5
 
[Is the list empty?]
 
If
 
FIRST = NULL
 
then
 
Return (NEW)
 
 
6
 
[Initialize search for a last node]
 
SAVE 

 
FIRST
 
 
7
 
[Search for end of list]
 

 
 
 
SAVE 

 
LINK (SAVE)
 
 
8
 
[Set link field of last node to NEW)
 
LINK (SAVE) 

 
NEW
 
 
9
 
[Return first node pointer]
 
Return (FIRST)
 
When 
INSERT
END
 
is invoked it
 
returns a pointer value to the variable FIRST
 
FIRST 

 
INSERT
END
 
(X, FIRST)
 
 

 
Linked List
 
 
Prof. Pradyumansinh Jadeja (9879461848)  | 
2130702 

 
Data Structure
 
9
 
 
Insert
 
a node
 
into Ordered Linked List
 

 
There are many applications where it is desirable to maintain an ordered linear list. The ordering is in 
increasing or decreasing order on INFO field. Such ordering results in 
more efficient processing.
 

 
The general algorithm for inserting a node into an ordered linear list is as below.
 
1.
 
Remove a node from availability stack.
 
2.
 
Set the field of new node.
 
3.
 
If the linked list is empty then return the address of new node.
 
4.
 
If node preced
es all other nodes in the list then inserts a node at the front of the list and returns its 
address.
 
5.
 
Repeat step 6 while information contain of the node in the list is less than the information content of 
the new node.
 
6.
 
Obtain the next node in the linked li
st.
 
7.
 
Insert the new node in the list and return address of its first node.
 
 
 
 

 
Linked List
 
 
Prof. Pradyumansinh Jadeja (9879461848)  | 
2130702 

 
Data Structure
 
10
 
 
Function:
 
INSORD( X, FIRST )
 
Given 
X
, a new element
 
and FIRST
 
is
 
a pointer to the first element of a linked linear list
. Typical node contains 
INFO and LINK fields. AVAIL
 
is a poi
nter to the top element of the availability s
tack; NEW 
& SAVE are
 
temporary 
pointer 
variable
s
. 
This function inserts a new node
 
such that linked list preserves the ordering of the terms in 
increasing order of their INFO field
. This function returns address
 
of FIRST node.
 
 
1
 
[
Underflow?
]
 
IF 
 
AVAIL = NULL
 
Then
 

 
 
 
Return(FIRST)
 
 
2
 
[Obtain address of next free Node]
 
NEW

AVAIL
 
 
3
 
[Remove free node from Availability Stack]
 
AVAIL

LINK(AVAIL)
 
 
4.
 
[Is the list is empty]
 
If
 
FIRST = 
NULL
 
then
 
LINK (NEW) 

 
NULL
 
R
eturn (NEW)
 
 
5.
 
[Does the new node precede all other node in the list?]
 
If
 

 
then
 
LINK (NEW) 

 
FIRST
 
R
eturn (NEW)
 
 
6.
 
[Initialize temporary pointer]
 
SAVE  

 
FIRST
 
 
7.
 
[Search for predecessor of new node]
 

 
 
 
SAVE 

 
LINK (SAVE)
 
 
8.
 
[Set link field of NEW node and its predecessor]
 
LINK (NEW) 

 
LINK (SAVE)
 
LINK (SAVE) 

 
NEW
 
 
9.
 
[Return first node pointer]
 
R
eturn (FIRST)
 
When INSERT
ORD
 
is invoked it returns a pointer value to the variable FIRST
 
FIRST 

 
INSERT
ORD
 
(X, FIRST)
 
 

 
Linked List
 
 
Prof. Pradyumansinh Jadeja (9879461848)  | 
2130702 

 
Data Structure
 
11
 
 
By repeatedly involving function 
INSORD;
 
we can easily obtains an ordered liner list for example the
 
sequence of 
statements. 
 
 
 
 
Algorithm to delete a node from Linked List
 

 
Algorithm that deletes node fr
om a linked linear list:
-
 
1.
 
If a linked list is empty, then write under flow and return.
 
2.
 
Repeat step 3 while end of the list has not been reached and the node has not been found.
 
3.
 
Obtain the next node in list and record its predecessor node.
 
4.
 
If the end of the
 
list has been reached then write node not found and return.
 
5.
 
Delete the node from list.
 
6.
 
Return the node into availability area.
 
 
 
29
 
10
 
29
 
10
 
25
 
29
 
10
 
25
 
29
 
40
 
10
 
25
 
29
 
37
 
40
 
FRONT
 
FRONT
 
FRONT
 
FRONT
 
FRONT
 
Trace of construction of 
an ordered linked linear list using function INSORD
 
FRONT 

 
NULL
 
FRONT 

 
INSORD (29, FRONT)
 
FRONT 

 
INSORD (10, FRONT)
 
FRONT 

 
INSORD (25, FRONT)
 
FRONT 

 
INSORD (40, FRONT)
 
FRONT 

 
INSORD (37, FRONT)
 

 
Linked List
 
 
Prof. Pradyumansinh Jadeja (9879461848)  | 
2130702 

 
Data Structure
 
12
 
 
Procedure:
 
DELETE( X, FIRST)
 
Given 
X
, an address of node which we want to delete
 
and FIRST
 
is
 
a pointer to the first element of a linked linear 
list
. 
Typical node contains INFO and LINK fields. SAVE & PRED are temporary pointer 
variables.
 
 
 
Function
:
 
COPY (FIRST)
 

 
FIRST is a pointer to the first node in the linked list, this function makes a copy of the list.
 

 
The new list is to contain nodes whose information and pointer fields are denoted by FIELD and PTR, 
respectively. The address of the first node in the newly created list is to be placed in BEGIN. NEW, SAVE and 
PRED are points variables.
 

 
A general algorithm to copy a linked list
 
1.
 
If the list is empty then return null
 
1.
 
[
Is 
Empty list?]
 
If
 
FIRST = NULL
 
then
 

 
return
 
 
2.
 
[Initialize search for X]
 
SAVE 

 
FIRST
 
 
3.
 
[Find X]
 
Repeat thru step
-

 
 
4.
 
[Update predecessor marker]
 
PRED 

 
SAVE
 
 
5.
 
[Move to next node]
 
SAVE 

 
LINK (SAVE)
 
 
6.
 
[End of the list]
 
If
 

 
then
 

 
return
 
 
7.
 
[Delete X]
 
If
 
X = FIRST (if X is first 
node?)
 
then
 
FIRST 

 
LINK (FIRST)
 
else
 
LINK (PRED) 

 
LINK (X)
 
 
8.
 
[
Free Deleted Node
]
 
Free (X)
 

 
Linked List
 
 
Prof. Pradyumansinh Jadeja (9879461848)  | 
2130702 

 
Data Structure
 
13
 
 
2.
 
If the availability stack is empty then
 
write availability stack underflow and return else copy the first 
node.
 
3.
 
Report thru step 5 while the old list has not been reached.
 
4.
 
Obtain next node in old list and record its predecessor node.
 
5.
 
If availability stack is empty then write availability stack 
underflow and return else copy the node and 
add it to the rear of new list.
 
6.
 
Set link of the last node in the new list to null and return.
 
 
 
1.
 
[
Is 
Empty List
?
]
 
If
 
FIRST = NULL
 
then
 
return (NULL)
 
 
2.
 
[Copy first node]
 
NEW    

    
NODE
 
New 

 
AVAIL
 
AVAIL 

 
LINK (AVAIL)
 
FIELD (NEW) 

 
INFO (FIRST)
 
BEGIN 

 
NEW
 
 
3.
 
[Initialize traversal]
 
SAVE 

 
FIRST
 
 
4.
 
[Move the next node if not at the end if list]
 

 
 
5.
 
[Update predecessor and save pointer]
 
PRED 

 
NEW
 
SAVE 

 
LINK (SAVE)
 
 
6.
 
[Copy nod
e]
 
If
 
AVAIL = NULL
 
then
 

 
R
eturn (0)
 
else
 
NEW 

 
AVAIL
 
 
AVAIL 

 
LINK (AVAIL)
 
 
FIELD (NEW) 

 
INFO (SAVE)
 
 
PTR (PRED) 

 
NEW
 
 
7.
 
[Set link of last node and return]
 
PTR (NEW) 

 
NULL
 
R
eturn (BEGIN) 
 

 
Linked List
 
 
Prof. Pradyumansinh Jadeja (9879461848)  | 
2130702 

 
Data Structure
 
14
 
 
5.
 
Write following algorithms for circular link list
 
1)
 
Insert at First Position
 
2)
 
Insert at Last Position
 
3)
 
Insert in Ordered Linked List
 
4)
 
Delete Element
 
 
PROCEDURE
: CIRCULAR_LINK_INSERT_FIRST (X, FIRST, LAST)
 
FIRST an
d LAST are
 
pointer
s
 
to the first and last element of a
 
circular
 
linked linear list respectively whose typical 
node contains INFO and LINK fields.
 
NEW is a temporary 
pointer
 
variable.
 
This procedure inserts value X at the 
first position of Circular linked l
inear list.
 
 
 
 
 
1.
 
[Create New Empty Node]
 
NEW    

    
NODE
 
 
2.
 
[Initialize fields of new node and its link to the list]
 
INFO (NEW)
 

 
X
 
If
 
FIRST = NULL
 
then
 
LINK
 
(NEW)
 

 
NEW
 
 
 
FIRST
 

 
LAST
 

 
NEW
 
else 
 
LINK
 
(NEW)
 

 
FIRST
 
 
 
LINK
 
(LAST)
 

 
NEW
 
 
 
FIRST
 

 
NEW
 
Return
 
 

 
Linked List
 
 
Prof. Pradyumansinh Jadeja (9879461848)  | 
2130702 

 
Data Structure
 
15
 
 
PROCEDURE
: CIR_LINK_INSERT_END (X, FIRST, LAST)
 
FIRST and LAST are
 
pointer
s
 
to the first and last element of a
 
circular
 
linked linear list respectively whose typical 
node contains INFO and LINK fields.
 
NEW is a temporary 
pointer
 
variable.
 
This procedure inserts value X at the 
last position of Circular linked linear list.
 
 
 
 
 
1.
 
[Create New Empty Node]
 
NEW    

    
NODE
 
 
2.
 
[Initialize fields of new node and its link to the list]
 
If
 
FIRST = NULL
 
then 
 
LINK
 
(NEW)
 

 
NEW
 
 
 
FIRST
 

 
LAST
 

 
NEW
 
else 
 
LINK(NEW)
 

 
FIRST
 
 
 
LINK(LAST)
 

 
NEW
 
 
 
LAST
 

 
NEW
 
Return
 

 
Linked List
 
 
Prof. Pradyumansinh Jadeja (9879461848)  | 
2130702 

 
Data Structure
 
16
 
 
PROCEDURE
: CIR_LINK_INSERT_ORDER (X, FIRST, LAST)
 
FIRST and LAST are
 
pointer
s
 
to the first and last element of a
 
circular
 
linked linear list respectivel
y whose typical 
node contains INFO and LINK fields.
 
NEW is a temporary 
pointer
 
variable.
 
This procedure inserts value X
 
such 
that linked list preserves the ordering of the terms in increasing order of their INFO field.
 
 
 
1.
 
[Create New Empty Node]
 
NEW    

    
NODE
 
 
 
2.
 
[Copy information content into new node]
 
INFO (NEW) 

 
X
 
 
3.
 
[Is Linked List is empty?]
 
If 
 
FIRST = NULL
 
then 
 
LINK (NEW) 

 
NEW
 
 
 
FIRST 

 
LAST 

 
NEW
 
 
 
Return
 
 
4.
 
[Does new node precedes all other nodes in List?]
 
If 
 

 
then 
 
LIN
K (NEW) 

 
FIRST
 
 
 
LINK (LAST) 

 
NEW
 
 
 
FIRST 

 
NEW
 
 
 
R
eturn
 
 
5.
 
[Initialize Temporary Pointer]
 
SAVE 

 
FIRST
 
 
6.
 
[Search for Predecessor of new node]
 

 
 
 
SAVE 

 
LINK(SAVE)
 
 
7.
 
[Set link field of NEW node and its
 
Predecessor]
 
LINK(NEW) 

 
LINK(SAVE)
 
LINK(SAVE) 

 
NEW
 
If
 
SAVE = LAST
 
then 
 
LAST 

 
NEW
 
 
8.
 
[
Finish
]
 
Return
 
 

 
Linked List
 
 
Prof. Pradyumansinh Jadeja (9879461848)  | 
2130702 

 
Data Structure
 
17
 
 
PROCEDURE: CIR_LINK_
D
ELETE (X, FIRST, LAST)
 
FIRST and LAST are
 
pointer
s
 
to the first and last element of a
 
circular
 
linked linear list respectively whose typical 
node contains INFO and LINK fields.
 
SAVE & PRED are
 
tempor
ary 
pointer
 
variable
s
.
 
This procedure deletes
 
a 
node whose address is given by pointer variable X.
 
 
 
1.
 
[
Is 
Empty List?]
 
If
 
FIRST = NULL
 
then
 

Linked List is Empty

 
 
 
R
eturn
 
 
2.
 
[Initialize Search for X]
 
SAVE
 

 
FIRST
 
 
3.
 
[Find X]
 
Repeat thru step 5 while 

 
 
4.
 
[Update predecessor marker]
 
PRED 

 
SAVE
 
 
5.
 
[Move to next node]
 
SAVE 

 
LINK (SAVE)
 
 
6.
 
[End of Linked List]
 
If 
 

 
then 
 

 
 
 
return
 
 
7.
 
[Delete X]
 
If
 
X = FIRST
 
then 
 
FIRST 

 
LINK (FIRST)
 
 
 
LINK (LAST) 

 
FIRST
 
else 
 
LINK (PRED) 

 
LINK(X)
 
 
 
If
 
X = LAST
 
 
 
then
 
LAST 

 
PRED
 
 
8.
 
[
Free Deleted Node
]
 
Free (X)
 

 
Linked List
 
 
Prof. Pradyumansinh Jadeja (9879461848)  | 
2130702 

 
Data Structure
 
18
 
 
6.
 
Write an algorithm to perform each
 
of the following operations on Circular 
singly linked list using header node
 
1)
 
add node at beginning
 
2)
 
add node at the end
 
3)
 
insert a node containing x after node having address P
 
4)
 
delete a node which contain element x
 
FUNCTION: CIR_LINK_HEAD_INSERT_
FIRST (X, FIRST, LAST)
 
FIRST and LAST are
 
pointer
s
 
to the first and last element of a
 
circular
 
linked linear list respectively whose typical 
node contains INFO and LINK fields.
 
NEW is a temporary 
pointer
 
variable.
 
HE
AD is the address of HEAD node.
 
This procedure inserts value X at the first position of Circular linked linear list.
 
 
 
FUNCTION: CIR_LINK_HEAD_INSERT_LAST (X, FIRST, LAST)
 
FIRST and LAST are
 
pointer
s
 
to the first and last element of a
 
circular
 
linked linear list respectively whose typical 
node contains INFO and LINK fields.
 
NEW is a temporary points variable.
 
HEAD is the address of HEAD node. This 
procedure inserts value X at the 
last
 
position of Circular linked linear list.
 
 
 
1.
 
[
Create New Emp
ty Node
]
 
NEW    

    
NODE
 
 
2.
 
[Initialize fields of new node and its link to the list]
 
INFO
 
(NEW)
 

 
X
 
LINK
 
(NEW)
 

 
HEAD
 
LINK
 
(LAST)
 

 
NEW
 
LAST 

 
NEW
 
1.
 
[
Create New Empty Node
]
 
NEW    

    
NODE
 
 
2.
 
[Initialize fields of new node and its link to the list]
 
INFO (NEW) 

 
X
 
LINK (NEW) 

 
LINK (HEAD)
 
LINK (HEAD) 

 
NEW
 

 
Linked List
 
 
Prof. Pradyumansinh Jadeja (9879461848)  | 
2130702 

 
Data Structure
 
19
 
 
FUNCTION: CIR_LINK_HEAD_INSERT_AFTER_Node
-
P (X, FIRST, LAST)
 
FIRST and LAST are
 
pointer
s
 
to the first and last element of a
 
circular
 
linked linear list re
spectively whose typical 
node contains INFO and LINK fields.
 
NEW is a temporary pointer
 
variable.
 
HEAD is the address of HEAD node. 
This procedure
 
insert a node after a node having address P
.
 
 
 
 
 
1.
 
[
Create New Empty Node
]
 
NEW    

    
NODE
 
 
2.
 
 
[Initialize field
s of new node and its link to the list]
 
INFO (NEW) 

 
X
 
LINK (NEW) 

 
LINK (P)
 
LINK (P) 

 
NEW
 
If 
 
P = LAST
 
then 
 
LAST 

 
NEW
 

 
Linked List
 
 
Prof. Pradyumansinh Jadeja (9879461848)  | 
2130702 

 
Data Structure
 
20
 
 
PROCEDURE: CIR_LINK_HEAD_DELETE (X, FIRST, LAST)
 
FIRST and LAST are
 
pointer
s
 
to the first and last element of a
 
circular
 
linked linear list respectively whose typical 
node contains INFO and LINK fields.
 
SAVE
 
& PRED
 
are temporary pointer
 
variable
s
.
 
HEAD is the address of HEAD 
node. This procedure 
deletes a node whose value is X
.
 
 
 
1.
 
[Is Empty List?]
 
If
 
FIRST = NULL
 
then
 

Underflow
)
 
 
 
return
 
 
2.
 
[Initialize Search for X]
 
SAVE 

 
FIRST
 
 
3.
 
 
[Find X]
 

 
 
4.
 
 
[Update Predecessor]
 
PRED 

 
SAVE
 
 
5.
 
 
[Move to next node]
 
SAVE
 

 
LINK(SAVE)
 
 
6.
 
 
[End of the List]
 
If
 
INFO
 

 
then
 
wr

 
 
 
return
 
 
7.
 
 
[Delete node X]
 
If
 
INFO (FIRST) = X
 
then
 
LINK (HEAD) 

 
LINK(FIRST)
 
else
 
LINK (PRED) 

 
LINK(SAVE)
 
 
 
If
 
SAVE = LAST
 
 
 
then 
 
LAST 

 
PRED
 
 
8.
 
 
[
Free Deleted Node
]
 
Free (X)
 

 
Linked List
 
 
Prof. Pradyumansinh Jadeja (9879461848)  | 
2130702 

 
Data Structure
 
21
 
 
7.
 
Write following algorithms for doubly link list
 
1) Insert 
 
2) Insert in Ordered Linked List
 
3) Delete Element 
 
PRDCEDURE:
 
DOUBINS (L, R, M, X)
 
Given a 
doubly link list whose left most and right most nodes addressed are given by the pointer variables L and 
R respectively. It is required to insert a node whose address is given by the pointer variable NEW. The left and 
right links of nodes are denoted by LP
TR and RPTR respectively. The information field of a node is denoted by 
variable INFO. The name of an element of the list is NODE. The insertion is to be performed to the left of a 
specific node with its address given by the pointer variable M. The informa
tion to be entered in the node is 
contained in X.
 
 
1.
 
[
Create New Empty Node
]
 
NEW          NODE
 
 
2.
 
[Copy information field]
 
INFO (NEW) 

 
X
 
 
3.
 
 
[Insert into an empty list]
 
If
 
 
R = NULL
 
then 
 
LPTR  (NEW) 

 
RPTR (NULL) 

 
NULL
 
 
L 

 
R 

 
NEW
 
 
R
eturn
 
 
4.
 
[Is left most 
insertion ?]
 
If 
 
M = L
 
then 
 
LPTR (NEW) 

NULL
 
 
RPTR (NEW) 

 
M
 
 
LPTR (M)

 
NEW
 
 
L 

 
NEW
 
 
R
eturn
 
 
5.
 
 
[Insert in middle]
 
LPTR (NEW)

 
LPTR (M)
 
RPTR (NEW) 

 
M
 
LPTR (M) 

 
NEW
 
RPTR (LPTR (NEW)) 

 
NEW
 
R
eturn
 
 

 
Linked List
 
 
Prof. Pradyumansinh Jadeja (9879461848)  | 
2130702 

 
Data Structure
 
22
 
 
PROCEDURE: 
DOUBINS_ORD (L, R, M, X)
 
Given a doubly link list whose left most and right most nodes addressed are given by the pointer variables L and 
R respectively. It is required to insert a node whose address is given by the pointer variable NEW.
 
The left and 
right links of nodes are denoted by LPTR and RPTR respectively. The information field of a node is denoted by 
variable INFO. The name of an element of the list is NODE. The insertion is to be performed in ascending order 
of info part. The inf
ormation to be entered in the node is contained in X.
 
 
1.
 
[
Create New Empty Node
]
 
NEW          NODE
 
 
2.
 
[ Copy information field]
 
INFO (NEW) 

 
X
 
 
3.
 
 
[Insert into an empty list
]
 
If
 
 
 
R = NULL
 
then
 
LPTR (NEW) 

 
RPTR (NULL) 

 
NULL
 
 
 
 
L 

 
R 

 
NEW
 
 
 
 
return
 
 
4.
 
 
[Does the new node precedes all other nodes in List? ]
 
If
 
 

 
then 
 
RPTR (NEW) 

 
L
 
 
 
 
LPTR(NEW)

 
NULL
 
 
 
 
LPTR (L) 

 
NEW
 
 
 
 
L 

 
NEW
 
 
 
 
R
eturn
 
 
5.
 
 
[ Initialize 
temporary
 
Pointer]
 
SAVE 

 
L
 
 
6.
 
 
[Search for predecessor of New node]
 
Repeat while RP

 
 
 
SAVE 

 
RPTR (SAVE)
 
 
7.
 
 
[Set link field of new node and its predecessor]
 
RPTR (NEW) 

 
RPTR(SAVE)
 
LPTR (RPTR(SAVE)) 

 
NEW
 
RPTR (SAVE) 

 
NEW
 
LPTR (NEW) 

 
SAVE
 
 
If
 
 
SAVE = R
 
then 
 
RPTR(SAVE) 

 
NEW
 

 
Linked List
 
 
Prof. Pradyumansinh Jadeja (9879461848)  | 
2130702 

 
Data Structure
 
23
 
 
PROCEDURE:
 
DOUBDEL (L, R, OLD)
 
Given a doubly linked list with the addresses of left most and right most nodes are given by the pointer variables 
L and R respectively. It is required to delete the node whose address 
is
 
contained in the variable OLD. Node 
contains left and right links wi
th names LPTR and RPTR respectively.
 
 
 
1.
 
[ Is underflow ?]
 
If 
 
R=NULL
 
then 
 

 
 
 
return
 
 
2.
 
 
[Delete node]
 
If 
 
L = R (single node in list)
 
then
 
L 

 
R 

 
NULL
 
else
 
If 
 
OLD = L (left most node)
 
 
then
 
L 

 
RPTR(L)
 
 
 
LPTR (L) 

 
NULL
 
 
else
 
if
 
OLD =
 
R (right most)
 
 
 
then
 
R 

 
LPTR (R)
 
 
 
 
RPTR (R) 

 
NULL
 
 
 
else
 
RPTR  (LPTR (OLD)) 

 
RPTR (OLD)
 
 
 
 
LPTR  (RPTR (OLD)) 

 
LPTR (OLD)
 
 
3.
 
[ 
FREE
 
deleted node]
 
FREE
 
(OLD)
 

 
Linked List
 
 
Prof. Pradyumansinh Jadeja (9879461848)  | 
2130702 

 
Data Structure
 
24
 
 
8.
 
Write the implementation procedure of basic primitive operations of the 
stack using: (i) Linear array  (ii) linked list.
 
 
 
Implement PUSH and POP using 
Linear array
 
#define 
MAXSIZE
 
100
 
int stack[
MAXSIZE
];
 
int 
top=
-
1
;
 
 
void push(int val)
 
{
 
if(top
 
>
=
 
MAXSIZE
)
 
printf("Stack is Overflow");
 
else
 
stack[
++
top]
 
=
 
val;
 
}
 
 
int pop()
 
{
 
int a;
 
if(top>
=
0)
 
{
 
a=stack[top];
 
top

-
;
 
return a;
 
}
 
else
 
{
 
printf("Stack is 
Underflow, Stack is empty, nothing to POP!");
 
return 
-
1;
 
}
 
}
 
 

 
Linked List
 
 
Prof. Pradyumansinh Jadeja (9879461848)  | 
2130702 

 
Data Structure
 
25
 
 
 
 
9.
 
Write the implementation procedure of basic primitive operations of the 
Queue using: (i) Linear 
arra
y (
ii) linked list
 
 
Implement PUSH and POP using Linked List
 
#include<stdio.h>
 
#include<malloc.h>
 
 
struct node
 
{
 
    
int info;
 
    
struct node *
link
;
 
} *
top
;
 
 
void 
push
(int 
val
)
 
{
 
struct node *p;
 
    
 
p = (struct 
node*)malloc(sizeof(struct node));
 
    
 
p 

 
info = 
val
;
 
    
 
p 

 
link
 
= 
top
;
 
 
top
 
= p;
 
 
return;
 
}
 
 
int pop()
 
{
 
 
int val;
 
if(top!=NULL)
 
{
 
 
val = 
top
 

 
info
;
 
top=top
 

link;
 
return val;
 
}
 
else
 
{
 
printf("
Stack Underflow");    
 
return 
-
1;
 
}
 
}
 
 

 
Linked List
 
 
Prof. Pradyumansinh Jadeja (9879461848)  | 
2130702 

 
Data Structure
 
26
 
 
 
Implement Enqueue(Insert)and Dequeue(Delete)using Linear Array
 
# include <stdio.h>
 
# define 
MAXS
IZE
 
10
0
 
int 
queue
[
MAXSIZE
], front = 
-
1, rear = 
-
1;
 
void enqueue(
int 
val
)
 
{
 
 
if(rear >=
 
MAXSIZE
)
 
 
{
 
 
 
printf("Queue is overflow") ;
 
 
 
return ;
 
 
}
 
 
rear++;
 
queue
 
[rear]
 
= 
val
;
 
 
if(front == 
-
1)
 
 
{
 
 
 
front++;
 
 
}
 
}
 
int
 
dequeue()
 
{
 
 
int data;
 
 
if(front == 
-
1)
 
 
{
 
 
 
printf("Queue is underflow") ;
 
 
 
return
 
-
1
;
 
 
}
 
 
data =
 
queue
 
[front];
 
 
if(front == rear)
 
 
{
 
 
 
front = rear = 
-
1;
 
 
}
 
 
else
 
 
{
 
 
 
front++;
 
 
}
 
return data;
 
}
 

 
Linked List
 
 
Prof. Pradyumansinh Jadeja (9879461848)  | 
2130702 

 
Data Structure
 
27
 
 
 
Implement Enqueue(Insert)and Dequeue(Delete)using Linked List
 
#include<stdio.h>
 
#include<malloc.h>
 
 
struct node
 
{
 
    
int info;
 
    
struct node *
link
;
 
} *front, *rear;
 
 
 
void enqueue(int 
val
)
 
{
 
struct node *p;
 
    
 
p
 
= (struct node*)malloc(sizeof(struct node));
 
p 

 
info = 
val
;
 
p 

 
link
 
= NULL;
 
if (rear == NULL || front == NULL)
 
    
 
{
 
 
 
 
front = p;
 
 
 
}
 
else
 
 
 
{
 
 
 
rear
 

 
link
 
= p;
 
 
rear = p;
 
 
 
}
 
}
 
 
int dequeue()
 
{
 
    
struct node *p;
 
    
int 
val
;
 
    
if (front == NULL || rear == NULL)
 
    
{
 
        
printf("
Under Flow");
 
        
exit(0);
 
    
}
 
    
else
 
    
{
 
        
p = front;
 
        
val
 
= p
 

 
info;
 
        
front = front
 

 
link
;
 
        
free(p);
 
    
}
 
    
return (
val
);
 
}
 

 
Linked List
 
 
Prof. Pradyumansinh Jadeja (9879461848)  | 
2130702 

 
Data Structure
 
28
 
 
10.
 
Write an algorithm to implement ascending priority queue using 
singular linear linked list which has insert() function such that queue 
remains ordered list. Also implement remove() function
 
 
 
remove()
 
{
 
 
struct node *tmp;
 
 
if(front == NULL)
 
 
 
printf("Queue Underflow
\
n");
 
 
else
 
 
{
 
 
 
tmp = front;
 
 
 
printf("Deleted item is 
%d
\
n",tmp
-
>info);
 
 
 
front = front
-
>link;
 
 
 
free(tmp);
 
 
}
 
}/*End of remove()*/
 
 
 
struct node
 
{
 
 
int 
priority;
 
 
int info;
 
 
struct node *link;
 
}*front = NULL;
 
 

 
Linked List
 
 
Prof. Pradyumansinh Jadeja (9879461848)  | 
2130702 

 
Data Structure
 
29
 
 
 
insert()
 
{
 
 
struct node *tmp,*q;
 
 
int added_item,item_priority;
 
 
tmp = (struct node *)malloc(sizeof(struct node));
 
 
printf("Input the item value to be added in the queue : ");
 
 
scanf("%d",&added_item);
 
 
printf("Enter
 
its priority : ");
 
 
scanf("%d",&item_priority);
 
 
tmp
-
>info = added_item;
 
 
tmp
-
>priority = item_priority;
 
 
/*Queue is empty or item to be added has priority more than 
first item*/
 
 
if( front == NULL || item_priority < front
-
>priority )
 
 
{
 
 
 
tmp
-
>link = fro
nt;
 
 
 
front = tmp;
 
 
}
 
 
else
 
 
{
 
 
 
q = front;
 
 
 
while( q
-
>link != NULL && 
 
q
-
>link
-
>priority <= item_priority )
 
 
 
{
 
 
 
 
q=q
-
>link;
 
}
 
 
 
tmp
-
>link = q
-
>link;
 
 
 
q
-
>link = tmp;
 
 
}/*End of else*/
 
}/*End of insert()*/
 

 
Linked List
 
 
Prof. Pradyumansinh Jadeja (9879461848)  | 
2130702 

 
Data Structure
 
30
 
 
 
 
display()
 
{
 
 
struct node *ptr;
 
 
ptr = front;
 
 
if(front == NULL)
 
 
 
printf("Queue is empty
\
n");
 
 
else
 
 
{ 
 
 
 
printf("Queue is :
\
n");
 
 
 
printf("Priority Item
\
n");
 
 
 
while(ptr != NULL)
 
 
 
{
 
 
 
 
printf("%5d %5d
\
n",ptr
-
>
priority,ptr
-
>info);
 
 
 
 
ptr = ptr
-
>link;
 
 
 
}
 
 
}/*End of else */
 
}/*End of display() */
 

 
Nonlinear Data Structure (Graph & Tree)
 
 
Prof. Pradyumansinh Jadeja (9879461848)  | 
2130702 

 
Data Structure
 
1
 
 
1.
 
Discuss following
 
1.
 
Graph
 

 
A graph G consist of a 
non
-
empty
 
set V called the set of nodes (points, vertices) of the 
graph, a set E which is the set of edges and a mapping from the set of 
edges E to a set of 
pairs of elements of V.
 

 
It is also convenient to write a graph as G=(V,E).
 

 
Notice that definition of graph implies that to every edge of a graph G, we can associate a 

a pair of nodes (
u
,
v
) 
where 
u
, 
v
 

u
 
and 
v
. 
 
2.
 
Adjacent Nodes
 

 
Any two nodes which are connected by an edge in a graph are called adjacent node.
 
3.
 
Directed & Undirected Edge
 

 
In a graph G=(V,E) an edge which is directed from on
e end to another end is called a 
directed edge, while the edge which has no specific direction is called undirected edge.
 
4.
 
Directed graph (Digraph)
 

 
A graph in which every edge is directed is called directed graph or digraph.
 
5.
 
Undirected graph
 

 
A graph in whic
h every edge is undirected is called 
un
directed graph
.
 
6.
 
Mixed Graph
 

 
If some of the edges are directed and some are undirected in graph then the graph is called 
mixed graph.
 
7.
 
Loop (Sling)
 

 
An edge of a graph which joins a node to itself is called a 
loop (sling).
 
8.
 
Parallel Edges
 

 
In some directed as well as undirected graphs, we may have certain
 
p
airs of nodes joined by 
more th
a
n one edge
s
, such edges are 
called Par
a
l
lel
 
edges.
 
9.
 
Multigraph
 

 
Any graph which contains some parallel edges is called multigraph.
 
10.
 
Weighted Graph
 

 
A graph in which weights are assigned to every edge is called weighted graph.
 

 
Nonlinear Data Structure (Graph & Tree)
 
 
Prof. Pradyumansinh Jadeja (9879461848)  | 
2130702 

 
Data Structure
 
2
 
 
11.
 
Isolated Node
 

 
In a graph a node which is not adjacent to any other node
 
is called isolated node.
 
12.
 
Null Graph
 

 
A graph containing only isolated nodes are called null graph. In other words set of edges in 
null graph is empty.
 
13.
 
Path of Graph
 

 
Let G=(V, E) be a simple digraph such that the terminal node of any  edge in the sequence i
s 
the initial node of the edge, if any appearing next in the sequence defined as path of the 
graph.
 
14.
 
Length of Path
 

 
The number of edges appearing in the sequence of the path is called length of path.
 
15.
 
Degree of vertex
 

 
The no of edges which have V as their te
rminal node is call as indegree of node V
 

 
The no of edges which have V as their initial node is call as outdegree of node V
 

 
Sum of indegree and outdegree of node V is called its Total Degree or Degree of vertex.
 
16.
 
Simple Path (Edge Simple)
 

 
A path in a diagra
ph in which the edges are distinct is called simple path or edge simple.
 
17.
 
Elementary Path (Node Simple)
 

 
A path in which all the nodes through which it traverses are distinct is called elementary 
path.
 
18.
 
Cycle (Circuit)
 

 
A path which originates and ends in the 
same node is called cycle (circuit).
 
19.
 
Directed Tree
 

 
A directed tree is an acyclic digraph which has one node called its root with in degree 0, 
while all other nodes have in degree 1.
 

 
Every directed tree must have at least one node.
 

 
An isolated node is also 
a directed tree.
 
20.
 
Terminal Node (Leaf Node)
 

 
In a directed tree, any node which has out degree 
0 is called terminal node or le
a
f
 
node.
 
21.
 
Level of Node
 

 
The level of any node is the length of its path from the root.
 

 
Nonlinear Data Structure (Graph & Tree)
 
 
Prof. Pradyumansinh Jadeja (9879461848)  | 
2130702 

 
Data Structure
 
3
 
 
22.
 
Ordered Tree
 

 
In a directed tree an ordering of
 
the nodes at each level is prescribed then such a tree is 
called ordered tree.
 
23.
 
Forest
 

 
If we delete the root and its edges connecting the nodes at level 1, we obtain a set of 
disjoint tree. A set of disjoint tree is a forest.
 
24.
 
M
-
ary Tree
 

 
If in a directed tr
ee the out degree of every node is less than or equal to m then tree is 
called an m
-
ary tree.
 
25.
 
Full or Complete M
-
ary Tree
 

 
If the out degree of each and every node is exactly equal to m or 0 and their number of 
nodes at level 
i
 
is 
m
(i
-
1)
 
then the tree is ca
lled a full or comple
te
 
m
-
ary tree.
 
26.
 
Positional M
-
ary Tree
 

 
If we consider m
-
ary trees in which the m children of any node are assumed to have m 
distinct positions, if such positions are taken into account, then tree is called positional m
-
ary tree.
 
27.
 
Height of
 
the tree
 

 
T
he height of a tree is the length of the path from the root to the deepest node in the tree.
 
28.
 
Binary tree
 

 
If in a directed tree the out degree of every node is less than or equal to 2 then tree is called 
binary tree.
 
29.
 
Strictly binary tree
 

 
A 
strict
ly binary tree (sometimes proper binary tree or 2
-
tree or full binary tree) is a tree in 
which every node other than the leaves has two children.
 
30.
 
Complete binary tree
 

 
If the out degree of each and every node is exactly equal to 2 or 0 and their number of 
n
odes at level 
i
 
is 
2
(i
-
1)
 
then the tree is called a full or complete binary tree.
 
31.
 
Sibling
 

 
Siblings are nodes that share the same parent node.
 
32.
 
Binary search tree
 

 
A binary search tree is a binary tree  in which each node possessed a key that satisfy the 
following conditions
 

 
Nonlinear Data Structure (Graph & Tree)
 
 
Prof. Pradyumansinh Jadeja (9879461848)  | 
2130702 

 
Data Structure
 
4
 
 
1.
 
All key (if any) in the left sub tree of the root precedes the key in the root.
 
2.
 
The key in the root precedes all key (if any) in the right sub tree.
 
3.
 
The left and right sub tree sub trees of the root are again search trees.
 
33.
 
Height 
Balanced Binary tree (AVL Tree)
 

 
A tree is called AVL (height balance binary tree), if each node possesses one of the following 
properties
 
1.
 
A node is called left heavy if the longest path in its left sub tree is one longer then 
the longest path of its right 
sub tree.
 
2.
 
A node is called right heavy if the longest path in the right sub tree is one longer 
than path in its left sub tree.
 
3.
 
A node is called balanced, if the longest path in both the right and left sub tree are 
equal.
 
 
2.
 
Explain the Preorder, Inorder and Postorder traversal techniques of the 
binary tree with suitable example.
 

 
The most common operations performed on tree structure is that of traversal. This is a procedure by 
which each node i
n the tree is processed exactly once in a systematic manner.
 

 
There are three ways of traversing a binary tree.
 
1.
 
Preorder Traversal
 
2.
 
Inorder Traversal
 
3.
 
Postorder Traversal
 
 
 
 
A
 
B
 
C
 
E
 
D
 
G
 
F
 
Fig. 
1.1
 
Preorder traversal : A  B  C  D  E  F  G
 
Inorder traversal : C  B  A  E  F  D  G
 
Postorder traversal : C  B  F  E  G  D  A
 
Converse Preorder traversal :
 
A  D  G  E  F  B  C
 
Converse Inorder traversal :
 
G  D  F  E  A  B  C
 
Converse Postorder traversal :
 
G  F  E  D  C  B  A
 

 
Nonlinear Data Structure (Graph & Tree)
 
 
Prof. Pradyumansinh Jadeja (9879461848)  | 
2130702 

 
Data Structure
 
5
 
 
Preorder
 

 
Preorder traversal of a binary tree is defined as follow
 
o
 
Process the root node
 
o
 
Traverse the left subtree in preorder
 
o
 
Traverse the right 
subtree in preorder
 

 
If particular subtree is empty (i.e., node has no left or right descendant) the traversal is performed by 
doing nothing, In other words, a null subtree is considered to be fully traversed when it is encountered.
 

 
The preorder traversal of a tree (Fig. 1.1) is given by A  B  C  D  E  F  G
 
Inorder
 

 
The Inorder traversal of a binary tree is given by follo
wing steps,
 
o
 
Traverse the left subtree in Inorder
 
o
 
Process the root node
 
o
 
Traverse the right subtree in Inorder
 

 
The Inorder traversal of a tree (Fig. 1.1) is given by C  B  A  E  F  D  G
 
Postorder
 

 
The postorder traversal is given by
 
o
 
Traverse the left subtree 
in postorder
 
o
 
Traverse the right subtree in postorder
 
o
 
Process the root node
 

 
The Postorder traversal of a tree (Fig. 1.1) is given by  C  B  F  E  G  D  A
 

 

 
If we interchange left and right words in the preceding definitions, we obtain three new tra
versal orders 
which are called
 
o
 
Converse Preorder (A  D  G  E  F  B  C) 
 
o
 
Converse Inorder (G  D  F  E  A  B  C)
 
o
 
Converse Postorder (G  F  E  D  C  B  A)
 
 
3.
 
Write the algorithm of Preorder, Inorder and Postorder traversal 
techniques of the binary tree.
 
Procedure : RPREORDER(T)
 

 
Given a binary tree whose root node address is given by pointer variable T and whose node structure
 
is 
same as described below. 
 
This procedure traverses
 
the tree in preorder, in a recursive manner.
 

 
Nonlinear Data Structure (Graph & Tree)
 
 
Prof. Pradyumansinh Jadeja (9879461848)  | 
2130702 

 
Data Structure
 
6
 
 
 
Procedure : RINORDER(T)
 

 
Given a binary tree whose root node address is given by pointer variable T and whose node structure is 
same as described below. 
This procedure traverses
 
the tree in inorder, in a recursive manner.
 
 
1.
 
[Check for empty Tree]
 
If 
 
T = NULL
 
then
 

 
 
 
return
 
 
2.
 
[Process the Left Subtree]
 
If 
 

 
then 
 
RINORDER (LPTR (T))
 
 
3.
 
[Process the root node]
 
write (DATA(T))
 
 
4.
 
 
[Process the Right Subtree]
 
If 
 

 
then 
 
RINORDER (
RPTR (T))
 
 
 
5.
 
 
[Finished]
 
return
 
1.
 
[Check for empty Tree]
 
If 
 
T = NULL
 
then
 

 
 
 
return
 
e
lse
 
write (DATA(T))
 
 
2.
 
[Process the Left Subtree]
 
If 
 

 
then 
 
RPREORDER (LPTR (T))
 
 
3.
 
 
[Process the Right Subtree]
 
If 
 

 
then 
 
RPREORDER (RPTR (T))
 
 
4.
 
[Fini
shed]
 
return
 
LPTR
 
DATA
 
RPTR
 

 
Nonlinear Data Structure (Graph & Tree)
 
 
Prof. Pradyumansinh Jadeja (9879461848)  | 
2130702 

 
Data Structure
 
7
 
 
Procedure : RPOSTORDER(T)
 

 
Given a binary tree whose root node address is given by pointer variable T and whose node structure is 
same as described below. 
This procedure traverses
 
the tree in postorder, in a recursive manner.
 
 
 
4.
 
Give traversa
l order of following tree into Inorder, Preorder and P
ostorder.
 
 
 
1
 
2
 
3
 
4
 
5
 
Inorder: 
2 1 4 5 3
 
Preorder:
 
1 2 3 4 5
 
Post 
order:
 
2 5 4 3 1
 
 
1.
 
[Check for empty Tree]
 
If 
 
T = NULL
 
then
 

 
 
 
return
 
 
2.
 
[Process the Left Subtree]
 
If 
 

 
then 
 
RPOSTORDER (LPTR (T))
 
 
3.
 
 
[Process the Right Subtree]
 
If 
 
RPTR (T

 
then 
 
RPOSTORDER (RPTR (T))
 
 
4.
 
 
[Process the root node]
 
write (DATA(T))
 
 
5.
 
 
[Finished]
 
return
 

 
Nonlinear Data Structure (Graph & Tree)
 
 
Prof. Pradyumansinh Jadeja (9879461848)  | 
2130702 

 
Data Structure
 
8
 
 
5.
 
Construct a tree f
or the given Inorder and P
ostorder traversals
 
 
 
 
A
 
D
 
A
 
B
 
C
 
D  G  B
 
H  E  I  C  F
 
G
 
H
 
F
 
H  E  I
 
D  G
 
A
 
B
 
C
 
F
 
I
 
E
 
Inorder 
   
: 
D
 
G
 
B
 
A
 
H
 
E
 
I
 
C
 
F
 
Postorder 
: 
G
 
D
 
B
 
H
 
I
 
E
 
F
 
C
 
A
 
 

 
Nonlinear Data Structure (Graph & Tree)
 
 
Prof. Pradyumansinh Jadeja (9879461848)  | 
2130702 

 
Data Structure
 
9
 
 
 
 
A
 
C
 
A
 
B
 
D
 
B  C
 
E  D  G  H  F  I
 
E
 
G  H  F  I
 
A
 
B
 
D
 
F
 
E
 
Postorder : C B E H G I F D A
 
Inorder    : B C A E D G H F I
 
 
C
 
I
 
G  H 
 
C
 
A
 
B
 
D
 
F
 
E
 
I
 
G
 
H
 

 
Nonlinear Data Structure (Graph & Tree)
 
 
Prof. Pradyumansinh Jadeja (9879461848)  | 
2130702 

 
Data Structure
 
10
 
 
6.
 
Constr
uct a tree for the given Inorder and P
reorder traversals
 
 
G
 
G
 
B
 
P
 
Q  B  K 
 
C  F  A
 
P  E  D  H  R
 
D  E  R  H
 
Pre
order
 
: G B Q A C K F P D  E R H
 
Inorder   : Q B K C F A G P E D  H R
 
Q
 
K  C  F  A
 
G
 
B
 
P
 
R  H
 
Q
 
K  C  F 
 
A
 
D
 
E
 
G
 
B
 
P
 
Q
 
A
 
D
 
E
 
F
 
C
 
K
 
R
 
H
 

 
Nonlinear Data Structure (Graph & Tree)
 
 
Prof. Pradyumansinh Jadeja (9879461848)  | 
2130702 

 
Data Structure
 
11
 
 
7.
 
Create a binary search tree for the following data : 
 
50 ,25 ,75, 22,40,60,80,90,15,30
 
 
 
8.
 
Construct binary search tree for the following data and find its Inorder, 
Preorder and Postorder traversal
 
10,3,15,22,6,45,65,23,78,34,5
 
 
10
 
3
 
15
 
6
 
22
 
5
 
45
 
65
 
34
 
23
 
78
 
Preorder  :
 
10, 3, 6, 5, 15, 22, 45, 23, 34, 65, 78
 
Inorder     :
 
3, 5, 6, 10, 15, 22, 23, 34, 45, 65, 78
 
Postorder :
 
5, 6, 3, 34, 23, 78, 65, 45, 22, 15, 10
 
50
 
25
 
75
 
22
 
40
 
80
 
60
 
30
 
15
 
90
 

 
Nonlinear Data Structure (Graph & Tree)
 
 
Prof. Pradyumansinh Jadeja (9879461848)  | 
2130702 

 
Data Structure
 
12
 
 
9.
 
Write a short note on threaded binary tree
 

 
The wasted NULL links in the binary tree storage representation can be replaced by threads.
 

 
A binary tree is threaded according to particular traversal order. e.g.: Threads for 
the inorder traversals 
of tree are pointers to its higher nodes, for this traversal order.
 
o
 
If left link of node P is null, then this link is replaced by the address of its predecessor.
 
o
 
If right link of node P is null, then it is replaced by the address of 
its successor
 

 
Because the left or right link of a node can denote either structural link or a thread, we must somehow 
be able to distinguish them.
 

 
Method 1:
-
 
Represent thread a 

ve address.
 

 
Method 2:
-
 
To have a separ
ate Boolean flag for each of le
f
t
 
and ri
ght pointers, node structure for this is 
given below,
 
LPTR
 
LTHREAD
 
Data
 
RTHREAD
 
RPTR
 
Alternate node for threaded binary tree.
 

 
LTHREAD = true = Denotes leaf thread link
 

 
LTHREAD = false = Denotes leaf structural link
 

 
RTHREAD = true = Denotes right threaded 
link
 

 
RTHREAD = false = Denotes right structural link
 
 

 
Head node is simply another node which serves as the predecessor and successor of first and last tree 
nodes. Tree is attached to the left branch of the head node
 
Head
 
 
Advantages
 

 
Inorder traversal 
is
 
faster than unthreaded version as 
s
tack is not required.
 

 
Effectively determines the predecessor and successor for inorder traversal, for unthreaded tree this task is 
more difficult.
 

 
A stack is required to provide upward pointing information in tree which th
reading provides.
 

 
It is possible to generate successor or predecessor of any node
 
without having over head of st
a
ck with the 
help of threading.
 
Disadvantages
 

 
Threaded trees are unable to share common subtrees
 

 
Nonlinear Data Structure (Graph & Tree)
 
 
Prof. Pradyumansinh Jadeja (9879461848)  | 
2130702 

 
Data Structure
 
13
 
 

 
If 

ve addressing is not permitted in 
programming language, two additional fields are required.
 

 
Insertion into and deletion from threaded binary tree are more time consuming because both thread and 
structural link must be maintained.
 
 
 
A
 
B
 
C
 
D
 
E
 
F
 
G
 
Fully In
-
t
hreaded 
binary tree of 
given binary tree
 
HEAD
 
A
 
B
 
D
 
F
 
C
 
E
 
G
 
Binary Tree
 
Inorder Traversal  C  B  A  E  F  D  G
 

 
Nonlinear Data Structure (Graph & Tree)
 
 
Prof. Pradyumansinh Jadeja (9879461848)  | 
2130702 

 
Data Structure
 
14
 
 
 
10.
 
Draw a right in threaded binary tree for the given tree
 
 
 
 
 
A
 
B
 
C
 
E
 
F
 
G
 
H
 
Right In
-
t
hreaded 
binary tree of 
given binary tree
 
HEAD
 
D
 

 
Nonlinear Data Structure (Graph & Tree)
 
 
Prof. Pradyumansinh Jadeja (9879461848)  | 
2130702 

 
Data Structure
 
15
 
 
11.
 
What is the meaning of height balanced tree? How rebalancing is done in 
height balanced tree
.
 
A tree is called AVL (height balance binary tree), if each node possesses one of the following properties
 
1.
 
A node is called l
eft heavy if the longest path in its left sub tree is one longer then the longest path of its 
right sub tree.
 
2.
 
A node is called right heavy if the longest path in the right sub tree is one longer than path in its left sub 
tree.
 
3.
 
A node is called balanced, if
 
the longest path in both the right and left sub tree are equal.
 
If tree becomes unbalanced by inserting any node, then based on position of insertion, we need to rotate the 
unbalanced node. Rotation is the process to make tree balanced
 
1)
 
Insertion into Left
 
sub
-
tree of nodes Left child 

 
Single Right Rotation
 
2)
 
Insertion into Right sub
-


 
Left Right Rotation
 
3)
 
Insertion into Left sub
-


 
Right Left Rotation
 
4)
 
Insertion into Right sub
-


 
Si
ngle Left Rotation
 
1)
 
Insertion into Left sub
-
tree of nodes Left child 

 
Single Right Rotation
 
If node becomes unbalanced after insertion of new node at 
Left sub
-
tree of nodes Left child
, then we need 
to perform 
Single Right Rotation
 
for unbalanced node.
 
Righ
t Rotation
 
a.
 

-
tree
 
b.
 
Consider
 
leaf child to be the new parent
 
c.
 
Attach old parent onto right of new parent
 
d.
 

-
tree as leaf sub
-
tree of new right child
 
 
 
J
 
K
 
Z
 
X
 
Y
 
N
 
K
 
X
 
J
 
N
 
Z
 
Y
 
Right 
Rotation
 
Critical Node
 

 
Nonlinear Data Structure (Graph & Tree)
 
 
Prof. Pradyumansinh Jadeja (9879461848)  | 
2130702 

 
Data Structure
 
16
 
 
 
2)
 
Insertion into Right sub
-


 
Left Right Rotation
 
If node becomes unbalanced after insertion of new node at 
Right sub
-

, then we need 
to perform 
Left Right Rotation
 
for unbalanced node.
 
Leaf rotation 
of
 
leaf child follo
wed by right rotation of parent
 
 
3)
 
Insertion into Left sub
-


 
Right Left Rotation
 
If node becomes unbalanced after insertion of new node at 
Left sub
-

, then we 
need to perform 
Right Left Rotation
 
for unba
lanced node.
 
 
Single right rotation of right child foll
owed by left rotation of parent
 
J
 
K
 
Z
 
X
 
Y
 
n
 
X
 
K
 
n
 
Z
 
Y
 
J
 
X
 
n
 
Z
 
K
 
J
 
Y
 
Left
 
Rotation of K
 
Right
 
Rotation of J
 
13
 
5
 
10
 
7
 
15
 
3
 
7
 
3
 
15
 
5
 
13
 
10
 
7
 
13
 
5
 
10
 
15
 
3
 
7
 
13
 
5
 
10
 
15
 
3
 
Critical Node
 
Steps of 
Right 
Rotation
 

 
Nonlinear Data Structure (Graph & Tree)
 
 
Prof. Pradyumansinh Jadeja (9879461848)  | 
2130702 

 
Data Structure
 
17
 
 
 
4)
 
Insertion into Right sub
-


 
Single Left Rotation
 
If node becomes unbalanced after insertion of new node at 
Right sub
-
tree of nodes Right child
, then we 
need to perform 
Single 
Left
 
Rotation
 
for u
nbalanced node.
 
Left Rotation
 
a.
 

-
tree
 
b.
 
Consider right child to be new parent
 
c.
 
Attach old parent onto 
left
 
of new parent
 
d.
 

t
 
sub
-
tree as right sub
-
tree of new 
left
 
child
 
 
 
 
50
 
70
 
40
 
80
 
60
 
90
 
60
 
80
 
50
 
90
 
60
 
40
 
70
 
50
 
40
 
70
 
80
 
90
 
Example
 
Unbalanced node
 
X
 
Y
 
T2
 
T3
 
T1
 
n
 
Y
 
X
 
T3
 
T1
 
T2
 
n
 
Leaf 
 
Rotation of X
 
Unbalanced node
 
X
 
T1
 
Z
 
Y
 
T4
 
T2
 
T3
 
Unbalanced node
 
X
 
T1
 
Y
 
T2
 
Z
 
T3
 
T4
 
Right
 
Rotation of Z
 
Y
 
X
 
Z
 
T3
 
T4
 
T1
 
T2
 
Left 
 
Rotation of X
 

 
Nonlinear Data Structure (Graph & Tree)
 
 
Prof. Pradyumansinh Jadeja (9879461848)  | 
2130702 

 
Data Structure
 
18
 
 
12.
 
Construct AVL Search tree by inserting following elements in order of 
their occurrence 6, 5, 4, 3, 2, 1
 
 
 
Assignment:
 

 
Define height of the binary tree. Define height balanced tree with its advantages. Construct a height 
balanced binary tree (AVL tree) for the following data 42,06,54,62,88,50,22,32,12,33
 

 
Construct the AVL se
arch tree by inserting the following elements in the order of their occurrence. 64, 1, 
44, 26, 13, 110, 98, 85
 
6
F
:
\
D
F
S
\
D
F
S 
F
i
n
a
l 
M
a
t
e
r
i
a
l
F
:
\
D
F
S
\
D
F
S 
F
i
n
a
Insert  6
 
Insert : 5
 
6
F
:
\
D
F
S
\
D
F
S 
F
i
n
a
l 
M
a
t
e
r
i
a
l
F
:
\
D
F
S
\
D
F
S 
F
i
n
a
l 
5
F
:
\
D
F
S
\
D
F
S 
F
i
n
a
l 
M
a
t
e
r
i
a
l
F
:
\
D
F
S
\
D
F
S 
F
i
6
F
:
\
D
F
S
\
D
F
S 
F
i
n
a
l 
M
a
t
e
r
i
a
l
F
:
\
D
F
S
\
D
F
S 
F
i
n
a
l 
5
F
:
\
D
F
S
\
D
F
S 
F
i
n
a
l 
M
a
t
e
r
i
a
l
F
:
\
D
F
S
\
D
F
S 
F
i
4
F
:
\
D
F
S
\
D
F
S 
F
i
n
a
l 
M
a
t
e
r
i
a
l
F
:
\
D
F
S
\
D
F
S 
Insert 
 
: 
4
 
Right
 
Rotate
 
6
 
5
 
F
i
n
a
l 
M
a
t
e
r
i
a
l
F
:
\
D
F
S
\
D
F
S 
F
i
n
a
l 
M
a
t
e
r
i
a
l
 
4
:
\
D
F
S
\
D
F
S 
F
i
n
a
l 
M
a
t
e
r
i
a
l
F
:
\
D
F
S
\
D
F
S 
F
i
n
6
F
:
\
D
F
S
\
D
F
S 
F
i
n
a
l 
M
a
t
e
r
i
a
l
F
:
\
D
F
S
\
D
F
S 
F
i
5
 
F
i
n
a
l 
M
a
t
e
r
i
a
l
F
:
\
D
F
S
\
D
F
S 
F
i
n
a
l 
M
a
t
e
r
i
a
l
 
4
:
\
D
F
S
\
D
F
S 
F
i
n
a
l 
M
a
t
e
r
i
a
l
F
:
\
D
F
S
\
D
F
S 
F
i
n
6
F
:
\
D
F
S
\
D
F
S 
F
i
n
a
l 
M
a
t
e
r
i
a
l
F
:
\
D
F
S
\
D
F
S 
F
i
3
:
\
D
F
S
\
D
F
S 
F
i
n
a
l 
M
a
t
e
r
i
a
l
F
:
\
D
F
S
\
D
F
S 
F
Insert :  3
 
Insert : 2
 
5
 
F
i
n
a
l 
M
a
t
e
r
i
a
l
F
:
\
D
F
S
\
D
F
S 
F
i
n
a
l 
 
6
F
:
\
D
F
S
\
D
F
S 
F
i
n
a
l 
M
a
t
e
r
i
a
l
F
:
\
3
:
\
D
F
S
\
D
F
S 
F
i
n
a
l 
M
a
t
e
r
i
a
l
F
:
2
:
\
D
F
S
\
D
F
S 
F
i
n
a
l 
M
a
t
e
r
i
a
l
Righ
t
 
Rotate 4
 
5
 
F
i
n
a
l 
M
a
t
e
r
i
a
l
F
:
\
D
F
S
\
D
F
S 
F
i
n
a
l 
M
3
:
\
D
F
S
\
D
F
S 
F
i
n
a
l 
M
a
t
e
r
i
a
l
F
:
\
D
6
F
:
\
D
F
S
\
D
F
S 
F
i
n
a
l 
M
a
t
e
r
i
a
l
F
:
\
2
:
\
D
F
S
\
D
F
S 
F
i
n
a
l 
M
a
t
e
r
i
a
l
F
:
4
:
\
D
F
S
\
D
F
S 
F
i
n
a
l 
M
a
t
e
r
i
a
l
F
:
Insert : 1
 
5
 
F
i
n
a
l 
M
a
t
e
r
i
a
l
F
:
\
D
F
S
\
D
F
S 
F
i
n
a
l 
M
3
:
\
D
F
S
\
D
F
S 
F
i
n
a
l 
M
a
t
e
r
i
a
l
F
:
\
D
6
F
:
\
D
F
S
\
D
F
S 
F
i
n
a
l 
M
a
t
e
r
i
a
l
F
:
\
2
:
\
D
F
S
\
D
F
S 
F
i
n
a
l 
M
a
t
e
r
i
a
l
F
:
4
:
\
D
F
S
\
D
F
S 
F
i
n
a
l 
M
a
t
e
r
i
a
l
F
:
1
:
\
D
F
S
\
D
F
S 
F
i
n
a
l 
M
a
t
e
r
i
a
l
Right 
 
Rotate 5
 
3
 
F
i
n
a
l 
M
a
t
e
r
i
a
l
F
:
\
D
F
S
2
:
\
D
F
S
\
D
F
S 
F
i
n
a
l 
M
a
t
5
:
\
D
F
S
\
D
F
S 
F
i
n
a
l 
M
a
t
1
:
\
D
F
S
\
D
F
S 
F
i
n
a
l 
M
4
:
\
D
F
S
\
D
F
S 
F
i
n
a
l 
M
6
F
:
\
D
F
S
\
D
F
S 
F
i
n
a
l 
1
 
2
 
3
 
4
 
5
 
6
 

 
Nonlinear Data Structure (Graph & Tree)
 
 
Prof. Pradyumansinh Jadeja (9879461848)  | 
2130702 

 
Data Structure
 
19
 
 
13.
 
What are the advantages of Multiway search tree in disc access? 
Construct B tree of or
der 5 for the following data 
1
,6,
7,
2,11,5,10,13,12,20,16,24
,3,4,18,19,14,25
 
 
Insert: 1
 
1
 
1
 
Insert: 
6
 
1
,  6
 
Insert: 
7
 
1
,  6,   7
 
Insert: 
2
 
1
,  2,   6,   7
 
Insert: 
11
 
1,  2,   6,   7,   11
 
Overflow
 
1
,  2
 
7,  11
 
6
 
2
 
3
 
4
 
5
 
1
,  2,  5
 
7,  11
 
6
 
Insert: 
5
 
6
 
1
,  2,  5
 
7,  10,  11
 
6
 
Insert: 
10
 
1
,  2,  5
 
7, 10, 11, 13
 
6
 
Insert: 
13
 
7
 
8
 
1
,  2,  5
 
7, 10, 11, 12, 13
 
6
 
Insert: 
12
 
Overflow
 
1
,  2,  5
 
12, 13
 
6, 11
 
7, 10
 
Insert: 
20
 
1
,  2,  5
 
12, 13, 20
 
6, 11
 
7, 10
 
9
 
10
 
11
 
Insert: 
16
 
1
,  2,  5
 
12, 13, 16, 20
 
6, 11
 
7, 10
 
Insert: 
24
 
1
,  2,  5
 
12, 13, 16, 20, 24
 
6, 11
 
7, 10
 
Overflow
 
1
,  2,  5
 
20, 24
 
6, 11, 16
 
7, 10
 
12, 13
 
12
 

 
Nonlinear Data Structure (Graph & Tree)
 
 
Prof. Pradyumansinh Jadeja (9879461848)  | 
2130702 

 
Data Structure
 
20
 
 
 
Assignment:
 

 
Construct mutiway search tree for the following data of order for 100, 150, 50, 55, 250, 200, 170, 65, 75, 
20, 30, 52, 10, 25, 180, 190, 300, 5
 
 
 
13
 
1,  2, 3, 4, 5
 
20, 24
 
6, 11, 16
 
7, 10
 
12, 13
 
Insert: 
3, 4
 
Overflow
 
20, 24
 
3   6   11    16
 
7, 10
 
12, 13
 
4, 5
 
1, 2
 
14
 
Insert: 
18, 19, 14
 
18, 19, 20, 24
 
3   6   11    16
 
7, 10
 
12, 13, 14
 
4, 5
 
1, 2
 
15
 
Insert: 
25
 
18, 19, 20, 24, 25
 
3   6   11    16
 
7, 10
 
12, 13, 14
 
4, 5
 
1, 2
 
18, 19
 
3 ,  6   
 
7, 10
 
12, 13, 14
 
4, 5
 
1, 2
 
24, 25
 
Overflow
 
16 , 20   
 
11   
 

 
Nonlinear Data Structure (Graph & Tree)
 
 
Prof. Pradyumansinh Jadeja (9879461848)  | 
2130702 

 
Data Structure
 
21
 
 
14.
 
What is 2
-
3 tree?
 
A
 
2
-
3 tree is a type of data structure
 
with following properties
.
 

 
All data appears at the leaves.
 

 
Data elements are ordered from left (minimum) to right (maximum).
 

 
Every path through the tree is the same length.
 

 
Interior nodes have 
2
 
or 
3
 
subtrees.
 
 
15.
 
What is graph? How it can be represented using adjacency matrix, what 
is path matrix? How path matrix can be found out using adjacency m
atrix .
 
Graph
 

 
A graph G consist of a non empty set V called the set of nodes (points, vertices) of the graph, a set E 
which is the set of edges and a mapping from the set of edges E to a set of pairs of elements of V.
 

 
It is also convenient to write a graph
 
as G=(V,E).
 

 
Notice that definition of graph implies that to every edge of a graph G, we can associate a pair of nodes 

s
ociated with a pair of nodes (
u
,
v
) where 
u
, 
v
 

that edge x connect U and V.
 
A
dj
acency matrix
 
Let G = (V, E) be a simple diagraph in which V = {v
1
, v
2

n
} and the nodes are assumed to be ordered from 
v
1
 
to v
n
. An n x n matrix A whose elements are a
ij 
are given by
 
a
ij
 
=
 



























 
is called
 
adjacency matrix of the graph G.
 

 
Any element of the adjacency matrix is either 0 or 1.
 

 
For a given graph G =m (V, E), an adjacency matrix depends upon the ordering of the elements of V.
 

 
For different ordering of the elements of V we get different adjacenc
y matrices.
 

 
Nonlinear Data Structure (Graph & Tree)
 
 
Prof. Pradyumansinh Jadeja (9879461848)  | 
2130702 

 
Data Structure
 
22
 
 
 

 
We can extend the idea of matri
x representation to multigraph 
and weighted graphs. In the case of 
multigraph or weighted
 
graph
 
we write a
ji
 
= w, where a
ij
 
denotes either the multiplicity 
or 
the 
weight of the edge.
 
Path 
matrix
 

 
An entry of 1 in the ith row and jth column of A shows the existence of an edge (v
i
, v
j
), that is a path 
of length 1 from v
i
 
to v
j
.
 

 
Let denote the elements of A
2
 
by a
ij
(2)
. Then 















 

 
Therefore 
a
ij
(2)
 
is equal to the number of 
different paths of exactly length 2 from v
i
 
to v
j
.
 

 
Similarly element in i
th
 
row and j
th
 
column of A
3
 
gives number of paths of exactly length 3 from v
i
 
to 
v
j
.
 
 
 
16.
 
Which are the basic traversing techniques of the Graph? Write the 
algorithm of them.
 

 
Most graph problems involve traversal of a graph. Traversal of a grap
h means visit each node exactly 
once.
 

 
Two commonly used graphs traversal techniques are
 
1.
 
Depth First Search (DFS)
 
2.
 
Breadth First Search (BFS)
 
1
 
1
 
0
 
0
 
0
 
1
 
0
 
1
 
1
 
2
 
0
 
1
 
1
 
1
 
0
 
0
 
 
Different path matrices
 
A
2 
= 
 
1
 
1
 
0
 
1
 
1
 
1
 
0
 
0
 
2
 
2
 
0
 
1
 
0
 
1
 
0
 
1
 
 
A
3 
= 
 
1
 
2
 
0
 
1
 
1
 
1
 
0
 
1
 
2
 
3
 
0
 
2
 
1
 
1
 
0
 
0
 
 
A
4
 
= 
 
V
1
 
V
2
 
V
3
 
V
4
 
 
V
1
 
V
2
 
V
3
 
V
4
 
V
1
 
0
 
1
 
0
 
1
 
V
2
 
1
 
0
 
0
 
0
 
V
3
 
1
 
1
 
0
 
1
 
V
4
 
0
 
1
 
0
 
0
 
 
A digraph and its adjacency matrix
 

 
Nonlinear Data Structure (Graph & Tree)
 
 
Prof. Pradyumansinh Jadeja (9879461848)  | 
2130702 

 
Data Structure
 
23
 
 
Depth First Search (DFS)
 

 
It is like preorder traversal of tree.
 

 
Traversal can start from any vertex vi
 

 
Vi is visited
 
and then all vertices adjacent to vi are traversed recursively using DFS
 
 

 
Since graph can have cycles, we must avoid re
-
visiting a node. To do this when we visit a vertex V, 
we marks it visited as visited should not be selected for traversal.
 
1
 
3
 
4
 
5
 
6
 
7
 
8
 
2
 
Graph G
 
DFS (G, 1) is given by
 
a)
 
Visit (1)
 
b)
 
DFS (G, 2)
 
DFS (G, 3)
 
DFS (G, 4)
 
DFS (G, 5)
 
DFS
 
traversal of given graph is: 
1, 
2, 6, 3, 8, 7, 4, 5
 

 
Nonlinear Data Structure (Graph & Tree)
 
 
Prof. Pradyumansinh Jadeja (9879461848)  | 
2130702 

 
Data Structure
 
24
 
 
 
 
 
Procedure : 
D
FS (
vertecx
 
V)
 
This procedure traverse the graph G in DFS manner. V is a starting vertex to be explored. S is a 
Stack, visited[] is an array which tells you whether particular vertex is visited or not. W is a 
adjacent node of vertex V. PUSH 
and POP are functions to insert and remove from stack 
respectively.
 
 
1.
 
[Initialize TOP and Visited]
 
visited[] 

 
0
 
TOP 

 
0
 
2.
 
[Push vertex into stack]
 
PUSH (V)
 
3.
 
[Repeat  while stack is not empty]
 
Repeat step 3 while stack is not empty
 
 
 
v  

 
POP()
 
 
 
if
 
visited
[v] is 0
 
 
 
then 
 
visited [v] 

 
1
 
 
 
 
for all W
 
adjacent to v
 
 
 
 
 
if
 
visited [
w
] is 0
 
 
 
 
 
then
 
PUSH (W)
 
 
 
 
end for
 
 
 
end if
 
 
 
 
 

 
Nonlinear Data Structure (Graph & Tree)
 
 
Prof. Pradyumansinh Jadeja (9879461848)  | 
2130702 

 
Data Structure
 
25
 
 
Breadth First Search (BFS)
 

 
This methods starts from vertex v
0
 
 

 
V
0
 
is marked as visited. All vertices adjacent to v
0
 
are visited next
 

 
Let vertices adjacent to v
0
 
are v
1
, v
2
, v
3
, v
4
 

 
v
1
, v
2
, v
3
 
and v
4
 
are marked visited. 
 

 
All unvisited vertices adjacent to v
1
, v
2
, v
3
, v
4
 
are visited next.
 

 
The method continuous until all v
ertices are visited
 

 
The algorithm for BFS has to maintain a list of vertices which have been visited but not explored for 
adjacent vertices. The vertices which have been visited but not explored for adjacent vertices can be 
stored in queue.
 

 
Initially the 
queue contains the starting vertex.
 

 
In every iteration, a vertex is removed from the queue and its adjacent vertices which are not visited 
as yet are added to the queue.
 

 
The algorithm terminates when the queue becomes empty.
 
 
1
 
3
 
4
 
5
 
6
 
7
 
8
 
2
 
Graph G
 
BFS
 
traversal of given graph is: 
1 | 2, 3, 4, 5 | 6, 7 | 8
 

 
Nonlinear Data Structure (Graph & Tree)
 
 
Prof. Pradyumansinh Jadeja (9879461848)  | 
2130702 

 
Data Structure
 
26
 
 
 
17.
 
What is spanning tree?
 

 
A Spanning tree of a graph is an undirected tree consisting of only those edges necessary to connect all 
the nodes 
in the original graph
 

 
A spanning tree has the properties that
 
o
 
For any pair of nodes there exists only one path between them
 
o
 
Insertion of any edge to a spanning tree forms a unique cycle
 

 
The particular Spanning for a graph depends on the criteria used to 
generate it.
 

 
If DFS search is use, those edges traversed by the algorithm forms the edges of tree, referred to as 
Depth First Spanning Tree.
 

 
If BFS Search is used, the spanning tree is formed from those edges traversed during the search, 
producing Breadth 
First Search Spanning tree.
 
Procedure : BFS (
Vertex
 
V)
 
This procedure traverse the graph G in BFS manner. V is a starting vertex to be explored. Q is a 
queue, visited[] is an array which tells you whether particular vertex is visited or not. W 
is a 
adjacent node of vertex V.
 
 
1.
 
Initialize Q
 
2.
 
[Marks visited of V as 1]
 
visited [v]

 
1
 
3.
 
[Add vertex v to Q]
 
InsertQueue(V)
 
4.
 
[Repeat while Q is not empty]
 
Repeat while Q is not empty
 
 
 
v 

 
RemoveFromQueue()
 
 
 
For all vertices W adjacent to v
 
 
 
 
 
if
 
visited
[w] is 0
 
 
 
 
 
then 
 
visited[w] 

1
 
 
 
 
 
 
InsertQueue(w)
 

 
Nonlinear Data Structure (Graph & Tree)
 
 
Prof. Pradyumansinh Jadeja (9879461848)  | 
2130702 

 
Data Structure
 
27
 
 
 
 
18.
 
Consider the graph shown in Fig Find depth
-
first and breadth first 
traversals of this graph starting at A
 
 
 
A
 
B
 
C
 
D
 
F
 
E
 
V0
 
V1
 
V2
 
V3
 
V4
 
V5
 
V6
 
V7
 
V0
 
V1
 
V2
 
V3
 
V4
 
V5
 
V6
 
V7
 
V0
 
V1
 
V2
 
V3
 
V4
 
V5
 
V6
 
V7
 
DFS Spanning Tree
 
BFS Spanning Tree
 

 
Nonlinear Data Structure (Graph & Tree)
 
 
Prof. Pradyumansinh Jadeja (9879461848)  | 
2130702 

 
Data Structure
 
28
 
 
 
A
 
B
 
C
 
D
 
F
 
E
 
DFS : A B D C F E
 
A
 
B
 
C
 
D
 
F
 
E
 
BFS : A B C D F E
 

 
Nonlinear Data Structure (Graph & Tree)
 
 
Prof. Pradyumansinh Jadeja (9879461848)  | 
2130702 

 
Data Structure
 
29
 
 
19.
 
Define spanning tree and minimum spanning tree. Find the minimum 
spanning tree of the graph shown in Fig.
 
 
 
A
 
B
 
C
 
D
 
E
 
4
 
5
 
3
 
6
 
6
 
5
 
2
 
7
 
1
 

 
Let X 
be the set of nodes explored, initially X = { A }
 
Step 1:
 
Taking minimum weight edge of all Adjacent 
edges of
 
X = { A }
 
A
 
B
 
4
 
Step 2
:
 
Taking minimum weight edge of all Adjacent 
edges of
 
X = { A
 
, B
 
}
 
A
 
B
 
4
 
X = { A , B }
 
C
 
2
 
X = { A , B 
, C 
}
 
Step 3
:
 
Taking minimum weight edge of all Adjacent 
edges of
 
X = { A
 
, B
 
, C 
}
 
A
 
B
 
4
 
C
 
2
 
X = { A , B 
, C, D 
}
 
D
 
Step 4
:
 
Taking minimum weight edge of all Adjacent 
edges of
 
X = { A
 
, B
 
, C , D 
}
 
A
 
B
 
4
 
C
 
2
 
X = { A , B 
, C, D, E 
}
 
D
 
E
 
1
 
1
 
3
 
A 

 
B | 4
 
A 

 
E | 5
 
A 

 
C | 6
 
A 

 
D | 6
 
B 

 
E | 3
 
B 

 
C | 2
 
C 

 
E | 6
 
C 

 
D | 1
 
D 

 
E | 7
 
 
Al
l
 
nodes of graph are there with set X, so we obtained minimum spanning tree of cost
: 4 + 2 + 1 + 3 = 10
 

 
Nonlinear Data Structure (Graph & Tree)
 
 
Prof. Pradyumansinh Jadeja (9879461848)  | 
2130702 

 
Data Structure
 
30
 
 
 
 
A
 
B
 
C
 
D
 
E
 
4
 
5
 
3
 
6
 
6
 
5
 
2
 
7
 
1
 

 
Step 1:
 
Taking min edge (C,D)
 
Step 
2
:
 
Taking next min edge (B,C)
 
 
B
 
C
 
2
 
A
 
B
 
4
 
C
 
2
 
D
 
E
 
1
 
3
 
Al
l
 
edges
 
of graph 
has been visited
, 
 
so we obtained minimum spanning tree of cost
: 
4 + 2 + 1 + 3 = 10
 
C
 
D
 
D
 
1
 
1
 
Step 
3
:
 
Taking next min 
edge (B,E)
 
 
B
 
C
 
2
 
D
 
1
 
E
 
3
 
Step 
4
:
 
Taking next min edge (A,B)
 
 
Step 
5
:
 
Taking next min edge (A,E) it forms cycle so do not consider
 
Step 
6
:
 
Taking next min edge (C,E) it forms cycle so do not consider
 
Step 
7
:
 
Taking next min 
edge (A,D) it forms cycle so do not consider
 
Step 
8
:
 
Taking next min edge (A,C) it forms cycle so do not consider
 
Step 
9
:
 
Taking next min edge (E,D) it forms cycle so do not consider
 
 
 
 
 

 
Nonlinear Data Structure (Graph & Tree)
 
 
Prof. Pradyumansinh Jadeja (9879461848)  | 
2130702 

 
Data Structure
 
31
 
 
20.
 
Give example and applications of directed and undirected graphs. Find 
the adjacency matrix for the graph shown in Fig.
 
 
 
Applications of graph: 
 

 
Electronic Circuits
 
o
 
Printed Circuit Board
 
o
 
Integrated Circuit
 

 
Transportation networks
 
o
 
Highway networks
 
Modeling a road network with vertexes as towns and edge costs as distances.
 
o
 
Water Supply netw
orks
 
Modeling a water supply network. A cost might relate to current or a function of capacity and 
length. As water flows in only 1 direction, from higher to lower pressure connections or 
downhill, such a network is inherently an acyclic directed graph.
 
o
 
Fl
ight network
 
Minimizing the cost and time taken for air travel when direct flights don't exist between starting 
and ending airports.
 

 
Computer networks
 
o
 
Local Area Network
 
o
 
Internet
 
Dynamically modeling the status of a set of routes by which traffic might be 
directed over the 
Internet.
 
o
 
Web
 
Using a directed graph to map the links between pages within a website and to analyze ease of 
navigation between different parts of the site.
 

 
Databases
 
o
 
Entity Relationship Diagram
 
 
1
 
2
 
6
 
4
 
5
 
3
 
 
1
 
2
 
3
 
4
 
5
 
6
 
1
 
0
 
1
 
0
 
0
 
0
 
0
 
2
 
0
 
0
 
0
 
1
 
0
 
0
 
3
 
1
 
0
 
0
 
0
 
0
 
0
 
4
 
0
 
0
 
1
 
0
 
1
 
0
 
5
 
0
 
0
 
1
 
0
 
0
 
1
 
6
 
1
 
0
 
1
 
0
 
0
 
0
 
 
Adjacency matrix for the given graph
 

 
Nonlinear Data Structure (Graph & Tree)
 
 
Prof. Pradyumansinh Jadeja (9879461848)  | 
2130702 

 
Data Structure
 
3
2
 
 
21.
 

vertex F5 for the graph shown in Fig.
 
 
 
A
 
B
 
C
 
D
 
E
 
F
 
1
 
 
3
 
 
1
 
 
2
 
 
4
 
 
5
 
 
7
 
 
6
 
 
2
 
 
A
 
B
 
C
 
D
 
E
 
F
 
1
 
 
3
 
 
1
 
 
2
 
 
4
 
 
5
 
 
7
 
 
6
 
 
2
 
 
Step 1: 
Traverse all adjacent node of A
 
0
 
 
1
 
 
3
 
 

 

 

 

 
A
 
B
 
C
 
D
 
E
 
F
 
1
 
 
3
 
 
1
 
 
2
 
 
4
 
 
5
 
 
7
 
 
6
 
 
2
 
 
Step 2
: 
Traverse
 
all adjacent node of B
 
0
 
 
1
 
 
3
 
 
3
 
5
 

 
A
 
B
 
C
 
D
 
E
 
F
 
1
 
 
3
 
 
1
 
 
2
 
 
4
 
 
5
 
 
7
 
 
6
 
 
2
 
 
Step 3
: 
Traverse all adjacent node of C
 
0
 
 
1
 
 
3
 
 
3
 
5
 

 
A
 
B
 
C
 
D
 
E
 
F
 
1
 
 
3
 
 
1
 
 
2
 
 
4
 
 
5
 
 
7
 
 
6
 
 
2
 
 
Step 4
: 
Traverse all adjacent node of D
 
0
 
 
1
 
 
3
 
 
3
 
5
 
9
 
A
 
B
 
C
 
D
 
E
 
F
 
1
 
 
3
 
 
1
 
 
2
 
 
4
 
 
5
 
 
7
 
 
6
 
 
2
 
 
Step 5
: 
Traverse 
all adjacent node of E
 
0
 
 
1
 
 
3
 
 
3
 
5
 
7
 

 
Shortest path from node 
A to F
 
is :
 
A 

 
B 

 
E 

 
F
 
as shown in step 5
 

 
Length of path is 
7
 

 
Hashing
 
 
Prof. Pradyumansinh Jadeja (9879461848)  | 
2130702 

 
Data Structure
 
1
 
 
What is 
Hashing?
 

 
Sequential search requires, on the average O(n) comparisons to locate an element. So many 
comparisons are not desirable for a large database of elements.
 

 
Binary search 
requires much fewer 
comparisons on the average O (log n) but there is an additional 
requirement that the data should be sorted. Even with best sorting algorithm, sorting of elements 
require 0(n log n) comparisons.
 

 
There is another widely used technique for
 
storing of data called hashing.
 
I
t does away with 
th
e 
requirement of keeping data sorted (as in binary search) and its best case timing complexity is of 
constant
 
order (0(1)).
 
In its worst case, hashing algorithm starts behaving like linear search.
 

 
Best c
ase timing 
behavior
 
of searching using hashing = 
O(
 
1)
 

 
Worst case timing 
Behavior
 
of se
arching using hashing = O(n)
 

 
In 
hashing,
 
the record for a key 
va
lue "key", is directly referred by calculating the address from the key 
value. Address or location of an 
element
 
or record, x, is obtained by computing some arithmetic 
function f.
 
f(key) gives the address of x i
n 
the table.
 
 
 
Hash Table Data 
Structure:
 
There are two different forms of hashing.
 
1.
 
Open hashing or
 
external hashing
 
Open or external hashing, allows records to be stored in unlimited space (could be a hard disk). It places 
no limitation on the size of the tables
.
 
f()

Address
 
Hash Table
 
  
 
0 
      
1
        
 
2
       
3
      
 
4
      
 
 
5
      
 
 
6
 
Mapping of Record in hash table
 
Record
 

 
Hashing
 
 
Prof. Pradyumansinh Jadeja (9879461848)  | 
2130702 

 
Data Structure
 
2
 
 
2.
 
Close hashing or internal hashi
n
g
 
Closed or internal hashing, uses a fixed space for 
storage and thus limits the size of hash table.
 
1.
 
Open Hashing D
ata 
S
tructure
 
 

 
The basic idea is that the records [elements] are partitioned into B classes, numbered 
0,1,
2
 

 
B
-
l
 

 
A
 
Hashing function f(x) maps a record with key n to an integer value between 0 and B
-
l.
 

 
Each bucket in the bucket table 
is the head of the linked list of records mapped to that bucket.
 
2.
 
Close Hashing Data Structure
 
 
b
 
 
 
c
 
d
 
0
 
1
 
2
 
3
 
4
 
5
 

 
A closed hash table keeps the elements in the bucket itself. 
 

 
Only one el
ement can be put in the bucket
 

 
If we try to place an element in the bucket 
 
f(n) and find it already holds 
an element, then we say that a collision has occurred. 
 

 
In case of collision, the element should be rehashed to alternate empty 
location f
1
(x), f2(x), ... 
 
within the bucket table
 

 
I
n closed hashing, collision handling is a very important issue.
 
bucket table 
header
 
List of Elements
 
1
i
s
t 
o
f 
E
l
e
m
e
n
t
s
 
B
-
1
 
The open hashing data organization
 

 
Hashing
 
 
Prof. Pradyumansinh Jadeja (9879461848)  | 
2130702 

 
Data Structure
 
3
 
 
 
Hashing Functions
 
Characteristics of a Good Hash Function 
 

 
A good hash function avoids collisions.
 

 
A good hash function tends to spread keys evenly in the
 
array. 
 

 
A good hash function is easy to compute.
 
Different hashing functions
 
1.
 
Division
-
Method
 
2.
 
Midsquare Methods 
 
3.
 
Folding Method
 
4.
 
Digit Analysis
 
5.
 
Length Dependent Method
 
6.
 
Algebraic Coding 
 
7.
 
Multiplicative Hashing
 
1.
 
Division
-
Method
 

 
In this method we use modular ar
ithmetic system to divide the key value by some integer divisor m 
(may be table size).
 

 
It gives us the location value, where the element can be placed. 
 

 
We can write,
 
L = (K mod m) + 1
 
 
 
where L => location in table/file
 
 
 
K => key value
 
 
 
m => table size/
number of slots in file
 

 
Suppose,
 
k = 23, m = 10 then 
 
L = (23 mod 10) + 1= 3 + 1=4
, The
 
key whose value is 23 is placed in 4th location.
 
2.
 
Midsquare Methods
 

 
In this case, we square the value of a key and take the number of digits required to form an address,
 
from the middle position of squared value.
 

 
Suppose a key value is 16, then its square is 256. Now if we want address of two digits, then you 
select the address as 56 (i.e. two digits starting from middle of 256).
 
3.
 
Folding Method
 

 
Most machines have a small 
number of primitive data types for which there are arithmetic 
instructions. 
 

 
Frequently key to be used will not fit easily in to one of these data types
 

 
It is not possible to discard the portion of the key that does not fit into such an arithmetic data typ
e
 

 
Hashing
 
 
Prof. Pradyumansinh Jadeja (9879461848)  | 
2130702 

 
Data Structure
 
4
 
 

 
The solution is to combine the various parts of the key in such a way that all parts of the key affect 
for final result such an operation is termed folding of the key.
 

 
That is the key is actually partitioned into number of parts, each part having the sam
e length as that 
of the required address.
 

 
 
Add the value of each parts, ignoring the final carry to get the required address. 
 

 
This is done in two ways :
 
o
 
Fold
-
shifting: 
Here actual values of each parts of key are added.
 

 
Suppose, the key is : 12345678, and 
the required address is of two digits,
 

 
Then break the key into
:
 
12, 34, 56, 78.
 

 
Add these, we get 12 + 34 + 56 + 78 : 180, ignore first 1 we get 80 as location
 
o
 
Fold
-
boundary: 
Here the reversed values of outer parts of key are added.
 

 
Suppose, the key is : 
12345678, and the required address is of two digits,
 

 
Then break the key into: 21, 34, 56, 87.
 

 
Add these, we get 21 + 34 + 56 + 87 : 198, ignore first 1 we get 98 as location
 
4.
 
Digit Analysis
 

 
This hashing function is a distribution
-
dependent.
 

 
Here we make a 
statistical analysis of digits of the key, and select those digits (of fixed position) 
which occur quite frequently.
 

 
Then reverse or shifts the digits to get the address.
 

 
For example, if the key is : 9861234. If the statistical analysis has revealed the fa
ct that the third and 
fifth position digits occur quite frequently, then we choose the digits in these positions from the key. 
So we get, 62. Reversing it we get 26 as the address.
 
5.
 
Length Dependent Method
 

 
In this type of hashing function we use the length 
of the key along with some portion of the key j to 
produce the address, directly.
 

 
In th
e 
indirect
 
method, the length of the key along with some portion of the key is used to obtain 
intermediate value.
 
6.
 
Algebraic Coding 
 

 
Here a n bit key value is represented
 
as a polynomial.
 

 
The divisor polynomial is then constructed based on the address range required.
 

 
The modular division of key
-
polynomial by divisor polynomial, to get the address
-
polynomial.
 

 
Let f(x) = polynomial of n bit key = a
1
 
+ a
2

n
x
n
-
1
 

 
d(x)
 
= 
divisor polynomial
 
= 
x
1
 
+ d
1
 
+ d
2

1
x
1
-
1
 

 
then the required address polynomial will be
 
f(x) mod d(x)
 
7.
 
Multiplicative Hashing
 

 
This method is based on obtaining an address of a key, based on the multiplication value.
 

 
Hashing
 
 
Prof. Pradyumansinh Jadeja (9879461848)  | 
2130702 

 
Data Structure
 
5
 
 

 
If k is the non
-
negative key, and a constant c, (0 < c < 1), compute kc mod 1, which is a fractional part of 
kc.
 

 
Multiply this fractional part by m and take a floor value to get the address
 

 











 

 
0 < h (k) < m
 
 
Collision Resolution Strategies (Synonym Resolution)
 

 
Collision resolution is the main problem in hashing.
 

 
If the element to be inserted is mapped to the same location, where an element is already inserted then 
we have a 
collision and it must be resolved.
 

 
There are several strategies for collision resolution. The most commonly used are :
 
1.
 
Separate chaining
 
-
 
used with open hashing
 
2.
 
Open addressing
 
-
 
used with closed hashing
 
1.
 
Separate ch
aining
 

 
In this strategy, a separate list
 
of all elements mapped to the same value is maintained.
 

 
Separate chaining is based on collision avoidance.
 

 
If memory space is tight, separate chaining should be avoided.
 

 
Additional memory space for links is wasted in storing address of linked elements.
 

 
Ha
shing function should ensure even distribution of elements among buckets; otherwise the timing 
behavior of most operations on hash table will deteriorate.
 

 
Hashing
 
 
Prof. Pradyumansinh Jadeja (9879461848)  | 
2130702 

 
Data Structure
 
6
 
 
 
Example : 
The integers give
n
 
below are to be inserted in a hash table with 5 locations using 
chaining
 
to resolve collisions. Construct hash table and use simplest hash function. 1, 2, 3, 4, 5, 
10, 21, 22, 33, 34, 15, 32,
 
31, 48, 49, 50
 
An element can be mapped to a 
location
 
in the hash table using the mapping function 
key % 10
.
 
Hash Table Location
 
Mapped element
 
0
 
5, 10, 15, 50
 
1
 
1, 21, 31
 
2
 
2, 22, 32
 
3
 
3, 33, 48
 
4
 
4, 34, 49
 
10
 
List of Elements
 
A Separate Chaining Hash Table
 
50
 
12
 
62
 
32
 
4
 
24
 
9
 
69
 
7
 
0
 
1
 
2
 
3
 
4
 
5
 
6
 
7
 
8
 
9
 

 
Hashing
 
 
Prof. Pradyumansinh Jadeja (9879461848)  | 
2130702 

 
Data Structure
 
7
 
 
 
 
2.
 
Open Addressing
 

 
Separate chaining requires additional memory space for pointers. Open addressing hashing is an 
alternate method of handling collision.
 

 
In 
open addressing, if a collision occurs, alternate cells are tried until an empty cell is found.
 
a.
 
Linear probing
 
b.
 
Quadratic probing
 
c.
 
Double hashing.
 
a)
 
Linear Probing 
 

 
In linear probing, whenever there is a collision, cells are searched sequentially (with 
wraparound) for an empty cell. 
 

 
Fig. 
shows the result of inserting keys {5,18,55,78,35,15} using the hash function 
(f(key)= 
key%10)
 
and linear probing strategy.
 
 
Empty
 
Table
 
After 
 
5
 
After
 
18
 
After
 
55
 
After
 
78
 
After
 
35
 
After
 
15
 
0
 
 
 
 
 
 
 
15
 
1
 
 
 
 
 
 
 
 
2
 
 
 
 
 
 
 
 
3
 
 
 
 
 
 
 
 
4
 
 
 
 
 
 
 
 
5
 
 
5
 
5
 
5
 
5
 
5
 
5
 
6
 
 
 
 
55
 
55
 
55
 
55
 
7
 
 
 
 
 
 
35
 
35
 
8
 
 
 
18
 
18
 
18
 
18
 
18
 
9
 
 
 
 
 
78
 
78
 
78
 
 

 
Linear probing is easy to implement but it suffers from "
primary clustering
"
 
Hash Table
 
0
 
1
 
2
 
3
 
4
 
5
 
50
 
10
 
1
5
 
31
 
1
 
21
 
32
 
2
 
22
 
48
 
3
 
33
 
49
 
4
 
34
 

 
Hashing
 
 
Prof. Pradyumansinh Jadeja (9879461848)  | 
2130702 

 
Data Structure
 
8
 
 

 
When many keys are mapped to the same location (clustering), linear probing will not 
distribute these keys evenly in the hash
 
table
.
 
These keys will be stored in neighborhood of 
the location where they are mapped. This will lead to clustering of keys around the point of 
collision
 
b)
 
Quadratic probing
 

 
One way of reducing "primary clustering" is to use quadratic probing to resolve 
collision.
 

 
Suppose the "key" is mapped to the location j and the cell j is already occupied. In quadratic 
prob
ing, the location j, (j+1), (j+4
)
,
 
(j+9), ... 
 
are examined to find the first empty cell where the 
key is to be inserted.
 

 
This table reduces prima
ry clustering.
 

 
It does not ensure that all cells in the table will be examined to find an empty cell. Thus, it may 
be possible that key will not be inserted even if there is an empty cell in the table.
 
 
c)
 
Double Hashing 
 

 
This method r
equires two hashing func
tions f1
 
(key) and f2 (key)
.
 

 
P
roblem of clustering can easily be handled through double hashing.
 

 
Function f
1 
(key) is known as primary hash function.
 

 
In case the address obtained by f
1 
(key) is already occupied by a key,
 
the function f2
 
(key) is 
evaluated.
 

 
The second function f2
 
(key) is used to compute the increment to be added to the address 
obtained by the first hash function f
1 
(key) in case of collision.
 

 
The search for an empty location is made successively at the addresses
 
f
1
 
(key) + f2(key), 
        
  
f
1 
(key) + 2f2
 
(key), f
1
 
(key) + 3f2(key),...
 

 
File
 
 
Prof. Pradyumansinh Jadeja (9879461848)  | 
2130702 

 
Data Structure
 
1
 
 
What is 
File
?
 

 
A file is a 
collection
 
of records where a record consists of one or more fields.
 
Each contains the same 
sequence of fields.
 

 
Each field is normally of fixed length.
 

 
A 
sample file with four records is show
n
 
below:
 
 
Name
 
Roll No.
 
Year
 
Marks
 
AMIT
 
1000
 
1
 
82
 
KALPESH
 
1005
 
2
 
54
 
JITENDRA
 
1009
 
1
 
75
 
RAVI
 
1010
 
1
 
79
 
 

 
There are four records
 

 
There are four fields (Name, Roll No., Year, Marks)
 

 
R
ecords can be uniquely identified on the field 'Roll No.' Therefore, Roll No. is the key field.
 

 
A database is a collection of files.
 

 
Commonly, used file organizations are :
 
1.
 
Sequential files
 
2.
 
Relative files
 
3.
 
Direct files
 
4.
 
Indexed Sequential files
 
5.
 
Index files
 

 
Primitive Operations on a File :
 
1.
 
Creation
 
2.
 
Reading
 
3.
 
Insertion
 
4.
 
Deletion
 
5.
 
Updation
 
6.
 
Searching
 
 
Sequential Files 
 
It is the most common type of file.  In this type of 
file:
 

 
A fixed format is used fo
r record.
 

 
All records are of the same length.
 

 
Position of each field in record and length of field is fixed.
 

 
Records are physically ordered on the value of one of the fields 
-
 
called the ordering field.
 

 
File
 
 
Prof. Pradyumansinh Jadeja (9879461848)  | 
2130702 

 
Data Structure
 
2
 
 
 
Block 1
 
Name
 
Roll No.
 
Year
 
Marks
 
AMIT
 
1000
 
1
 
82
 
KALPESH
 
1005
 
2
 
54
 
JITENDRA
 
1009
 
1
 
75
 
RAVI
 
1010
 
1
 
79
 
Block 2
 
NILESH
 
1011
 
2
 
89
 
 
 
 
 
 
Some blocks of an ordered (sequential) file of students records with Roll no. as the ordering field
 
Advantages of sequential file over unordered files :
 

 
Reading of records in order of the ordering key is extremely efficient. 
 

 
Finding the next record in order of the ordering key usually, does not require additional block 
access. Next record may be found in the same block.
 

 
Searching operation on ordering key
 
is must faster. Binary search can be utilized. A binary search will 
require 
log
2
b
 
block accesses where b is the total number of blocks in the file.
 
Disadvantages of sequential file :
 

 
Sequential file does not give any advantage when the search operation is
 
to be carried out on non
-
 
ordering field.
 

 
Inserting a record is an expensive operation. Insertion of a new record requires finding of place of 
insertion and then all records ahead of it must be moved to create space for the record to be 
inserted. This cou
ld be very expensive for large files.
 

 
Deleting a record is an expensive operation. Deletion too requires movement of records.
 

 
Modification of field value of ordering key could be time consuming. Modifying the ordering field 
means the record can change its 
position. This requires deletion of the old record followed by 
insertion of the modified record.
 
 
Hashing (Direct file organization):
 

 
It is a common technique used for fast accessing of 
records on secondary storage.
 

 
Records of a file are divided among buckets.
 

 
A bucket is either one disk block or cluste
r
 
of contiguous blocks.
 

 
A hashing function maps a key into a bucket number. The buckets are numbered 0, 1,2...b
-
1
.
 

 
A hash function f maps 
each key value into one of the integers 0 through b 
-
 
1.
 

 
If x is a key, f(x) is the number of bucket that contains the record with key x.
 

 
File
 
 
Prof. Pradyumansinh Jadeja (9879461848)  | 
2130702 

 
Data Structure
 
3
 
 

 
The blocks making up each bucket could either be contiguous blocks or they can be chained together in 
a linked list.
 

 
T
ranslation of bucket number to disk block address is done with the help of bucket directory. It gives the 
address of the first block of the chained blocks in a linked list.
 

 
Hashing is quite efficient in retrieving a record on hashed key. The average number
 
of block accesses for 
retrieving a record.
 

























 

 
Thus the operation is b times faster (b = number of buckets) than unordered file.
 

 
To insert a record with key value x, the new record can added to the last block in the chain for bucket 
f(x). If the record does not fit into the existing block, record is stored in a new block and this new block is 
added at the end of the chain for bucket
 
f(x).
 

 
A well designed hashed structure requires two block accesses for most operations
 
 
 
Indexing
 

 
Indexing is used to speed up retrieval of records.
 
0
 
1
 
2
 
 
b
-
1
 
230
 
 
460
 
 
580
 
 
 
 
480
 
 
790
 
 
850
 
 
 
 
321
 
 
531
 
 
651
 
 
 
 
232
 
 
242
 
 
262
 
 
 
 
270
 
 
470
 
 
582
 
 
 
 
930
 
 
420
 
 
510
 
 
 
 
Bucket 0
 
Bucket 1
 
Bucket 2
 
Bucket 
Directory
 
Hashing with buckets of chained blocks
 

 
File
 
 
Prof. Pradyumansinh Jadeja (9879461848)  | 
2130702 

 
Data Structure
 
4
 
 

 
It is done with the help of a separate sequential file. Each record of in the index file consi
sts of two 
fields, a key field and a pointer into the main file.
 

 
To find a specific record for the given key value, index is searched for the given key value.
 

 
Binary search can used to search in index file. After getting the address of record from index fi
le, the 
record in main file can easily be retrieved.
 
 

 
Index file is ordered on the ordering key Roll No. each record of index file points to the corresponding 
record. Main file is not sorted.
 
Advantages of indexing over sequential 
file:
 

 
Sequential file can be searched effec
tively on ordering key. When it is necessary to search for a record 
on the basis of some other attribute than the ordering key field, sequential file representation is 
inadequate.
 

 
Multiple indexes can be maintained for each type of field  used for searchin
g. Thus, indexing provides 
much better flexibility.
 

 
An index file usually requires less storage space than the main file. A binary search on sequential file will 
require accessing of more blocks. This can be explained with the help of the following example
.
 
Consider 
the example of a sequential file with r = 1024 records of fixed length with record size R = 128 bytes 
stored on disk with block size B = 2048 bytes.
 

 
Number of blocks required to store the file
 
= 








 

 
Number of block accesses for se
arching a record = log
2
64
= 6
 

 
Suppose, we want to construct an index on a key field that is V = 4 bytes long and the block pointer is P = 
4 bytes long.
 

 
A record of an index file is of the form <V;, Pj> and it will need 8 bytes per entry.
 

 
Total Number of ind
ex entries = 1024
 

 
Number of blocks b' required to store the file
 
= 








 

 
Number of block accesses for searching a record = log
2
4= 2
 
1000
 
10
1
0
 
10
12
 
10
15
 
10
16
 
 
 
 
 
 
 
 
AMIT
 
KALPESH
 
JITENDRA
 
RAVI
 
NILESH
 
Name
 
1010
 
10
16
 
10
00
 
10
12
 
10
15
 
Roll No
 
1
 
1
 
3
 
2
 
1
 
Year
 
70
 
80
 
65
 
78
 
95
 
Marks
 
Main File
 
Search
 
Key
 
Pointer
 
Index 
File
 

 
File
 
 
Prof. Pradyumansinh Jadeja (9879461848)  | 
2130702 

 
Data Structure
 
5
 
 

 
With indexing, new records can be added at the end of the main file. It will not require movement of 
records as in the case of sequential file. Updation of index file requires fewer block accesses compare to 
sequential file
 
Types of 
Indexes:
 
1.
 
Primary 
indexes
 
2.
 
Clustering indexes
 
3.
 
Secondary indexes
 
 
Primary 
Indexes
 
(Indexed Sequential File)
:
 

 
An indexed sequential file is characterized by
 
o
 
Sequential organization (ordered on primary key)
 
o
 
Index
ed on primary key
 

 
An indexed sequential file is both ordered and indexed.
 

 
Records are organized in sequence based on a key field, known as primary key.
 

 
An index to the file is added to support random access. Each record in the index file consists of two 
fi
elds:
 
a key field, which is the same as the key field in the main
 
file.
 

 
Number of records in the index file is equal to the number of blocks in the main file (data file) and not 
equal to the number of records in the main file (data file).
 

 
To create a prima
ry index on the ordered file shown in the Fig. we use the rollno field as primary key. 
Each entry in the index file has rollno value and a block pointer. The first three index entries are as 
follows.
 
o
 
<101, address of block 1>
 
o
 
<201, address of block 2>
 
o
 
<351
, address of block 3>
 

 
Total number of entries in index is same as the number of disk b
locks in the ordered data file.
 

 
A binary search on the index file requires very few block accesses
 

 
File
 
 
Prof. Pradyumansinh Jadeja (9879461848)  | 
2130702 

 
Data Structure
 
6
 
 
 
 
 
Clustering Indexes
 

 
If records of a file are ordered on a non
-
key field, we can create a different type of index known as 
clustering index.
 

 
A non
-
key field does not have distinct value for each record.
 

 
A Clustering index is also an ordered file with two fields.
 
101
 
201
 
351
 
 
805
 
905
 
 
 
 
 
 
 
 
 
101
 
 
 
 
200
 
 
 
201
 
 
 
 
350
 
 
 
351
 
 
 
 
400
 
 
 
805
 
 
 
 
904
 
 
Block Pointer
 
Roll No
 
Index File
 
Data File
 
Primary Index on ordering key field roll number
 

 
File
 
 
Prof. Pradyumansinh Jadeja (9879461848)  | 
2130702 

 
Data Structure
 
7
 
 
 
 
Secondary indexes
 
(Simple Index File)
 

 
While the hashed, sequential and indexed sequential files are suitable for operations based on ordering 
key or the hashed key. Above file organizations are not suitable for operation
s involving a search on a 
field other than ordering or hashed key.
 

 
If searching is required on various keys, secondary indexes on these fields must be maintained. A 
secondary index is an ordered file with two fields.
 
o
 
Some non
-
ordering field of the data fil
e.
 
o
 
A block pointer
 

 
There could be several secondary indexes for the same file.
 

 
One could use binary search on index file as entries of the index file are ordered on secondary key field. 
Records of the data files are not ordered on secondary key field.
 

 
A 
secondary index requires more storage space and longer search time than does a primary index.
 

 
A secondary index file has an entry for every record whereas primary index file has an entry for every 
block in data file.
 

 
There is a single primary index file bu
t the number of secondary indexes could be quite a few.
 
100
 
105
 
106
 
108
 
109
 
 
 
 
 
 
100
 
Math
 
100
 
Science
 
Block Pointer
 
Field 
Value
 
Index File
 
Field Clustering Data File
 
Example of clustering index on roll no
 
 
 
105
 
Physics
 
 
105
 
 
105
 
 
 
 
106
 
 
 
106
 
 
 
108
 
 
108
 
 
 
 
109
 
 
 
109
 
 
 

 
File
 
 
Prof. Pradyumansinh Jadeja (9879461848)  | 
2130702 

 
Data Structure
 
8
 
 
 
 
1
 
2
 
3
 
4
 
5
 
 
 
 
 
 
6
 
7
 
8
 
9
 
10
 
 
 
 
 
 
11
 
12
 
13
 
14
 
15
 
 
 
 
 
 
16
 
17
 
18
 
19
 
20
 
 
 
 
 
 
2
 
 
5
 
 
 
 
3
 
 
 
17
 
 
 
Index
 
Field
 
6
 
 
10
 
 
 
 
14
 
 
 
7
 
 
 
13
 
 
4
 
 
 
 
15
 
 
 
18
 
 
 
12
 
 
1
 
 
 
 
19
 
 
 
8
 
 
 
9
 
 
11
 
 
 
 
16
 
 
 
20
 
 
 
Index File
 
Data
 
File
 
Block
 
Pointer
 
Indexing Field Roll No
 
A secondary index on a non
-
ordering key field
 

 
Sorting and Searching
 
 
Prof. Pradyumansinh Jadeja (9879461848)  | 
2130702 

 
Data Structure
 
1
 
 
Bubble sort
 

 
Bubble sort
, sometimes referred 
as
 
sinking sort
.
 

 
It
 
is a simple
 
sorting algorithm
 
that works by repeatedly stepping through the list to be sorted, 
comparing each pair of 
adjacent items and
 
swapping
 
them if they are in the wrong order.
 

 
The pass through the list is repeated until no swaps are needed, which ind
icates that the list is 
sorted.
 

 
The algorithm gets its name from the way smaller elements "
bubble" to the top of the 
list.
 

 
As
 
it only uses comparisons to operate on elements, it is a
 
comparison sort
.
 

 
Although the algorithm is simple, it is too slow for practical use, even compared to
 
insertion sort.
 
Algorithm
 
 
Program
 
#include <stdio.h>
 
void
 
main()
 
{
 
 
int array[100], n, i, j, temp;
 
 
 
printf("Enter number of elements
\
n
");
 
 
scanf("%d", &n);
 
 
 
printf("Enter %d integers
\
n
", n);
 
for (
i
 
= 0; 
I 
< n; 
i
++)
 
{
 
 
 
scanf("%d", &array[
i
]);
 
 
}
 
 
 
for (
i
 
= 0 ;
i
< ( n 
-
 
1 );
i
++)
 
 
{
 
 
 
for (
j
 
= 0 ;
 
j
< n 
-
 
c 
-
 
1;
 
j
++)
 
 
 
{
 
 
 
 
if (array[
j
] > array[
j
+1])
 
 
/* For decreasing order use < */
 
 
 
 
{
 
for
 
i
 

 
1 to
 
n
 
do
 
 
for
 
j
 

 
1 to
 
n
-
i
 
do
 
 
 
If A
rray
[
j
] > 
Array[j+1]
 
then
 
 
/* For decreasing order use < */
 
 
temp
 

 
A
rray
[
j
]
 
 
 
 
A
rray
[
j
]
 

 
A [
j+1
]
 
   
 
 
 
A
rray
[
j+1
]
 

 
temp
 

 
Sorting and Searching
 
 
Prof. Pradyumansinh Jadeja (9879461848)  | 
2130702 

 
Data Structure
 
2
 
 
 
 
 
 
tem
p       = array[
j
];
 
 
 
 
 
array[
j
]   = array[
j
+1];
 
 
 
 
 
array[
j
+1] =
 
tem
p;
 
 
 
 
}
 
 
 
}
 
 
}
 
 
 
printf("Sorted list
 
in ascending order:
\
n
");
 
 
 
for (
i
 
= 0 ;
i
< n ;
i
++ )
 
 
{
 
 
 
printf("%d
\
n
", array[
i
]);
 
 
}
 
 
getch();
 
}
 
Example
 
Consider an array A of 5 element
 
 
Pass
-
1: 
The comparisons for pass
-
1 are as follows.
 
Compare A[0] and A[1]. Since 45>34
,
 
interchange them.
 
Compare A[1] and A[2]. Since 
45<56
,
 
no
 
interchange
.
 
Compare A[2] and A[3]. Since 
56>23
,
 
interchange them.
 
Compare 
A[3] and A[4]. Since 5
6>12
 
interchange them
.
 
At the end of first pass the largest element of the array, 56, is bubbled up to the last position in the 
array as shown.
 
45
 
34
 
56
 
23
 
12
 
A[0]
 
A[1]
 
 
A[2]
 
 
A[3]
 
 
A[4]
 
 

 
Sorting and Searching
 
 
Prof. Pradyumansinh Jadeja (9879461848)  | 
2130702 

 
Data Structure
 
3
 
 
 
Pass
-
2: 
The comparisons for pass
-
2 are as follows.
 
Compare A[0] and A[1]. Since 
34<45
,
 
no 
interchange.
 
Compare A[1] and A[2]. Since 
45>23
,
 
interchange
 
them
.
 
Compare A[2] and A[3]. Since 
45
>
12
,
 
interchange them.
 
 
Pass
-
3: 
The comparisons for pass
-
3
 
are as follows.
 
Compare A[0] and A[1]. Since 34
>23
, interchange
 
them
.
 
Compare A[1] and A[2]. Since 
34
>
12
, interchange them
.
 
 
34
 
23
 
12
 
45
 
56
 
23
 
34
 
12
 
45
 
56
 
23
 
12
 
34
 
45
 
56
 
Third Largest element
 
34
 
45
 
23
 
12
 
55
 
34
 
45
 
23
 
12
 
56
 
34
 
23
 
45
 
12
 
56
 
34
 
23
 
12
 
45
 
56
 
Second Largest element
 
45
 
34
 
56
 
23
 
12
 
34
 
45
 
56
 
23
 
12
 
34
 
45
 
56
 
23
 
12
 
34
 
45
 
23
 
56
 
12
 
34
 
45
 
23
 
12
 
56
 
Largest element
 

 
Sorting and Searching
 
 
Prof. Pradyumansinh Jadeja (9879461848)  | 
2130702 

 
Data Structure
 
4
 
 
Pass
-
4: 
The comparisons for pass
-
4 are as follows.
 
Compare A[0] and A[1]. Since 23>12, interchange them.
 
 
 
 
 
23
 
12
 
34
 
45
 
56
 
12
 
23
 
34
 
45
 
56
 
Sorted Array
 

 
Sorting and Searching
 
 
Prof. Pradyumansinh Jadeja (9879461848)  | 
2130702 

 
Data Structure
 
5
 
 
Selection Sort
 

 
The ide
a of algorithm is quite simple.
 

 
Array is imaginary divided into two parts 
-
 
sorted one
 
and
 
unsorted one
.
 

 
At the beginning,
 
sorted part
 
is
 
empty, while
 
unsorted one
 
contains
 
whole array.
 

 
At every s
tep,
 
algorithm finds
 
minimal element
 
in the
 
unsorted part
 
and adds it to the end of the
 
sorted one
.
 

 
When
 
unsorted part
 
becomes
 
empty, algorithm
 
stops.
 
Algorithm
 
 
Program
 
#include <stdio.h>
 
void
 
main()
 
{
 
   
 
int array[100],
 
n
,
 
i
,
 
j
,
 
min
,
 
temp
;
 
 
   
 
printf("Enter number of elements
\
n");
 
   
 
scanf("%d", &n);
 
printf("Enter %d integers
\
n", n);
 
for (
 
i
 
= 0 ;
 
i
 
< n ;
 
i
++ )
 
{
 
      
 
 
scanf("%d", &array[
i
]);
 
 
}
 
 
 
for (
 
i
 
= 0 ;
 
i
 
< ( n 
-
 
1 ) ;
 
i
++ )
 
  
 
{
 
      
 
 
min
 
= 
i
;
 
 
     
 
 
for (
 
j
 
=
 
i
 
+ 1 ;
 
j
 
< n ;
 
j
++ )
 
      
 
 
{
 
         
 
 
 
if ( array[
min
] > array[
j
] )
 
            
 
 
 
min
 
=
 
j
;
 
      
 
 
}
 
SELECTION_SORT
 
(A)
 
for
 
i
 

 
1 to
 
n
-
1 do
 
   
 
 
min
 

 
i
;
 
   
 
 
for
 
j
 

 
i
 
+ 1 to n do
 
       
 
 
 
If A[
j
] < A[i]
 
then
 
           
 
 
 
 
min
 

 
j
 
   
 
 
If min!=i then
 
temp
 

 
A[
i
]
 
 
 
A[
i
]
 

 
A [
min
]
 
   
 
 
 
A[
min
]
 

 
temp
 
 

 
Sorting and Searching
 
 
Prof. Pradyumansinh Jadeja (9879461848)  | 
2130702 

 
Data Structure
 
6
 
 
      
 
 
if (
 
min
 
!=
 
i
 
)
 
      
 
 
{
 
      
   
 
 
 
temp
 
= array[
i
];
 
         
 
 
 
array[
i
] = array[
min
];
 
         
 
 
 
array[
min
] =
 
temp
;
 
      
 
 
}
 
   
 
}
 
 
   
 
printf
("Sorted list in ascending order:
\
n");
 
 
   
 
for (
 
i
 
= 0 ;
 
i
 
< n ;
 
i
++ )
 
 
{
 
      
 
 
printf("%d
\
n", array[
i
]);
 
 
}
 
 
 
getch();
 
}
 

 
Sorting and Searching
 
 
Prof. Pradyumansinh Jadeja (9879461848)  | 
2130702 

 
Data Structure
 
7
 
 
Example
 
 
 
5
 
1
 
12
 
-
5
 
16
 
2
 
12
 
14
 
Unsorted Array
 
5
 
1
 
12
 
-
5
 
16
 
2
 
12
 
14
 
-
5
 
1
 
12
 
5
 
16
 
2
 
12
 
14
 
-
5
 
1
 
12
 
5
 
16
 
2
 
12
 
14
 
Unsorted Sub Array
 
Sorted Sub Array
 
Exchange 5 and 
-
5
 
No Exchange
 
Unsorted Sub Array
 
Sorted Sub Array
 
Exchange 12 and 2
 
 
-
5
 
1
 
2
 
5
 
16
 
12
 
12
 
14
 
Unsorted Sub Array
 
Sorted Sub Array
 
No Exchange
 
 
 
-
5
 
1
 
2
 
5
 
16
 
12
 
12
 
14
 
Unsorted Sub Array
 
Sorted Sub Array
 
Exchange 16 and 12
 
 
-
5
 
1
 
2
 
5
 
12
 
16
 
12
 
14
 
Unsorted Sub 
Array
 
Sorted Sub Array
 
Exchange 16 and 12
 
 
-
5
 
1
 
2
 
5
 
12
 
12
 
16
 
14
 
Unsorted Sub Array
 
Sorted Sub Array
 
Exchange 16 and 14
 
 
-
5
 
1
 
2
 
5
 
12
 
12
 
14
 
16
 
Sorted Sub Array
 
End of the Array
 
 
Step 

 
1
:
 
Step 

 
2:
 
Step 

 
3:
 
Step 

 
4:
 
Step 

 
5:
 
Step 

 
6:
 
Step 

 
7:
 
Step 

 
8:
 
Step 

 
9:
 

 
Sorting and Searching
 
 
Prof. Pradyumansinh Jadeja (9879461848)  | 
2130702 

 
Data Structure
 
8
 
 
Quick Sort
 

 
Q
uicksort is the currently fastest known sorting algorithm and is often the best practical choice for sorting, 
as its average expected running time is O(n log(n)).
 

 
Pick an element, called a
 
pivot
,
 
from the array.
 

 
Reorder the array so that all elements with values less than the pivot come before the pivot, while all 
elements with values greater than the pivot come after it (equal values can go either way). After this 
partitioning, the pivot is in it
s final position. This is called the
 
partition
 
operation.
 

 
Recursively
 
apply the above steps to the sub
-
array of elements with smaller values and separately to the 
sub
-
array of elements with greater values.
 

 
Quicksort, like
 
merge sort, is a
 
divide
-
and
-
conque
r
 
recursive
 
algorithm.
 

 
The basic divide
-
and
-
conquer p
rocess for sorting a sub array A
[
i
..
j
] is summarized in the following three easy 
steps:
 
o
 
Divide:
 
Partition 
T
[
i
..
j
] Into two sub arrays 
T
[
i
..
l
-
1]
 
and 
T
[
l
+1

 
j
] such that each element of 
T
[
i..l
-
1]
 
is 
less than or equal to 
T
[
l
], which is, in turn, less th
an or equal to each element of 
T
[
l
+1

 
j
]
. Compute the 
index 
l
 
as part of this partitioning procedure
 
o
 
Conquer:
 
Sort the two sub arrays 
T
[
i
..
l
-
1]
 
and 
T
[
l
+1

 
j
]
 
by recursive calls to quicksort.
 
o
 
Combine:
 
Since the sub arrays are sorted in place, no work is needed to 
combing them: the entire array 
T
[
i..j
]
 
is now sorted.
 
Algorithm
 
Procedure
 
pivot
 
(
T [
i

]
; 
var
 
l
)
 
{Permutes the elements in array 
T [
i

]
 
and returns a value l such that, at the end, 
i<=l<=j
,
 
T[
k
] <
=
P
 
for all 

, T[
l
] =
P, a
nd T[
k
] > 
P
 
for all 

 
where 
P
 
is the initial value T[
i
]}
 
P
 

T[
i
]
 
K
 

i
; 
l
 

j
+1
 
Repeat
 
k
 

k
+1 
until
 
T[
k
] > 
P
 
 
Repeat
 
l
 

l
-
1 
until
 
T[
l

P
 
While
 
k
 
< l
 
do
 
      
Swap T[
k
] and T[
l
]
 
      
Repeat
 
k
 

k
+1 
until
 
T[
k
] > 
P
 
      
Repeat
 
l
 

l
-
1 
until
 
T[
l

P
 
Swap T[
i
] and T[
l
]
 
Procedure
 
quicksort
 
(
T [
i

]
)
 
{Sorts sub array 
T [
i

]
 
into non decreasing order}
 
if
 
j
 

 
i
 
is sufficiently small 
then
 
insert (
T[

]
)
 
else
 
 
pivot (
T[

]
,
l
)
 
 
quicksort (T[

 
-
 
1])
 
 
quicksort (T[
l

j
]
 

 
Sorting and Searching
 
 
Prof. Pradyumansinh Jadeja (9879461848)  | 
2130702 

 
Data Structure
 
9
 
 
Program
 
#include<stdio.h>
 
void
 
quicksort(int
 
[10],int,int);
 
int
 
partition(
int
 
[10]
,int,
 
int
);
 
void
 
main()
 
{
 
  
 
int
 
x[20],size,i;
 
 
 
 
 
printf("Enter size of the array: ");
 
 
 
 
scanf("%d",&size);
 
 
 
 
 
printf("Enter %d elements: ",size);
 
  
 
for(i=0;i<size;i++)
 
 
{
 
   
 
 
 
scanf("%d",&x[i]);
 
 
}
 
 
 
 
 
quicksort(x,0,size
-
1);
 
 
 
 
 
printf("Sorted elements: ");
 
  
 
for(i=0;i<size;i++)
 
 
{
 
   
 
 
 
printf(" %d",x[i]);
 
 
}
 
 
getch();
 
}
 
 
void
 
quicksort(int
 
x[10],int
 
first,int
 
last)
 
{
 
 
Int mid;
 
 
if(first<last)
 
 
{
 
 
 
mid=
 
partition(
int
 
x
,int
 
first,int
 
last
)
 
        
 
 
quicksort(x,first,
mid
-
1);
 
        
 
 
 
quicksort(x,
mid
+1,last);
 
 
}
 
}
 
int
 
partition(
int
 
x[10],int
 
p,int
 
r
)
 
 
{
 
 
int 
value
, i, j
, temp
;
 

 
Sorting and Searching
 
 
Prof. Pradyumansinh Jadeja (9879461848)  | 
2130702 

 
Data Structure
 
10
 
 
 
value=x[r
];
 
 
i=p
-
1;
 
 
for(
j=
p
;
j<=r
-
1;j++)
 
 
{
 
 
 
If(x[j]
 

value)
 
 
 
{
 
 
 
 
i=i+1;
 
 
 
 
temp=x[i];
 
x[i]=x[j];
 
                 
 
 
 
x[j]=temp;
 
 
 
}
 
 
}
 
 
temp=x[i
+1
];
 
x[i
]=x[r
];
 
               
x[r
]=temp;
 
 
 
Return (i+1)
;
 
}
 

 
Sorting and Searching
 
 
Prof. Pradyumansinh Jadeja (9879461848)  | 
2130702 

 
Data Structure
 
11
 
 
Example
 
 
2
 
8
 
7
 
1
 
3
 
5
 
6
 
4
 
i
 
P , j
 
r
 
2
 
8
 
7
 
1
 
3
 
5
 
6
 
4
 
j
 
P , i
 
r
 
2
 
8
 
7
 
1
 
3
 
5
 
6
 
4
 
j
 
P , i
 
r
 
2
 
8
 
7
 
1
 
3
 
5
 
6
 
4
 
j
 
P , i
 
r
 
(a)
 
(
b
)
 
(
c
)
 
(
d
)
 
(
e
)
 
2
 
1
 
7
 
8
 
3
 
5
 
6
 
4
 
j
 
P
 
i
 
Exchange 8 and 1
 
(
f
)
 
2
 
1
 
3
 
8
 
7
 
5
 
6
 
4
 
j
 
P
 
i
 
r
 
r
 
(
g
)
 
2
 
1
 
3
 
8
 
7
 
5
 
6
 
4
 
j
 
P
 
i
 
r
 
Exchange 7 and 3
 
(
h
)
 
2
 
1
 
3
 
8
 
7
 
5
 
6
 
4
 
P
 
i
 
r
 
(
i
)
 
2
 
1
 
3
 
4
 
7
 
5
 
6
 
8
 
P
 
i
 
r
 
Exchange 8 and 4
 
2
 
1
 
3
 
4
 
7
 
5
 
6
 
8
 
Apply same method for left and right sub array finally we will get sorted 
array
 
Left Sub Array
 
Right Sub Array
 
Sort given array using Quick Sort:
 
2
 
8
 
7
 
1
 
3
 
5
 
6
 
4
 

 
Sorting and Searching
 
 
Prof. Pradyumansinh Jadeja (9879461848)  | 
2130702 

 
Data Structure
 
12
 
 
Merge Sort
 

 
The
 
merge sort
 
algorithm is based on the classical divide
-
and
-
conquer paradigm. It operates as follows:
 
 
o
 
DIVIDE
:
 
Partition the n
-
element sequence to be sorted into two subsequences of n/2 elements each.
 
 
o
 
CONQU
ER
:
 
Sort the two subsequences recursively using the merge sort.
 
 
o
 
COMBINE
:
 
Merge the two sorted subsequences of size n/2 each to produce the sorted sequence 
consisting of n elements.
 
 

 
Note that recursion
 
"
bottoms out
"
 
when the sequence 
to be sorted is of un
it length.
 

 
Since every sequence of length 1 is in sorted order, no furth
er recursive call is necessary.
 

 
The key operation of the merge
 
sort algorithm is the merging of the two sorted 
sub 
sequences
 
in the 
"combine step".
 

 
To perform the merging, we use an 
auxiliary
 
procedure Merge
 
(A,p,q,r), where A is an array and p,q and r 
are indices numbering elements of the array such that 
proce
dure assumes that the sub
 
arrays A[p..q] and 
A[q+1...r] are in sorted order.
 

 
It merges them to form a single sorted sub
 
array 
that replaces the current sub
 
array A[p..r]. Thus finally,
 
we 
obtain the sorted array A[1..n], which is the solution.
 
Algorithm
 
 
MERGE 
(
A,p
,q
,r
)
 
n1 = q
  
-
p
 
+
 
1
 
n2 = r 

 
q
 

 
for i = 1 to n1
 
 
L[i] = A[p+i
-
1]
 
for
 
j = 1 to n2
 
 
R[j] = A[q+j]
 
L[n1+1] = infinite
 
R[n2+1]= infinite
 
i=1
 
j=1
 
for k = p to r
 
 
if L[i]
 

 
R[j]
 
 
 
A[k]=L[i]
 
 
 
i = i +1
 
 
else A[k] = R[j]
 
 
 
j = j + 1
 

 
Sorting and Searching
 
 
Prof. Pradyumansinh Jadeja (9879461848)  | 
2130702 

 
Data Structure
 
13
 
 
 
Program
 
#include<stdio.h>
 
void
 
mergesort(int
 
[20
],int,int);
 
int merge(
int
 
[20]
,int,
 
int
, int);
 
void
 
main()
 
{
 
  
 
int
 
x[20],size,i;
 
 
 
 
 
printf("Enter size of the array: ");
 
 
 
 
scanf("%d",&size);
 
 
 
 
 
printf("Enter %d elements: ",size);
 
  
 
for(i=0;i<size;i++)
 
 
{
 
   
 
 
 
scanf("%d",&x[i]);
 
 
}
 
 
 
 
 
merge
sort(x,0,size
-
1);
 
 
 
 
 
printf("Sorted elements: ");
 
  
 
for(
i=0;i<size;i++)
 
 
{
 
   
 
 
 
printf(" %d",x[i]);
 
 
}
 
 
getch();
 
}
 
 
void
 
merge
sort(int
 
x[20
],int
 
p
,int
 
r
)
 
{
 
 
Int
 
q
;
 
 
if(p<r
)
 
MERGE SORT (
A,p,r
)
 
 
 
if
 
p < r
 
 
then
 
q
<
--
 
[ (p + r) / 2 ]
 
 
MERGE SORT(
A,p,q
)
 
 
MERGER SORT(
A,q
 
+ 1,
r
)
 
 
MERGE(
A,p,q,r
)
 
 
 

 
Sorting and Searching
 
 
Prof. Pradyumansinh Jadeja (9879461848)  | 
2130702 

 
Data Structure
 
14
 
 
 
{
 
 
 
q
=
(p+r)/2;
 
 
        
 
 
mergesort(x,p,q
);
 
        
 
 
 
merge
sort(x,
q+1,r
);
 
 
merge(x
,p,q,r
)
 
 
 
 
}
 
}
 
int 
merge
(int
 
x[20
],int
 
p,int
 
q,int r
)
 
 
{
 
 
Int n1,n2,L[20],R[20],i,j
,k
;
 
 
n1 = q
  
-
p
 
+
 
1
;
 
n2 = r 

 
q;
 
 
for(i=1; i<=n1;i++)
 
 
{
 
 
 
L[i]=x[p+i
-
1];
 
 
}
 
 
for(j=1; i<=n2;j++)
 
 
{
 
 
 
R[j]=x[q+
j
];
 
 
}
 
 
L[n1+1]=NULL;
 
 
L[n2+1]=NULL;
 
 
I=1;
 
 
J=1;
 
 
For(k=p;k<=r;k++)
 
 
{
 
 
 
If(L[i]<=R[j])
 
 
 
{
 
 
 
 
X[k]=L[i];
 
 
 
 
I++;
 
 
 
}
 
 
 
Else
 
 
 
{
 
 
 
 
x[k] = R[j];
 
 
 
 
j++;
 
 
 
}
 
 
}
 
}
 
 

 
Sorting and Searching
 
 
Prof. Pradyumansinh Jadeja (9879461848)  | 
2130702 

 
Data Structure
 
15
 
 
Example
 
 
 
 
 
38
 
27
 
43
 
3
 
9
 
82
 
10
 
38
 
27
 
43
 
3
 
9
 
82
 
10
 
38
 
27
 
43
 
3
 
9
 
82
 
10
 
38
 
27
 
43
 
3
 
9
 
82
 
10
 
27
 
38
 
3
 
43
 
9
 
82
 
10
 
3
 
27
 
38
 
43
 
9
 
10
 
82
 
3
 
9
 
10
 
27
 
38
 
43
 
82
 
38
 
27
 
43
 
3
 
9
 
82
 
10
 
Sort given array usin
g
 
merge sort
 

 
Sorting and Searching
 
 
Prof. Pradyumansinh Jadeja (9879461848)  | 
2130702 

 
Data Structure
 
16
 
 
Linear
/
Sequential
 
Search
 

 
In
 
computer science
,
 
linear search
 
or
 
sequential search
 
is a method for finding a particular value in a
 
list
 
that 
consists of checking every one of its elements, one at a time and in seq
uence, until the desired one is 
found. 
 

 
Linear search is the simplest
 
search algorithm
.
 

 
I
t is a special case of
 
brute
-
force search
. Its
 
worst case cost
 
is proportional to the number of e
lements in the 
list.
 
Algorithm
 
 
Program
 
#include <stdio.h>
 
void
 
main()
 
{
 
 
 
int array[100],
 
key
, 
i
, n;
 
 
 
   
 
printf("Enter 
the number of elements in array
\
n");
 
   
 
scanf("%d",&n);
 
 
 
   
 
printf("Enter %d integer(s)
\
n", n);
 
 
 
   
 
for (
i
 
= 0;
 
i
 
< n;
 
i
++)
 
 
{
 
 
 
printf(
"Array[%d]=
",
 
i
);
 
      
 
 
scanf("%d", &array[
i
]);
 
 
}
 
 
 
   
 
printf("Enter the number to search
\
n");
 
   
 
scanf("%d", 
&
key
);
 
 
 
# Input: Array A, integer key
 
# Output: first index of key in A, 
 
# or 
-
1 if no
t found
 
 
Algorith: Linear_Search
 
f
or
 
i = 0 to last index of A:
 
if A[i] equals key:
 
return i
 
return 
-
1
 

 
Sorting and Searching
 
 
Prof. Pradyumansinh Jadeja (9879461848)  | 
2130702 

 
Data Structure
 
17
 
 
   
 
for (
i
 
= 0; 
i
 
< n; 
i
++)
 
   
 
{
 
      
 
 
if (array[
i
] ==
 
key
)     /* if required element found */
 
      
 
 
{
 
         
 
 
 
printf("%d is present at location %d.
\
n",
 
key
, 
i
+1);
 
         
 
 
 
break;
 
      
 
 
}
 
  
 
 
}
 
   
 
if (
i
 
== n)
 
{
 
      
 
 
printf("%d i
s not present in array.
\
n", search);
 
 
}
 
 
g
etch();
 
}
 
Example
 
 
2
 
9
 
3
 
1
 
8
 
Search for 1 in given array:
 
2
 
9
 
3
 
1
 
8
 
(a)
 
i
 
Comparing value of i
th
 
index with element to be search one 
by one until we get seache
 
element or end of the array
 
 
2
 
9
 
3
 
1
 
8
 
(b
)
 
i
 
2
 
9
 
3
 
1
 
8
 
(c
)
 
i
 
2
 
9
 
3
 
1
 
8
 
(d
)
 
i
 
Element found at i
th
 
index
 

 
Sorting and Searching
 
 
Prof. Pradyumansinh Jadeja (9879461848)  | 
2130702 

 
Data Structure
 
18
 
 
Binary Search
 

 
If we have an array that is sorted, we can use a much more efficient algorithm called a
 
Binary Search
.
 

 
In binary search each time we divide array into two equal half and compare middle element with search 
e
lement.
 

 
If middle element is equal to search element then we got that element and return that index otherwise if 
middle element is less than search element we look right part of array and if middle element is greater than 
search element we look left part o
f array
.
 
Algorithm
 
 
Program
 
#include <stdio.h>
 
void
 
main()
 
{
 
  
 
 
int
 
i
, first, last, middle, n,
 
key
, array[100];
 
 
 
   
 
printf("Enter number of elements
\
n");
 
   
 
scanf("%d",&n);
 
 
   
 
printf("Enter %d integers
 
in sorted order
\
n", n);
 
 
   
 
for
 
(
 
i
 
= 0 ;
 
i
 
< n ;
 
i
++ )
 
 
{
 
      
 
 
scanf("%d",&array[
i
]);
 
 
}
 
 
   
 
printf("Enter value to find
\
n");
 
   
 
scanf("%d",&
key
);
 
# Input: Sorted Array A, integer key
 
# Output: first index of key in A, or 
-
1 if not found
 
 
Alg
orith: Binary
_Search
 
(A, left, right)
 
while left <= right
 
middle = index halfway between left, right
 
if D[middle] matches key
 
return middl
e
 
else if key less than A[middle]
 
right = middle 
-
1
 
else
 
left = middle + 1
 
return 
-
1
 

 
Sorting and Searching
 
 
Prof. Pradyumansinh Jadeja (9879461848)  | 
2130702 

 
Data Structure
 
19
 
 
 
 
   
 
first = 0;
 
   
 
last = n 
-
 
1;
 
   
 
middle = (first+last)/2;
 
 
 
  
 
 
while( first <= last )
 
   
 
{
 
      
 
 
if (
array[middle] ==
 
key
)
 
 
 
{
 
         
 
 
 
printf("%d found at location %d.
\
n",
 
key
, middle+1);
 
         
 
 
 
break;
 
 
 
}
 
      
 
 
else if ( array[middle]
>key
 
) 
 
     
 
 
 
{
 
 
 
 
Last=middle
 
-
 
1;
 
      
 
 
}
 
      
 
 
else
 
         
 
 
 
first
 
= middle 
+
 
1;
 
 
 
      
 
 
middle = (first + last)/2;
 
  
 
 
}
 
   
 
if ( first > last )
 
 
{
 
      
 
 
printf("Not found! %d is not present in the list.
\
n",
 
key
);
 
 
}
 
 
 
getch();
 
 
}
 
Example
 
 
Find 6 in {
-
1, 5, 6, 18, 19, 25, 46, 78, 102, 114}.
 
Step 1
 
--
>
 
(middle element is 19 > 6): Search in left part
 
 
 
-
1
 
 
5
 
 
6
 
 
18 
 
19
 
25
 
 
46
 
 
78
 
 
102
 
 
114
 
Step 2
 
--
>
 
(middle element is 5 < 6):
 
S
earch in Right part
 
 
 
-
1
 
 
 
5
 
 
 
6
 
 
18
 
 
Step 3
 
--
>
 
(middle element is 6 == 6):
 
Element Found
 
 
 
 
6
 
 
18
 
 
 

