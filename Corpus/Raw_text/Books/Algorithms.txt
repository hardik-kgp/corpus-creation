
1. PreviewTo introduce the general approach that we™ll be taking to studyingalgorithms, we™ll examine a classic elementary problem: ﬁReduce a givenfraction to lowest terms.ﬂWe want to write 213, not 416, 200/300, or 178468/267702. Solving this problem is equival.ent to finding the greatest commondivisor (gcd) of the numerator and the denominator: the largest integer whichdivides them both. A fraction is reduced to lowest terms by dividing bothnumerator and denominator by their greatest common divisor.PascalA concise description of the Pascal language is given in the Wirth and JensenPascal User Manual and Report that serves as the definition for the language.Our purpose here is not to repeat information from that book but rather toexamine the implementation of a few simple algorithms which illustrate someof the basic features of the language and. the style that we™ll be using.Pascal has a rigorous high-level syntax which allows easy identification ofthe main features of the program. The variables (var) and functions (function)used by the program are declared first, f~ollowed by the body of the program.(Other major program parts, not used in the program below which are declaredbefore the program body are constants and types.) Functions have the same
format as the main program except that they return a value, which is set by
assigning something to the function name within the body of the function.
(Functions that return no value are called procedures.)The built-in function readln reads a. line from the input and assigns thevalues found to the variables given as arguments; writeln is similar. A standardbuilt-in predicate, eof, is set to true when there is no more input. (Input andoutput within a line are possible with read, write, and eoln.) The declarationof input and output in the program statement indicates that the program isusing the ﬁstandardﬂ input and output &reams.9
10CHAPTER 1To begin, we™ll consider a Pascal program which is essentially a transla-tion of the definition of the concept of the greatest common divisor into aprogramming language.program example(input, output);var x, y: integer;function gcd( u, v: integer) : integer;var t: integer;beginif u<v then t:=u else t:=v;while (u mod t<>O) or (vmod t<>O) do t:=t-1;gcd:=tend ;beginwhile not eof dobeginreadln (x, y ) ;writeln(x, y, gcd(abs(x), abs(y)));endend.The body of the program above is trivial: it reads two numbers from theinput, then writes them and their greatest common divisor on the output.The gcd function implements a ﬁbrute-forceﬂ method: start at the smaller ofthe two inputs and test every integer (decreasing by one until 1 is reached)until an integer is found that divides both of the inputs. The built-in functionabs is used to ensure that gcd is called with positive arguments. (The modfunction is used to test whether two numbers divide: u mod v is the remainderwhen u is divided by v, so a result of 0 indicates that v divides u.)Many other similar examples are given in the Pascal User Manual andReport. The reader is encouraged to scan the manual, implement and testsome simple programs and then read the manual carefully to become reason-ably comfortable with most of the features of Pascal.Euclid™s AlgorithmA much more efficient method for finding the greatest common divisor thanthat above was discovered by Euclid over two thousand years ago. Euclid™smethod is based on the fact that if u is greater than v then the greatestcommon divisor of u and v is the same as the greatest common divisor of vand u - v. Applying this rule successively, we can continue to subtract offmultiples of v from u until we get a number less than v. But this number is
PREVIEW11exactly the same as the remainder left after dividing u by v, which is whatthe mod function computes: the greatee:t common divisor of u and v is thesame as the greatest common divisor of 1) and u mod v. If u mod v is 0, then vdivides u exactly and is itself their greatest common divisor, so we are done.This mathematical description explains how to compute the greatestcommon divisor of two numbers by computing the greatest common divisorof two smaller numbers. We can implement this method directly in Pascal
simply by having the gcd function call itself with smaller arguments:function gcd( u, v:integer) : integer;beginif v=O then gcd:= uelse gcd:=gcd(v, u mod v)end;(Note that if u is less than v, then u m™od v is just u, and the recursive calljust exchanges u and v so things work as described the next time around.)If the two inputs are 461952 and 116298, then the following table shows thevalues of u and v each time gcd is invoked:(461952,1:16298)(116298,1:13058)(113058,324O)(3240,2898)(2898,342)(342,162)(162,18)(1% 0)It turns out that this algorithm always uses a relatively small number ofsteps: we™ll discuss that fact in some moire detail below.RecursionA fundamental technique in the design of efficient algorithms is recursion:solving a problem by solving smaller versions of the same problem, as in theprogram above. We™ll see this general approach used throughout this book,and we will encounter recursion many tirnes. It is important, therefore, for usto take a close look at the features of the above elementary recursive program.An essential feature is that a recursive program must have a terminationcondition. It can™t always call itself, there must be some way for it to do
12CHAPTER 1something else. This seems an obvious point when stated, but it™s probablythe most common mistake in recursive programming. For similar reasons, oneshouldn™t make a recursive call for a larger problem, since that might lead toa loop in which the program attempts to solve larger and larger problems.Not all programming environments support a general-purpose recursionfacility because of intrinsic difficulties involved. Furthermore, when recursionis provided and used, it can be a source of unacceptable inefficiency. For these
reasons, we often consider ways of removing recursion. This is quite easy todo when there is only one recursive call involved, as in the function above. Wesimply replace the recursive call with a goto to the beginning, after insertingsome assignment statements to reset the values of the parameters as directedby the recursive call. After cleaning up the program left by these mechanicaltransformations, we have the following implementation of Euclid™s algorithm:function gcd(u, v:integer):integer;var t: integer;beginwhile v<>O dobegin t:= u mod v; u:=v; v:=t end;gcd:=uend ;Recursion removal is much more complicated when there is more thanone recursive call. The algorithm produced is sometimes not recognizable, andindeed is very often useful as a di.fferent way of looking at a fundamental al-gorithm. Removing recursion almost always gives a more efficient implemen-tation. We™ll see many examples of this later on in the book.Analysis of AlgorithmsIn this short chapter we™ve already seen three different algorithms for the sameproblem; for most problems there are many different available algorithms.How is one to choose the best implementation from all those available?This is actually a well developed area of study in computer science.Frequently, we™ll have occasion to call on research results describing the per-formance of fundamental algorithms. However, comparing algorithms can be
challenging indeed, and certain general guidelines will be useful.Usually the problems that we solve have a natural ﬁsizeﬂ (usually theamount of data to be processed; in the above example the magnitude ofthe numbers) which we™ll normally call N. We would like to know theresources used (most often the amount of time taken) as a function of N.We™re interested in the average case, the amount of time a program might be
expected to take on ﬁtypicalﬂ input data, and in the worst case, the amountof time a program would take on the worst possible input configuration.Many of the algorithms in this book are very well understood, to the pointthat accurate mathematical formulas are known for the average- and worst-case running time. Such formulas are developed first by carefully studyingthe program, to find the running time in terms of fundamental mathematicalquantities and then doing a mathematical analysis of the quantities involved.For some algorithms, it is easy to hgure out the running time. For ex-ample, the brute-force algorithm above obviously requires min(u, VU)-gcd(u, V)iterations of the while loop, and this quantity dominates the running time ifthe inputs are not small, since all the other statements are executed either0 or 1 times. For other algorithms, a substantial amount of analysis is in-volved. For example, the running time of the recursive Euclidean algorithmobviously depends on the ﬁoverheadﬂ required for each recursive call (whichcan be determined only through detailed1 knowledge of the programming en-vironment being used) as well as the number of such calls made (which canbe determined only through extremely sophisticated mathematical analysis).Several important factors go into this analysis which are somewhat out-side a given programmer™s domain of influence. First, Pascal programs aretranslated into machine code for a given computer, and it can be a challenging
task to figure out exactly how long even one Pascal statement might take to
execute (especially in an environment where resources are being shared, sothat even the same program could have varying performance characteristics).Second, many programs are extremely sensitive to their input data, and per-
formance might fluctuate wildly depending on the input. The average case
might be a mathematical fiction that is not representative of the actual data
on which the program is being used, and the worst case might be a bizarre
construction that would never occur in practice. Third, many programs of
interest are not well understood, and specific mathematical results may not
be available. Finally, it is often the case that programs are not comparable at
all: one runs much more efficiently on one particular kind of input, the other
runs efficiently under other circumstances.With these caveats in mind, we™ll use rough estimates for the runningtime of our programs for purposes of classification, secure in the knowledgethat a fuller analysis can be done for important programs when necessary.Such rough estimates are quite often easy to obtain via the old programmingsaw ﬁ90% of the time is spent in 10% of the code.ﬂ (This has been quoted inthe past for many different values of ﬁgo%.ﬁ)The first step in getting a rough estimate of the running time of a programis to identify the inner loop. Which instructions in the program are executedmost often? Generally, it is only a few instructions, nested deep within the
CHAPTER 1control structure of a program, that absorb all of the machine cycles. It isalways worthwhile for the programmer to be aware of the inner loop, just tobe sure that unnecessary expensive instructions are not put there.Second, some analysis is necessary to estimate how many times the innerloop is iterated. It would be beyond the scope of this book to describe themathematical mechanisms which are used in such analyses, but fortunatelythe running times many programs fall into one of a few distinct classes. When
possible, we™ll give a rough description of the analysis of the programs, but it
will often be necessary merely to refer to the literature. (Specific references
are given at the end of each major section of the book.) For example, the
results of a sophisticated mathematical argument show that the number ofrecursive steps in Euclid™s algorithm when u is chosen at random less than v isapproximately ((12 In 2)/7r2) 1n TJ. Often, the results of a mathematical analysisare not exact, but approximate in a precise technical sense: the result mightbe an expression consisting of a sequence of decreasing terms. Just as we are
most concerned with the inner loop of a program, we are most concerned with
the leading term (the largest term) of a mathematical expression.As mentioned above, most algorithms have a primary parameter N,usually the number of data items to be processed, which affects the runningtime most significantly. The parameter N might be the degree of a polyno-mial, the size of a file to be sorted or searched, the number of nodes in agraph, etc. Virtually all of the algorithms in this book have running time
proportional to one of the following functions:1Most instructions of most programs are executed once or at mostonly a few times. If all the instructions of a program have this
property, we say that its running time is constant. This is obviously
the situation to strive for in algorithm design.log NWhen the running time of a program is logarithmic, the programgets slightly slower as N grows.This running time commonly occursin programs which solve a big problem by transforming it into asmaller problem by cutting the size by some constant fraction. Forour range of interest, the running time can be considered to be lessthan a Yargeﬂ constant. The base of the logarithm changes theconstant, but not by much: when N is a thousand, log N is 3 if thebase is 10, 10 if the base is 2; when N is a million, 1ogN is twiceas great. Whenever N doubles, log N increases by a constant, butlog N doesn™t double until N increases to N2.NWhen the running time of a program is linear, it generally is the casethat a small amount of processing is done on each input element.
When N is a million, then so is the running time. Whenever N
PREVTEW15doubles, then so does the running time. This is the optimal situationfor an algorithm that must process N inputs (or produce N outputs).NlogN This running time arises in algorithms which solve a problem byN2N32Nbreaking it up into smaller subpr™oblems, solving them independently,and then combining the solutions. For lack of a better adjective(linearithmic?), we™ll say that th™e running time of such an algorithmis ﬁN log N.ﬂWhen N is a million, N log N is perhaps twentymillion. When N doubles, the running time more than doubles (butnot much more).When the running time of an algorithm is quadratic, it is practicalfor use only on relatively small problems. Quadratic running timestypically arise in algorithms which process all pairs of data items(perhaps in a double nested loop). When N is a thousand, the
running time is a million. Whenever N doubles, the running time
increases fourfold.Similarly, an algorithm which prlocesses triples of data items (perhapsin a triple-nested loop) has a cubic running time and is practical foruse only on small problems. VVhen N is a hundred, the runningtime is a million. Whenever N doubles, the running time increaseseightfold.Few algorithms with exponential running time are likely to be ap-propriate for practical use, though such algorithms arise naturally asﬁbrute-forceﬂ solutions to problems. When N is twenty, the runningtime is a million. Whenever N doubles, the running time squares!The running time of a particular prlogram is likely to be some constanttimes one of these terms (the ﬁleading termﬂ) plus some smaller terms. Thevalues of the constant coefficient and the terms included depends on the resultsof the analysis and on implementation details. Roughly, the coefficient of theleading term has to do with the number of instructions in the inner loop:at any level of algorithm design it™s prudent to limit the number of suchinstructions. For large N the effect of the leading term dominates; for smallN or for carefully engineered algorithms, more terms may contribute andcomparisions of algorithms are more difficult. In most cases, we™ll simply referto the running time of programs as ﬁlinear,ﬂ ﬁN log N, ﬂ ﬁcubic,ﬂ etc., withthe implicit understanding that more detailed analysis or empirical studiesmust be done in cases where efficiency is very important.A few other functions do arise. For example, an algorithm with N2inputs that has a running time that is cubic in N is more properly classedas an N3j2 algorithm. Also some algorithms have two stages of subproblemdecomposition, which leads to a running time proportional to N(log N)2. Both
CHAPTER 1of these functions should be considered to be much closer to N log N than toN2 for large N.One further note on the ﬁlogﬂ function. As mentioned above, the baseof the logarithm changes things only by a constant factor. Since we usuallydeal with analytic results only to within a constant factor, it doesn™t matter
much what the base is, so we refer to ﬁlogN,ﬂ etc. On the other hand,it is sometimes the case that concepts can be explained more clearly whensome specific base is used. In mathematics, the natz~ral logarithm (base e =2.718281828.. .) arises so frequently that a special abbreviation is commonlyused: log, N = In N. In computer science, the binary logarithm (base 2) arisesso frequently that the abbreviation log, N = lg N is commonly used. Forexample, lg N rounded up to the nearest integer is the number of bits requiredto represent N in binary.Implementing AlgorithmsThe algorithms that we will discuss in this book are quite well understood,but for the most part we™ll avoid excessively detailed comparisons. Our goalwill be to try to identify those algorithms which are likely to perform best fora given type of input in a given application.The most common mistake made in the selection of an algorithm is toignore performance characteristics. Faster algorithms are often more compli-cated, and implementors are often willing to accept a slower algorithm toavoid having to deal with added complexity. But it is often the case thata faster algorithm is really not much more complicated, and dealing withslight added complexity is a small price to pay to avoid dealing with a slowalgorithm. Users of a surprising number of computer systems lose substantialtime waiting for simple quadratic algorithms to finish when only slightly more
complicated N log N algorithms are available which could run in a fraction
the time.The second most common mistake made in the selection of an algorithmis to pay too much attention to performance characteristics. An N log Nalgorithm might be only slightly more complicated than a quadratic algorithmfor the same problem, but a better N log N algorithm might give rise to asubstantial increase in complexity (and might actually be faster only for verylarge values of N). Also, many programs are really run only a few times:the time required to implement and debug an optimized algorithm might besubstantially more than the time required simply to run a slightly slower one.The programs in this book use only basic features of Pascal, rather thantaking advantage of more advanced capabilities that are available in Pascaland other programming environments. Our purpose is to study algorithms,not systems programming nor advanced features of programming languages.
PREVIEW17It is hoped that the essential features of the algorithms are best exposedthrough simple direct implementations in a near-universal language. For the
same reason, the programming style is somewhat terse, using short variable
names and few comments, so that the control structures stand out. Theﬁdocumentationﬂ of the algorithms is the accompanying text. It is expectedthat readers who use these programs in actual applications will flesh them outsomewhat in adapting them for a particular use.
18Exercises1.2.3.4.
5.6.
7.8.9.10.Solve our initial problem by writing a Pascal program to reduce a givenfraction x/y to lowest terms.Check what values your Pascal system computes for u mod v when u andv are not necessarily positive. Which versions of the gcd work properlywhen one or both of the arugments are O?Would our original gcd program ever be faster than the nonrecursiveversion of Euclid™s algorithm?Give the values of u and v each time the recursive gcd is invoked afterthe initial call gcd(12345,56789).Exactly how many Pascal statements are executed in each of the threegcd implementations for the call in the previous exercise?Would it be more efficient to test for u>v in the recursive implementationof Euclid™s algorithm?Write a recursive program to compute the largest integer less than log, Nbased on the fact that the value of this function for N div 2 is one greaterthan for N if N > 1.Write an iterative program for the problem in the previous exercise. Also,write a program that does the computation using Pascal library sub-routines. If possible on your computer system, compare the performanceof these three programs.Write a program to compute the greatest common divisor of three integersu, v, and w.For what values of N is 10NlgN > 2N2? (Thus a quadratic algorithmis not necessarily slower than an NlogN one.)
19SOURCES for background materialA reader interested in learning more about Pascal will find a large numberof introductory textbooks available, for example, the ones by Clancy andCooper or Holt and Hune. Someone with experience programming in other
languages can learn Pascal effectively directly from the manual by Wirth andJensen. Of course, the most important thing to do to learn about the languageis to implement and debug as many programs as possible.Many introductory Pascal textbooks contain some material on data struc-tures. Though it doesn™t use Pascal, an important reference for further infor-mation on basic data structures is volume one of D.E. Knuth™s series on TheArt of Computer Programming. Not only does this book provide encyclopediccoverage, but also it and later books in the series are primary references formuch of the material that we™ll be covering in this book. For example, anyone
interested in learning more about Euclid™s algorithm will find about fifty pagesdevoted to it in Knuth™s volume two.Another reason to study Knuth™s volume one is that it covers in detailthe mathematical techniques needed for the analysis of algorithms. A readerwith little mathematical background sh™ould be warned that a substantialamount of discrete mathematics is required to properly analyze many algo-rithms; a mathematically inclined reader will find much of this material ablysummarized in Knuth™s first book and applied to many of the methods we™llbe studying in later books.M. Clancy and D. Cooper, Oh! Pascal, W. W. Norton & Company, New York,1982.R. Holt and J. P.Hume, Programming Standard Pascal, Reston (Prentice-Hall),Reston, Virginia, 1980.D. E. Knuth, The Art of Computer Programming. Volume 1: FundamentalAlgorithms, Addison-Wesley, Reading, MA, 1968.D. E. Knuth, The Art of Computer Programming. Volume .2: SeminumericalAlgorithms, Addison-Wesley, Reading, MA, Second edition, 1981.K. Jensen and N. Wirth, Pascal User Manual and Report, Springer-Verlag,New York, 1974.

MATHEMATICAL ALGORITHMS5*.a. .). . .. . . .I-. .. . . -.- ﬁ. -..m..‚.™l .™: -. .. :- .:-... : --:.:. . .- a-:.. . * . .- -*...‚..a.. .. ‚.:.. . . ..; . i... ..+.. --, ,.-. . . .., . . .:. :mm. . . . : . *™. . c -*.,- . .-. . .-- .l .- 5. - - /:.m. ..- . . - -. - . . 5.‚-‚-: . . . . : . I: :* . .. ‚...* -I--..:...

2. ArithmeticclAlgorithms for doing elementary arithmetic operations such as addition,multiplication, and division have a. very long history, dating back tothe origins of algorithm studies in the work of the Arabic mathematicianal-Khowdrizmi, with roots going even further back to the Greeks and theBabylonians.Though the situation is beginning to change, the raison d™e^tre of manycomputer systems is their capability for doing fast, accurate numerical cal-culations. Computers have built-in capabilities to perform arithmetic on in-tegers and floating-point representations of real numbers; for example, Pascalallows numbers to be of type integer or re;d, with all of the normal arithmeticoperations defined on both types. Algorithms come into play when the opera-tions must be performed on more complicated mathematical objects, such as
polynomials or matrices.In this section, we™ll look at Pascal implementations of some simplealgorithms for addition and multiplication of polynomials and matrices. Thealgorithms themselves are well-known and straightforward; we™ll be examining
sophisticated algorithms for these problems in Chapter 4. Our main purpose
in this section is to get used to treating th™ese mathematical objects as objectsfor manipulation by Pascal programs. This translation from abstract data tosomething which can be processed by a computer is fundamental in algorithmdesign. We™ll see many examples throughout this book in which a properrepresentation can lead to an efficient algorithm and vice versa. In thischapter, we™ll use two fundamental ways of structuring data, the array andthe linked list. These data structures are used by many of the algorithms inthis book; in later sections we™ll study some more advanced data structures.PolynomialsSuppose that we wish to write a program that adds two polynomials: we would23
24CJUJ™TER 2like it to perform calculations like(1+ 2x - 3x3) + (2 -x) = 3 + x - 3x3.In general, suppose we wish our program to be able to compute r(x) = p(x) +q(x), where p and q are polynomials with N coefficients. The followingprogram is a straightforward implementation of polynomial addition:program poJyadd(input, output);con& maxN=lOO;var p, q, r: array [ O..maxN] of real;N, i: integer;beginreadln (N) ;for i:=O to N-l do read(p[i]);for i:=O to N-l do read(q[i]);for i:=O to N-J do r[i] :=p[i]+q[i];for i:=O to N-l do write(r[i]);wri telnend.In this program, the polynomial p(z) = pc + pix + a.. + pr\r-isN-™ isrepresented by the array p [O..N-l] with p [j] = pj, etc. A polynomial of degreeN-l is defined by N coefficients. The input is assumed to be N, followed bythe p coefficients, followed by the q coefficients. In Pascal, we must decideahead of time how large N might get; this program will handle polynomialsup to degree 100. Obviously, maxN should be set to the maximum degreeanticipated. This is inconvenient if the program is to be used at differenttimes for various sizes from a wide range: many programming environments
allow ﬁdynamic arraysﬂ which, in this case, could be set to the size N. We™ll
see another technique for handling this situation below.The program above shows that addition is quite trivial once this repre-sentation for polynomials has been chosen; other operations are also easilycoded. For example, to multiply we can replace the third for loop byfor i:=O to 2*(N-I) do r[i] :=O;for i:=O to N-l dofor j:=O to N-l dorTi+j]:=r[i+j]+p[i]*qb];
ARITHMETICAlso, the declaration of r has to be suita.bly changed to accomodate twice asmany coefficients for the product. Each of the N coefficients of p is multipliedby each of the N coefficients of q, so this is clearly a quadratic algorithm.An advantage of representing a polynomial by an array containing itscoefficients is that it™s easy to reference any coefficient directly; a disadvantageis that space may have to be saved for more numbers than necessary. For
example, the program above couldn™t reasonably be used to multiply(1+ .10000)(1+ 2,lOOOO) = 1+ 3~10000 + 2~20000,even though the input involves only four c™oefficients and the output only three.An alternate way to represent a pol:ynomial is to use a linked list. Thisinvolves storing items in noncontiguous memory locations, with each itemcontaining the address of the next. The Pascal mechanisms for linked lists aresomewhat more complicated than for arrays. For example, the following pro-gram computes the sum of two polynomials using a linked list representation(the bodies of the readlist and add functions and the writelist procedure aregiven in the text following):program polyadd(input, output);type link q = mode;node = record c: real; next: link end ;var N: integer; a: link;function readlist(N: integer) : link;procedure writelist(r: link);function add(p, q: link) : link;beginreadln(N); new(z);writelist(add(readlist(N), readlist(Nend.The polynomials are represented by linked lists which are built by thereadlist procedure. The format of these is described in the type statement:the lists are made up of nodes, each node containing a coefficient and a linkto the next node on the list. If we have a link to the first node on a list, thenwe can examine the coefficients in order, by following links. The last nodeon each list contains a link to a special (dummy node called a: if we reach zwhen scanning through a list, we know we™re at the end. (It is possible to getby without such dummy nodes, but they do make certain manipulations onthe lists somewhat simpler.) The type statement only describes the formatsof the nodes; nodes can be created only when the builtin procedure new iscalled. For example, the call new(z) creates a new node, putting a pointer to
26CHAPTER 2it in a. (The other nodes on the lists processed by this program are createdin the readlist and add routines.)The procedure to write out what™s on a list is the simplest. It simplysteps through the list, writing out the value of the coefficient in each nodeencountered, until z is found:procedure writelist(r: link);beginwhile r<>z dobegin write(rf.c); r:=rt.next end;wri telnend ;The output of this program will be indistinguishable from that of theprogram above which uses the simple array representation.Building a list involves first calling new to create a node, then filling inthe coefficient, and then linking the node to the end of the partial list built sofar. The following function reads in N coefficients, assuming the same formatas before, and constructs the linked list which represents the correspondingpolynomial:function readlist (N: integer) : link;var i: integer; t: link;begint:=z;for i:=O to N-l dobegin new(tf.next); t:=tt.next; read(tt.c) end;tf.next:=z; readlist:=zf.next; zf.next:=zend ;The dummy node z is used here to hold the link which points to the first nodeon the list while the list is being constructed. After this list is built, a is setto link to itself. This ensures that once we reach the end of a list, we staythere. Another convention which is sometimes convenient, would be to leave zpointing to the beginning, to provide a way to get from the back to the front.Finally, the program which adds two polynomials constructs a new listin a manner similar to readlist, calculating the coefficients for the resultby stepping through the argument lists and adding together correspondingcoefficients:
ARITHM73TIC27function add(p, q: link): link;var t : link ;begint:=z;repeatnew(tt.next); t:=tf.next;tf.c:=pt.c+qf.c;p:=pf.next; q:=qf.nextuntil (p=z) and (q=z);tt.next:=z; add:=zt.nextend ;Employing linked lists in this way, we use only as many nodes as arerequired by our program. As N gets larger, we simply make more calls on new.By itself, this might not be reason enough. to use linked lists for this program,because it does seem quite clumsy comlpared to the array implementationabove. For example, it uses twice as much space, since a link must be storedalong with each coefficient. However, as suggested by the example above, wecan take advantage of the possibility that many of the coefficients may be zero.We can have list nodes represent only the nonzero terms of the polynomial byalso including the degree of the term represented within the list node, so thateach list node contains values of c and j to represent cxj. It is then convenientto separate out the function of creating a node and adding it to a list, asfollows:type link = fnode;node = record c: real; j: integer; next: link end;function listadd(t: link; c: real; j: integer): link;beginnew(tf.next); t:=tT.next;tf.c:=c; tt.j:=j;listadd:=t;end ;The listadd function creates a new node, gives it the specified fields, and linksit into a list after node t. Now the readlist routine can be changed either toaccept the same input format as above (a:nd create list nodes only for nonzerocoefficients) or to input the coefficient and exponent directly for terms withnonzero coefficient. Of course, the write,!ist function also has to be changedsuitably. To make it possible to process the polynomials in an organized
28CIZ4PTER 2way, the list nodes might be kept in increasing order of degree of the termrepresented.Now the add function becomes more interesting, since it has to performan addition only for terms whose degrees match, and then make sure that noterm with coefficient 0 is output:function add(p, q: link): link;begint:=z; st.j:=iV+l;repeatif (pf.j=qf.j) and (pf.c+qf.c<>O.O) thenbegint:=listadd(t,pf.c+qt.c,pt.j);p:=pt.next; q:=qf.nextendelse if pf.j<qt.j thenbegin t:=listadd(t, pt.c, pf.j); p:=pt.next endelse if qf.j<pt.j thenbegin t:=listadd(t, qf.c, q1.j); q:=qt.next end;until (p=z) and (q=z);tf.next:=z; add:=zf.nextend ;These complications are worthwhile for processing ﬁsparseﬂ polynomialswith many zero coefficients, but the array representation is better if there areonly a few terms with zero coefficients. Similar savings are available for other
operations on polynomials, for example multiplication.MatricesWe can proceed in a similar manner to implement basic operations on two-dimensional matrices, though the programs become more complicated. Sup-pose that we want to compute the sum of the two matricesThis is term-by-term addition, just as for polynomials, so the addition pro-gram is a straightforward extension of our program for polynomials:
ARITHMETIC29program matrixadd(input, output);const maxN=lO;var p, q, r: array [O..maxN, O..maxN] of real;N, i, j: integer;beginreadln (N) ;for i:=O to N-l do for j:=O to N-l do read(p[i, j]);for i:=O to N-l do for j:=O to N-l do read(q[i, j]);for i:=O to N-l do for j:=O to N-l do r[i, j]:=p[i, j]+q[i, j];for i:=O to N-l do for j:=O to N doif j=N then writeln else write(r[i, j]);end.Matrix multiplication is a more complicated operation. For our example,Element r[i, j] is the dot product of the ith row of p with the jth columnof q. The dot product is simply the sum of the N term-by-term multiplica-tions p[i, l]*q[l, j]+p[i, 2]*q[2, j]+... p[i, N-l]*q[N-I, j] as in the followingprogram:for i:=O to h-1 dofor j:=O to N-l dobegint:=o.o;for k:=iO to N-l do t:=t+p[i, k]*q[k, j];r[i, j]:=tend ;Each of the N2 elements in the result matrix is computed with N mul-tiplications, so about N3 operations are required to multiply two N by Nmatrices together. (As noted in the previous chapter, this is not really a cubicalgorithm, since the number of data items in this case is about N2, not N.)As with polynomials, sparse matrices (those with many zero elements) canbe processed in a much more efficient manner using a linked list representation.To keep the two-dimensional structure intact, each nonzero matrix elementis represented by a list node containing ,a value and two links: one pointingto the next nonzero element in the same row and the other pointing to thenext nonzero element in the same column. Implementing addition for sparse
CHAPTER 2matrices represented in this way is similar to our implementation for sparsepolynomials, but is complicated by the fact that each node appears on twolists.Data StructuresEven if there are no terms with zero coefficients in a polynomial or no zeroelements in a matrix, an advantage of the linked list representation is that wedon™t need to know in advance how big the objects that we™ll be processingare. This is a significant advantage that makes linked structures preferablein many situations. On the other hand, the links themselves can consume asignificant part of the available space, a disadvantage in some situations. Also,access to individual elements in linked structures is much more restricted than
in arrays.We™ll see examples of the use of these data structures in various algo-rithms, and we™ll see more complicated data structures that involve moreconstraints on the elements in an array or more pointers in a linked repre-sentation. For example, multidimensional arrays can be defined which usemultiple indices to access individual items.Similarly, we™ll encounter manyﬁmultidimensionalﬂ linked structures with more than one pointer per node.The tradeoffs between competing structures are usually complicated, anddifferent structures turn out to be appropriate for different situations.When possible it is wise to think of the data and the specific operationsto be performed on it as an abstract data structure which can be realized inseveral ways. For example, the abstract data structure for polynomials in theexamples above is the set of coefficients: a user providing input to one of theprograms above need not know whether a linked list or an array is being used.
Modern programming systems have sophisticated mechanisms which make
it possible to change representations easily, even in large, tightly integratedsystems.
AFUTHAJETIC31Exercises1.2.3.4.5.6.7.8.9.10.Another way to represent polynomials is to write them in the form rc(x-rr)(z - r2) . . . (X - TN). How would you multiply two polynomials in thisrepresentation?How would you add two polynomials represented as in Exercise l?Write a Pascal program that multiplies two polynomials, using a linkedlist representation with a list node for each term.Write a Pascal program that multiplies sparse polynomials, using a linkedlist representation with no nodes for terms with 0 coefficients.Write a Pascal function that returns the value of the element in the ithrow and jth column of a sparse matrix, assuming that the matrix isrepresented using a linked list representation with no nodes for 0 entries.Write a Pascal procedure that sets the value of the element in the ithrow and jth column of a sparse matrix to v, assuming that the matrix isrepresented using a linked list representation with no nodes for 0 entries.What is the running time of matrix multiplication in terms of the numberof data items?Does the running time of the polynornial addition programs for nonsparseinput depend on the value of any of the coefficients?Run an experiment to determine which of the polynomial addition programs runs fastest on your computer system, for relatively large N.Give a counterexample to the assertion that the user of an abstract datastructure need not know what representation is being used.

3. Random NumbersOur next set of algorithms will bie methods for using a computer togenerate random numbers. We will find many uses for random numberslater on; let™s begin by trying to get a better idea of exactly what they are.Often, in conversation, people use the term random when they reallymean arbitrary. When one asks for an trrbitrary number, one is saying thatone doesn™t really care what number one gets: almost any number will do.By contrast, a random number is a precisely defined mathematical concept:
every number should be equally likely to occur. A random number will satisfysomeone who needs an arbitrary number, but not the other way around.For ﬁevery number to be equally likely to occurﬂ to make sense, we mustrestrict the numbers to be used to some finite domain. You can™t have arandom integer, only a random integer in some range; you can™t have a random
real number, only a random fraction in some range to some fixed precision.It is almost always the case that not just one random number, but asequence of random numbers is needed (otherwise an arbitrary number mightdo). Here™s where the mathematics comes in: it™s possible to prove many factsabout properties of sequences of random numbers. For example, we can expectto see each value about the same number of times in a very long sequenceof random numbers from a small domain. Random sequences model manynatural situations, and a great deal is known about their properties. To beconsistent with current usage, we™ll refer to numbers from random sequencesas random numbers.There™s no way to produce true random numbers on a computer (or anydeterministic device). Once the program is written, the numbers that it willproduce can be deduced, so how could they be random? The best we can hopeto do is to write programs which produce isequences of numbers having many ofthe same properties as random numbers. Such numbers are commonly calledpseudo-random numbers: they™re not really random, but they can be useful33
CHAF™TER 3as approximations to random numbers, in much the same way that floating-point numbers are useful as approximations to real numbers. (Sometimes it™sconvenient to make a further distinction: in some situations, a few properties
of random numbers are of crucial interest while others are irrelevant. In
such situations, one can generate quasi-random numbers, which are sure to
have the properties of interest but are unlikely to have other properties of
random numbers. For some applications, quasi-random numbers are provablypreferable to pseudo-random numbers.)It™s easy to see that approximating the property ﬁeach number is equallylikely to occurﬂ in a long sequence is not enough. For example, each number inthe range [l,lOO] appears once in the sequence (1,2,. . . ,lOO), but that sequenceis unlikely to be useful as an approximation to a random sequence. In fact,in a random sequence of length 100 of numbers in the range [l,lOO], it islikely that a few numbers will appear more than once and a few will notappear at all. If this doesn™t happen in a sequence of pseudo-random numbers,
then there is something wrong with the random number generator. Many
sophisticated tests based on specific observations like this have been devised
for random number generators, testing whether a long sequence of pseudo
random numbers has some property that random numbers would. The randomnumber generators that we will study do very well in such tests.We have been (and will be) talking exclusively about uniform randomnumbers, with each value equally likely. It is also common to deal with randomnumbers which obey some other distribution in which some values are morelikely than others. Pseudo-random numbers with non-uniform distributionsare usually obtained by performing some operations on uniformly distributedones. Most of the applications that we will be studying use uniform randomnumbers.ApplicationsLater in the book we will meet many applications in which random numberswill be useful. A few of them are outlined here. One obvious application is incryptography, where the major goal is to encode a message so that it can™t beread by anyone but the intended recipient. As we will see in Chapter 23, oneway to do this is to make the message look random using a pseudo-randomsequence to encode the message, in such a way that the recipient can use thesame pseudorandom sequence to decode it.Another area in which random numbers have been widely used is insimulation. A typical simulation involves a large program which models someaspect of the real world: random numbers are natural for the input to suchprograms. Even if true random numbers are not needed, simulations typically
need many arbitrary numbers for input, and these are conveniently provided
by a random number generator.
RANDOM NUMBERS35When a very large amount of data is to be analyzed, it is sometimessufficient to process only a very small amount of the data, chosen accordingto random sampling. Such applications are widespread, the most prominentbeing national political opinion polls.Often it is necessary to make a choice when all factors under considerationseem to be equal. The national draft lottery of the 70™s or the mechanismsused on college campuses to decide which students get the choice dormitoryrooms are examples of using random numbers for decision making. In this
way, the responsibility for the decision is given to ﬁfateﬂ (or the computer).Readers of this book will find themselves using random numbers exten-sively for simulation: to provide random or arbitrary inputs to programs.Also, we will see examples of algorithms which gain efficiency by using random
numbers to do sampling or to aid in decision making.Linear Congruential MethodThe most well-known method for generating random numbers, which has beenused almost exclusively since it was introduced by D. Lehmer in 1951, is theso-called linear congruential method. If a [I]contains some arbitrary number,then the following statement fills up an array with N random numbers usingthis method:for i:=2 to N doa[i]:=(a[i-l]*b $1) mod mThat is, to get a new random number, take the previous one, multiplyit by a constant b, add 1 and take the remainder when divided by a secondconstant m. The result is always an integer between 0 and m-l. This isattractive for use on computers because the mod function is usually trivial toimplement: if we ignore overflow on the arithmetic operations, then most com-puter hardware will throw away the bits that overflowed and thus effectively
perform a mod operation with m equal to one more than the largest integerthat can be represented in the computer word.Simple as it may seem, the linear congruential random number generatorhas been the subject of volumes of detailed and difficult mathematical analysis.This work gives us some guidance in choosing the constants b and m. Someﬁcommon-senseﬂ principles apply, but in this case common sense isn™t enoughto ensure good random numbers. First, m should be large: it can be thecomputer word size, as mentioned above,but it needn™t be quite that largeif that™s inconvenient (see the implementation below). It will normally beconvenient to make m a power of 10 or 2. Second, b shouldn™t be too large ortoo small: a safe choice is to use a number with one digit less than m. Third,
CHAPTER 3b should be an arbitrary constant with no particular pattern in its digits,except that it should end with*-~21, with z even: this last requirement isadmittedly peculiar, but it prevents the occurrence of some bad cases thathave been uncovered by the mathematical analysis.The rules described above were developed by D.E.Knuth, whose textbookcovers the subject in some detail. Knuth shows that these choices will makethe linear congruential method produce good random numbers which passseveral sophisticated statistical tests.The most serious potential problem,which can become quickly apparent, is that the generator could get caughtin a cycle and produce numbers it has already produced much sooner thanit should. For example, the choice b=l9, m=381, with a[ I] =O, produces thesequence 0,1,20,0,1,20 ,...,a notrvery-random sequence of integers between 0and 380.Any initial value can be used to get the random number generator startedwith no particular effect except of course that different initial values will giverise to different random sequences.Often, it is not necessary to store thewhole sequence as in the program above. Rather, we simply maintain a globalvariable a, initialized with some value, then updated by the computationa:=(a*b+l) mod m.In Pascal (and many other programming languages) we™re still one stepaway from a working implementation because we™re not allowed to ignoreoverflow: it™s defined to be an error condition that can lead to unpredictable
results. Suppose that we have a computer with a 32-bit word, and we choose
m =190000000, b=3f 415821, and, initially, a=1234567. All of these values arecomfortably less than the largest integer that can be represented, but the firsta* b+l operation causes overflow.The part of the product that causes theoverflow is not relevant to our computation, we™re only interested in the lasteight digits. The trick is to avoid overflow by breaking the multiplication up
into pieces. To multiply p by q, we write p = 104pr + pc and q = 104qr + qo,so the product isPq= (104Pl + po)(104q1 + qo)= lo8Plql + 104(p1qo + poq1) + poqo.Now, we™re only interested in eight digits for the result, so we can ignorethe first term and the first four digits of the second term. This leads to thefollowing program:
RAAJDOM NUMBERS37program random (inpu t, output) ;con& m=100000000; ml=lOOOO; b=31415821;var i, a, IV: integer;function mult(p, q: integer): integer;var pl, ~0, ql, q0: integer;beginpl :=p div ml ; pO:=p mod ml ;ql :=q div ml; qO:=q mod ml;mult:=( ((pO*ql+pl*qO) mod ml)*ml+pO*qO) mod m;end ;function random : integer ;begina:=(mult(a, b)+l) mod m;random :=a;end ;beginread(hJ, a);for i:=l to N do writeln(random)end.The function mult in this program computes p*q mod m, with no overflowas long as m is less than half the largest integer that can be represented. Thetechnique obviously can be applied with m=ml*ml for other values of ml.Here are the ten numbers produced by this program with the input N =10 and a = 1234567:358845™0880001069635126504363565110344728718151369171742098556711595659939877There is some obvious non-randomness in these numbers: for example,the last digits cycle through the digits O-9. It is easy to prove from theformula that this will happen. Generally speaking, the digits on the right are
CHAPTER 3not particularly random. This leads to a common and serious mistake in theuse of linear congruential random number generators: the following is a bad
program for producing random numbers in the range [0, r - 11:function randombad(r: integer) : integer;begina:=(mult(b, a)+l) mod m;randombad:=a mod r;end ;The non-random digits on the right are the only digits that are used,so the resulting sequence has few of the desired properties. This problem iseasily fixed by using the digits on the left. We want to compute a numberbetween 0 and r-l by computing a*r mod m, but, again, overflow must becircumvented, as in the following implementation:function randomint(r: integer): integer;begina:=(mult(a, b)+l) mod m;randomint:=((a div ml)*r) div mlend ;Another common technique is to generate random real numbers between0 and 1 by treating the above numbers as fractions with the decimal pointto the left. This can be implemented by simply returning the real value a/m
rather than the integer a. Then a user could get an integer in the range [O,r)by simply multiplying this value by r and truncating to the nearest integer.Or, a random real number between 0 and 1 might be exactly what is needed.Additive Congruential MethodAnother method for generating random numbers is based on linear feedbackshift registers which were used for early cryptographic encryption machines.The idea is to start with a register filled with some arbitrary pattern, thenshift it right (say) a step at a time, filling in vacated positions from the leftwith a bit determined by the contents of the register. The diagram belowshows a simple 4-bit register, with the new bit taken as the ﬁexclusive orﬂ ofthe two rightmost bits.
RANDOM NUMBERS39Below are listed the contents of the register for the first sixteen steps ofthe process:0 1 2 3 4 5 6 71011 0101 1010 1101 1110 1111 0111 00118 9 10 11 12 13 14 150001 1000 0100 0010 1001 1100 0110 1011Notice that all possible nonzero bit patterns occur, the starting valuerepeats after 15 steps. As with the linear congruential method, the mathe-matics of the properties of these registers has been studied extensively. For
example, much is known about the choices of ﬁtapﬂ positions (the bits used
for feedback) which lead to the generation of all bit patterns for registers ofvarious sizes.Another interesting fact is that the calculation can be done a word at atime, rather than a bit at a time, according to the same recursion formula.In our example, if we take the bitwise ﬁexclusive orﬂ of two successive words,we get the word which appears three places later in the list. This leadsus to a random number generator suitable for easy implementation on ageneral-purpose computer. Using a feedblack register with bits b and c tappedcorresponds to using the recursion: a[k]==(a[k-b]+a[k-c]) mod m. To keepthe correspondence with the shift register model, the ﬁ+ﬂ in this recursionshould be a bitwise ﬁexclusive or.ﬂHowever, it has been shown that goodrandom numbers are likely to be produced even if normal integer addition isused. This is termed the additive congwential method.To implement this method, we need to keep a table of size c which alwayshas the c most recently generated num.bers. The computation proceeds byreplacing one of the numbers in the table by the sum of two of the othernumbers in the table. Initially, the tablse should be filled with numbers thatare not too small and not too large. (‚One easy way to get these numbersis to use a simple linear congruential generator!) Knuth recommends thechoices b=31, c=55 will work well for most applications, which leads to theimplementation below.
40CHAPTER 3procedure randinit (s: integer) ;begina[O] :=s; j:=O;repeat j:=j+l; ab]:=(mult(b, alj--l])+l) mod m until j=54;end ;function randomint(r: integer): integer;beginj:=(j+l) mod 5.5;alj]:=(a[(j+23)mod 55]+a [ (jf54) mod 551) mod m;randomint:=((ab] div ml)*r) div mlend;The program maintains the 55 most recently generated numbers, with the lastgenerated pointed to by j. Thus, the global variable a has been replaced bya full table plus a pointer (j) into it. This large amount of ﬁglobal stateﬂ is adisadvantage of this generator in some applications, but it is also an advantagebecause it leads to an extremely long cycle even if the modulus m is small.The function randomint returns a random integer between 0 and r-l. Ofcourse, it can easily be changed, just as above, to a function which returns arandom real number between 0 and 1 (a b]/m).Testing RandomnessOne can easily detect numbers that are not random, but certifying that asequence of numbers is random is a difficult task indeed. As mentioned above,
no sequence produced by a computer can be random, but we want a sequencethat exhibits many of the properties of random numbers. Unfortunately, it isoften not possible to articulate exactly which properties of random numbersare important for a particular application.On the other hand, it is always a good idea to perform some kind of teston a random number generator to be sure that no degenerate situations haveturned up. Random number generators can be very, very good, but whenthey are bad they are horrid.Many tests have been developed for determining whether a sequenceshares various properties with a truly random sequence. Most of these testshave a substantial basis in mathematics, and it would definitely be beyond thescope of this book to examine them in detail. However, one statistical test,the x2 (chi-square) test, is fundamental in nature, quite easy to implement,and useful in several applications, so we™ll examine it more carefully.The idea of the x2 test is to check whether or not the numbers producedare spread out reasonably. If we generate N positive numbers less than r, then
RAh™DOM NUA4BERS41we™d expect to get about N/r numbers o:f each value. (But the frequencies ofoccurrence of all the values should not be exactly the same: that wouldn™t berandom!) It turns out that calculating whether or not a sequence of numbers
is distributed as well as a random sequence is very simple, as in the followingprogram:function t:hisquare(N, r, s: integer) : real;var i, t: integer;f: array [O..rmax] of integer;beginran&nit(s);for i:=O to rmax do f[i] :=O;for i:=l to Ndobegint:=ranndomint(r);f[t]::=f[t]+l;end ;t:=O; for i:=O to r-l do t:=t+f[i]*f[i];chisquare:= ((r*t/N) - N);end ;We simply calculate the sum of the squares of the frequencies of occur-rence of each value, scaled by the expected frequency then subtract off thesize of the sequence. This number is called the ﬁx2 statistic,ﬂ which may beexprebsed mathematically asx2 = Co<i<T(fi -WYN/r ™If the x2 statistic is close to r, then the numbers are random; if it is too faraway, then they are not. The notions of ﬁcloseﬂ and ﬁfar awayﬂ can be moreprecisely defined: tables exist which tell exactly how to relate the statistic to
properties of random sequences. For the simple test that we™re performing,
the statistic should be within 2fi of r. This is valid if N is bigger than about107, and to be sure, the test should be tried a few times, since it could bewrong about one out of ten times.This test is so simple to implement that it probably should be includedwith every random number generator, just to ensure that nothing unexpectedcan cause serious problems. All the ﬁgood generatorsﬂ that we have discussedpass this test; the ﬁbad onesﬂ do not. Using the above generators to generate
a thousand numbers less than 100, we get a x2 statistic of 100.8 for the
CHAPTER 3linear congruential method and 105.4 for the additive congruential method,both certainly well within 20 of 100. But for the ﬁbadﬂ generator which uses
the rightrhand bits from the linear congruential generator the statistic is 0(why?) and for a linear congruential method with a bad multiplier (101011)the statistic is 77.8, which is significantly out of range.Implementation NotesThere are a number of facilities commonly added to make a random numbergenerator useful for a variety of applications. Usually, it is desirable to set
up the generator as a function that is initialized and then called repeatedly,returning a different random number each time. Another possibility is to callthe random number generator once, having it fill up an array with all the
random numbers that will be needed for a particular computation. In either
case, it is desirable that the generator produce the same sequence on successive
calls (for initial debugging or comparison of programs on the same inputs) and
produce an arbitrary sequence (for later debugging). These facilities all involve
manipulating the ﬁstateﬂ retained by the random number generator between
calls. This can be very inconvenient in some programming environments. The
additive generator has the disadvantage that it has a relatively large state (thearray of recently produced words), but it has the advantage of having such along cycle that it is probably not necessary for each user to initialize it.A conservative way to protect against eccentricities in a random numbergenerator is to combine two generators. (The use of a linear congruentialgenerator to initialize the table for an additive congruential generator is
an elementary example of this.) An easy way to implement a combinationgenerator is to have the first generator fill a table and the second chooserandom table positions to fetch numbers to output (and store new numbersfrom the first generator).When debugging a program that uses a random number generator, it isusually a good idea to use a trivial or degenerate generator at first, such asone which always returns 0 or one which returns numbers in order.As a rule, random number generators are fragile and need to be treatedwith respect. It™s difficult to be sure that a particular generator is goodwithout investing an enormous amount of effort in doing the various statistical
tests that have been devised. The moral is: do your best to use a good
generator, based on the mathematical analysis and the experience of others;just to be sure, examine the numbers to make sure that they ﬁlookﬂ random;if anything goes wrong, blame the random number generator!
RAh™DOM MJM73ERS43Exercises1. Write a program to generate random four-letter words (collections ofletters). Estimate how many words your program will generate beforea word is repeated.2. How would you simulate generating random numbers by throwing twodice and taking their sum, with the added complication that the dice arenonstandard (say, painted with the numbers 1,2,3,5,8, and 13)?3.What is wrong with the following linear feedback shift register?4. Why wouldn™t the ﬁorﬂ or ﬁandﬂ function (instead of the ﬁexclusive orﬂfunction) work for linear feedback shift registers?5.Write a program to produce a randorn two dimensional image. (Example:generate random bits, write a ﬁ*ﬂ when 1 is generated, ﬂ ﬂ when 0 isgenerated. Another example: use random numbers as coordinates in atwo dimensional Cartesian system, write a ﬁ*ﬂ at addressed points.)6.Use an additive congruential random number generator to generate 1000positive integers less than 1000. Design a test to determine whether or
not they™re random and apply the test.7.Use a linear congruential generator .with parameters of your own choos-ing to generate 1000 positive integers less than 1000. Design a test todetermine whether or not they™re random and apply the test.8.Why would it be unwise to use, for example, b=3 and c=6 in the additivecongruential generator?9. What is the value of the x2 statistic for a degenerate generator whichalways returns the same number?10. Describe how you would generate random numbers with m bigger thanthe computer word size.

4. PolynomialsThe methods for doing arithmetic operations given in Chapter 2 aresimple and straightforward solutions to familiar problems. As such, theyprovide an excellent basis for applying allgorithmic thinking to produce moresophisticated methods which are substantially more efficient. As we™ll see, itis one thing to write down a formula which implies a particular mathematical
calculation; it is quite another thing to write a computer program which
performs the calculation efficiently.Operations on mathematical objects are far too diverse to be cataloguedhere; we™ll concentrate on a variety of algorithms for manipulating polyno-mials.The principal method that we™ll study in this section is a polynomial multiplication scheme which is of no particular practical importance butwhich illustrates a basic design paradigm called divide-and-conquer which ispervasive in algorithm design. We™ll see in this section how it applies to matrixmultiplication as well as polynomial multiplication; in later sections we™ll see
it applied to most of the problems that we encounter in this book.EvaluationA first problem which arises naturally is to compute the value of a givenpolynomial at a given point. For example, to evaluatep(x) = x4 + 3x3 - 6x2 + 2x + 1for any given x, one could compute x4,then compute and add 3x3, etc. Thismethod requires recomputation of the powers of x; an alternate method, whichrequires extra storage, would save the powers of x as they are computed.A simple method which avoids recomputation and uses no extra spaceis known as Homer™s rule: by alternat:ing the multiplication and additionoperations appropriately, a degree-N polynomial can be evaluated using only45
46CHAPTER 4N - 1 multiplications and N additions. The parenthesizationP(X) = x(x(x(x + 3) - 6) + 2) + 1makes the order of computation obvious:Y:=PN;for i:=N-I downto 0 do y:=x*y+p[i];This program (and the others in this section) assume the array representationfor polynomials that we discussed in Chapter 2.A more complicated problem is to evaluate a given polynomial at manydifferent points. Different algorithms are appropriate depending on how manyevaluations are to be done and whether or not they are to be done simul-taneously. If a very large number of evaluations is to be done, it may be
worthwhile to do some ﬁprecomputingﬂ which can slightly reduce the costfor later evaluations. Note that using Horner™s method would require aboutN2 multiplications to evaluate a degree-N polynomial at N different points.Much more sophisticated methods have been designed which can solve theproblem in N(logN)™ steps, and in Chapter 36 we™ll see a method that usesonly N log N multiplications for a specific set of N points of interest.If the given polynomial has only one term, then the polynomial evalua-tion problem reduces to the exponentiation problem: compute xN. Horner™srule in this case degenerates to the trivial algorithm which requires N - 1multiplications. For an easy example of how we can do much better, considerthe following sequence for computing x32:x z2 x4 x8 x16 32I 7 f f7x .Each term is obtained by squaring the previous term, so only five multiplica-tions are required (not 31).The ﬁsuccessive squaringﬂ method can easily be extended to general Nif computed values are saved. For example, x55 can be computed from theabove values with four more multiphcations:In general, the binary representation of N can be used to choose whichcomputed values to use. (In the example, since 55 = (110111)2, all but x8are used.) The successive squares can be computed and the bits of N testedwithin the same loop. Two methods are available to implement this using only
PoLYNoMlALs47one ﬁaccumulator,ﬂlike Horner™s method. One algorithm involves scanningthe binary representation of N from left to right, starting with 1 in theaccumulator. At each step, square the accumulator and also multiply by zwhen there is a 1 in the binary representation of N. The following sequenceof values is computed by this method for N = 55:1 1 z x2 x3 x6 xl226 27 54 557,) 7 I,,xlZi,x ,x ,x ,x .; // *~Another well-known alforithm whks similarly, bht scans N from right toleft. This problem is a standard introductory programming exercise, but it ishardly of practical interest.InterpolationThe ﬁinverseﬂ problem to the problem of evaluating a polynomial of degree Nat N points simultaneously is the problem of polynomial interpolation: givena set of N points x1 ,x2,. . . ,xN and associated values yr,y2,. . . ,yN, find theunique polynomial of degree N - 1 which1 hasp(Xl)= Yl,P(zz)= Y21 . . ..?'(xN) = YN.The interpolation problem is to find the polynomial, given a set of points andvalues. The evaluation problem is to find the values, given the polynomial
and the points. (The problem of finding the points, given the polynomial and
the values, is root-finding.)The classic solution to the interpolation problem is given by Lagrange™sinterpolation formula, which is often used as a proof that a polynomial ofdegree N - 1 is completely determined by N points:This formula seems formidable at first but is actually quite simple. Forexample, the polynomial of degree 2 which has p(l) = 3, p(2) = 7, and p(3) =13 is given byP(X) = 3x-2x-31-21-3+7s!s+13s5=jwhich simplifies tox2 +a:+ 1.For x from xl, x2, . . . ,XN, the formula is constructed so that p(xk) = yk for1 5 k 5 N, since the product evaluates to 0 unless j = k, when it evaluates
48CHAPTER 4to 1. In the example, the last two terms are 0 when z = 1, the first and lastterms are 0 when x = 2, and the first two terms are 0 when x = 3.To convert a polynomial from the form described by Lagrange™s formulato our standard coefficient representation is not at all straightforward. Atleast N2 operations seem to be required, since there are N terms in the sum,each consisting of a product with N factors. Actually, it takes some clevernessto achieve a quadratic algorithm, since the factors are not just numbers, but
polynomials of degree N. On the other hand, each term is very similar tothe previous one. The reader might be interested to discover how to takeadvantage of this to achieve a quadratic algorithm. This exercise leaves onewith an appreciation for the non-trivial nature of writing an efficient programto perform the calculation implied by a mathematical formula.As with polynomial evaluation, there are more sophisticated methodswhich can solve the problem in N(log N)2 steps, and in Chapter 36 we™ll seea method that uses only N log N multiplications for a specific set of N pointsof interest.MultiplicationOur first sophisticated arithmetic algorithm is for the problem of polynomialmultiplication: given two polynomials p(x) and q(x), compute their productp(x)q(x). As noted in Chapter 2, polynomials of degree N - 1 could haveN terms (including the constant) and the product has degree 2N - 2 and asmany as 2N - 1 terms. For example,(1 +x+3x2 -4x3)(1 + 2x - 5s2 - 3~~) = (1 + 3a: - 6z3 - 26x4 + 11~~ + 12x7.The naive algorithm for this problem that we implemented in Chapter 2requires N2 multiplications for polynomials of degree N - 1: each of the Nterms of p(x) must be multiplied by each of the N terms of q(x).To improve on the naive algorithm, we™ll use a powerful technique foralgorithm design called divide-and-conquer: split the problem into smallerparts, solve them (recursively), then put the results back together in someway. Many of our best algorithms are designed according to this principle.In this section we™ll see how divide-and-conquer applies in particular to thepolynomial multiplication problem. In the following section we™ll look at some
analysis which gives a good estimate of how much is saved.One way to split a polynomial in two is to divide the coefficients in half:given a polynomial of degree N-l (with N coefficients) we can split it into twopolynomials with N/2 coefficients (assume that N is even): by using the N/2
low-order coefficients for one polynomial and the N/2 high-order coefficients
PoLMvoMIALs49for the other. For p(z) = po + pla: + . .. + PN-IZ?‚, definef%(x) =p,, +pla:+ﬁ~+pN,2-~xN™2-1Ph(x) = pN/2 + pN/2+15 -I- ™ ™ * + pN-1xN™2-?Then, splitting q(x)in the same way, we have:P(x) = Pi(x) + zN™2ph(x),q(x) = 41(x) + ﬁN™2qh(x).Now, in terms of the smaller polynomials;, the product is given by:P(x)dx) = Pdx)ql(x) + (Pdxk?h(x) + d+h(x))xN™2 + Ph(x)qh(x)xN.(We used this same split in the previous chapter to avoid overflow.) What™sinteresting is that only three multiplications are necessary to compute theseproducts, because if we compute TV = pl(x)ql(x), ?-h(x) = ph(x)qh(x), andTm(x) = (?‚dx) + Ph(x))(ql(x) + qh(z)),we can get the product p(x)q(x) bycomputingp(x)q(x) = Tl(x) + (Tm(x) - ?-l(x) - ?-h(x))xN™2 + ‚?-h(x)xN.Polynomial addition requires a linear algorithm, and the straightforward poly-nomial multiplication algorithm of Chapter 2 is quadratic, so it™s worthwhile
to do a few (easy) additions to save one (difficult) multiplication. Below we™lllook more closely at the savings achieved by this method.For the example given above, with p(x) = 1 +x +3x2 -4x3 and q(x) =1 + 2x - 5x2 - 3x3, we haveQ(X) = (1+ x)(1 + 2x) = I + 3x + 2x2,Q(X) = (3 -4x)(-5 - 3x) = -15 + 11x + 12x2,T,(X) = (4 - 3x)(-4 - x) =: -16 +8x + 3x2.Thus, r,(x) - Q(X) -?-h(x) = -2 - 6x - 11x2, and the product is computed asp(x)q(x) = (1 + 3x + 2x2) + (-2 -6x - 11x2)x2 + (-15 + 11x + 12x2)x4= 1+3x - 6x3 - 26x4 + 11x5 t 12x6.This divide-and-conquer approach solves a polynomial multiplication problemof size N by solving three subproblems of size N/2, using some polynomialaddition to set up the subproblems and to combine their solutions. Thus, thisprocedure is easily described as a recursive program:
50CHAPTER 4function mult(p, q: array[O..N-I] of real;N: integer) : array [O..2*N-21 of real;var pl, 41, ph, qh, tl, t2: array [O..(N div 2)-I] of real;rl, rm, rh: array [O..N-I] of red;i, N2: integer;beginif N=l then mult[O]:=p[O]*q[O]elsebeginN2:=N div 2;for i:=O to N2-1 dobegin pl[i]:=p[i]; ql[i]:=q[i] end;for i:=N2 to N-l dobegin ph[i-N2]:=p[i]; qh[i-N2]:=q[i] end;for i:=O to N2-I do tI[i]:=pl[i]+ph[i];for i:=O to N2-1 do t2[i]:=ql[i]+qh[i];rm:=mult(tl, t2, N2);rl:=mult(pl, 41, N2);rh:=mult(ph, qh, N2);for i:=O to N-2 do mult [i] :=rl[i]mult [N-l] :=O;for i:=O to N-2 do mult [N+i] :=rh [i]for i:=O to N-2 domult[N2+i]:=mult[N2+i]+rm[i]-(rl[i]+rh[i]);end ;end.Although the above code is a succinct description of this method, it is (unfortu-nately) not a legal Pascal program because functions can™t dynamically declare
arrays. This problem could be handled in Pascal by representing the polync+mials as linked lists, as we did in Chapter 2. This program assumes that N is apower of two, though the details for general N can be worked out easily. Themain complications are to make sure that the recursion terminates properlyand that the polynomials are divided properly when N is odd.The same method can be used for multiplying integers, though care mustbe taken to treat ﬁcarriesﬂ properly during the subtractions after the recursivecalls.As with polynomial evaluation and interpolation, there are sophisticatedmethods for polynomial multiplication, and in Chapter 36 we™ll see a methodthat works in time proportional to N log N.
POLYNOMIALS51Divide-and-conquer RecurrencesWhy is the divide-and-conquer method g:iven above an improvement? In thissection, we™ll look at a few simple recurrence formulas that can be used tomeasure the savings achieved by a divide-and-conquer algorithm.From the recursive program, it is clear that the number of integer multi-plications required to multiply two polynomials of size N is the same as thenumber of multiplications to multiply three pairs of polynomials of size N/2.
(Note that, for example, no multiplications are required to compute T~(z)z~,just data movement.) If M(N) is the number of multiplications required tomultiply two polynomials of size N, we haveM(N) = 3M(N/2)for N > 1 with M(1) = 1. Thus M(2) q = 3, M(4) = 9, M(8) = 27, etc. Ingeneral, if we take N = 2n, then we can repeatedly apply the recurrence toitself to find the solution:M(2n) = 3M(2ﬂ-l) = 32M(2ﬂ-2) = 33M(2+s) = . . . = 3n~(I) = 3n.If N = 2n, then 3% = 2(‚s31n = 2n1s3 = N™s3. Although this solution is exactonly for N = 2n, it works out in general thatM(N) FZ Nlg3 z N1.58,which is a substantial savings over the N2 naive method. Note that if we wereto have used all four multiplications in the simple divide-and-conquer method,the recurrence would be M(N) = 4M(Nl/2) with the solution M(2n) = 4n =N2.The method described in the previous section nicely illustrates the divide-and-conquer technique, but it is seldom usled in practice because a much betterdivide-and-conquer method is known, which we™ll study in Chapter 36. Thismethod gets by with dividing the original into only two subproblems, with
a little extra processing. The recurrence describing the number of multiplica-tions required isM(N) = 2M(N/2) + N.Though we don™t want to dwell on the mathematics of solving such recur-rences, formulas of this particular form arise so frequently that it will be
worthwhile to examine the development of an approximate solution. First, as
above, we write N = 2?M(2n) = 2M(2™ﬁ-‚) + 2ﬂ.
52CHAPTER 4The trick to making it simple to apply this same recursive formula to itself isto divide both sides by 2n:M(2n) M(29- = 2n-l $1.2nNow, applying this same formula to itself n times ends up simply giving ncopies of the ﬁ1,ﬂ from which it follows immediately that M(2n) = 712~. Again,it turns out that this holds true (roughly) for all N, and we have the solutionM(N) z NlgN.We™ll see several algorithms from different applications areas whose perfor-mance characteristics are described by recurrences of this type. Fortunately,
many of the recurrences that come up are so similar to those above that thesame techniques can be used.For another example, consider the situation when an algorithm dividesthe problem to be solved in half, then is able to ignore one half and (recursively)solve the other. The running time of such an algorithm might be describedby the recurrenceM(N) = M(N/2) + 1.This is easier to solve than the one in the previous paragraph. We immediatelyhave I14(2~) = n and, again, it turns out that M(N) z 1gN.Of course, it™s not always possible to get by with such trivial manipula-tions. For a slightly more difficult example, consider an algorithm of the typedescribed in the previous paragraph which must somehow examine each ele-ment before or after the recursive step. The running time of such an algorithm
is described by the recurrenceM(N) = M(N/2) + N.Substituting N = 2n and applying the same recurrence to itself n times nowgivesThis must be evaluated to get the result I~f(2~) = 2n+1 - 1 which translatesto M(N) z 2N for general N.To summarize, many of the most interesting algorithms that we willencounter are based on the divide-and-conquer technique of combining thesolutions of recursively solved smaller subproblems. The running time of suchalgorithms can usually be described by recurrence relationships which are adirect mathematical translation of the structure of the algorithm. Though
PoLYNoMIALs53such relationships can be challenging to solve precisely, they are often easy tosolve for some particular values of N to get solutions which give reasonableestimates for all values of N. Our purpo,se in this discussion is to gain someintuitive feeling for how divide-and-conquer algorithms achieve efficiency, notto do detailed analysis of the algorithms. Indeed, the particular recurrencesthat we™ve just solved are sufficient to describe the performance of most ofthe algorithms that we™ll be studying, and we™ll simply be referring back to
them.Matrix MultiplicationThe most famous application of the divide-and-conquer technique to an arith-metic problem is Strassen™s method for matrix multiplication. We won™t gointo the details here, but we can sketch the method, since it is very similar to
the polynomial multiplication method that we have just studied.The straightforward method for multiplying two N-by-N matrices re-quires N3 scalar multiplications, since each of the N2 elements in the productmatrix is obtained by N multiplications.Strassen™s method is to divide the size of the problem in half; this cor-responds to dividing each of the matrice;s into quarters, each N/2 by N/2.The remaining problem is equivalent to multiplying 2-by-2 matrices. Just aswe were able to reduce the number of multiplications required from four tothree by combining terms in the polynomial multiplication problem, Strassenwas able to find a way to combine terms to reduce the number of multiplica-tions required for the 2-by-2 matrix multiplication problem from 8 to 7. Therearrangement and the terms required are quite complicated.The number of multiplications required for matrix multiplication usingStrassen™s method is therefore defined by the divide-and-conquer recurrenceM(N) = 7M(N/2)which has the solutionM(N) M N1g7 FZ N2.81.This result was quite surprising when it first appeared, since it had previouslybeen thought that N3 multiplications were absolutely necessary for matrixmultiplication. The problem has been studied very intensively in recent years,and slightly better methods than Strassen™s have been found. The ﬁbestﬂalgorithm for matrix multiplication has still not been found, and this is oneof the most famous outstanding problems of computer science.It is important to note that we have been counting multiplications only.Before choosing an algorithm for a practical application, the costs of theextra additions and subtractions for combining terms and the costs of the
CHAPTER 4recursive calls must be considered. These costs may depend heavily on theparticular implementation or computer used. But certainly, this overhead
makes Strassen™s method less efficient than the standard method for smallmatrices. Even for large matrices, in terms of the number of data items input,Strassen™s method really represents an improvement only from N™.5 to N1.41.This improvement is hard to notice except for very large N. For example, Nwould have to be more than a million for Strassen™s method to use four timesas few multiplications as the standard method, even though the overhead permultiplication is likely to be four times as large. Thus the algorithm is a
theoretical, not practical, contribution.This illustrates a general tradeoff which appears in all applications (thoughthe effect, is not always so dramatic): simple algorithms work best for smallproblems, but sophisticated algorithms can reap tremendous savings for large
problems.rl-
POLYNOMIALS55Exercises1.Give a method for evaluating a polynomial with known roots ~1, ~2, . . . ,TN, and compare your method with Horner™s method.2.Write a program to evaluate polynomials using Horner™s method, wherea linked list representation is used for the polynomials. Be sure that your
program works efficiently for sparse polynomials.3.Write an N2 program to do Lagrang:ian interpolation.4.Suppose that we know that a polynomial to be interpolated is sparse (hasfew non-zero coefficients). Describe how you would modify Lagrangianinterpolation to run in time proportional to N times the number of non-zero coefficients.5.Write out all of the polynomial multipllications performed when the divide-and-conquer polynomial multiplication method described in the text isused tosquare 1+x+~2+x3+s4+x5+x6+~7+xs.6.The polynomial multiplication routinie mult could be made more efficientfor sparse polynomials by returning 0 if all coefficients of either input are0. About how many multiplications ((to within a constant factor) wouldsuch a program use to square 1 + xN?7.Can x32 be computed with less than five multiplications? If so, say whichones; if not, say why not.8.Can x55 be computed with less than nine multiplications? If so, say whichones; if not, say why not.9.Describe exactly how you would modify mult to multiply a polynomial ofdegree N by another of degree M, with N > M.10. Give the representation that you would use for programs to add andmultiply multivariate polynomials such as xy2z + 31~~~7~~2~~ + w. Givethe single most important reason for choosing this representation.

5. Gaussian EliminationCertainly one of the most fundam.ental scientific computations is thesolution of systems of simultaneous equations. The basic algorithm forsolving systems of equations, Gaussian elimination, is relatively simple andhas changed little in the 150 years since it was invented. This algorithm has
come to be well understood, especially in the past twenty years, so that it can
be used with some confidence that it will efficiently produce accurate results.This is an example of an algorithm that will surely be available in mostcomputer installations; indeed, it is a primitive in several computer languages,notably APL and Basic. However, the basic algorithm is easy to understandand implement, and special situations do arise where it might be desirable
to implement a modified version of the algorithm rather than work with a
standard subroutine. Also, the method deserves to be learned as one of the
most important numeric methods in use today.As with the other mathematical material that we have studied so far, ourtreatment of the method will highlight only the basic principles and will beself-contained. Familiarity with linear algebra is not required to understandthe basic method. We™ll develop a simple Pascal implementation that mightbe easier to use than a library subroutine for simple applications. However,we™ll also see examples of problems which could arise. Certainly for a large orimportant application, the use of an expertly tuned implementation is calledfor, as well as some familiarity with the underlying mathematics.A Simple ExampleSuppose that we have three variables :c,y and z and the following threeequations:x + 3y - 4;~ = 8,x+y-2;z=2,-x-2y+5;s=-1.57
58CHAPTER 5Our goal is to compute the values of the variables which simultaneouslysatisfy the equations. Depending on the particular equations there may not
always be a solution to this problem (for example, if two of the equations are
contradictory, such as 2 + y = 1, z + y = 2) or there may be many solutions(for example, if two equations are the same, or there are more variables thanequations). We™ll assume that the number of equations and variables is thesame, and we™ll look at an algorithm that will find a unique solution if one
exists.To make it easier to extend the formulas to cover more than just threepoints, we™ll begin by renaming the variables, using subscripts:s1+3s2-4~=8,21+22-223=2,-x1 - 2x2 + 5x3 = -1.To avoid writing down variables repeatedly, it is convenient to use matrixnotation to express the simultaneous equations. The above equations areexactly equivalent to the matrix equationThere are several operations which can be performed on such equations whichwill not alter the solution:Interchange equations: Clearly, the order in which the equations arewritten down doesn™t affect the solution. In the matrix representation,this operation corresponds to interchanging rows in the matrix (andthe vector on the right hand side).Rename variables: This corresponds to interchanging columns in thematrix representation. (If columns i and j are switched, then variablesxi and xj must also be considered switched.)Multiply equations by a constant: Again, in the matrix representation,this corresponds to multiplying a row in the matrix (and the cor-responding element in the vector on the righbhand side) by a constant.Add two equations and replace one of them by the sum. (It takes alittle thought to convince oneself that this will not affect the solution.)For example, we can get a system of equations equivalent to the one aboveby replacing the second equation by the difference between the first two:
GAUSSIAN ELIMINATION59Notice that this eliminates zi from the second equation. In a similar manner,we can eliminate xi from the third equation by replacing the third equationby the sum of the first and third:(i ; ‚;)(iz) =($).Now the variable zi is eliminated from all but the first equation. By sys-tematically proceeding in this way, we can transform the original system ofequations into a system with the same solution that is much easier to solve.For the example, this requires only one more step which combines two of theoperations above: replacing the third equation by the difference between thesecond and twice the third. This makes all of the elements below the maindiagonal 0: systems of equations of this form are particularly easy to solve.
The simultaneous equations which result in our example are:xi+3xs-453=8,2x2 - 22s = 6,-42s = -8.Now the third equation can be solved immediately: x3 = 2. If we substitutethis value into the second equation, we can compute the value of x2:2x2 - 4 == 6,x2 == 5.Similarly, substituting these two values in the first equation allows the valueof xi to be computed:x1 + 15 - 8 = 8,Xl = 1,which completes the solution of the equations.This example illustrates the two basic phases of Gaussian elimination.The first is the forward elimination phase, where the original system is trans-formed, by systematically eliminating variables from equations, into a systemwith all zeros below the diagonal. This process is sometimes called triangula-tion. The second phase is the backward substitution phase, where the valuesof the variables are computed using the t:riangulated matrix produced by thefirst phase.Outline of the MethodIn general, we want to solve a system of N equations in N unknowns:allxl + a1222 + --- + alNxN = bl,a2121 + a2252 + * 9 * + a2NxN = bz,aNlx1 + aN252 $ - -. -+ aNNxN = bN.
60CHAJ™TER 5In matrix form, these equations are written as a single matrix equation:or simply AX = b, where A represents the matrix, z represents the variables,and b represents the rightrhand sides of the equations. Since the rows of Aare manipulated along with the elements of b, it is convenient to regard b asthe (N + 1)st column of A and use an N-by-(N + 1) array to hold both.Now the forward elimination phase can be summarized as follows: firsteliminate the first variable in all but the first equation by adding the ap-propriate multiple of the first equation to each of the other equations, then
eliminate the second variable in all but the first two equations by adding theappropriate multiple of the second equation to each of the third through theNth equations, then eliminate the third variable in all but the first threeequations, etc. To eliminate the ith variable in the jth equation (for j be-tween i $- 1 and N) we multiply the ith equation by aji/aii and subtract itfrom the jth equation. This process is perhaps more succinctly described bythe following program, which reads in N followed by an N-by-( N + 1) matrix,
performs the forward elimination, and writes out the triangulated result. In
the input, and in the output the ith line contains the ith row of the matrix
followed by b,.program gauss(input, output);const maxN=50;var a: array[I..maxN, l..maxN] of real;i, J™, k, N: integer;beginreadln (N) ;for j:==l to N dobegin for k:=l to N+1 do read(ab, k]); readln end;for i:==l to N dofor j:=i+l to N dofor k:=N+l downto i doab,k]:=aIj,k]-a[i,k]*ab,i]/a[i,i];for j:==l to N dobegin for k:=l to N+1 do write(ab, k]); writeln end;end.
GAUSSIAN ELlMlNATION61(As we found with polynomials, if we wtint to have a program that takes Nas input, it is necessary in Pascal to first decide how large a value of N will
be ﬁlegal,ﬂand declare the array suitably.) Note that the code consists ofthree nested loops, so that the total running time is essentially proportionalto N3. The third loop goes backwards so as to avoid destroying ab, i] beforeit is needed to adjust the values of other #elements in the same row.The program in the above paragraph is too simple to be quite right: a[& i]might be zero, so division by zero could ‚occur. This is easily fixed, becausewe can exchange any row (from i+1 to N) with the ith row to make a[i, i]non-zero in the outer loop. If no such row can be found, then the matrix issingular: there is no unique solution.In fact, it is advisable to do slightly more than just find a row with anon-zero entry in the ith column. It™s best to use the row (from if1 to N)whose entry in the ith column is the largest in absolute value. The reason forthis is that severe computational errors can arise if the a[& i] value which isused to scale a row is very small. If a[i, i] is very small, then the scaling factorab, i]/a[i, i] which is used to eliminate the ith variable from the jth equation(for j from i+l to N) will be very large. In fact, it could get so large as todwarf the actual coefficients ali, k], to the point where the alj, k] value getsdistorted by ﬁround-off error.ﬂPut simply, numbers which differ greatly in magnitude can™t be accuratelyadded or subtracted in the floating point number system commonly used torepresent real numbers, but using a small a[& i] value greatly increases thelikelihood that such operations will have to be performed. Using the largestvalue in the ith column from rows i+l to N will ensure that the scaling factoris always less than 1, and will prevent the occurrence of this type of error. Onemight contemplate looking beyond the ith column to find a large element, but
it has been shown that accurate answers can be obtained without resorting to
this extra complication.The following code for the forward elimination phase of Gaussian elimina-tion is a straightforward implementation of this process. For each i from 1 toN, we scan down the ith column to find the largest element (in rows past theith). The row containing this element is exchanged with the ith , then the ithvariable is eliminated in the equations i+.l to N exactly as before:
62CHAPTER 5procedure eliminate;var i, j, k, max: integer;t: real;beginfor i:=l to Ndobeginmax:=i;for j:=i+l to N doif abs(aIj, i])>abs(a[max, i]) then max:=j;for k:=i to N+l dobegin t:=a[i, k]; a[i, k] :=a[max, k]; a[max, k] :=t end;for j:=i+l to N dofor k:=N+l downto i doab,k]:=ab,k]-a[i,k]*ab,i]/a[i,i];endend ;(A call to eliminate should replace the three nested for loops in the programgauss given above.) There are some algorithms where it is required that thepivot a[i, i] be used to eliminate the ith variable from every equation but theith (not just the (i+l)st through the Nth). This process is called full pivoting;for forward elimination we only do part of this work hence the process is calledpartial pivoting .After the forward elimination phase has completed, the array a hasall zeros below the diagonal, and the backward substitution phase can beexecuted. The code for this is even more straightforward:procedure substitute;var j, k: integer;t: real;beginfor j:=N downto 1 dobegintr=o.o;for k:=j+l to N do t:=t+ab, k]*x[k];r!i:=(ali, N+ll-t)/alj,j]end ;A call to eliminate followed by a call to substitute computes the solution inthe N-element array x. Division by 0 could still occur for singular matrices.
GAUSSLAN ELMNATION63Obviously a ﬁlibraryﬂ routine would check for this explicitly.An alternate way to proceed after forward elimination has created allzeros below the diagonal is to use precisely the same method to produce allzeros above the diagonal: first make the last column zero except for a[N, N]by adding the appropriate multiple of a[N, N], then do the same for the next-to-last column, etc. That is, we do ﬁpartial pivotingﬂ again, but on the otherﬁpartﬂ of each column, working backwards through the columns. After thisprocess, called Gauss- Jordan reduction, is complete, only diagonal elementsare non-zero, which yields a trivial solution.Computational errors are a prime source of concern in Gaussian elimina-tion. As mentioned above, we should be wary of situations when the mag-nitudes of the coefficients vastly differ. Using the largest available element
in the column for partial pivoting ensures that large coefficients won™t be ar-
bitrarily created in the pivoting process, but it is not always possible to avoid
severe errors. For example, very small coefficients turn up when two differentequations have coefficients which are quite close to one another. It is actuallypossible to determine in advance whether such problems will cause inaccurate
answers in the solution. Each matrix haa an associated numerical quantitycalled the condition number which can ble used to estimate the accuracy ofthe computed answer. A good library subroutine for Gaussian eliminationwill compute the condition number of the matrix as well as the solution, so
that the accuracy of the solution can be lknown. Full treatment of the issuesinvolved would be beyond the scope of this book.Gaussian elimination with partial pivoting using the largest availablepivot is ﬁguaranteedﬂ to produce results with very small computational errors.There are quite carefully worked out mathematical results which show that thecalculated answer is quite accurate, except for ill-conditioned matrices (whichmight be more indicative of problems in .the system of equations than in themethod of solution). The algorithm has been the subject of fairly detailedtheoretical studies, and can be recommended as a computational procedureof very wide applicability.Variations and ExtensionsThe method just described is most appropriate for N-by-N matrices withmost of the N2 elements non-zero. As we™ve seen for other problems, specialtechniques are appropriate for sparse matrices where most of the elements are0. This situation corresponds to systems ‚of equations in which each equationhas only a few terms.If the non-zero elements have no particular structure, then the linkedlist representation discussed in Chapter ‚2 is appropriate, with one node foreach non-zero matrix element, linked together by both row and column. The
64CHAPTER 5standard method can be implemented for this representation, with the usualextra complications due to the need to create and destroy non-zero elements.
This technique is not likely to be worthwhile if one can afford the memory to
hold the whole matrix, since it is much more complicated than the standardmethod. Also, sparse matrices become substantially less sparse during theGaussian elimination process.Some matrices not only have just a few non-zero elements but also havea simple structure, so that linked lists are not necessary. The most commonexample of this is a ﬁband)) matrix, where the non-zero elements all fall veryclose to the diagonal. In such cases, the inner loops of the Gaussian eliminationalgorithms need only be iterated a few times, so that the total running time(and storage requirement) is proportional to N, not N3.An interesting special case of a band matrix is a ﬁtridiagonalﬂ matrix,where only elements directly on, directly above, or directly below the diagonalare non-zero. For example, below is the general form of a tridiagonal matrixfor N = !j:/a11a12000~21a22a23000a32a33a34000a43a44a45i 000a54a55For such matrices, forward elimination and backward substitution each reduceto a single for loop:for i:=l to N-l dobegina[i+l, N+l]:=a[i+l, N+l]-a[i, iV+l]*a[i+l, i]/a[i,i];a[i+l, ifl] :=a[i+l, i+l]-a[i, i+l]*a[i+l, i]/a[i,i]end ;for j:== N downto 1 doxb]:=(ab, N+1]-ab, j+l]*xb+1])/ab, j];For forward elimination, only the case j=i+l and k=i+l needs to be included,since a[i, k]=O for k>i+l. (The case k =i can be skipped since it sets to 0an array element which is never examined again -this same change could bemade to straight Gaussian elimination.) Of course, a two-dimensional arrayof size N2 wouldn™t be used for a tridiagonal matrix. The storage required forthe above program can be reduced to be linear in N by maintaining four arraysinstead of the a matrix: one for each of the three nonzero diagonals and onefor the (N + l)st column. Note that this program doesn™t necessarily pivot onthe largest available element, so there is no insurance against division by zero
GAUSSIAN ELMNATION65or the accumulation of computational errors. For some types of tridiagonalmatrices which arise commonly, it can be proven that this is not a reason for
concern.Gauss-Jordan reduction can be implemented with full pivoting to replacea matrix by its inverse in one sweep th.rough it. The inverse of a matrixA, written A-‚, has the property that a system of equations Ax = b couldbe solved just by performing the matrix multiplication z = A-lb. Still, N3operations are required to compute x given b. However, there is a way topreprocess a matrix and ﬁdecomposeﬂ it into component parts which makeit possible to solve the corresponding system of equations with any givenrightchand side in time proportional to 1V2, a savings of a factor of N overusing Gaussian elimination each time.Roughly, this involves rememberingthe operations that are performed on the (N + 1)st column during the forwardelimination phase, so that the result of forward elimination on a new (N + 1)stcolumn can be computed efficiently and then back-substitution performed asusual.Solving systems of linear equations has been shown to be computationallyequivalent to multiplying matrices, so tlhere exist algorithms (for example,Strassen™s matrix multiplication algorithm) which can solve systems of N
equations in N variables in time proportional to N2.*l.... As with matrixmultiplication, it would not be worthwhile to use such a method unless verylarge systems of equations were to be processed routinely. As before, the
actual running time of Gaussian elimination in terms of the number of inputs
is N312. which is difficult to imnrove uoon in nractice.
66Exercises1.2.3.4.5.
6.7.8.9.10.Give the matrix produced by the forward elimination phase of Gaussianelimination (gauss, with eliminate) when used to solve the equations x +y+z=6, 2x+y+3z=12, and3x+y+32=14.Give a system of three equations in three unknowns for which gauss as is(without eliminate) fails, even though there is a solution.What is the storage requirement for Gaussian elimination on an N-by-Nmatrix with only 3N nonzero elements?Describe what happens when eliminate is used on a matrix with a row ofall 0™s.Describe what happens when eliminate then substitute are used on amatrix with a column of all 0™s.Which uses more arithmetic operations: Gauss-Jordan reduction or backsubstitution?If we interchange columns in a matrix, what is the effect on the cor-responding simultaneous equations?How would you test for contradictory or identical equations when usingeliminate.Of what use would Gaussian elimination be if we were presented with asystem of M equations in N unknowns, with M < N? What if M > N?Give an example showing the need for pivoting on the largest availableelement, using a mythical primitive computer where numbers can be
represented with only two significant digits (all numbers must be of the
form z.y x 10™ for single digit integers 2, y, and 2).
6. Curve FittingThe term curve fitting (or data fitting) is used to describe the generalproblem of finding a function which matches a set of observed values ata set of given points. Specifically, given the pointsand the corresponding valuesYl,Y2,--.,YN,the goal is to find a function (perhaps of a specified type) such thatf(zl) = Yl, f(z2) = Y2,. . . , f(zN) = YNand such that f(z)assumes ﬁreasonableﬂ values at other data points. It couldbe that the z™s and y™s are related by some unknown function, and our goalis to find that function, but, in general, the definition of what is ﬁreasonableﬂdepends upon the application. We™ll see that it is often easy to identifyﬁunreasonableﬂ functions.Curve fitting has obvious application in the analysis of experimental data,and it has many other uses. For example,, it can be used in computer graphicsto produce curves that ﬁlook niceﬂ withlout the overhead of storing a largenumber of points to be plotted. A related application is the use of curve fittingto provide a fast algorithm for computing the value of a known function atan arbitrary point: keep a short table of exact values, curve fit to find othervalues.Two principal methods are used to approach this problem. The first isinterpolation: a smooth function is to be found which exactly matches thegiven values at the given points. The second method, least squares data fitting,is used when the given values may not be exact, and a function is sought whichmatches them as well as possible.67
68CHAPTER 6Polynomial InterpolationWe™ve already seen one method for solving the data-fitting problem: if f isknown to be a polynomial of degree N - 1, then we have the polynomial inter-polation problem of Chapter 4. Even if we have no particular knowledge aboutf, we could solve the data-fitting problem by letting f(z) be the interpolatingpolynomial of degree N - 1 for the given points and values. This could becomputed using methods outlined elsewhere in this book, but there are manyreasons not to use polynomial interpolation for data fitting. For one thing,a fair amount of computation is involved (advanced N(log N)2 methods areavailable, but elementary techniques are quadratic). Computing a polynomialof degree 100 (for example) seems overkill for interpolating a curve through100 points.The main problem with polynomial interpolation is that high-degreepolynomials are relatively complicated functions which may have unexpectedproperties not well suited to the function being fitted. A result from classical
mathematics (the Weierstrass approximation theorem) tells us that it is pos-
sible to approximate any reasonable function with a polynomial (of sufficientlyhigh degree). Unfortunately, polynomials of very high degree tend to fluctuatewildly. It turns out that, even though most functions are closely approximated
almost everywhere on a closed interval by an interpolation polynomial, thereare always some places where the approximation is terrible. Furthermore,this theory assumes that the data values are exact values from some unknown
function when it is often the case that the given data values are only ap-
proximate. If the y™s were approximate values from some unknown low-degree
polynomial, we would hope that the coefficients for the high-degree terms in
the interpolating polynomial would be 0. It doesn™t usually work out this
way; instead the interpolating polynomial tries to use the high-degree terms
to help achieve an exact fit. These effects make interpolating polynomials
inappropriate for many curve-fitting applications.Spline InterpolationStill, low-degree polynomials are simple curves which are easy to work withanalytically, and they are widely used for curve fitting. The trick is to abandon
the idea of trying to make one polynomial go through all the points and instead
use different polynomials to connect adjacent points, piecing them togethersmoothly,, An elegant special case of this, which also involves relativelystraightforward computation, is called spline interpolation.A ﬁsplineﬂ is a mechanical device used by draftsmen to draw aestheticallypleasing curves: the draftsman fixes a set of points (knots) on his drawing, thenbends a flexible strip of plastic or wood (the spline) around them and tracesit to produce the curve. Spline interpolation is the mathematical equivalentof this process and results in the same curve.
CURVE FITTING69It can be shown from elementary mechanics that the shape assumed bythe spline between two adjacent knots is a third-degree (cubic) polynomial.Translated to our data-fitting problem, this means that we should consider
the curve to be N - 1 different cubic polynomialsSi(X) = aix3 + biX2 + cix + di,i=1,2 ,..., N-l,with si(x) defined to be the cubic polynomial to be used in the interval betweenxi and xi+17 as shown in the following diagram:yps ... A:‚ﬁ‚ﬁ™The spline can be represented in the obvious way as four one-dimensionalarrays (or a 4-by-(N - 1) two-dimensional array). Creating a spline consistsof computing the necessary a, b, c, d coefficients from the given x points andy values. The physical constraints on the spline correspond to simultaneousequations which can be solved to yield the coefficients.For example, we obviously must have si(xi) = yi and si(xi+i) = yi+l fori=1,2,***,N - 1 because the spline must touch the knots. Not only does thespline touch the knots, but also it curves ;smoothly around them with no sharpbends or kinks. Mathematically, this means that the first derivatives of thespline polynomials must be equal at the knots (si-i(xi) = s:(xi) for i = 2,3,. . . ,N - 1). In fact, it turns out that the second derivatives of the polynomialsmust be equal at the knots. These conditions give a total of 4N - 6 equationsin the 4(N-1) unknown coefficients. Two more conditions need to be specifiedto describe the situation at the endpoints of the spline. Several options areavailable; we™ll use the so-called ﬁnaturalﬂ spline which derives from s;1(xr) =0 and s&,(x~) = 0.Theseconditions give a full system of 4N - 4 equationsin 4N - 4 unknowns, which could be solved using Gaussian elimination tocalculate all the coefficients that describe the spline.The same spline can be computed somewhat more efficiently becausethere are actually only N - 2 ﬁunknownsﬂ:most of the spline conditions areredundant. For example, suppose that p, is the value of the second derivativeof the spline at xi, so that s:)_~(x~) = .sy(xi) = pi for i = 2,. . . , N - 1, withpr = pN = 0. If the values of pl, . . . ,phr are known, then all of the a, b, c, dcoefficients can be computed for the spline segments, since we have four
70CHAPTER 6equations in four unknowns for each spline segment: for i = 1,2,. . . , N - 1,we must haveSi(&) = yi%(%+1) = !A+1((Xi) = pis:‚(xi+l) = pi+1.Thus, to fully determine the spline, we need only compute the values ofP21...,pN-1. But this discussion hasn™t even considered the conditions thatthe first derivatives must match.These N - 2 conditions provide exactlythe N - 2 equations needed to solve for the N - 2 unknowns, the pi secondderivative values.To express the a, b, c, and d coefficients in terms of the p second derivativevalues, then substitute those expressions into the four equations listed abovefor each spline segment, leads to some unnecessarily complicated expressions.
Instead it is convenient to express the equations for the spline segments in acertain canonical form that involves fewer unknown coefficients. If we changevariables to t = (CC - zi)/(x,+1 - Q) then the spline can be expressed in thefollowing way:sip) = tyi+1 + (1 - t)yi + (x,+1 - xd2[(t3 - qpi+1 - ((1 -t)ﬂ - (1 - t))pJNow each spline is defined on the interval [O,l]. This equation is less formi-dable than it looks because we™re mainly interested in the endpoints 0 and 1,and either t or (1 - t) is 0 at these points. It™s trivial to check that the splineinterpolates and is continuous because si-r(l) = si(O) = yi for i = 2,. . . , N-l,and it™s only slightly more difficult to verify that the second derivative is con-tinuous because s:(l) = s;+,(O) = pi+i.These are cubic polynomials whichsatisfy the requisite conditions at the endpoints, so they are equivalent to thespline segments described above. If we were to substitute for t and find thecoefficient of x3, etc., then we would get the same expressions for the a™s, b™s,c™s, and d™s in terms of the x™s, y™s, and p™s as if we were to use the methoddescribed in the previous paragraph. But there™s no reason to do so, because
we™ve checked that these spline segments satisfy the end conditions, and wecan evaluate each at any point in its interval by computing t and using theabove formula (once we know the p™s).To solve for the p™s we need to set the first derivatives of the splinesegments equal at the endpoints. The first derivative (with respect to x) ofthe above equation iss:(t) = zi + (Xi+1 - zJ[(3t2 - l)pi+i + (3(I - t)2 + I)pi]
CURVE FITTING71where z = (yi+l-yi)/(zi+l-zi). Now, setting &(l) = s;(O) for i = 2,. . . , N-1 gives our system of N - 2 equations to solve:(Xi - ~i-l)Pi-l+2(~i,-l - +1)p, + (Xi+1 -z&+1 = zi -z&1.This system of equations is a simple ﬁtridiagonalﬂ form which is easily solvedwith a degenerate version of Gaussian elimination as we saw in Chapter 5. Ifwe let ui = zi+l - zi, di = 2(zi+l -xi--i), and wi = zi - zi.-1, we have, forexample, the following simultaneous equ.ations for N = 7:In fact, this is a symmetric tridiagonal system, with the diagonal below themain diagonal equal to the diagonal above the main diagonal. It turns out thatpivoting on the largest available element is not necessary to get an accuratesolution for this system of equations.The method described in the above paragraph for computing a cubicspline translates very easily into Pascal:procedure makespline;var i: integer;beginreadln (N) ;for i:=l to N do readln(x[i],y[i]);for i:=2 to N-l do d[i]:=2*(x[i+l]-x[i-11);for i:=l to N-l do u[i]:=x[i+l]-x[i];for i:=2 to N-l dow[i]:=(y[i+l]--y[i])/u[i]-(y[i]-y[i-l])/u[i-11;p[l] :=o.o; p[Nj :=o.o;for i:=2 to N-2 dobeginw[i+l]:=w[i+;l]-w[i]*u[i]/d[i];d[i+l]:=d[i+l]-u[i]*u[i]/d[i]end ;for i:=N-1 downto 2 dop[i]:=(w[i]-u[i]*p[i+l])/d[i];end ;
72CHAPTER 6The arrays d and u are the representation of the tridiagonal matrix that issolved using the program in Chapter 5. We use d[i] where a[i, i] is used inthat program, u[i] where a [i+l, i] or a[i, i+l] is used, and z[i] where a[i, N+I]is used.For an example of the construction of a cubic spline, consider fitting aspline to the five data points(1.0,2.0), (2.0,1.5), (4.0,1.25), (5.0,1.2), (8.0,1.125), (10.0,l.l).(These come from the function 1 + l/z.) The spline parameters are found bysolving the system of equationswith the result p2 = 0.06590, p3 = -0.01021, p4 = 0.00443, ps = -0.00008.To evaluate the spline for any value of 2 in the range [zr , zN], we simplyfind the interval [zi, zi+r] containing z, then compute t and use the formulaabove for si(z) (which, in turn, uses the computed values for pi and pi+r).function eval(v: real): real;var t: real; i: integer;function f(x: real): red;begin f:=x*x*x-x end;begini:=O; repeat i:=i+l until v<=x[i+l];t:=(v-x[i])/u[i];eval:=t*y[i+l]+(l-t)*y[i]end +u[i]*u[i]*(f(t)*p[i+l]-f(l-t)*p[i]);This program does not check for the error condition when v is not betweenx[l] and x[IVl. If there are a large number of spline segments (that is, if Nis large), then there are more efficient ﬁsearchingﬂ methods for finding theinterval containing v, which we™ll study in Chapter 14.There are many variations on the idea of curvefitting by piecing togetherpolynomials in a ﬁsmoothﬂ way: the computation of splines is a quite well-developed field of study. Other types of splines involve other types of smooth-ness criteria as well as changes such as relaxing the condition that the splinemust exactly touch each data point. Computationally, they involve exactly
CURVE FITTING73the same steps of determining the coefficients for each of the spline pieces bysolving the system of linear equations derived from imposing constraints onhow they are joined.Method of Least SquaresA very common experimental situation is that, while the data values that wehave are not exact, we do have some idea of the form of the function whichis to fit the data. The function might depend on some parametersand the curve fitting procedure is to find the choice of parameters that ﬁbestﬂmatches the observed values at the given points. If the function were a poly-nomial (with the parameters being the coefficients) and the values were exact,then this would be interpolation. But now we are considering more generalfunctions and inaccurate data. To simplify the discussion, we™ll concentrateon fitting to functions which are expressed as a linear combination of simplerfunctions, with the unknown parameters being the coefficients:f(x) = Clfl(X) + c2f2(x) +**a+ cA4fdx).This includes most of the functions that we™ll be interested in. After studyingthis case, we™ll consider more general functions.A common way of measuring how well a function fits is the least-squarescriterion: the error is calculated by adding up the squares of the errors ateach of the observation points:E= c (f(xj)-yj)2.l<j<N--This is a very natural measure: the squaring is done to stop cancellationsamong errors with different signs. Obviously, it is most desirable to find the
choice of parameters that minimizes E. It turns out that this choice can becomputed efficiently: this is the so-called method of least squares.The method follows quite directly from the definition. To simplify thederivation, we™ll do the case M = 2, N = 3, but the general method will followdirectly. Suppose that we have three points xi, x2, x3 and corresponding valuesyi, ys, ys which are to be fitted to a function of the form f(x) = cl fi(x) +cz f2(x). Our job is to find the choice of the coefficients cl, cz which minimizesthe least-squares errorE =(clfl(xl) + czfdxd - yd2+ (nf1(x2) + czfz(x2) - Y2)2+ (Clfi(X3) + c2f2(x3) - Y3)2.
74CHAPTER 6To find the choices of cl and c2 which minimize this error, we simply need toset the derivatives dE/dq and dE/dcz to zero. For cl we have:g =2(cl.fl(G) + Czfz(~1) - Yl)fl(~l)1+ 2(Clfl(~Z) + czfz(z2) - yz)f1(52)+2(clfl(~3)+CZf2(~3)-Y3)fi(X3).Setting the derivative equal to zero leaves an equation which the variables cland cs must satisfy (fi(~i), etc. are all ﬁconstantsﬂ with known values):clvl(~1vl(~l) + fl(~Z)fl(~Z) + fl(Z3)fi(53)]+c2[f2(~l)fl(~l) + f2(~2)fl(z2) + f2(~3)fl(z3)]= Yl.fl(G) + YZfl(52) + Y3fl(53).We get a similar equation when we set the derivative dE/dc2 to zero.These rather formidable-looking equations can be greatly simplified usingvector notation and the ﬁdot productﬂ operation that we encountered brieflyin Chapter 2. If we define the vectors x = (21, zz,23) and y = (yi, yz, ys) andthen the dot product of x and y is the real number defined byX-Y = z1y1+ xzy2 + 23y3Now, if we define the vectors fi = (fl(xi),fi(xz),fi(xs)) and fs = (fs(xi),f2(52), f2(23)) thenour equations for the coefficients cl and cz can be verysimply expressed:Clfi . fi + CZfi * fz = y . fiClfZ.fi +c2f2 *f2 =y-f2.These can be solved with Gaussian elimination to find the desired coefficients.For example, suppose that we know that the data points(1.0,2.05), (2.0,1.53), (4.0,1.26), (5.0,1.21), (8.0,1.13), (10.0,l.l).should be fit by a function of the form cl + cz/x. (These data points areslightly perturbed from the exact values for 1 + l/x). In this case, we havefi = (l.O,l.O, l.O,l.O,l.O, 1.0) and f2 = (1.0,0.5,0.25,0.2,0.125,0.1) so we haveto solve the system of equations
CURVE FITTING75with the result cl = 0.998 and c2 = 1.054 (both close to 1, as expected).The method outlined above easily generalizes to find more than twocoefficients. To find the constants ~1~2,. . . ,CM inf(z) = clfl(z) + czfz(s) + *+* + CA4fM(Z)which minimize the least squares error for the point and observation vectorsfirst compute the function component vectorsfl = (fl(d, f1(s2), . . . , fl(ZN)),f-2 = (f2(~1), f2(z2), . * *, f2(Ziv)),Then make up an M-by-M linear system of equations AC = b witha,j = fi ﬂ fy,b, = fj . y.The solution to this system of simultaneous equations yields the requiredcoefficients.This method is easily implemented by maintaining a two dimensionalarray for the f vectors, considering y as the (M + 1)st vector. Then an arraya[l..M, I..M+I] can be filled as follows:for i:=l to Mdofor j:==l to M+l dobeginit:= 0.0;for k:=l to N do t:=t+f[i, k]*fb, k];a[& j]:=t;end;and then solved using the Gaussian elimination procedure from Chapter 5.The method of least squares can be extended to handle nonlinear func-tions (for example a function such as f(x) = cle-C2Zsincg~), and it is often
76CHAPTER 6used for this type of application.The idea is fundamentally the same; theproblem is that the derivatives may not be easy to compute. What is usedis an iterative method: use some estimate for the coefficients, then use thesewithin the method of least squares to compute the derivatives, thus producinga better estimate for the coefficients. This basic method, which is widely used
today, was outlined by Gauss in the 1820s.
CURVE FITTING77Exercises1.Approximate the function lgx with a degree 4 interpolating polynomialat the points 1,2,3,4, and 5. Estimat.e the quality of the fit by computingthe sum of the squares of the errors at 1.5, 2.5, 3.5, and 4.5.2.Solve the previous problem for the function sinx. Plot the function andthe approximation, if that™s possible on your computer system.3.Solve the previous problems using a cubic spline instead of an interpolat-ing polynomial.4.Approximate the function lgx with a cubic spline with knots at 2N forN between 1 and 10. Experiment with different placements of knots inthe same range to try to obtain a better fit.5.What would happen in least squares data fitting if one of the functionswas the function Ii(x) = 0 for some i?6.What would happen in least squares data-fitting if all the observed valueswere O?7.What values of a, b, c minimize the least-squares error in using the functionf(x) = ux log x + bx + c to approximate the observations f(1) = 0, f(4) =13, f(8) = 41?8.Excluding the Gaussian elimination phase, how many multiplications areinvolved in using the method of least squares to find M coefficients basedon N observations?9.Under what circumstances would the matrix which arises in least-squarescurve fitting be singular?10.Does the least-squares method work if two different observations are in-cluded for the same point?

7. IntegrationComputing the integral is a fundamental analytic operation often per-formed on functions being processed on computers. One of two com-pletely different approaches can be used, depending on the way the function isrepresented. If an explicit representation of the function is available, then it
may be possible to do symbolic integrathn to compute a similar representationfor the integral. At the other extreme, the function may be defined by a table,so that function values are known for only a few points. The most common
situation is between these: the function to be integrated is represented in sucha way that its value at any particular point can be computed. In this case,the goal is to compute a reasonable approximation to the integral of the func-tion, without performing an excessive number of function evaluations. Thiscomputation is often called quadrature by numerical analysts.Symbolic IntegrationIf full information is available about a function, then it may be worthwhileto consider using a method which involves manipulating some representation
of the function rather than working with numeric values.The goal is totransform a representation of the function into a representation of the integral,in much the same way that indefinite integration is done by hand.A simple example of this is the integ,ration of polynomials. In Chapters 2and 4 we examined methods for ﬁsymbolicallyﬂ computing sums and productsof polynomials, with programs that work.ed on a particular representation forthe polynomials and produced the representation for the answers from the rep-resentation for the inputs. The operation of integration (and differentiation)of polynomials can also be done in this way. If a polynomial79
80CHAPTER 7is represented simply by keeping the values of the coefficients in an array pthen the integral can be easily computed as follows:!;;:I! downto 1 do p [i] :=p[i-II/i;: ;This is a direct implementation of the well-known symbolic integrationrule Jc tie™dt = xi/i for i > 0.Obviously a wider class of functions than just polynomials can be handledby adding more symbolic rules. The addition of composite rules such asintegration by parts,/udv=uv-sv du,can greatly expand the set of functions which can be handled. (Integrationby parts requires a differentiation capability. Symbolic differentiation is some-
what easier than symbolic integration, since a reasonable set of elementary
rules plus the composite chain rule will suffice for most common functions.)The large number of rules available to be applied to a particular functionmakes symbolic integration a difficult task. Indeed, it has only recently beenshown that there is an algorithm for this task: a procedure which either
returns the integral of any given function or says that the answer cannot be
expressed in terms of elementary functions. A description of this algorithm
in its full generality would be beyond the scope of this book. However,
when the functions being processed are from a small restricted class, symbolicintegration can be a powerful tool.Of course, symbolic techniques have the fundamental limitation thatthere are a great many integrals (many of which occur in practice) which can™tbe evaluated symbolically. Next, we™ll examine some techniques which have
been developed to compute approximations to the values of real integrals.Simple Quadrature MethodsPerhaps the most obvious way to approximate the value of an integral is therectangle method: evaluating an integral is the same as computing the areaunder a curve, and we can estimate the area under a curve by summing theareas of small rectangles which nearly fit under the curve, as diagrammedbelow.
INTEGRATION81To be precise, suppose that we are to compute Jab f(x)dx, and that theinterval [a, b] over which the integral is to be computed is divided into Nparts, delimited by the points x1, x2,. . . ,xN+l. Then we have N rectangles,with the width of the ith rectangle (1 5 i 5 N)) given by x,+1 - x,. For theheight of the ith rectangle, we could use f(x,) or f(xi+l), but it would seemthat the result would be more accurate -if the value of f at the midpoint ofthe interval (f((xi + xi+l)/2))is used, as in the above diagram. This leads tothe quadrature formulawhich estimates the value of the integral ‚of f(x) over the interval from a = x1to b = xN+l. In the common case where all the intervals are to be the samesize, say x$+1 - xi = 20, we have xi+1 + zz = (2i + l)w, so the approximationr to the integral is easily computed.function inf,rect(a, b: real; N: integer) : real;var i: intieger; w, i-: real;beginr:=O; w:=(b-a)/N;for i:=l to N do r:=r+w*f(a-w,/2+i*w);intrect :==r;end ;Of course, as N gets larger, the answer becomes more accurate, Forexample, the following table shows the estimate produced by this function forJ: dxlx (which we know to be In 2 = 0.6931471805599.. . ) when invoked withthe call intrect(l.0,2.O,N) for N = 10,100,1000:
82CHAPTER 710 0.6928353604100100 0.69314405562831000 0.6931471493100When N = 1000, our answer is accurate to about seven decimal places.More sophisticated quadrature methods can achieve better accuracy withmuch less work.It is not difficult to derive an analytic expression for the error made inthe rectangle method by expanding f(z) in a Taylor series about the midpointof each interval, integrating, then summing over all intervals. We won™t go
through the details of this calculation: our purpose is not to derive detailed
error bounds, but rather to show error estimates for simple methods and how
these estimates suggest more accurate methods. This can be appreciated even
by a reader not familiar with Taylor series. It turns out thats~bf(Z)dz=7+~313+W5e5f...where w is the interval width ((b - a)/N) and es depends on the value ofthe third derivative of f at the interval midpoints, etc. (Normally, this isa good approximation because most ﬁreasonableﬂ functions have small high-order derivatives, though this is not always true.) For example, if we chooseto make w = .Ol (which would correspond to N = 200 in the example above),this formula says the integral computed by the procedure above should beaccurate to about six places.Another way to approximate the integral is to divide the area under thecurve into trapezoids, as diagrammed below.This trapezoid method leads to the quadrature formulat = c (x,+1 -Xi)f(G) + f(si+dl<z<N2 .
INTEGRATION83(Recall that the area of a trapezoid is one-half the product of the height andthe sum of the lengths of the two bases.) The error for this method can be
derived in a similar way as for the rectangle method. It turns out thatsp f(x) dx = t - 2w3e3 - 4w5e5 + . . . .Thus the rectangle method is twice as accurate as the trapezoid method.This is borne out by our example. The following procedure implements thetrapezoid method in the common case where all the intervals are the samewidth:function inttrap(a, b: real; N: integer): real;var i: integer; w, t: real;begint:=O; w:=(b-a)/N;for i:=l to N do t:=t+w*(f(a+(i--l)*w)+f(a+i*w))/2;inttrap:=t;end ;This procedure produces the following estimates for J12 dx/x:10 0.6937714031754100 0.69315343048181000 0.6931472430599It may seem surprising at first that the rectangle method is more accuratethan the trapezoid method: the rectangles tend to fall partly under the curve,partly over (so that the error can cancel out within an interval), while thetrapezoids tend to fall either completely under or completely over the curve.Another perfectly reasonable method is spline quadrature: spline inter-polation is performed using methods we have discussed and then the integralis computed by piecewise application of the trivial symbolic polynomial in-tegration technique described above. Bel™ow, we™ll see how this relates to theother methods.Compound MethodsExamination of the formulas given above for the error of the rectangle andtrapezoid methods leads to a simple method with much greater accuracy,called Simpson™s method. The idea is to eliminate the leading term in the error
84CHAPTER 7by combining the two methods. Multiplying the formula for the rectanglemethod by 2, adding the formula for the trapezoid method then dividing by3 gives the equations~bJ(~)d5=~(2r+t-2w5t5+...).The w3 term has disappeared, so this formula tells us that we can get a methodthat is accurate to within w5 by combining the quadrature formulas in thesame way:If an interval size of .Ol is used for Simpson™s rule, then the integral canbe computed to about ten-place accuracy. Again, this is borne out in ourexample. The implementation of Simpson™s method is only slightly more
complicated than the others (again, we consider the case where the intervals
are the same width):function intsimp(a, b: real; N: integer): real;var i: integer; w, s: real;begins:=O; w:=(b-a)/N;for i:=l to Ndos:=s+w*(f(a+(i-l)*w)+4*f(a-w/2+i*w)+f(a+i*w))/6;intsimp:=s;end ;This program requires three ﬁfunction evaluationsﬂ (rather than two) in theinner loop, but it produces far more accurate results than do the previous twomethods.10 0.6931473746651100 0.69314718057951000 0.6931471805599More complicated quadrature methods have been devised which gainaccuracy by combining simpler methods with similar errors. The most well-known is Romberg integration, which uses two different sets of subintervalsfor its two ﬁmethods.ﬂ
INTEGRATION85It turns out that Simpson™s method is exactly equivalent to interpolatingthe data to a piecewise quadratic function, then integrating. It is interestingto note that the four methods we have discussed all can be cast as piecewise
interpolation methods: the rectangle rule interpolates to a constant (degree-O
polynomial); the trapezoid rule to a line (degree-l polynomial); Simpson™s rule
to a quadratic polynomial; and spline qua.drature to a cubic polynomial.Adaptive QuadratureA major flaw in the methods that we have discussed so far is that the errorsinvolved depend not, only upon the subinterval size used, but also upon the
value of the high-order derivatives of the function being integrated. This
implies that the methods will not work well at all for certain functions (thosewith large high-order derivatives). But few functions have large high-orderderivatives everywhere. It is reasonable to use small intervals where the
derivatives are large and large intervals where the derivatives are small. A
method which does this in a systematic way is called an adaptive quadrature
routine.The general approach in adaptive quadrature is to use two differentquadrature methods for each subinterval, compare the results, and subdividethe interval further if the difference is too great. Of course some care should
be exercised, since if two equally bad methods are used, they might agree quiteclosely on a bad result. One way to avoid this is to ensure that one methodalways overestimates the result and that the other always underestimates the
result,. Another way to avoid this is to ensure that one method is more accurate
than the other. A method of this type is described next.There is significant overhead involved in recursively subdividing the in-terval, so it pays to use a good method fo:r estimating the integrals, as in thefollowing implementation:function adapt (a, b: real) : real;beginif abs(intsimp(a, b, 10)-intsimp(a, b, 5))<tolerancethen adapt:=intsimp(a, b, 10)else adapt:=adapt(a, (a+b)/2) + adapt((a+b)/2, b);end;Both estimates for the integral are derived from Simpson™s method, oneusing twice as many subdivisions as the other. Essentially, this amounts tochecking the accuracy of Simpson™s method over the interval in question andthen subdividing if it is not good enough.
86CHAPTER 7Unlike our other methods, where we decide how much work we wantto do and then take whatever accuracy results, in adaptive quadrature we dohowever much work is necessary to achieve a degree of accuracy that we decide
upon ahead of time. This means that tolerance must be chosen carefully,so that the routine doesn™t loop indefinitely to achieve an impossibly hightolerance. The number of steps required depends very much on the nature ofthe function being integrated. A function which fluctuates wildly will requirea large number of steps, but such a function would lead to a very inaccurateanswer for the ﬁfixed intervalﬂ methods. A smooth function such as our
example can be handled with a reasonable number of steps. The following
table gives, for various values of t, the value produced and the number ofrecursive calls required by the above routine to compute Jrz dx/x:0.00001000000 0.6931473746651 10.00000010000 0.6931471829695 50.00000000100 0.6931471806413 13
0.00000000001 0.6931471805623 33The above program can be improved in several ways. First, there™scertainly no need to call intsimp(a, b, IO) twice. In fact, the function valuesfor this call can be shared by intsimp(a, b, 5). Second, the tolerance boundcan be related to the accuracy of the answer more closely if the tolerance isscaled by the ratio of the size of the current interval to the size of the fullinterval. Also, a better routine can obviously be developed by using an evenbetter quadrature rule than Simpson™s (but it is a basic law of recursion that
another adaptive routine wouldn™t be a good idea). A sophisticated adaptivequadrature routine can provide very accurate results for problems which can™tbe handled any other way, but careful attention must be paid to the types of
functions to be processed.We will be seeing several algorithms that have the same recursive struc-ture as the adaptive quadrature method given above. The general techniqueof adapting simple methods to work hard only on difficult parts of complexproblems can be a powerful one in algorithm design.rl
INTEGRATION87Exercises1.2.3.4.5.6.7.8.9.10.Write a program to symbolically integrate (and differentiate) polynomialsin x and lnx. Use a recursive implementation based on integration by
parts.Which quadrature method is likely to produce the best answer for in-tegrating the following functions: f(s) = 5x, f(x) = (3 - x)(4 + z), f(s) =sin(x)?Give the result of using each of the four elementary quadrature methods(rectangle, trapezoid, Simpson™s, spline) to integrate y = l/x in the inter-val [.l,lO].Answer the previous question for the function y = sinx.Discuss what happens if adaptive quadrature is used to integrate thefunction y = l/x in the interval [-1,2].Answer the previous question for the elementary quadrature methods.Give the points of evaluation when adaptive quadrature is used to in-tegrate the function y = l/s in the interval [.l,lO] with a tolerance of.l.Compare the accuracy of an adaptive quadrature based on Simpson™smethod to an adaptive quadrature ba:sed on the rectangle method for theintegral given in the previous problent.Answer the previous question for the function y = sinx.Give a specific example of a function for which adaptive quadrature wouldbe likely to give a drastically more accurate result than the other methods.
88SOURCES for Mathematical AlgorithmsMuch of the material in this section falls within the domain of numeri-cal analysis, and several excellent textbooks are available. One which paysparticular attention to computational issues is the 1977 book by Forsythe,
Malcomb and Moler. In particular, much of the material given here in Chapters5, 6, and 7 is based on the presentation given in that book.The second major reference for this section is the second volume of D. E.Knuth™s comprehensive treatment of ﬁThe Art of Computer Programming.ﬂKnuth uses the term ﬁseminumericalﬂ to describe algorithms which lie atthe interface between numerical and symbolic computation, such as randomnumber generation and polynomial arithmetic. Among many other topics,
Knuths volume 2 covers in great depth the material given here in Chapters1, 3, and 4. The 1975 book by Borodin and Munro is an additional referencefor Strassen™s matrix multiplication method and related topics. Many ofthe algorithms that we™ve considered (and many others, principally symbolicmethods as mentioned in Chapter 7) are embodied in a computer system called
MACSYMA, which is regularly used for serious mathematical work.Certainly, a reader seeking more information on mathematical algorithmsshould expect to find the topics treated at a much more advanced mathemati-cal level in the references than the material we™ve considered here.Chapter 2 is concerned with elementary data structures, as well as poly-nomials. Beyond the references mentioned in the previous part, a reader in-terested in learning more about this subject might study how elementary datastructures are handled in modern programming languages such as Ada, whichhave facilities for building abstract data structures.A. Borodin and I. Munro, The Computational Complexity of Algebraic andNumerical Problems, American Elsevier, New York, 1975.G. E. Forsythe, M. A. Malcomb, and C. B. Moler, Computer Methods forMathematical Computations, Prentice-Hall, Englewood Cliffs, NJ, 1977.D. E. Knuth, The Art of Computer Programming. Volume &: SeminumericalAlgorithms, Addison-Wesley, Reading, MA (second edition), 1981.MIT Mathlab Group, MACSYMA Reference Manual, Laboratory for Comput-er Science, Massachusetts Institute of Technology, 1977.P. Wegner, Programming with ada: an introduction by means of graduatedexamples, Prentice-Hall, Englewood Cliffs, NJ, 1980.
SORTING... - .. .*.-...-. :.. -.. ... -... I . -. . :.:.

8. Elementary Sorting MethodsAs our first excursion into the area of sorting algorithms, we™ll studysome ﬁelementaryﬂ methods which are appropriate for small files orfiles with some special structure. There are several reasons for studying thesesimple sorting algorithms in some detail.First, they provide a relativelypainless way to learn terminology and basic mechanisms for sorting algorithmsso that we get an adequate background for studying the more sophisticated
algorithms. Second, there are a great ma.ny applications of sorting where it™sbetter to use these simple methods than the more powerful general-purposemethods. Finally, some of the simple methods extend to better general-purpose methods or can be used to improve the efficiency of more powerfulmethods. The most prominent example of this is seen in recursive sortswhich ﬁdivide and conquerﬂ big files into many small ones. Obviously, it isadvantageous to know the best way to deal with small files in such situations.As mentioned above, there are several sorting applications in which arelatively simple algorithm may be the method of choice. Sorting programsare often used only once (or only a few times). If the number of items to besorted is not too large (say, less than five hundred elements), it may well bemore efficient just to run a simple method than to implement and debug acomplicated method. Elementary metho™ds are always suitable for small files(say, less than fifty elements); it is unlikely that a sophisticated algorithmwould be justified for a small file, unless a very large number of such files are to
be sorted. Other types of files that are relatively easy to sort are ones that are
already almost sorted (or already sorted!‚) or ones that contain large numbersof equal keys. Simple methods can do much better on such well-structuredfiles than general-purpose methods.As a rule, the elementary methods that we™ll be discussing take aboutN2 steps to sort N randomly arranged items. If N is small enough, this maynot be a problem, and if the items are not randomly arranged, some of the91
92CHAPTER 8methods might run much faster than more sophisticated ones. However, itmust be emphasized that these methods (with one notable exception) shouldnot be used for large, randomly arranged files.Rules of the GameBefore considering some specific algorithms, it will be useful to discuss somegeneral terminology and basic assumptions for sorting algorithms. We™ll be
considering methods of sorting files of records containing keys. The keys,which are only part of the records (often a small part), are used to control thesort. The objective of the sorting method is to rearrange the records so that
their keys are in order according to some well-defined ordering rule (usually
numerical or alphabetical order).If the file to be sorted will fit into memory (or, in our context, if it willfit into a Pascal array), then the sorting method is called internal. Sortingfiles from tape or disk is called external sorting. The main difference betweenthe two is that any record can easily be accessed in an internal sort, whilean external sort must access records sequentially, or at least in large blocks.
We™ll look at a few external sorts in Chapter 13, but most of the algorithms
that we™ll consider are internal sorts.As usual, the main performance parameter that we™ll be interested in isthe running time of our sorting algorithms. As mentioned above, the elemen-tary methods that we™ll examine in this chapter require time proportional
to N2 to sort N items, while more advanced methods can sort N items intime proportional to N log N. It can be shown that no sorting algorithmcan use less than N log N comparisons between keys, but we™ll see that there
are methods that use digital properties of keys to get a total running time
proportional to N.The amount of extra memory used by a sorting algorithm is the secondimportant factor we™ll be considering. Basically, the methods divide into threetypes: those that sort in place and use no extra memory except perhaps for
a small stack or table; those that use a linked-list representation and so useN extra words of memory for list pointers; and those that need enough extramemory to hold another copy of the array to be sorted.A characteristic of sorting methods which is sometimes important inpractice is stability: a sorting method is called stable if it preserves the relativeorder of equal keys in the file. For example, if an alphabetized class list issorted by grade, then a stable method will produce a list in which studentswith the same grade are still in alphabetical order, but a non-stable method islikely to produce a list with no evidence of the original alphabetic order. Most
of the simple methods are stable, but most of the well-known sophisticatedalgorithms are not. If stability is vital, it can be forced by appending a
ELEMENTARY SORTING METHODS93small index to each key before sorting or 5y lengthening the sort key in someother way. It is easy to take stability for granted: people often react to theunpleasant effects of instability with disbelief. Actually there are few methods
which achieve stability without using significant extra time or space.The following program, for sorting three records, is intended to illustratethe general conventions that we™ll be using. (In particular, the main program isa peculiar way to exercise a program that is known to work only for N = 3: the
point is that most of the sorting programs we™ll consider could be substituted
for sort3 in this ﬁdriverﬂ program.)program threesort(input, output);con& maxN==100;var a: array [l..maxN] of integer;N, i: integer;procedure sort3;var t : integer;beginif a[l]>a[2] thenbegin t:-=a[l]; a[1if a[l]>a[J] then]:=a[2]; a[2]:=t endbegin t:=a[l]; a[l]:=a[3]; a[3]:=t end;if a[2]>a[3] thenbegin t:=a[2]; a[2]:=a[3]; a[3]:=t end;end;beginreadln (N) ;for i:=l to N do read(a[i]);if N=3 then sort3;for i:=l to N do write(a[i]);wri telnend.The three assignment statements following each if actually implement anﬁexchangeﬂ operation. We™ll write out the code for such exchanges rather thanuse a procedure call because they™re fundamental to many sorting programsand often fall in the inner loop.In order to concentrate on algorithmjc issues, we™ll work with algorithmsthat simply sort arrays of integers into numerical order. It is generally straight-forward to adapt such algorithms for use in a practical application involving
large keys or records. Basically, sorting programs access records in one of two
ways: either keys are accessed for comparison, or entire records are accessed
94CHAPTER 8to be moved. Most of the algorithms that we will study can be recast in termsof performing these two operations on arbitrary records. If the records to besorted are large, it is normally wise to do an ﬁindirect sortﬂ: here the recordsthemselves are not necessarily rearranged, but rather an array of pointers (orindices) is rearranged so that the first pointer points to the smallest record,
etc. The keys can be kept either with the records (if they are large) or with
the pointers (if they are small).By using programs which simply operate on a global array, we™re ignoringﬁpackaging problemsﬂ that can be troublesome in some programming environ-ments. Should the array be passed to the sorting routine as a parameter?Can the same sorting routine be used to sort arrays of integers and arraysof reals (and arrays of arbitrarily complex records)? Even with our simpleassumptions, we must (as usual) circumvent the lack of dynamic array sizes
in Pascal by predeclaring a maximum. Such concerns will be easier to deal
with in programming environments of the future than in those of the past
and present. For example, some modern languages have quite well-developed
facilities for packaging together programs into large systems. On the other
hand, such mechanisms are not truly required for many applications: small
programs which work directly on global arrays have many uses; and some
operating systems make it quite easy to put together simple programs like
the one above, which serve as ﬁfiltersﬂ between their input and their output.
Obviously, these comments apply to many of the other algorithms that we™ll
be examining, though their effects are perhaps most acutely felt for sortingalgorithms.Some of the programs use a few other global variables. Declarationswhich are not obvious will be included with the program code. Also, we™llsometimes assume that the array bounds go to 0 or iV+1, to hold special keysused by some of the algorithms. We™ll frequently use letters from the alphabetrather than numbers for examples: these are handled in the obvious way usingPascal™s ord and chr ﬁtransfer functionsﬂ between integers and characters.The sort3 program above uses an even more constrained access to the file:it is three instructions of the form ﬁcompare two records and exchange themif necessary to put the one with the smaller key first.ﬂ Programs which useonly this type of instruction are interesting because they are well suited forhardware implementation. We™ll study this issue in more detail in Chapter35.Selection SortOne of the simplest sorting algorithms works as follows: first find the smallestelement in the array and exchange it with the element in the first position,
then find the second smallest element and exchange it with the element in
ELEMENTARY SORTING METHODS95the second position, continuing in this way until the entire array is sorted.This method is called selection sort because it works by repeatedly ﬁselectingﬂthe smallest remaining element.The following program sorts a [1..N] intonumerical order:procedure selection;var i, j, min, t: integer;beginfor i:=l to N dobeginmin:=i;for j:=i+l to N doif ab]<a[min] then min:=j;t:=a[min]; a[min]:=a[i]; a[i]:=tend ;end ;This is among the simplest of sorting methods, and it will work very well forsmall files. Its running time is proportional to N2: the number of comparisonsbetween array elements is about N2/2 since the outer loop (on i) is executed Ntimes and the inner loop (on j) is executed about N/2 times on the average. Itturns out that the statement min:=j is executed only on the order of N log N
times, so it is not part of the inner loopDespite its simplicity, selection sort has a quite important application:it is the method of choice for sorting files with very large records and smallkeys. If the records are M words long (but the keys are only a few words long),then the exchange takes time proportional to M, so the total running timeis proportional to N2 (for the comparisons) plus NM (for the exchanges). IfM is proportional to N then the running time is linear in the amount of datainput, which is difficult to beat even with an advanced method. Of course ifit is not absolutely required that the records be actually rearranged, then anﬁindirect sortﬂ can be used to avoid the NM term entirely, so a method whichuses less comparisons would be justified. Still selection sort is quite attractivefor sorting (say) a thousand lOOO-word records on one-word keys.Insertion SortAn algorithm almost as simple as selection sort but perhaps more flexible isinsertion sort. This is the method often used by people to sort bridge hands:consider the elements one at a time, inserting each in its proper place amongthose already considered (keeping them s.orted). The element being consideredis inserted merely by moving larger elements one position to the right, then
96ChXPTER 8inserting the element into the vacated position. The code for this algorithmis straightforward:procedure insertion;var i, j, v: integer;beginfor i:=2 to N dobeginv:=a[i]; j:=i;while ab-1]>v dobegin ab] :=ab-11; j:=j-1 end;ab] :=vend ;end ;As is, this code doesn™t work, because the while will run past the left endof the array if t is the smallest element in the array. One way to fix this isto put a ﬁsentinelﬂ key in a[O],making it at least as small as the smallestelement in the array. Using sentinels in situations like this is common insorting programs to avoid including a test (in this case j>l) which almostalways succeeds within the inner loop. If for some reason it is inconvenient touse a sentinel and the array really must have the bounds [1..N], then standardPascal does not allow a clean alternative, since it does not have a ﬁconditionalﬂand instruction: the test while (j>l)and (a1j-l]>v) won™t work becauseeven when j=l, the second part of the and will be evaluated and will causean o&of-bounds array access. A goto out of the loop seems to be required.(Some programmers prefer to goto some lengths to avoid goto instructions,for example by performing an action within the loop to ensure that the loopterminates. In this case, such a solution seems hardly justified, since it makesthe program no clearer, and it adds extra overhead everytime through theloop to guard against a rare event.)On the average, the inner loop of insertion sort is executed about N2/2times: The ﬁaverageﬂ insertion goes about halfway into a subfile of size N/2.This is inherent in the method. The point of insertion can be found moreefficiently using the searching techniques in Chapter 14, but N2/2 moves (tomake room for each element being inserted) are still required; or the numberof moves can be lowered by using a linked list instead of an array, but then
the methods of Chapter 14 don™t apply and N2/2 comparisons are required(to find each insertion point).
ELEMENTARY SORTING METHODS97ShellsortInsertion sort is slow because it exchang,es only adjacent elements. For ex-ample, if the smallest element happens to be at the end of the array, it takesN steps to get it where it belongs. Shellsort is a simple extension of insertionsort which gets around this problem by allowing exchanges of elements thatare far apart.If we replace every occurrence of ﬁ1ﬂ by ﬁhﬂ (and ﬁ2ﬂ by ﬁh+lﬂ) ininsertion sort, the resulting program rearranges a file to give it the propertythat taking every hth element (starting anywhere) yields a sorted file. Such afile is said to be h-sorted. Put another way, an h-sorted file is h independentsorted files, interleaved together. By h-sorting for some large values of h, wecan move elements in the array long distances and thus make it easier to h-sortfor smaller values of h. Using such a procedure for any sequence of values ofh which ends in 1 will produce a sorted file: this is Shellsort.The following example shows how a sample file of fifteen elements issorted using the increments 13, 4, 1:123456789101112131415A S 0 R T I N G E X A M P L E13A E 0 R TI N C:EXAMPLS4A E A G EI N M P L 0 R T X S1AAEEGIL h4 N 0 P R S T XIn the first pass, the A in position 1 is compared to the L in position 14, thenthe S in position 2 is compared (and exchanged) with the E in position 15. Inthe second pass, the A T E P in positions 1, 5, 9, and 13 are rearranged toput A E P T in those positions, and similarly for positions 2, 6, 10, and 14,etc. The last pass is just insertion sort, but no element has to move very far.The above description of how Shellsort gains efficiency is necessarilyimprecise because no one has been able to analyze the algorithm. Somesequences of values of h work better than others, but no explanation for thishas been discovered. A sequence which has been shown empirically to do wellis . . . ,1093,364,121,40,13,4,1, as in the following program:
98CHAPTER 8procedure shellsort;label 0;var i, j, h, v: integer;beginh:=l; repeat h:=3*h+l until h>N;repeath:=h div 3;for i:=h+l to N dobeginv:=a[i]; j:=i;while ab-h]>v dobegina[j]:=ab-h]; j:=j-h;if j<=h then goto 0end ;0: ab]:=vend ;until h= 1;end ;Note that sentinels are not used because there would have to be h of them,for the largest value of h used.The increment sequence in this program is easy to use and leads to anefficient sort. There are many other increment sequences which lead to amore efficient sort (the reader might be amused to try to discover one), but itis difficult to beat the above program by more than 20% even for relativelylarge N. (The possibility that much better increment sequences exist is still,however, quite real.) On the other hand, there are some bad incrementsequences. Shellsort is sometimes implemented by starting at h=N (insteadof initializing so as to ensure the same sequence is always used as above). Thisvirtually ensures that a bad sequence will turn up for some N.Comparing Shellsort with other methods analytically is difficult becausethe functional form of the running time for Shellsort is not, even known (anddepends on the increment sequence). For the above program, two conjectures1 25are N(logN)2 and N .The running time is not particularly sensitive tothe initial ordering of the file, especially in contrast to, say, insertion sort,which is linear for a file already in order but quadratic for a file in reverseorder.Shellsort is the method of choice for many sorting applications because ithas acceptable running time even for moderately large files (say, five thousandelements) and requires only a very srnall amount of code, which is easy to get
ELEMENTARY SORTING METHODS99working. We™ll see methods that are more efficient in the next few chapters,but they™re perhaps only twice as fast (if that much) except for large N, andthey™re significantly more complicated. In short, if you have a sorting problem,use the above program, then determine vvhether the extra effort required toreplace it with a sophisticated method will be worthwhile. (On the otherhand, the Quicksort algorithm of the next chapter is not that much moredifficult to implement. . . )Digression: Bubble SortAn elementary sorting method that is often taught in introductory classes isbubble sort: keep passing through the file, exchanging adjacent elements, ifnecessary; when no exchanges are required on some pass, the file is sorted.An implementation of this method is given below.procedure bubblesort;var j, t: integer;beginrepeatt:=a[l];for j:=2 to N doif ab--l]>alj] thenbegin t:=:a[j-I]; ab-1]:=ab]; a[j]:=t enduntil t=a[l];end ;It takes a moment™s reflection to convince oneself first that this works at all,second that the running time is quadratic.It is not clear why this methodis so often taught, since insertion sort seems simpler and more efficient byalmost any measure. The inner loop of bubble sort has about twice as manyinstructions as either insertion sort or selection sort.Distribution CountingA very special situation for which there is a simple sorting algorithm is thefollowing: ﬁsort a file of N records whose keys are distinct integers between 1and N.ﬂ The algorithm for this problem isfor i:=l to N do t[a[i]]:=a[i];for i:=l to N do a[i]:=t[i];
100CHAPTER 8This algorithm uses a temporary array t. It is possible (but much morecomplicated) to solve this problem without an auxiliary array.A more realistic problem solved by an algorithm in the same spirit is:ﬁsort a file of N records whose keys are integers between 0 and M - 1.ﬂ If Mis not too large, an algorithm called distribution counting can be used to solvethis problem. The idea is to count the number of keys with each value, thenuse the counts to move the records into position on a second pass through thefile, as in the following code:for j:=O to M-l do countlj]:=O;for i:=l to Ndocount[a[i]]:=count[a[i]]+l;for j:=l to M-l docount b] :=count Ij-l]+count b] ;for i:=N downto 1 dobegint[count[a[i]]]:=a[i];count[a[i]]:=count[a[i]]-1end ;for i:=l to N do a[i]:=t[i];To see how this code works, consider the following sample file of integers:1 2 3 4 5 6 7 89 10 11 12 13 14 15 163 110 3 7 5 5 2 4 2 10 2 6 4The first for loop initializes the counts to 0; the second produces the counts0 1 2 3 4 5 6 72 3 3 2 2 2 1 1This says that there are two O™s, three l™s, etc. The third for loop adds thesenumbers to produce0 1 2 3 4 5 6 72 58 10 12 14 15 16That is, there are two numbers less than 1, five numbers less than 2, etc.Now, these can be used as addresses to sort the array:1 2 3 4 5 6 7 89 10 11 12 13 14 15 160 0 1112 2 2 3 3 4 4 5 5 6 7
ELEMENTARY SORTING METHODS101For example, when the 4 at the end of the file is encountered, it™s put intolocation 12, since count[4] says that there are 12 keys less than or equal to4. Then count[4] is decremented, since there™s now one less key less than orequal to 4. The inner loop goes from N down to 1 so that the sort will bestable. (The reader may wish to check this.)This method will work very well for the type of files postulated. Further-more, it can be extended to produce a much more powerful method that we™llexamine in Chapter 10.Non-Random FilesWe usually think of sorting files that are in some arbitrarily scrambled order.However, it is quite often the case that we have a lot of information about a
file to be sorted. For example, one often wants to add a few elements to asorted file and thus produce a larger sorted file. One way to do so is to simplyappend the new elements to the end of t.he file, then call a sorting algorithm.General-purpose sorts are commonly mi™sused for such applications; actually,elementary methods can take advantage of the order present in the file.For example, consider the operation of insertion sort on a file which isalready sorted. Each element is immediately determined to be in its proper inthe file, and the total running time is linear. The same is true for bubble sort,but selection sort is still quadratic. (The leading term in the running time ofselection sort does not depend on the order in the file to be sorted.)Even if a file is not completely sorted, insertion sort can be quite usefulbecause the running time of insertion sort depends quite heavily on the orderpresent in the file. The running time depends on the number of inversions: foreach element count up the number of e:iements to its left which are greater.This is the distance the elements have to move when inserted into the fileduring insertion sort. A file which has some order in it will have fewer
inversions in it than one which is arbitrarily scrambled.The example cited above of a file formed by tacking a few new elenientsonto a large sorted file is clearly a case where the number of the inversionsis low: a file which has only a constant number of elements out of place will
have only a linear number of inversions. Another example is a file where each
element is only a constant distance front its final position. Files like this can
be created in the initial stages of some advanced sorting methods: at a certain
point it is worthwhile to switch over to jnsertion sort.In short, insertion sort is the method of choice for ﬁalmost sortedﬂ fileswith few inversions: for such files, it will outperform even the sophisticatedmethods in the next few chapters.
102Exercises1.2.3.4.5.6.7.8.9.10.Give a sequence of ﬁcompare-exchangeﬂ operations for sorting four records.Which of the three elementary methods runs fastest for a file which isalready sorted?Which of the three elementary methods runs fastest for a file in reverseorder?Test the hypothesis that selection sort is the fastest of the three elemen-tary methods, then insertion sort, then bubble sort.Give a good reason why it might be inconvenient to use a sentinel key forinsertion sort (aside from the one that comes up in the implementation
of Shellsort).How many comparisons are used by Shellsort to 7-sort, then S-sort thekeys EASYQUESTION?Give an example to show why 8,4,2,1 would not be a good way to finishoff a Shellsort increment sequence.Is selection sort stable? How about insertion sort and bubble sort?Give a specialized version of distribution counting for sorting files whereelements have only one of two values (x or y).Experiment with different increment sequences for Shellsort: find one thatruns faster than the one given for a random file of 1000 elements.
9. QuicksortIn this chapter, we™ll study the sorting algorithm which is probablymore widely used than any other, Quicksort. The basic algorithm wasinvented in 1960 by C. A. R. Hoare, and it has been studied by many peoplesince that time. Quicksort is popular because it™s not difficult to implement,it™s a good ﬁgeneral-purposeﬂ sort (works well in a variety of situations), andit consumes less resources than any other sorting method in many situations.The desirable features of the Quicksort algorithm are that it is in-place(uses only a small auxiliary stack), requires only about NlogN operationson the average to sort N items, and has an extremely short inner loop.The drawbacks of the algorithm are that it is recursive (implementation iscomplicated if recursion is not available), has a worst case where it takes
about N2 operations, and is fragile: a simple mistake in the implementationmight go unnoticed and could cause it tea perform badly for some files.The performance of Quicksort is very well understood. It has beensubjected to a thorough mathematical analysis and very precise statementscan be made about performance issues.The analysis has been verified byextensive empirical experience, and the algorithm has been refined to thepoint where it is the method of choice in a broad variety of practical sorting
applications. This makes it worthwhile to look somewhat more carefully at
ways of efficiently implementing Quicksort than we have for other algorithms.
Similar implementation techniques are appropriate for other algorithms; withQuicksort we can use them with confidence because the performance is so wellunderstood.It is tempting to try to develop ways to improve Quicksort: a fastersorting algorithm is computer science™s ﬁbetter mousetrap.ﬂ Almost from themoment Hoare first published the algorithm,ﬁimprovedﬂ versions have beenappearing in the literature. Many ideas have been tried and analyzed, butit is easy to be deceived, because the algorithm is so well balanced that the103
104CHAPTER 9effects of improvements in one part of the program can be more than offset bythe effects of bad performance in another part of the program. We™ll examinein some detail three modifications which do improve Quicksort substantially.A carefully tuned version of Quicksort is likely to run significantly fasterthan any other sorting method on most computers. However, it must becautioned that tuning any algorithm can make it more fragile, leading to
undesirable and unexpected effects for some inputs. Once a version has been
developed which seems free of such effects, this is likely to be the program to
use for a library sort utility or for a serious sorting application. But if one is
not willing to invest the effort to be sure that a Quicksort implementation is
not flawed, Shellsort is a much safer choice and will perform adequately for
significantly less implementation effort.The Basic AlgorithmQuicksort is a ﬁdivide-and-conquerﬂ method for sorting. It works by partition-ing a file into two parts, then sorting the parts independently. As we will see,the exact position of the partition depends on the file, so the algorithm hasthe following recursive structure:procedure quicksort(l, r: integer);var i;beginif r>l thenbegini:=:partition(1, r)quicksort (1, i- 1) ;quicksort(i+l, r);endend ;The parameters I and r delimit the subfile within the original file that is tobe sorted: the call quicksort(l, N) sorts the whole file.The crux of the method is the partition procedure, which must rearrangethe array to make the following three conditions hold:(i) the element a[i] is in its final place in the array for some i,(ii) all the elements in a[]],. . .,a[i-l] are less than or equal to a[i],(iii) all the elements in a[i+l], . . .,a[r] are greater than or equal to a[i].This can be simply and easily implemented through the following generalstrategy. First, arbitrarily choose a[r] to be the element that will go into
QUICKSORT105its final position. Next, scan from the left end of the array until findingan element greater than a[r] and scan from the right end of the array untilfinding an element less than a[r]. The two elements which stopped the scansare obviously out of place in the final p,srtitioned array, so exchange them.(Actually, it turns out, for reasons described below, to be best to also stop thescans for elements equal to a[r], even though this might seem to involve someunnecessary exhanges.) Cont,inuing in this way ensures that all array elementsto the left of the left pointer are less than a[r], and array elements to the rightof the right pointer are greater than a [r] . When the scan pointers cross, thepartitioning process is nearly complete: all that remains is to exchange a[r]with the leftmost element of the right subfile.The following table shows how our sample file of keys is partitioned usingthis method:123456789101112131415A S 0 R TINGEXAMPLHA AS M P LmA A EOXSMPLNAA EHTINGOXSMPLRThe rightmost element, E, is chosen as the partitioning element. Firstthe scan from the left stops at the S, then the scan from the right stops at theA, then these two are exchanged, as shown on the second line of the table.Next the scan from the left stops at the 0, then the scan from the right stopsat the E, then these two are exchanged, as shown on the third line of thetable. Next the pointers cross. The scan from the left stops at the R, andthe scan from the right stops at the E. The proper move at this point is toexchange the E at the right with the R, leaving the partitioned file shown on
the last line of the table. The sort is finished by sorting the two subfiles oneither side of the partitioning element (recursively).The following program gives a full implementation of the method.
106CHAPTER 9procedure quicksort(1, r: integer) ;var v, t, i, j: integer;beginif r>l thenbeginv:=a[r]; i:=I-I; j:=r;repeatrepeat i:=i+l until a[i]>=v;repeat j:=j-1 until ab]<=v;t:=a[i]; a[i]:=alj]; ab]:=t;until j<=i;a[j]:=a[i]; a[i]:=a[r]; a[rJ:=t;quicksort(l, i-l);quicksort(i+l, r)endend;In this implementation, the variable v holds the current value of the ﬁpartition-ing elementﬂ a[r], and i and j are the left and right scan pointers, respectively.An extra exchange of a[i] with a b] is done with j<i just after the pointers crossbut before the crossing is detected and the outer repeat loop exited. (Thiscould be avoided with a goto.) The three assignment statements following thatloop implement the exchanges a[i] with a[j] (to undo the extra exchange) anda[i] with a[r] (to put the partitioning element into position).As in insertion sort, a sentinel key is needed to stop the scan in thecase that the partitioning element is the smallest element in the file. In thisimplementation, no sentinel is needed to stop the scan when the partitioning
element is the largest element in the file, because the partitioning elementitself is at the right end of the file to stop the scan. We™ll shortly see an easyway to avoid having either sentinel key.The ﬁinner loopﬂ of Quicksort consists simply of incrementing a pointerand comparing an array element against a fixed value. This is really whatmakes Quicksort quick: it™s hard to imagine a simpler inner loop.Now the two subfiles are sorted recursively, finishing the sort. Thefollowing table traces through these recursive calls. Each line depicts the resultof partitioning the displayed subfile, using the boxed partitioning element.
QUICKSORT107123456789101112131415ASORTINGEXAMPLEAAEmTINGOXSMPLRA A(El0A AI.4L IN G 0 P MUX T SLIGmOPNL-lG I L@IL-lI0N P 0u0 P0PclS T XwAAEEGILMNOPRSTXNote that every element is (eventually) put into place by being used as apartitioning element.The most disturbing feature of the program above is that it runs veryinefficiently on simple files. For example, if it is called with a file that is alreadysorted, the partitions will be degenerate, and the program will call itself N
times, only knocking off one element for each call. This means not only
that the time required will be about N2/2, but also that the space requiredto handle the recursion will be about N (see below), which is unacceptable.Fortunately, there are relatively easy ways to ensure that this worst casedoesn™t occur in actual applications of the program.When equal keys are present in the file, two subtleties become apparent.First, there is the question of whether to have both pointers stop on keys
CHAPTER 9equal to the partitioning element, or to have one pointer stop and the otherscan over them, or to have both pointers scan over them. This question has
actually been studied in some detail mathematically, with the result thatit™s best to have both pointers stop. This tends to balance the partitions inthe presence of many equal keys. Second, there is the question of properly
handling the pointer crossing in the presence of equal keys. Actually, the
program above can be slightly improved by terminating the scans when j<i,then using quicksort(l, j) for the first recursive call. This is an improvementbecause when j=i we can put two elements into position with the partitioning,by letting the loop iterate one more time. (This case occurs, for example, if Rwere E in the example above.) It is probably worth making this change becausethe program given leaves a record with a key equal to the partitioning key ina[r], which makes the first partition in the call quicksort(i+l, r) degeneratebecause its rightmost key is its smallest. The implementation of partitioninggiven above is a bit easier to understand, so we™ll leave it as is in the discussions
below, with the understanding that this change should be made when large
numbers of equal keys are present.The best thing that could happen would be for each partitioning stage todivide the file exactly in half. This would make the number of comparisonsused by Quicksort satisfy the divide-and-conquer recurrenceC(N) = 2C(N/2) + N.(The 2C(N/2) covers the cost of doing the two subfiles; the N is the cost ofexamining each element, using one partitioning pointer or the other.) FromChapter 4, we know this recurrence has the solutionC(N) z N lg iv.Though things don™t always go this well, it is true that the partition fallsin the middle on the average. Taking the precise probability of each parti-
tion position into account makes the recurrence more complicated, and more
difficult to solve, but the final result is similar. It turns out thatC(N) 25 2NlnN,which implies that the total running time of Quicksort is proportional toN log N (on the average).Thus, the implementation above will perform very well for many applica-tions and is a very reasonable general-purpose sort. However, if the sort is tobe used a great many times, or if it is to be used to sort a very large file, thenit might be worthwhile to implement several of the improvements discussedbelow which can ensure that the worst case won™t occur, reduce the average
running time by 20-30%, and easily eliminate the need for a sentinel key.
QUICKSORT109Removing RecursionIn Chapter 1 we saw that the recursive call could be removed from Euclid™salgorithm to yield a non-recursive program controlled by a simple loop. Thiscan be done for other programs with one recursive call, but the situationis more complicated when two or more recursive calls are involved, as in
Quicksort. Before dealing with one recursive call, enough information must
be saved to allow processing of later recursive calls.The Pascal programming environment uses a pushdown stack to managethis. Each time a procedure call is made, the values of all the variables arepushed onto the stack (saved). Each time a procedure returns, the stack ispopped: the information that was most recently put on it is removed.A stack may be represented as a linked list, in which case a push isimplemented by linking a new node onto the front of the list and a popby removing the first node on the list, or as an array, in which case apointer is maintained which points to the top of the stack, so that a pushis implemented by storing the information and incrementing the pointer, and
a pop by decrementing the pointer and retrieving the information.There is a companion data structure called a queue, where items arereturned in the order they were added. In a linked list implementation ofa queue new items are added at the end, not the beginning. The arrayimplementation of queues is slightly more complicated. Later in this bookwe™ll see other examples of data structures which support the twin operationsof inserting new items and deleting items according to a prescribed rule (mostnotably in Chapters 11 and 20).When we use recursive calls, the values of all variables are saved on animplicit stack by the programming environment; when we want an improvedprogram, we use an explicit stack and save only necessary information. It
is usually possible to determine which variables must be saved by examiningthe program carefully; another approach is to rework the algorithm based onusing an explicit stack rather than explicit recursion.This second approach is particularly appropriate for Quicksort and manysimilar algorithms. We think of the stack as containing ﬁwork to be done,ﬂin the form of subfiles to be sorted. Any time we need a subfile to process,we pop the stack. When we partition, we create two subfiles to be processed,which can be pushed on the stack. This leads to the following non-recursiveimplementation of Quicksort:
110CHAPTER 9procedure quicksort;var t, i, 1, r: integer;stack: array[O..M] of integer; p: integer;begin1:=1; r:=N; p:=2;repeatif r>l thenbegini:=partition(l, r);if (i-l)> (r-i)then begin stack[p] :=I; stack[p+l] :=i-I; I:=i+I endelse begin stack[p] :=i+l; stack[p+l] :=r; r:=i-I end;p:=p+2;endelsebegin p:=p-2; I:=stack[p]; r:=stack[p+I] end;until p=Oend;This program differs from the description above in two important ways. First,,rather than simply putting two subfiles on the stack in some arbitrary order,their sizes are checked and the larger of the two is put on the stack first.Second, the smaller of the two subfiles is not put on the stack at all; the valuesof the parameters are simply reset,, just as we did for Euclid™s algorithm. Thistechnique, called ﬁend-recursion removalﬂ can be applied to any procedurewhose last action is a recursive call. For Quicksort, the combination of end-recursion removal and a policy of processing the smaller of the two subfilesfirst turns out to ensure that the stack need only contain room for about, lg Nentries, since each entry on the stack after the top one must represent a subfileless than half the size of the previous entry.This is in sharp contrast to the size of the stack in the worst case in therecursive implementation, which could be as large as N (for example, in thecase that the file is already sorted). This is a subtle but real difficulty with
a recursive implementation of Quicksort: there™s always an underlying stack,
and a degenerate case on a large file could cause the program to terminate
abnormally because of lack of memory. This behavior is obviously undesirablefor a library sorting routine. Below we™ll see ways to make degenerate casesextremely unlikely, but, there™s no way to avoid this problem completely ina recursive implementation (even switching the order in which subfiles areprocessed doesn™t help, without end-recursion removal).Of course the non-recursive method processes the same subfiles as the
QUICKSORT111recursive method for our example; it just does them in a different order, asshown in the following table:123456789 10 11 12 13 14 15ASORTINGEXAMPLEAAEIE/INGOXSMPLRA A[EluA A0ALING0PM0R X TElS TTSXL IGmO P N0G I Lal0I0N P 000 PPAAAEEGILMNOPRSTXThe simple use of an explicit stack above leads to a far more efficientprogram than the direct recursive implementation, but there is still overheadthat could be removed. The problem is that, if both subfiles have only oneelement, entries with r-1 are put on the stack only to be immediately takenoff and discarded. It is straightforward to change the program to simply notput any such files on the stack. This change is more important when the nextimprovement is included, which involves ignoring small subfiles in the sameway.
112CHAPTER 9Small SubfilesThe second improvement stems from the observation that a recursive programis guaranteed to call itself for many small subfiles, so it should be changed to
use a better method when small subfiles are encountered. One obvious way todo this is to change the test at the beginning of the recursive routine from ﬁifr>l thenﬂ to a call on insertion sort (modified to accept parameters definingthe subfile to be sorted), that is ﬁif r-l <= M then insertion(1, r).ﬂ Here Mis some parameter whose exact value depends upon the implementation. Thevalue chosen for M need not be the best possible: the algorithm works aboutthe same for M in the range from about 5 to about 25. The reduction in therunning time is on the order of 20% for most applications.A slightly easier method, which is also slightly more efficient, is to justchange the test at the beginning to ﬁif r-l > M thenﬂ: that is, simply ignoresmall subfiles during partitioning. In the non-recursive implementation, thiswould be done by not putting any files of less than M on the stack. Afterpartitioning, what is left is a file that is almost sorted. As mentioned in theprevious chapter, insertion sort is the method of choice for such files. That
is, insertion sort will work about as well for such a file as for the collection of
little files that it would get if it were being used directly. This method should
be used with caution, because the insertion sort is likely always to sort evenif the Quicksort has a bug which causes it not to work at all. The excessivecost may be the only sign that something went wrong.Median-of- Three PartitioningThe third improvement is to use a better partitioning element. There areseveral possibilities here. The safest thing to do to avoid the worst case wouldbe to use a random element from the array for a partitioning element. Thenthe worst case will happen with negligibly small probability. This is a simpleexample of a ﬁprobabilistic algorithm,ﬂwhich uses randomness to achievegood performance almost always, regardless of the arrangement of the input.This can be a useful tool in algorithm design, especially if some bias in the
input is suspectred. However, for Quicksort it is probably overkill to put a fullrandom-number generator in just for this purpose: an arbitrary number willdo just as well.A more useful improvement is to take three elements from the file, thenuse the median of the three for the partilioning element. If the three elementschosen are from the left,, middle, and right of the array, then the use ofsentinels can be avoided as follows: sort the three elements (using the three-exchange method in the last chapter), then exchange the one in the middlewith air-l], then run the partitioning algorithm on a[1+1, . . ..r-21. Thisimprovement is called the median-of-three partitioning method.
QUICKSORT113The median-of-three method helps Quicksort in three ways. First, itmakes the worst case much more unlikely to occur in any actual sort. In orderfor the sort to take N2 time, two out of the three elements examined must beamong the largest or among the smallest elements in the file, and this musthappen consistently through most of the partitions. Second, it eliminates theneed for a sentinel key for partitioning, since this function is served by the
three elements examined before partitioning. Third, it actually reduces the
total running time of the algorithm by about 5%.The combination of a nonrecursive implementation of the median-of-three method with a cutoff for small subfiles can improve the running time ofQuicksort from the naive recursive implementation by 25% to 30%. Furtheralgorithmic improvements are possible (for example the median of five or moreelements could be used), but the amount of time saved will be marginal. Moresignificant time savings can be realized (with less effort) by coding the innerloops (or the whole program) in assembly or machine language. Neither pathis recommended except for experts with serious sorting applications.
114Exercises1.2.3.4.5.6.
7.
8.9.10.Implement a recursive Quicksort with a cutoff to insertion sort for subfileswith less than M elements and empirically determine the value of M forwhich it runs fastest on a random file of 1000 elements.Solve the previous problem for a nonrecursive implementation.Solve the previous problem also incorporating the median-of-three im-provement.About how long will Quicksort take to sort a file of N equal elements?What is the maximum number of times that the largest element could bemoved during the execution of Quicksort?Show how the file ABABABA is partitioned, using the two methodssuggested in the text.How many comparisons does Quicksort use to sort the keys EASY QUESTION?How many ﬁsentinelﬂ keys are needed if insertion sort is called directlyfrom within Quicksort?Would it be reasonable to use a queue instead of a stack for a non-recursiveimplementation of Quicksort? Why or why not?Use a least squares curvefitter to find values of a and b that give thebest formula of the form aN In N + bN for describing the total numberof instructions executed when Quicksort is run on a random file.
10. Radix SortingThe ﬁkeysﬂ used to define the order of the records in files for manysorting applications can be very complicated. (For example, considerthe ordering function used in the telephone book or a library catalogue.)Because of this, it is reasonable to define sorting methods in terms of the
basic operations of ﬁcomparingﬂ two keys and ﬁexchangingﬂ two records.
Most of the methods we have studied can be described in terms of these two
fundamental operations. For many applications, however, it is possible totake advantage of the fact that the keys can be thought of as numbers fromsome restricted range. Sorting methods which take advantage of the digitalproperties of these numbers are called radix sorts. These methods do not justcompare keys: they process and compare pieces of keys.Radix sorting algorithms treat the keys as numbers represented in abase-M number system, for different values of M (the radix) and work withindividual digits of the numbers. For example, consider an imaginary problemwhere a clerk must sort a pile of cards with three-digit numbers printed on
them. One reasonable way for him to proceed is to make ten piles: one for
the numbers less than 100, one for the numbers between 100 and 199, etc.,
place the cards in the piles, then deal with the piles individually, either byusing the same method on the next dig:t or by using some simpler methodif there are only a few cards. This is a slimple example of a radix sort withM = 10. We™ll examine this and some other methods in detail in this chapter.Of course, with most computers it™s more convenient to work with M = 2 (orsome power of 2) rather than M = 10.Anything that™s represented inside a digital computer can be treatedas a binary number, so many sorting applications can be recast to makefeasible the use of radix sorts operating on keys which are binary numbers.Unfortunately, Pascal and many other lari.guages intentionally make it difficultto write a program that depends on the binary representation of numbers.115
116CYHPTER 10(The reason is that Pascal is intended to be a language for expressing programsin a machine-independent manner, and different computers may use differentrepresentations for the same numbers.) This philosophy eliminates many types
of ﬁbit-flickingﬂ techniques in situations better handled by fundamental Pascal
constructs such as records and sets, but radix sorting seems to be a casualty of
this progressive philosophy. Fortunately, it™s not too difficult to use arithmetic
operations to simulate the operations needed, and so we™ll be able to write
(inefficient) Pascal programs to describe the algorithms that can be easily
translated to efficient programs in programming languages that support bit
operations on binary numbers.Given a (key represented as a) binary number, the fundamental operationneeded for radix sorts is extracting a contiguous set of bits from the number.Suppose we are to process keys which we know to be integers between 0 and1000. We may assume that these are represented by ten-bit binary numbers.In machine language, bits are extracted from binary numbers by using bitwiseﬁandﬂ operations and shifts. For example, the leading two bits of a ten-bitnumber are extracted by shifting right eight bit positions, then doing a bitwiseﬁandﬂ with the mask 0000000011. In Pascal, these operations can be simulatedwith div and mod. For example, the leading two bits of a ten-bit number xare given by (x div 256)mod 4. In general, ﬁshift 2 right k bit positionsﬂcan be simulated by computing x div 2k,and ﬁzero all but the j rightmostbits of xﬂ can be simulated by computing x mod 2j. In our description ofthe radix sort algorithms, we™ll assume the existence of a function bits(x, k, j:integer): integer which combines these operations to return the j bits whichappear k bits from the right in 5 by computing (x div ak) mod 23. Forexample, the rightmost bit of z is returned by the call bits(x, 0,l). Thisfunction can be made efficient by precomputing (or defining as constants)the powers of 2. Note that a program which uses only this function willdo radix sorting whatever the representation of the numbers, though we can
hope for much improved efficiency if the representation is binary and the
compiler is clever enough to notice that the computation can actually be
done with machine language ﬁshiftﬂ and ﬁandﬂ instructions. Many Pascal
implementations have extensions to the language which allow these operations
to be specified somewhat more directly.Armed with this basic tool, we™ll consider two different types of radixsorts which differ in the order in which they examine the bits of the keys. Weassume that the keys are not short, so that it is worthwhile to go to the effortof extracting their bits. If the keys are short, then the distribution countingmethod in Chapter 8 can be used. Recall that this method can sort N keys
known to be integers between 0 and M - 1 in linear time, using one auxiliarytable of size M for counts and another of size N for rearranging records.Thus, if we can afford a table of size 2™, then b-bit keys can easily be sorted
RADIX SORTING117in linear time. Radix sorting comes into play if the keys are sufficiently long(say b = 32) that this is not possible.The first basic method for radix sorting that we™ll consider examines thebits in the keys from left to right. It is based on the fact that the outcome ofﬁcomparisonsﬂ between two keys depend: only on the value of the bits at thefirst position at which they differ (reading from left to right). Thus, all keyswith leading bit 0 appear before all keys with leading bit 1 in the sorted file;among the keys with leading bit 1, all keys with second bit 0 appear beforeall keys with second bit 1, and so forth. The left-to-right radix sort, whichis called radix exchange sort, sorts by sy::tematically dividing up the keys inthis way.The second basic method that we™ll consider, called straight radix sort,examines the bits in the keys from right to left. It is based on an interestingprinciple that reduces a sort on b-bit keys to b sorts on l-bit keys. We™ll seehow this can be combined with distribution counting to produce a sort thatruns in linear time under quite generous assumptions.The running times of both basic radix sorts for sorting N records with bbit keys is essentially Nb. On the one hanIl, one can think of this running timeas being essentially the same as N log N, ;;ince if the numbers are all different,b must be at least 1ogN. On the other hand, both methods usually usemany fewer than Nb operations: the left-to-right method because it can stoponce differences between keys have been Yound; and the right-to-left method,because it can process many bits at once.Radix Exchange SortSuppose we can rearrange the records of a file so that all those whose keysbegin with a 0 bit come before all those whose keys begin with a 1 bit. Thisimmediately defines a recursive sorting method: if the two subfiles are sortedindependently, then the whole file is sorted. The rearrangement (of the file)is done very much like the partitioning n Quicksort: scan from the left tofind a key which starts with a 1 bit, scan from the right to find a key whichstarts with a 0 bit, exchange, and continue the process until the scanningpointers cross. This leads to a recursive sorting procedure that is very similarto Quicksort:
118CHAPTER 10procedure radixexchange(l, r, b: integer);var t, i, j: integer;beginif (r>l) and (b>=O) thenbegini:=]; j:=r;repeatwhile (bits(a[i], b, 1)=0) and (i<j) do i:=i+l;while (bits(ab], b, 1)=1) and (i<j) do j:=j-1;t:=a[i]; a[i]:=a[j]; ab]:=t;until j=i;if bits(a[r], b, I)=0 then j:=j+l;radixexchange(l, j-1, b-l);radixexchangedj, r, b-l) ;endend ;For simplicity, assume that a [1..N] contains positive integers less than 232(that is, they could be represented as 31-bit binary numbers). Then the callradixexchange(1, N, 30) will sort the array. The variable b keeps track ofthe bit being examined, ranging from 30 (leftmost) down to 0 (rightmost).(It is normally possible to adapt the implementation of bits to the machinerepresentation of negative numbers so that negative numbers are handled ina uniform way in the sort.)This implementation is obviously quite similar to the recursive implemen-tation of Quicksort in the previous chapter. Essentially, the partitioning inradix exchange sort is like partitioning in Quicksort except that the number2b is used instead of some number from the file as the partitioning element.Since 2b may not be in the file, there can be no guarantee that an elementis put into its final place during partitioning. Also, since only one bit is be-ing examined, we can™t rely on sentinels to stop the pointer scans; therefore
the tests (i<j) are included in the scanning loops. As with Quicksort, an
extra exchange is done for the case j=i, but it is not necessary to undo thisexchange outside the loop because the ﬁexchangeﬂ is a[i] with itself. Also aswith Quicksort, some care is necessary in this algorithm to ensure that the
nothing ever ﬁfalls between the cracksﬂ when the recursive calls are made.The partitioning stops with j=i and all elements to the right of a[i] having 1bits in the bth position and all elements to the left of a[i] having 0 bits in thebth position. The element a[i] itself will have a 1 bit unless all keys in thefile have a 0 in position b. The implementation above has an extra test justafter the partitioning loop to cover this case.
RADIX SORTING119The following table shows how our rample file of keys is partitioned andsorted by this method. This table is can be compared with the table given inChapter 9 for Quicksort, though the operation of the partitioning method iscompletely opaque without the binary representation of the keys.123456789101112131415ASORTINGEXAMPLEAEOLMINGEAXTPRS
AEAEGINMLO
A A E E G
A A
A AE E GE EI N b/i L 0L M N 0L MN0STPRXS R P TP R SR SAAEEGILMNOPRSTXThe binary representation of the keys used for this example is a simplefive-bit code with the ith letter in the alphabet represented by the binaryrepresentation of the number i. This, is a simplified version of real charactercodes, which use more bits (seven or eight) and represent more characters(upper/lower case letters, numbers, special symbols). By translating the keysin this table to this five-bit characte:i* code, compressing the table so that thesubfile partitioning is shown ﬁin parallelﬂ rather than one per line, and then
120CIIAF™TER 10transposing rows and columns, we can see how the leading bits of the keyscontrol partitioning:A00001A00001s10011E00101001111001111R10010L01100T10100M01101I01001I01001N01110N01110G00111G00111E00101E00101x11000A00001A00001x11000M01101T10100P10000P10000L01100R10010E00101s10011A00001E00101A00001E00101G00111I01001N01110M01101L01100001111s10011T10100P10000R10010x11000A00001A00001E00101E00101G00111I01001N01110M01101L01100001111s10011R10010P10000T10100L011 0MN01110001111P011 i 1100 0R10010s10011A 00001A 00001E 00101E 00101L 01100M 01101N 011100 01111R 10010s 10011One serious potential problem for radix sort not brought out in thisexample is that degenerate partitions (with all keys having the same value forthe bit being used) can happen frequently. For example, this arises commonlyin real files when small numbers (with many leading zeros) are being sorted.It also occurs for characters: for example suppose that 32-bit keys are made
up from four characters by encoding each in a standard eight-bit code thenputting them together. Then degenerate partitions are likely to happen at thebeginning of each character position, since, for example, lower case letters allbegin with the same bits in most character codes. Many other similar effects
are obviously of concern when sorting encoded data.From the example, it can be seen that once a key is distinguished fromall the other keys by its left bits, no further bits are examined. This is adistinct advantage in some situations, a disadvantage in others. When thekeys are truly random bits, each key should differ from the others after aboutlg N bits, which could be many fewer than the number of bits in the keys.This is because, in a random situation, we expect each partition to divide thesubfile in half. For example, sorting a file with 1000 records might involveonly examining about ten or eleven bits from each key (even if the keysare, say, 32-bit keys). On the other hand, notice that all the bits of equalkeys are examined. Radix sorting simply does not work well on files which
R&XX SORTING121contain many equal keys. Radix exchange sort is actually slightly faster thanQuicksort if the keys to be sorted are comprised of truly random bits, but
Quicksort can adapt better to less randon situations.Straight Radix SortAn alternative radix sorting method is tc examine the bits from right to left.This is the method used by old computer-card-sorting machines: a deck ofcards was run through the machine 80 times, once for each column, proceedingfrom right to left. The following example shows how a right-to-left bit-by-bitradix sort works on our file of sample ke:rs.A00001R10010s10011T10100001111N01110R10010x11000T10100P10000I01001L01100N01110A00001G00111s10011E00101001111x11000I01001A00001G00111M01101E00101P10000A00001L01100M01101E00101E00101T10100x11000P10000L01100A00001I01001E00101A00001M01101E00101R10010N01110s10011001111G00111:c11000I™10000fl00001.:01001ii00001I110010310011‚Y101001,01100I?0010114011011200101N01110001111G00111P10000A00001A00001A00001A00001E00101R10010E00101s10011G00111T10100I01001E00101L01100E00101M01101G00111N01110x11000001111I01001P10000L01100R10010M01101s10011N01110T10100001111x11000The ith column in this table is sorted on the trailing i bits of the keys.The ith column is derived from the (i - l$t column by extracting all the keyswith a 0 in the ith bit, then all the keys with a 1 in the ith bit.It™s not easy to be convinced that the method works; in fact it doesn™twork at all unless the one-bit partitioning process is stable. Once stabilityhas been identified as being important, a trivial proof that the method workscan be found: after putting keys with ti,h bit 0 before those with ith bit 1(in a stable manner) we know that any l,wo keys appear in proper order (onthe basis of the bits so far examined) in the file either because their ith bitsare different, in which case partitioning puts them in the proper order, or
because their ith bits are the same, in which case they™re in proper order
because of stability. The requirement 01% stability means, for example, that
122CRAPTER 10the partitioning method used in the radix exchange sort can™t be used for thisright-to-left sort.The partitioning is like sorting a file with only two values, and the dis-tribution counting sort that we looked at in Chapter 8 is entirely appropriatefor this. If we assume that A4 = 2 in the distribution counting program andreplace a[i] by bits(a[i], k, l), then that program becomes a method for sortingthe elements of the array a on the bit k positions from the right and puttingthe result in a temporary array t. But there™s no reason to use A4 = 2; infact we should make M as large as possible, realizing that we need a table ofM counts. This corresponds to using m bits at a time during the sort, withM = 2m.Thus, straight radix sort becomes little more than a generalizationof distribution counting sort, as in the following implementation for sortinga[l..N] on the b rightmost bits:procedure straig&radix( b: integer) ;var i, j, pass: integer;beginfor pass:=0 to (b div m)-1 dobeginfor j:=O to M-l do countlj] :=O;for i:=l to N docount[bits(a[i],pass*m, m)] :=count[bits(a[i],pass*m, m)]+l;for j:=l to M-l docountIj]:=countIj-l]+countb];for i:=N downto 1 dobegint[count[bits(a[i],pass*m,m)]]:=a[i];count[bits(a[i],pass*m,m)]:=count[bits(a[i],pass*m,m)]-l;end ;for i:=l to N do a[i]:=t[i];end ;end ;For clarity, this procedure uses two calls on bits to increment and decrementcount, when one would suffice. Also, the correspondence M = 2m has beenpreserved in the variable names, though some versions of ﬁpascalﬂ can™t tellthe difference between m and M.The procedure above works properly only if b is a multiple of m. Normally,this is not a particularly restrictive assumption for radix sort: it simply cor-responds to dividing the keys to be sorted into an integral number of equalsize pieces.When m=b we have distribution counting sort; when m=l we
RADIX SORTING123have straight radix sort, the rightrto-left l&by-bit radix sort described in theexample above.The implementation above moves the file from a to t during each dis-tribution counting phase, then back to a in a simple loop. This ﬁarray copyﬂloop could be eliminated if desired by making two copies of the distributioncounting code, one to sort from a into t, the other to sort from t into a.A Linear SortThe straight radix sort implementation given in the previous section makesb/m passes through the file. By making rr: large, we get a very efficient sortingmethod, as long as we have M = 2m words of memory available. A reasonablechoice is to make m about one-fourth th,e word-size (b/4), so that the radixsort is four distribution counting passes. The keys are treated as base-Mnumbers, and each (base--M) digit of each key is examined, but there areonly four digits per key. (This directly corresponds with the architecturalorganization of many computers: one typical organization is to have 32-bit
words, each consisting of four g-bit bytes. The bits procedure then winds upextracting particular bytes from words in this case, which obviously can bedone very efficiently on such computers.) Now, each distribution counting
pass is linear, and since there are only four of them, the entire sort is linear,
certainly the best performance we could hope for in a sort.In fact, it turns out that we can get bj, with only two distribution countingpasses. (Even a careful reader is likely ‚10 have difficulty telling right fromleft by this time, so some caution is called for in trying to understand thismethod.) This can be achieved by taking advantage of the fact that the filewill be almost sorted if only the leading b,‚2 bits of the bbit keys are used. Aswith Quicksort, the sort can be completed efficiently by using insertion sorton the whole file afterwards. This method is obviously a trivial modification
to the implementation above: to do a right-to-left sort using the leading halfof the keys, we simply start the outer loop at pass=b div (2*m) rather thanpass=l. Then a conventional insertion sol-t can be used on the nearly-orderedfile that results. To become convinced that a file sorted on its leading bitsis quite well-ordered, the reader should examine the first few columns of thetable for radix exchange sort above. For example, insertion sort run on thethe file sorted on the first three bits would require only six exchanges.Using two distribution counting passes (with m about one-fourth the wordsize), then using insertion sort to finish ;he job will yield a sorting methodthat is likely to run faster than any of the others that we™ve seen for large fileswhose keys are random bits. Its main disal,dvantage is that it requires an extraarray of the same size as the array being sorted. It is possible to eliminatethe extra array using linked-list techniquies, but extra space proportional toN (for the links) is still required.
CHAPTER 10A linear sort is obviously desirable for many applications, but there arereasons why it is not the panacea that it might seem. First, it really doesdepend on the keys being random bits, randomly ordered. If this condition is
not sati.sfied, severely degraded performance is likely. Second, it requires extraspace proportional the size of the array being sorted. Third, the ﬁinner loopﬂof the program actually contains quite a few instructions, so even though it™s
linear, it won™t be as much faster than Quicksort (say) as one might expect,except for quite large files (at which point the extra array becomes a realliability). The choice between Quicksort and radix sort is a difficult one
that is likely to depend not only on features of the application such as key,
record, and file size, but also on features of the programming and machine
environment that relate to the efficiency of access and use of individual bits.Again, such tradeoffs need to be studied by an expert and this type of studyis likely to be worthwhile only for serious sorting applications.
RADlX SORTING125Exercises1. Compare the number of exchanges used by radix exchange sort withthe number of exchanges used by Qlricksort for the file 001,011,101,110,000,001,010,111,110,010.2. Why is it not as important to remove the recursion from the radix ex-change sort as it was for Quicksort?3.Modify radix exchange sort to skip leading bits which are identical on allkeys. In what situations would this be worthwhile?4.True or false: the running time of sti,aight radix sort does not depend onthe order of the keys in the input file. Explain your answer.5. Which method is likely to be faste-* for a file of all equal keys: radixexchange sort or straight radix sort?6.True or false: both radix exchange sort and straight radix sort examineall the bits of all the keys in the file. Explain your answer.7. Aside from the extra memory reqciirement, what is the major disad-vantage to the strategy of doing straight radix sorting on the leadingbits of the keys, then cleaning up with insertion sort afterwards?8.Exactly how much memory is requirl:d to do a 4-pass straight radix sortof N b-bit keys?9.What type of input file will make radix exchange sort run the most slowly(for very large N)?10. Empirically compare straight radix sort with radix exchange sort for arandom file of 1000 32-bit keys.

11. Priority QueuesIn many applications, records with keys must be processed in order,but not necessarily in full sorted order and not necessarily all at once.Often a set of records must be collected, then the largest processed, thenperhaps more records collected, then the next largest processed, and so forth.An appropriate data structure in such an environment is one which supportsthe operations of inserting a new element and deleting the largest element.This can be contrasted with queues (delete the oldest) and stacks (delete thenewest). Such a data structure is called a priority queue. In fact, the priorityqueue might be thought of as a generalization of the stack and the queue (andother simple data structures), since these data structures can be implementedwith priority queues, using appropriate priority assignments.Applications of priority queues include simulation systems (where thekeys might correspond to ﬁevent timesﬂ which must be processed in order),job scheduling in computer systems (where the keys might correspond toﬁprioritiesﬂ which indicate which users should be processed first), and numeri-cal computations (where the keys might be computational errors, so the largestcan be worked on first).Later on in this book, we™ll see how to use priority queues as basicbuilding blocks for more advanced algorithms. In Chapter 22, we™ll develop afile compression algorithm using routines from this chapter, and in Chapters31 and 33, we™ll see how priority queues can serve as the basis for severalfundamental graph searching algorithms. These are but a few examples ofthe important role served by the priority queue as a basic tool in algorithmdesign.It is useful to be somewhat more precise about how a priority queue willbe manipulated, since there are several operations we may need to performon priority queues in order to maintain them and use them effectively forapplications such as those mentioned above. Indeed, the main reason that127
128CHAPTER 11priority queues are so useful is their flexibility in allowing a variety of differentoperations to be efficiently performed on set of records with keys. We want tobuild and maintain a data structure containing records with numerical keys(priorities), suppor mg some of the following operations:t™Construct a priority queue from N given items.Insert a new item.Remove the largest item.Replace the largest item with a new item (unless the new item is larger).Change the priority of an item.Delete an arbitrary specified item.Join two priority queues into one large one.(If records can have duplicate keys, we take ﬁlargestﬂ to mean ﬁany recordwith the largest key value.ﬁ)The replace operation is almost equivalent to an insert followed by aremove (the difference being that the insert/remove requires the priority queueto grow temporarily by one element). Note that this is quite different fromdoing a remove followed by an insert. This is included as a separate capabilitybecause, as we will see, some implementations of priority queues can do thereplace operation quite efficiently. Similarly, the change operation could beimplemented as a delete followed by an insert and the construct could be imple-mented with repeated uses of the insert operation, but these operations can bedirectly implemented more efficiently for some choices of data structure. Thejoin operation requires quite advanced data structures for efficient implemen-tation; we™ll concentrate instead on a ﬁclassicalﬂ data structure, called a heap,which allows efficient implementations of the first five operations.The priority queue as described above is an excellent example of anabstract data structure: it is very well defined in terms of the operationsperformed on it, independent of the way the data is organized and processedin any particular implementation.The basic premise of an abstract datastructure is that nothing outside of the definitions of the data structureand the algorithms operating on it should refer to anything inside, exceptthrough function and procedure calls for the fundamental operations. The
main motivation for the development of abstract data structures has been
as a mechanism for organizing large programs. They provide a way to limit
the size and complexity of the interface between (potentially complicated)algorithms a.nd associated data structures and (a potentially large numberof) programs which use the algorithms and data structures. This makes iteasier to understand the large program, and makes it more convenient to
change or improve the fundamental algorithms. For example, in the present
PRIORITY QUEUES129context, there are several methods for implementing the various operationslisted above that can have quite different performance characteristics. Defining
priority queues in terms of operations on an abstract data structure providesthe flexibility necessary to allow experimentation with various alternatives.Different implementations of priority queues involve different performancecharacteristics for the various operations to be performed, leading to costtradeoffs. Indeed, performance differences are really the only differences al-lowed by the abstract data structure concept. First, we™ll illustrate this point
by examining a few elementary data structures for implementing priorityqueues. Next, we™ll examine a more advanced data structure, and then showhow the various operations can be implemented efficiently using this data
structure. Also, we™ll examine an important sorting algorithm that follows
naturally from these implementations.Elementary ImplementationsOne way to organize a priority queue is as an unordered list, simply keepingthe items in an array a[l..N] without paying attention to the keys. Thusconstruct is a ﬁno-opﬂ for this organization. To insert simply increment N andput the new item into a[N], a constant-time operation. But replace requiresscanning through the array to find the element with the largest key, whichtakes linear time (all the elements in the array must be examined). Thenremove can be implemented by exchanging a[N] with the element with thelargest key and decrementing N.Another organization is to use a sorted list, again using an array a [1..N]but keeping the items in increasing order of their keys. Now remove simplyinvolves returning a[N] and decrementing N (constant time), but insert in-volves moving larger elements in the array right one position, which couldtake linear time.Linked lists could also be used for the unordered list or the sorted list.This wouldn™t change the fundamental performance characteristics for insert,remove, or replace, but it would make it possible to do delete and join inconstant time.Any priority queue algorithm can be turned into a sorting algorithm bysuccessively using insert to build a priority queue containing all the items to besorted, then successively using remove to empty the priority queue, receivingthe items in reverse order. Using a priority queue represented as an unorderedlist in this way corresponds to selection sort; using the sorted list corresponds
to insertion sort.As usual, it is wise to keep these simple implementations in mind becausethey can outperform more complicated methods in many practical situations.For example, the first method might be appropriate in an application where
130CRAPTER 11only a few ﬁremove largestﬂ operations are performed as opposed to a largenumber of insertions, while the second method would be appropriate if the
items inserted always tended to be close to the largest element in the priorityqueue. Implementations of methods similar to these for the searching problem(find a record with a given key) are given in Chapter 14.Heap Data StructureThe data structure that we™ll use to support the priority queue operationsinvolves storing the records in an array in such a way that each key isguaranteed to be larger than the keys at two other specific positions. In turn,each of those keys must be larger than two more keys, and so forth. Thisordering is very easy to see if we draw the array in a two-dimensional ﬁtreeﬂstructure with lines down from each key to the two keys known to be smaller.This structure is called a ﬁcomplete binary treeﬂ: place one node (called theroot), then, proceeding down the page and from left to right, connect two nodesbeneath each node on the previous level until N nodes have been placed. Thenodes below each node are called its sons; the node above each node is called
its father. (We™ll see other kinds of ﬁbinary treesﬂ and ﬁtreesﬂ in Chapter 14and later chapters of this book.) Now, we want the keys in the tree to satisfythe heap condition: the key in each node should be larger than (or equal to)the keys in its sons (if it has any). Note that this implies in particular thatthe largest key is in the root.We can represent complete binary trees sequentially within an array bysimply putting the root at position 1, its sons at positions 2 and 3, the nodes atthe next level in positions 4, 5,6 and 7, etc., as numbered in the diagram above.For example, the array representation for the tree above is the following:123456789101112XTOGSMNAERAI
PRIORITY QUEUES131This natural representation is useful because it is very easy to get from anode to its father and sons. The father of the node in position j is in positionj div 2, and, conversely, the two sons of the node in position j are in position2j and 2j + 1. This makes t,raversal of such a tree even easier than if the treewere implemented with a standard linked representation (with each elementcontaining a pointer to its father and sons). The rigid structure of completebinary trees represented as arrays does limit their utility as data structures,but there is just enough flexibility to allow the implementation of efficient
priority queue algorithms. A heap is a complete binary tree, represented as
an array, in which every node satisfies the heap condition. In particular, thelargest key is always in the first position in the array.All of the algorithms operate along some path from the root to the bottomof the heap (just moving from father to son or from son to father). It is easyto see that, in a heap of N nodes, all paths have about 1gN nodes on them.(There are about N/2 nodes on the bottom, N/4 nodes with sons on thebottom, N/8 nodes with grandsons on the bottom, etc. Each ﬁgenerationﬂ
has about half as many nodes as the next, which implies that there can be
at most lg N generations.) Thus all of the priority queue operations (exceptjoin) can be done in logarithmic time using heaps.Algorithms on HeapsThe priority queue algorithms on heaps all work by first making a simplestructural modification which could violate the heap condition, then travelingthrough the heap modifying it to ensure that the heap condition is satisfiedeverywhere. Some of the algorithms travel through the heap from bottom to
top, others from top to bottom. In all of the algorithms, we™ll assume that
the records are one-word integer keys stored in an array a of some maximumsize, with the current size of the heap kept in an integer N. Note that N is asmuch a part of the definition of the heap as the keys and records themselves.To be able to build a heap, it is necessary first to implement the insertoperation. Since this operation will increase the size of the heap by one, Nmust be incremented. Then the record to be inserted is put into a[N], butthis may violate the heap property. If the heap property is violated (the newnode is greater than its father), then the violation can be fixed by exchanging
the new node with its father. This may, in turn, cause a violation, and thus
can be fixed in the same way. For example, if P is to be inserted in the heap
above, it is first stored in a[N] as the right son of M. Then, since it is greater
than M, it is exchanged with M, and since it is greater than 0, it is exchanged
with 0, and the process terminates since it is less that X. The following heap
results:
132CHAPTER 11The code for this method is straightforward. In the following implementation,insert adds a new item to a[N], then calls upheap to fix the heap conditionviolation at Nprocedure upheap(k: integer);var v: integer;beginv:=a[k]; a[O]:=maxint;while a[k div 21 <=v dobegin a[k]:=a[k div 21; k:=k div 2 end;a[k] :=v;end ;procedure insert (v: integer) ;beginN:=N+l; a[N] :=v;whew(N)end ;As with insertion sort, it is not necessary to do a full exchange within theloop, because v is always involved in the exchanges. A sentinel key must beput in a[O] to stop the loop for the case that v is greater than all the keys inthe heap.The replace operation involves replacing the key at the root with a newkey, then moving down the heap from top to bottom to restore the heapcondition. For example, if the X in the heap above is to be replaced withC, the first step is to store C at the root. This violates the heap condition,but the violation can be fixed by exchanging C with T, the larger of the two
sons of the root. This creates a violation at the next level, which can be fixed
PRIORITY QUEUES133again by exchanging C with the larger of its two sons (in this case S). Theprocess continues until the heap condition is no longer violated at the node
occupied by C. In the example, C makes it all the way to the bottom of the
heap, leaving:The ﬁremove the largestﬂ operation involves almost the same process.Since the heap will be one element smaller after the operation, it is necessaryto decrement iV, leaving no place for the element that was stored in the lastposition. But the largest element is to be removed, so the remove operationamounts to a replace, using the element that was in a(iV]. For example, thefollowing heap results from removing the T from the heap above:The implementation of these procedures is centered around the operationof fixing up a heap which satisfies the heap condition everywhere exceptpossibly at the root. The same operation can be used to fix up the heapafter the value in any position is lowered. It may be implemented as follows:
134CHAPTER 11procedure downheap(k: integer) ;label 0;var i, j, v: integer;beginv:=a[k];while k<= N div 2 dobeginj:=k+k;if j<N then if ab]<ab+l] then j:=j+l;if v>=ab] then goto 0;a[k]:=ab]; k:=j;end;O:a[k] :=vend ;This procedure moves down the heap (starting from position k), exchangingthe node at position j with the larger of its two sons if necessary, stopping whenj is larger than both sons or the bottom is reached. As above, a full exchangeis not needed because v is always involved in the exchanges. The inner loop inthis program is an example of a loop which really has two distinct exits: one
for the case that the bottom of the heap is hit (as in the first example above),and another for the case that the heap condition is satisfied somewhere in theinterior of the heap.Now the implementation of the remove operation is simple:function remove: integer;beginremove:=a[l];a[l]:=a[N]; N:=N-1;downheap(1);end ;The return value is set from a[l], then the element from a [N] is put into a[l]and the size of the heap decremented, leaving only a call to downheap to fixup the heap condition everywhere.The implementation of the replace operation is only slightly more com-plicated:
PRIORITY QUEUES135function replace(v: integer):integer;begina[O] :=v;downheap( 0) ;replace:=a[O];end ;This code uses a[O] in an artificial way: its sons are 0 (itself) and 1, so if v islarger than the largest element in the heap, the heap is not touched; otherwisev is put into the heap and a[11 returned..The delete operation for an arbitrary element from the heap and thechange operation can also be implemented by using a simple combination ofthe methods above. For example, if the priority of the element at position kis raised, then upheapcan be called, and if it is lowered then downheapdoes the job. On the other hand, the join operation is far more difficult andseems to require a much more sophisticated data structure.All of the basic operations insert, remove, replace, (downheap and upheup),delete, and change involve moving along a path between the root and the hot-tom of the heap, which includes no more than about log N elements for a heapof size N. Thus the running times of the above programs are logarithmic.HeapsortAn elegant and efficient sorting method can be defined from the basic opera-tions on heaps outlined above.This method, called Heapsort, uses no extramemory and is guaranteed to sort M elements in about Mlog M steps nomatter what the input. Unfortunately, its inner loop is quite a bit longerthan the inner loop of Quicksort, and it is about twice as slow as Quicksort
on the average.The idea is simply to build a heap containing the elements to be sortedand then to remove them all in order. In this section, N will continue to bethe size of the heap, so we will use M for the number of elements to be sorted.One way to sort is to implement the construct operation by doing M insertoperations, as in the first two lines of the following code, then do M removeoperations, putting the element removed into the place just vacated by theshrinking heap:N:=O;for k:=l to M do insert(a[k]);for k:=M downto 1 do a[k]:=remove;
136CHAPTER 11This code breaks all the rules of abstract data structures by assuming a par-ticular representation for the priority queue (during each loop, the priority
queue resides in a[l], . . . ,a[k-1]), but it is reasonable to do this here becausewe are implementing a sort, not a priority queue. The priority queue proce-dures are being used only for descriptive purposes: in an actual implementa-
tion of the sort, we would simply use the code from the procedures to avoid
doing so many unnecessary procedure calls.It is actually a little better to build the heap by going backwards throughit, making little heaps from the bottom up. Note that every position in thearray is the root of a small heap, and downheap will work equally well forsuch small heaps as for the big heap. Also, we™ve noted that remove can beimplemented by exchanging the first and last elements, decrementing N, andcalling downheap(1). This leads to the following implementation of Heapsort:procedure heapsort;var k, t: integer;beginN:=M;
for k:=M div 2 downto 1 do downheap(repeatt:=a[l]; a[l]:=a[N]; a[N]:=t;N:=N-1; downheap(1)until NC = 1;end ;The first two lines of this code constitute an implementation of construct(M:integer) to build a heap of M elements. (The keys in a[ (M div 2)+1..M] eachform heaps of one element, so they trivially satisfy the heap condition anddon™t need to be checked.) It is interesting to note that, though the loops in
this program seem to do very different things, they can be built around the
same fundamental procedure.The following table shows the contents of each heap operated on bydownheap for our sorting example, just after downheap has made the heapcondition hold everywhere.
PRIORITY QUEUES137123456789 10 11 12 13 14 15ASORTINGEXAMPLENL EPM IXT ARG EP0 NM I L EXR TG E S AXTPRSONGEAAMILETSPREONGEAAMILSRPLEONGEAAMIR L PIEONGEAAMP L 0IEMNGEAAOLNIEMAGEANLMIEAAGEM L EIEAAGLIEGEAAIGEAEAG E E A AE A E AE A AA AAAAEEGILMNOPRSTXAs mentioned above, the primary reason that Heapsort is of practicalinterest is that the number of steps required to sort M elements is guaranteedto be proportional to M log M, no matter what the input. Unlike the othermethods that we™ve seen, there is no ﬁworst-caseﬂ input that will make Heap-sort run slower. The proof of this is simple: we make about 3M/2 calls todownheap (about M/2 to construct the heap and M for the sort), each ofwhich examines less than log M heap elements, since the heap never has morethan M elements.Actually, the above proof uses an overestimate. In fact, it can be proventhat the construction process takes linear time since so many small heaps areprocessed. This is not of particular importance to Heapsort, since this timeis still dominated by the M log M time for sorting, but it is important forother priority queue applications, where a linear time construct can lead toa linear time algorithm. Note that constructing a heap with M successiveinserts requires M log M steps in the worst case (though it turns out to belinear on the average).
138CHAPTER 11Indirect HeapsFor many applications of priority queues, we don™t want the records movedaround at all. Instead, we want the priority queue routine to tell us whichof the records is the largest, etc., instead of returning values. This is akinto the ﬁindirect sortﬂ or the ﬁpointer sortﬂ concept described at the begin-ning of Chapter 8. Modification of the above programs to work in this way
is straightforward, though sometimes confusing. It will be worthwhile to ex-
amine this in more detail here because it is so convenient to use heaps in thisway.Specifically, instead of rearranging the keys in the array a the priorityqueue routines will work with an array heap of indices into the array a, suchthat a[heap[k]] is the key of the kth element of the heap, for k between 1 andN. Moreover, we want to maintain another array inv which keeps the heapposition of the kth array element. Thus the inv entry for the largest element
in the array is 1, etc. For example, if we wished to change the value of a[k]we could find its heap position in inv[k], for use by upheap or downheap. Thefollowing table gives the values in these arrays for our sample heap:k: 123456789101112131415a[k]:A S 0 R T I N G E X A M P L Eheap[k]:lO5134237891111261415a[heap[k]]: X T P R S 0 N G E A A M I L Ea[k]: A S 0 R TINGEXAMPLEinv[k]: 105642137891111231415Note that heap[inv[k]]=inv[heap[k]]=k for all k from 1 to N.We start with heap[k]=inv[k]=k for k from 1 to N, which indicates thatno rearrangement has been done. The code for heap construction looks muchthe same as before:procedure pqconstruct;var k: integer;beginN:=M;
for k:=l to N dobegin heap[k] :=k; inv[k] :=k end;for k:=M div 2 downto 1 do pqdownheap(k) ;end ;
PRIORITY QUEUES139We™ll prefix implementations of priority queue routines based on indirect heapswith ﬁpqﬂ for indentification when they are used in later chapters.Now, to modify downheap to work indirectly, we need only examine theplaces where it references a. Where it did a comparison before, it must nowaccess a indirectly through heap. Where it did a move before, it must nowmake the move in heap, not a, and it must modify inv accordingly. This leadsto the following implementation:procedure pqdownheap(k: integer);label 0;var j, v: integer;beginv:=heap[k];while k<= N div 2 dobeginj:=k+k;if j<N then if a[heapIj]]<a[heapb+1]] then j:=j+l;if a[v]>=a[heaplj]:] then goto 0;heap [k] :=heap b] ;inv[heaplj]] :=k; k:=j;end;O:heap[k] :=v; inv[v] :=kend ;The other procedures given above can be modified in a similar fashion toimplement ﬁpqinsert,ﬂ ﬁpqchange,ﬂ etc.A similar indirect implementation can be developed based on maintainingheap as an array of pointers to separately allocated records. In this case, alittle more work is required to implement the function of inv (find the heapposition, given the record).Advanced ImplementationsIf the join operation must be done efficiently, then the implementations thatwe have done so far are insufficient and more advanced techniques are needed.
Although we don™t have space here to go into the details of such methods, wecan discuss some of the considerations that go into their design.By ﬁefficiently,ﬂ we mean that a join should be done in about the sametime as the other operations. This immediately rules out the linkless repre-sentation for heaps that we have been using, since two large heaps can bejoined only by moving all the elements in at least one of them to a largearray. It is easy to translate the algorithms we have been examining to uselinked representations; in fact, sometimes there are other reasons for doing
140CHAPTER 11so (for example, it might be inconvenient to have a large contiguous array).In a direct linked representation, links would have to be kept in each nodepointing to the father and both sons.It turns out that the heap condition itself seems to be too strong to allowefficient implementation of the join operation. The advanced data structuresdesigned to solve this problem all weaken either the heap or the balance
condition in order to gain the flexibility needed for the join. These structures
allow all the operations be completed in logarithmic time.Ll
PRIORITY QUEUES141Exercises1.2.3.4.5.6.7.8.9.10.Draw the heap that results when the following operations are performedon an intitially empty heap: insert( IO), insert(5), insert(2), replate(4),insert(6), insert(8), remove, insert(T), insert(3).Is a file in reverse sorted order a heap?Give the heap constructed by successive application of insert on the keysEASYQUESTION.Which positions could be occupied by the 3rd largest key in a heap ofsize 32? Which positions could not be occupied by the 3rd smallest keyin a heap of size 32?Why not use a sentinel to avoid the j<N test in downheap?Show how to obtain the functions of stacks and normal queues as specialcases of priority queues.What is the minimum number of keys that must be moved during aremove the largest operation in a heap? Draw a heap of size 15 for whichthe minimum is achieved.Write a program to delete the element at postion d in a heap.Empirically compare the two methods of heap construction described inthe text, by building heaps with 1000 random keys.Give the contents of inv after pqconstruct is used on the keys E A S Y QUESTION.

12. Selection and MergingSorting programs are often used for applications in which a full sort isnot necessary. Two important operations which are similar to sortingbut can be done much more efficiently are selection, finding the kth smallestelement (or finding the k smallest elements) in a file, and merging, combiningtwo sorted files to make one larger sorted file. Selection and merging areintimately related to sorting, as we™ll see, and they have wide applicability in
their own right.An example of selection is the process of finding the median of a set ofnumbers, say student test scores. An example of a situation where mergingmight be useful is to find such a statistic for a large class where the scores are
divided up into a number of individually sorted sections.Selection and merging are complementary operations in the sense thatselection splits a file into two independent files and merging joins two inde-pendent files to make one file. The relationship between these operations also
becomes evident if one tries to apply theﬁdivide-and-conquerﬂ paradigm tocreate a sorting method. The file can either be rearranged so that when twoparts are sorted the whole file is sorted, or broken into two parts to be sortedand then combined to make the sorted whole file. We™ve already seen what
happens in the first instance: that™s Quicksort, which consists basically of a
selection procedure followed by two recursive calls. Below, we™ll look at mer-gesort, Quicksort™s complement in that it consists basically of two recursivecalls followed by a merging procedure.Both selection and merging are easier than sorting in the sense that theirrunning time is essentially linear: the programs take time proportional to Nwhen operating on N items. But available methods are not perfect in either
case: the only known ways to merge in place (without using extra space)
are too complex to be reduced to practical programs, as are the only known
selection methods which are guaranteed to be linear even in the worst case.143
144CHAPTER 12SelectionSelection has many applications in the processing of experimental and otherdata. The most prominent use is the special case mentioned above of findingthe median element of a file: that item which is greater than half the itemsin the file and smaller than half the items in the file. The use of the medianand other order statistics to divide a file up into smaller percentile groups isvery common. Often only a small part of a large file is to be saved for furtherprocessing; in such cases, a program which can select, say, the top ten percent
of the elements of the file might be more appropriate than a full sort.An algorithm for selection must find the kth smallest item out of a file ofN items. Since an algorithm cannot guarantee that a particular item is thekth smallest without having examined and identified the k- 1 items which aresmaller and the N - k elements which are larger, most selection algorithmscan return all of the k smallest elements of a file without a great deal of extracalculation.We™ve already seen two algorithms which are suitable for direct adapta-tion to selection methods. If k is very small, then selection sort will work verywell, requiring time proportional to Nk: first find the smallest element, thenfind the second smallest by finding the smallest among the remaining items,etc. For slightly larger k, priority queues provide a selection mechanism: firstinsert k items, then replace the largest N - k times using the remaining items,leaving the k smallest items in the priority queue. If heaps are used to imple-ment the priority queue, everything can be done in place, with an approximaterunning time proportional to N log k.An interesting method which will run much faster on the average can beformulated from the partitioning procedure used in Quicksort. Recall thatQuicksort™s partitioning method rearranges an array a[l..N] and returns aninteger i such that a[l],. . .,a[i-l] are less than or equal to a[i] and a[i+l],. . . ,a[N] are greater than or equal to a[i]. If we™re looking for the kth smallestelement in the file, and we™re fortunate enough to have k=i, then we™re done.Otherwise, if k<i then we need to look for the kth smallest element in theleft subfile, and if k>i then we need to look for the (k-i)th smallest elementin the right subfile. This leads immediately to the recursive formulation:
SELECTION AAD MERGING145procedure seJect(J, r, k: integer);var I;begil 1if r> J thenbegini::=partition(J, r);if i>J+k-1 then seJect(J, i-l, k);if i<J+k-I then seJect(i+l, r, k-i);endend;This procedure rearranges the array so lhat a[J],. . . ,a[k-l] are less than orequal to a[k] and a[k+1],...,a[r] are greater than or equal to a[k]. Forexample, the call seJect(l, N, (N+l) div Z) partitions the array on its medianvalue.For the keys in our sorting example, this program uses only threerecursive calls to find the median, as shown in the following table:123456789 10 11 12 13 14 15ASORTINGEXAMPLEA A EMTINGOXSMPLRLINGOPMmXTSL IG(M(0 P Nm-The file is rearranged so that the median is in place with all smaller elementsto the left and all larger elements to the right (and equal elements on eitherside), but it is not fully sorted.Since the select procedure always end 3 with only one call on itself, it is notreally recursive in the sense that no stael. is needed to remove the recursion:when the time comes for the recursive call, we can simply reset the parametersand go back to the beginning, since there is nothing more to do.
146CHAPTER 12procedure select(k: integer) ;var vt i j 1 r: integer;, 7 9 t )beginl:=l; r:=N;while r>l dobeginv:=a[r]; i:=l-1; j:=r;repeatrepeat i:=i+l until a[i]>=v;repeat j:=j-1 until ab]<=v;t:=a[i]; a[i]:=alj]; ab]:=t;until j<=i;alj]:=a[i]; a[i]:=a[r]; a[r]:=t;if i>=k then r:=i-1;if i<=k then l:=i+l;end ;end ;We use the identical partitioning procedure to Quicksort: as with Quicksort,this could be changed slightly if many equal keys are expected. Note that inthis non-recursive program, we™ve eliminated the simple calculations involving
k.This method has about the same worst case as Quicksort: using it tofind the smallest element in an already sorted file would result in a quadraticrunning time. It is probably worthwhile to use an arbitrary or a random
partitioning element (but not the median-of-three: for example, if the smallestelement is sought, we probably don™t want the file split near the middle). Theaverage running time is proportional to about N + Iclog(N/k), which is linearfor any allowed value of k.It is possible to modify this Quicksort-based selection procedure so that itsrunning time is guaranteed to be linear. These modifications, while importantfrom a theoretical standpoint, are extremely complex and not at all practical.MergingIt is common in many data processing environments to maintain a large(sorted) data file to which new entries are regularly added. Typically, anumber of new entries are ﬁbatched,ﬂ appended to the (much larger) mainfile, and the whole thing resorted. This situation is tailor-made for merging: a
much better strategy is to sort the (small) batch of new entries, then merge it
with the large main file. Merging has many other similar applications which
SELECTION AND MERGING147make it worthwhile to study. Also, we™ll examine a sorting method based onmerging.In this chapter we™ll concentrate on programs for two-way merging: pro-grams which combine two sorted input files to make one sorted output file. Inthe next chapter, we™ll look in more deLii at multiway merging, when morethan two files are involved. (The most important application of multiwaymerging is external sorting, the subject cf that chapter.)To begin, suppose that we have two sorted arrays a [l..M] and b [1..N] ofintegers which we wish to merge into a third array c [ 1. .M+N] . The followingis a direct implementation of the obvious method of successively choosing forc the smallest remaining element from a and b:a[M+l I:=maxint; b[N+l] :=maxint;for k:=l to M+N doif a[il<blj]then begin c[k]:=a[i]; i:=i+l endelw begin c[k]:=bb]; j:=j+l end;The implementation is simplified by making room in the a and b arrays forsentinel keys with values larger than all the other keys. When the a(b) arrayis exhausted, the loop simply moves the rc,st of the b(a) array into the c array.The time taken by this method is obviously proportional to M+N.The above implementation uses extra space proportional to the size of themerge. It would be desirable to have an in-place method which uses c[l..M]for one input and c[M+I..M+N] for the other. While such methods exist,they are so complicated that an (N + M)log(N + M) inplace sort would bemore efficient for practical values of N and M.Since extra space appears to be required for a practical implementation,we might as well consider a linked-list imy™lementation. In fact, this method isvery well suited to linked lists. A full implementation which illustrates all theconventions we™ll use is given below; note that the code for the actual merge
is just about as simple as the code above:
CHAPTER 12program listmerge(input, output);type link=tnode;node=record k: integer; next: link end;var N, M: integer; z: link;function merge(a, b: link) : link;var c: link;beginc:=z;repeatif at.k<=bf.kthen begin ct.next:=a; c:=a; a:=at.next endelse begin ct.next:=b; c:=b; b:=bf.next enduntil cf.k=maxint;merge:=zf.next; zt next:=zend ;beginreadln (N, M) ;new(z); zf.k:=maxint; zt.next:=z;writelist(merge(readlist(N), read&(M)))end.This program merges the list pointed to by a with the list pointed to by b,with the help of an auxiliary pointer c. The lists are initially built with thereadlist routine from Chapter 2. All lists are defined to end with the dummynode a, which normally points to itself, and also serves as a sentinel. Duringthe merge, a points to the beginning of the newly merged list (in a mannersimilar to the implementation of readlist), and c points to the end of thenewly merged list (the node whose link field must be changed to add a newelement to the list). After the merged list is built, the pointer to its first node
is retrieved from z and z is reset to point to itself.The key comparison in merge includes equality so that the merge will bestable, if the b list is considered to follow the a list. We™ll see below how thisstability in the merge implies stability in the sorting programs which use thismerge.Once we have a merging procedure, it™s not difficult to use it as the basisfor a recursive sorting procedure. To sort a given file, divide it in half, sort thetwo halves (recursively), then merge the two halves together. This involvesenough data movement that a linked list representation is probably the mostconvenient. The following program is a direct recursive implementation of afunction which takes a pointer to an unsorted list as input and returns as its
value a pointer to the sorted version of the list. The program does this byrearranging the nodes of the list: no temporary nodes or lists need be allocated.
SELECTION AND MIERGING149(It is convenient to pass the list length as E. parameter to the recursive program:alternatively, it could be stored with the list or the program could scan thelist to find its length.)function sort(c: link; fi: integer): link;var a, b: link;i: integer;beginif cf.next=z then sor~,:=c elsebegina:=c;for i:= 2 to N div 2 do c:=ct.next;b:=cf.next; cf.next:=z;sort:=merge(sort(a N div 2), sort(b, N-(N div 2)));end ;end ;This program sorts by splitting the list po: nted to by c into two halves, pointedto by a and b, sorting the two halves recursively, then using merge to producethe final result. Again, this program adheres to the convention that all listsend with z: the input list must end with z (and therefore so does the b list);and the explicit instruction cf.next:=z puts z at the end of the a list. Thisprogram is quite simple to understand in a recursive formulation even thoughit actually is a rather sophisticated algorithm.The running time of the program fits the standard ﬁdivide-and-conquerﬂrecurrence M(N) = 2M(N/2) + N. The program is thus guaranteed to runin time proportional to NlogN. (See Chapter 4).Our file of sample sorting keys is processed as shown in the followingtable. Each line in the table shows the result of a call on merge. First wemerge 0 and S to get 0 S, then we merge this with A to get A 0 S. Eventuallywe merge R T with I N to get I N R T, then this is merged with A 0 S toget A I N 0 R S T, etc.:
150CHAPTER 12123456789101112131415A S 0 R TINGEXAMPLE0sA0SR TI NINRTAINORSTE GA XA E G XM PE LE L M PAEEGLMPXAAEEGILMNOPRSTXThus, this method recursively builds up small sorted files into larger ones.Another version of mergesort processes the files in a slightly different order:first scan through the list performing l-by-l merges to produce sorted sublistsof size 2, then scan through the list performing 2-by-2 merges to producesorted sublists of size 4, then do 4-by-4 merges to get sorted sublists of size8, etc., until the whole list is sorted. Our sample file is sorted in four passesusing this ﬁbottom-upﬂ mergesort:123456789101112131415ASORTINGEXAMPLEA SIO R ITIG N E XIA M L PIEAORSGINTAEMXELPAGINORSTAEELMPXAAEEGILMNOPRSTXIn general, 1ogN passes are required to sort a file of N elements, since eachpass doubles the size of the sorted subfiles. A detailed implementation of thisidea is given below.
SELECTION AND MERGING151function mergesort(c: link): link;var a, b, head, todo, t: link;i, N: integer;beginN:=l; ntw(head); headf.next:=c;repeattodo:=.ieadt.next; c:=head;repeatt:=todo;a:=t: for i:=l to N-l do t:=tf.next;b:=tﬂ.next; tt.next:=z;t:=b for i:=l to N-l do t:=tf.next;todo:=tt.next; tf.next:=z;cf.nest:=merge(a, b);for i: =1 to N+N do c:=ct.nextuntil to do=z;N:=N+ N;until a=hf:adf.next;mergesort:=headf.nextend ;This program uses a ﬁlist headerﬂ node (pointed to by head) whose link fieldpoints to the file being sorted. Each iteration of the outer repeat loop passesthrough the file, producing a linked list comprised of sorted subfiles twice aslong as for the previous pass. This is done by maintaining two pointers, oneto the part of the list not yet seen (todoi and one to the end of the part ofthe list for which the subfiles have already been merged (c). The inner repeatloop merges the two subfiles of length N starting at the node pointed to bytodo producing a subfile of length N+N vrhich is linked onto the c result list.The actual merge is accomplished by saking a link to the first subfile to bemerged in a, then skipping N nodes (using the temporary link t), linking zonto the end of a™s list, then doing the same to get another list of N nodespointed to by b (updating todo with the link of the last node visited), thencalling merge. (Then c is updated by simply chasing down to the end of thelist just merged. This is a simpler (but slightly less efficient) method than
various alternatives which are available, such as having merge return pointers
to both the beginning and the end, or maintaining multiple pointers in each
list node.)Like Heapsort, mergesort has a gual,anteed N log N running time; likeQuicksort, it has a short inner loop. Thus it combines the virtues of thesemethods, and will perform well for all ir.puts (though it won™t be as quick
CHAPTER 12as Quicksort for random files). The main advantage of mergesort over thesemethods is that it is stable; the main disadvantage of mergesort over thesemethods is that extra space proportional to N (for the links) is required. Itis also possible to develop a nonrecursive implementation of mergesort usingarrays, switching to a different array for each pass in the same way that we
discussed in Chapter 10 for straight radix sort.Recursion RevisitedThe programs of this chapter (together with Quicksort) are typical of im-plementations of divide-and-conquer algorithms. We™ll see several algorithms
with similar structure in later chapters, so it™s worthwhile to take a more
detailed look at some basic characteristics of these implementations.Quicksort is actually a ﬁconquer-and-divideﬂ algorithm: in a recursiveimplementation, most of the work is done before the recursive calls. On theother hand, the recursive mergesort is more in the spirit of divide-and-conquer:first the file is divided into two parts, then each part is conquered individually.The first problem for which mergesort does actual processing is a small one;at the finish the largest subfile is processed. Quicksort starts with actualprocessing on the largest subfile, finishes up with the small ones.This difference manifests itself in the non-recursive implementations ofthe two methods. Quicksort must maintain a stack, since it has to save largesubproblems which are divided up in a data-dependent manner. Mergesort
admits to a simple non-recursive version because the way in which it divides
the file is independent of the data, so the order in which it processes sub-problems can be rearranged somewhat to give a simpler program.Another practical difference which manifests itself is that mergesort isstable (if properly implemented); Quicksort is not (without going to extratrouble). For mergesort, if we assume (inductively) that the subfiles have beensorted stably, then we need only be sure that the merge is done in a stablemanner, which is easily arranged. But for Quicksort, no easy way of doing
the partitioning in a stable manner suggests itself, so the possibility of being
stable is foreclosed even before the recursion comes into play.Many algorithms are quite simply expressed in a recursive formulation.In modern programming environments, recursive programs implementing suchalgorithms can be quite useful. However, it is always worthwhile to study the
nature of the recursive structure of the program and the possibility of remov-
ing the recursion. If the result is not a simpler, more efficient implementation
of the algorithm, such study will at least lead to better understanding of the
method.
SELECTION AND MERGING153Exercises1.For N = 1000, empirically determine: the value of k for which the Quick-sort-based partitioning procedure be :omes faster than using heaps to findthe Ic th smallest element in a randc™m file.2.Describe how you would rearrange an array of 4N elements so that theN smallest keys fall in the first N Isositions, the next N keys fall in thenext N positions, the next N in the next N positions, and the N largestin the last N positions.3.Show the recursive calls made when select is used to find the median ofthe keys EASYQUESTION.4. Write a program to rearrange a file so that all the elements with keysequal to the median are in place, with smaller elements to the left andlarger elements to the right.5.What method would be best for an application that requires selection ofthe lath largest element (for various arbitrary Ic) a large number of timeson the same file?6.True or false: the running time of mergesort does not depend on the orderof the keys in the input file. Explair. your answer.7. What is the smallest number of steps mergesort could use (to within aconstant factor)?8. Implement a bottom-up non-recursive mergesort that uses two arraysinstead of linked lists.9.Show the contents of the linked lists l™assed as arguments to each call whenthe recursive mergesort is used to sort the keys EASY Q U E S T IO N.10. Show the contents of the linked l&t at each iteration when the non-recursive mergesort is used to sort the keys EASY QUE S TIO N.

I 3. External SortingMany important sorting applications involve processing very large files,much too large to fit into the primal y memory of any computer. Methodsappropriate for such applications are ca.led external methods, since they in-volve a large amount of processing external to the central processing unit (asopposed to the internal methods that we™ve been studying).There are two major factors which make external algorithms quite differ-ent from those we™ve seen until now.l™irst, the cost of accessing an itemis orders of magnitude greater than any bookkeeping or calculating costs.Second, even with this higher cost, there are severe restrictions on access,
depending on the external storage medium used: for example, items on a
magnetic tape can be accessed only in a sequential manner.The wide variety of external storage device types and costs make the de-velopment of external sorting methods v~:ry dependent on current technology.The methods can be complicated, and many parameters affect their perfor-mance: that a clever method might go unappreciated or unused because of a
simple change in the technology is a definite possibility in external sorting.For this reason, we™ll concentrate on general methods in this chapter ratherthan on developing specific implementatjons.In short, for external sorting, the ﬁs:istemsﬂ aspect of the problem is cer-tainly as important as the ﬁalgorithmsﬂ .ispect. Both areas must be carefullyconsidered if an effective external sort is to be developed. The primary costs inexternal sorting are for input-output. A good exercise for someone planning
to implement an efficient program to sort a very large file is first to implementan efficient program to copy a large file, then (if that was too easy) implementan efficient program to reverse the order of the elements in a large file. The
systems problems that arise in trying tc solve these problems efficiently are
similar to those that arise in external sorts. Permuting a large external filein any non-trivial way is about as diffictllt as sorting it, even though no key155
156CWAPTER 13comparisons, etc. are required. In external sorting, we are mainly concernedwith limiting the number of times each piece of data is moved between theexternal storage medium and the primary memory, and being sure that suchtransfers are done as efficiently as allowed by the available hardware.External sorting methods have been developed which are suitable for thepunched cards and paper tape of the past, the magnetic tapes and disks ofthe present, and the bubble memories and videodisks of the future. The es-sential differences among the various devices are the relative size and speedof available storage and the types of data access restrictions. We™ll con-
centrate on basic methods for sorting on magnetic tape and disk because these
devices are likely to remain in widespread use and illustrate the two fundamen-tally different modes of access that characterize many external storage sys-tems. Often, modern computer systems have a ﬁstorage hierarchyﬂ of several
progressively slower, cheaper, and larger memories. Many of the algorithms
that we will consider can be adapted to run well in such an environment, butwe™ll deal exclusively with ﬁtwo-levelﬂ memory hierarchies consisting of mainmemory and disk or tape.Sort-MergeMost external sorting methods use the following general strategy: make a firstpass through the file to be sorted, breaking it up into blocks about the size
of the internal memory, and sort these blocks. Then merge the sorted blockstogether, by making several passes through the file, making successively largersorted blocks until the whole file is sorted. The data is most often accessed ina sequential manner, which makes this method appropriate for most externaldevices. Algorithms for external sorting strive to reduce the number of passes
through the file and to reduce the cost of a single pass to be as close to the
cost of a copy as possible.Since most of the cost of an external sorting method is for input-output,we can get a rough measure of the cost of a sort-merge by counting the numberof times each word in the file is read or written, (the number of passes over all
the data). For many applications, the methods that we consider will involve
on the order of ten or less such passes.Note that this implies that we™reinterested in methods that can eliminate even a single pass. Also, the runningtime of the whole external sort can be easily estimated from the running time
of something like the ﬁreverse file copyﬂ exercise suggested above.Balanced Multiway MergingTo begin, we™ll trace through the various steps of the simplest sort-mergeprocedure for an example file. Suppose that we have records with the keys ASORTINGANDMERGINGEXAMPLEonaninputtape;these
EXTERNAL SORTING157are to be sorted and put onto an output tape. Using a ﬁtapeﬂ simply meansthat we™re restricted to read the records isequentially: the second record can™tbe read until the first has been, etc. Assume further that we have only enoughroom for three records in our computer memory but that we have plenty oftapes available.The first step is to read in the file t.lree records at a time, sort them tomake three-record blocks, and output the sorted blocks. Thus, first we read inA S 0 and output the block A 0 S, next are read in R T I and output the blockI R T,and so forth. Now, in order for these blocks to be merged together,they must be on different tapes. If we want to do a three-way merge, then wewould use three tapes, ending up with the following configuration after thesorting pass:Tape I: A 0 S1, M NA E XTape 2:I R TEl G RL M PTape 3: A G NGIN ENow we™re ready to merge the sorted blocks of size three together. Weread the first record off each input tapl: (there™s just enough room in thememory) and output the one with the smallest key. Then the next recordfrom the same tape as the record just output is read in and, again, the recordin memory with the smallest key is output. When the end of a three-wordblock in the input is encountered, then that tape is ignored until the blocks
from the other two tapes have been processed, and nine records have been
output. Then the process is repeated to merge the second three-word block
on each tape into a nine-word block (whiC1 is output on a different tape, to getready for the next merge). Continuing, we get three long blocks configuredas follows:Taped: A A G I N 0 R S TTape 5: D E G G I M N N RTape 6: A E E 1, M P XNow one more three-way merge completes the sort. If we had a muchlonger file with many blocks of size 9 on each tape, then we would finish thesecond pass with blocks of size 27 on tapes 1, 2, and 3, then a third pass
would produce blocks of size 81 on tapes 4, 5, and 6, and so forth. We needsix tapes to sort an arbitrarily large file: three for the input and three for the
CHAPTER 13output of each three-way merge. Actually, we could get by with just fourtapes: the output could be put on just one tape, then the blocks from thattape distributed to the three input tapes in between merging passes.This method is called the balanced multiway merge: it is a reasonable al-gorithm for external sorting and a good starting point for the implementationof an external sort. The more sophisticated algorithms below could make thesort run perhaps 50% faster, but not much more. (On the other hand, whenexecution times are measured in hours, which is not uncommon in externalsorting, even a small percentage decrease in running time can be helpful and50% can be quite significant.)Suppose that we have N words to be manipulated by the sort and aninternal memory of size M. Then the ﬁsortﬂ pass produces about N/M sortedblocks. (This estimate assumes l-word records: for larger records, the numberof sorted blocks is computed by multiplying further by the record size.) Ifwe do P-way merges on each subsequent pass, then the number of subsequentpasses is about logp(N/M),since each pass reduces the number of sortedblocks by a factor of P.Though small examples can help one understand the details of the al-gorithm, it is best to think in terms of very large files when working withexternal sorts. For example, the formula above says that using a 4-way merge
to sort a 200-million-word file on a computer with 1 million words of memory
should take a total of about five passes. A very rough estimate of the runningtime can be found by multiplying by five the running time for the reverse filecopy implementation suggested above.Replacement SelectionIt turns out that the details of the implementation can be developed in anelegant and efficient way using priority queues. First, we™ll see that priorityqueues provide a natural way to implement a multiway merge. More impor-tant, it turns out that we can use priority queues for the initial sorting passin such a way that they can produce sorted blocks much longer than could fit
into internal memory.The basic operation needed to do P-way merging is to repeatedly outputthe smallest of the smallest elements not yet output from each of the P blocksto be merged. That element should be replaced with the next element fromthe block from which it came. The replace operation on a priority queueof size P is exactly what is needed. (Actually, the ﬁindirectﬂ verions of thepriority queue routines, as described in Chapter 11, are more appropriate forthis application.) Specifically, to do a P-way merge we begin by filling up a
priority queue of size P with the smallest element from each of the P inputsusing the pqinsert procedure from Chapter 11 (appropriately modified so that
EXTERNAL SORTING159the smallest element rather than the larl;est is at the top of the heap). Then,using the pqreplace procedure from Chitpter 11 (modified in the same way)we output the smallest element and replace it in the priority queue with thenext element from its block.For example, the following table shows the result of merging A 0 S withI R T and A G N (the first merge from ‚)ur example above):123A I AAI0GI0IN0NR00RR SS TTThe lines in the table represent the contents of a heap of size three usedin the merging process. We begin with t1 e first three keys in each block. (Theﬁheap conditionﬂ is that the first key must be smaller than the second andthird.) Then the first A is output and replaced with the 0 (the next key in itsblock). This violates the heap condition, so the 0 is exchanged with the otherA. Then that A is output and replaced with the next key in its block, the G.This does not violate the heap condition, so no further change is necessary.Continuing in this way, we produce the! sorted file (read down in the tableto see the keys in the order in which they appear in the first heap positionand are output). When a block is exhausted, a sentinel is put on the heapand considered to be larger than all the other keys. When the heap consistsof all sentinels, the merge is completed. This way of using priority queues issometimes called replacement selection.Thus to do a P-way merge, we can use replacement selection on a priorityqueue of size P to find each element to be output in 1ogP steps. Thisperformance difference is not of particular practical relevance, since a brute-force implementation can find each elernent to output in P steps, and P isnormally so small that this cost is dwarfed by the cost of actually outputtingthe element. The real importance of re™placement selection is the way thatit can be used in the first part of the scrt-merge process: to form the initialsorted blocks which provide the basis fo* the merging passes.
160CHAPTER 13The idea is to pass the (unordered) input through a large priority queue,always writing out the smallest element on the priority queue as above, andalways replacing it with the next element from the input, with one additional
proviso: if the new element is smaller than the last one put out, then, sinceit could not possibly become part of the current sorted block, it should bemarked as a member of the next block and treated as greater than all elements
in the current block. When a marked element makes it to the top of thepriority queue, the old block is ended and a new block started. Again, thisis easily implemented with pqinsert and pqreplace from Chapter 11, againappropriately modified so that the smallest element is at the top of the heap,and with pqreplace changed to treat marked elements as always greater than
unmarked elements.Our example file clearly demonstrates the value of replacement selection.With an internal memory capable of holding only three records, we canproduce sorted blocks of size 5, 4, 9, 6, and 1, as illustrated in the followingtable. Each step in the diagram below shows the next key to be input (boxed)and the contents of the heap just before that key is input. (As before, theorder in which the keys occupy the first position in the heap is the order inwhich they are output.) Asterisks are used to indicate which keys in the heap
belong to different blocks: an element marked the same way as the element at
the root belongs to the current sorted block, others belong to the next sorted
block. Always, the heap condition (first key less than the second and third) is
maintained, with elements in the next sorted block considered to be greater
than elements in the current sorted block.IlLI0T0I-uN-Is-l-LlA-I.40DId-A0RSTG*1*N*N*SSSI™I™I™AAA00E A M D M A* G* Eﬂq-RIRI D M EIPI E* G* M*--T0G E M R L G* P* M*0--T111 G M RIEl L* P* Mﬂ--N™qN I M R0M™ P* E--N™LlG MN RuP*EN*qE N G* R0EN* i-d R G* E*DIAl X G* E*For example, when pqreplace is called for M, it returns N for output (A andD are considered greater) and then sifts down M to make the heap A M D.
EXTERNAL SORTING161It can be shown that, if the keys a-e random, the runs produced usingreplacement selection are about twice the size of what could be produced usingan internal method. The practical effect of this is to save one merging pass:
rather than starting with sorted runs about the size of the internal memoryand then taking a merging pass to produce runs about twice the size of theinternal memory, we can start right of™ with runs about twice the size ofthe internal memory, by using replacement selection with a priority queue ofsize M. If there is some order in the keys, then the runs will be much, much
longer. For example, if no key has more than M larger keys before it in the
file, the file will be completely sorted by the replacement selection pass, and
no merging will be necessary! This is the most important practical reason to
use the method.In summary, the replacement seleclion technique can be used for boththe ﬁsortﬂ and the ﬁmergeﬂ steps of a balanced multiway merge. To sort Nl-word records using an internal memo y of size M and P + 1 tapes, firstuse replacement selection with a priority queue of size M to produce initialruns of size about 2M (in a random situation) or longer (if the file is partiallyordered) then use replacement selection with a priority queue of size P forabout log,(N/2M) (or fewer) merge passes.Practical ConsiderationsTo complete an implementation of the llorting method outlined above, it isnecessary to implement the inputroutput functions which actually transferdata between the processor and the ex;ernal devices. These functions areobviously the key to good performance for the external sort, and they justas obviously require careful consideratisw of some systems (as opposed toalgorithm) issues. (Readers unfamiliar with computers at the ﬁsystemsﬂ levelmay wish to skim the next few paragraphs.)A major goal in the implementation should be to overlap reading, writing,and computing as much as possible.Most large computer systems haveindependent processing units for controlling the large-scale input/output (I/O)devices which make this overlapping pos:#ible. The efficiency achievable by anexternal sorting method depends on the number of such devices available.For each file being read or written, there is a standard systems program-ming technique called double-buffering which can be used to maximize theoverlap of I/O with computing. The idl:a is to maintain two ﬁbuffers,ﬂ onefor use by the main processor, one for us: by the I/O device (or the processorwhich controls the I/O device). For input, the processor uses one buffer while
the input device is filling the other. When the processor has finished usingits buffer, it waits until the input device has filled its buffer, then the buffersswitch roles: the processor uses the near data in the just-filled buffer while
162CHAPTER 13the input device refills the buffer with the data already used by the processor.The same technique works for output, with the roles of the processor andthe device reversed. Usually the I/O time is far greater than the processingtime and so the effect of double-buffering is to overlap the computation timeentirely; thus the buffers should be as large as possible.A difficulty with double-buffering is that it really uses only about halfthe available memory space. This can lead to inefficiency if a large numberof buffers are involved, as is the case in P-way merging when P is not small.This problem can be dealt with using a technique called forecasting, whichrequires the use of only one extra buffer (not P) during the merging process.Forecasting works as follows. Certainly the best way to overlap input withcomputation during the replacement selection process is to overlap the inputof the buffer that needs to be filled next with the processing part of thealgorithm. But it is easy to determine which buffer this is: the next inputbuffer to be emptied is the one whose lust item is smallest. For example, whenmerging A 0 S with I R T and A G N we know that the third buffer will bethe first to empty, then the first. A simple way to overlap processing withinput for multiway merging is therefore to keep one extra buffer which is filledby the input device according to this rule. When the processor encounters anempty buffer, it waits until the input buffer is filled (if it hasn™t been filledalready), then switches to begin using that buffer and directs the input deviceto begin filling the buffer just emptied according to the forecasting rule.The most important decision to be made in the implementation of themultiway merge is the choice of the value of P, the ﬁorderﬂ of the merge. Fortape sorting, when only sequential access is allowed, this choice is easy: Pmust be chosen to be one less than the number of tape units available: themultiway merge uses P input tapes and one output tape. Obviously, thereshould be at least two input tapes, so it doesn™t make sense to try to do tapesorting with less than three tapes.For disk sorting, when access to arbitrary positions is allowed but issomewhat more expensive than sequential access, it is also reasonable tochoose P to be one less than the number of disks available, to avoid thehigher cost of non-sequential access that would be involved, for example, iftwo different input files were on the same disk. Another alternative commonly
used is to pick P large enough so that the sort will be complete in two mergingphases: it is usually unreasonable to try to do the sort in one pass, but a two-pass sort can often be done with a reasonably small P. Since replacementselection produces about N/2M runs and each merging pass divides thenumber of runs by P, this means P should be chosen to be the smallest integerwith P2 > N/2M. For our example of sorting a 200-million-word file on acomputer with a l-million-word memory, this implies that P = 11 would be asafe choice to ensure a two-pass sort. (The right value of P could be computed
EXTERNAL SORTING163exactly after the sort phase is completed ) The best choice between these twoalternatives of the lowest reasonable value of P and the highest reasonablevalue of P is obviously very dependent on many systems parameters: bothalternatives (and some in between) should be considered.Polyphase MergingOne problem with balanced multiway merging for tape sorting is that itrequires either an excessive number of tape units or excessive copying. ForP-way merging either we must use 2P t lpes (P for input and P for output)or we must copy almost all of the file from a single output tape to P inputtapes between merging passes, which effectively doubles the number of passesto be about 21og,(N/2M).Severalclevl:r tape-sorting algorithms have beeninvented which eliminate virtually all of this copying by changing the way inwhich the small sorted blocks are merged together. The most prominent ofthese methods is called polyphase mergir;g.The basic idea behind polyphase merging is to distribute the sorted blocksproduced by replacement selection somewhat unevenly among the availabletape units (leaving one empty) and thc:n to apply a ﬁmerge until emptyﬂstrategy, at which point one of the output tapes and the input, tape switchroles.For example, suppose that we have just three tapes, and we start outwith the following initial configuration of sorted blocks on the tapes. (Thiscomes from applying replacement selection to our example file with an internal
memory that can only hold two records.:Tape I : A 0 R S TIN AGN DEMR GINTape,2:EGX AMP ELTape 3:After three 2-way merges from tape3 1 and 2 to tape 3, the second tapebecomes empty and we are left with the configuration:Tapel: DEMR G INTape 2:TapeS:AEGOR STX AIMNP AEGLNThen, after two 2-way merges from tapes 1 and 3 to tape 2, the first tapebecomes empty, leaving:Tape 1:TapeZ:ADEEGMORRSTX AGIIMNNPTape3:AEGLN
164CHAPTER 13The sort is completed in two more steps. First, a two-way merge fromtapes 2 and 3 to tape 1 leaves one file on tape 2, one file on tape 1. Then atwoway merge from tapes 1 and 2 to tape 3 leaves the entire sorted file ontape 3.This ﬁmerge until emptyﬂ strategy can be extended to work for an ar-bitrary number of tapes. For example, if we have four tape units Tl, T2,T3, and T4 and we start out with Tl being the output tape, T2 having 13initial runs, T3 having 11 initial runs, and T4 having 7 initial runs, then afterrunning a 3-way ﬁmerge until empty,ﬂwe have T4 empty, Tl with 7 (long)runs, T2 with 6 runs, and T3 with 4 runs. At this point, we can rewindTl and make it an input tape, and rewind T4 and make it an output tape.Continuing in this way, we eventually get the whole sorted file onto Tl:Tl T2 T3 T4013 11 77 6 4 03 2 0 41 0 2 20 1 1 11 0 0 0The merge is broken up into many phases which don™t involve all the data,but no direct copying is involved.The main difficulty in implementing a polyphase merge is to determinehow to distribute the initial runs. It is not difficult to see how to build thetable above by working backwards: take the largest number on each line, make
it zero, and add it to each of the other numbers to get the previous line. This
corresponds to defining the highest-order merge for the previous line which
could give the present line. This technique works for any number of tapes(at least three): the numbers which arise are ﬁgeneralized Fibonacci numbersﬂwhich have many interesting properties. Of course, the number of initial runsmay not be known in advance, and it probably won™t be exactly a generalized
Fibonacci number. Thus a number of ﬁdummyﬂ runs must be added to make
the number of initial runs exactly what is needed for the table.The analysis of polyphase merging is complicated, interesting, and yieldssurprising results. For example, it turns out that the very best method fordistributing dummy runs among the tapes involves using extra phases andmore dummy runs than would seem to be needed. The reason for this is thatsome runs are used in merges much more often than others.
EXTERNAL SORTING165There are many other factors to be t&ken into consideration in implement-ing a most efficient tape-sorting method. For example, a major factor whichwe have not considered at all is the timt: that it takes to rewind a tape. Thissubject has been studied extensively, ant many fascinating methods have beendefined. However, as mentioned above, the savings achievable over the simplemultiway balanced merge are quite limited. Even polyphase merging is onlybetter than balanced merging for small P, and then not substantially. ForP > 8, balanced merging is likely to run j™aster than polyphase, and for smallerP the effect of polyphase is basically to sue two tapes (a balanced merge withtwo extra tapes will run faster).An Easier WayMany modern computer systems provide a large virtual memory capabilitywhich should not be overlooked in imp ementing a method for sorting verylarge files. In a good virtual memory syf#tem, the programmer has the abilityto address a very large amount of data, leaving to the system the responsibilityof making sure that addressed data is Lransferred from external to internalstorage when needed. This strategy relict on the fact that many programs havea relatively small ﬁlocality of referenceﬂ :each reference to memory is likely tobe to an area of memory that is relatively close to other recently referencedareas. This implies that transfers from e:rternal to internal storage are neededinfrequently. An int,ernal sorting method with a small locality of reference canwork very well on a virtual memory system. (For example, Quicksort has twoﬁlocalitiesﬂ :most references are near one of the two partitioning pointers.)But check with your systems programmclr before trying it on a very large file:a method such as radix sorting, which hE,s no locality of reference whatsoever,would be disastrous on a virtual memory system, and even Quicksort couldcause problems, depending on how well the available virtual memory systemis implemented. On the other hand, th™: strategy of using a simple internalsorting method for sorting disk files desl:rves serious consideration in a goodvirtual memorv environment.
166Exercises1.Describe how you would do external selection: find the kth largest in afile of N elements, where N is much too large for the file to fit in mainmemory.2. Implement the replacement selection algorithm, then use it to test theclaim that the runs produced are about twice the internal memory size.3.What is the worst that can happen when replacement selection is used toproduce initial runs in a file of N records, using a priority queue of sizeM, with M < N.4. How would you sort the contents of a disk if no other storage (exceptmain memory) were available for use?5. How would you sort the contents of a disk if only one tape (and mainmemory) were available for use?6. Compare the 4-tape and 6-tape multiway balanced merge to polyphasemerge with the same number of tapes, for 31 initial runs.7.How many phases does 5-tape polyphase merge use when started up withfour tapes containing 26,15,22,28 runs?8. Suppose the 31 initial runs in a 4-tape polyphase merge are each onerecord long (distributed 0, 13, 11, 7 initially). How many records arethere in each of the files involved in the last three-way merge?9. How should small files be handled in a Quicksort implementation to berun on a very large file within a virtual memory environment?10.How would you organize an external priority queue? (Specifically, designa way to support the insert and remove operations of Chapter 11, when
the number of elements in the priority queue could grow to be much to
large for the queue to fit in main memory.)
167SOURCES for SortingThe primary reference for this section is volume three of D. E. Knuth™sseries on sorting and searching. Further information on virtually every topicthat we™ve touched upon can be found in that book. In particular, the results
that we™ve quoted on performance chal,acteristics of the various algorithmsare backed up by complete mathematic:tl analyses in Knuth™s book.There is a vast amount of literatllre on sorting. Knuth and Rivest™s1973 bibliography contains hundreds of entries, and this doesn™t include thetreatment of sorting in countless books ind articles on other subjects (not tomention work since 1973).For Quicksort, the best reference is Hoare™s original 1962 paper, whichsuggests all the important variants, including the use for selection discussedin Chapter 12. Many more details on the mathematical analysis and the
practical effects of many of the modifications and embellishments which have
been suggested over the years may be fat nd in this author™s 1975 Ph.D. thesis.A good example of an advanced priority queue structure, as mentioned inChapter 11, is J. Vuillemin™s ﬁbinomial cueuesﬂ as implemented and analyzedby M. R. Brown. This data structure supports all of the priority queueoperations in an elegant and efficient manner.To get an impression of the myriall details of reducing algorithms likethose we have discussed to general-purpoire practical implementations, a readerwould be advised to study the reference material for his particular computersystem™s sort utility. Such material necef sarily deals primarily with formats ofkeys, records and files as well as many other details, and it is often interestingto identify how the algorithms themselv:s are brought into play.M. R. Brown, ﬁImplementation and am.lysis of binomial queue algorithms,ﬂSIAM Journal of Computing, 7, 3, (August, 1978).C. A. R. Hoare, ﬁQuicksort,ﬂ Computer Journal, 5, 1 (1962).D. E. Knuth, The Art of Computer Programming. Volume S: Sorting andSearching, Addison-Wesley, Reading, M9, second printing, 1975.R. L. Rivest and D. E. Knuth, ﬁBibliogIaphy 26: Computing Sorting,ﬂ Com-puting Reviews, 13, 6 (June, 1972).R. Sedgewick, Quicksort, Garland, New York, 1978. (Also appeared as theauthor™s Ph.D. dissertation, Stanford University, 1975).

SEARCHINGcfI--!t-Ii

14. Elementary Searching MethodsA fundamental operation intrinsic ;o a great many computational tasksis searching: retrieving some partic-liar information from a large amountof previously stored information.Normally we think of the information asdivided up into records, each record haling a key for use in searching. Thegoal of the search is to find all records with keys matching a given search key.The purpose of the search is usually to ;1ccess information within the record(not merely the key) for processing.Two common terms often used to describe data structures for searchingare dictionaries and symbol tables. For example, in an English language dic-tionary, the ﬁkeysﬂ are the words and the ﬁrecordsﬂ the entries associated withthe words which contain the definition, pronunciation, and other associated in-formation. (One can prepare for learning and appreciating searching methodsby thinking about how one would implenent a system allowing access to anEnglish language dictionary.) A symbol table is the dictionary for a program:the ﬁkeysﬂ a-e the symbolic names used in the program, and the ﬁrecordsﬂcontain information describing the objet t named.In searching (as in sorting) we havt: programs which are in widespreaduse on a very frequent basis, so that it vrill be worthwhile to study a varietyof methods in some detail. As with sorling, we™ll begin by looking at someelementary methods which are very useful for small tables and in other specialsituations and illustrate fundamental techniques exploited by more advancedmethods. We™ll look at methods which stelre records in arrays which are eithersearched with key comparisons or index:d by key value, and we™ll look at afundamental method which builds structures defined by the key values.As with priority queues, it is best to think of search algorithms as belong-ing to packages implementing a variety of generic operations which can beseparated from particular implementations, so that alternate implementations
could be substituted easily. The operations of interest include:171
172CHAPTER 14Initialize the data structure.Search for a record (or records) having a given key.Insert a new record.Delete a specified record.Join two dictionaries to make a large one.Sort the dictionary; output all the records in sorted order.As with priority queues, it is sometimes convenient to combine some of theseoperations. For example, a search and insert operation is often included forefficiency in situations where records with duplicate keys are not to be keptwithin the data structure. In many methods, once it has been determinedthat a key does not appear in the data structure, then the internal state ofthe search procedure contains precisely the information needed to insert a new
record with the given key.Records with duplicate keys can be handled in one of several ways,depending on the application. First, we could insist that the primary searchingdata structure contain only records with distinct keys. Then each ﬁrecordﬂ inthis data structure might contain, for example, a link to a list of all records
having that key. This is the most convenient arrangement from the point
of view of the design of searching algorithms, and it is convenient in some
applications since all records with a given search key are returned with onesearch.The second possibility is to leave records with equal keys in theprimary searching data structure and return any record with the given keyfor a search. This is simpler for applications that process one record at a
time, where the order in which records with duplicate keys are processed is
not important. It is inconvenient from the algorithm design point of view
because some mechanism for retrieving all records with a given key must still
be provided. A third possibility is to assume that each record has a unique
identifier (apart from the key), and require that a search find the record witha given identifier, given the key. Or, some more complicated mechanism couldbe used to distinguish among records with equal keys.Each of the fundamental operations listed above has important applica-tions, and quite a large number of basic organizations have been suggested tosupport efficient use of various combinations of the operations. In this and the
next few chapters, we™ll concentrate on implementations of the fundamental
functions search and insert (and, of course, initialize), with some comment ondelete and sort when appropriate. As with priority queues, the join operationnormally requires advanced techniques which we won™t be able to considerhere.Sequential SearchingThe simplest method for searching is simply to store the records in an array,
ELEMENTARY SEARCHING METHCDS173then look through the array sequentially each time a record is sought. Thefollowing code shows an implementation of the basic functions using this
simple organization, and illustrates sorle of the conventions that we™ll usein implementing searching methods.type node=record key, info: integer end;var a: array [O.maxN] of node;N: integer;procedure initialize;begin N:=O er d;function seqsearc:h(v: integer; x: integer): integer;begina[N+l].key:=v;if (x>=O) and (x<=N) thenrepeat x:=x+1 until v=a[x].key;seqsearch : =xend ;function seqinsel t(v: integer): integer;beginN:=N+I; a[Pr].key:=v;seqinsert:=N;end ;The code above processes records that have integer keys (key) and ﬁassociatedinformationﬂ (info). As with sorting, it vrill be necessary in many applicat,ionsto extend the programs to handle more complicated records and keys, butthis won™t fundamentally change the algorithms. For example, info could bemade into a pointer to an arbitrarily complicated record structure. In sucha case, this field can serve as the unique identifier for the record for use in
distinguishing among records with equal keys.The search procedure takes two arguments in this implementation: thekey value being sought and an index (x) into the array. The index is includedto handle the case where several records have the same key value: by succes-
sively executing t:= search(v, t) starting at t=O we can successively set t tothe index of each record with key value v.A sentinel record containing the key value being sought is used, whichensures that the search will always terminate, and therefore involves onlyone completion test within the inner loclp. After the inner loop has finished,testing whether the index returned is g;reater than N will tell whether thesearch found the sentinel or a key from the table. This is analogous to ouruse of a sentinel record containing the smallest or largest key value to simplify
174CHAF™TER 14the coding of the inner loop of various sorting algorithms.This method takes about N steps for an unsuccessful search (every recordmust be examined to decide that a record with any particular key is absent)and about N/2 steps, on the average, for a successful search (a ﬁrandomﬂsearch for a record in the table will require examining about half the entries,on the average).Sequential List SearchingThe seqsearch program above uses purely sequential access to the records,and thus can be naturally adapted to use a linked list representation for the
records. One advantage of doing so is that it becomes easy to keep the listsorted, as shown in the following implementation:type link=rnode;node=record key, info: integer; next: link end;var head, t, z: link;i: integer;procedure initialize;beginnew(z); zt.next:=z;new(head); headf.next:=z;end ;function listsearch(v: integer; t: link): link;beginzf.key:=v;repeat t : = tt .next until v< = tt .key;if v= tt .key then listsearch := telselis tsearch : = zend ;function listinsert (v: integer; t : link) : link;var x: link;beginzf.key:=v;while tt.nextt.key<v do t:=tt.next;new(x); xt.next:=tf.next; tt.next:=x;xf.key:=v;Jistinsert:=x;end ;With a sorted list, a search can be terminated unsuccessfully when a recordwith a key larger than the search key is found. Thus only about half the
ELEMENTARY SEARCHING METHO.DS175records (not all) need to be examined fo:* an unsuccessful search. The sortedorder is easy to maintain because a new record can simply be inserted into thelist at the point at which the unsuccessful search terminates. As usual with
linked lists, a dummy header node head and a tail node a allow the code tobe substantially simpler than without th:m. Thus, the call listinsert(v, head)will put a new node with key v into the lj st pointed to by the next field of thehead, and listsearch is similar. Repeated calls on listsearch using the linksreturned will return records with duplica,te keys. The tail node z is used as asentinel in the same way as above. If lis6search returns a, then the search wasunsuccessful.If something is known about the relative frequency of access for variousrecords, then substantial savings can oftc:n be realized simply by ordering therecords intelligently. The ﬁoptimalﬂ arrangement is to put the most frequentlyaccessed record at the beginning, the second most frequently accessed record
in the second position, etc. This technique can be very effective, especially if
only a small set of records is frequently accessed.If information is not available about the frequency of access, then anapproximation to the optimal arrangerlent can be achieved with a ﬁself-organizingﬂ search: each time a record is accessed, move it to the beginningof the list. This method is more conveniently implemented when a linked-listimplementation is used. Of course the running time for the method dependson the record access distributions, so it it; difficult to predict how it will do ingeneral. However, it is well suited to the quite common situation when mostof the accesses to each record tend to happen close together.Binary SearchIf the set of records is large, then the total search time can be significantlyreduced by using a search procedure based on applying the ﬁdivide-and-conquerﬂ paradigm: divide the set of records into two parts, determine whichof the two parts the key being sought t™elongs to, then concentrate on thatpart. A reasonable way to divide the sets of records into parts is to keep therecords sorted, then use indices into the sorted array to delimit the part of the
array being worked on. To find if a given key v is in the table, first compareit with the element at the middle position of the table. If v is smaller, thenit must be in the first half of the table; if v is greater, then it must be in thesecond half of the table. Then apply the method recursively. (Since only onerecursive call is involved, it is simpler to express the method iteratively.) Thisbrings us directly to the following implementation, which assumes that thearray a is sorted.
176CHAPTER 14function binarysearch (v: integer) : integer;var x, 1, r: integer;begin1:=1; r:=N;repeatx:=(I+r) div 2;if v<a[x].key then r:=x-l else 1:=x+1until (v=a[x].key) or (br);if v=a [x] .key then binarysearch :=xelsebinarysearch := N+ 1end ;Like Quicksort and radix exchange sort, this method uses the pointers 1 andr to delimit the subfile currently being worked on. Each time through theloop, the variable x is set to point to the midpoint of the current interval, andthe loop terminates successfully, or the left pointer is changed to x+1, or theright pointer is changed to x-l, depending on whether the search value v isequal to, less than, or greater than the key value of the record stored at a[~].The following table shows the subfiles examined by this method whensearching for S in a table built by inserting the keys A S E A R C H I N G EXAMPLE:1234567891011121314151617AAACEEEGHILMNPRSXAAACEEEGMILMNPRSXILMmPRSX--PNS xrls xThe interval size is at least halved at each step, so the total number oftimes through the loop is only about 1gN. However, the time required toinsert new records is high: the array must be kept sorted, so records must bemoved to make room for new records. For example, if the new record has
a smaller key than any record in the table, then every entry must be movedover one position. A random insertion requires that N/2 records be moved,on the average. Thus, this method should not be used for applications which
involve many insertions.
ELEMENTARY SEARCHING METHODS177Some care must be exercised to pro.)erly handle records with equal keysfor this algorithm: the index returned cmluld fall in the middle of a block ofrecords with key v, so loops which scan in both directions from that indexshould be used to pick up all the records.Of course, in this case the runningtime for the search is proportional to lg)V plus the number of records found.The sequence of comparisons made by the binary search algorithm ispredetermined: the specific sequence used is based on the value of the keybeing sought and the value of N. The comparison structure can be simplydescribed by a binary tree structure. The following binary tree describes thecomparison structure for our example se, of keys:In searching for the key S for instance, it is first compared to H. Since it isgreater, it is next compared to N; otheruise it would have been compared toC), etc. Below we will see algorithms that use an explicitly constructed binarytree structure to guide the search.One improvement suggested for binary search is to try to guess moreprecisely where the key being sought falls Tvithin the current interval of interest(rather than blindly using the middle element at each step). This mimics theway one looks up a number in the telephone directory, for example: if thename sought begins with B, one looks r(ear the beginning, but if it beginswith Y, one looks near the end. This method, called interpolation search,requires only a simple modification to the program above. In the programabove, the new place to search (the midpoint of the interval) is computedwith the statement x:=(l+r) div 2. This is derived from the computationz = 1+ $(r - 1): the middle of the interval is computed by adding half the sizeof the interval to the left endpoint. Inte*polation search simply amounts toreplacing i in this formula by an estima;e of where the key might be basedon the values available: i would be appropriate if v were in the middle of theinterval between a[I].key and a[r].key, but we might have better luck trying
178CHAPTER 14x:=J+(v-a[J].Jcey)*(r-J) div (a[r].Jcey-a[J].key). Of course, this assumesnumerical key values. Suppose in our example that the ith letter in thealphabet is represented by the number i. Then, in a search for S, the firsttable position examined would be x = 1 + (19 - 1)*(17 - 1)/(24 - 1) = 13. Thesearch is completed in just three steps:1234567891011121314151617AAACEEEGHILMNPRSXPHS x0 sxOther search keys are found even more efficiently: for example X and A arefound in the first step.Interpolation search manages to decrease the number of elements ex-amined to about 1oglogN. This is a very slowly growing function whichcan be thought of as a constant for practical purposes: if N is one billion,1glgN < 5. Thus, any record can be found using only a few accesses, a sub-stantial improvement over the conventional binary search method. But thisassumes that the keys are rather well distributed over the interval, and it
does require some computation: for small N, the 1ogN cost of straight binarysearch is close enough to log log N that the cost of interpolating is not likelyto be worthwhile. But interpolation search certainly should be considered forlarge files, for applications where comparisons are particularly expensive, orfor external methods where very high access costs are involved.Binary Tree SearchBinary tree search is a simple, efficient dynamic searching method whichqualifies as one of the most fundamental algorithms in computer science. It™sclassified here as an ﬁelementaryﬂ method because it is so simple; but in factit is the method of choice in many situations.The idea is to build up an explicit structure consisting of nodes, eachnode consisting of a record containing a key and left and right links. Theleft and right links are either null, or they point to nodes called the left sonand the right son. The sons are themselves the roots of trees, called the leftsubtree and the right subtree respectively. For example, consider the followingdiagram, where nodes are represented as encircled key values and the links bylines connected to nodes:
ELEMENTARY SEARCHTNG METHODS179EARe?CHIThe links in this diagram all point down. Thus, for example, E™s right linkpoints to R, but H™s left link is null.The defining property of a tree is that every node is pointed to by onlyone other node called its father.(We assume the existence of an imaginarynode which points to the root.) The defining property of a binary tree is thateach node has left and right links. For s:arching, each node also has a recordwith a key value; in a binary search tree we insist that all records with smallerkeys are in the left subtree and that i.11 records in the right subtree havelarger (or equal) key values. We™ll soon see that it is quite simple to ensurethat binary search trees built by successively inserting new nodes satisfy this
defining property.A search procedure like binarysearch immediately suggests itself for thisstructure. To find a record with a give 1 key U, first compare it against theroot. If it is smaller, go to the left SI btree; if it is equal, stop; and if itis greater, go to the right subtree.AplJy the method recursively. At eachstep, we™re guaranteed that no parts of tlie tree other than the current subtreecould contain records with key v, and, just as the size of the interval in binarysearch shrinks, the ﬁcurrent subtreeﬂ always gets smaller. The procedure stopseither when a record with key v is founcl or, if there is no such record, whenthe ﬁcurrent subtreeﬂ becomes empty. (The words ﬁbinary,ﬂ ﬁsearch,ﬂ andﬁtreeﬂ are admittedly somewhat overuse,1 at this point, and the reader shouldbe sure to understand the difference betlveen the binarysearch function givenabove and the binary search trees described here. Above, we used a binarytree to describe the sequence of comparisons made by a function searching
in an array; here we actually construct2. data structure of records connectedwith links which is used for the search.)
180CHAPTER 14type link=tnode;node=record key, info: integer; 1, r: link end;var t, head, z: link;function treesearch(v: integer; x: link): link;beginzt.key:=v;repeatif v<xf.key then x:=xt.l else x:=xt.runtil v=xt . key;treesearch : =xend ;As with sequential list searching, the coding in this program is simplifiedby the use of a ﬁtailﬂ node z. Similarly, the insertion code given below issimplified by the use of a tree header node head whose right link points to theroot. To search for a record with key v we set x:= treesearch(v, head).If a node has no left (right) subtree then its left (right) link is set topoint to z. As in sequential search, we put the value sought in a to stopan unsuccessful search. Thus, the ﬁcurrent subtreeﬂ pointed to by x neverbecomes empty and all searches are ﬁsuccessfulﬂ : the calling program cancheck whether the link returned points to a to determine whether the searchwas successful. It is sometimes convenient to think of links which point to z aspointing to imaginary external nodes with all unsuccessful searches ending atexternal nodes. The normal nodes which cont,ain our keys are called internalnodes; by introducing external nodes we can say that every internal nodepoints to two other nodes in the tree, even though, in our implementation, allof the external nodes are represented by the single node z.For example, if D is sought in the tree above, first it is compared againstE, the key at the root. Since D is less, it is next compared against A, the keyin the left son of the node containing E. Continuing in this way, D is comparednext against the C to the right of that node. The links in the node containingC are pointers to z so the search terminates with D being compared to itselfin z and the search is unsuccessful.To insert a node into the tree, we just do an unsuccessful search for it,then hook it on in place of z at the point where the search terminated, as inthe following code:
ELEMENTARY SEARCHING METHODS181function treeinsert(v: integer; x:link): link;var f: link;beginrepeatf:=x;if v<xf.key then x:=x1.1 else x:=x7.1-until x=z;new(x); xf.key:=v; xt.l:=z; xf.r:=z;if v<ff.key then f/.1:=x else f/x=x;treeinsert:=xend ;To insert a new key in a tree with a tree header node pointed to by head, wecall treeinsert(v, head). To be able to do the insertion, we must keep track ofthe father f of x, as it proceeds down the tree. When the bottom of the tree(x=z) is reached, f points to the node whose link must be changed to point tothe new node inserted. The function returns a link to the newly created nodeso that the calling routine can fill in the info field as appropriate.When a new node whose key is equal to some key already in the treeis inserted, it will be inserted to the right of the node already in the tree.All records with key equal to v can be processed by successively setting t tosearch(v, t) as we did for sequential searching.As mentioned above, it is convenient to use a tree header node headwhose right link points to the actual root node of the tree, and whose key issmaller than all other key values (for simplicity, we use 0 assuming the keysare all positive integers). The left link of head is not used. The empty tree isrepresented by having the right link of head point to z, as constructed by thefollowing code:procedure treeinitialize;beginnew(z); new(head);headt.key:=O; headf.r:=z;end ;To see the need for head, consider what happens when the first node is insertedinto an empty tree constructed by treeinitialize.The diagram below shows the tree constructed when our sample keys areinserted into an initially empty tree.
182CHAPTER 14The nodes in this tree are numbered in the order in which they were inserted.Since new nodes are added at the bottom of the tree, the construction process
can be traced out from this diagram: the tree as it was after Ic records had beeninserted is simply the part of the tree consisting only of nodes with numbersless than k (and keys from the first k letters of A S E A R C H I N G E X AM P L E).The sort function comes almost for free when binary search trees areused, since a binary search tree represents a sorted file if you look at it theright way. Consider the following recursive program:procedure treeprint (x: link) ;beginif x< > a thenbegintreeprint (xl .I) ;printnode(treeprint(xf.r)endend ;
ELEMENTARY SEARCHING METHODSThe call treeprint(head7.r) will print out the keys of the tree in order. Thisdefines a sorting method which is remarkably similar to Quicksort, with thenode at the root of the tree playing a role similar to that of the partitioning
element in Quicksort. A major difference is that the tree-sorting method must
use extra memory for the links, while Quicksort sorts with only a little extramemory.The running times of algorithms on binary search trees are quite depen-dent on the shapes of the trees. In the best case, the tree could be shaped likethat given above for describing the comparison structure for binary search,with about lg N nodes between the root and each external node. We might,roughly, expect logarithmic search times on the average because the first ele-ment inserted becomes the root of the tree; if N keys are to be inserted at
random, then this element would divide the keys in half (on the average),
leading to logarithmic search times (using the same argument on the subtrees).
Indeed, were it not for the equal keys, it could happen that the tree given abovefor describing the comparison structure for binary search would be built. Thiswould be the best case of the algorithm, with guaranteed logarithmic running
time for all searches. Actually, the root is equally likely to be any key in a
truly random situation, so such a perfectly balanced tree would be extremely
rare. But if random keys are inserted, it turns out that the trees are nicely
balanced. The average number of steps for a treesearch in a tree built bysuccessive insertion of N random keys is proportional to 2 In N.On the other hand, binary tree searching is susceptible to the same worst-case problems as Quicksort. For example, when the keys are inserted in order(or in reverse order) the binary tree search method is no better than thesequential search method that we saw at the beginning of this chapter. In the
next chapter, we™ll examine a technique for eliminating this worst case and
making all trees look more like the best-case tree.The implementations given above for the fundamental search, insert, andsort functions using binary tree structures are quite straightforward. However,binary trees also provide a good example of a recurrent theme in the studyof searching algorithms: the delete function is often quite cumbersome toimplement. To delete a node from a binary tree is easy if the node has nosons, like L or P in the tree above (lop it off by making the appropriate linkin its father null); or if it has just one son, like G or R in the tree above(move the link in the son to the appropriate father link); but what aboutnodes with two sons, such as H or S in the tree above? Suppose that x is alink to such a node. One way to delete the node pointed to by x is to first sety to the node with the next highest key. By examining the treeprint routine,one can become convinced that this node must have a null left link, and thatit can be found by y:=xf.r; while yt.l<>z do p:=yt.l. Now the deletion canbe accomplished by copying yfkey and yf.info into xt.key and xt.info, then
184CIfAPTER 14deleting the node pointed to by y. Thus, we delete H in the example aboveby copying I into H, then deleting I; and we delete the E at node 3 by copying
the E at node 11 into node 3, then deleting node 11. A full implementation
of a treedelete procedure according to this description involves a fair amount
of code to cover all the cases: we™ll forego the details because we™ll be doing
similar, but more complicated manipulations on trees in the next chapter. It is
quite typical for searching algorithms to require significantly more complicated
implementations for deletion: the keys themselves tend to be integral to thestructure, and removal of a key can involve complicated repairs.Indirect Binary Search TreesAs we saw with heaps in Chapter 11, for many applications we want a search-ing structure to simply help us find records, without moving them around.For example, we might have an array a[l..N] of records with keys, and wewould like the search routine to give us the index into that array of the recordmatching a certain key. Or we might want to remove the record with a givenindex from the searching structure, but still keep it in the array for someother use.To adapt binary search trees to such a situation, we simply make theinfo field of the nodes the array index. Then we could eliminate the key fieldby having the search routines access the keys in the records directly, e.g. viaan instruction like if v<a[xt .info] then. . . . However, it is often better tomake a copy of the key, and use the code above just as it is given. We™lluse the function name bstinsert(v, info: integer; x: link) to refer to a functionjust like treeinsert, except that it also sets the info field to the value givenin the argument. Similarly, a function bstdelete(v,info: integer;x: link) todelete the node with key v and array index info from the binary search treerooted at x will refer to an implementation of the delete function as describedabove. These functions use an extra copy of the keys (one in the array, onein the tree), but this allows the same function to be used for more than one
array, or as we™ll see in Chapter 27, for more than one key field in the same
array. (There are other ways to achieve this: for example, a procedure could
be associated with each tree which extracts keys from records.)Another direct way to achieve ﬁindirectionﬂ for binary search trees is tosimply do away with the linked implementation entirely. That is, all links justbecome indices into an array a[1 ..N] of records which contain a key field and 1and r index fields. Then link references such as if v<xf.key then x:=x7.1 else. . .become array references such as if v<a[x].key then x:=a[x].J else.. . . Nocalls to new are used, since the tree exists within the record array: new(head)becomes head:=& new(z) becomes z:=iV+1, and to insert the Mth node, wewould pass M, not v, to treeinsert, and then simply refer to a[M].key insteadof v and replace the line containing new(x) in treeinsert with x:=M. This
ELEMENTARY SEARCHING METHODS185way of implementing binary search trees to aid in searching large arrays ofrecords is preferred for many applications, since it avoids the extra expense of
copying keys as in the previous paragraph, and it avoids the overhead of the
storage allocation mechanism implied by new. The disadvantage is that space
is reserved with the record array for links which may not be in use, whichcould lead to problems with large arrays in a dynamic situation.
186Exercises1. Implement a sequential searching algorithm which averages about N/2steps for both successful and unsuccessful search, keeping the records ina sorted array.2.Give the order of the keys after records with the keys E A S Y Q U E S TI 0 N have been put into an intially empty table with search and insertusing the self-organizing search heuristic.3.Give a recursive implementation of binary search.4.Suppose a[i]=2i for 1 5 i 5 N. How many table positions are examinedby interpolation search during the unsuccessful search for 2k - l?5.Draw the binary search tree that results from inserting records with thekeys E A S Y Q U E S T I 0 N into an initially empty tree.6. Write a recursive program to compute the height of a binary tree: thelongest distance from the root to an external node.7.Suppose that we have an estimate ahead of time of how often search keysare to be accessed in a binary tree. Should the keys be inserted into thetree in increasing or decreasing order of likely frequency of access? Why?8.Give a way to modify binary tree search so that it would keep equal keystogether in the tree. (If there are any other nodes in the tree with the
same key as any given node, then either its father or one of its sons shouldhave an equal key.)9.Write a nonrecursive program to print out the keys from a binary searchtree in order.10.Use a least-squares curvefitter to find values of a and b that give the bestformula of the form aN In N + bN for describing the total number ofinstructions executed when a binary search tree is built from N randomkeys.
15. Balanced TreesThe binary tree algorithms of the previous section work very well fora wide variety of applications, but they do have the problem of badworst-case performance. What™s more, as with Quicksort, it™s embarrassinglytrue that the bad worst case is one that™s likely to occur in practice if the
person using the algorithm is not watching for it. Files already in order,
files in reverse order, files with alternating large and small keys, or files with
any large segment having a simple structure can cause the binary tree search
algorithm to perform very badly.With Quicksort, our only recourse for improving the situation was toresort to randomness: by choosing a random partitioning element, we couldrely on the laws of probability to save us from the worst case. Fortunately,
for binary tree searching, we can do much better: there is a general technique
that will enable us to guarantee that this worst case will not occur. This
technique, called balancing, has been used as the basis for several differentﬁbalanced treeﬂ algorithms. We™ll look closely at one such algorithm anddiscuss briefly how it relates to some of the other methods that are used.As will become apparent below, the implementation of balanced treealgorithms is certainly a case of ﬁeasier said than done.ﬂ Often, the generalconcept behind an algorithm is easily described, but an implementation is a
morass of special and symmetric cases. Not only is the program developed in
this chapter an important searching method, but also it is a nice illustrationof the relationship between a ﬁhigh-levelﬂ algorithm description and a ﬁlow-levelﬂ Pascal program to implement the algorithm.Top-Down 2-3-4 TreesTo eliminate the worst case for binary search trees, we™ll need some flexibilityin the data structures that we use. To get this flexibility, let™s assume that wecan have nodes in our trees that can hold more than one key. Specifically, we™ll187
188CHAPTER 15allow J-nodes and d-nodes, which can hold two and three keys respectively. A3-node has t.hree links coming out of it, one for all records with keys smallerthan both its keys, one for all records with keys in between its two keys, andone for all records with keys larger than both its keys. Similarly, a 4-node
has four links coming out of it, one for each of the intervals defined by its
three keys. (The nodes in a standard binary search tree could thus be called,%nodes: one key, two links.) We™ll see below some efficient ways of definingand implementing the basic operations on these extended nodes; for now, let™sassume we can manipulate them conveniently and see how they can be put
together to form trees.For example, below is a &Y-4 tree which contains some keys from oursearching example.It is easy to see how to search in such a tree. For example, to search for0 in the tree above, we would follow the middle link from the root, since 0is between E and R then terminate the unsuccessful search at the right linkfrom the node containing H and I.To insert a new node in a 2-3-4 tree, we would like to do an unsuccessfulsearch and then hook the node on, as before. It is easy to see what to if thenode at which the search terminates is a 2-node: just turn it into a 3-node.Similarly, a 3-node can easily be turned into a 4-node. But what should wedo if we need to insert our new node into a 4-node? The answer is that weshould first split the 4-node into two 2-nodes and pass one of its keys furtherup in the tree. To see exactly how to do this, let™s consider what happens
when the keys from A S E A R C H I N G E X A M P L E are inserted intoan initially empty tree. We start out with a a-node, then a 3-node, then a4-node:Now we need to put a second A into the 4-node. But notice that as far asthe search procedure is concerned, the 4-node at the right above is exactlyequivalent to the binary tree:
BALANCED TREES189EFeiiA sIf our algorithm ﬁsplitsﬂ the 4-node to make this binary tree before trying toinsert the A, then there will be room for A at the bottom:EF5b-lAA sNow R, C, and the H can be inserted, but when it™s time for I to be inserted,there™s no room in the 4-node at the right:Again, this 4-node must be split into two 2-nodes to make room for the I, butthis time the extra key needs to be inserted into the father, changing it from
a 2-node to a S-node. Then the N can be inserted with no splits, then the Gcauses another split, turning the root into a 4-node:But what if we were to need to split a 4-node whose father is also a 4-node?One method would be to split the father also, but this could keep happeningall the way back up the tree. An easier way is to make sure that the father of
any node we see won™t be a 4-node by splitting any 4-node we see on the way
down the tree. For example, when E is inserted, the tree above first becomes
190This ensures that we could handle the situation at the bottom even if E wereto go into a 4-node (for example, if we were inserting another A instead).
Now, the insertion of E, X, A, M, P, L, and E finally leads to the tree:The above example shows that we can easily insert new nodes into 2-3-4 trees by doing a search and splitting 4-nodes on the way down the tree.Specifically, every time we encounter a 2-node connected to a 4-node, we
should transform it into a 3-node connected to two 2-nodes:and every time we encounter a 3-node connected to a 4-node, we shouldtransform it into a 4-node connected to two 2-nodes:
BALANCED TREESThese transformations are purely ﬁlocalﬂ: no part of the tree need be examinedor modified other than what is diagrammed. Each of the transformationspasses up one of the keys from a 4-node to its father in the tree, restructuringlinks accordingly. Note that we don™t have to worry explicitly about the fatherbeing a 4-node since our transformations ensure that as we pass through eachnode in the tree, we come out on a node that is not a 4-node. In particular,when we come out the bottom of the tree, we are not on a 4-node, and wecan directly insert the new node either by transforming a 2-node to a 3-nodeor a 3-node to a 4-node. Actually, it is convenient to treat the insertion as a
split of an imaginary 4-node at the bottom which passes up the new key to be
inserted. Whenever the root of the tree becomes a 4-node, we™ll split it into
three 2-nodes, as we did for our first node split in the example above. This(and only this) makes the tree grow one level ﬁhigher.ﬂThe algorithm sketched in the previous paragraph gives a way to dosearches and insertions in 2-3-4 trees; since the 4-nodes are split up on theway from the top down, the trees are called top-down 2-S-4 trees. What™sinteresting is that, even though we haven™t been worrying about balancing atall, the resulting trees are perfectly balanced! The distance from the root toevery external node is the same, which implies that the time required by asearch or an insertion is always proportional to log N. The proof that the treesare always perfectly balanced is simple: the transformations that we performhave no effect on the distance from any node to the root, except when we splitthe root, and in this case the distance from all nodes to the root is increasedby one.The description given above is sufficient to define an algorithm for search-ing using binary trees which has guaranteed worst-case performance. However,we are only halfway towards an actual implementation. While it would bepossible to write algorithms which actually perform transformations on dis-tinct data types representing 2-, 3-, and 4-nodes, most of the things that needto be done are very inconvenient in this direct representation. (One can be-come convinced of this by trying to implement even the simpler of the twonode transformations.) Furthermore, the overhead incurred in manipulatingthe more complex node structures is likely to make the algorithms slower thanstandard binary tree search. The primary purpose of balancing is to provideﬁinsuranceﬂ against a bad worst case, but it would be unfortunate to haveto pay the overhead cost for that insurance on every run of the algorithm.Fortunately, as we™ll see below, there is a relatively simple representation of2-, 3-, and 4-nodes that allows the transformations to be done in a uniformway with very little overhead beyond the costs incurred by standard binarytree search.
192CHAPTER 15Red-Black TreesRemarkably, it is possible to represent 2-3-4 trees as standard binary trees(2-nodes only) by using only one extra bit per node. The idea is to represent3-nodes and 4nodes as small binary trees bound together by ﬁredﬂ linkswhich contrast with the ﬁblackﬂ links which bind the 2-3-4 tree together. Therepresentation is simple: 4-nodes are represented as three 2-nodes connectedby red links and 3-nodes are represented as two 2-nodes connected by a red
link (red links are drawn as double lines):(Either orientation for a 3-node is legal.) The binary tree drawn below is oneway to represent the final tree from the example above. If we eliminate thered links and collapse the nodes they connect together, the result is the 2-3-4tree from above. The extra bit per node is used to store the color of the link
pointing to that node: we™ll refer to 2-3-4 trees represented in this way asred-black trees.
BALANCED TREES193The ﬁslantﬂ of each 3-node is determined by the dynamics of the algorithmto be described below. There are many red-black trees corresponding to each
2-3-4 tree. It would be possible to enforce a rule that 3-nodes all slant the
same way, but there is no reason to do so.These trees have many structural properties that follow directly from theway in which they are defined. For example, there are never two red links ina row along any path from the root to an external node, and all such pathshave an equal number of black links. Note that it is possible that one path(alternating black-red) be twice as long as another (all black), but that allpath lengths are still proportional to 1ogN.A striking feature of the tree above is the positioning of duplicate keys.On reflection, it is clear that any balanced tree algorithm must allow recordswith keys equal to a given node to fall on both sides of that node: otherwise,severe imbalance could result from long strings of duplicate keys. This impliesthat we can™t find all nodes with a given key by repeated calls to the searchingprocedure, as in the previous chapter. However, this does not present a real
problem, because all nodes in the subtree rooted at a given node with thesame key as that node can be found with a simple recursive procedure likethe treeprint procedure of the previous chapter. Or, the option of requiring
distinct keys in the data structure (with linked lists of records with duplicatekeys) could be used.One very nice property of red-black trees is that the treesearch procedurefor standard binary tree search works without modification (except for theproblem with duplicate keys discussed in the previous paragraph). We™llimplement the link colors by adding a boolean field red to each node which istrue if the link pointing to the node is red, false if it is black; the treesearchprocedure simply never examines that field. That is, no ﬁoverheadﬂ is addedby the balancing mechanism to the time taken by the fundamental searching
procedure. Each key is inserted just once, but might be searched for many
times in a typical application, so the end result is that we get improved search
times (because the trees are balanced) at relatively little cost (because no work
for balancing is done during the searches).Moreover, the overhead for insertion is very small: we have to do some-thing different only when we see 4-nodes, and there aren™t many 4-nodes inthe tree because we™re always breaking them up. The inner loop needs onlyone extra test (if a node has two red sons, it™s a part of a 4-node), as shownin the following implementation of the insert procedure:
194CHripTER 15function rbtreeinsert(v: integer; x:Jink) : link;var gg, g, f: link;beginf:=x; g:=x;repeatgg:=g; g:=f; f:=x;if v<xf.key then x:=xf.J else x:=xf.r;if xt.Jt.red and xt.rt.red then x:=spJit(v, gg, g, f, x);until x=8;new(x); xt.key:=v; xt.J:=z; xt.r:=z;if v<f/.key then f/.J:=x else Q.r:=x;rbtreeinsert:=x;x:=spJit(v, gg, g, f, x);end ;In this program, x moves down the tree as before, with gg, g, and f keptpointing to x™s great-grandfather, grandfather, and father in the tree. To seewhy all these links are needed, consider the addition of Y to the tree above.When the external node at the right of the 3-node containing S and X isreached, gg is R, g is S, and f is X. Now, Y must be added to make a 4-nodecontaining S, X, and Y, resulting in the following tree:We need a pointer to R (gg) because R™s right link must be changed to pointto X, not S. To see exactly how this comes about, we need to look at theoperation of the split procedure.To understand how io implement the split operation, let™s consider thered-black representation for the two transformations we must perform: if wehave a 2-node connected to a 4-node, then we should convert them into a
BALANCED TREES1953-node connected to two a-nodes; if we have a S-node connected to a 4-node,we should convert them into a 4-node connected to two 2-nodes. When anew node is added at the bottom, it is considered to be the middle node ofan imaginary 4-node (that is, think of a as being red, though this never getsexplicitly tested).The transformation required when we encounter a a-node connected to a4-node is easy:This same transformation works if we have a 3-node connected to a 4-node inthe ﬁrightﬂ way:Thus, split will begin by marking x to be red and the sons of x to be black.This leaves the two other situations that can arise if we encounter a S-node
connected to a 4-node:
196CHAPTER 15gfX6*?(Actually, there are four situations, since the mirror images of these two canalso occur for S-nodes of the other orientation.) In these cases, the split-up ofthe 4-node has left two red links in a row, an illegal situation which must be
corrected. This is easily tested for in the code: we just marked x red; if x™s
father f is also red, we must take further action. The situation is not too bad
because we do have three nodes connected by red links: all we need to do is
transform the tree so that the red links point down from the same node.Fortunately, there is a simple operation which achieves the desired effect.Let™s begin with the easier of the two, the third case, where the red linksare oriented the same way. The problem is that the 3-node was oriented thewrong way: accordingly, we restructure the tree to switch the orientation ofthe 3-node, thus reducing this case to be the same as the second, where thecolor flip of x and its sons was sufficient. Restructuring the tree to reorient aS-node involves changing three links, as shown in the example below:
BALANCED TREES197In this diagram, TI represents the tree containing all the records with keysless than A, Tz, contains all the records with keys between A and B, and soforth. The transformation switches the orientation of the S-node containingA and B without disturbing the rest of the tree. Thus none of the keys inTI, Tz, T3, and T, are touched. In this case, the transformation is effected bythe link changes st.l:=gsf.r; gst.r:=s; yt.l:=gs. Also, note carefully that thecolors of A and B are switched. There are three analogous cases: the 3-nodecould be oriented the other way, or it could be on the right side of y (oriented
either way).Disregarding the colors, this single rotation operation is defined on anybinary search tree and is the basis for several balanced tree algorithms. It isimportant to note, however, that doing a single rotation doesn™t necessarily
improve the balance of the tree. In the diagram above, the rotation bringsall the nodes in Tl one step closer to the root, but all the nodes in T3 arelowered one step. If T3 were to have more nodes than Tl, then the tree afterthe rotation would become less balanced, not more balanced. Top-down 2-3-4trees may be viewed as simply a convenient way to identify single rotationswhich are likely to improve the balance.Doing a single rotation involves structurally modifying the tree, some-thing that should be done with caution. A convenient way to handle the fourdifferent cases outlined above is to use the search key v to ﬁrediscoverﬂ the
relevant son (s) and grandson (gs) of the node y. (We know that we™ll only be
reorienting a 3-node if the search took us to its bottom node.) This leads tosomewhat simpler code that the alternative of remembering during the searchnot only the two links corresponding to s and gs but also whether they areright or left links. We have the following function for reorienting a 3-node
along the search path for v whose father is y:function rotate(v: integer; y: link): link;var s,gs: link;beginif v<yt.key then s:=yf.l else s:=yf.r;if v< st . keythen begin gs:=sf.l; st.l:=gsf.r; gst.r:=s endelse begin gs:=st.r; sf.r:=gsf.l; gsf.I:=s end;if v<yt.key then yf.l:=gs else yf.r:=gs;rotate:=gsend ;If s is the left link of y and gs is the left link of s, this makes exactly the linktransformations for the diagram above.The reader may wish to check the
198CHAPTER 15other cases. This function returns the link to the top of the S-node, but doesnot do the color switch itself.Thus, to handle the third case for split, we can make g red, then set x torotate(v,gg), then make x black. This reorients the 3-node consisting of thetwo nodes pointed to by g and f and reduces this case to be the same as thesecond case, when the 3-node was oriented the right way.Finally, to handle the case when the two red links are oriented in differentdirections, we simply set f to rotate(v, g). This reorients the ﬁillegalﬂ S-nodeconsisting of the two nodes pointed to by f and x. These nodes are the samecolor, so no color change is necessary, and we are immediately reduced tothe third case. Combining this and the rotation for the third case is called adouble rotation for obvious reasons.This completes the description of the operations which must be performedby split. It must switch the colors of x and its sons, do the bottom part of adouble rotation if necessary, then do the single rotation if necessary:function split(v: integer; gg, g, f, x: link): link;beginxf.red:=true; xt.lf.red:=false; xf.rt.red:=false;if ft.red thenbegingf.red:= true;if (v<gf.key)<> (v<fi.key) then f:=rotate(v, g);x:=rotate(v, gg);xf.red:=falseend ;headf.rf.red:=false;split:=xend ;This procedure takes care of fixing the colors after a rotation and also restartsx high enough in the tree to ensure that the search doesn™t get lost dueto all the link changes. The long argument list is included for clarity; thisprocedure should more properly be declared local to rbtreeinsert, with accessto its variables.If the root is a 4-node then the split procedure will make the root red,corresponding to transforming it, along with the dummy node above it into a3-node. Of course, there is no reason to do this, so a statement is included atthe end of split to keep ihe root black.Assembling the code fragments above gives a very efficient, relativelysimple algorithm for insertion using a binary tree structure that is guaranteed
BALANCED TREESto take a logarithmic number of steps for all searches and insertions. Thisis one of the few searching algorithms with that property, and its use is
justified whenever bad worst-case performance simply cannot be tolerated.
Furthermore, this is achieved at very little cost. Searching is done just asquickly as if the balanced tree were constructed by the elementary algorithm,and insertion involves only one extra bit test and an occasional split. Forrandom keys the height of the tree seems to be quite close to 1gN (and onlyone or two splits are done for the average insertion) but no one has been ableto analyze this statistic for any balanced tree algorithm. Thus a key in a fileof, say, half a million records can be found by comparing it against only abouttwenty other keys.Other AlgorithmsThe ﬁtop-down 2-3-4 treeﬂ implementation using the ﬁred-blackﬂ frameworkgiven in the previous section is one of several similar strategies than have
been proposed for implementing balanced binary trees. As we saw above, it
is actually the ﬁrotateﬂ operations that balance the trees: we™ve been looking
at a particular view of the trees that makes it easy to decide when to rotate.Other views of the trees lead to other algorithms, a few of which we™ll mentionbriefly in this section.The oldest and most well-known data structure for balanced trees is theAVL tree. These trees have the property that the heights of the two subtreesof each node differ by at most one.If this condition is violated because ofan insertion, it turns out that it can be reinstated using rotations. But thisrequires an extra loop: the basic algorithm is to search for the value beinginserted, then proceed up the tree along the path just travelled adjusting theheights of nodes using rotations. Also, it is necessary to know whether eachnode has a height that is one less than, the same, or one greater than t,heheight of its brother. This requires two bits if encoded in a straightforwardway, though there is a way to get by with just one bit per node.A second well-known balanced tree structure is the 2-3 tree, where only2-nodes and 3-nodes are allowed. It is possible to implement insert using anﬁextra loopﬂ involving rotations as with AVL trees, but there is not quiteenough flexibility to give a convenient top-down version.In Chapter 18, we™ll study the most important type of balanced tree, anextension of 2-3-4 trees called B-trees. These allow up to M keys per node forlarge M, and are widely used for searching applications involving very largefiles.
200Exercises1.Draw the top-down 2-3-4 tree that is built when the keys E A S Y Q UE S T I 0 N are inserted into an initially empty tree (in that order).2.Draw a red-black representation of the tree from the previous question.3. Exactly what links are modified by split and rotate when Z is inserted(after Y) into the example tree for this chapter?4.Draw the red-black tree that results when the letters A to K are insertedin order, and describe what happens in general when keys are inserted
into the trees in ascending order.5.How many tree links actually must be changed for a double rotation, andhow many are actually changed in the given implementation?6.Generate two random 32-node red-black trees, draw them (either by handor with a program), and compare them with the unbalanced binary searchtrees built with the same keys.7.Generate ten random lOOO-node red-black trees. Compute the number ofrotations required to build the trees and the average distance from theroot to an external node for the trees that you generate. Discuss the
results.8. With 1 bit per node for ﬁcolor,ﬂwe can represent 2-, 3-, and 4-nodes.How many different types of nodes could we represent if we used 2 bitsper node for ﬁcolorﬂ?9.Rotations are required in red-black trees when S-nodes are made into 4-nodes in an ﬁunbalancedﬂ way. Why not eliminate rotations by allowing4-nodes to be represented as any three nodes connected by two red links
(perfectly balanced or not)?10. Use a least-squares curvefitter to find values of a and b that give thebest formula of the form aN 1gN + bN for describing the total numberof instructions executed when a red-black tree is built from N randomkeys.
16. HashingA completely different approach to searching from the comparison-based tree structures of the last section is provided by hashing: directlyreferencing records in a table by doing arithmetic transformations on keysinto t,able addresses. If we were to know that the keys are distinct integersfrom 1 to N, then we could store the record with key i in table position i,ready for immediate access with the key value. Hashing is a generalizationof this trivial method for typical searching applications when we don™t havesuch specialized knowledge about the key values.The first step in a search using hashing is to compute a hush functionwhich transforms the search key into a table address. No hash function isperfect, and two or more different keys might hash to the same table address:the second part of a hashing search is a collision resolution process whichdeals with such keys. One of the collision resolution methods that we™ll studyuses linked lists, and is appropriate in a highly dynamic situation where thenumber of search keys can not be predicted in advance. The other two collisionresolution methods that we™ll examine achieve fast search times on recordsstored within a fixed array.Hashing is a good example of a ﬁtime-space tradeoff.ﬂ If there were nomemory limitation, then we could do any search with only one memory accessby simply using the key as a memory address. If there were no time limitation,
then we could get by with only a minimum amount of memory by using asequential search method. Hashing provides a way to use a reasonable amountof memory and time to strike a balance between these two extremes. Efficientuse of available memory and fast access to the memory are prime concerns ofany hashing method.Hashing is a ﬁclassicalﬂ computer science problem in the sense that thevarious algorithms have been studied in some depth and are very widely used.There is a great deal of empirical and analytic evidence to support the utility201
202CHAPTER 16of hashing for a broad variety of applications.Hash FunctionsThe first problem we must address is the computation of the hash functionwhich transforms keys into table addresses. This is an arithmetic computationwith properties similar to the random number generators that we have studied.
What is needed is a function which transforms keys (usually integers or shortcharacter strings) into integers in the range [O..M-11, where A4 is the amountof memory available. An ideal hash function is one which is easy to computeand approximates a ﬁrandomﬂ function: for each input, every output shouldbe ﬁequally likely.ﬂSince the methods that we will use are arithmetic, the first step is totransform keys into numbers which can be operated on (and are as large aspossible). For example, this could involve removing bits from character stringsand packing them together in a machine word. From now on, we™ll assumethat such an operation has been performed and that our keys are integerswhich fit into a machine word.One commonly used method is to take A4 to be prime and, for any keyk, compute h(k) = k mod M. This is a straightforward method which is easyto compute in many environments and spreads the key values out well.A second commonly used method is similar to the linear congruentialrandom number generator: take M = 2m and h(k) to be the leading m bits of(bkmod w), where w is the word size of the computer and b is chosen as forthe random number generator. This can be more efficiently computed thanthe method above on some computers, and it has the advantage that it can
spread out key values which are close to one another (e. g., templ, temp$temp3). As we™ve noted before, languages like Pascal are not well-suited tosuch operaiions.Separate ChainingThe hash functions above will convert keys into table addresses: we still needto decide how to handle the case when two keys hash to the same address. Themost straightforward method is to simply build a linked list, for each tableaddress, of the records whose keys hash to that address. Since the keys whichhash to the same table position are kept in a linked list, they might as wellbe kept in order. This leads directly to a generalization of the elementary listsearching method that we discussed in Chapter 14. Rather than maintaining
a single list with a single list header node head as discussed there, we maintainM lists with M list header nodes, initialized as follows:
HASHTNG203type link=fnode;node=record key, info: integer; next: link end;var heads: array [O..M] of link;t, z: link;procedure initialize;var i: integer;beginnew(z); zt.next:=z;for i:=O to M-l dobegin new(heads[i]); heads[i]f.next:=z end;end ;Now the procedures from Chapter 14 can be used as is, with a hash functionused to choose among the lists. For example, listinsert(v, heads[v mod M] )can be used to add something to the table, t:=listsearch(v, heads[v mod M])to find the first record with key v, and successively set t:=listsearch(v, t) untilt=z to find subsequent records with key v.For example if the ith letter in the alphabet is represented with thenumber i and we use the hash function h(k) = kmod M, then we get thefollowing hash values for our sample set of keys with M = 11:Key:ASEARCHINGEXAMPLEHash:18517389375212515if these keys are successively inserted into an initially empty table, the follow-ing set of lists would result:012345678910AMCEG H IA X NER SAELPObviously, the amount of time required for a search depends on the lengthof the lists (and the relative positions of the keys in them). The lists could beleft unordered: maintaining sorted lists is not as important for this applicationas it was for the elementary sequential search because the lists are quite short.For an ﬁunsuccessful searchﬂ (for a record with a key not in the table) wecan assume that the hash function scrambles things enough so that each of
204CHAPTER 16the M lists is equally likely to be searched and, as in sequential list searching,that the list searched is only traversed halfway (on t,he average). The averagelength of the list examined (not counting z) in this example for unsuccessfulsearch is (0+4+2+2+0+4+0+2+2+1+0)/11 z 1.545. This would be theaverage time for an unsuccessful search were the lists unordered; by keepingthem ordered we cut the time in half. For a ﬁsuccessful searchﬂ (for one of the
records in the table), we assume that each record is equally likely to be sought:seven of the keys would be found as the first list item examined, six would befound as the second item examined, etc., so the average is (7.1+ 6.2 + 2.3 +2.4)/17) z 1.941. (This count assumes that equal keys are distinguished witha unique identifier or some other mechanism, and the search routine modifiedappropriately to be able to search for each individual key.)If N, the number of keys in the table, is much larger than M then a goodapproximation to the average length of the lists is N/M. As in Chapter 14,unsuccessful and successful searches would be expected to go about halfwaydown some list. Thus, hashing provides an easy way to cut down the time
required for sequential search by a factor of M, on the average.In a separate chaining implementation, M is typically chosen to be rela-tively small so as not to use up a large area of contiguous memory. But it™sprobably best to choose M sufficiently large that the lists are short enough tomake sequential search the most efficient method for them: ﬁhybridﬂ methods(such as using binary trees instead of linked lists) are probably not worth the
trouble.The implementation given above uses a hash table of links to headersof the lists containing the actual keys. Maintaining M list header nodes issomewhat wasteful of space; it is probably worthwhile to eliminate them andmake heads be a table of links to the first keys in the lists. This leads to
some complication in the algorithm. For example, adding a new record to the
beginning of a list becomes a different operation than adding a new record
anywhere else in a list, because it involves modifying an entry in the table of
links, not a field of a record. An alternate implementation is to put the first
key within the table. If space is at a premium, it is necessary to carefullyanalyze the tradeoff between wasting space for a table of links and wastingspace for a key and a link for each empty list. If N is much bigger than M thenthe alternate method is probably better, though M is usually small enoughthat the extra convenience of using list header nodes is probably justified.Open AddressingIf the number of elements to be put in the hash table can be estimated inadvance, then it is probably not worthwhile to use any links at all in the hashtable. Several methods have been devised which store N records in a table
HASHING205of size A4 > N, relying on empty places in the table to help with collisionresolution. Such methods are called open-addressing hashing methods.The simplest open-addressing method is called linear probing: when thereis a collision (when we hash to a place in the table which is already occupiedand whose key is not the same as the search key), then just probe the next
position in the table: that is, compare the key in the record there against
the search key. There are three possible outcomes of the probe: if the keysmatch, then the search terminates successfully; if there™s no record there,then the search terminates unsuccessfully; otherwise probe the next position,
continuing until either the search key or an empty table position is found. Ifa record containing the search key is to be inserted following an unsuccessfulsearch, then it can simply be put into the empty table space which terminated
the search. This method is easily implemented as follows:type node=record key, info: integer end;var a: array [O..M] of node;function h(k: integer): integer;begin h:=k mod Mend;procedure hashinitialize;var i: integer;beginfor i:=O to M do a[i].key:=maxint;end ;function hashinsert (v: integer) : integer;var x: integer;beginx:=h(v);while a[x].key<>maxint do x:=(x+1) mod M;a [x] .key:=v;hashinsert :=x;end ;Linear probing requires a special key value to signal an empty spot in thetable: this program uses maxint for that purpose. The computation x:=(x+1)mod M corresponds to examining the next position (wrapping back to thebeginning when the end of the table is reached). Note that this program doesnot check for the table being filled to capacity. (What would happen in thiscase?)The implementation of hashsearch is similar to hashinsert: simply addthe condition ﬁa [x] .key< >vﬂto the while loop, and delete the followinginstruction which stores v. This leaves the calling routine with the task
206CHAPTER 16of checking if the search was unsuccessful, by testing whether the tableposition returned actually contains v (successful) or maxi& (unsuccessful).Other conventions could be used, for example hashsearch could return Mfor unsuccessful search. For reasons that will become obvious below, openaddressing is not appropriate if large numbers of records with duplicate keys
are to be processed, but hashsearch can easily be adapted to handle equal
keys in the case where each record has a unique identifier.For our example set of keys with A4 = 19, we might get the hash values:Key:ASEARCHINGEXAMPLEHash:1051183891475511316125The following table shows the steps of successively inserting these into aninitially empty hash table:0123456789101112131415161718-SAAESAAm ESAAC E0HSAAC EHIIISAAC EH I0NSAAC E0GHINSAAC R~~GHISAAC ~~~~~~:SmbimwEEGHIXNSAACAEEGHIX0MNSAACAEEGHIXMNSAACAEEGHIXL-lLMNSAACA~~~~~~lE]LMN0RRRRRR
RR
RR0P RP RPR
HASHING207The table size is greater than before, since we must have M > N, but thetotal amount of memory space used is less, since no links are used. Theaverage number of items that must be examined for a successful search for
this example is: 33/17 z 1.941.Linear probing (indeed, any hashing method) works because it guaranteesthat, when searching for a particular key, we look at every key that hashesto the same table address (in particular, the key itself if it™s in the table).Unfortunately, in linear probing, other keys are also examined, especiallywhen the table begins to fill up: in the example above, the search for Xinvolved looking at G, H, and I which did not have the same hash value.What™s worse, insertion of a key with one hash value can drastically increasethe search times for keys with other hash values: in the example, an insertionat position 17 would cause greatly increased search times for position 16. This
phenomenon, called clustering, can make linear probing run very slowly for
nearly full tables.Fortunately, there is an easy way to virtually eliminate the clusteringproblem: double hashing. The basic strategy is the same; the only difference isthat, instead of examining each successive entry following a collided position,we use a second hash function to get a fixed increment to use for the ﬁprobeﬂsequence. This is easily implemented by inserting u:=h2(v) at the beginningof the procedure and changing x:=(x+1) mod M to x:=(x+u) mod M withinthe while loop. The second hash function h2 must be chosen with some care,otherwise the program might not work at all.First, we obviously don™t want to have u=O, since that would lead to aninfinite loop on collision. Second, it is important that M and u be relativelyprime here, since otherwise some of the probe sequences could be very short(for example, consider the case M=2u). This is easily enforced by makingM prime and u<M. Third, the second hash function should be ﬁdifferentﬂfrom the first, otherwise a slightly more complicated clustering could occur.A function such as hz(k) = M - 2 - k mod (M - 2) will produce a good rangeof ﬁsecondﬂ hash values.For our sample keys, we get the following hash values:KeyASEARCHINGEXAMPLEHash1:1051183891475511316125Hash2™:1615121616149831012101641512The following table is produced by successively inserting our sample keysinto an initially empty table using double hashing with these values.
208CHAPTER 160123456789101112131415 16 17 180A0S AS AaIS AS AS AS AS AS A
S AS AsmS AS AS AsB0CCCCCCCCCCC0ClElE0AEAl-4EAREIHIAREHl2-lAREH I0NAR-EIGI H INAR0ETH ImN0AR0EGHIENM AREGHIEm0NX ARclEGHIEAr-lMNX AREGHIEAMNX~AR-EGHIEAMMNXPAR~~G~I~AL~N~PMRThis technique uses the same amount of space as linear probing but theaverage number of items examined for successful search is slightly smaller:32/17 z1.882. Still, such a full table is to be avoided as shown by the 9probes used to insert the last E in this example.Open addressing methods can be inconvenient in a dynamic situation,when an unpredictable number of insertions and deletions might have to beprocessed. First, how big should the table be? Some estimate must be made
of how many insertions are expected but performance degrades drastically as
the table starts to get full. A common solution to this problem is to rehash
everything into a larger table on a (very) infrequent basis. Second, a word of
caution is necessary about deletion: a record can™t simply be removed froma table built with linear probing or double hashing. The reason is that laterinsertions into the table might have skipped over that record, and searchesfor those records will terminate at the hole left by the deleted record. A
way to solve this problem is to have another special key which can serve
as a placeholder for searches but can be identified and remembered as an
HASHING209empty position for insertions. Note that neither table size nor deletion are aparticular problem with separate chaining.Analytic ResultsThe methods discussed above have been analyzed completely and it is pos-sible to compare their performance in some detail. The following formulas,summarized from detailed analyses described by D. E. Knuth in his book onsorting and searching, give the average number of items examined (probes) forunsuccessful and successful searching using the methods we™ve studied. Theformulas are most conveniently expressed in terms of the ﬁload factorﬂ of thehash table, cr = N/M. Note that for separate chaining we can have CY > 1,but for the other methods we must have Q < 1.UnsuccessfulSuccessfulSeparate Chaining:1+ 42(a + 1)/ZLinear Probing:l/2+1/2(1-42 1/2+1/2(1-a)Double Hashing:l/(1 - a)- ln( 1 - o)/oFor small o, it turns out that all the formulas reduce to the basic result thatunsuccessful search takes about 1 + N/M probes and successful search takesabout 1 + N/2M probes. (Except, as we™ve noted, the cost of an unsuccessfulsearch for separate chaining is reduced by about half by ordering the lists.)The formulas indicate how badly performance degrades for open addressing
as CY gets close to 1. For large M and N, with a table about 90% full, linearprobing will take about 50 probes for an unsuccessful search, compared to10 for double hashing. Comparing linear probing and double hashing againstseparate chaining is more complicated, because there is more memory availablein the open addressing methods (since there are no links). The value of CY usedshould be modified to take this into account, based on the relative size of keysand links. This means that it is not normally justified to choose separatechaining over double hashing on the basis of performance.The choice of the very best hashing method for a particular applica-tion can be very difficult. However, the very best method is rarely neededfor a given situation, and the various methods do have similar performancecharacteristics as long as the memory resource is not being severely strained.Generally, the best course of action is to use the simple separate chainingmethod to reduce search times drastically when the number of records to beprocessed is not known in advance (and a good storage allocator is available)and to use double hashing to search among a set of keys whose size can beroughly predicted ahead of time.Many other hashing methods have been developed which have applicationin some special situations. Although we can™t go into details, we™ll briefly
210CHAPTER 16consider two examples to illustrate the nature of specially adapted hashingmethods. These and many other methods are fully described in Knuth™s book.The first, called ordered hashing, is a method for making use of orderingwithin an open addressing table: in standard linear probing, we stop thesearch when we find an empty table position or a record with a key equalto the search key; in ordered hashing, we stop the search when we find arecord with a key greater than or equal to the search key (the table must becleverly constructed to make this work). This method turns out to reducethe time for unsuccessful search to approximately that for successful search.(This is the same kind of improvement that comes in separate chaining.) Thismethod is useful for applications where unsuccessful searching is frequentlyused. For example, a text processing system might have an algorithm forhyphenating words that works well for most words, but not for bizarre cases(such as ﬁbizarreﬂ). The situation could be handled by looking up all words
in a relatively small exception dictionary of words which must be handled ina special way, with most searches likely to be unsuccessful.Similarly, there are methods for moving some records around duringunsuccessful search to make successful searching more efficient. In fact, R. P.Brent developed a method for which the average time for a successful search
can be bounded by a constant, giving a very useful method for applications
with frequent successful searching in very large tables such as dictionaries.These are only two examples of a large number of algorithmic improve-ments which have been suggested for hashing. Many of these improvementsare interesting and have important applications. However, our usual cautionsmust be raised against premature use of advanced methods except by expertswith serious searching applications, because separate chaining and doublehashing are simple, efficient, and quite acceptable for most applications.Hashing is preferred to the binary tree structures of the previous twochapters for many applications because it is somewhat simpler and it canprovide very fast (constant) searching times, if space is available for a large
enough table. Binary tree structures have the advantages that they are
dynamic (no advance information on the number of insertions is needed), they
can provide guaranteed worst-case performance (everything could hash to the
same place even in the best hashing method), and they support a wider range
of operations (most important, the sort function). When these factors are notimportant, hashing is certainly the searching method of choice.0
HASHING211Exercises1.Describe how you might implement a hash function by making use of agood random number generator. Would it make sense to implement arandom number generator by making use of a hash function?2.How long could it take in the worst case to insert N keys into an initiallyempty table, using separate chaining with unordered lists? Answer thesame question for sorted lists.3.Give the contents of the hash table that results when the keys E A S Y QU E S T I 0 N are inserted in that order into an initially empty table of
size 13 using linear probing. (Use hi(k) = kmod 13 for the hash functionfor the lath letter of the alphabet.)4.Give the contents of the hash table that results when the keys E A S YQ U E S T I 0 N are inserted in that order into an initially empty tableof size 13 using double hashing. (Use hi(k) from the previous question,hz(lc) = 1 + (Ic mod 11) for the second hash function.)5. About how many probes are involved when double hashing is used tobuild a table consisting of N equal keys?6.Which hashing method would you use for an application in which manyequal keys are likely to be present?7.Suppose that the number of items to be put into a hash table is knownin advance. Under what condition will separate chaining be preferable to
double hashing?8.Suppose a programmer has a bug in his double hashing code so that oneof the hash functions always returns the same value (not 0). Describewhat happens in each situation (when the first one is wrong and when
the second one is wrong).9.What hash function should be used if it is known in advance that the keyvalues fall into a relatively small range?10.Criticize the following algorithm for deletion from a hash table built withlinear probing. Scan right from the element to be deleted (wrapping asnecessary) to find an empty position, then scan left to find an elementwith the same hash value. Then replace the element to be deleted withthat element, leaving its table position empty.

17. Radix SearchingSeveral searching methods proceed by examining the search keys onebit at a time (rather than using full comparisons between keys at eachstep). These methods, called radix searching methods, work with the bits ofthe keys themselves, as opposed to the transformed version of the keys usedin hashing. As with radix sorting methods, these methods can be useful when
the bits of the search keys are easily accessible and the values of the searchkeys are well distributed.The principal advantages of radix searching methods are that they providereasonable worst-case performance without the complication of balanced trees;they provide an easy way to handle variable-length keys; some allow some sav-
ings in space by storing part of the key within the search structure; and they
can provide very fast access to data, competitive with both binary search trees
and hashing. The disadvantages are that biased data can lead to degeneratetrees with bad performance (and data comprised of characters is biased) andthat some of the methods can make very inefficient use of space. Also, as
with radix sorting, these methods are designed to take advantage of particularcharacteristics of the computer™s architecture: since they use digital propertiesof the keys, it™s difficult or impossible to do efficient implementations in lan-guages such as Pascal.We™ll examine a series of methods, each one correcting a problem inherentin the previous one, culminating in an important method which is quite usefulfor searching applications where very long keys are involved. In addition, we™llsee the analogue to the ﬁlinear-time sortﬂ of Chapter 10, a ﬁconstant-timeﬂ
search which is based on the same principle.Digital Search TreesThe simplest radix search method is digital tree searching: the algorithm isprecisely the same as that for binary tree searching, except that rather than213
214CHAPTER 17branching in the tree based on the result of the comparison between the keys,we branch according to the key™s bits.At the first level the leading bit isused, at the second level the second leading bit, and so on until an externalnode is encountered. The code for this is virtually the same as the codefor binary tree search. The only difference is that the key comparisons arereplaced by calls on the bits function that we used in radix sorting. (Recallfrom Chapter 10 that bits(x, k, j)is the j bits which appear k from the rightand can be efficiently implemented in machine language by shifting right kbits then setting to 0 all but the rightmost j bits.)function digitalsearch(v: integer; x: link) : link;var b: integer;beginzf.key:=v; b:=maxb;repeatif bits(v, b, I)=0 then x:=x1.1 else x:=xt.r;b:=b-1;until v=xt .key;digitalsearch:=xend ;The data structures for this program are the same as those that we used forelementary binary search trees. The constant maxb is the number of bits inthe keys to be sorted. The program assumes that the first bit in each key(the (maxb+l)st from the right) is 0 (perhaps the key is the result of a call tobits with a third argument of maxb), so that searching is done by setting x:=digitalsearch(v, head), where head is a link to a tree header node with 0 keyand a left link pointing to the search tree. Thus the initialization procedurefor this program is the same as for binary tree search, except that we beginwith headf.l:=z instead of headt.r:=z.We saw in Chapter 10 that equal keys are anathema in radix sorting; thesame is true in radix searching, not in this particular algorithm, but in theones that we™ll be examining later. Thus we™ll assume in this chapter that allthe keys to appear in the data structure are distinct: if necessary, a linked listcould be maintained for each key value of the records whose keys have thatvalue. As in previous chapters, we™ll assume that the ith letter of the alphabetis represented by the five-bit binary representation of i. That is, we™ll use thefollowing sample keys in this chapter:
RADLX SEARCHING215ASERCHINGXMPL0000110011
00101100100001101000
01001
011100011111000011011000001100To be consistent with hits, we consider the bits to be numbered O-4, fromright to left. Thus bit 0 is A™s only nonzero bit and bit 4 is P™s only nonzerobit.The insert procedure for digital search trees also derives directly from thecorresponding procedure for binary search trees:function digitaJinsert(v: integer; x: link): link;var f: link; b: integer;beginb:=maxb;repeatf:=x;if bits(v, b, I)=0 then x:=xt.J else x:=xf.r;b:=b-f ;until x=z;new(x); xf.key:=v; xf.J:=z; xt.r:=z;if bits(v, b+l, I)=0 then Q.‚.l:=x else ff.r:=x;digitalinsert: =xend ;To see how the algorithm works, consider what happens when a new key Z=11010 is added to the tree below. We go right twice because the leading two
bits of Z are 1, then we go left, where we hit the external node at the left ofX, where Z would be inserted.
216CRAPTER 17The worst case for trees built with digital searching will be much betterthan for binary search trees. The length of the longest path in a digitalsearch tree is the length of the longest match in the leading bits betweenany two keys in the tree, and this is likely to be relatively short. And it isobvious that no path will ever be any longer than the number of bits in thekeys: for example, a digital search tree built from eight-character keys with,say, six bits per character will have no path longer than 48, even if thereare hundreds of thousands of keys.For random keys, digital search treesare nearly perfectly balanced (the height is about 1gN). Thus, they providean attractive alternative to standard binary search trees, provided that bitextraction can be done as easily as key comparison (which is not really thecase in Pascal).Radix Search TriesIt is quite often the case that search keys are very long, perhaps consisting oftwenty characters or more. In such a situation, the cost of comparing a searchkey for equality with a key from the data structure can be a dominant costwhich cannot be neglected. Digital tree searching uses such a comparison ateach tree node: in this section we™ll see that it is possible to get by with onlyone comparison per search in most cases.The idea is to not store keys in tree nodes at all, but rather to put allthe keys in external nodes of the tree. That is, instead of using a for externalnodes of the structure, we put nodes which contain the search keys. Thus,we have two types of nodes: internal nodes, which just contain links to other
nodes, and external nodes, which contain keys and no links. (E. Fredkin
RADlX SEARCHING217named this method ﬁtrieﬂ because it is useful for retrieval; in conversation it™susually pronounced ﬁtry-eeﬂ or just ﬁtryﬂ for obvious reasons.) To search fora key in such a structure, we just branch according to its bits, as above, but
we don™t compare it to anything until we get to an external node. Each keyin the tree is stored in an external node on the path described by the leadingbit pattern of the key and each search key winds up at one external node, soone full key comparison completes the search.After an unsuccessful search, we can insert the key sought by replacingthe external node which terminated the search by an imternal node whichwill have the key sought and the key which terminated the search in externalnodes below it. Unfortunately, if these keys agree in more bit positions, it is
necessary to add some external nodes which do not correspond to any keysin the tree (or put another way, some internal nodes which have an emptyexternal node as a son). The following is the (binary) radix search trie for our
sample keys:Now inserting Z=llOlO into this tree involves replacing X with a new internalnode whose left son is another new internal node whose sons are X and Z.The implementation of this method in Pascal is actually relatively com-plicated because of the necessity to maintain two types of nodes, both ofwhich could be pointed to by links in internal nodes. This is an example of
an algorithm for which a low-level implementation might be simpler than a
high-level implementation. We™ll omit the code for this because we™ll see an
improvement below which avoids this problem.The left subtree of a binary radix search trie has all the keys which have0 for the leading bit; the right subtree has all the keys which have 1 for the
218CHAPTER 17leading bit. This leads to an immediate correspondence with radix sorting:binary trie searching partitions the file in exactly the same way as radix
exchange sorting. (Compare the trie above with the partitioning diagram we
examined for radix exchange sorting, after noting that the keys are slightly
different.) This correspondence is analogous to that between binary tree
searching and Quicksort.An annoying feature of radix tries is the ﬁone-wayﬂ branching required forkeys with a large number of bits in common, For example, keys which differonly in the last bit require a path whose length is equal to the key length, nomatter how many keys there are in the tree. The number of internal nodes can
be somewhat larger than the number of keys. The height of such trees is still
limited by the number of bits in the keys, but we would like to consider thepossibility of processing records with very long keys (say 1000 bits or more)which perhaps have some uniformity, as might occur in character encodeddata. One way to shorten the paths in the trees is to use many more thantwo links per node (though this exacerbates the ﬁspaceﬂ problem of using toomany nodes); another way is to ﬁcollapseﬂ paths containing one-way branchesinto single links. We™ll discuss these methods in the next two sections.Multiway Radix SearchingFor radix sorting, we found that we could get a significant improvement inspeed by considering more than one bit at a time. The same is true for radixsearching: by examining m bits at a time, we can speed up the search by a
factor of 2m.However, there™s a catch which makes it necessary to be morecareful applying this idea than was necessary for radix sorting. The problemis that considering m bits at a time corresponds to using tree nodes with
M = 2m links, which can lead to a considerable amount of wasted space forunused links. For example, if M = 4 the following tree is formed for oursample keys:HIL MRS
RADLX SEARCHTNGNote that there is some wasted space in this tree because of the large numberof unused external links. As M gets larger, this effect gets worse: it turns outthat the number of links used is about MN/In M for random keys. On theother hand this provides a very efficient searching method: the running timeis about log, N. A reasonable compromise can be struck between the time
efficiency of multiway tries and the space efficiency of other methods by usinga ﬁhybridﬂ method with a large value of M at the top (say the first two levels)and a small value of M (or some elementary method) at the bottom. Again,efficient implementations of such methods can be quite complicated becauseof multiple node types.For example, a two-level 32-way tree will divide the keys into 1024 cate-gories, each accessible in two steps down the tree. This would be quite usefulfor files of thousands of keys, because there are likely to be (only) a few keysper category. On the other hand, a smaller M would be appropriate for filesof hundreds of keys, because otherwise most categories would be empty andtoo much space would be wasted, and a larger M would be appropriate forfiles with millions of keys, because otherwise most categories would have toomany keys and too much time would be wasted.It is amusing to note that ﬁhybridﬂ searching corresponds quite closelyto the way humans search for things, for example, names in a telephonebook. The first step is a multiway decision (ﬁLet™s see, it starts with ‚Aﬂ‚),followed perhaps by some two way decisions (ﬁIt™s before ‚Andrews™, but after‚Aitkenﬂ‚) followed by sequential search (ﬁ ‚Algonquin™ . . . ‚Algren™ . . . No,‚Algorithms™ isn™t listed!ﬁ). Of course computers are likely to be somewhatbetter than humans at multiway search, so two levels are appropriate. Also,26-way branching (with even more levels) is a quite reasonable alternativeto consider for keys which are composed simply of letters (for example, in a
dictionary).In the next chapter, we™ll see a systematic way to adapt the structure totake advantage of multiway radix searching for arbitrary file sizes.PatriciaThe radix trie searching method as outlined above has two annoying flaws:there is ﬁone-way branchingﬂ which leads to the creation of extra nodes in thetree, and there are two different types of nodes in the tree, which complicatesthe code somewhat (especially the insertion code). D. R. Morrison discovereda way to avoid both of these problems in a method which he named Patricia(ﬁPractical Algorithm To Retrieve Information Coded In Alphanumericﬂ).The algorithm given below is not in precisely the same form as presented
by Morrison, because he was interested in ﬁstring searchingﬂ applications of
the type that we™ll see in Chapter 19. In the present context, Patricia allows
220CHAPTER 17searching for N arbitrarily long keys in a tree with just N nodes, but requiresonly one full key comparison per search.One-way branching is avoided by a simple device: each node containsthe index of the bit to be tested to decide which path to take out of thatnode. External nodes are avoided by replacing links to external nodes withlinks that point upwards in the tree, back to our normal type of tree nodewith a key and two links. But in Patricia, the keys in the nodes are notused on the way down the tree to control the search; they are merely stored
there for reference when the bottom of the tree is reached. To see how Patricaworks, we™ll first look at the search algorithm operating on a typical tree, thenwe™ll examine how the tree is constructed in the first place. For our examplekeys, the following Patricia tree is constructed when the keys are successivelyinserted.To search in this tree, we start at the root and proceed down the tree, usingthe bit index in each node to tell us which bit to examine in the search key,going right if that bit is 1, left if it is 0. The keys in the nodes are not
examined at all on the way down the tree. Eventually, an upwards link isencountered: each upward link points to the unique key in the tree that hasthe bits that would cause a search to take that link. For example, S is theonly key in the tree that matches the bit pattern 10x11. Thus if the key at
the node pointed to by the first upward link encountered is equal to the search
key, then the search is successful, otherwise it is unsuccessful. For tries, all
searches terminate at external nodes, whereupon one full key comparison is
done to determine whether the search was successful or not; for Patricia allsearches terminate at upwards links, whereupon one full key comparison isdone to determine whether the search was successful or not. Futhermore, it™seasy to test whether a link points up, because the bit indices in the nodes (by
RADLX SEARCHING221definition) decrease as we travel down the tree. This leads to the followingsearch code for Patricia, which is as simple as the code for radix tree or triesearching:type link=fnode;node=record key, info, b: integer; 1, r: link end;var head: link;function patriciasearch(v: integer; x: link): link;var f: link;beginrepeatf:=x;if bits(v, xf.b, I)=0 then x:=xf.l else x:=xf.r;until f‚r.b<=xt.b;patriciasearch :=xend ;This function returns a link to the unique node which could contain the recordwith key v. The calling routine then can t 3st whether the search was successfulor not. Thus to search for Z=llOlO in tie above tree we go right, then up atthe right link of X. The key there is not Z so the search is unsuccessful.The following diagram shows the ,ransformations made on the rightsubtree of the tree above if Z, then T art added.X37!!ic?)Pz11R0--e-&The search for Z=llOlO ends at the node c:ontaining X=11000. By the definingproperty of the tree, X is the only key i-1 the tree for which a search wouldterminate at that node. If Z is inserted, there would be two such nodes, sothe upward link that was followed into the node containing X should be madeto point to a new node containing Z, with a bit index corresponding to theleftmost point where X and Z differ, and with two upward links: one pointingto X and the other pointing to Z. This corresponds precisely to replacing the
222CHAPTER 17external node containing X with a new internal node with X and Z as sons inradix trie insertion, with one-way branching eliminated by including the bitindex.The insertion of T=lOlOO illustrates a more complicated case. The searchfor T ends at P=lOOOO, indicating that P is the only key in the tree with thepattern 10x0x. Now, T and P differ at bit 2, a position that was skippedduring the search. The requirement that the bit indices decrease as we godown the tree dictates that T be inserted between X and P, with an upward
self pointer corresponding to its own bit 2. Note carefully that the fact that
bit 2 was skipped before the insertion of T implies that P and R have the
same bit 2 value.The examples above illustrate the only two cases that arise in insertionfor Patricia. The following implementation gives the details:function patriciainsert(v: integer; x: link): link;var t,f: link; i: integer;begint :=patriciasearch (v,x) ;i:=maxb;while bits(v, i, I)=bits(tt.key, i, 1) do i:=i-I;repeatf:=x;if bits(v, xf.b, I)=0 theu x:=xf.l else x:=xt.r;until (xT.b<=i) or (Q.b<=xt.b);new(t); tf.key:=v; tf.b:=i;if bits(v, tf.b, I)=0then begin tt.l:=t; tt.r:=x endelse begin tf.r:=t; tf.l:=x end;if bits(v, Q.b, I)=0 then ft.l:=t else ff.r:=t;patriciainsert := tend ;(This code assumes that head is initialized with key field of 0, a bit index ofmaxb and both links upward self pointers.) First, we do a search to find the
key which must be distinguished from v, then we determine the leftmost bit
position at which they differ, travel down the tree to that point, and insert a
new node containing v at that point.Patricia is the quintessential radix searching method: it manages toidentify the bits which distinguish the search keys and build them into adata structure (with no surplus nodes) that quickly leads from any searchkey to the only key in the data structure that could be equal. Clearly, the
RADlX SEARCHING223same technique as used in Patricia can be used in binary radix trie searchingto eliminate one-way branching, but this only exacerbates the multiple nodetype problem.Unlike standard binary tree search, the radix methods are insensitive tothe order in which keys are inserted; thtty depend only upon the structure ofthe keys themselves. For Patricia the pl,icement of the upwards links dependon the order of insertion, but the tree structure depends only on the bits inthe keys, as for the other methods. This, even Patricia would have troublewith a set of keys like 001, 0001, 00001, 300001, etc., but for normal key sets,the tree should be relatively well-balanced so the number of bit inspections,even for very long keys, will be roughly proportional to 1gN when there areN nodes in the tree.The most useful feature of radix trie searching is that it can be doneefficiently with keys of varying length. In all of the other searching methodswe have seen the length of the key is ﬁbuilt intoﬂ the searching procedure insome way, so that the running time is dependent on the length of the keysas well as the number of keys. The spetific savings available depends on themethod of bit access used. For example, suppose we have a computer whichcan efficiently access g-bit ﬁbytesﬂ of tlata, and we have to search amonghundreds of lOOO-bit keys. Then Patricia would require access of only about9 or 10 bytes of the search key for thl: search, plus one 125-byte equalitycomparison while hashing requires accest of all 125-bytes of the search key forcomputing the hash function plus a few elluality comparisons, and comparison-based methods require several long comparisons. This effect makes Patricia(or radix trie searching with one-way branching removed) the search method
of choice when very long keys are involved.
224Exercises1.2.3.4.5.6.7.
8.9.10.Draw the digital search tree that results when the keys E A S Y Q U ES T I 0 N are inserted into an initially empty tree (in that order).Generate a 1000 node digital search tree and compare its height and thenumber of nodes at each level against a standard binary search tree anda red-black tree (Chapter 15) built from the same keys.Find a set of 12 keys that make a particulary badly balanced digitalsearch trie.Draw the radix search trie that results when the keys E A S Y Q U E ST I 0 N are inserted into an initially empty tree (in that order).A problem with 26-way multiway radix search tries is that some lettersof the alphabet are very infrequently used. Suggest a way to fix thisproblem.Describe how you would delete an element from a multiway radix searchtree.Draw the Patricia tree that results when the keys E A S Y Q U E S T I0 N are inserted into an initially empty tree (in that order).Find a set of 12 keys that make a particulary badly balanced Patriciatree.Write a program that prints out all keys in a Patricia tree having thesame initial t bits as a given search key.Use a least-squares curvefitter to find values of a and b that give the bestformula of the form UN 1gN + bN for describing the total number ofinstructions executed when a Patricia tree is built from N random keys.
18. External SearchingSearching algorithms appropriate for accessing items from very largefiles are of immense practical impcrtance. Searching is the fundamentaloperation on large data files, and certainly consumes a very significant fractionof the resources used in many computer installations.We™ll be concerned mainly with met hods for searching on large disk files,since disk searching is of the most practical interest. With sequential devicessuch as tapes, searching quickly degenel.ates to the trivially slow method: tosearch a tape for an item, one can™t do much better than to mount the tapeand read until the item is found. Remarkably, the methods that we™ll studycan find an item from a disk as large as ;L billion words with only two or threedisk accesses.As with external sorting, the ﬁsystemsﬂ aspect of using complex I/Ohardware is a primary factor in the perfo.mance of external searching methodsthat we won™t be able to study in detai:. However, unlike sorting, where theexternal methods are really quite differer.t from the internal methods, we™ll seethat external searching methods are 1ogil:al extensions of the internal methodsthat we™ve studied.Searching is a fundamental operaticIn for disk devices. Files are typicallyorganized to take advantage of particular. device characteristics to make accessof information as efficient as possible. A3 we did with sorting, we™ll work witha rather simple and imprecise model of ‚diskﬂ devices in order to explain theprincipal characteristics of the fundamental methods. Determining the bestexternal searching method for a particlllar application is extremely compli-cated and very dependent on characteristics of the hardware (and systemssoftware), and so it is quite beyond the scope of this book. However, we cansuggest some general approaches to use.For many applications we would like to frequently change, add, deleteor (most important) quickly access small bits of information inside very, very225
CHAPTER 18large files. In this chapter, we™ll examine some methods for such dynamicsituations which offer the same kinds of advantages over the straightforwardmethods that binary search trees and hashing offer over binary search andsequential search.A very large collection of information to be processed using a computeris called a database. A great deal of study has gone into methods of building,maintaining and using databases.However, large databases have very highinertia: once a very large database has been built around a particular searchingstrategy, it can be very expensive to rebuild it around another. For this reason,the older, static methods are in widespread use and likely to remain so, thoughthe newer, dynamic methods are beginning to be used for new databases.Database applications systems typically support much more complicatedoperations than a simple search for an item based on a single key. Searchesare often based on criteria involving more than one key and are expected to
return a large number of records. In later chapters we™ll see some examplesof algorithms which are appropriate for some search requests of this type,but general search requests are sufficiently complicated that it is typical to doa sequential search over the entire database, testing each record to see if it
meets the criteria.The methods that we will discuss are of practical importance in the im-plementation of large file systems in which every file has a unique identifierand the purpose of the file system is to support efficient access, insertion anddeletion based on that identifier. Our model will consider the disk storageto be divided up into pages, contiguous blocks of information that can beefficiently accessed by the disk hardware. Each page will hold many records;
our task is to organize the records within the pages in such a way that any
record can be accessed by reading only a few pages. We assume that theI/O time required to read a page completely dominates the processing timerequired to do any computing involving that page. As mentioned above, thisis an oversimplified model for many reasons, but it retains enough charac-teristics of actual external storage devices to allow us to consider some of thefundamental methods which are used.Indexed Sequential AccessSequential disk searching is the natural extension of the elementary sequentialsearching methods that we considered in Chapter 14: the records are storedin increasing order of their keys, and searches are done by simply readingin the records one after the other until one containing a key greater than orequal to the search key is found. For example, if our search keys come fromE X T E R N A L S E A R C H I N G E X A M P L E and we have diskscapable of holding three pages of four records each, then we would have theconfiguration:
EXTERNAL SEARCHING227Diskl. A A A CE E E EEGHIDisk Z?: L L M NNPRRSTXXAs with external sorting, we must consider very small examples to under-stand the algorithms but think about ve y large examples to appreciate theirperformance. Obviously, pure sequentizl searching is unattractive because,for example, searching for W in the exainple above would require reading allthe pages.To vastly improve the speed of a search, we can keep, for each disk, anﬁindexﬂ of which keys belong to which pages on that disk, as in the followingexample:Disk 1:*lc2eAAACEEEEDisk ,Z:eli2nEGHILLMNDisk3: nlr2xNPRRS T X XThe first page of each disk is its index: lower case letters indicate thatonly the key value is stored, not the full record; numbers are page indices.In the index, each page number is folloTved by the value of its last key andpreceded by the value of the last key on the previous page. (The ﬁ*ﬂ is asentinel key, smaller than all the others.) Thus, for example, the index fordisk 2 says that its first page contains records with keys between E and Iinclusive and its second page contains records with keys between I and Ninclusive. Normally, it should be possil)le to fit many more keys and pageindices on an index page than records on a ﬁdataﬂ page; in fact, the index fora whole disk should require only a few pages. These indices are coupled with
a ﬁmaster indexﬂ which tells which keys are on which disk. For our example,
the master index would be U*1 e 2 n 3 x,ﬂ where boldface integers are disknumbers. The master index is likely to be small enough that it can be keptin memory, so that most records can be found with only two pages accessed,one for the index on the appropriate disl. and one for the page containing theapproriate record. For example, a searc.h for W would involve first readingthe index page from disk 3, then reading the second page (from disk 3) whichis the only one that could contain W. Sc:arches for keys which appear in theindex require reading three pages the irdex plus the two pages flanking thekey value in the index. If no duplicate keys are in the file, then the extra pageaccess can be avoided. On the other hansl, if there are many equal keys in the
228CHAPTER 18file, several page accesses might be called for (records with equal keys mightfill several pages).Because it combines a sequential key organization with indexed access,this organization is called indexed sequential. It is the method of choice forapplications where changes to the database are likely to be made infrequently.The disadvantage of using indexed sequential access is that it is very inflexible.For example, adding B to the configuration above requires that virtually thewhole database be rebuilt, with new positions for many of the keys and new
values for the indices.B-TreesA better way to handle searching in a dynamic situation is to use balancedtrees. In order to reduce the number of (relatively expensive) disk accesses, itis reasonable to allow a large number of keys per node so that the nodes have
a large branching factor. Such trees were named B-trees by R. Bayer and
E. McCreight, who were the first to consider the use of multiway balancedtrees for external searching. (Many people reserve the term ﬁB-treeﬂ todescribe the exact data structure built by the algorithm suggested by Bayer
and McCreight; we™ll use it as a generic term to mean ﬁexternal balancedtrees.ﬁ)The top-down algorithm that we used for 2-3-4 trees extends readily tohandle more keys per node: assume that there are anywhere from 1 to M - 1keys per node (and so anywhere from 2 to M links per node). Searchingproceeds in a way analogous to 2-3-4 trees: to move from one node to thenext, first find the proper interval for the search key in the current node and
then exit through the corresponding link to get to the next node. Continue
in this way until an external node is reached, then insert the new key intothe last internal node reached. As with top-down 2-3-4 trees, it is necessaryto ﬁsplitﬂ nodes that are ﬁfullﬂ on the way down the tree: any time we see
a k-node attached to an M node, we replace it by a (k + 1)-node attachedto two M/2 nodes. This guarantees that when the bottom is reached thereis room to insert the new node. The B-tree constructed for M = 4 and oursample keys is diagrammed below:
EXTERNAL SEARCHING229This tree has 13 nodes, each corresponding to a disk page. Each node mustcontain links as well as records. The choice M = 4 (even though it leaves uswith familiar 2-3-4 trees) is meant to emphasize this point: before we couldfit four records per page, now only three! will fit, to leave room for the links.The actual amount of space used up depends on the relative size of recordsand links. We™ll see a method below wh ch avoids this mixing of records andlinks.For example, the root node might bl: stored as ﬁ10 E 11 N 12ﬂ, indicatingthat the root of the subtree containing records with keys less than or equalto E is on page 0 of disk 1, etc. Just as ‚ve kept the master index for indexedsequential search in memory, it™s reasonable to keep the root node of the B-tree in memory. The other nodes for ou:™ example might be stored as follows:Disk1:20 A 2122 E 30H31L3240 R 41 T 42Disk,!?: OAOOAOCOEO OEODisk3:0 E 0 GO0 I 0OLOMODisk4 :ONOPOROOS00X0X0The assignment of nodes to disk pages in this example is simply to proceeddown the tree, working from right to l& at each level, assigning nodes todisk 1, then disk 2, etc. In an actual ihpplication, other assignments mightbe indicated. For example, it might bt: better to avoid having all searchesgoing through disk 1 by assigning first to page 0 of all the disks, etc. Intruth, more sophisticated strategies are needed because of the dynamics of
the tree construction (consider the diffic:ulty of implementing a split routinethat respects either of the above strategies).The nodes at the bottom level in t1 e B-trees described above all containmany 0 links which can be eliminated 1)~ marking such nodes in some way.Furthermore, a much larger value of M 1:an be used at the higher levels of thetree if we store just keys (not full records) in the interior nodes as in indexedsequential access. To see how to take aclvantage of these observations in ourexample, suppose that we can fit up to seven keys and eight links on a page, sothat we can use M = 8 for the interior rodes and M = 5 for the bottom-levelnodes (not M = 4 because no space for 1 nks need be reserved at the bottom).A bottom node splits when a fifth record is added to it; the split involvesﬁinsertingﬂ the key of the middle recortl into the tree above, which operatesas a normal B-tree from M = 8 (on stored keys, not records). This leads tothe following tree:
230CHAPTER 18The effect for a typical application is likely to be much more dramatic sincethe branching factor of the tree is increased by roughly the ratio of the recordsize to key size, which is likely to be large. Also, with this type of organization,the ﬁindexﬂ (which contains keys and links) can be separated from the actualrecords, as in indexed sequential search:Diskl: 11 11220 a 21 e 22 e 30 h 3132 n 40 r 41 s 42Disk R: A AA C EE EDisk 3: E E GH IL L MDisk4: N N PR RST X XAs before, the root node is kept in memory. Also the same issues as discussedabove regarding node placement on the disks arise.Now we have two values of M, one for the interior nodes which determinesthe branching factor of the tree (MI) and one for the bottom-level nodes whichdetermines the allocation of records to pages (MB). To minimize the numberof disk accesses, we want to make both MI and MB as large as possible, evenat the expense of some extra computation. On the other hand, we don™t wantto make MI huge, because then most tree nodes would be largely empty andspace would be wasted and we don™t want to make MB huge because thiswould reduce to sequential search of the bottom-level nodes. Usually, it isbest to relate both MI and MB to the page size. The obvious choice for MBis the number of records that can fit on a page: the goal of the search is tofind the page containing the record sought. If MI is taken to be the numberof keys that can fit on two to four pages, then the B-tree is likely to be only bethree levels deep, even for very large files (a three-level tree with MI = 1024can handle up to 10243, or over a billion, entries). But recall that the rootnode of the tree, which is accessed for every operation on the tree, is kept inmemory, so that only two disk accesses are required to find any element in
the file.As discussed in Chapter 15, a more complicated ﬁbottom-upﬂ insertionmethod is commonly used for B-trees, though the distinction between top-
EXTERNAL. SEARCHING231down and bottom up methods loses iml)ortance for three level trees. Othervariations of balanced trees are more iriportant for external searching. Forexample, when a node becomes full, sp itting (and the resultant half-emptynodes) can be forestalled by dumping some of the contents of the node into
its ﬁbrotherﬂ node (if it™s not too full). This leads to better space utilizationwithin the nodes, which is likely to be o ™ central concern in a large-scale disksearching application.Extendible HashingAn alternative to B-trees which extends digital searching algorithms to applyto external searching was developed in 1978 by R. Fagin, J. Nievergelt, N.Pippenger, and R. Strong. This method, called extendible hashing, guaranteesthat no more than two disk accesses will be used for any search. As with Etrees, our records are stored on pages which are split into two pieces whenthey fill up; as with indexed sequential access, we maintain an index which
we access to find the page containing the records which match our search key.
Extendible hashing combines these approaches by using digital properties ofthe search keys.To see how extendible hashing worlcs, we™ll consider how it handles suc-cessive insertions of keys from E X T E R N A L S E A R C H I N G E X AM P L E, using pages with a capacity o * up to four records.We start with an ﬁindexﬂ with just one entry, a pointer to the pagewhich is to hold the records. The first four records fit on the page, leavingthe following trivial structure:Disk 1: ; 0Disk 2:ZETXThe directory on disk 1 says that all records are on page 0 of disk 2, wherethey are kept in sorted order of their keys. For reference, we also give thebinary value of the keys, using our standard encoding of the five-bit binaryrepresentation of i for the ith letter of the alphabet. Now the page is full,
and must be split in order to add the ks:y R=lOOlO. The strategy is simple:put records with keys that begin with 0 on one page and records with keysthat begin with 1 on another page. Thi: necessitates doubling the size of thedirectory, and moving half the keys from page 0 of disk 2 to a new page,leaving the following structure:
232CHAPTER 180: I$101 E0101 E1:4 10010 RDisk1:202110100 TDisk Z?: E ERTX111000 xNow N=OlllO and A=00001 can be added, but another split is neededbefore L=OllOO can be added:0:0001 A0101 EDisk 1: 20 21Disk2:AEEN RTX10100 T11000 xRecall our basic assumption that we do disk I/O in page units, and thatprocessing time is negligible compared to the time to input or output a page.
Thus, keeping the records in sorted order of their keys is not a real expense:
to add a record to a page, we must read the page into memory, modify it,
and write it back out. The extra time required to insert the new record to
maintain sorted order is not likely to be noticable in the typical case whenthe pages are small.Proceeding in the same way, as for the first split, we make room for L=01100 by splitting the first page into two pieces, one for keys that begin with 00and one for keys that begin with 01. What™s not immediately clear is what todo with the directory. One alternative would be to simply add another entry,one pointer to each page. This is unattractive because it essentially reduces
to indexed sequential search (albeit a radix version): the directory has to be
scanned sequentially to find the proper page during a search. Alternatively,
we can just double the size of the directory again, giving the structure:00: 0 001 A0 101 E0 101 E01: 01110 LiDiskI:01110 NDisk,!?: A E ELNRTX10: 1 010 R11: 1 100 T11000 xNow we can access any record by using the first two bits of its key to accessdirectly the directory entry that contains the address of the page containing
EXTERNAL SEARCHING233the record.Continuing a little further, we call add S=lOOll and E=OOlOl beforeanother split is necessary to add A=OOOOl. This split also requires doublingthe directory, leaving the structure:Diskl: 2021222230303030Disk 2: A AEEE LNDisk3: R S T XIn general, the structure built by exl endible hashing consists of a directoryof 2d words (one for each d-bit pattern) and a set of leaf pages which containall records with keys beginning with a specific bit pattern (of less than orequal to d bits). A search entails using ,he leading d bits of the key to indexinto the directory, which contains pointc:rs to 1ea.f pages. Then the referencedleaf page is accessed and searched (usin:; any strategy) for the proper record.A leaf page can be pointed to by more tlian one directory entry: to be precise,if a leaf page contains all the records uith keys that begin with a specific kbits (those marked with a vertical line in the pages on the diagram above),then it will have 2d-k directory entries pointing to it. In the example above,we have d = 3, and page 0 of disk 3 contains all the records with keys thatbegin with a 1 bit, so there are four dirl:ctory entries pointing to it.The directory contains only pointc:rs to pages. These are likely to besmaller than keys or records, so more directory entries will fit on each page.For our example, we™ll assume that we can fit twice as many directory entriesas records per page, though this ratio is likely to be much higher in practice.When the directory spans more than one page, we keep a ﬁroot nodeﬂ inmemory which tells where the directoTT pages are, using the same indexingscheme. For example, if the directory spans two pages, the root node mightcontain the two entries ﬁ10 11,ﬂ indicatir g that the directory for all the recordswith keys beginning with 0 are on page 0 of disk 1, and the directory for allkeys beginning with 1 are on page 1 o‚ disk 1. For our example, this splitoccurs when the E is inserted. Continuing up until the last E (see below), weget the following disk storage structure:
234CHAPTER 18Disk1:20202122303031324040414142424242Disk Z?: A A A CEEEE GDisk3: H ILLMNNDisk4:PRR S TxxAs illustrated in the above example, insertion into an extendible hashingstructure can involve one of three operations, after the leaf page which couldcontain the search key is accessed. If there™s room in the leaf page, the new
record is simply inserted there; otherwise the leaf page is split in two (half the
records are moved to a new page). If the directory has more than one entry
pointing to that leaf page, then the directory entries can be split as the page
is. If not, the size of the directory must be doubled.As described so far, this algorithm is very susceptible to a bad inputkey distribution: the value of d is the largest number of bits required toseparate the keys into sets small enough to fit on leaf pages, and thus ifa large number of keys agree in a large number of leading bits, then the
directory could get unacceptably large.For actual large-scale applications,this problem can be headed off by hashing the keys to make the leadingbits (pseudo-)random.To search for a record, we hash its key to get a bitsequence which we use to access the directory, which tells us which page tosearch for a record with the same key.From a hashing standpoint, we canthink of the algorithm as splitting nodes to take care of hash value collisions:hence the name ﬁextendible hashing.ﬂThis method presents a very attractivealternative to B-trees and indexed sequential access because it always usesexactly two disk accesses for each search (like indexed sequential), while still
retaining the capability for efficient insertion (like B-trees).Even with hashing, extraordinary steps must be taken if large numbersof equal keys are present. They can make the directory artificially large; andthe algorithm breaks down entirely if there are more equal keys than fit in
one leaf page. (This actually occurs in our example, since we have five E™s,.) Ifmany equal keys are present then we could (for example) assume distinct keysin the data structure and put pointers to linked lists of records containing
equal keys in the leaf pages. To see the complication involved, consider theinsertion of the last E into the structure above.Virtual MemoryThe ﬁeasier wayﬂ discussed at the end of Chapter 13 for external sortingapplies directly and trivially to the searching problem. A virtual memoryis actually nothing more than a general-purpose external searching method:given an address (key), return the information associated with that address.
EXTERNAL. SEARCHING235However, direct use of the virtual men ory is not recommended as an easysearching application. As mentioned in Chapter 13, virtual memories performbest when most accesses are relatively close to previous accesses. Sorting
algorithms can be adapted to this, but the very nature of searching is that
requests are for information from arbitr n-y parts of the database.
236Exercises1.Give the contents of the B-tree that results when the keys E A S Y Q UE S T I 0 N are inserted in that order into an initially empty tree, withM = 5.2.Give the contents of the B-tree that results when the keys E A S Y Q UE S T I 0 N are inserted in that order into an initially empty tree, withM = 6, using the variant of the method where all the records are kept inexternal nodes.3.Draw the B-tree that is built when sixteen equal keys are inserted into aninitially empty tree, with M = 5.4.Suppose that one page from the database is destroyed. Describe how youwould handle this event for each of the B-tree structures described in thetext.5.Give the contents of the extendible hashing table that results when thekeys E A S Y Q U E S T I 0 N are inserted in that order into an initiallyempty table, with a page capacity of four records. (Following the example
in the text, don™t hash, but use the five-bit binary representation of i as
the key for the ith letter.)6.Give a sequence of as few distinct keys as possible which make an exten-dible hashing directory grow to size 16, from an initially empty table,with a page capacity of three records.7.Outline a method for deleting an item from an extendible hashing table.8.Why are ﬁtop-downﬂ B-trees better than ﬁbottom-upﬂ B-trees for concur-rent access to data? (For example, suppose two programs are trying to
insert a new node at the same time.)9. Implement search and insert for internal searching using the extendiblehashing method.10.Discuss how the program of the previous exercise compares with doublehashing and radix trie searching for internal searching applications.
237SOURCES for SearchingAgain, the primary reference for this section is Knuth™s volume three.Most of the algorithms that we™ve st ldied are treated in great detail inthat book, including mathematical analyses and suggestions for practicalapplications.The material in Chapter 15 come:, from Guibas and Sedgewick™s 1978paper, which shows how to fit many classical balanced tree algorithms intothe ﬁred-blackﬂ framework, and which gives several other implementations.There is actually quite a large literature on balanced trees. Comer™s 1979survey gives many references on the subject of Btrees.The extendible hashing algorithm presented in Chapter 18 comes fromFagin, Nievergelt, Pippenger and Stron;‚s 1979 paper. This paper is a mustfor anyone wishing further information In external searching methods: it tiestogether material from our Chapters 16 and 17 to bring out the algorithm inChapter 18.Trees and binary trees as purely mltthematical objects have been studiedextensively, quite apart from computer science. A great deal is known aboutthe combinatorial properties of these objects. A reader interested in studyingthis type of material might begin with Icnuth™s volume 1.Many practical applications of thl: methods discussed here, especiallyChapter 18, arise within the context of slatabase systems. An introduction tothis field is given in Ullman™s 1980 book.D. Comer, ﬁThe ubquitous &tree,ﬂ Colrlputing Surveys, 11 (1979).R. Fagin, J. Nievergelt, N. Pippenger aIld H. R. Strong, ﬁExtendible Hashing- a fast access method for dynamic fi.es,ﬂ ACM transactions on DatabaseSystems, 4, 3 (September, 1979).L. Guibas and R. Sedgewick, ﬁA dichromatic framework for balanced trees,ﬂin 19th Annual Sym.posium on Foundations of Computer Science, IEEE, 1978.Also in A Decade of Progress 1970-19811, Xerox PARC, Palo Alto, CA.D. E. Knuth, The Art of Computer Pr ,gramming. Volume 1: FundamentalAlgorithms, Addison-Wesley, Reading, IAA, 1968.D. E. Knuth, The Art of Computer PI.ogramming. Volume 3: Sorting andSearching, Addison-Wesley, Reading, MA, second printing, 1975.J. D. Ullman, Principles of Database Sy: terns, Computer Science Press, Rock-ville, MD, 1982.

. . . . . . . . . . . . . . .. .. . . . . . .. . . : . . . . . . . .:i:.:. . . . . :- :..: .:.. *::.:.::.. ..:.™ : .:ﬂ- . . .. . . . . . . :. . . . .. . . .. . . . . . . . .*.. . . - **--. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .. . . . . . . .. . . . . . .. . . . . . . . .. . . .. . . . . . . . .. . . . . . . . . .. . . ... . . .. . . . . . . . .. . ... .. .. .. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .. . . . . . . . i..::. . .-. :...-. . . .: ..:::. . . .:.::.: .:. . . . .. . :. . .. . ... . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ..~........................ . . . . . . . . . . . . . . . .. . . .. . . . . .... ... .. . . . . . . . . . . . . . . . . . . . . . . . . . . .. .: . . . . .. . . . . . . .. . . . . . . .. .. . . . . . . . . . . .. . . :.:. . . . . .i::...:..:. I:.:™ :.:.:..:;. . * :. :-: - ::= . . .. .i:- .: . *. . .:..:...:...:............::.......:.....::...::.~:.:..:.*...:...:...:...:~..::.:::.. . . . . . . . . . . . . . .. . . ... . . . . . . . . . . . . . . . . . . . . . . . . .. . . .. .. . . ... . . . .. .. .. . .. . . . . . . . . . . . .. . . . . .. . . . .. . . .. . . . . . . . :. . . . . . . . . . ...:: .:.* :*‚:. . . . .. .... . . . . .:: .i: - .:*.:.: .. . .* .: . : ﬁ:. . . . . . ...* . :. ..i™: :. . . . . . ..:.:.........:..:.:..........:.:......:....::.:..:.....:.....::....::::..*.:.,:..:. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .. . ... ..*....... . . . . . . . . . . . . . . . .. .. . . . . . .. .. . .. ..n.. . . .. . .. . . . . . . . . . . ..,. . . . . .: . .I.: : :.:.: .:... .:.. :™. -.: :.. ..:. .::. . :. -. . :. . . :.:.:. . . . . . . . . . .. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*. . .. . . . . . . . . . . . .. . . . . . . . . . . . . . . . . . . . . ,.......................... . . .-:.::.:. .:: . ...: .* :. ....: ;::... ..:. :.:. . . . . . . . . . . . .. . . . . . .:. . . . * . . . . . . . ... . . .. * . ..:*:..*:. . :™ . :. . . .. . . .. . ... . . . . . . .. . .. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ..~. . . . . .. . . . . . . . . . . . . . . .. . . . . .. . . . .. . . . . . . . . . . . . . . . . . . . . . . .. .. ... . . . . . . . . ... . . . . .. . . . . . . . . . . ,. . . :. . . .. . . . . . . ...::. .‚... : -. :i™ - :: .-.:.:. :: . . . . .. .. . . . . .. .. . . .. . . --:: . ..i.. .: -:.:....:..:.:..::...:.:.....................~..:....:.::.:.::.....~.:...:.......:.:..*.. . . . .. . . . . ....I.. . . . . .. . . .. . .. . . . . . . . . . . . . . . . . . . . . . . . . . . . ... . . . . ..,. . .. .::.: . : -*. .‚.:..™. . . . . ... . ...*.... . ::: :...: : . -..:, :. : . . . . . . . .; . ..::.. :. . : 1.: .::I. :.:. : . . . . .. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .,.I.. . . .... . . . . .. .. . . . . . . .. . . . . . . . . . . . . . . . . .. . .. . . . . . . . . . . . .. . . . . .. . .. . . . . . . . . . . . . . . . .. . . . . . . . ... . . . .. . . . .. . . . ..i. : :.- ‚.: I ‚:::..: ::: .. . ::. . . : * . ::**:.. . ::::.. -. ::... . .. . . .. . . . . . ..:..........::....:....:::.....:::....:.:.........~..........:.....:...:....:....:. . .. . . . . . . . . . . . . .. . . . . . . .. . . . ..I... .. . . . . . .. .. . . . . .. .. . . . . . . . . . . . .. . . . . . .. . . . . .. . ..:- *. . :::* ﬁ‚: . ...*-.: :*.: :. : .:* ‚: .:: . :‚.:::. .. . . . . .-.*.-. .:- ::ﬁ‚..:™. . . . ... . : . . . . .. . . . .. ..:..:.:.:........::::..........:...:.:....::::.:..:.:.:.....:.:::::..:.:....::..... . . . . . . . ... . . . . . . . . . . . .. . .. . . . . . . . . .. . . . . . . . .. . . . ...ﬁ.. . . . .. .. . . .. .. . ..,.ﬁ, .*. . . .:.* : ..:. :.: ..:... . . . . . .. . . . **..* . :. . .:. . . . .. . .:... . . . . . . . . .: *:.: . . :. . 1.. . .:. *..*. . . . . ..‚*I .. . . . . .. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .. . . . .. . . . . .. . .. . . . . . . . . . .. . . . . . . . . . . . . . . . . .*............ . . . . .. . . . . . . . ... . . . . .. . .. . . . . . . . . .*.. -: .: -: . . . . . . .. . .. .. . . .*. . ::.:.:.:..:.. . . 1: ‚:: :. . . .* :. . . . .. . . . . . .:*. . . . . . ..:*. . .. . . . . . . .. . . . . .::...:.....:......:...:.:......:.......::.:.....:.,........:.:.....:...:.:.:.::.... . .. . ..r. . . . . . . . .. . . . . .. . .. . .. . ... . . . . . . . . . . . . . . .. .. . . . . .. . .. . . . . . .. . ... ‚.:. . . . . .. . . . . .. . . . . . . . . . .,. . . . . . . .::.:. . . .: .*- : . .:. : ..:... ia.... .:.:. : . . . ..::-: . :.. . . . .. . ...:. ... .. . . . .. . . . ..O . ...::.:..:.:.........:....:.::.::.:.::.i...::.....:.....~.::.........:...::::....... . . . . .. . . . . . . .. .. .. . . . . . . . . . . . . . . . . . . . . ... . .. . . . . . ... . . .. . . . . . . . . .. .- -* - - * : .- --. . . . . .. . . .. . . . . . ... . . . .. . . . . . ... . . . . .:.::. -:: : .:. .:-..:: .:.,...:.: -- ..: -*..: ‚: : :...... . . . .. . ... . . .. . . ..:...:.....:.:.::.:::.:.:.::.::....:...::::........:...:....:.:.::.:..:.......:.::. . . . . .. . . ..I. .. . .. . . . . . . . . . . .. . . . . . . . . . . . . . . . . .. . .. . . . . . . . .. . .. .. . . . . .. . . . . . . . . .. .... ..: :.:.*.:.... . . . . . . . .. . . . . . .. . . ... :.: :::.:: . . . . . . . .: :..;..-‚:.. .:..:. . .:..:: ..: I.. . .i: . *..:.:...........:......::.:..:....:...............,...:...:...:::.::.:..~:.....*... . . . . . . . . .. . . .. . . . . . . . . . . . .. . . . . . . . . . . . . . . . . . . . . . . .. . .. . . . . . . . . . .. . . . . . . . . . . . . . . . .. . . . ... . . . . . . .. . . ...:. . . . . .. . .. . . . . . .. ... . . . .. . . ::. .: ::.... .. . y.:. : . . .. . . . . . ... . .:™ .:. . . . . . . .. . . . . : . : :: ... . .. . . . . . . . . . . .. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .. . . . . . . . ... . . . . . . . . . . .. . .. . . . . . . . . . . . . . . . . . . . . . . .. . . . . . . .. . . . . ... . . . . . .

19. String SearchingData to be processed often does not decompose logically into indepen-dent records with small identifiable pieces. This type of data is charac-terized only by the fact that it can be written down as a string: a linear(typically very long) sequence of characters.Strings are obviously central in ﬁword processingﬂ systems, which providea variety of capabilities for the manipulation of text. Such systems process textstrings, which might be loosely defined as sequences of letters, numbers, andspecial characters. These objects can be quite large (for example, this bookcontains over a million characters), and efficient algorithms play an importantrole in manipulating them.Another type of string is the binary string, a simple sequence of 0 and 1values. This is in a sense merely a special type of text string, but it is worthmaking the distinction not only because different algorithms are appropriatebut also binary strings arise naturally in many applications. For example,
some computer graphics systems represent pictures as binary strings. (This
book was printed on such a system: the present page was represented at one
time as a binary string consisting of millions of bits.)In one sense, text strings are quite different objects than binary strings,since they are made up of characters from a large alphabet. In another, the twotypes of strings are equivalent, since each text character can be representedby (say) eight binary bits and a binary string can be viewed as a text string bytreating eight-bit chunks as characters. We™ll see that the size of the alphabetfrom which the characters are taken to form a string is an important factorin the design of string processing algorithms.A fundamental operation on strings is pattern matching: given a textstring of length N and a pattern of length M, find an occurrence of thepattern within the text. (We will use the term ﬁtextﬂ even when referring toa sequence of O-l values or some other special type of string.) Most algorithms241
242CHAPTER 19for this problem can easily be extended t,o find all occurrences of the patternin the text, since they scan sequentially through t,he text and can be restartedat the point directly after the beginning of a match to find the next match.The pattern-matching problem can be characterized as a searching prob-lem with the pattern as the key, but the searching algorithms that we havestudied do not apply directly because the pattern can be long and because
it ﬁlines upﬂ with the text in an unknown way. It is an interesting problemto study because several very different (and surprising) algorithms have onlyrecently been discovered which not only provide a spectrum of useful practicalmethods but also illustrate some fundamental algorithm design techniques.A Short HistoryThe development of the algorithms that we™ll be examining has an interestinghistory: we™ll summarize it here to place the various methods into perspective.There is an obvious brute-force algorithm for string processing which is inwidespread use. While it has a worst-case running time proportional to MN,the strings which arise in many applications lead to a running time whichis virtually always proportional to M + N. Furthermore, it is well suited togood architectural features on most computer systems, so an optimized versionprovides a ﬁstandardﬂ which is difficult to beat with a clever algorithm.In 1970, S. A. Cook proved a theoretical result about a particular type ofabstract machine implying that an algorithm exists which solves the pattern-matching problem in time proportional to M + N in the worst case. D. E.Knuth and V. R. Pratt laboriously followed through the construction Cookused to prove his theorem (which was not intended at all to be practical)
to get an algorithm which they were then able to refine to be a relativelysimple practical algorithm. This seemed a rare and satisfying example of atheoretical result having immediate (and unexpected) practical applicability.But it turned out that J. H. Morris had discovered virtually the same algorithmas a solution to an annoying practical problem that confronted him whenimplementing a text editor (he didn™t want to ever ﬁback upﬂ in the text
string). However, the fact that the same algorithm arose from two such
different approaches lends it credibility as a fundamental solution to the
problem.Knuth, Morris, and Pratt didn™t get around to publishing their algorithmuntil 1976, and in the meantime R. S. Boyer and J. S. Moore (and, indepen-dently, R. W. Gosper) discovered an algorithm which is much faster in many
applications, since it often examines only a fraction of the characters in the
text string. Many text editors use this algorithm to achieve a noticeabledecrease in response time for string searches.Both the Knuth-Morris-Pratt and the Boyer-Moore algorithms requiresome complicated preprocessing on the pattern that is difficult to understand
STRING SEARCHING243and has limited the extent, to which they are used. (In fact, the story goesthat an unknown systems programmer found Morris™ algorithm too difficult
to understand and replaced it with a brute-force implementation.)In 1980, R. M. Karp and M. 0. Rabin observed that the problem is notas different from the standard searching problem as it had seemed, and cameup with an algorithm almost as simple as the brute-force algorithm which
virtually always runs in time proportional to M + N. Furthermore, theiralgorithm extends easily to two-dimensional patterns and text, which makesit more useful than the others for picture processing.This story illustrates that the search for a ﬁbetter algorithmﬂ is still veryoften justified: one suspects that there are still more developments on thehorizon even for this problem.Brute-Force AlgorithmThe obvious method for pattern matching that immediately comes to mind isjust to check, for each possible position in the text at which the pattern couldmatch, whether it does in fact match. The following program searches in this
way for the first occurrence of a pattern p [ 1. .M] in a text string a [ 1. .N] :function brutesearch: integer;var i, j: integer;begini:=l; j:=l;repeatif a[i]=plj]then begin i:=i+l; j:=j+l endelse begin i:=i-j+2; j:=1 end;until (j>M) or (i>N);if j>M then brutesearch:=i-M else brutesearch:=iend ;The program keeps one pointer (i) into the text, and another pointer (j) intothe pattern. As long as they point to matching characters, both pointers areincremented. If the end of the pattern is reached (j>M), then a match hasbeen found. If i and j point to mismatching characters, then j is reset to pointto the beginning of the pattern and i is reset to correspond to moving thepattern to the right one position for matching against the text. If the endof the text is reached (i>N), then there is no match. If the pattern does notoccur in the text, the value N+l is returned.In a text-editing application, the inner loop of this program is seldomiterated, and the running time is very nearly proportional to the number of
244CHAPTER 19text characters examined. For example, suppose that we are looking for thepattern STING in the text stringA STRING SEARCHING EXAMPLE CONSISTING OF SIMPLE TEXTThen the statement j:=j+l is executed only four times (once for each S,but twice for the first ST) before the actual match is encountered. On theother hand, this program can be very slow for some patterns. For example, ifthe pattern is 00000001 and the text string is:00000000000000000000000000000000000000000000000000001then j is incremented 7*45 (315) times before the match is encountered. Suchdegenerate strings are not likely in English (or Pascal) text, but the algorithmdoes run more slowly when used on binary (two-character) text, as might occur
in picture processing and systems programming applications. The following
table shows what happens when the algorithm is used to search for 10010111
in the following binary string:100111010010010010010111000111100111010010100101001010010111There is one line in this table for each time the body of the repeat loopis entered, and one character for each time j is incremented. These are theﬁfalse startsﬂ that occur when trying to find the pattern: an obvious goal isto try to limit the number and length of these.Knuth-Morris-Pratt AlgorithmThe basic idea behind the algorithm discovered by Knuth, Morris, and Prattis this: when a mismatch is detected, our ﬁfalse startﬂ consists of charactersthat we know in advance (since they™re in the pattern). Somehow we should beable to take advantage of this information instead of backing up the i pointerover all those known characters.
STRING SEARCHING245For a simple example of this, suppose that the first character in thepattern doesn™t appear again in the pattern (say the pattern is 10000000).Then, suppose we have a false start j characters long at some position inthe text. When the mismatch is detected, we know, by dint of the factthat j characters have matched, that we don™t have to ﬁback upﬂ the text
pointer i, since none of the previous j-l characters in the text can match
the first character in the pattern.This change could be implemented byreplacing i:=i-j+2 in the program above by i:=i+l. The practical effect ofthis change is limited because such a specialized pattern is not particularlylikely to occur, but the idea is worth thinking about because the Knuth-Morris-Pratt algorithm is a generalization. Surprisingly, it is always possibleto arrange things so that the i pointer is never decremented.Fully skipping past the pattern on detecting a mismatch as describedin the previous paragraph won™t work when the pattern could match itselfat the point of the mismatch. For example, when searching for 10100111 in1010100111 we first detect the mismatch at the fifth character, but we hadbetter back up to the third character to continue the search, since otherwisewe would miss the match. But we can figure out ahead of time exactly what
to do, because it depends only on the pattern, as shown by the following table:j p[l..j-l]next b]2 1113 1014 10125 10103The array next [1..M] will be used to determine how far to back up when amismatch is detected. In the table, imagine that we slide a copy of the firstj-l characters of the pattern over itself, from left to right starting with thefirst character of the copy over the second character of the pattern, stoppingwhen all overlapping characters match (or there are none). These overlapping
characters define the next possible place that the pattern could match, if a
mismatch is detected at pbl. The distance to back up (next b]) is exactlyone plus the number of the overlapping characters. Specifically, for j>l, thevalue of nextb] is the maximum k<j for which the first k-l characters ofthe pattern match the last k-l characters of the first j-l characters of thepattern. A vertical line is drawn just after plj-next[j] ] on each line of the
246CHAPTER 19table. As we™ll soon see, it is convenient to define next[I] to be 0.This next array immediately gives a way to limit (in fact, as we™ll see,eliminate) the ﬁbackupﬂ of the text pointer i: a generalization of the methodabove. When i and j point to mismatching characters (testing for a patternmatch beginning at position i-j+1 in the text string), then the next possibleposition for a pattern match is beginning at position i-nextIj]+l. But bydefinition of the next table, the first nextb]--I characters at that positionmatch the first nextb]-l characters of the pattern, so there™s no need toback up the i pointer that far: we can simply leave the i pointer unchangedand set the j pointer to next b], as in the following program:function kmpsearch : integer ;var i, j: integer;begini:=l; j:=l;repeatif (j=O) or (a[i]=pb])then begin i:=i+l; j:=j+l endelse begin j:=nextLj] end;until (j>M) or (i>N);if j> M then kmpsearch : =i-M else kmpsearch : =i;end ;When j=l and a[i] does not match the pattern, there is no overlap, so we wantto increment i and set j to the beginning of the pattern. This is achieved bydefining next [I] to be 0, which results in j being set to 0, then i is incrementedand j set to 1 next time through the loop. (For this trick to work, the patternarray must be declared to start at 0, otherwise standard Pascal will complainabout subscript out of range when j=O even though it doesn™t really have toaccess p[O] to determine the truth of the or.) Functionally, this program isthe same as brutesearch, but it is likely to run faster for patterns which arehighly self-repetitive.It remains to compute the next table. The program for this is short buttricky: it is basically the same program as above, except that it is used tomatch the pattern against itself.
STRING SEARCHING247procedure initnext ;var i, j: integer;begini:=l; j:=O; next[l]:=O;repeatif (j=O) or (p[i]=plj])then begin i:=i+l; j:=j+l; next[i]:=j endelse begin j:=nextIj] end;until i>M;end ;Just after i and j are incremented, it has been determined that the first j-lcharacters of the pattern match the characters in positions p [i-j- 1. .i-1 1, thelast j-l characters in the first i-l characters of the pattern. And this is thelargest j with this property, since otherwise a ﬁpossible matchﬂ of the patternwith itself would have been missed. Thus, j is exactly the value to be assignedto next [il.An interesting way to view this algorithm is to consider the pattern asfixed, so that the next table can be ﬁwired inﬂ to the program. For example,the following program is exactly equivalent to the program above for thepattern that we™ve been considering, but it™s likely to be much more efficient.i:=O;0:i:=i+l;1: if a[i]<>‚l™then goto 0; i:=i+l;2: if a[i]<>‚O™then goto 1; i:=i+l;3: if a[i]<>‚l™then goto 1; i:=i+l;4: if a[i]<>‚O™then goto 2; i:=i+l;5: if a[i]<>‚O™then goto 3; i:=i+l;6: if a[i]<>‚l™then goto 1; i:=i+l;7: if a[i]<>‚l™then goto 2; i:=i+l;8: if a[i]<>‚l™then goto 2; i:=i+l;search : =i-8;The goto labels in this program correspond precisely to the next table. Infact, the in&next program above which computes the next table could easilybe modified to output this program!To avoid checking whether i>N eachtime i is incremented, we assume that the pattern itself is stored at the endof the text as a sentinel, in a[N+l ..N+M]. (This optimization could alsobe applied to the standard implementation.) This is a simple example of aﬁstring-searching compilerﬂ :given a pattern, we can produce a very efficient
248CHAPTER 19program which can scan for that pattern in an arbitrarily long text string.We™ll see generalizations of this concept in the next two chapters.The program above uses just a few very basic operations to solve thestring searching problem. This means that it can easily be described in termsof a very simple machine model, called a finite-state machine. The following
diagram shows the finite-state machine for the program above:c-d--------...I,---.//e--.--.//\/™ ‚\\ff -_\ ™\\ f\\;D-1'0 10 0 '1\' 'I/,/\\//',‚Z-- H'///- .- ..'/N-w--=z----#CC/'----_----cc)The machine consists of states (indicated by circled letters) and transi-tions (indicated by arrows). Each state has two transitions leaving it: a matchtransition (solid line) and a non-match transition (dotted line). The statesare where the machine executes instructions; the transitions are the goto in-structions.When in the state labeled ﬁ5,ﬂ the machine can perform justone instruction: ﬁif t.he current character is x then scan past it and take thematch transition, otherwise take the non-match transition.ﬂ To ﬁscan pastﬂa character means to take the next character in the string as the ﬁcurrent
characterﬂ;the machine scans past characters as it matches them. Thereis one exception to this: the non-match transition in the first state (markedwith a double line) also requires that the machine scan to the next charac-ter. (Essentially this corresponds to scanning for the first occurrence of thefirst character in the pattern.) In the next chapter we™ll see how to use asimilar (but more powerful) machine to help develop a much more powerful
pattern-matching algorithm.The alert reader may have noticed that there™s still some room for im-provement in this algorithm, because it doesn™t take into account the characterwhich caused the mismatch. For example, suppose that we encounter 1011when searching for our sample pattern 10100111. After matching 101, wefind a mismatch on the fourth character, at which point the next table saysto check the second character, since we already matched the 1 in the thirdcharacter. However, we could not have a match here: from the mismatch, weknow that the next character in the text is not 0, as required by the pattern.
STRING SEARCHING249Another way to see this is to look at the version of the program with the nexttable ﬁwired inﬂ:at label 4 we go to 2 if a[i] is not 0, but at label 2 we goto 1 if a[i] is not 0. Why not just go to 1 directly? Fortunately, it is easyto put this change into the algorithm. We need only replace the statementnext[i] :=j in the initnext program byif plj]<>p[i] then next[i]:=j else next[i]:=nextb];With this change, we either increment j cr reset it from the next table at mostonce for each value of i, so the algorithm is clearly linear.The Knuth-Morris-Pratt algorithm LS not likely to be significantly fasterthan the brute-force method in most actual applications, because few ap-plications involve searching for highly self-repetitive patterns in highly self-repetitive text. However, the method does have a major virtue from a practi-cal point of view: it proceeds sequentially through the input and never ﬁbacksupﬂ in the input. This makes the method convenient for use on a large file
being read in from some external device. (Algorithms which require backup
require some complicated buffering in this situation.)Boyer-Moore AlgorithmIf ﬁbacking upﬂ is not a problem, then a significantly faster string searchingmethod can be developed by scanning .,he pattern from right to left whentrying to match it against the text. When searching for our sample pattern10100111, if we find matches on the eighth, seventh, and sixth character butnot on the fifth, then we can immediatelyi slide the pattern seven positions tothe right, and check the fifteenth character next, because our partial matchfound 111, which might appear elsewhm?re in the pattern. Of course, thepattern at the end does appear elsewhere: in general, so we need a next tableas above. For example, the following is a right-to-left version of the next tablefor the pattern 10110101:j p[M--j+2..M] p[M-n~3xt~]+l..M] nextb]21 1014301011010174101012501011010115610101101015711010110101580110101101015
250CHAPTER 19The number at the right on the jth line of the table gives the maximumnumber of character positions that the pattern can be shifted to the right
given that a mismatch in a right-toleft scan occurred on the jth characterfrom the right in the pattern. This is found in a similar manner as before, bysliding a copy of the pattern over the last j-l characters of itself from left
to right starting with the next-to-last character of the copy lined up with thelast character of the pattern, stopping when all overlapping characters match(also taking into account the character which caused the mismatch).This leads directly to a program which is quite similar to the aboveimplementation of the Knuth-Morris-Pratt method. We won™t go into thisin more detail because there is a quite different way to skip over characterswith right-to-left pattern scanning which is much better in many cases.The idea is to decide what to do next based on the character that causedthe mismatch in the tezt as well as the pattern. The simplest realization ofthis leads immediately to a quite useful program. Consider the first examplethat we studied, searching for the pattern STING in the text stringA STRING SEARCHING EXAMPLE CONSISTING OF SIMPLE TEXTProceeding from right to left to match the pattern, we first check the Gin the pattern against the R (the fifth character) in the text. Not only dothese not match, but also we can notice that R does not appear anywherein the pattern, so we might as well slide it all the way past the R. The nextcomparison is of the G in the pattern against the fifth character following the
R (the S in SEARCHING). This time, we can slide the pattern to the rightuntil its S matches the S in the text. Then the G in the pattern is comparedagainst the C in SEARCHING, which doesn™t appear in the pattern, so it canbe slid five more places to the right. After three more five-character skips,we arrive at the T in CONSISTING, at which point we align the patternso that the its T matches the T in the text and find the full match. Thismethod brings us right to the match position at a cost of examining only sevencharacters in the text (and five more to verify the match)! If the alphabetis not small and the pattern is not long, then this ﬁmismatched character
algorithmﬂ will find a pattern of length M in a text string of length N inabout N/M steps.The mismatched character algorithm is quite easy to implement. Itsimply improves a brute-force right-to-left pattern scan by using an arrayskip which tells, for each character in the alphabet, how far to skip if thatcharacter appears in the text and causes a mismatch:
STRING SEARCHING251function mischarsearch: integer;var i, j: integer;begini:=M; j:=:M;repeatif a[i]=pb]then begin i:=i-1; j:=j-1 endelsebegini:=i+M-j+l; j:=M;if skip[index(a[i])]>M-j+1 theni:=i+skip[index(a[i])]-(M-j+l);end;until (j<l) or (i>N);mischarsearch:=i+lend ;The statement i:=i+M-j+1 resets i to the next position in the text string (asthe pattern moves from left-to-right across it); then j:=M resets the patternpointer to prepare for a right-to-left character-by-character match. The nextstatement moves the pattern even further across the text, if warranted. Forsimplicity, we assume that we have a function index(c: char): integer; thatreturns 0 for blanks and i for the ith letter of the alphabet, and a procedureinitskip which initializes the skip array tll M for characters not in the patternand then for j from 1 to M sets skip[index(pb])] to M-j. For example, forthe pattern STING, the skip entry for G would be 0, the entry for N would be1, the entry for I would be 2, the entry for T would be 3, the entry for S wouldbe 4, and the entries for all other letters T,vould be 5. Thus, for example, whenan S is encountered during a right-to-lefi, search, the i pointer is incrementedby 4 so that the end of the pattern is alig;ned four positions to the right of theS (and consequently the S in the pattern lines up with the S in the text). Ifthere were more than one S in the pattern, we would want to use the rightmostone for this calculation: hence the skip array is built by scanning from left toright.Boyer and Moore suggested combining the two methods we have outlinedfor right-to-left patt,ern scanning, choosing the larger of the two skips calledfor.The mismatched character algorithm obviously won™t help much for bi-nary strings, because there are only two possibilities for characters which causethe mismatch (and these are both likely to be in the pattern). However, the
bits can be grouped together to make ﬁcharactersﬂ which can be used exactly
252CRAI™TER 19as above. If we take b bits at a time, then we need a skip table with 2b entries.The value of b should be chosen small enough so that this table is not toolarge, but large enough that most b-bit sections of the text are not likely tobe in the pattern. Specifically, there are M - b + 1 different b-bit sections inthe pattern (one starting at each bit position from 1 through M-b+ 1) so wewant M - b + 1 to be significantly less than 2b. For example, if we take b tobe about lg(4M), then the skip table will be more than three-quarters filledwith M entries. Also b must be less than M/2, otherwise we could miss thepattern entirely if it were split between two b-bit text sections.Rabin-Karp AlgorithmA brute-force approach to string searching which we didn™t examine abovewould be to use a large memory to advantage by treating each possible M-character section of the text as a key in a standard hash table. But it isnot necessary to keep a whole hash table, since the problem is set up so that
only one key is being sought: all that we need to do is to compute the hashfunction for each of the possible M-character sections of the text and check ifit is equal to the hash function of the pattern. The problem with this methodis that it seems at first to be just as hard to compute the hash function for Mcharacters from the text as it is merely to check to see if they™re equal to thepattern. Rabin and Karp found an easy way to get around this problem for the
hash function h(k) = kmodq where q (the table size) is a large prime. Theirmethod is based on computing the hash function for position i in the textgiven its value for position i - 1. The method follows quite directly from themathematical formulation. Let™s assume that we translate our M charactersto numbers by packing them together in a computer word, which we thentreat as an integer. This corresponds to writing the characters as numbers ina base-d number system, where d is the number of possible characters. The
number corresponding to a[i..i + M - l] is thusz = a[i]dMP1 + a[i + lIdMe + ... + a[i + M - l]and we can assume that we know the value of h(z) = xmodq. But shiftingone position right in the text simply corresponds to replacing x by(x - a[i]dMel)d + a[i + M].A fundamental property of the mod operation is that we can perform it at anytime during these operations and still get the same answer. Put another way,if we take the remainder when divided by q after each arithmetic operation(to keep the numbers that we™re dealing with small) then we get the sameanswer that we would if we were to perform all of the arithmetic operations,then take the remainder when divided by q.
STRING SEARCHTNG253This leads to the very simple pattelm-matching algorithm implementedbelow. The program assumes the same i.ldex function as above, but d=32 isused for efficiency (the multiplications might be implemented as shifts).function rksearch : integer;const q=33554393; d=3.Z;var hl, h2, dM, i: integer:begindM:=l; for i:=l to M-1 do dM:=(d*dM) mod q;hl:=O; for i:=l to M do hl:=(hl*d+index(p[i])) mod q;h2:=0; for i:=l to M do h2:=(h2*d+index(a[i])) mod q;i:=l;while (hloh2) and (i<=N-M) dobeginh2:=(h2+d*q-index(,t[i])*dM) mod q;h2:=(h2*d+index(a[i+M])) mod q;i:=i+l;end ;rksearch :=i;end ;The program first computes a hash valle hl for the pattern, then a hashvalue h2 for the first M characters of the text. (Also it computes the valueof dﬂ-™ modq in the variable dM.) Then it proceeds through the text string,using the technique above to compute the hash function for the M charactersstarting at position i for each i, comparing each new hash value to hl. The
prime q is chosen to be as large as possible, but small enough that (d+l)*qdoesn™t cause overflow: this requires less mod operations then if we used thelargest repesentable prime. (An extra d*q is added during the h2 calculationto make sure that everything stays positive so that the mod operation worksas it should.)This algorithm obviously takes time proportional to N + M. Note thatit really only finds a position in the text which has the same hash value as thepattern, so, to be sure, we really should do a direct comparison of that textwith the pattern. However, the use of suc:i a large value of q, made possible bythe mod computations and by the fact that we don™t have to keep the actualhash table around, make8 it extremely unlikely that a collision will occur.Theoretically, this algorithm could still take NM steps in the (unbelievably)worst case, but in practice the algorithm can be relied upon to take aboutN + M steps.
254CHAPTER 19Multiple SearchesThe algorithms that we™ve been discussing are all oriented towards a specificstring searching problem: find an occurrence of a given pattern in a giventext string. If the same text string is to be the object of many patternsearches, then it will be worthwhile to do some processing on the string tomake subsequent searches efficient.If there are a large number of searches, the string searching problem canbe viewed as a special case of the general searching problem that we studiedin the previous section. We simply treat the text string as N overlappingﬁkeys,ﬂ the ith key defined to be a[l..N], the entire text string starting atposition i. Of course, we don™t manipulate the keys themselves, but pointersto them: when we need to compare keys i and j we do character-by-character
compares starting at positions i and j of the text string. (If we use a ﬁsentinelﬂcharacter larger than all other characters at the end, then one of the keyswill always be greater than the other.) Then the hashing, binary tree, and
other algorithms of the previous section can be used directly. First, an entirestructure is built up from the text string, and then efficient searches can beperformed for particular patterns.There are many details which need to be worked out in applying searchingalgorithms to string searching in this way; our intent is to point this out asa viable option for some string searching applications. Different methods will
be appropriate in different situations. For example, if the searches will always
be for patterns of the same length, a hash table constructed with a single scan
as in the Rabin-Karp method will yield constant search times on the average.
On the other hand, if the patterns are to be of varying length, then one of the
tree-based methods might be appropriate. (Patricia is especially adaptable tosuch an application.)Other variations in the problem can make it significantly more difficultand lead to drastically different methods, as we™ll discover in the next twochapters.r-l
STRING SEARCHING255Exercises1.2.3.4.5.6.7.8.9.10.Implement a brute-force pattern ms.tching algorithm that scans the pat-tern from right to left.Give the next table for the Knuth-Morris-Pratt algorithm for the patternAAIWUAA.Give the next table for the Knuth-Morris-Pratt algorithm for the patternAERACADABRA.Draw a finite state machine which can search for the pattern AE3RACADAFBA.How would you search a text file fo; a string of 50 consecutive blanks?Give the right-to-left skip table for the right-left scan for the patternAENACADABRA.Construct an example for which the right-to-left pattern scan with onlythe mismatch heuristic performs badly.How would you modify the Rabin-Karp algorithm to search for a givenpattern with the additional proviso that the middle character is a ﬁ‚wildcardﬂ (any text character at all can match it)?Implement a version of the Rabin-Karp algorithm that can find a giventwo-dimensional pattern in a given two-dimensional text. Assume both
pattern and text are rectangles of characters.Write programs to generate a random lOOO-bit text string, then find alloccurrences of the last /c bits elsewhere in the string, for k = 5,10,15.(Different methods might be appropriate for different values of k.)

20. Pattern MatchingIt is often desirable to do string searching with somewhat less thancomplete information about the pattern to be found. For example, theuser of a text editor may wish to specif;r only part of his pattern, or he maywish to specify a pattern which could match a few different words, or he mightwish to specify that any number of occurrences of some specific charactersshould be ignored. In this chapter we™ll consider how pattern matching of thistype can be done efficiently.The algorithms in the previous chapter have a rather fundamental depen-dence on complete specification of the pattern, so we have to consider differentmethods. The basic mechanisms that we will consider make possible a very
powerful string searching facility which can match complicated M-characterpatterns in N-character text strings in time proportional to MN.First, we have to develop a way to describe the patterns: a ﬁlanguageﬂthat can be used to specify, in a rigorous way, the kinds of partial stringsearching problems suggested above. Th .s language will involve more powerfulprimitive operations than the simple ﬁcheck if the ith character of the textstring matches the jth character of the patternﬂ operation used in the previous
chapter. In this chapter, we consider three basic operations in terms of animaginary type of machine that has the capability for searching for patternsin a text string. Our pattern-matching algorithm will be a way to simulate
the operation of this type of machine.[n the next chapter, we™ll see how totranslate from the pattern specification (which the user employs to describehis string searching task) to the machine specification (which the algorithm
employs to actually carry out the search).As we™ll see, this solution to the pattern matching problem is intimatelyrelated to fundamental processes in computer science. For example, themethod that we will use in our program to perform the string searching taskimplied by a given pattern description is akin to the method used by the257
258CHAPTER 20Pascal system to perform the computational task implied by a given Pascalprogram.Describing PatternsWe™ll consider pattern descriptions made up of symbols tied together with thefollowing three fundamental operations.(i)Concatenation. This is the operation used in the last chapter. If twocharacters are adjacent in the pattern, then there is a match if and onlyif the same two characters are adjacent in the text. For example, AI3means A followed by B.(ii)Or. This is the operation that allows us to specify alternatives in thepattern. If we have an ﬁorﬂ between two characters, then there is amatch if and only if either of the characters occurs in the text. We™lldenote this operation by using the symbol + and use parentheses toallow it to be combined with concatenation in arbitrarily complicatedways. For example, A+B means ﬁeither A or Bﬂ; C(AC+B)D meansﬁeither CACD or CBDﬂ; and (A+C)((B+C)D) means ﬁeither ABD orCBD or ACD or CCD.ﬂ(iii) Closure. This operation allows parts of the pattern to be repeatedarbitrarily. If we have the closure of a symbol, then there is a match ifand only if the symbol occurs any number of times (including 0). Closurewill be denoted by placing a* after the character or parenthesized groupto be repeated. For example, AB* matches strings consisting of an Afollowed by any number of B™s, while (AB)ﬂ matches strings consistingof alternating A™s and B™s.A string of symbols built up using these three operations is called a regularexpression.Each regular expression describes many specific text patterns.Our goal is to develop an algorithm which will determine if any of the patternsdescribed by a given regular expression occur in a given text string.We™ll concentrate on concatenation, or, and closure in order to showthe basic principles in developing a regular-expression pattern matching al-gorithm. Various additions are commonly made in actual systems for con-
venience. For example, -A might meanﬁmatch any character except A.ﬂThis not operation is the same as an or involving all the characters exceptA but is much easier to use. Similarly, ﬁ7ﬂ might mean ﬁmatch any letter.ﬂAgain, this is obviously much more compact than a large or. Other examplesof additional symbols which might make specification of large patterns easier
are symbols which match the beginning or end of a line, any letter or anynumber, etc.These operations can be remarkably descriptive. For example, the patterndescription ?*(ie + ei)?™ matches all words which have ie or ei in them (and so
PATTERN h4ATCHliVGare likely to be misspelled!); and (1 + 01)™ (0 + 1) describes all strings of O™s andl™s which do not have two consecutive 0™~Obviously there are many differentpattern descriptions which describe the same strings: we must try to specifysuccinct pattern descriptions just as we ;ry to write efficient algorithms.The pattern matching algorithm that we™ll examine may be viewed asa generalization of the brute force left-to-right string searching method (thefirst method that we looked at in Chapter 19). The algorithm looks for the
leftmost substring in the text string which matches the pattern description byscanning the text string from left to rignt, testing, at each position whetherthere is a substring beginning at that position which matches the patterndescription.Pattern Matching MachinesRecall that we can view the Knuth-Morris-Pratt algorithm as a finite-statemachine constructed from the search pattern which scans the text. The
method we will use for regular-expressior pattern matching is a generalization
of this.The finite-state machine for the Knuth-Morris-Pratt algorithm changesfrom state to state by looking at a character from the text string and thenchanging to one state if there™s a match, to another state if not. A mismatchat any point means that the pattern couldn™t occur in the text starting at that
point. The algorithm itself can be thought of as a simulation of the machine.
The characteristic of the machine that makes it easy to simulate is that it
is deterministic: each state transition is completely determined by the nextinput character.To handle regular expressions, it will be necessary to consider a morepowerful abstract machine. Because of the or operation, the machine can™tdetermine whether or not the pattern could occur at a given point by examin-ing just one character; in fact, because 0:™ closure, it can™t even determine howmany characters might need to be exam:ned before a mismatch is discovered.The most natural way to overcome these problems is to endow the machinewith the power of nondeterminism: when faced with more than one way totry to match the pattern, the machine should ﬁguessﬂ the right one! Thisoperation seems impossible to allow, but, we will see that it is easy to write a
program to simulate the actions of such a machine.For example, the following diagram shows a nondeterministic finite-statemachine that could be used to search for the pattern description (A*B+AC)Din a text string.
260CHAPTER 20As in the deterministic machine of the previous chapter, the machine cantravel from a state labeled with a character to the state ﬁpointed toﬂ by thatstate by matching (and scanning past) that character in the text string. Whatmakes the machine nondeterministic is that there are some states (called nullstates) which not only are not labeled, but also can ﬁpoint toﬂ two differentsuccessor states. (Some null states, such as sta.te 4 in the diagram, are ﬁno-opﬂ states with one exit, which don™t affect the operation of the machine,but which make easier the implementation of the program which constructsthe machine, as we™ll see. State 9 is a null state with no exits, which stopsthe machine.) When in such a state, the machine can go to either successorstate regardless of what™s in the input (without scanning past anything). Themachine has the power to guess which transition will lead to a match for thegiven text string (if any will). Note that there are no ﬁnon-matchﬂ transitionsas in the previous chapter: the machine fails no find a match only if there isno way even to guess a sequence of transitions that leads to a match.The machine has a unique initial state (which is pointed to by a ﬁfreeﬂarrow) and a unique final state (which has no arrows going out). When startedout in the initial state, the machine should be able to ﬁrecognizeﬂ any stringdescribed by the pattern by reading characters and changing state accordingto its rules, ending up in the ﬁfinal state.ﬂ Because it has the power ofnondeterminism, the machine can guess the sequence of state changes thatcan lead to the solution. (But when we try to simulate the machine on astandard computer, we™ll have to try all the possibilities.) For example, todetermine if its pattern description (A*B+AC)D can occur in the text stringCDAABCAAABDDACDAACthe machine would immediately report failure if started on the first or secondcharacter; it would work some to report failure on the next two characters; it
would immediately report failure on the fifth or sixth characters; and it would
guess the sequence of state transitions
PATTERN iMATCHING5 22 1 2261123489to recognize AAAE%D if started on the seventh character.We can construct the machine for a given regular expression by buildingpartial machines for parts of the expref#sion and defining the ways in whichtwo partial machines can be composed into a larger machine for each of thethree operations: concatenation, or, and closure.We start with the trivial machine to recognize a particular character. It™sconvenient to write this as a two-state machine, with one initial state (whichalso recognizes the character) and one final state, as below:-49-ONow to build the machine for the concatenation of two expressions from themachines for the individual expressions,we simply merge the final state ofthe first with the initial state of the second:Similarly, the machine for the or operation is built by adding a new null statepointing to the two initial states, and making one final state point to the
other, which becomes the final state of l,he combined machine.Finally, the machine for the closure operation is built by making the finalstate the initial state and making it point back to the old initial state and anew final state.
262CHAPTER 20A machine can be built which corresponds to any regular expression bysuccessively applying these rules. The numbers of the states for the examplemachine above are in order of creation as the machine is built by scanningthe pattern from left to right, so the construction of the machine from therules above can be easily traced. Note that we have a 2-state trivial machinefor each letter in the regular expression, and each + and * causes one state tobe created (concatenation causes one to be deleted) so the number of states iscertainly less than twice the number of characters in the regular expression.Representing the MachineOur nondeterministic machines will all be constructed using only the threecomposition rules outlined above, and we can take advantage of their simple
structure to manipulate them in a straightforward way. For example, no statehas more than two arrows leaving it. In fact, there are only two types of states:those labeled by a character from the input alphabet (with one arrow leaving)and unlabeled (null) states (with two or fewer arrows leaving). This means
that the machine can be represented with only a few pieces of information
per node. For example, the machine above might be represented as follows:StateCharacter Next I Next 205-1A22313B4-4885626A7-7C8-8D9900The rows in this table may be interpreted as instructions to the nondeter-ministic machine of the iorm ﬁIf you are in State and you see Character thenscan the character and go to state Next I (or Next 2)ﬂ State 9 is the finalstate in this example, and State 0 is a pseudo-initial state whose Next I entry
PATTERN MATCHINGis the number of the actual initial state. (Note the special representation usedfor null states with 0 or 1 exits.)Since we often will want to access states just by number, the most suitableorganization for the machine is to use the array representation. We™ll use thethree arraysch: amty [O..Mmax] of char;nextl, next2: array [O..Mmax] of integer;Here Mmax is the maximum number of™ states (twice the maximum patternlength). It would be possible to get by with two-thirds this amount of space,since each state really uses only two rreaningful pieces of information, butwe™ll forsake this improvement for the sake of clarity and also because patterndescriptions are not likely to be particularly long.We™ve seen how to build up mach.nes from regular expression patterndescriptions and how such machines might be represented as arrays. However,to write a program to do the translation from a regular expression to thecorresponding nondeterministic machine representation automatically is quiteanother matter. In fact, even writing a program to determine if a given regularexpression is legal is challenging for the uninitiated. In the next chapter, we™llstudy this operation, called parsing, in much more detail. For the moment,we™ll assume that this translation has been done, so that we have availablethe ch, nextl, and next2 arrays representing a particular nondeterministicmachine which corresponds to the regular expression pattern description ofinterest.Simulating the MachineThe last step in the development of a. general regular-expression pattern-matching algorithm is to write a program which somehow simulates the opera-tion of a nondeterministic pattern-matching machine. The idea of writing a
program which can ﬁguessﬂ the right answer seems ridiculous. However, inthis case it turns out that we can keep track of all possible matches in asystematic way, so that we do eventually encounter the correct one.One possibility would be to develop a recursive program which mimicsthe nondeterministic machine (but tries all possibilities rather than guessingthe right one). Instead of using this approach, we™ll look at a nonrecursive
implementation which exposes the basic operating principles of the methodby keeping the states under consideration in a rather peculiar data structurecalled a deque, described in some detail below.The idea is to keep track of all states that could possibly be encounteredwhile the machine is ﬁlooking atﬂ the c:lrrent input character. Each of these
264CHAPTER 20states are processed in turn: null states lead to two (or fewer) states, states forcharacters which do not match the current input are eliminated, and states
for characters which do match the current input lead to new states for usewhen the machine is looking at the next input character. Thus, we maintaina list of all the states that the nondeterministic machine could possibly be inat a particular point in the text: the problem is to design an appropriate data
structure for this list.Processing null states seems to require a stack, since we are essentiallypostponing one of two things to be done, just as when we removed therecursion from Quicksort (so the new state should be put at the beginning
of the current list, lest it get postponed indefinitely). Processing the other
states seems to require a queue, since we don™t want to examine states for thenext input character until we™ve finished with the current character (so thenew state should be put at the end of the current list). Rather than choosingbetween these two data structures, we™ll use both! Deques (ﬁdouble-endedqueuesﬂ) combine the features of stacks and queues: a deque is a list to whichitems can be added at either end. (Actually, we use an ﬁoutput-restricteddeque,ﬂ since we always remove items from the beginning, not the end: thatwould be ﬁdealing from the bottom of the deck.ﬁ)A crucial property of the machine is that there are no ﬁloopsﬂ consisting ofjust null states: otherwise it could decide nondeterministically to loop forever.It turns out that this implies that the number of states on the deque at anytime is less than the number of characters in the pattern description.The program given below uses a deque to simulate the actions of a non-deterministic pattern-matching machine as described above. While examin-ing a particular character in the input, the nondeterministic machine can be
in any one of several possible states: the program keeps track of these in
a deque dq. One pointer (head) to the head of the deque is maintained so
that items can be inserted or removed at the beginning, and another pointer
(tail) to the tail of the deque is maintained so that items can be inserted
at the end. If the pattern description has M characters the deque can beimplemented in a ﬁcircularﬂ manner in an array of M integers. The con-tents of the deque are the elements ﬁbetweenﬂ head and tail (inclusive): ifhead<=tail, the meaning is obvious; if head>tail we take the elements thatwould fall between head and tail if the elements of dq were arranged in acircle:dq[head], dq[head+l],. . .,dq[M-l],dq[O], dq[l], . . .,dq[tail].This isquite simply implemented by using head:= head+1 mod M to increment headand similarly for tail. Similarly, head:= head+M-1 mod M refers to the ele-ment before head in therrray: this is the position at which an element shouldbe added to the beginning of the deque.The main loop of the program removes a state from the deque (by
PATTERN MATCHING265incrementing head mod M and then referring to dq[head]) and performs theaction required. If a character is to be matched, the input is checked for therequired character: if it is found, the sate transition is effected by puttingthe new state at the end of the deque (so that all states involving the currentcharacter are processed before those involving the next one). If the state is
null, the two possible states to be simulated are put at the beginning of the
deque. The states involving the curren, input character are kept separatedfrom those involving the next by a marker scan=-1 in the deque: whenscan is encountered, the pointer into th,: input string is advanced. The loopterminates when the end of the input is reached (no match found), state 0 isreached (legal match found), or only one item, the scan marker is left on thedeque (no match found). This leads directly to the following implementation:function match(j: intege.-): integer;const scan=- 1;var head, tail, nl, n2: integer;dq: array [O..Mmax] of integer;procedure addhead(x: integer);begin dq[head] :=x;head:=(head+M-1) mod A4 end;procedure addtail(x: integer);begin tail:=(tail+l) mod M; dq[tail]:=x end;beginhead:=l; taiJ:=O;addtail(next1 [O]); addtail(scan);match:=j-1;repeatif dq [head] =scan thfsnbegin j:=j+l; addtail(scan) endelse if ch [dq[head]]==alj] thenaddtail(next1 [dq[head]])else if ch[dq[head]]==™ ‚thenbeginnl :=nextl [dq[her!d]] ; n2:=next2[dq[head]];addhead(n1); if r™l<>n2 then addhead(n2)end ;head:=(head+l) mod Muntil (j>N) or (dq[head]=O) or (head=tail);if dq[head]=O then match:=j-1;end ;This function takes as its argument the -1osition j in the text string a at which
266GIAF'TER20it should start trying to match. It returns the index of the last character inthe match found (if any, otherwise it returns j-1).The following table shows the contents of the deque each time a state isremoved when our sample machine is run with the text string AABD. (Forclarity, the details involving head, tail, and the maintenance of the circulardeque are suppressed in this table: each line shows those elements in the dequebetween the head and tail pointers.) The characters appear in the lefthandcolumn in the table at the point when the program has finished scanningthem.5scan2613366scanA scan22713377scanA scan22scan133scanB scan44scan8scanD scan99scan0scanscan6scanscan227scan7scanscan22scanThus, we start with State 5 while scanning the first character. First State 5leads to States 2 and 6, then State 2 leads to States 1 and 3, all of which need
to scan the same character and are on the beginning of the deque. Then State1 leads to State 2, but at the end of the deque (for the next input character).State 3 only leads to another state while scanning a B, so it is ignored whilean A is being scanned. When the ﬁscanﬂ sentinel finally reaches the front of
the deque, we see that the machine could be either in State 2 or State 7 afterscanning an A. Continuing, the program eventually ends up the final state,after considering all transitions consistent with the text string.
PATTERN MATCHINGThe running time of this program obviously depends very heavily onthe pattern being matched. However, for each of the N input characters, itprocesses at most M states of the mac:nne, so the worst case running timeis proportional to MN. For sure, not all nondeterministic machines can besimulated so efficiently, as discussed in more detail in Chapter 40, but the useof a simple hypothetical pattern-matching machine in this application leadsto a quite reasonable algorithm for a quite difficult problem. However, tocomplete the algorithm, we need a program which translates arbitrary regularexpressions into ﬁmachinesﬂ for interpretation by the above code. In the nextchapter, we™ll look at the implementation of such a program in the context ofa more general discussion of compilers a,nd parsing techniques.r-l
268Exercises1.Give a regular expression for recognizing all occurrences of four or fewerconsecutive l™s in a binary string.2. Draw the nondeterministic pattern matching machine for the patterndescription (A+B)* +C.3.Give the state transitions your machine from the previous exercise wouldmake to recognize ABBAC.4.Explain how you would modify the nondeterministic machine to handlethe ﬁnotﬂ function.5.Explain how you would modify the nondeterministic machine to handleﬁdon™t-careﬂ characters.6.What would happen if match were to try to simulate the following ma-chine?7.Modify match to handle regular expressions with the ﬁnotﬂ function andﬁdon™t-careﬂ characters.8. Show how to construct a pattern description of length M and a textstring of length N for which the running time of match is as large aspossible.9.Why must the deque in match have only one ﬁscanﬂ sentinel in it?10.Show the contents of the deque each time a state is removed when matchis used to simulate the example machine in the text with the text stringACD.
21. ParsingSeveral fundamental algorithms have been developed to recognize legalcomputer programs and to decomI:ose their structure into a form suitablefor further processing. This operation, called parsing, has application beyondcomputer science, since it is directly related to the study of the structureof language in general. For example, parsing plays an important role in sys-tems which try to ﬁunderstandﬂ natural (human) languages and in systemsfor translating from one language to another. One particular case of inter-est is translating from a ﬁhigh-levelﬂ co.nputer language like Pascal (suitablefor human use) to a ﬁlow-levelﬂ assembly or machine language (suitable formachine execution). A program for doing such a translation is called a com-piler.Two general approaches are used for parsing. Top-down methods lookfor a legal program by first looking for parts of a legal program, then lookingfor parts of parts, etc. until the pieces are small enough to match the input
directly. Bottom-up methods put pieces of the input together in a structuredway making bigger and bigger pieces until a legal program is constructed.In general, top-down methods are recursive, bottom-up methods are iterative;top-down methods are thought to be easier to implement, bottom-up methodsare thought to be more efficient.A full treatment of the issues involved in parser and compiler constructionwould clearly be beyond the scope of thi>, book. However, by building a simpleﬁcompilerﬂ to complete the pattern-mats:hing algorithm of the previous chap-ter, we will be able to consider some of™ the fundamental concepts involved.First we™ll construct a top-down parser for a simple language for describingregular expressions. Then we™ll modify the parser to make a program whichtranslates regular expressions into pattern-matching machines for use by thematch procedure of the previous chapter.Our intent in this chapter is to give some feeling for the basic principles269
270CHAPTER 21of parsing and compiling while at the same time developing a useful patternmatching algorithm. Certainly we cannot treat the issues involved at the
level of depth that they deserve. The reader should be warned that subtle
difficulties are likely to arise in applying the same approach to similar prob-
lems, and advised that compiler construction is a quite well-developed field
with a variety of advanced methods available for serious applications.Context-Free GrammarsBefore we can write a program to determine whether a program written ina given language is legal, we need a description of exactly what constitutes
a legal program. This description is called a grammar: to appreciate the ter-
minology, think of the language as English and read ﬁsentenceﬂ for ﬁprogramﬂ
in the previous sentence (except for the first occurrence!). Programming lan-
guages are often described by a particular type of grammar called a context-free grammar. For example, the context-free grammar which defines the setof all legal regular expressions (as described in the previous chapter) is givenbelow.(expression) : : =(term) 1 (term) + (expression)(term) ::= (factor) 1 (factor)(term)(factor) ::= ((expression)) ( 21 1 (factor)*This grammar describes regular expressions like those that we used in the lastchapter, such as (l+Ol)*(O+l) or (A*B+AC)D. Each line in the grammar iscalled a production or replacement rule. The productions consist of terminalsymbols (, ), + and *which are the symbols used in the language beingdescribed (‚91,ﬂ a special symbol, stands for any letter or digit); nonterminalsymbols (expression), (term), and (factor) which are internal to the grammar;and metasymbols I:=and ( which are used to describe the meaning of theproductions. The ::= symbol, which may be read 2s a,ﬂ defines the left-handside of the production in terms of the right-hand side; and the 1 symbol, whichmay be read as ﬁorﬂ indicates alternative choices. The various productions,though expressed in this concise symbolic notation, correspond in a simpleway to an intuitive description of the grammar. For example, the secondproduction in the example grammar might be read ﬁa (term) is a (factor)or a (factor) followed by a (term).ﬂOne nonterminal symbol, in this case(expreswon), is distinguished in the sense that a string of terminal symbols isin the language described by the grammar if and only if there is some way touse the productions to derive that string from the distinguished nonterminal
by replacing (in any number of steps) a nonterminal symbol by any of the ﬁorﬂ
clauses on the right-hand side of a production for that nonterminal symbol.
PARSING271One natural way to describe the result of this derivation process is calleda purse tree: a diagram of the complete grammatical structure of the stringbeing parsed. For example, the following parse tree shows that the string
(A*B+AC)D is in the language described by the above grammar.The circled internal nodes labeled E, F, a.nd T represent (expression), (factor),and (term), respectively. Parse trees like this are sometimes used for English,to break down a ﬁsentenceﬂ into ﬁsubject,ﬂ ﬁverb,ﬂ ﬁobject,ﬂ etc.The main function of a parser is to accept strings which can be so derivedand reject those that cannot, by attempting to construct a parse tree forany given string. That is, the parser can recognize whether a string is in
the language described by the grammar by determining whether or not there
exists a parse tree for the string. Top-down parsers do so by building the
tree starting with the distinguished nonterminal at the top, working down
towards the string to be recognized at the bottom; bottom-up parsers do this
by starting with the string at the bottom, working backwards up towards the
distinguished nonterminal at the top.As we™ll see, if the strings being reo>gnized also have meanings implyingfurther processing, then the parser can convert them into an internal repre-sentation which can facilitate such processing.Another example of a context-free grammar may be found in the appen-dix of the Pascal User Manual and Report: it describes legal Pascal programs.The principles considered in this section for recognizing and using legal ex-pressions apply directly to the complex job of compiling and executing Pascal
272CHAPTER 21programs. For example, the following grammar describes a very small subsetof Pascal, arithmetic expressions involving addition and multiplication.(expression) ::=(term) 1 (term) + (expression)(term) ::= (factor) 1 (factor)* (term)(factor) ::= ((expression)) ) 21Again, w is a special symbol which stands for any letter, but in this grammarthe letters are likely to represent variables with numeric values. Examples oflegal strings for this grammar are A+(B*C) and (A+B*C)*D*(A+(B+C)).As we have defined things, some strings are perfectly legal both as arith-metic expressions and as regular expressions. For example, A*(B+C) mightmean ﬁadd B to C and multiply the result by Aﬂ or ﬁtake any number of A™sfollowed by either B or C.ﬂ This points out the obvious fact that checkingwhether a string is legally formed is one thing, but understanding what itmeans is quite another. We™ll return to this issue after we™ve seen how toparse a string to check whether or not it is described by some grammar.Each regular expression is itself an example of a context-free grammar:any language which can be described by a regular expression can also bedescribed by a context-free grammar. The converse is not true: for example,
the concept of ﬁbalancingﬂ parentheses can™t be captured with regular ex-pressions.Other types of grammars can describe languages which can™t bedescribed by context-free grammars. For example, context-sensitive grammarsare the same as those above except that the left-hand sides of productions
need not be single nonterminals. The differences between classes of languages
and a hierarchy of grammars for describing them have been very carefully
worked out and form a beautiful theory which lies at the heart of computerscience.Top-Down ParsingOne parsing method uses recursion to recognize strings from the languagedescribed exactly as specified by the grammar. Put simply, the grammar issuch a complete specification of the language that it can be turned directly
into a program!Each production corresponds to a procedure with the name of the non-terminal on the left-hand side. Nonterminals on the right-hand side of theinput correspond to (possibly recursive) procedure calls; terminals correspondto scanning the input string. For example, the following procedure is part ofa top-down parser for our regular expression grammar:
PARSING273procedure expression;beginterm ;if plj]=‚+™ thenbegin j:=j+ 1; expression endend ;An array p contains the regular expre:;sion being parsed, with an index jpointing to the character currently begin examined. To parse a given regularexpression, we put it in p[l..M], (with a sentinel character in p[M+l] whichis not used in the grammar) set j to 1, and call expression. If this results inj being set to M+1, then the regular ex 3ression is in the language describedby the grammar. Otherwise, we™ll see below how various error conditions arehandled.The first thing that expression does is call term, which has a slightly morecomplicated implementation:procedure term ;beginfact x-;if (1: b]=‚( ‚) or letter(ptj]) then term;endA direct translation from the grammar would simply have term call factorand then term. This obviously won™t work because it leaves no way toexit from term: this program would go into an infinite recursive loop ifcalled. (Such loops have particularly unpleasant effects in many systems.)The implementation above gets around this by first checking the input to
decide whether term should be called. l™he first thing that term does is callfactor, which is the only one of the proc:dures that could detect a mismatchin the input. From the grammar, we know that when factor is called, thecurrent input character must be either :L ﬁ(ﬂ or an input letter (representedby u). This process of checking the nez- t character (without incrementing jto decide what to do is called lookahead. For some grammars, this is notnecessary; for others even more lookahead is required.Now, the implementation of factor fallows directly from the grammar. Ifthe input character being scanned is not a ﬁ(ﬂ or an input letter, a procedureerror is called to handle the error condit on:
274CHAPTER 21procedure factor;beginif pb]=‚(‚thenbeginj:=j+l;expression ;if p b] = ‚) ™ then j : =j+ 1 else errorendelse if letter(plj]) then j:=j+l else error;if pb]=‚*‚then j:=j+l;end ;Another error condition occurs when a ﬁ)ﬂ is missing.These procedures are obviously recursive; in fact they are so intertwinedthat they can™t be compiled in Pascal without using the forward constructto get around the rule that a procedure can™t be used without first beingdeclared.The parse tree for a given string gives the recursive cal! structure duringparsing. The reader may wish to refer to the tree above and trace throughthe operation of the above three procedures when p contains (A*B+AC)D andexpression is called with j=1. This makes the origin of the ﬁtop-downﬂ nameobvious. Such parsers are also often called recursive descent parsers becausethey move down the parse tree recursively.The top-down approach won™t work for all possible context-free gram-mars. For example, if we had the production (expression) ::= v 1 (expression)+ (term) then we would haveprocedure badexpression ;beginif letter(pb]) then j:=j+l elsebeginbadexpression ;if p b] < > ‚+ ™ then error elsebegin j:=j+l; term endendend ;If this procedure were called with plj]a nonletter (as in our example, forj=l) then it would go into an infinite recursive loop. Avoiding such loops isa principal difficulty in the implementation of recursive descent parsers. For
PARSING275term, we used lookahead to avoid such a loop; in this case the proper way toget around the problem is to switch the grammar to say (term)+(expression).The occurrence of a nonterminal as the first thing on the right hand side ofa replacement rule for itself is called left recursion. Actually, the problem
is more subtle, because the left recursion can arise indirectly: for exampleif we were to have the productions (expression) ::= (term) and (term) ::=v 1 (expression) + (term). Recursive descent parsers won™t work for suchgrammars: they have to be transformed to equivalent grammars without leftrecursion, or some other parsing method has to be used. In general, there
is an intimate and very widely studied connection between parsers and the
grammars they recognize. The choice of a parsing technique is often dictated
by the characteristics of the grammar to be parsed.Bottom- Up ParsingThough there are several recursive calls in the programs above, it is an in-structive exercise to remove the recursion systematically. Recall from Chapter
9 (where we removed the recursion from Quicksort) that each procedure call
can be replaced by a stack push and each procedure return by a stack pop,
mimicking what the Pascal system does to implement recursion. A reasonfor doing this is that many of the calls which seem recursive are not trulyrecursive. When a procedure call is the last action of a procedure, then asimple goto can be used. This turns expression and term into simple loops,which can be incorporated together and combined with factor to produce asingle procedure with one true recursive call (the call to expression withinfactor).This view leads directly to a quite simple way to check whether regularexpressions are legal. Once all the procedure calls are removed, we see thateach terminal symbol is simply scanned as it is encountered. The only realprocessing done is to check whether there is a right parenthesis to match eachleft parenthesis and whether each ‚I+ﬂ is followed by either a letter or a ﬁ(I™.That is, checking whether a regular expression is legal is essentially equivalentto checking for balanced parentheses.This can be simply implemented bykeeping a counter, initialized to 0, which is incremented when a left paren-thesis is encountered, decremented when a right parenthesis is encountered.
If the counter is zero when the end of the expression is reached, and each ‚I+ﬂof the expression is followed by either a letter or a ﬁ(ﬁ, then the expressionwas legal.Of course, there is more to parsing than simply checking whether theinput string is legal: the main goal is to build the parse tree (even if in animplicit way, as in the top-down parser) for other processing. It turns out to
be possible to do this with programs with the same essential structure as the
parenthesis checker described in the previous paragraph. One type of parser
276CHAPTER 21which works in this way is the ‚so-called shift-reduce parser. The idea is tomaintain a pushdown stack which holds terminal and nonterminal symbols.Each step in the parse is either a shift step, in which the next input characteris simply pushed onto the stack, or a reduce step, in which the top characterson the stack are matched to the right-hand side of some production in thegrammar and ﬁreduced toﬂ (replaced by) the nonterminal on the left sideof that production. Eventually all the input characters get shifted onto thestack, and eventually the stack gets reduced to a single nonterminal symbol.The main difficulty in building a shift-reduce parser is deciding when toshift and when to reduce. This can be a complicated decision, dependingon the grammar. Various types of shift-reduce parsers have been studied ingreat detail, an extensive literature has been developed on them, and they arequite often preferred over recursive descent parsers because they tend to beslightly more efficient and significantly more flexible. Certainly we don™t have
space here to do justice to this field, and we™ll forgo even the details of an
implementation for our example.CompilersA compiler may be thought of as a program which translates from one lan-guage to another. For example, a Pascal compiler translates programs fromthe Pascal language into the machine language of some particular computer.We™ll illustrate one way that this might be done by continuing with ourregular-expression pattern-matching example, where we wish to translate
from the language of regular expressions to a ﬁlanguageﬂ for pattern-matching
machines, the ch, nextl, and next2 arrays of the match program of the pre-vious chapter.Essentially, the translation process is ﬁone-to-oneﬂ: for each character inthe pattern (with the exception of parentheses) we want to produce a statefor the pattern-matching machine (an entry in each of the arrays). The trickis to keep track of the information necessary to fill in the next1 and next2arrays. To do so, we™ll convert each of the procedures in our recursive descentparser into functions which create pattern-matching machines. Each functionwill add new states as necessary onto the end of the ch, nextl, and next2arrays, and return the index of the initial state of the machine created (thefinal state will always be the last entry in the arrays).For example, the function given below for the (expression) productioncreates the ﬁorﬂ states for the pattern matching machine.
PARSING277function expression : integer;var tl, t2: integer;begintl : = term ;expression : = tl ;if plj]=‚+™ thenbeginj:=j+l; state:=state+I;t2:=state; expression:=t2; state:=state+l;setstate(t2, ™ ‚,expression, tl ) ;setstate(t2-I, ™ ‚, state, state);end ;end ;This function uses a procedure setstate which simply sets the ch, nextl, andnext2 array entries indexed by the first argument to the values given in thesecond, third, and fourth arguments, respectively. The index state keeps trackof the ﬁcurrentﬂ state in the machine being built. Each time a new state is
created, state is simply incremented. Thus, the state indices for the machine
corresponding to a particular procedure call range between the value of state
on entry and the value of state on exit.The final state index is the valueof state on exit. (We don™t actually ﬁcreateﬂ the final state by incrementingstate before exiting, since this makes it easy to ﬁmergeﬂ the final state with
later initial states, as we™ll see below.)With this convention, it is easy to check (beware of the recursive call!)that the above program implements the rule for composing two machines withthe ﬁorﬂ operation as diagramed in the previous chapter. First the machine
for the first part of the expression is built (recursively), then two new null
states are added and the second part of the expression built. The first null
state (with index t2--1) is the final state of the machine of the first part ofthe expression which is made into a ﬁno-opﬂ state to skip to the final state forthe machine for the second part of the expression, as required. The second
null state (with index t2) is the initial state, so its index is the return value
for expression and its next1 and next2 entries are made to point to the initialstates of the two expressions. Note carefully that these are constructed in theopposite order than one might expect, because the value of state for the no-opstate is not known until the recursive call to expression has been made.The function for (term) first builds the machine for a (factor) then, ifnecessary, merges the final state of that machine with the initial state of themachine for another (term). This is easier done than said, since state is thefinal state index of the call to factor. A call to term without incrementingstate does the trick:
278CHAPTER 21function term ;var t: integer;beginterm :=factor;if (pb]=‚(‚) or letter(p[j]) then t:=termend ;(We have no use for the initial state index returned by the second call toterm, but Pascal requires us to put it, somewhere, so we throw it away in atemporary variable t.)The function for (factor) uses similar techniques to handle its three cases:a parenthesis calls for a recursive call on expression; a v calls for simpleconcatenation of a new state; and a * calls for operations similar to those inexpression, according to the closure diagram from the previous section:function factor;var tl, t2: integer;begintl :=state;if plj]=‚(‚thenbeginj:=j+l; t2:=expression;if p b] = ‚) ™ then j := j+ 1 else errorendelse if letter(pb]) thenbeginsetstate(state,plj], state+l, 0);t2:=state; j:=j+l; state:=state+Iendelse error;if p[j]<>‚*‚then factor:=t2 elsebeginsetstate(state,™ ‚, state+l, t2);factor:=state; next1 [tl-I] :=state;j:=j+l; state:=state+l;end ;end ;The reader may find it instructive to trace through the construction ofthe machine for the pattern (A*B+AC)D given in the previous chapter.
PARSING279The final step in the development >f a general regular expression pat-tern matching algorithm is to put these procedures together with the matchprocedure, as follows:j:==l; state:=l;ne Ytl [0] :=expression;setstate(state, ™ ‚, 0,O);foI i:=l to N-l doif match(i)>=i then writeln(i);This program will print out all character positions in a text string a[l.. . N]where a pattern p[l.. .M] leads to a match.Compiler-CompilersThe program for general regular expresr:ion pattern matching that we havedeveloped in this and the previous chapter is efficient and quite useful. Aversion of this program with a few added capabilities (for handling ﬁdon™t-careﬂ characters and other amenities) is likely to be among the most heavilyused utilities on many computer systems.It is interesting (some might say confusing) to reflect on this algorithmfrom a more philosophical point of view. In this chapter, we have consideredparsers for unraveling the structure of regular expressions, based on a formaldescription of regular expressions using a context-free grammar. Put anotherway, we used the context-free gramma]™ to specify a particular ﬁpatternﬂ:sequences of characters with legally balz.nced parentheses. The parser thenchecks to see if the pattern occurs in the input (but only considers a matchlegal if it covers the entire input string). Thus parsers, which check that aninput string is in the set of strings defined by some context-free grammar,and pattern matchers, which check that an input string is in the set ofstrings defined by some regular expression, are essentially performing the samefunction! The principal difference is that context-free grammars are capableof describing a much wider class of strings. For example, the set of all regularexpressions can™t be described with regular expressions.Another difference in the way we™ve implemented the programs is that thecontext-free grammar is ﬁbuilt inﬂ to the parser, while the match procedureis ﬁtable-drivenﬂ: the same program wol,ks for all regular expressions, oncethey have been translated into the propel. format. It turns out to be possibleto build parsers which are table-driven In the same way, so that the sameprogram can be used to parse all language 3 which can be described by context-free grammars. A parser generator is a program which takes a grammar asinput and produces a parser for the language described by that grammar as
280CHAPTER 21output. This can be carried one step further: it is possible to build compilerswhich are table-driven in terms of both the input and the output languages. Acompiler-compiler is a program which takes two grammars (and some formalspecification of the relationships between them) as input and produces acompiler which translates strings from one language to the other as output.Parser generators and compiler-compilers are available for general use inmany computing environments, and are quite useful tools which can be usedto produce efficient and reliable parsers and compilers with a relatively small
amount of effort. On the other hand, top-down recursive descent parsers of the
type considered here are quite serviceable for simple grammars which arise in
many applications. Thus, as with many of the algorithms we have considered,
we have a straightforward method which can be used for applications where
a great deal of implementation effort might not be justified, and several ad-
vanced methods which can lead to significant performance improvements forlarge-scale applications. Of course, in this case, this is significantly understat-ing the point: we™ve only scratched the surface of this extensively researched
PARSING281Exercises1.2.3.4.5.6.7.
8.9.10.How does the recursive descent parser find an error in a regular expressionsuch as (A+B)*BC+ which is incomplete?Give the parse tree for the regular expression ((A+B)+(Ct-D)*)*.Extend the arithmetic expression grammar to include exponentiation, divand mod.Give a context-free grammar to d™:scribe all strings with no more thantwo consecutive 1™s.How many procedure calls are used by the recursive descent parser torecognize a regular expression in terms of the number of concatenation,or, and closure operations and the number of parentheses?Give the ch, next1 and next2 arrays that result from building the patternmatching machine for the pattern ((A+B)+(C+D)*)*.Modify the regular expression grammar to handle the ﬁnotﬂ function andﬁdon™t-careﬂ characters.Build a general regular expression pattern matcher based on the improvedgrammar in your answer to the previous question.Remove the recursion from the recursive descent compiler, and simplifythe resulting code as much as possible. Compare the running time of thenonrecursive and recursive methods.Write a compiler for simple arithmetic expressions described by the gram-mar in the text. It should produce a list of ‚*instructionsﬂ for a machinecapable of three operations: Pugh the value of a variable onto a stack;add the top two values on the stick, removing them from the stack, thenputting the result there; and mt.ltiply the top two values on the stack, inthe same way.

22. File CompressionFor the most part, the algorithms that we have studied have been de-signed primarily to use as little time as possible and only secondarily toconserve space.In this section, we™ll examine some algorithms with the op-posite orientation: methods designed primarily to reduce space consumptionwithout using up too much time. Ironically, the techniques that we™ll examineto save space are ﬁcodingﬂ methods from information theory which were de-veloped to minimize the amount of information necessary in communicationssystems and therefore originally intended to save time (not space).In general, most files stored on computer systems have a great deal ofredundancy. The methods we will examine save space by taking advantageof the fact that most files have a relatively low ﬁinformation content.ﬂ File
compression techniques are often used for text files (in which certain charac-
ters appear much more often than others), ﬁrasterﬂ files for encoding pictures
(which can have large homogeneous areas), and files for the digital repre-
sentation of sound and other analog signals (which can have large repeated
patterns).We™ll look at an elementary algorithm for the problem (which is still quiteuseful) and an advanced ﬁoptimalﬂ method. The amount of space saved bythese methods will vary depending on characteristics of the file. Savings of
20% to 50% are typical for text files, and savings of 50% to 90% might be
achieved for binary files. For some types of files, for example files consisting
of random bits, little can be gained. In fact, it is interesting to note that any
general-purpose compression method must make some files longer (otherwise
we could continually apply the method to produce an arbitrarily small file).On one hand, one might argue that file compression techniques are lessimportant than they once were because the cost of computer storage deviceshas dropped dramatically and far more storage is available to the typical userthan in the past. On the other hand, it can be argued that file compression283
CHAPTER 22techniques are more important than ever because, since so much storage is inuse, the savings they make possible are greater. Compression techniques arealso appropriate for storage devices which allow extremely high-speed accessand are by nature relatively expensive (and therefore small).Run-Length EncodingThe simplest type of redundancy in a file is long runs of repeated characters.For example, consider the following string:AAAABBBAABBBBBCCCCCCCCDABCBAAABBBBCCCDThis string can be encoded more compactly by replacing each repeatedstring of characters by a single instance of the repeated character along witha count of the number of times it was repeated. We would like to say that thisstring consists of 4 A™s followed by 3 B™s followed by 2 A™s followed by 5 B™s,etc. Compressing a string in this way is called run-length encoding. Thereare several ways to proceed with this idea, depending on characteristics of theapplication. (Do the runs tend to be relatively long? How many bits are usedto encode the characters being encoded?) We™ll look at one particular method,then discuss other options.If we know that our string contains just letters, then we can encodecounts simply by interspersing digits with the letters, thus our string mightbe encoded as follows:Here ﬁ4Aﬂ means ﬁfour A™s,ﬂand so forth. Note that is is not worthwhileto encode runs of length one or two, since two characters are needed for theencoding.For binary files (containing solely O™s and l™s), a refined version of thismethod is typically used to yield dramatic savings. The idea is simply to storethe run lengths, taking advantage of the fact that the runs alternate between
0 and 1 to avoid storing the O™s and l™s themselves. (This assumes that there
are few short runs, but no run-length encoding method will work very well
unless most of the runs are long.) For example, at the left in the figure
below is a ﬁrasterﬂ representation of the letter ﬁqﬂ lying on its side, which isrepresentative of the type of information that might have to be processed by atext formatting system (such as the one used to print this book); at the right
is a list of numbers which might be used to store the letter in a compressed
form.
FILE COMPRESSION000000000000000000000000000011111111111111000000000000000000000000000000000001111111111111111110000000000000000000000000000001111111111111111111111110000
0000000000000000000000111111111111111111111111110000000000000000000000011111111111111111111111111111100000000000000000000111111100000000000000~0001111111000000000000000000011111000000000000000000000011111000000000000000000011100000000000000000000000000111
000000000000000000011100000000000000000000000000111
000000000000000000011100000000000000000000000000111
0000000000000000000111000000000000000000000000001110000000000000000000011110000000000000000000000011100000000000000000000000111000000000000000000001110000111111111111111111111111111111111111111111111111110111111111111111111111111111111111111111111111111110111111111111111111111111111111111111111111111111110111111111111111111111111111111111111111111111111110!111111111111111111111111111111111111111111111111101100000000000000000000000000000000000000000000001128528 14 926 18 723 24 4
22 26 3
20 30 119 7 18 719 5 22 5
19 3 26 3
19 3263
19 3 26 3
19 3 26 3
20 4 23 3 122 3 20 3 31 501 50
1 501 501 50
1 2462That is, the first line consists of 28 O™s followed by 14 l™s followed by 9 moreO™s, etc. The 63 counts in this table plus the number of bits per line (51)contain sufficient information to reconstruct the bit array (in particular, notethat no ﬁend of lineﬂ indicator is needed). If six bits are used to represent each
count, then the entire file is represented with 384 bits, a substantial savings
over the 975 bits required to store it explicitly.Run-length encoding requires a separate representation for the file to beencoded and the encoded version of the file, so that it can™t work for all files.This can be quite inconvenient: for example, the character file compressionmethod suggested above won™t work for character strings that contain digits.If other characters are used to encode the counts, it won™t work for stringsthat contain those characters. To illustrate a way to encode any string froma fixed alphabet of characters using only characters from that alphabet, we™ll
assume that we only have the 26 letters of the alphabet (and spaces) to work
with.How can we make some letters represent digits and others representparts of the string to be encoded? One solution is to use some characterwhich is likely to appear rarely in the text as a so-called escape character.Each appearance of that character signals that the next two letters form a(count,character) pair, with counts represented by having the ith letter ofthe alphabet represent the number i.Thus our example string would berepresented as follows with Q as the escape character:
286CHAPTER 22QDABBBAAQEBQHCDABCBAAAQDBCCCDThe combination of the escape character, the count, and the one copyof the repeated character is called an escape sequence. Note that it™s notworthwhile to encode runs less than four characters long since at least threecharacters are required to encode any run.But what if the escape character itself happens to occur in the input?We can™t afford to simply ignore this possibility, because it might be difficultto ensure that any particular character can™t occur. (For example, someone
might try to encode a string that has already been encoded.) One solution to
this problem is to use an escape sequence with a count of zero to represent the
escape character. Thus, in our example, the space character could representzero, and the escape sequence ﬁQ(space)ﬂ would be used to represent anyoccurrence of Q in the input. It is interesting to note that files which containQ are the only files which are made longer by this compression method. If a
file which has already been compressed is compressed again, it grows by at
least the number of characters equal to the number of escape sequences used.Very long runs can be encoded with multiple escape sequences. Forexample, a run of 51 A™s would be encoded as QZAQYA using the conventionsabove. If many very long runs are expected, it would be worthwhile to reservemore than one character to encode the counts.In practice, it is advisable to make both the compression and expansionprograms somewhat sensitive to errors. This can be done by including a smallamount of redundancy in the compressed file so that the expansion program
can be tolerant of an accidental minor change to the file between compressionand expansion. For example, it probably is worthwhile to put ﬁend-of-lineﬂcharacters in the compressed version of the letter ﬁqﬂ above, so that theexpansion program can resynchronize itself in case of an error.Run-length encoding is not particularly effective for text files because theonly character likely to be repeated is the blank, and there are simpler ways toencode repeated blanks. (It was used to great advantage in the past to com-press text files created by reading in punched-card decks, which necessarilycontained many blanks.) In modern systems, repeated strings of blanks are
never entered, never stored: repeated strings of blanks at the beginning oflines are encoded as ﬁtabs,ﬂ blanks at the ends of lines are obviated by theuse of ﬁend-of-lineﬂ indicators. A run-length encoding implementation like
the one above (but modified to handle all representable characters) saves only
about 4% when used on the text file for this chapter (and this savings allcomes from the letter ﬁqﬂ example!).Variable-Length EncodingIn this section we™ll examine a file compression technique called Huffman
FILE COMPRESSION287encoding which can save a substantial amount of space on text files (andmany other kinds of files). The idea is to abandon the way that text files areusually stored: instead of using the usual seven or eight bits for each character,Huffman™s method uses only a few bits for characters which are used often,more bits for those which are rarely used.It will be convenient to examine how the code is used before consideringhow it is created. Suppose that we wish to encode the string ﬁA SIMPLESTRING TO BE ENCODED USING A MINIMAL NUMBER OF BITS.ﬂEncoding it in our standard compact binary code with the five-bit binaryrepresentation of i representing the ith letter of the alphabet (0 for blank)gives the following bit sequence:000010000010011010010110110000011000010100000100111010010010010010111000111000001010001111
000000001000101000000010101110000110111100100
001010010000000101011001101001011100011100000
000010000001101010010111001001011010000101100
000000111010101011010001000101100100000001111
001100000000010010011010010011To ﬁdecodeﬂ this message, simply read off five bits at a time and convertaccording to the binary encoding defined above. In this standard code, the
C, which appears only once, requires the same number of bits as the I, which
appears six times. The Huffman code achieves economy in space by encodingfrequently used characters with as few bits as possible so that the total numberof bits used for the message is minimized.The first step is to count the frequency of each character within themessage to be encoded. The following code fills an array count[0..26] with thefrequency counts for a message in a character array a[l..M]. (This programuses the index procedure described in Chapter 19 to keep the frequency countfor the ith letter of the alphabet in count[i], with count[0] used for blanks.)for i:=O to 26 do count [i] :=O;for i:=l to M docount[index(a[i])] :=count[index(a[i])]+1;For our example string, the count table produced is0 1 2 3 4 5 6 7 8 910111213141516 171819202122232425261133125120600245310243200000
288CHAPTER 22which indicates that there are eleven blanks, three A™s, three B™s, etc.The next step is to build a ﬁcoding treeﬂ from the bottom up accordingto the frequencies. First we create a tree node for each nonzero frequencyfrom the table above:Now we pick the two nodes with the smallest frequencies and create a newnode with those two nodes as sons and with frequency value the sum of the
values of the sons:(It doesn™t matter which nodes are used if there are more than two with thesmallest frequency.) Continuing in this way, we build up larger and larger
subtrees. The forest of trees after all nodes with frequency 2 have been put
in is as follows:Next, the nodes with frequency 3 are put together, creating two new nodesof frequency 6, etc. Ultimately, all the nodes are combined together into asingle tree:
FILE COMPRESSION289c!lb1 1c PNote that nodes with low frequencies end up far down in the tree and nodeswith high frequencies end up near the root of the tree. The numbers labelingthe external (square) nodes in this tree are the frequency counts, while thenumber labeling each internal (round) node is the sum of the labels of its
two sons. The small number above each node in this tree is the index intothe count array where the label is stored, for reference when examining theprogram which constructs the tree below. (The labels for the internal nodeswill be stored in count[27..51] in an order determined by the dynamics of theconstruction.) Thus, for example, the 5 in the leftmost external node (thefrequency count for N) is stored in count [14], the 6 in the next external node(the frequency count for I) is stored in count [9], and the 11 in the father ofthese two is stored in count[33], etc.It turns out that this structural description of the frequencies in the formof a tree is exactly what is needed to create an efficient encoding. Beforelooking at this encoding, let™s look at the code for constructing the tree.The general process involves removing the smallest from a set of unorderedelements, so we™ll use the pqdownheap procedure from Chapter 11 to build andmaintain an indirect heap on the frequency values. Since we™re interested insmall values first, we™ll assume that the sense of the inequalities in pqdownheaphas been reversed. One advantage of using indirection is that it is easy toignore zero frequency counts. The following table shows the heap constructed
for our example:
290CWTER 22k123456789101112131415161718heap PI371621121562094131452181910count[heap[k]]1212231362455324311Specifically, this heap is built by first initializing the heap array to point tothe non-zero frequency counts, then using the pqdownheap procedure fromChapter 11, as follows:N:=O;for i:=O to 26 doif count [i] < > 0 thenbegin N:=N+I; heap[N] :=i end;for k:=N downto 1 do pqdownheap(k);As mentioned above, this assumes that the sense of the inequalities in thepqdownheap code has been reversed.Now, the use of this procedure to construct the tree as above is straightfor-ward: we take the two smallest elements off the heap, add them and put theresult back into the heap. At each step we create one new count, and decrease
the size of the heap by one. This process creates N-l new counts, one for
each of the internal nodes of the tree being created, as in the following code:repeatt:=heap[l]; heap[l]:=heap[N]; N:=N-1;pqdownheap(l);count[26+N]:=count[heap[I]]+count[t];dad[t]:=26+N; dad[heap[l]]:=-26-N;heap[l]:=26+N; pqdownheap(1);until N= 1;dad[26+N] :=O;The first two lines of this loop are actually pqremove; the size of the heap isdecreased by one. Then a new internal node is ﬁcreatedﬂ with index 26+Nandgiven a value equal to the sum of the value at the root and value just removed.Then this node is put at the root, which raises its priority, necessitating
another call on pqdownheap to restore order in the heap. The tree itself is
represented with an array of ﬁfatherﬂ links: dad[t] is the index of the fatherof the node whose weight is in count [t]. The sign of dad[t] indicates whetherthe node is a left or right son of its father. For example, in the tree abovewe might have dad[O]=-30, count[30]=21, dad[30]=-28, and count[28]=37
FILE COMPRESSION291(indicating that the node of weight 21 has index 30 and its father has index28 and weight 37).The Huffman code is derived from this coding tree simply by replacing thefrequencies at the bottom nodes with the associated letters and then viewingthe tree as a radix search trie:CPNow the code can be read directly from this tree. The code for N is 000,the code for I is 001, the code for C is 110100, etc. The following program
fragment reconstructs this information from the representation of the coding
tree computed during the sifting process. The code is represented by two
arrays: code[k] gives the binary representation of the kth letter and len [k]gives the number of bits from code[k] to use in the code. For example, I isthe 9th letter and has code 001, so code [9]=1 and len [ 9]=3.
292CHAPTER 22for k:=O to 26 doif count[k]=O thenbegin code[k] :=O; len[k] :=O endelsebegini:=O; j:=l; t:=dad[k]; x:=0;repeatif t<O then begin x:=x+j; t:=--t end;t:=dad[t]; j:=j+j; i:=i+Iuntil t=O;code[k] :=x; len[k] :=i;end ;Finally, we can use these computed representations of the code to encode themessage:for j:=l to M dofor i:=Ien[index(ab])] downto 1 dowrite(bits(code[index(ab])],i-I, 1):1);This program uses the bits procedure from Chapters 10 and 17 to access singlebits. Our sample message is encoded in only 236 bits versus the 300 used forthe straightforward encoding, a 21% savings:01101111001001101011010110001110011110011101110111001000011111111101101001110101110011111000001101000100101101100101101111000010010010000111111101101111010001000001101001101000111100010000101001011100101111110100011101110101001110111001An interesting feature of the Huffman code that the reader undoubtedlyhas noticed is that delimiters between characters are not stored, even thoughdifferent characters may be coded with different numbers of bits. How canwe determine when one character stops and the next begins to decode themessage? The answer is to use the radix search trie representation of thecode. Starting at the root, proceed down the tree according to the bits in themessage: each time an external node is encountered, output the character atthat node and restart at the root. But the tree is built at the time we encode
FlLE COMPRESSION293the message: this means that we need to save the tree along with the messagein order to decode it. Fortunately, this does not present any real difficulty.
It is actually necessary only to store the code array, because the radix search
trie which results from inserting the entries from that array into an initially
empty tree is the decoding tree.Thus, the storage savings quoted above is not entirely accurate, becausethe message can™t be decoded without the trie and we must take into accountthe cost of storing the trie (i.e.,the code array) along with the message.Huffman encoding is therefore only effective for long files where the savings inthe message is enough to offset the cost, or in situations where the coding triecan be precomputed and used for a large number of messages. For example, atrie based on the frequencies of occurrence of letters in the English languagecould be used for text documents.For that matter, a trie based on thefrequency of occurrence of characters in Pascal programs could be used forencoding programs (for example,ﬁ;ﬂ is likely to be near the top of such atrie). A Huffman encoding algorithm saves about 23% when run on the textfor this chapter.As before, for truly random files, even this clever encoding scheme won™twork because each character will occur approximately the same number oftimes, which will lead to a fully balanced coding tree and an equal number ofbits per letter in the code.I
2941.2.3.4.5.6.7.8.9.10.ExercisesImplement compression and expansion procedures for the run-length en-coding method for a fixed alphabet described in the text, using Q as theescape character.Could ﬁQQﬂ occur somewhere in a file compressed using the methoddescribed in the text? Could ﬁQQ&ﬂ occur?Implement compression and expansion procedures for the binary file en-coding method described in the text.The letter ﬁqﬂ given in the text can be processed as a sequence of five-bit characters. Discuss the pros and cons of doing so in order to use acharacter-based run-length encoding method.Draw a Huffman coding tree for the string ﬁABRACADABRA.ﬂ Howmany bits does the encoded message require?What is the Huffman code for a binary file? Give an example showingthe maximum number of bits that could be used in a Huffman code for aN-character ternary (three-valued) file.Suppose that the frequencies of the occurrence of all the characters to beencoded are different. Is the Huffman encoding tree unique?Huffman coding could be extended in a straightforward way t,o encodein two-bit characters (using 4-way trees). What would be the mainadvantage and the main disadvantage of doing so?What would be the result of breaking up a Huffman-encoded string intofive-bit characters and Huffman encoding that string?Implement a procedure to decode a Huffman-encoded string, given thecode and len arrays.
23. CryptologyIn the previous chapter we looked at methods for encoding strings ofcharacters to save space. Of course, there is another very importantreason to encode strings of characters: to keep them secret.Cryptology, the study of systems for secret communications, consists oftwo competing fields of study: cryptography, the design of secret communica-tions systems, and cryptanalysis, the study of ways to compromise secret com-munications systems. The main application of cryptology has been in militaryand diplomatic communications systems, but other significant applications
are becoming apparent. Two principal examples are computer file systems
(where each user would prefer to keep his files private) and ﬁelectronic funds
transferﬂ systems (where very large amounts of money are involved). A com-
puter user wants to keep his computer files just as private as papers in his
file cabinet, and a bank wants electronic funds transfer to be just as secure
as funds transfer by armored car.Except for military applications, we assume that cryptographers are ﬁgoodguysﬂ and cryptanalysts are ﬁbad guysﬂ:our goal is to protect our computerfiles and our bank accounts from criminals. If this point of view seems some-what unfriendly, it must be noted (without being over-philosophical) that by
using cryptography one is assuming the existence of unfriendliness! Of course,even ﬁgood guysﬂ must know something about cryptanalysis, since the verybest way to be sure that a system is secure is to try to compromise it yourself.(Also, there are several documented instances of wars being brought to anend, and many lives saved, through successes in cryptanalysis.)Cryptology has many close connections with computer science and al-gorithms, especially the arithmetic and string-processing algorithms that wehave studied. Indeed, the art (science?) of cryptology has an intimate relation-ship with computers and computer science that is only beginning to be fullyunderstood. Like algorithms, cryptosystems have been around far longer295
296CHAPTER 23than computers. Secrecy system design and algorithm design have a commonheritage, and the same people are attracted to both.It is not entirely clear which branch of cryptology has been affected mostby the availability of computers. The cryptographer now has available a muchmore powerful encryption machine than before, but this also gives him moreroom to make a mistake. The cryptanalyst has much more powerful tools
for breaking codes, but the codes to be broken are more complicated than
ever before. Cryptanalysis can place an incredible strain on computationalresources; not only was it among the first applications areas for computers,but it still remains a principal applications area for modern supercomputers.More recently, the widespread use of computers has led to the emergenceof a variety of important new applications for cryptology, as mentioned above.New cryptographic methods have recently been developed appropriate for such
applications, and these have led to the discovery of a fundamental relationship
between cryptology and an important area of theoretical computer sciencethat we™ll examine briefly in Chapter 40.In this chapter, we™ll examine some of the basic characteristics of cryp-tographic algorithms because of the importance of cryptography in moderncomputer systems and because of close relationships with many of the algo-
rithms we have studied. We™ll refrain from delving into detailed implementa-
tions: cryptography is certainly a field that should be left to experts. While
it™s not difficult to ﬁkeep people honestﬂ by encrypting things with a simple
cryptographic algorithm, it is dangerous to rely upon a method implemented
by a non-expert.Rules of the GameAll the elements that go into providing a means for secure communicationsbetween two individuals together are called a cryptosystem. The canonicalstructure of a typical cryptosystem is diagramed below:ﬁattackat dawnﬂThe sender (S) wishes to send a message (called the plaintezt) to thereceiver (R). To do so, he transforms the plaintext into a secret form suitable
CRYPTOLOGYfor transmission (called the ciphertext) using a cryptographic algorithm (theencryption method) and some key (K) parameters. To read the message,the receiver must have a matching cryptographic algorithm (the decryptionmethod) and the same key parameters, which he can use to transform theciphertext back into the plaintext, the message. It is usually assumed thatthe ciphertext is sent over insecure communications lines and is available to
the cryptanalyst (A). It also is usually assumed that the encryption anddecryption methods are known to the cryptanalyst: his aim is to recover theplaintext from the ciphertext without knowing the key parameters. Note that
the whole system depends on some separate prior method of communication
between the sender and receiver to agree on the key parameters. As a rule,
the more key parameters, the more secure the cryptosystem is but the more
inconvenient it is to use. This situation is akin to that for more conventional
security systems: a combination safe is more secure with more numbers on the
combination lock, but it is harder to remember the combination. The parallelwith conventional systems also serves as a reminder that any security systemis only as secure as the trustworthiness of the people that have the key.It is important to remember that economic questions play a central rolein cryptosystems. There is an economic motivation to build simple encryptionand decryption devices (since many may need to be provided and complicated
devices cost more).Also, there is an economic motivation to reduce theamount of key information that must be distributed (since a very secure andexpensive method of communications must be used). Balanced against the cost
of implementing cryptographic algorithms and distributing key information
is the amount of money the cryptanalyst would be willing to pay to break
the system. For most applications, it is the cryptographer™s aim to develop alow-cost system with the property that it would cost the cryptanalyst muchmore to read messages than he would be willing to pay. For a few applications,
a ﬁprovably secureﬂ cryptosystem may be required: one for which it can be
ensured that the cryptanalyst can never read messages no matter what he iswilling to spend. (The very high stakes in some applications of cryptologynaturally imply that very large amounts of money are used for cryptanalysis.)
In algorithm design, we try to keep track of costs to help us choose the best
algorithms; in cryptology, costs play a central role in the design process.Simple MethodsAmong the simplest (and among the oldest) methods for encryption is theCaesar cipher: if a letter in the plaintext is the Nth letter in the alphabet,replace it by the (N + K)th letter in the alphabet, where K is some fixedinteger (Caesar used K = 3). For example, the table below shows how amessage is encrypted using this method with K = 1:
298CHAPTER 23Plaintext:ATTACK AT DAWNCiphertext:BUUBDLABUAEB X 0This method is weak because the cryptanalyst has only to guess the valueof K: by trying each of the 26 choices, he can be sure that he will read themessage.A far better method is to use a general table to define the substitutionto be made: for each letter in the plaintext, the table tells which letter to putin the ciphertext. For example, if the table gives the correspondenceABCDEFGHI JKLMNOPQRSTUVWXYZTHE QUICKBROWNFXJMPDVRLAZYGthen the message is encrypted as follows:Plaintext:ATTACK AT DAWNCiphertext: HWH OTHVTQHAFThis is much more powerful than the simple Caesar cipher because the crypt-analyst would have to try many more (about 27! > 1028) tables to be sureof reading the message. However,ﬁsimple substitutionﬂ ciphers like this areeasy to break because of letter frequencies inherent in the language. For ex-ample, since E is the most frequent letter in English text, the cryptanalyst
could get good start on reading the message by looking for the most frequent
letter in the ciphertext and assuming that it is to be replaced by E. While
this might not be the right choice, he certainly is better off than if he had to
try all 26 letters. He can do even better by looking at two-letter combinations(ﬁdigramsﬂ): certain digrams (such as QJ) never occur in English text whileothers (such as ER) are very common. By examining frequencies of lettersand combinations of letters, a cryptanalyst can very easily break a simplesubstitution cipher.One way to make this type of attack more difficult is to use more thanone table. A simple example of this is an extension of the Caesar cipher calledthe Vigenere cipher: a small repeated key is used to determine the value of Kfor each letter. At each step, the key letter index is added to the plaintextletter index to determine the ciphertext letter index. Our sample plaintext,
with the key ABC, is encrypted as follows:Key:ABCABCABCABCABPlaintext:ATTACK AT DAWNCiphertext: BVWBENACWAFDX P
CRYPTOLOGY299For example, the last letter of the ciphertext is P, the 16th letter of thealphabet, because the corresponding plaintext letter is N (the 14th letter),and the corresponding key letter is B (the 2nd letter).The Vigenere cipher can obviously be made more complicated by usingdifferent general tables for each letter of the plaintext (rather than simpleoffsets). Also, it is obvious that the longer the key, the better. In fact, if the
key is as long as the plaintext, we have the V&am cipher, more commonlycalled the one-time pad. This is the only provably secure cryptosystem known,and it is reportedly used for the Washington-Moscow hotline and other vitalapplications. Since each key letter is used only once, the cryptanalyst can
do no better than try every possible key letter for every message position,
an obviously hopeless situation since this is as difficult as trying all possible
messages. However, using each key letter only once obviously leads to a severe
key distribution problem, and the one-time pad is only useful for relatively
short messages which are to be sent infrequently.If the message and key are encoded in binary, a more common schemefor position-by-position encryption is to use the ﬁexclusive-orﬂ function: toencrypt the plaintext, ﬁexclusive-orﬂ it (bit by bit) with the key. An attractivefeature of this method is that decryption is the same operation as encryption:the ciphertext is the exclusive-or of the plaintext and the key, but doinganother exclusive-or of the ciphertext and the key returns the plaintext.
Notice that the exclusive-or of the ciphertext and the plaintext is the key.
This seems surprising at first, but actually many cryptographic systems have
the property that the cryptanalyst can discover the key if he knows the
plaintext.Encryption/Decryption MachinesMany cryptographic applications (for example, voice systems for militarycommunications) involve the transmission of large amounts of data, and thismakes the one-time pad infeasible. What is needed is an approximation tothe one-time pad in which a large amount of ﬁpseudo-keyﬂ can be generatedfrom a small amount of true key to be distributed.The usual setup in such situations is as follows: an encryption machineis fed some cryptovariables (true key) by the sender, which it uses to generatea long stream of key bits (pseudo-key). The exclusive-or of these bits andthe plaintext forms the ciphertext.The receiver, having a similar machineand the same cryptovariables, uses them to generate the same key stream toexclusive-or against the ciphertext and to retrieve the plaintext.Key generation in this context is obviously very much like random numbergeneration, and our random number generation methods are appropriate forkey generation (the cryptovariables are the initial seeds of the random number
300CHAPTER 23generator). In fact, the linear feedback shift registers that we discussed inChapter 3 were first developed for use in encryption/decryption machinessuch as described here. However, key generators have to be somewhat morecomplicated than random number generators, because there are easy ways toattack simple linear feedback shift registers. The problem is that it might beeasy for the cryptanalyst to get some plaintext (for example, silence in a voicesystem), and therefore some key. If the cryptanalyst can get enough key thathe has the entire contents of the shift register, then he can get all the keyfrom that point on.Cryptographers have several ways to avoid such problems. One way is tomake the feedback function itself a cryptovariable. It is usually assumed thatthe cryptanalyst knows everything about the structure of the machine (maybe
he stole one) except the cryptovariables, but if some of the cryptovariables are
used to ﬁconfigureﬂ the machine, he may have difficulty finding their values.
Another method commonly used to confuse the cryptanalyst is the productcipher, where two different machines are combined to produce a complicatedkey stream (or to drive each other). Another method is nonlinear substitution;here the translation between plaintext and ciphertext is done in large chunks,
not bit-by-bit. The general problem with such complex methods is that theycan be too complicated for even the cryptographer to understand and thatthere always is the possibility that things may degenerate badly for somechoices of the cryptovariables.Public-Key CryptosystemsIn commercial applications such as electronic funds transfer and (real) com-puter mail, the key distribution problem is even more onerous than in the
traditional applications of cryptography.The prospect of providing longkeys (which must be changed often) to every citizen, while still maintain-ing both security and cost-effectiveness, certainly inhibits the development ofsuch systems. Methods have recently been developed, however, which promiseto eliminate the key distribution problem completely. Such systems, calledpublic-key cryptosystems, are likely to come into widespread use in the nearfuture. One of the most prominent of these systems is based on some of thearithmetic algorithms that we have been studying, so we will take a close look
at how it works.The idea in public-key cryptosystems is to use a ﬁphone bookﬂ of encryp-tion keys. Everyone™s encryption key (denoted by P) is public knowledge: aperson™s key could be listed, for example, next to his number in the telephone
book. Everyone also has a secret key used for decryption; this secret key
(denoted by S) is not known to anyone else. To transmit a message M, the
sender looks up the receiver™s public key, uses it to encrypt the message, and
then transmits the message. We™ll denote the encrypted message (ciphertext)
CRYPTOLOGYby C=P(M). The receiver uses his private decryption key to decrypt and readthe message. For this system to work we must have at least the following
properties:(4S(P(M))=M for every message M.(ii)All (S,P) pairs are distinct.(iii)Deriving S from P is as hard as reading M.(iv)Both S and P are easy to compute.The first of these is a fundamental cryptographic property, the second twoprovide the security, and the fourth makes the system feasible for use.This general scheme was outlined by W. Diffie and M. Hellman in 1976,but they had no method which satisfied all of these properties. Such amethod was discovered soon afterwards by R. Rivest, A. Shamir, and L.Adleman. Their scheme, which has come to be known as the RSA public-key cryptosystem, is based on arithmetic algorithms performed on very largeintegers. The encryption key P is the integer pair (N,p) and the decryptionkey S is the integer pair (N,s), where s is kept secret. These numbers areintended to be very large (typically, N might be 200 digits and p and s mightbe 100 digits). The encryption and decryption methods are then simple: firstthe message is broken up into numbers less than N (for example, by taking
lg N bits at a time from the binary string corresponding to the characterencoding of the message). Then these numbers are independently raised to apower modulo N: to encrypt a (piece of a) message M, compute C = P(M) =MPmod N, and to decrypt a ciphertext C, compute M = S(C) = CﬂmodN. This computation can be quickly and easily performed by modifying theelementary exponentiation algorithm that we studied in Chapter 4 to takethe remainder when divided by N after each multiplication. (No more than2 log N such operations are required for each piece of the message, so the tot,alnumber of operations (on 100 digit numbers!) required is linear in the numberof bits in the message.)Property (iv) above is therefore satisfied, and property (ii) can be easilyenforced. We still must make sure that the cryptovariables N, p, and s can bechosen so as to satisfy properties (i) and (iii). To be convinced of these requiresan exposition of number theory which is beyond the scope of this book, butwe can outline the main ideas. First, it is necessary to generate three large(approximately loo-digit) ﬁrandomﬂ prime numbers: the largest will be s andwe™ll call the other two x and y. Then N is chosen to be the product of xand y, and p is chosen so that ps mod (x - l)(y - 1) = 1. It is possible to provethat, with N, p, and s chosen in this way, we have Mps mod N = M for allmessages M.More specifically, each large prime can be generated by generating a largerandom number, then testing successive numbers starting at that point until
302CHAPTER 23a prime is found. One simple method performs a calculation on a randomnumber that, with probability l/2, will ﬁproveﬂ that the number to be testedis not prime. (A number which is not prime will survive 20 applications ofthis test less than one time out of a million, 30 applications less than 1 time
out of a billion.) The last step is to compute p: it turns out that a variant of
Euclid™s algorithm (see Chapter 1) is just what is needed.Furthermore, s seems to be difficult to compute from knowledge of p (andN), though no one has been able to prove that to be the case. Apparently,finding p from s requires knowledge of x and y, and apparently it is necessaryto factor N to calculate x and y. But factoring N is thought to be verydifficult: the best factoring algorithms known would take millions of years to
factor a 200-digit number, using current technology.An attractive feature of the RSA system is that the complicated com-putations involving N, p, and s are performed only once for each user whosubscribes to the system, which the much more frequent operations of encryp-tion and decryption involve only breaking up the message and applying thesimple exponentiation procedure.This computational simplicity, combinedwith all the convenience features provided by public-key cryptosystems, makethis system quite attractive for secure communications, especially on computersystems and networks.The RSA method has its drawbacks: the exponentiation procedure is ac-tually expensive by cryptographic standards, and, worse, there is the linger-ing possibility that it might be possible to read messages encrypted using the
method. This is true with many cryptosystems: a cryptographic method mustwithstand serious cryptanalytic attacks before it can be used with confidence.Several other methods have been suggested for implementing public-keycryptosystems. Some of the most interesting are linked to an important classof problems which are generally thought to be very hard (though this is not
known for sure), which we™ll discuss in Chapter 40. These cryptosystems
have the interesting property that a successful attack could provide insight on
how to solve some well-known difficult unsolved problems (as with factoring
for the RSA method). This link between cryptology and fundamental topicsin computer science research, along with the potential for widespread use ofpublic-key cryptography, have made this an active area of current research.rl
303Exercises1.2.3.4.5.6.7.8.9.10.Decrypt the following message, which was encrypted with a Vigenerecipher using the pattern CAB (repeated as necessary) for the key (on a27-letter alphabet, with blank preceding A): DOBHBUAASXFZWJQQWhat table should be used to decrypt messages that have been encryptedusing the table substitution method?Suppose that a Vigenere cipher with a two-character key is used to encrypta relatively long message. Write a program to infer the key, based on the
assumption that the frequency of occurrence of each character in odd
positions should be roughly equal to the frequency of occurrence of each
character in the even positions.Write matching encryption and decryption procedures which use theﬁexclusive orﬂ operation between a binary version of the message witha binary stream from one of the linear congruential random numbergenerators of Chapter 3.Write a program to ﬁbreakﬂ the method given in the previous exercise,assuming that the first 10 characters of the message are known to be
blanks.Could one encrypt plaintext by ﬁandﬂing it (bit by bit) with the key?Explain why or why not.True or false: Public-key cryptography makes it convenient to send thesame message to several different users. Discuss your answer.What is P(S(M)) for the RSA method for public-key cryptography?RSA encoding might involve computing Mn, where M might be a k digitnumber, represented in an array of k integers, say. About how manyoperations would be required for this computation?Implement encryption/decryption procedures for the RSA method (as-sume that s, p and N are all given and represented in arrays of integersof size 25).
304SOURCES for String ProcessingThe best references for further information on many of the algorithms inthis section are the original sources. Knuth, Morris, and Pratt™s 1977 paperand Boyer and Moore™s 1977 paper form the basis for much of the materialfrom Chapter 19. The 1968 paper by Thompson is the basis for the regular-expression pattern matcher of Chapters 20-21. Huffman™s 1952 paper, thoughit predates many of the algorithmic considerations here, still makes interesting
reading. Rivest, Shamir, and Adleman describe fully the implementation andapplications of their public-key cryptosystem in their 1978 paper.The book by Standish is a good general reference for many of the topicscovered in these chapters, especially Chapters 19, 22, and 23. Parsing andcompiling are viewed by many to be the heart of computer science, and thereare a large number of standard references available, for example the bookby Aho and Ullman. An extensive amount of background information oncryptography may be found in the book by Kahn.A. V. Aho and J. D. Ullman, Principles of Compiler Design, Addison-Wesley,Reading, MA, 1977.R. S. Boyer and J. S. Moore, ﬁA fast string searching algorithm,ﬂ Communica-tions of the ACM, 20, 10 (October, 1977).D. A. Huffman, ﬁA method for the construction of minimum-redundancycodes,ﬂProceedings of the IRE, 40 (1952).D. Kahn, The Codebreakers, Macmillan, New York, 1967.D. E. Knuth, J. H. Morris, and V. R. Pratt, ﬁFast pattern matching in strings,ﬂSIAM Journal on Computing, 6, 2 (June, 1977).R. L. Rivest, A. Shamir and L. Adleman,ﬁA method for obtaining digitalsignatures and public-key cryptosystems,ﬂ Communications of the ACM, 21,2 (February, 1978).T. A. Standish, Data Structure Techniques, Addison-Wesley, Reading, MA,1980.K. Thompson, ﬁRegular expression search algorithm,ﬂ Communications of theACM, 11, 6 (June, 1968).
GEOMETRIC ALGORITHMS

24. Elementary Geometric MethodsComputers are being used more and more to solve large-scale problemswhich are inherently geometric. Geometric objects such as points, linesand polygons are the basis of a broad variety of important applications andgive rise to an interesting set of problems and algorithms.Geometric algorithms are important in design and analysis systems forphysical objects ranging from buildings and automobiles to very large-scaleintegrated circuits. A designer working with a physical object has a geometric
intuition which is difficult to support in a computer representation. Many
other applications directly involve processing geometric data. For example,a political ﬁgerrymanderingﬂ scheme to divide a district up into areas whichhave equal population (and which satisfy other criteria such as putting most
of the members of the other party in one area) is a sophisticated geometricalgorithm. Other applications abound in mathematics and statistics, wheremany types of problems arise which can be naturally set in a geometric
representation.Most of the algorithms that we™ve studied have involved text and num-bers, which are represented and processed naturally in most programmingenvironments. Indeed, the primitive operations required are implemented inthe hardware of most computer systems. For geometric problems, we™ll seethat the situation is different: even the most elementary operations on pointsand lines can be computationally challenging.Geometric problems are easy to visualize, but that can be a liability.Many problems which can be solved instantly by a person looking at a pieceof paper (example: is a given point inside a given polygon?) require non-trivial computer programs. For more complicated problems, as in many otherapplications, the method of solution appropriate for implementation on a
computer might be quite different from the method of solution appropriate
for a person.307
CWAPTER 24One might suspect that geometric algorithms would have a long historybecause of the constructive nature of ancient geometry and because usefulapplications are so widespread, but actually much of the work in the field
has been quite recent. Of course, it is often the case that the work of an-
cient mathematicians has useful application in the development of algorithms
for modern computers. The field of geometric algorithms is interesting tostudy because there is strong historical context, because new fundamentalalgorithms are still being developed, and because many important large-scaleapplications require these algorithms.Points, Lines, and PolygonsMost of the programs that we™ll study will operate on simple geometric objectsdefined in a two-dimensional space. (But we will consider a few algorithmswhich work in higher dimensions.) The fundamental object is a point, whichwe™ll consider to be a pair of integers -the ﬁcoordinatesﬂ of the point inthe usual Cartesian system. Considering only points with integer coordinatesleads to slightly simpler and more efficient algorithms, and is not as severe a
restriction as it might seem. A line is a pair of points, which we assume areconnected together by a straight line segment. A polygon is a list of points: weassume that successive points are connected by lines and that the first point
is connected to the last to make a closed figure.To work with these geometric objects, we need to be decide how torepresent them. Most of our programs will use the obvious representationstype point = record x,y: integer end;line = record pl, p2: point end;Note that points are restricted to have integer coordinates. A real repre-sentation could also be used. However, it is important to note that restricting
the algorithms to process only integers can be a very significant timesaver
in many computing environments, because integer calculations are typically
much more efficient that ﬁfloating-pointﬂ calculations. Thus, when we can get
by with dealing only with integers without introducing much extra complica-
tion, we will do so.More complicated geometric objects will be represented in terms of thesebasic components. For example, polygons will be represented as arrays ofpoints. Note that using arrays of lines would result in each point on the
polygon being included twice (though that still might be the natural repre-
sentation for some algorithms). Also, it is useful for some applications to
include extra information associated with each point or line. This can clearlybe handled by adding an info field to the records.
ELEMENTARY GEOMETRIC METHODS309We™ll use the following set of sixteen points to illustrate the operation ofseveral geometric algorithms:.El K‚0l F*A‚C‚I‚G‚N‚Ll J‚Hl Dl Ml BThe points are labeled with single letters for reference in explaining theexamples. The programs usually have no reason to refer to points by ﬁnameﬂ;they are simply stored in an array and are referred to by index. Of course,the order in which the points appear in the array may be important in someof the programs: indeed, it is the goal of some geometric algorithms to ﬁsortﬂ
the points into some particular order.The labels that we use are assignedin the order in which the points are assumed to appear in the input. Thesepoints have the following integer coordinates:ABCDEFGH I JKLMNOPx:31164581791410161513212y:91831511647513142161210A typical program will maintain an array p [1..N] of points and simplyread in N pairs of integers, assigning the first pair to the x and y coordinatesof p [I], the second pair to the x and y coordinates of p [2], etc. When pis representing a polygon, it is sometimes convenient to maintain ﬁsentinelﬂvalues p[O]=p[N] and p[N+l]=p[l].
310CXAPTER 24At some™ point, we usually want to ﬁdrawﬂ our geometric objects. Evenif this is not inherent in the application, it is certainly more pleasant to workwith pictures than numbers when developing or debugging a new implemen-tation. It is clear that the fundamental operation here is drawing a line. Manytypes of hardware devices have this capability, but it is reasonable to consider
drawing lines using just characters, so that we can print approximations to
picture of our objects directly as output to Pascal programs (for example).
Our restriction to integer point coordinates helps us here: given a line, we
simply want a collection of points that approximates the line. The following
recursive program draws a line by drawing the endpoints, then splitting the
line in half and drawing the two halves.procedure draw(l: line) ;var dx, dy: integer;t: point; 11,12: line;begindot(l.pl.x,l.pl.y); dot(l.p2.x,l.p2.y);dx:=J.p2.x-1.pl.x; dy:=l.p2.y-1.pl.y;if (abs(dx)>l) or (abs(dy)>l) thenbegint.x:=l.pl .x+dx div 2; t.y:=l.pl .y+dy div 2;Il.pl:=l.pl; H.p2:=t; draw(l1);/2.pl:=t; /2.p2:=l.p2; draw(12);end ;end ;The procedure dot is assumed to ﬁdrawﬂ a single point. One way toimplement this is to maintain a two-dimensional array of characters with onecharacter per point allowed, initialized to ﬁaﬂ. The dot simply corresponds tostoring a different character (sayrr*ﬁ) in the array position corresponding tothe referenced point. The picture is ﬁdrawnﬂ by printing out the whole array.For example, when the above procedure is used with such a dot procedurewith a 33x33 picture array to ﬁdrawﬂ the lines connecting our sample pointsBG, CD, EO, IL, and PK at a resolution of two characters per unit of measure,we get the following picture:
ELEMENTARY GEOMETRIC METHODS311............................................................................*...............................*...............................*.......................*.......*.......................*.......*.............*.........*.......*...............*.......*.......*................*......*..........................*....*............................*..*.............................*.*...............................*...............................*...............................*...............................*.......................*.......*........................*......*........................*......*.........................*.......................**.......*.........................***...*.............................**.*...............................*................................***..............................*..**...........................*.....***.................................**.................................*.................................**.................................*............................................................................Algorithms for converting geometric objects to points in this manner are calledscan-conversion algorithms. This example illustrates that it is easy to drawnice-looking diagonal lines like EO and IL, but that it is somewhat harder tomake lines of arbitrary slope look nice using a coarse matrix of characters. The
recursive method given above has the disadvantages that it is not particularly
efficient (some points get plotted several times) and that it doesn™t draw
certain lines very well (for example lines which are nearly horizontal and
nearly vertical). It has the advantages that it is relatively simple and that
it handles all the cases of the various orientation of the endpoints of the linein a uniform way. Many sophisticated scan-conversion algorithms have beendeveloped which are more efficient and more accurate than this recursive one.If the array has a very large number of dots, then the ragged edges ofthe lines aren™t discernible, but the same types of algorithms are appropriate.However, the very high resolution necessary to make high-quality lines canrequire very large amounts of memory (or computer time), so sophisticatedalgorithms are called for, or other technologies might be appropriate. For
example, the text of this book was printed on a device capable of printing
millions of dots per square inch, but most of the lines in the figures were drawn
312CHAPTER 24with pen and ink.Line IntersectionAs our first example of an elementary geometric problem, we™ll consider theproblem of determining whether or not two given line segments intersect. The
following diagram illustrates some of the situations that can arise./E0When line segments actually intersect, as do CD and BG, the situation is quitestraightforward except that the endpoint of one line might fall on the other, as
in the case of KP and IL. When they don™t intersect, then we extend the line
segments and consider the position of the intersection point of these extended
lines. This point could fall on one of the segments, as in the case of IL and
BG, or it could lie on neither of the segments, as in the case of CD and OE, or
the lines could be parallel, as in the case of OE and IL. The straightforward
way to solve this problem is to find the intersection point of the lines defined
by the line segments, then check whether this intersection point falls between
the endpoints of both of the segments. Another easy method uses a tool thatwe™ll find useful later, so we™ll consider it in more detail: Given a line andoints, we™re often interested in whether the two points fall on the samethe line or not. This function is straightforward to compute from thefor the lines as follows:
ELEMENTARY GEOMETRIC METHODS313function same(l: line; pl,p2: point): integer;var dx, dy, dxl, dx2, dyl, dy2: integer;begindx:=l.p2.x-1.pl.x; dy:=l.p2.y-1.pl.y;dxl :=pl .x-1.~1.~;dyl :=pl.y-1.~1 .y;dx2:=p2.x-1.p2.x; dy2:=p2.y-1.p2.y;same:=(dx*dyl-ddy*dxl)*(dx*dy2-dpdx2)end;In terms of the variables in this program, it is easy to check that the quantity(da: dyl - dy dzl) is 0 if pl is on the line, positive if pl is on one side, andnegative if it is on the other side. The same holds true for the other point, sothe product of the quantities for the two points is positive if and only if thepoints fall on the same side of the line, negative if and only if the points fall
on different sides of the line, and 0 if and only if one or both points fall on
the line. We™ll see that different algorithms need to treat points which fall on
lines in different ways, so this three-way test is quite useful.This immediately gives an implementation of the intersect function. Ifthe endpoints of both line segments are on opposite sides of the other thenthey must intersect.function intersect(ll,l2: line): boolean;beginintersect:=(same(ll, 12.pl,12.p2)<=0)and (same(l2,ll.pl,ll.p2)<=0)end ;Unfortunately, there is one case where this function returns the wrong answer:if the four line endpoints are collinear, it always will report intersection, eventhough the lines may be widely separated. Special cases of this type are thebane of geometric algorithms. The reader may gain some appreciation for thekind of complications such cases can lead to by finding a clean way to repair
intersect and same to handle all cases.If many lines are involved, the situation becomes much more complicated.Later on, we™ll see a sophisticated algorithm for determining whether any pairin a set of N lines intersects.Simple Closed PathTo get the flavor of problems dealing with sets of points, let™s consider theproblem of finding a path through a set of N given points which doesn™t
314CHAF™TER 24intersect itself, visits all the points, and returns to the point at which itstarted. Such a path is called a simple closed path. One can imagine manyapplications for this: the points might represent homes and the path the routethat a mailman might take to get to each of the homes without crossing hispath. Or we might simply want a reasonable way to draw the points using amechanical plotter. This is an elementary problem because it asks only for
any closed path connecting the points. The problem of finding the best such
path, called the traveling salesman problem, is much, much more difficult.We™ll look at this problem in some detail in the last few chapters of this book.In the next chapter, we™ll consider a related but much easier problem: finding
the shortest path that surrounds a set of N given points. In Chapter 31, we™llsee how to find the best way to ﬁconnectﬂ a set of points.An easy way to solve the elementary problem at hand is the following:Pick one of the points to serve as an ﬁanchor.ﬂ Then compute the angle madeby drawing a line from each of the points in the set to the anchor and then
out the positive horizontal direction (this is part of the polar coordinate of
each point with the anchor point as origin). Next, sort the points according
to that angle. Finally, connect adjacent points. The result is a simple closed
path connecting the points, as drawn below:
ELEMENTARY GEOMETRIC METHODS315In this example, B is used as the anchor. If the points are visited in the orderB M J L N P K F I E C 0 A H G D B then a simple closed polygon will betraced out.If dx and dy are the delta x and y distances from some point to the anchorpoint, then the angle needed in this algorithm is tan-™ dyldx. Althoughthe arctangent is a built-in function in Pascal (and some other programmingenvironments), it is likely to be slow and it leads to at least two annoying extraconditions to compute: whether dx is zero, and which quadrant the point isin. Since the angle is used only for the sort in this algorithm, it makes senseto use a function that is much easier to compute but has the same orderingproperties as the arctangent (so that when we sort, we get the same result).A good candidate for such a function is simply dy/(dy + dz). Testing forexceptional conditions is still necessary, but simpler. The following programreturns a number between 0 and 360 that is not the angle made by pl andp2 with the horizontal but which has the same order properties as the trueangle.function theta(pl, p2: point): real;var dx, dy, ax, ay: integer;t: real;begindx:=p2.x-p1.x; ax:=abs(dx);dy:=p2.y-p1.y; ay:=abs(dy);if (dx=O) and (dy=O) then t:=Oelse t:=dy/(ax+ay);if dx<O then t:= 2-telse if dy<O then t:=4+t;theta:=t*90.0;end ;In some programming environments it may not be worthwhile to use suchprograms instead of standard trigonometric functions; in others it might leadto significant savings. (In some cases it might be worthwhile to change thetato have an integer value, to avoid using real numbers entirely.)Inclusion in a PolygonThe next problem that we™ll consider is a natural one: given a polygon repre-sented as an array of points and another point, determine whether the point
is inside or outside. A straightforward solution to this problem immediately
suggests itself: draw a long line segment from the point in any direction (long
enough so that its other endpoint is guaranteed to be outside the polygon) and
316CHAPTER 24count the number of lines from the polygon that it crosses. If the number isodd, the point must be inside; if it is even, the point is outside. This is easily
seen by tracing what happens as we come in from the endpoint on the outside:
after the first line we hit, we are inside, after the second we are outside, etc.If we proceed an even number of times, the point at which we end up (theoriginal point) must be outside.The situation is not quite so simple, because some intersections mightoccur right at the vertices of the input polygon. The drawing below showssome of the situations that need to be handled.Lines 1 and 2 are straightforward; line 3 leaves the polygon at a vertex; andline 4 coincides with one of the edges of the polygon. The point where line3 exits should count as 1 intersection with the polygon; all the other points
where lines intersect vertices should count as 0 (or 2). The reader may be
amused to try to find a simple test to distinguish these cases before reading
further.The need to handle cases where polygon vertices fall on the test linesforces us to do more than just count the line segments in the polygon whichintersect the test line. Essentially, we want to travel around the polygon,incrementing an intersection counter whenever we go from one side of the test
ELEMENTARY GEOMETRIC METHODS317line to another. One way to implement this is to simply ignore points whichfall on the test line, as in the following program:function inside(t: point): boolean;var count, i,j: integer;It, lp: line;begincount:=O; j:=O;PPI :=PPI; P[N+~I :=~[ll;lt.pl:=t; It.p2:=t; It.plx:=maxint;for i:=l to N dobeginIp.pl:=p[i]; Ip.p2:=p[i];if not intersect(lp, It) thenbeginIp.p2:=pIj] ; j:=i;if intersect(lp, It) then count:=count+l;end ;end ;inside:=( (count mod 2)=1);end ;This program uses a horizontal test line for ease of calculation (imagine theabove diagram as rotated 45 degrees). The variable j is maintained as theindex of the last point on the polygon known not to lie on the test line. Theprogram assumes that p[l] is the point with the smallest z coordinate amongall the points with the smallest y coordinate, so that if p[l] is on the testline, then p [0] cannot be. For example, this choice might be used for p [I] asthe ﬁanchorﬂ for the procedure suggested above for computing a simple closedpolygon. The same polygon can be represented by N different p arrays, butas this illustrates it is sometimes convenient to fix a standard rule for p [l]. Ifthe next point on the polygon which is not on the test line is on the same sideof the test line as the jth point, then we need not increment the intersectioncounter (count); otherwise we have an intersection. The reader may wish tocheck that this algorithm works properly for lines like lines 3 and 4 in the
diagram above.If the polygon has only three or four sides, as is true in many applications,then such a complex program is not called for: a simpler procedure based oncalls to same will be adequate.
318CHAPTER 24Perspective.From the few examples given, it should be clear that it is easy to underestimatethe difficulty of solving a particular geometric problem with a computer.There are many other elementary geometric computations that we have nottreated at all. For example, a program to compute the area of a polygonmakes an interesting exercise. However, the problems that we have studied
have provided some basic tools that we will find useful in later sections forsolving the more difficult problems.Some of the algorithms that we™ll study involve building geometric struc-tures from a given set of points. The ﬁsimple closed polygonﬂ is an elementaryexample of this. We will need to decide upon appropriate representations
for such structures, develop algorithms to build them, and investigate theiruse for particular applications areas.As usual, these considerations are in-tertwined. For example, the algorithm used in the inside procedure in thischapter depends in an essential way on the representation of the simple closedpolygon as an ordered set of points (rather than as an unordered set of lines).Many of the algorithms that we™ll study involve geometric search: wewant to know which points from a given set are close to a given point, or whichpoints fall in a given rectangle, or which points are closest to each other. Manyof the algorithms appropriate for such search problems are closely related tothe search algorithms that we studied in Chapters 14-17. The parallels will
be quite evident.Few geometric algorithms have been analyzed to the point where precisestatements can be made about their relative performance characteristics. Aswe™ve already seen, the running time of a geometric algorithm can depend onmany things. The distribution of the points themselves, the order in whichthey appear in the input, and whether trigonometric functions are needed
or used can all significantly affect the running time of geometric algorithms.As usual in such situations, we do have empirical evidence which suggestsgood algorithms for particular applications. Also, many of the algorithms aredesigned to nerform well in the worst case. no matter what theinoutis.
ELEMENTARY GEOMETRIC METHODS319Exercises1.2.3.4.5.6.7.8.9.10.List the points plotted by draw when plotting a line from (0,O) to (1,21).Give a quick algorithm for determining whether two line segments areparallel, without using any divisions.Given an array of lines, how would you test to see if they form a simpleclosed polygon?Draw the simple closed polygons that result from using A, C, and D asﬁanchorsﬂ in the method described in the text.Suppose that we use an arbitrary point for the ﬁanchorﬂ in the method forcomputing a simple closed polygon described in the text. Give conditionswhich such a point must satisfy for the method to work.What does the intersect function return when called with two copies ofthe same line segment?Write a program like draw to ﬁfill inﬂ an arbitrary triangle. (Your programshould call dot for all the points inside the triangle.)Does inside call a vertex of the polygon inside or outside?What is the maximum value achievable by count when inside is executedon a polygon with N vertices? Give an example supporting your answer.Write an efficient program for determining if a given point is inside agiven quadrilateral.

25. Finding the Convex HullOften, when we have a large number of points to process, we™re inter-ested in the boundaries of the point set. When looking at a diagram ofa set of points plotted in the plane, a human has little trouble distinguishingthose on the ﬁinsideﬂ of the point set from those which lie on the edge. This
distinction is a fundamental property of point sets; in this chapter we™ll see
how it can be precisely characterized by looking at algorithms for separating
out the ﬁboundaryﬂ points of a point set.The mathematical notion of the natural boundary of a point set dependson a geometric property called conwezity. This is a simple concept that thereader may have encountered before: a convex polygon is a polygon with theproperty that any line connecting any two points inside the polygon mustitself lie inside the polygon. For example, the ﬁsimple closed polygonﬂ thatwe computed in the previous chapter is decidedly nonconvex, but any triangleor rectangle is convex.Now, the mathematical name for the natural boundary of a point set isthe convex hull. The convex hull of a set of points in the plane is defined tobe the smallest convex polygon containing them all. Equivalently, the convexhull is the shortest path which surrounds the points. An obvious property of
the convex hull that is easy to prove is that the vertices of the convex polygon
defining the hull are points from the original point set. Given N points, someof them form a convex polygon within which all the others are contained. Theproblem is to find those points. Many algorithms have been developed to find
the convex hull; in this chapter we™ll examine a few representative ones.For a large number N of points, the convex hull could contain as few as3 points (if three points form a large triangle containing all the others) or asmany as N points (if all the points fall on a convex polygon, then they allcomprise their own convex hull). Some algorithms work well when there aremany points on the convex hull; others work better when there are only a few.321
322CHAPTER 25Below is diagramed our sample set of points and their convex hull.A fundamental property of the convex hull is that any line outside the hull,when moved in any direction towards the hull, hits the hull at one of its vertexpoints. (This is an alternate way to define the hull: it is the subset of pointsfrom the point set that could be hit by a line moving in at some angle frominfinity.) In particular, it™s easy to find a few points that are guaranteed to beon the hull by applying this rule for horizontal and vertical lines: the pointswith the smallest and largest z and y coordinates are all on the convex hull.The convex hull naturally defines the ﬁboundariesﬂ of a point set and isa fundamental geometric computation. It plays an important role in manystatistical computations, especially when generalized to higher dimensions.Rules of the GameThe input to an algorithm for finding the convex hull will obviously be anarray of points; we can use the point type defined in the previous chapter.The output will be a polygon, also represented as an array of points with theproperty that tracing through the points in the order in which they appear inthe array traces the outline of the polygon. On reflection, this might appearto require an extra ordering condition on the computation of the convex hull
FINDING THE: CONVEXHULL323(why not just return the points on the hull in any order?), but output inthe ordered form is obviously more useful, and it has been shown that theunordered computation is no easier to do. For all of the algorithms that weconsider, it is convenient to do the computation in place: the array used forthe original point set is also used to hold the output. The algorithms simply
rearrange the points in the original array so that the convex hull appears inthe first M positions, in order.From the description above, it may be clear that computing the convexhull is closely related to sorting. In fact, a convex hull algorithm can be usedto sort, in the following way. Given N numbers to sort, turn them into points(in polar coordinates) by treating the numbers as angles (suitably normalized)with a fixed radius for each point. The convex hull of this point set is anN-gon containing all of the points.Now, since the output must be orderedin the order the points appear on this polygon, it can be used to find thesorted order of the original values (remember that the input was unordered).
This is not a formal proof that computing the convex hull is no easier than
sorting, because, for example, the cost of the trigonometric functions required
to convert the original numbers to be sorted into points on the polygon must be
considered. Comparing convex hull algorithms (which involve trigonometric
operations) to sorting algorithms (which involve comparisons bet,ween keys)is a bit like comparing apples to oranges, but it has been shown that anyconvex hull algorithm must require about N log N operations, the same as
sorting (even though the operations allowed are likely to be quite different).
It is helpful to view finding the convex hull of a set of points as a kind ofﬁtwo-dimensional sortﬂ because frequent parallels to sorting algorithms arisein the study of algorithms for finding the convex hull.In fact, the algorithms that we™ll study show that finding the convex hullis no harder than sorting either: there are several algorithms that run in timeproportional to N log N in the worst case. Many of the algorithms tend to
use even less time on actual point sets, because their running time depends
on the way that the points are distributed and on the number of points onthe hull.We™ll look at three quite different methods for finding the convex hull ofa set of points and then discuss their relative running times.Package WrappingThe most natural convex hull algorithm, which parallels the method a humanwould use to draw the convex hull of a set of points, is a systematic way toﬁwrap upﬂ the set of points. Starting with some point guaranteed to be on theconvex hull (say the one with the smallest y coordinate), take a horizontal rayin the positive direction and ﬁsweepﬂ it upward until hitting another point; this
324CHAPTER 25point must be on the hull. Then anchor at that point and continue ﬁsweepingﬂuntil hitting another point, etc., until the ﬁpackageﬂ is fully ﬁwrappedﬂ (the
beginning point is included again). The following diagram shows how the hull
is discovered in this way.Of course, we don™t actually sweep through all possible angles, we just do astandard find-the-minimum computation to find the point that would be hitnext. This method is easily implemented by using the function theta(pl, p2:point) developed in the previous chapter, which can be thought of as returningthe angle between pl, p2 and the horizontal (though it actually returns a moreeasily computed number with the same ordering properties). The followingprogram finds the convex hull of an array p [I..iV] of points, represented asdescribed in the previous chapter (the array position p[N+l] is also used, tohold a sentinel):
FINDING THE CONVEX HULL325function wrap: integer;var i, min, M: integer;minangle, v: real;t: point;beginmin:=l;for i:=2 to Ndoif p[i].y<p[min].y then min:=i;M:=O; p[N+1]:=p[min]; minangle:=O.O;repeatM:=M+1; t:=p[M]; p[Mj:=p[min]; p[min]:=t;min:=N+l; v:=minangle; minangle:=360.0;for i:=M+1 to N+I doif theta(p[M],p[i])>v thenif theta(p[M], p[i])<minangle thenbegin min:=i; minangle:=theta(p[M], p[min]) end;until min= N+1;wrap:=M;end ;First, the point with the lowest y coordinate is found and copied into p[N+l]in order to stop the loop, as described below. The variable M is maintainedas the number of points so far included on the hull, and v is the currentvalue of the ﬁsweepﬂ angle (the angle from the horizontal to the line betweenp[M-l] and p[M]).The repeat loop puts the last point found into thehull by exchanging it with the Mth point, and uses the theta function fromthe previous chapter to compute the angle from the horizontal made by the
line between that point and each of the points not yet included on the hull,
searching for the one whose angle is smallest among those with angles bigger
than v. The loop stops when the first point (actually the copy of the first
point that was put into p[N+1]) is encountered again.This program may or may not return points which fall on a convex hulledge. This happens when more than one point has the same theta value withp[M] during the execution of the algorithm; the implementation above takesthe first value. In an application where it is important to find points fallingon convex hull edges, this could be achieved by changing theta to take the
distance between the points given as its arguments into account and give the
closer point a smaller value when two points have the same angle.The following table traces the operation of this algorithm: the Mth lineof the table gives the value of v and the contents of the p array after the Mthpoint has been added to the hull.
326CHAPTER 257.50(B(A C D E F G H I J K L M N 0 P18.00 BmC D E F G H I J K L A N 0 P83.08 B MWD E F G H I J K C A N 0 P144.00BMLmEFGHIJKCADOP190.00 B M L NHF G H I J K C A D 0 P225.00 B M L N EmG H I J K C A D F P257.14 B M L N E OmH I J K C A D F P315.00 B M L N E 0 GmI J K C A H F POne attractive feature of this method is that it generalizes to three (ormore) dimensions.The convex hull of a set of points in 3-space is a convexthree-dimensional object with flat faces. It can be found by ﬁsweepingﬂ aplane until the hull is hit, then ﬁfoldingﬂ faces of the plane, anchoring on
different lines on the boundary of the hull, until the ﬁpackageﬂ is ﬁwrapped.ﬂThe program is quite similar to selection sorting, in that we successivelychoose the ﬁbestﬂ of the points not yet chosen, using a brute-force search forthe minimum. The major disadvantage of the method is that in the worst case,when all the points fall on the convex hull, the running time is proportionalto N2.The Graham ScanThe next method that we™ll examine, invented by R. L. Graham in 1972,is interesting because most of the computation involved is for sorting: thealgorithm includes a sort followed by a relatively inexpensive (though not im-
mediately obvious) computation. The algorithm starts with the construction
of a simple closed polygon from the points using the method of the previouschapter: sort the points using as keys the theta function values correspondingto the angle from the horizontal made from the line connecting each point
with an ‚anchor™ point p[l] (with the lowest y coordinate) so that tracingP~~l,Pk% . . .,p[N],p[l] gives a closed polygon. For our example set of points,we get the simple closed polygon of the previous section. Note that p[N],p[l], and p[2] are consecutive points on the hull; we™ve essentially run thefirst iteration of the package wrapping procedure (in both directions).Computation of the convex hull is completed by proceeding around,trying to place each point on the hull and eliminating previously placed pointsthat couldn™t possibly be on the hull. For our example, we consider the points
FINDING ‚IYE CONVEXHULL327in the order B M J L N P K F I E C 0 A H G D. The test for which points toeliminate is not difficult. After each point has been added, we assume that wehave eliminated enough points so that what we have traced out so far could
be part of the convex hull, based on the points so far seen. The algorithm
is based on the fact that all of the point,s in the point set must be on thesame side of each edge of the convex hull. Each time we consider a point, weeliminate from the hull any edge which violates this condition.Specifically, the test for eliminating a point is the following: when wecome to examine a new point p[i], we eliminate p[k] from the hull if the linebetween p[k] and p[k-l]goes between p[i] and p[l]. If p[i] and p[l] areon the same side of the line, then p[k] could still be on the hull, so we don™teliminate it. The following diagram shows the situation for our example whenL is considered:....l Fl Kl N‚P\\.I\\J.JM\B\The extended line JM runs between L and B, so J couldn™t be on the hull. NowL, N, and P are added to the hull, then P is eliminated when K is considered(because the extended line NP goes between B and K), then F and I are added,leaving the following situation when E is considered.
328CHAPTER 25..\\\‚il\J\\\\M\‚\ BAt this point, I must be eliminated because FI runs between E and B, then Fand K must be eliminated because NKF runs between E and B. Continuingin this way, we finally arrive back at B, as illustrated below:G
FINDING THE CONVEX HULL329The dotted lines in the diagrams are all the edges that were included, theneliminated. The initial sort guarantees that each point is considered as apossible hull point in turn, because all points considered earlier have a smallertheta value. Each line that survives the ﬁeliminationsﬂ has the property thatevery point is on the same side of it as p[l], which implies that it must be onthe hull.Once the basic method is understood, the implementation is straightfor-ward. First, the point with the minimum y value is exchanged with p[l].Next, shellsort (or some other appropriate sorting routine) is used to rear-range the points, modified as necessary to compare two points using theirtheta values with p[l]. Finally, the scan described above is performed. Thefollowing program finds the convex hull of the point set p [1..N] (no sentinelis needed):function grahamscan : integer;var i, j, min, M: integer;1: line; t: point;beginmin:=l;for i:=2 to N doif p [i] .y<p [min] .y then min:=i;t:=p[l]; p[l]:=p[min]; p[min]:=t;shellsort ;M:=2;for i:=4 to NdobeginM:=M+2;repeatM:=M-1;I.pl:=p[M]; l.p2:=p[M-I];until same(l,p[l],p[i])>=O;t:=p[M+I]; p[M+I]:=p[i]; p[i]:=t;end ;grahamscan : =M;end ;The loop maintains a partial hull in p[l], . . . , p [Ml, as described in the text,above. For each new i value considered, M is decremented if necessary toeliminate points from the partial hull and then p [i] is exchanged with p [M+1]to (tentatively) add it to the partial hull. The following table shows thecontents of the p array each time a new point is considered for our example:
330CHAF™TER 251BBB
BB
BB
BB
BB
BBB2M345678910111213141516~~NPKFIEC~AHGD--MMJNPKFIECOAHGDMLmJmKFIECOAHGDM L;J™BymFIECOAHGD--MLNHJPBIECOAHGDMLNKmPJmECOAHGD--MLNKFWJPNCOAHGD--M L N IEl F I J P K ICI 0 A H G DMLN6@IJPKymAHGD--MLNEMIJPKFCMHGDMLNEOaJPKFCImGD--MLNEOANPKFCI-MLNEOMHPKFCIJlc.lEJ AuMLNEOGmPKFCIJ A H-This table depicts, for i from 4 to hJ, the solution when p[i] is first considered,with p[M] and p[i] boxed.The program as given above could fail if there is more than one point withthe lowest y coordinate, unless theta is modified to properly sort collinearpoints, as described above. (This is a subtle point which the reader maywish to check.) Alternatively, the min computation could be modified to find
the point with the lowest x coordinate among all points with the lowest y
coordinate, the canonical form described in Chapter 24.One reason that this method is interesting to study is that it is a simpleform of backtracking, the algorithm design technique of ﬁtry something, if itdoesn™t work then try something elseﬂ which we™ll see in much more compli-cated forms in Chapter 39.Hull SelectionAlmost any convex hull method can be vastly improved by a method developedindependently by W. F. Eddy and R. W. Floyd. The general idea is simple:pick four points known to be on the hull, then throw out everything inside thequadrilateral formed by those four points. This leaves many fewer points to
FINDING THE CONVEXHULL331be considered by, say, the Graham scan or the package wrapping technique.The method could be also applied recursively, though this is usually not worththe trouble.The four points known to be on the hull should be chosen with an eyetowards any information available about the input points. In the absenceof any information at all, the simplest four points to use are those with thesmallest and largest 5 and y coordinates. However, it might be better to adaptthe choice of points to the distribution of the input. For example, if all x andy values within certain ranges are equally likely (a rectangular distribution),then choosing four points by scanning in from the corners might be better(find the four points with the largest and smallest sum and difference of thetwo coordinates). The diagram below shows that only A and J survive theapplication of this technique to our example set of points.GThe recursive version of this technique is very similar to the Quicksort-like select procedure for selection that we discussed in Chapter 12. Like thatprocedure, it is vulnerable to an N2 worst-case running time. For example, ifall the original points are on the convex hull, then no points will get thrownout in the recursive step. Like select, the running time is linear on the average,as discussed further below.
CHAPTER 25Performance IssuesAs mentioned in the previous chapter, geometric algorithms are somewhatharder to analyze than algorithms from some of the other areas we™ve studiedbecause the input (and the output) is more difficult to characterize. It oftendoesn™t make sense to speak of LLrandomﬂ point sets: for example, as Ngets large, the convex hull of points drawn from a rectangular distribution isextremely likely to be very close to the rectangle defining the distribution. Thealgorithms that we™ve looked at depend on different properties of the point setdistribution and are thus in practice incomparable, because to compare themanalytically would require an understanding of very complicated interactionsbetween little-understood properties of point sets. On the other hand, we
can say some things about the performance of the algorithms that will helpchoosing one for a particular application.The easiest of the three to analyze is the Graham scan. It requires timeproportional to N log N for the sort and N for the scan. A moment™s reflectionis necessary to convince oneself that the scan is linear, since it does havea repeat ﬁloop-within-a-loop.ﬂHowever, it is easy to see that no point isﬁeliminatedﬂ more than once, so the total number of times the code withinthat repeat loop is iterated must be less than N.The ﬁpackage-wrappingﬂ technique, on the other hand, obviously takesabout MN steps, where M is the number of vertices on the hull. To comparethis with the Graham scan analytically would require a formula for M in termsof N, a difficult problem in stochastic geometry. For a circular distribution(and some others) the answer is that M is about N1/3, and for values of Nwhich are not large N‚j3 is comparable to log N (which is the expected valuefor a rectangular distribution), so this method will compete very favorablywith the Graham scan for many practical problems. Of course, the N2 worstcase should always be taken into consideration.Analysis of the Floyd-Eddy method requires even more sophisticatedstochastic geometry, but the general result is the same as that given byintuition: almost all the points fall inside the quadrilateral and are discarded.
This makes the running time of tbe whole convex hull algorithm proportional
to N, since most points are examined only once (when they are thrown out).
On the average, it doesn™t matter much which method is used after one
application of the Floyd-Eddy met,hod, since so few points are likely to beleft. However, to protect against the worst case (when all points are on thehull), it is prudent to use the Graham scan. This gives an algorithm which isalmost sure to run in linear time in practice and is guaranteed to run in time
proportional to N log N.- _r-l
FINDING THE CONVEX HULL333Exercises1.2.3.4.5.6.
7.8.9.10,Suppose it is known in advance that the convex hull of a set of points isa triangle. Give an easy algorithm for finding the triangle. Answer the
same question for a quadrilateral.Give an efficient method for determining whether a point falls within agiven convex polygon.Implement a convex hull algorithm like insertion sort, using your methodfrom the previous exercise.Is it strictly necessary for the Graham scan to start with a point guaran-teed to be on the hull? Explain why or why not.Is it strictly necessary for the package-wrapping method to start with apoint guaranteed to be on the hull? Explain why or why not.Draw a set of points that makes the Graham scan for finding the convexhull particularly inefficient.Does the Graham scan work for finding the convex hull of the pointswhich make up the vertices of any simple polygon? Explain why or give
a counterexample showing why not.What four points should be used for the Floyd-Eddy method if the inputis assumed to be randomly distributed within a circle (using random polarcoordinates)?Run the package-wrapping method for large points sets with both 2 andy equally likely to be between 0 and 1000. Use your curve fitting routineto find an approximate formula for the running time of your program for
a point set of size N.Use your curve-fitting routine to find an approximate formula for thenumber of points left after the Floyd-Eddy method is used on point sets
with x and y equally likely to be between 0 and 1000.

26. Range SearchingGiven a set of points in the plane, it is natural to ask which of thosepoints fall within some specified area.ﬁList all cities within 50 miles ofProvidenceﬂ is a question of this type which could reasonably be asked if aset of points corresponding to the cities of the U.S. were available. When the
geometric shape is restricted to be a rectangle, the issue readily extends to
non-geometric problems. For example,ﬁlist all those people between 21 and25 with incomes between $60,000 and $100,000ﬂ asks which ﬁpointsﬂ from afile of data on people™s names, ages, and incomes fall within a certain rectanglein the age-income plane.Extension to more than two dimensions is immediate. If we want to listall stars within 50 light years of the sun, we have a three-dimensional problem,and if we want the rich young people of the second example in the paragraph
above to be tall and female as well, we have a four-dimensional problem. In
fact, the dimension can get very high for such problems.In general, we assume that we have a set of records with certain at-tributes that take on values from some ordered set. (This is sometimes calleda database, though more precise and complete definitions have been developedfor this important term.) The problem of finding all records in a databasewhich satisfy specified range restrictions on a specified set of attributes iscalled range searching. For practical applications, this is a difficult and im-portant problem. In this chapter, we™ll concentrate on the two-dimensionalgeometric problem in which records are points and attributes are their coor-dinates, then we™ll discuss appropriate generalizations.The methods that we™ll look at are direct generalizations of methods thatwe have seen for searching on single keys (in one dimension). We presume thatmany queries will be made on the same set of points, so the problem splits intotwo parts: we need a preprocessing algorithm, which builds the given points
into a structure supporting efficient range searching, and a range-searching335
336CHAPTER 26algorithm, which uses the structure to return points falling within any given(multidimensional) range. This separation makes different methods difficultto compare, since the total cost depends not only on the distribution of the
points involved but also on the number and nature of the queries.The range-searching problem in one dimension is to return all pointsfalling within a specified interval.This can be done by sorting the pointsfor preprocessing and, then using binary search (to find all points in a giveninterval, do a binary search on the endpoints of the interval and return all thepoints that fall in between). Another solution is to build a binary search tree
and then do a simple recursive traversal of the tree, returning points that are
within the interval and ignoring parts of the tree that are outside the interval.For example, the binary search tree that is built using the x coordinates ofour points from the previous chapter, when inserted in the given order, is the
following:Now, the program required to find all the points in a given intervalis a direct generalization of the treeprint procedure of Chapter 14. If theleft endpoint of the interval falls to the left of the point at the root, we(recursively) search the left subtree, similarly for the right, checking eachnode we encounter to see whether its point falls within the interval:
RANGE SEARCHINGtype interval = record xl, x2: integer end;procedure bstrange(t: link; int: interval);var txl, tx2: boolean;beginif t<>z thenbegintxl:=tt.key>=int.xl;tx2:=tt.key<=int.x2;if txl then bstrange(tt .l, int);if txl and tx2 then write(name(tt.id), ™ ‚);if tx2 then bstrange( tt.r, int);endend ;(This program could be made slightly more efficient by maintaining the inter-val int as a global variable rather than passing its unchanged values throughthe recursive calls.) For example, when called on the interval [5,9] for the ex-ample tree above, range prints out E C H F I. Note that the points returneddo not necessarily need to be connected in the tree.These methods require time proportional to about N log N for preprocess-ing, and time proportional to about R+log N for range, where R is the numberof points actually falling in the range. (The reader may wish to check thatthis is true.) Our goal in this chapter will be to achieve these same runningtimes for multidimensional range searching.The parameter R can be quite significant: given the facility to make rangequeries, it is easy for a user to formulate queries which could require all ornearly all of the points. This type of query could reasonably occur in many
applications, but sophisticated algorithms are not necessary if all queries are
of this type. The algorithms that we consider are designed to be efficient for
queries which are not expected to return a large number of points.Elementary MethodsIn two dimensions, our ﬁrangeﬂ is an area in the plane. For simplicity, we™llconsider the problem of finding all points whose 5 coordinates fall within agiven x-interval and whose y coordinates fall within a given y-interval: thatis, we seek all points falling within a given rectangle. Thus, we™ll assume atype rectangle which is a record of four integers, the horizontal and verticalinterval endpoints. The basic operation that we™ll use is to test whether apoint falls within a given rectangle, so we™ll assume a function insiderect(p:point; rect: rectangle) which checks this in the obvious way, returning true if
338CHAPTER 26p falls within rect. Our goal is to find all the points which fall within a givenrectangle, using as few calls to insiderect as possible.The simplest way to solve this problem is sequential search: scan throughall the points, testing each to see if it falls within the specified range (by callinginsiderect for each point). This method is in fact used in many database
applications because it is easily improved by ﬁbatchingﬂ the range queries,
testing for many different ones in the same scan through the points. In a very
large database, where the data is on an external device and the time to read
the data is by far the dominating cost factor, this can be a very reasonablemethod: collect as many queries as will fit in the internal memory and searchfor them all in one pass through the large external data file. If t,his type ofbatching is inconvenient or the database is somewhat smaller, however, thereare much better methods available.A simple first improvement to sequential search is to apply directly aknown one-dimensional method along one or more of the dimensions to besearched. For example, suppose the following search rectangle is specified forour sample set of points:Dl NE.L‚K‚0l F‚P‚A‚C‚I‚G‚Dl H‚J‚MOne way to proceed is to find the points whose x coordinates fall within the xrange specified by the rectangle, then check the y coordinates of those points
RANGE SEARCHINGto determine whether or not they fall within the rectangle. Thus, points thatcould not be within the rectangle because their x coordinates are out of rangeare never examined. This technique is called projection; obviously we couldalso project on y. For our example, we would check E C H F and I for an xprojection, as described above and we would check 0 E F K P N and L for a
y projection.If the points are uniformly distributed in a rectangular shaped region,then it™s trivial to calculate the average number of points checked. Thefraction of points we would expect to find in a given rectangle is simply the
ratio of the area of that rectangle to the area of the full region; the fraction of
points we would expect to check for an x projection is the ratio of the width
of the rectangle to the width of the region, and similarly for a y projection.
For our example, using a 4-by-6 rectangle in a 16-by-16 region means thatwe would expect to find 3132 of the points in the rectangle, l/4 of them inan x projection, and 318 of them in a y projection. Obviously, under suchcircumstances, it™s best to project onto the axis corresponding to the narrowerof the two rectangle dimensions.On the other hand, it™s easy to constructsituations in which the projection technique could fail miserably: for exampleif the point set forms an ﬁLﬂ shape and the search is for a range that enclosesonly the point at the corner of the ﬁL,ﬂ then projection on either axis wouldeliminate only half the points.At first glance, it seems that the projection technique could be improvedsomehow to ﬁintersectﬂ the points that fall within the x range and the pointsthat fall within the y range. Attempts to do this without examining eitherall the points in the x range or all the points in the y range in the worst caseserve mainly to give one an appreciation for the more sophisticated methodsthat we are about to study.Grid MethodA simple but effective technique for maintaining proximity relationships amongpoints in the plane is to construct an artificial grid which divides the area tobe searched into small squares and keep short lists of points that fall into
each square. (This technique is reportedly used in archaeology, for example.)
Then, when points that fall within a given rectangle are sought, only the listscorresponding to squares that intersect the rectangle have to be searched. Inour example, only E, C, F, and K are examined, as sketched below.
340CRAPTER 26The main decision to be made in implementing this method is determiningthe size of the grid: if it is too coarse, each grid square will contain too manypoints, and if it is too fine, there will be too many grid squares to search (mostof which will be empty). One way to strike a balance between these two is tochoose the grid size so that the number of grid squares is a constant fraction
of the total number of points. Then the number of points in each square is
expected to be about equal to some small constant. For our example, using a
4 by 4 grid for a sixteen-point set means that each grid square is expected to
contain one point.Below is a straightforward implementation of a program to read in zycoordinates of a set of points, then build the grid structure containing thosepoints. The variable size is used to control how big the grid squares are andthus determine the resolution of the grid. For simplicity, assume that thecoordinates of all the points fall between 0 and some maximum value max.Then, to get a G-by-G grid, we set size to the value max/G, the width ofthe grid square. To find which grid square a point belongs to, we divide itscoordinates by size, as in the following implementation:
RANGE SEARCHING341program rangegrid(input, output);const Gmax=20;type point = record x, y, info: integer end;Jink=tnode;node=record p: point; next: link end;var grid: array[O..Gmax, O..Gmax] of link;p: point;i, j, k, size, N: integer;z: link;procedure insert(p: point);var t: link;beginnew(t); tf.p:=p;tf.next:=grid[p.x div size,p.y div size];grid [p.x div size, p.y div size] := t ;end ;beginnew(z);for i:=O to Gmax dofor j:=O to Gmax do grid[i, j] :=z;readln (N) ;for k:=l to N dobeginreadJn(p.x, p.y); p.info:=k;insert(p)end ;end.This program uses our standard linked list representations, with dummy tailnode z. The point type is extended to include a field info which containsthe integer k for the Jcth point read in, for convenience in referencing the
points. In keeping with the style of our examples, we™ll assume a function
name(k) to return the Jcth letter of the alphabet: clearly a more generalnaming mechanism will be appropriate for actual applications.As mentioned above, the setting of the variable size (which is omittedfrom the above program) depends on the number of points, the amount ofmemory available, and the range of coordinate values. Roughly, to get Mpoints per grid square, size should be chosen to be the nearest integer to maxdivided by ,/m. This leads to about N/M grid squares. These estimatesaren™t accurate for small values of the parameters, but they are useful formost situations, and similar estimates can easily be formulated for specialized
applications.
342CHAF™TER 26Now, most of the work for range searching is handled by simply indexinginto the grid array, as follows:procedure gridrange(rect : rectangle) ;var t: link;i, j: integer;beginfor i:=(rect.xl div size) to (rect.x2 div size) dofor j:=(rect.yl div size) to (rect.y2 div size) dobegint:=grid[i, j];while t<>z dobeginif insiderect( tt.p, rect) then write(name( tt.p.info));t:=tf.nextendendend ;The running time of this program is proportional to the number of grid squarestouched. Since we were careful to arrange things so that each grid square
contains a constant number of points on the average, this is also proportional,
on the average, to the number of points examined. If the number of points
in the search rectangle is R, then the number of grid squares examined isproportional to R. The number of grid squares examined which do not fallcompletely inside the search rectangle is certainly less than a small constanttimes R, so the total running time (on the average) is linear in R, the numberof points sought. For large R, the number of points examined which don™t fallin the search rectangle gets quite small: all such points fall in a grid squarewhich intersects the edge of the search rectangle, and the number of suchsquares is proportional to fi for large R. Note that this argument fallsapart if the grid squares are too small (too many empty grid squares insidethe search rectangle) or too large (too many points in grid squares on the
perimeter of the search rectangle) or if the search rectangle is thinner than
the grid squares (it could intersect many grid squares, but have few pointsinside it).The grid method works well if the points are well distributed over theassumed range but badly if they are clustered together. (For example, allthe points could fall in one grid box, which would mean that all the gridmachinery gained nothing.) The next method that we will examine makesthis worst case very unlikely by subdividing the space in a nonuniform way,
RANGE SEARCHING343adapting to the point set at hand.2D TreesTwo-dimensional trees are dynamic, adaptable data structures which are verysimilar to binary trees but divide up a geometric space in a manner convenientfor use in range searching and other problems. The idea is to build binary
search trees with points in the nodes, using the y and x coordinates of the
points as keys in a strictly alternating sequence.The same algorithm is used for inserting points into 2D trees as for normalbinary search trees, except at the root we use the y coordinate (if the pointto be inserted has a smaller y coordinate than the point at the root, go left;otherwise go right), then at the next level we use the 2 coordinate, then atthe next level the y coordinate, etc.,alternating until an external node isencountered. For example, the following 2D tree is built for our sample set ofpoints:El ElThe particular coordinate used is given at each node along with the pointname: nodes for which the y coordinate is used are drawn vertically, and
those for which the x coordinates is used are drawn horizontally.
344CHAPTER 26This technique corresponds to dividing up the plane in a simple way: allthe points below the point at the root go in the left subtree, all those above inthe right subtree, then all the points above the point at the root and to the leftof the point in the right subtree go in the left subtree of the right subtree ofthe root, etc. Every external node of the tree corresponds to some rectangle inthe plane. The diagram below shows the division of the plane corresponding
to the above tree. Each numbered region corresponds to an external node in
the tree; each point lies on a horizontal or vertical line segment which defines
the division made in the tree at that point.For example, if a new point was to be inserted into the tree from region 9 inthe diagram above, we would move left at the root, since all such points are
below A, then right at B, since all such points are to the right of B, then right
at J, since all such points are above J. Insertion of a point in region 9 would
correspond to drawing a vertical line through it in the diagram.The code for the construction of 2D trees is a straightforward modificationof standard binary tree search to switch between x and y coordinates at eachlevel:
RANGE SEARCHING345function twoDinsert(p: point; t: link) : link;var f: link;d, td: boolean;begind:=true;repeatif d then td:=p.x<tt.p.xelsetd :=p.y< tt .p.y;f:=t;if td then t:=tt.l else t:=tf.r;d:= not d;until t=z;new(t); tf.p:=p; tf.l:=z; tt.r:=z;if td then Q.l:=t else fi.r:=t;twoDinsert:=tend ;As usual, we use a header node head with an artificial point (0,O) which isﬁlessﬂ than all the other points so that the tree hangs off the right link ofhead, and an artificial node z is used to represent all the external nodes. Thecall twoDinsert(p, head) will insert a new node containing p into the tree. Aboolean variable d is toggled on the way down the tree to effect the alternatingtests on x and y coordinates. Otherwise the procedure is identical to thestandard procedure from Chapter 14. In fact, it turns out that for randomlydistributed points, 2D trees have all the same performance characteristics ofbinary search trees. For example, the average time to build such a tree isproportional to N log N, but there is an N2 worst case.To do range searching using 2D trees, we test the point at each nodeagainst the range along the dimension that is used to divide the plane of thatnode. For our example, we begin by going right at the root and right at node
E, since our search rectangle is entirely above A and to the right of E. Then,
at node F, we must go down both subtrees, since F falls in the x range defined
by the rectangle (note carefully that this is not the same as F falling within
the rectangle). Then the left subtrees of P and K are checked, correspondingto checking areas 12 and 14 of the plane, which overlap the search rectangle.This process is easily implemented with a straightforward generalization ofthe 1D range procedure that we examined at the beginning of this chapter:
346CHAPTER 26procedure twoDrange(t: link; rect: rectangle; d: boolean);var tl, t2, txl, tx2, tyl, ty2: boolean ;beginif t<>z thenbegintxl:=rect.xl<tf.p.x; tx2:=tt.p.x<=rect.x2;tyl :=rect.yl<tf.p.y; ty2:=tf.p.y<=rect.y2;if d then begin tl := txl ;t2:= tx2 endelse begin tl:=tyl; t2:=ty2 end;if tl then twoDrange(tt.l,rect, not d);if insiderect( tt.p, rect) then write(name( tt.p.info), ™ ‚);if t2 then twoDrange(tf.r, rect, not d);endend ;This procedure goes down both subtrees only when the dividing line cuts therectangle, which should happen infrequently for relatively small rectangles.Although the method hasn™t been fully analyzed, its running time seems sure
to be proportional to R + log N to retrieve R points from reasonable ranges ina region containing N points, which makes it very competitive with the gridmethod.Multidimensional Range SearchingBoth the grid method and 2D trees generalize directly to more than two dimen-sions: simple, straightforward extensions to the above algorithms immediatelyyield range-searching methods which work for more than two dimensions.However, the nature of multidimensional space dictates that some caution is
called for and that the performance characteristics of the algorithms mightbe difficult to predict for a particular application.To implement the grid method for k-dimensional searching, we simplymake grid a k-dimensional array and use one index per dimension. The mainproblem is to pick a reasonable value for size. This problem becomes quiteobvious when large k is considered: what type of grid should we use for lo-dimensional search? The problem is that even if we use only three divisionsper dimension, we need 31° grid squares, most of which will be empty, forreasonable values of N.The generalization from 2D to kD trees is also straightforward: simplycycle through the dimensions (as we did for two dimensions by alternatingbetween x and y) while going down the tree. As before, in a random situation,
the resulting trees have the same characteristics as binary search trees. Also
as before, there is a natural correspondence between the trees and a simple
RANGE SEARCHING347geometric process. In three dimensions, branching at each node correspondsto cutting the three-dimensional region of interest with a plane; in general we
cut the k-dimensional region of interest with a (k- 1)-dimensional hyperplane.If k is very large, there is likely to be a significant amount of imbalancein the kD trees, again because practical point sets can™t be large enough totake notice of randomness over a large number of dimensions. Typically, allpoints in a subtree will have the same value across several dimensions, whichleads to several one-way branches in the trees. One way to help alleviate thisproblem is, rather than simply cycle through the dimensions, always to use thedimension that will divide up the point set in the best way. This techniquecan also be applied to 2D trees. It requires that extra information (which
dimension should be discriminated upon) be stored in each node, but it does
relieve imbalance, especially in high-dimensional trees.In summary, though it is easy to see how to to generalize the programs forrange searching that we have developed to handle multidimensional problems,such a step should not be taken lightly for a large application. Large databaseswith many attributes per record can be quite complicated objects indeed, andit is often necessary to have a good understanding of the characteristics ofthe database in order to develop an efficient range-searching method for aparticular application. This is a quite important problem which is still beingactivelv studied.
348Exercises1.2.3.4.5.6.7.8.9.10.Write a nonrecursive version of the 1D range program given in the text.Write a program to print out all points from a binary tree which do notfall in a specified interval.Give the maximum and minimum number of grid squares that will besearched in the grid method as functions of the dimensions of the gridsquares and the search rectangle.Discuss the idea of avoiding the search of empty grid squares by usinglinked lists: each grid square could be linked to the next nonempty gridsquare in the same row and the next nonempty grid square in the samecolumn. How would the use of such a scheme affect the grid square sizeto be used?Draw the tree and the subdivision of the plane that results if we build a2D tree for our sample points starting with a vertical dividing line. (Thatis, call range with a third argument of false rather than true.)Give a set of points which leads to a worst-case 2D tree having no nodeswith two sons; give the subdivision of the plane that results.Describe how you would modify each of the methods, to return all pointsthat fall within a given circle.Of all search rectangles with the same area, what shape is likely to makeeach of the methods perform the worst?Which method should be preferred for range searching in the case thatthe points cluster together in large groups spaced far apart?Draw the 3D tree that results when the points (3,1,5) (4,8,3) (8,3,9)(6,277) (1,673) (1,375) (6,4,2)are inserted into an initially empty tree.
27. Geometric IntersectionA natural problem arising frequently in applications involving geometricdata is: ﬁGiven a set of N objects, do any two intersect?ﬂ The ﬁobjectsﬂinvolved may be lines, rectangles, circles, polygons, or other types of geometricobjects. For example, in a system for designing and processing integrated
circuits or printed circuit boards, it is important to know that no two wires
intersect to make a short circuit. In an industrial application for designing
layouts to be executed by a numerically controlled cutting tool, it is important
to know that no two parts of the layout intersect. In computer graphics,
the problem of determining which of a set of objects is obscured from a
particular viewpoint can be formulated as a geometric intersection problem
on the projections of the objects onto the viewing plane. And in operations
research, the mathematical formulation of many important problems leadsnaturally to a geometric intersection problem.The obvious solution to the intersection problem is to check each pair ofobjects to see if they intersect. Since there are about ;Nﬂ pairs of objects, therunning time of this algorithm is proportional to N2. For many applications,this is not a problem because other factors limit the number of objects whichcan be processed. However, geometric applications systems have become
much more ambitious, and it is not uncommon to have to process hundreds
of thousands or even millions of objects.The brute-force N2 algorithm isobviously inadequate for such applications. In this section, we™ll study ageneral method for determining whether any two out of a set of N objects
intersect in time proportional to N log N, based on algorithms presented by
M. Shamos and D. Hoey in a seminal paper in 1976.First, we™ll consider an algorithm for returning all intersecting pairsamong a set of lines that are constrained to be horizontal or vertical. Thismakes the problem easier in one sense (horizontal and vertical lines are rela-tively simple geometric objects), more difficult in another sense (returning all349
350CHAPTER 27intersecting pairs is more difficult than simply determining whether one suchpair exists). The implementation that we™ll develop applies binary search treesand the interval range-searching program of the previous chapter in a doublyrecursive program.Next, we™ll examine the problem of determining whether any two of aset of N lines intersect, with no constraints on the lines. The same generalstrategy as used for the horizontal-vertical case can be applied. In fact, thesame basic idea works for detecting intersections among many other types
of geometric objects. However, for lines and other objects, the extension
to return all intersecting pairs is somewhat more complicated than for the
horizontal-vertical case.Horizontal and Vertical LinesTo begin, we™ll assume that all lines are either horizontal or vertical: the twopoints defining each line either have equal x coordinates or equal y coordinates,as in the following sample set of lines:.IIJ(This is sometimes called Manhattan geometry because, the Chrysler buildingnotwithstanding, the Manhattan skyline is often sketched using only horizon-tal and vertical lines.) Constraining lines to be horizontal or vertical is cer-
tainly a severe restriction, but this is far from a ﬁtoyﬂ problem. It is often
the case that this restriction is imposed for some other reason for a particular
GEOMETRIC INTERSECTIONapplication. For example, very large-scale integrated circuits are typicallydesigned under this constraint.The general plan of the algorithm to find an intersection in such a setof lines is to imagine a horizontal scan line sweeping from bottom to topin the diagram. Projected onto this scan line, vertical lines are points, and
horizontal lines are intervals: as the scan line proceeds from bottom to top,
points (representing vertical lines) appear and disappear, and horizontal lines
are periodically encountered. An intersection is found when a horizontal line is
encountered which represents an interval on the scan line that contains a point
representing a vertical line. The point means that the vertical line intersects
the scan line, and the horizontal line lies on the scan line, so the horizontal
and vertical lines must intersect. In this way, the two-dimensional problem of
finding an intersecting pair of lines is reduced to the one-dimensional range-searching problem of the previous chapter.Of course, it is not necessary actually to ﬁsweepﬂ a horizontal line allthe way up through the set of lines: since we only need to take action whenendpoints of the lines are encountered, we can begin by sorting the linesaccording to their y coordinate, then processing the lines in that order. If thebottom endpoint of a vertical line is encountered, we add the x coordinate ofthat line to the tree; if the top endpoint of a vertical line is encountered, wedelete that line from the tree; and if a horizontal line is encountered, we doan interval range search using its two x coordinates. As we™ll see, some care is
required to handle equal coordinates among line endpoints (the reader should
now be accustomed to encountering such difficulties in geometric algorithms).To trace through the operation of our algorithm on our set of samplepoints, we first must sort the line endpoints by their y coordinate:BBDEFHJCGDICAGJFEIEach vertical line appears twice in this list, each horizontal line appearsonce. For the purposes of the line intersection algorithm, this sorted listcan be thought of as a sequence of insert (vertical lines when the bottom
endpoint is encountered), delete (vertical lines when the top endpoint is en-countered), and range (for the endpoints of horizontal lines) commands. Allof these ﬁcommandsﬂ are simply calls on the standard binary tree routinesfrom Chapters 14 and 26, using x coordinates as keys.For our example, we begin with the following sequence of binary searchtrees:
352CHAPTER 27D%EDE3FFirst B is inserted into an empty tree, then deleted. Then D, E, and F areinserted. At this point, H is encountered, and a range search for the interval
defined by H is performed on the rightmost tree in the above diagram. This
search discovers the intersection between H and F. Proceeding down the listabove in order, we add J, C, then G to get the following sequence of trees:DEI:kFJNext, the upper endpoint of D is encountered, so it is deleted; then I is addedand C deleted, which gives the following sequence of trees:At this point A is encountered, and a range search for the interval defined
GEOMETRIC INTERSECTION353by A is performed on the rightmost tree in the diagram above. This searchdiscovers the intersections between A and E, F, and I. (Recall that although
G and J are visited during this search, any points to the left of G or to the
right of J would not be touched.) Finally, the upper endpoints of G, J, F, E,
and I are encountered, so those points are successively deleted, leading back
to the empty tree.The first step in the implementation is to sort the line endpoints on theiry coordinate. But since binary trees are going to be used to maintain thestatus of vertical lines with respect to the horizontal scan line, they may as
well be used for the initial y sort! Specifically, we will use two ﬁindirectﬂ
binary trees on the line set, one with header node hy and one with header
node hx. The y tree will contain all the line endpoints, to be processed inorder one at a time; the x tree will contain the lines that intersect the currenthorizontal scan line. We begin by initializing both hx and hy with 0 keys
and pointers to a dummy external node z, as in treeinitialize in Chapter 14.Then the hy tree is constructed by inserting both y coordinates from verticallines and the y coordinate of horizontal lines into the binary search tree withheader node hy, as follows:procedure buildytree;var N, k, xl, yl, x2, y2: integer;beginreadln (N) ;for k:=l to N dobeginreadln (xl, yl , x2, y2) ;lines[k].pl.x:=xl; lines[k].pl.y:=yl;lines[k].p2.x:=x2; lines[k].p2.y:=y2;bstinsert(k, yl, hy);if y2< >yl then b&insert (k, y2, hy) ;end ;end ;This program reads in groups of four numbers which specify lines, and putsthem into the lines array and the binary search tree on the y coordinate. Thestandard b&insert routine from Chapter 14 is used, with the y coordinates askeys, and indices into the array of lines as the info field. For our example setof lines, the following tree is constructed:
354CHAPTER 27Now, the sort on y is effected by a recursive program with the same recursivestructure as the treeprint routine for binary search trees in Chapter 14. Wevisit the nodes in increasing y order by visiting all the nodes in the left subtreeof the hy tree, then visiting the root, then visiting all the nodes in the rightsubtree of the hy tree. At the same time, we maintain a separate tree (rootedat hx) as described above, to simulate the operation of passing a horizontalscan line through. The code at the point where each node is ﬁvisitedﬂ is rather
straightforward from the description above. First, the coordinates of theendpoint of the corresponding line are fetched from the lines array, indexedby the info field of the node. Then the key field in the node is comparedagainst these to determine whether this node corresponds to the upper or thelower endpoint of the line: if it is the lower endpoint, it is inserted into the
hx tree, and if it is the upper endpoint, it is deleted from the hx tree anda range search is performed. The implementation differs slightly from thisdescription in that horizontal lines are actually inserted into the hx tree, thenimmediately deleted, and a range search for a one-point interval is performedfor vertical lines. This makes the code properly handle the case of overlapping
vertical lines, which are considered to ﬁintersect.ﬂ
GEOMETRIC INTERSECTIONprocedure scan (next: link) ;var t, xl, x2, yl, y2: integer;int: interval;beginif next< > z thenbeginscan(nextf.1);xl:=lines[nextt.info].pl.x; yl :=lines[nextf.info].pl.y;x2:=lines[nextf.info].p2.x; y2:=lines[nextf.info].p2.y;if x2<xl then begin t:=x2; x2:=x1; xl :=t end;if y2<yl then begin t:=y2; y2:=yl; yl :=t end;if nextf.key=yl then bstinsert(nextf.info, xl, hx);if nextf .key=y2 thenbeginbstdelete(nextt.info, xl, hx);i&.x1 :=x1; i&.x2:=x2;write(name(nextt.info), ‚: ‚);bstrange(hxf.r, int);wri teln ;end ;scan (nextf .r)endend ;The running time of this program depends on the number of intersections thatare found as well as the number of lines. The tree manipulation operationstake time proportional to 1ogN on the average (if balanced trees were used,a 1ogN worst case could be guaranteed), but the time spent in b&range alsodepends on the total number of intersections it returns, so the total runningtime is proportional to N log N+I, where I is the number of intersecting pairs.In general, the number of intersections could be quite large. For example, ifwe have N/2 horizontal lines and N/2 vertical lines arranged in a crosshatchpattern, then the number of intersections is proportional to N2. As withrange searching, if it is known in advance that the number of intersectionswill be very large, then some brute-force approach should be used. Typical
applications involve a ﬁneedle-in-haystackﬂ sort of situation where a large set
of lines is to be checked for a few possible intersections.This approach of intermixed application of recursive procedures operat-ing on the x and y coordinates is quite important in geometric algorithms.Another example of this is the 2D tree algorithm of the previous chapter, and
we™ll see yet another example in the next chapter.
356CHAPTER 27General Line IntersectionWhen lines of arbitrary slope are allowed, the situation can become morecomplicated, as illustrated by the following example.First, the various line orientations possible make it necessary to test explicitlywhether certain pairs of lines intersect: we can™t get by with a simple intervalrange test. Second, the ordering relationship between lines for the binary
tree is more complicated than before, as it depends on the current y range
of interest. Third, any intersections which do occur add new ﬁinterestingﬂ yvalues which are likely to be different from the set of y values that we getfrom the line endpoints.It turns out that these problems can be handled in an algorithm with thesame basic structure as given above. To simplify the discussion, we™ll consideran algorithm for detecting whether or not there exists an intersecting pair ina set of N lines, and then we™ll discuss how it can be extended to return allintersections.As before, we first sort on y to divide the space into strips within whichno line endpoints appear. Just as before, we proceed through the sorted listof points, adding each line to a binary search tree when its bottom point isencountered and deleting it when its top point is encountered. Just as before,the binary tree gives the order in which the lines appear in the horizontal
GEOMETRIC INTERSECTION357ﬁstripﬂ between two consecutive y values. For example, in the strip betweenthe bottom endpoint of D and the top endpoint of B in the diagram above,the lines should appear in the order F B D G H. We assume that there are
no intersections within the current horizontal strip of interest: our goal is tomaintain this tree structure and use it to help find the first intersection.To build the tree, we can™t simply use 5 coordinates from line endpointsas keys (doing this would put B and D in the wrong order in the exampleabove, for instance). Instead, we use a more general ordering relationship: aline x is defined to be to the right of a line y if both endpoints of x are on thesame side of y as a point infinitely far to the right, or if y is to the left of 2,with ﬁleftﬂ defined analagously. Thus, in the diagram above, B is to the rightof A and B is to the right of C (since C is to the left of B). If x is neitherto the left nor to the right of y, then they must intersect. This generalizedﬁline comparisonﬂ operation is a simple extension of the same procedure ofChapter 24. Except for the use of this function whenever a comparison isneeded, the standard binary search tree procedures (even balanced trees, if
desired) can be used. For example, the following sequence of diagrams shows
the manipulation of the tree for our example between the time that line C is
encountered and the time that line D is encountered.BH%GBFH9GDEach ﬁcomparisonﬂ performed during the tree manipulation procedures isactually a line intersection test: if the binary search tree procedure can™t
decide to go right or left, then the two lines in question must intersect, andwe™re finished.But this is not the whole story, because this generalized comparisonoperation is not transitive. In the example above, F is to the left of B (becauseB is to the right of F) and B is to the left of D, but F is not to the left of D. Itis essential to note this, because the binary tree deletion procedure assumes
that the comparison operation is transitive: when B is deleted from the last
tree in the above sequence, the tree
358CHAPTER 27is formed without F and D ever having been explicitly compared. For ourintersection-testing algorithm to work correctly, we must explicitly test thatcomparisons are valid each time we change the tree structure. Specifically,
every time we make the left link of node 5 point to node y, we explicitly testthat the line corresponding to x is to the left of the line corresponding to y,according to the above definition, and similarly for the right. Of course, this
comparison could result in the detection of an intersection, as it does in our
example.In summary, to test for an intersection among a set of N lines, we usethe program above, but with the call to range removed, and with the binarytree routines extended to use the generalized comparison as described above.If there is no intersection, we™ll start with a null tree and end with a null treewithout finding any incomparable lines. If there is an intersection, then thetwo lines which intersect must be compared against each other at some pointduring the scanning process and the intersection discovered.Once we™ve found an intersection, we can™t simply press on and hopeto find others, because the two lines that intersect should swap places inthe ordering directly after the point of intersection. One way to handle thisproblem would be to use a priority queue instead of a binary tree for the ﬁysortﬂ: initially put lines on the priority queue according to the y coordinates oftheir endpoints, then work the scan line up by successively taking the smallest
y coordinate from the priority queue and doing a binary tree insert or delete
as above. When an intersection is found, new entries are added to the priorityqueue for each line, using the intersection point as the lower endpoint for each.Another way to find all intersections, which is appropriate if not toomany are expected, is to simply remove one of the intersecting lines whenan intersection is found. Then after the scan is completed, we know that allintersecting pairs must involve one of those lines, so we can use a brute forcemethod to enumerate all the intersections.An interesting feature of the above procedure is that it can be adapted tosolve the problem for testing for the existence of an intersecting pair amonga set of more general geometric shapes just by changing the generalizedcomparison procedure. For example, if we implement a procedure which
GEOMETRIC INTERSECTION359compares two rectangles whose edges are horizontal and vertical according tothe trivial rule that rectangle 5 is to the left of rectangle y if the right edge ofx is to the left of the left edge of y, then we can use the above method to testfor intersection among a set of such rectangles. For circles, we can use the x
coordinates of the centers for the ordering, but explicitly test for intersection
(for example, compare the distance between the centers to the sum of theradii). Again, if this comparison procedure is used in the above method, wehave an algorithm for testing for intersection among a set of circles. Theproblem of returning all intersections in such cases is much more complicated,
though the brute-force method mentioned in the previous paragraph willalways work if few intersections are expected. Another approach that willsuffice for many applications is simply to consider complicated objects as setsof lines and to use the line intersection procedure.rl
360Exercises1. How would you determine whether two triangles intersect? Squares?Regular n-gons for n > 4?2. In the horizontal-vertical line intersection algorithm, how many pairs oflines are tested for intersection in a set of lines with no intersections inthe worst case? Give a diagram supporting your answer.3.What happens if the horizontal-vertical line intersection procedure is usedon a set of lines with arbitrary slope?4. Write a program to find the number of intersecting pairs among a setof N random horizontal and vertical lines, each line generated with tworandom integer coordinates between 0 and 1000 and a random bit todistinguish horizontal from vertical.5. Give a method for testing whether or not a given polygon is simple(doesn™t intersect itself).6.Give a method for testing whether one polygon is totally contained withinanother.7Describe how you would solve the general line intersection problem giventhe additional fact that the minimum separation between two lines isgreater than the maximum length of the lines.8. Give the binary tree structure that exists when the line intersectionalgorithm detects an intersection in the following set of lines:9.Are the comparison procedures for circles and Manhattan rectangles thatare described in the text transitive?10. Write a program to find the number of intersecting pairs among a setof N random lines, each line generated with random integer coordinatesbetween 0 and 1000.
28. Closest Point ProblemsGeometric problems involving points on the plane usually involve im-plicit or explicit treatment of distances between the points. For ex-ample, a very natural problem which arises in many applications is the nearest-neighbor problem: find the point among a set of given points closest to a givennew point. This seems to involve checking the distance from the given point toeach point in the set, but we™ll see that much better solutions are possible. In
this section we™ll look at some other distance problems, a prototype algorithm,
and a fundamental geometric structure called the Voronoi diagram that canbe used effectively for a variety of such problems in the plane. Our approachwill be to describe a general method for solving closest point problems throughcareful consideration of a prototype implementation, rather than developingfull implementations of programs to solve all of the problems.Some of the problems that we consider in this chapter are similar to therange-searching problems of Chapter 26, and the grid and 2D tree methodsdeveloped there are suitable for solving the nearest-neighbor and other prob-
lems. The fundamental shortcoming of those methods is that they rely on
randomness in the point set: they have bad worst-case performance. Our aim
in this chapter is to examine yet another general approach that has guaranteed
good performance for many problems, no matter what the input. Some of the
methods are too complicated for us to examine a full implementation, and
they involve sufficient overhead that the simpler methods may do better for
actual applications where the point set is not large or where it is sufficientlywell dispersed. However, we™ll see that the study of methods with good worst-case performance will uncover some fundamental properties of point sets thatshould be understood even if simpler methods turn out to be more suitable.The general approach that we™ll be examining provides yet another ex-ample of the use of doubly recursive procedures to intertwine processing alongthe two coordinate directions. The two previous methods of this type that361
362CHAPTER 28we™ve seen (IcD trees and line intersection) have been based on binary searchtrees; in this case the method is based on mergesort.Closest PairThe closest-pair problem is to find the two points that are closest togetheramong a set of points. This problem is related to the nearest-neighbor prob-
lem; though it is not as widely applicable, it will serve us well as a prototype
closest-point problem in that it can be solved with an algorithm whose general
recursive structure is appropriate for other problems.It would seem necessary to examine the distances between all pairs ofpoints to find the smallest such distance: for N points this would mean arunning time proportional to N2.However, it turns out that we can usesorting to get by with only examining about N log N distances between pointsin the worst case (far fewer on the average) to get a worst-case running time
proportional to N 1ogN (far better on the average). In this section, we™llexamine such an algorithm in detail.The algorithm that we™ll use is based on a straightforward ﬁdivide-and-conquerﬂ strategy. The idea is to sort the points on one coordinate, say thex coordinate, then use that ordering to divide the points in half. The closestpair in the whole set is either the closest pair in one of the halves or the
closest pair with one member in each half. The interesting case, of course, is
when the closest pair crosses the dividing line: the closest pair in each halfcan obviously be found by using recursive calls, but how can all the pairs oneither side of the dividing line be checked efficiently?Since the only information we seek is the closest pair of the point set,we need examine only points within distance min of the dividing line, wheremin is the smaller of the distances between the closest pairs found in the two
halves. By itself, however, this observation isn™t enough help in the worst
case, since there could be many pairs of points very close to the dividing line.
For example, all the points in each half could be lined up right next to thedividing line.To handle such situations, it seems necessary to sort the points on y.Then we can limit the number of distance computations involving each pointas follows: proceeding through the points in increasing y order, check if each
point is inside the vertical strip consisting of all points in the plane within min
of the dividing line. For each such point, compute the distance between it and
any point also in the strip whose y coordinate is less than the y coordinate
of the current point, but not more than min less. The fact that the distance
between all pairs of points in each half is at least min means that only a fewpoints are likely to be checked, as demonstrated in our example set of points:
CLOSEST POINT PROBLEMS363III/&I ‚1.l LJ\MA vertical dividing line just to the right of F has eight points to the left, eightpoints to the right. The closest pair on the left half is AC (or AO), the closestpair on the right is JM. If we have the points sorted on y, then the closest pairwhich is split by the line is found by checking the pairs HI, CI, FK, which isthe closest pair in the whole point set, and finally EK.Though this algorithm is simply stated, some care is required to imple-ment it efficiently: for example, it would be too expensive to sort the pointson y within our recursive subroutine. We™ve seen several algorithms with a
running time described by the recurrence T(N) = 2T(N/2)+N, which impliesthat T(N) is proportional to N log N; if we were to do the full sort on y, thenthe recurrence would become T(N) = 2T(N/2) + Nlog N, and it turns outthat this implies that T(N) is proportional to N log2 N. To avoid this, weneed to avoid the sort of y.The solution to this problem is simple, but subtle. The mergesort methodfrom Chapter 12 is based on dividing the elements to be sorted exactly asthe points are divided above. We have two problems to solve and the samegeneral method to solve them, so we may as well solve them simultaneously!Specifically, we™ll write one recursive routine that both sorts on y and finds theclosest pair. It will do so by splitting the point set in half, then calling itself
recursively to sort the two halves on y and find the closest pair in each half,
364CHAPTER 28then merging to complete the sort on y and applying the procedure above tocomplete the closest pair computation. In this way, we avoid the cost of doingan extra y sort by intermixing the data movement required for the sort withthe data movement required for the closest pair computation.For the y sort, the split in half could be done in any way, but forthe closest pair computation, it™s required that the points in one half allhave smaller z coordinates than the points in the other half. This is easilyaccomplished by sorting on x before doing the division. In fact, we may aswell use the same routine to sort on z! Once this general plan is accepted,the implementation is not difficult to understand.As mentioned above, the implementation will use the recursive sort andmerge procedures of Chapter 12. The first step is to modify the list structuresto hold points instead of keys, and to modify merge to check a global variable
pass to decide how to do its comparison. If pass=l, the comparison shouldbe done using the x coordinates of the two points; if pass=2 we do the ycoordinates of the two points. The dummy node z which appears at theend of all lists will contain a ﬁsentinelﬂ point with artificially high z and ycoordinates.The next step is to modify the recursive sort of Chapter 12 also to do theclosest-point computation when pass=2. This is done by replacing the linecontaining the call to merge and the recursive calls to sort in that programby the following code:if pass=2 then middle:=bt.p.x;c:=merge(sort(a, N div 2), sort(b, N-(N div 2)));sort:=c;if pass=2 thenbegina:=c; pl :=zt.p; p2:=zt.p; p3:=zt.p; p4:=zf.p;repeatif abs(at.p.x-middle)<min thenbegincheck(at.p, pl);check( at .p, p2) ;check(af.p, ~3);check(at.p, ~4);pl :=p2; p2:=p3; p3:=p4; p4:=at.pend ;a:=af.nextuntil a=zend
CLOSEST POINT PROBLEMS365If pass=1, this is straight mergesort: it returns a linked list containing thepoints sorted on their z coordinates (because of the change to merge). Themagic of this implementation comes when pass=2. The program not only sortson y but also completes the closest-point computation, as described in detailbelow. The procedure check simply checks whether the distance between the
two points given as arguments is less than the global variable min. If so, it
resets min to that distance and saves the points in the global variables cpl
and cp2. Thus, the global min always contains the distance between cpl andcp2, the closest pair found so far.First, we sort on x, then we sort on y and find the closest pair by invokingsort as follows:new(z); zf.next:=z;zf.p.x:=maxint; zt.p.y:=maxint;new(h); ht.next:=readlist;min:=maxint;pass:=l; hf.next:=sort(hf.next, N);pass:=2; hf.next:=sort(hf.next, N);After these calls, the closest pair of points is found in the global variables cpland cp2 which are managed by the check ﬁfind the minimumﬂ procedure.The crux of the implementation is the operation of sort when pass=2.Before the recursive calls the points are sorted on x: this ordering is used todivide the points in half and to find the x coordinate of the dividing line. Ajterthe recursive calls the points are sorted on y and the distance between everypair of points in each half is known to be greater than min. The ordering ony is used to scan the points near the dividing line; the value of min is used tolimit the number of points to be tested. Each point within a distance of minof the dividing line is checked against each of the previous four points found
within a distance of min of the dividing line. This is guaranteed to find any
pair of points closer together than min with one member of the pair on eitherside of the dividing line. This is an amusing geometric fact which the readermay wish to check. (We know that points which fall on the same side of thedividing line are spaced by at least min, so the number of points falling in anycircle of radius min is limited.)It is interesting to examine the order in which the various vertical dividinglines are tried in this algorithm. This can be described with the aid of thefollowing binary tree:
CHAPTER 28G OA DE CH FI KB PN JM LEach node in this tree represents a vertical line dividing the points in the leftand right subtree. The nodes are numbered in the order in which the verticallines are tried in the algorithm. Thus, first the line between G and 0 is triedand the pair GO is retained as the closest so far. Then the line between A and
D is tried, but A and D are too far apart to change min. Then the line between0 and A is tried and the pairs GD G-4 and OA all are successively closer pairs.It happens for this example that no closer pairs are found until FK, which isthe last pair checked for the last dividing line tried. This diagram reflects the
difference between top-down and bottom-up mergesort. A bottom-up versionof the closest-pair problem can be developed in the same way as for mergesort,which would be described by a tree like the one above, numbered left to rightand bottom to top.The general approach that we™ve used for the closest-pair problem canbe used to solve other geometric problems. For example, another problem ofinterest is the all-nearest-neighbors problem: for each point we want to find
the point nearest to it. This problem can be solved using a program like the
one above with extra processing along the dividing line to find, for each point,
whether there is a point on the other side closer than its closest point on its
own side. Again, the ﬁfreeﬂ y sort is helpful for this computation.Voronoi DiagramsThe set of all points closer to a given point in a point set than to all other pointsin the set is an interesting geometric structure called the Voronoi polygon forthe point. The union of all the Voronoi polygons for a point set is called itsVoronoi diagram. This is the ultimate in closest-point computations: we™ll seethat most of the problems involving distances between points that we facehave natural and interesting solutions based on the Voronoi diagram. Thediagram for our sample point set is comprised of the thick lines in the diagrambelow:
CLOSEST POINT PROBLEMS367Basically, the Voronoi polygon for a point is made up of the perpendicularbisectors separating the point from those points closest to it. The actualdefinition is the other way around: the Voronoi polygon is defined to be theset of all points in the plane closer to the given point than to any other point
in the point set, and the points ﬁclosest toﬂ a point are defined to be those that
lead to edges on the Voronoi polygon. The dual of the Voronoi diagram makes
this correspondence explicit: in the dual, a line is drawn between each pointand all the points ﬁclosest toﬂ it. Put another way, x and y are connected inthe Voronoi dual if their Voronoi polygons have an edge in common. The dualfor our example is comprised of the thin dotted lines in the above diagram.The Voronoi diagram and its dual have many properties that lead toefficient algorithms for closest-point problems. The property that makes thesealgorithms efficient is t,hat the number of lines in both the diagram and thedual is proportional to a small constant times N. For example, the lineconnecting the closest pair of points must be in the dual, so the problem ofthe previous section can be solved by computing the dual and then simply
finding the minimum length line among the lines in the dual. Similarly, the
line connecting each point to its nearest neighbor must be in the dual, so theall-nearest-neighbors problem reduces directly to finding the dual. The convexhull of the point set is part of the dual, so computing the Voronoi dual is yet
CHAPTER 28another convex hull algorithm. We™ll see yet another example in Chapter 31of a problem which can be efficiently solved by first finding the Voronoi dual.The defining property of the Voronoi diagram means that it can be usedto solve the nearest-neighbor problem: to identify the nearest neighbor in apoint set to a given point, we need only find out which Voronoi polygon the
point falls in. It is possible to organize the Voronoi polygons in a structure
like a 2D tree to allow this search to be done efficiently.The Voronoi diagram can be computed using an algorithm with the samegeneral structure as the closest-point algorithm above. The points are firstsorted on their x coordinate. Then that ordering is used to split the points in
half, leading to two recursive calls to find the Voronoi diagram of the pointset for each half. At the same time, the points are sorted on y; finally, thetwo Voronoi diagrams for the two halves are merged together. As before, the
merging together (done with pass=2) can make use of the fact that the pointsare sorted on x before the recursive calls and that they are sorted on y and theVoronoi diagrams for the two halves have been built after the recursive calls.However, even with these aids, it is quite a complicated task, and presentationof a full implementation would be beyond the scope of this book.The Voronoi diagram is certainly the natural structure for closest-pointproblems, and understanding the characteristics of a problem in terms ofthe Voronoi diagram or its dual is certainly a worthwhile exercise. However,
for many particular problems, a direct implementation based on the generalschema given in this chapter may be suitable. This is powerful enough tocompute the Voronoi diagram, so it is powerful enough for algorithms basedon the Voronoi diagram, and it may admit to simpler, more efficient code, justas we saw for the closest-nair nroblem.
369Exercises1.2.3.4.5.6.7.8.9.10.Write programs to solve the nearest-neighbor problem, first using the gridmethod, then using 2D trees.Describe what happens when the closest-pair procedure is used on a setof points that fall on the same horizontal line, equally spaced.Describe what happens when the closest-pair procedure is used on a setof points that fall on the same vertical line, equally spaced.Give an algorithm that, given a set of 2N points, half with positive zcoordinates, half with negative x coordinates, finds the closest pair withone member of the pair in each half.Give the successive pairs of points assigned to cpl and cp2 when theprogram in the text is run on the example points, but with A removed.Test the effectiveness of making min global by comparing the performanceof the implementation given to a purely recursive implementation forsome large random point set.Give an algorithm for finding the closest pair from a set of lines.Draw the Voronoi diagram and its dual for the points A B C D E F fromthe sample point set.Give a ﬁbrute-forceﬂ method (which might require time proportional toN2) for computing the Voronoi diagram.Write a program that uses the same recursive structure as the closest-pairimplementation given in the text to find the convex hull of a set of points.
370SOURCES for Geometric AlgorithmsMuch of the material described in this section has actually been developedquite recently, so there are many fewer available references than for older,more central areas such as sorting or mathematical algorithms. Many of the
problems and solutions that we™ve discussed were presented by M. Shamos in1975. Shamos™ manuscript treats a large number of geometric algorithms, andhas stimulated much of the recent research.For the most part, each of the geometric algorithms that we™ve discussedis described in its own original reference. The convex hull algorithms treatedin Chapter 25 may be found in the papers by Jarvis, Graham, and Eddy. Therange searching methods of Chapter 26 come from Bentley and Freidman™ssurvey article, which contains many references to original sources (of particularinterest is Bentley™s own original article on kD trees, written while he was anundergraduate). The treatment of the closest point problems in Chapter 28 isbased on Shamos and Hoey™s 1976 paper, and the intersection algorithms ofChapter 27 are from their 1975 paper and the article by Bentley and Ottmann.But the best route for someone interested in learning more about geomet-ric algorithms is to implement some, work with them and try to learn abouttheir behavior on different types of point sets. This field is still in its infancy
and the best algorithms are yet to be discovered.J. L. Bentley, ﬁMultidimensional binary search trees used for associativesearching,ﬂ Communications of the ACM, 18, 9 (September, 1975).J. L. Bentley and J.H. Friedman, ﬁData structures for range searching,ﬂComputing Surveys, 11, 4 (December, 1979).J. L. Bentley and T. Ottmann, ﬁAlgorithms for reporting and counting geomet-ric intersections,ﬂIEEE Transactions on Computing, C-28, 9 (September,1979).W. F. Eddy, ﬁA new convex hull algorithm for planar sets,ﬂ ACM Transactionson Mathematical Software, 3 (1977).R. L. Graham, ﬁAn efficient algorithm for determining the convex hull of afinite planar set,ﬂ Information Processing Letters, 1 (1972).R. A. Jarvis,ﬁOn the identification of the convex hull of a finite set of pointsin the plane,ﬂ Information Processing Letters, 2 (1973).M. I. Shamos, Problems in Computational Geometry, unpublished manuscript,1975.M. I. Shamos and D. Hoey, ﬁClosest-point problems,ﬂ in 16th Annual Sympo-sium on Foundations of Computer Science, IEEE, 1975.M. I. Shamos and D. Hoey,ﬁGeometric intersection problems,ﬂ in 17th AnnualSymposium on Foundations of Computer Science, IEEE, 1976.
GRAPH ALGORITHMS

29. Elementary Graph AlgorithmsA great many problems are naturally formulated in terms of objectsand connections between them. For example, given an airline routemap of the eastern U. S., we might be interested in questions like: ﬁWhat™sthe fastest way to get from Providence to Princeton?ﬂ Or we might be more
interested in money than in time, and look for the cheapest way to get from
Providence to Princeton. To answer such questions we need only information
about interconnections (airline routes) between objects (towns).Electric circuits are another obvious example where interconnections be-tween objects play a central role. Circuit elements like transistors, resistors,and capacitors are intricately wired together. Such circuits can be represented
and processed within a computer in order to answer simple questions like ﬁIs
everything connected together?ﬂas well as complicated questions like ﬁIfthis circuit is built, will it work?ﬂ In this case, the answer to the first ques-tion depends only on the properties of the interconnections (wires), while theanswer to the second question requires detailed information about both thewires and the objects that they connect.A third example is ﬁjob scheduling,ﬂwhere the objects are tasks to beperformed, say in a manufacturing process, and interconnections indicatewhich jobs should be done before others. Here we might be interested inanswering questions like ﬁWhen should each task be performed?ﬂA graph is a mathematical object which accurately models such situations.In this chapter, we™ll examine some basic properties of graphs, and in the nextseveral chapters we™ll study a variety of algorithms for answering questions ofthe type posed above.Actually, we™ve already encountered graphs in several instances in pre-vious chapters. Linked data structures are actually representations of graphs,and some of the algorithms that we™ll see for processing graphs are similar toalgorithms that we™ve already seen for processing trees and other structures.373
374CHAPTER 29For example, the finite-state machines of Chapters 19 and 20 are representedwith graph structures.Graph theory is a major branch of combinatorial mathematics and hasbeen intensively studied for hundreds of years. Many important and usefulproperties of graphs have been proved, but many difficult problems have yet to
be resolved. We™ll be able here only to scratch the surface of what is known
about graphs, covering enough to be able to understand the fundamental
algorithms.As with so many of the problem domains that we™ve studied, graphshave only recently begun to be examined from an algorithmic point of view.Although some of the fundamental algorithms are quite old, many of theinteresting ones have been discovered within the last ten years. Even trivialgraph algorithms lead to interesting computer programs, and the nontrivial
algorithms that we™ll examine are among the most elegant and interesting
(though difficult to understand) algorithms known.GlossaryA good deal of nomenclature is associated with graphs. Most of the termshave straightforward definitions, and it is convenient to put them in one placeeven though we won™t be using some of them until later.A graph is a collection of vertices and edges. Vertices are simple objectswhich can have names and other properties; an edge is a, connection betweentwo vertices. One can draw a graph by marking points for the vertices anddrawing lines connecting them for the edges, but it must be borne in mind
that the graph is defined independently of the representation. For example,the following two drawings represent the same graph:We define this graph by saying that it consists of the set of vertices A B C DE F G H I J K L M and the set of edges between these vertices AG Al3 ACLMJMJLJKEDFDHIFEAF™GE.
ELEMENTARY GRAPH ALGORITHMS375For some applications, such as the airline route example above, it mightnot make sense to rearrange the placement of the vertices as in the diagramsabove. But for some other applications, such as the electric circuit application
above, it is best to concentrate only on the edges and vertices, independent
of any particular geometric placement. And for still other applications, such
as the finite-state machines in Chapters 19 and 20, no particular geometric
placement of nodes is ever implied. The relationship between graph algorithms
and geometric problems is discussed in further detail in Chapter 31. For now,
we™ll concentrate on ﬁpureﬂ graph algorithms which process simple collections
of edges and nodes.A path from vertex x to y in a graph is a list of vertices in which successivevertices are connected by edges in the graph. For example, BAFEG is a pathfrom B to G in the graph above. A graph is connected if there is a pathfrom every node to every other node in the graph. Intuitively, if the vertices
were physical objects and the edges were strings connecting them, a connected
graph would stay in one piece if picked up by any vertex. A graph which is
not connected is made up of connected components; for example, the graphdrawn above has three connected components. A simple path is a path inwhich no vertex is repeated. (For example, BAFEGAC is not a simple path.)A cycle is a path which is simple except that the first and last vertex are thesame (a path from a point back to itself): the path AFEGA is a cycle.A graph with no cycles is called a tree. There is only one path betweenany two nodes in a tree. (Note that binary trees and other types of trees thatwe™ve built with algorithms are special cases included in this general definition
of trees.) A group of disconnected trees is called a forest. A spanning tree of agraph is a subgraph that contains all the vertices but only enough of the edgesto form a tree. For example, below is a spanning tree for the large componentof our sample graph.Note that if we add any edge to a tree, it must form a cycle (becausethere is already a path between the two vertices that it connects). Also, it iseasy to prove by induction that a tree on V vertices has exactly V - 1 edges.
376CHAPTER 29If a graph with V vertices has less than V - 1 edges, it can™t be connected.If it has more that V - 1 edges, it must have a cycle. (But if it has exactlyV - 1 edges, it need not be a tree.)We™ll denote the number of vertices in a given graph by V, the numberof edges by E. Note that E can range anywhere from 0 to $V(V - 1). Graphswith all edges present are called complete graphs; graphs with relatively fewedges (say less than Vlog V) are called sparse; graphs with relatively few ofthe possible edges missing are called dense.This fundamental dependence on two parameters makes the comparativestudy of graph algorithms somewhat more complicated than many algorithmsthat we™ve studied, because more possibilities arise. For example, one algo-
rithm might take about V2 steps, while another algorithm for the same prob-lem might take (E + V) log E steps. The second algorithm would be better forsparse graphs, but the first would be preferred for dense graphs.Graphs as defined to this point are called undirected graphs, the simplesttype of graph. We™ll also be considering more complicated type of graphs, inwhich more information is associated with the nodes and edges. In weightedgraphs integers (weights) are assigned to each edge to represent, say, distancesor costs. In directed graphs , edges are ﬁone-wayﬂ: an edge may go from x toy but not the other way. Directed weighted graphs are sometimes called net-works. As we™ll discover, the extra information weighted and directed graphscontain makes them somewhat more difficult to manipulate than simple un-directed graphs.RepresentationIn order to process graphs with a computer program, we first need to decidehow to represent them within the computer. We™ll look at two commonly usedrepresentations; the choice between them depends whether the graph is denseor sparse.The first step in representing a graph is to map the vertex names tointegers between 1 and V. The main reason for doing this is to make itpossible to quickly access information corresponding to each vertex, usingarray indexing. Any standard searching scheme can be used for this purpose:for instance, we can translate vertex names to integers between 1 and Vby maintaining a hash table or a binary tree which can be searched to findthe integer corresponding to any given vertex name. Since we have alreadystudied these techniques, we™ll assume that we have available a function indexto convert from vertex names to integers between 1 and V and a function nameto convert from integers to vertex names. In order to make the algorithms easyto follow, our examples will use one-letter vertex names, with the ith letterof the alphabet corresponding to the integer i. Thus, though name and index
ELEMENTARY GRAPH ALGORITHMS377are trivial to implement for our examples, their use makes it easy to extendthe algorithms to handle graphs with real vertex names using techniques fromChapters 14-17.The most straightforward representation for graphs is the so-called ad-jacenc y matrix representation.A V-by-V array of boolean values is main-tained, with a[x, y] set to true if there is an edge from vertex x to vertex yand false otherwise. The adjacency matrix for our example graph is givenbelow.ABCDEFGHIJKLMA1110011000000B1100000000000c1010000000000D0001110000000E0001111000000F1001110000000G1000101000000H000000011000010000000110000J0000000001111KOOOOOOOOO11 0 0L0000000001011M0000000001011Notice that each edge is really represented by two bits: an edge connectingx and y is represented by true values in both a[x, y] and a[y, x]. While itis possible to save space by storing only half of this symmetric matrix, itis inconvenient to do so in Pascal and the algorithms are somewhat simpler
with the full matrix. Also, it™s sometimes convenient to assume that there™s
an ﬁedgeﬂ from each vertex to itself, so a[x, x] is set to 1 for x from 1 to V.A graph is defined by a set of nodes and a set of edges connecting them.To read in a graph, we need to settle on a format for reading in these sets.The obvious format to use is first to read in the vertex names and then read
in pairs of vertex names (which define edges). As mentioned above, one easyway to proceed is to read the vertex names into a hash table or binary searchtree and to assign to each vertex name an integer for use in accessing vertex-indexed arrays like the adjacency matrix. The ith vertex read can be assignedthe integer i. (Also, as mentioned above, we™ll assume for simplicity in ourexamples that the vertices are the first V letters of the alphabet, so that wecan read in graphs by reading V and E, then E pairs of letters from the first
378CHAPTER 29V letters of the alphabet.) Of course, the order in which the edges appear isnot relevant. All orderings of the edges represent the same graph and resultin the same adjacency matrix, as computed by the following program:program adjmatrix(input, output);const maxV=50;var j, x, y, V, E: integer;a: array[l..maxV, l..maxq of boolean;beginreadln (V, E) ;for x:=1 to Vdofor y:=l to V do a[x, y] :=false;for x:=1 to V do a[x, x] :=true;for j:=l to E dobeginreadln (vl , v2) ;x:=index(vl); y:=index(v2);a[x,y]:=true; a[y,x]:=trueend ;end.The types of vl and v2 are omitted from this program, as well as the code forindex. These can be added in a straightforward manner, depending on thegraph input representation desired. (For our examples, vl and v2 could be oftype char and index a simple function which uses the Pascal ord function.)The adjacency matrix representation is satisfactory only if the graphsto be processed are dense: the matrix requires V2 bits of storage and V2steps just to initialize it. If the number of edges (the number of one bitsin the matrix) is proportional to V2,then this may be no problem becauseabout V2 steps are required to read in the edges in any case, but if the graphis sparse, just initializing this matrix could be the dominant factor in therunning time of an algorithm. Also this might be the best representation forsome algorithms which require more than V2 steps for execution. Next we™lllook at a representation which is more suitable for graphs which are not dense.In the adjacency structure representation all the vertices connected toeach vertex are listed on an adjacency list for that vertex. This can be easilyaccomplished with linked lists, as shown in the program below which buildsthe adjacency structure for our sample graph.
ELEMENTARY GRAPH ALGORITHMS379program adjlist(input, output);const maxV= 1000;type link=fnode;node=record v: integer; next: link end;var j, x, y, V, E: integer;t, z: link;adj: array[I..maxV] of link;beginreadln (V, E) ;new(z); zt.next:=z;for j:=l to V do adjb] :=z;for j:=l to E dobeginreadln (vl , v2) ;x:=index(vl); y:=index(v2);new(t); tt.v:=x; tf.next:=adj[y]; adj[y]:=t;new(t); tf.v:=y; tt.next:=adj[x]; adj[x]:=t;end ;end.(As usual, each linked list ends with a link to an artificial node z, whichlinks to itself.) For this representation, the order in which the edges appear
in the input is quite relevant: it (along with the list insertion method used)determines the order in which the vertices appear on the adjacency lists. Thus,the same graph can be represented in many different ways in an adjacencylist structure. Indeed, it is difficult to predict what the adjacency lists will
look like by examining just the sequence of edges, because each edge involvesinsertions into two adjacency lists.The order in which edges appear on the adjacency list affects, in turn, theorder in which edges are processed by algorithms. That is, the adjacency liststructure determines the way that various algorithms that we™ll be examiningﬁseeﬂ the graph. While an algorithm should produce a correct answer nomatter what the order of the edges on the adjacency lists, it might get to thatanswer by quite different sequences of computations for different orders. Andif there is more than one ﬁcorrect answer,ﬂdifferent input orders might leadto different output results.If the edges appear in the order listed after the first drawing of our samplegraph at the beginning of the chapter, the program above builds the followingadjacency list structure:
CXAPTER 29A: F C B GB: AC: AD: F EE: G F DF: A E DG: E AH: II: HJ: K L MK: JL: J MM: J LNote that again each edge is represented twice: an edge connecting x andy is represented as a node containing x on y™s adjacency list and as a nodecontaining y on x™s adjacency list.It is important to include both, sinceotherwise simple questions like ﬁWhich nodes are connected directly to nodex?ﬂ could not be answered efficiently.Some simple operations are not supported by this representation. Forexample, one might want to delete a vertex, x, and all the edges connected toit. It™s not sufficient to delete nodes from the adjacency list: each node on theadjacency list specifies another vertex whose adjacency list must be searchedfor a node corresponding to x to be deleted. This problem can be corrected bylinking together the two list nodes which correspond to a particular edge and
making the adjacency lists doubly linked. Then if an edge is to be removed,
both list nodes corresponding to that edge can be deleted quickly. Of course,all these extra links are quite cumbersome to process, and they certainlyshouldn™t be included unless operations like deletion are needed.Such considerations also make it plain why we don™t use a ﬁdirectﬂrepresentation for graphs: a data structure which exactly models the graph,with vertices represented as allocated records and edge lists containing links
to vertices instead of vertex names. How would one add an edge to a graph
represented in this way?Directed and weighted graphs are represented with similar structures. Fordirected graphs, everything is the same, except that each edge is representedjust once: an edge from x to y is represented by a true value in a [x, y] inthe adjacency matrix or by the appearance of y on x™s adjacency list in theadjacency structure. Thus an undirected graph might be thought of as adirected graph with directed edges going both ways between each pair ofvertices connected by an edge. For weighted graphs, everything again is thesame except that we fill the adjacency matrix with weights instead of boolean
ELEMENTARY GRAPH ALGORITHMSvalues (using some non-existent weight to represent false), or we include afield for the edge weight in adjacency list records in the adjacency structure.It is often necessary to associate other information with the verticesor nodes of a graph to allow it to model more complicated objects or tosave bookkeeping information in complicated algorithms. Extra information
associated with each vertex can be accommodated by using auxiliary arrays
indexed by vertex number (or by making adj an array of records in the
adjacency structure representation). Extra information associated with each
edge can be put in the adjacency list nodes (or in an array a of records in
the adjacency matrix representation), or in auxiliary arrays indexed by edge
number (this requires numbering the edges).Depth-First SearchAt the beginning of this chapter, we saw several natural questions that ariseimmediately when processing a graph. Is the graph connected? If not, what
are its connected components? Does the graph have a cycle? These and many
other problems can be easily solved with a technique called depth-first search,which is a natural way to ﬁvisitﬂ every node and check every edge in the graphsystematically. We™ll see in the chapters that follow that simple variationson a generalization of this method can be used to solve a variety of graphproblems.For now, we™ll concentrate on the mechanics of examining every pieceof the graph in an organized way. Below is an implementation of depth-firstsearch which fills in an array vaJ [l..Vl as it visits every vertex of the graph.The array is initially set to all zeros, so vaJ[k]=O indicates that vertex k hasnot yet been visited. The goal is to systematically visit all the vertices of thegraph, setting the vaJ entry for the nowth vertex visited to now, for now=1,2,...,V. The program uses a recursive procedure visit which visits all thevertices in the same connected component as the vertex given in the argument.To visit a vertex, we check all its edges to see if they lead to vertices whichhaven™t yet been visited (as indicated by 0 vaJ entries); if so, we visit them:
382CHAPTER 29procedure dfs;var now, k: integer;val: array [l..maxv] of integer;procedure visit(k: integer);var t: link;beginnow:=now+l; val[k] :=now;t:=adj[k];while t<>z dobeginif val[tt.v]=O then visit(tf.v);t:=tf.nextendend ;beginnow:=O;for k:=l to V do val[k] :=O;for k:=l to V doif val[k]=O then visit(k)end ;First visit is called for the first vertex, which results in nonzero val valuesbeing set for all the vertices connected to that vertex. Then dfs scans throughthe vaJ array to find a zero entry (corresponding to a vertex that hasn™t beenseen yet) and calls visit for that vertex, continuing in this way until all verticeshave been visited.The best way to follow the operation of depth-first search is to redrawthe graph as indicated by the recursive calls during the visit procedure. Thisgives the following structure.8H98IVertices in this structure are numbered with their val values: the vertices are
ELEMENTARY GRAPH ALGORITHMSactually visited in the order A F E G D C B H I J K L M. Each connectedcomponent leads to a tree, called the depth-first search tree. It is importantto note that this forest of depth-first search trees is simply another way ofdrawing the graph; all vertices and edges of the graph are examined by the
algorithm.Solid lines in the diagram indicate that the lower vertex was found by thealgorithm to be on the edge list of the upper vertex and had not been visitedat that time, so that a recursive call was made. Dotted lines correspond to
edges to vertices which had already been visited, so the if test in visit failed,
and the edge was not ﬁfollowedﬂ with a recursive call. These comments apply
to the first time each edge is encountered; the if test in visit also guardsagainst following the edge the second time that it is encountered. For example,once we™ve gone from A to F (on encountering F in A™s adjacency list), wedon™t want to go back from F to A (on encountering A in F™s adjacency list).Similarly, dotted links are actually checked twice: even though we checkedthat A was already visited while at G (on encountering A in G™s adjacencylist), we™ll check that G was already visited later on when we™re back at A (onencountering G in A™s adjacency list).A crucial property of these depth-first search trees for undirected graphsis that the dotted links always go from a node to some ancestor in the tree(another node in the same tree, that is higher up on the path to the root).At any point during the execution of the algorithm, the vertices divide intothree classes: those for which visit has finished, those for which visit has onlypartially finished, and those which haven™t been seen at all. By definition ofvisit, we won™t encounter an edge pointing to any vertex in the first class,and if we encounter an edge to a vertex in the third class, a recursive callwill be made (so the edge will be solid in the depth-first search tree). Theonly vertices remaining are those in the second class, which are precisely the
vertices on the path from the current vertex to the root in the same tree, and
any edge to any of them will correspond to a dotted link in the depth-firstsearch tree.The running time of dfs is clearly proportional to V + E for any graph.We set each of the V val values (hence the V term), and we examine eachedge twice (hence the E term).The same method can be applied to graphs represented with adjacencymatrices by using the following visit procedure:
384CHAPTER 29procedure visit(k: integer);var t: integer;beginnow:=now+l; vaI[k] :=now;for t:=l to Vdoif a[k, t] thenif val[t]=O then visit(t);end ;Traveling through an adjacency list translates to scanning through a row inthe adjacency matrix, looking for true values (which correspond to edges). Asbefore, any edge to a vertex which hasn™t been seen before is ﬁfollowedﬂ viaa recursive call. Now, the edges connected to each vertex are examined in adifferent order, so we get a different depth-first search forest:This underscores the point that the depth-first search forest is simplyanother representation of the graph whose particular structure depends bothon the search algorithm and the internal representation used. The runningtime of dfs when this visit procedure is used is proportional to V2, since everybit in the adjacency matrix is checked.Now, testing if a graph has a cycle is a trivial modification of the aboveprogram. A graph has a cycle if and only if a nonaero val entry is discoveredin visit. That is, if we encounter an edge pointing to a vertex that we™vealready visited, then we have a cycle. Equivalently, all the dotted links in thedepth-first search trees belong to cycles.Similarly, depth-first search finds the connected components of a graph.Each nonrecursive call to visit corresponds to a different connected component.An easy way to print out the connected components is to have visit print out
ELEMENTARY GRAPH ALGORITMMS385the vertex being visited (say, by inserting write(name(k)) just before exiting),then print 6ut some indication that a new connected component is to startjust before the call to visit, in dfs (say, by inserting two writeln statements).This technique would produce the following output when dfs is used on theadjacency list representation of our sample graph:GDEFCBAI HKMLJNote that the adjacency matrix version of visit will compute the same con-nected components (of course), but that the vertices will be printed out in a
different order.Extensions to do more complicated processing on the connected com-ponents are straightforward. For example, by simply inserting invaJ[now]=kafter vaJ[k]=now we get the ﬁinverseﬂof the vaJ array, whose nowth entryis the index of the nowth vertex visited. (This is similar to the inverse heapthat we studied at the end of Chapter 11, though it serves a quite differentpurpose.) Vertices in the same connected components are contiguous in thisarray, the index of each new connected component given by the value of now
each time visit is called in dfs. These values could be stored, or used to mark
delimiters in inval (for example, the first entry in each connected componentcould be made negative).The following table would be produced for ourexample if the adjacency list version of dfs were modified in this way:k name(k) vaJIk1 invaJ[k]1A1-12B763C654D575E346F237G428H8-89I9910J10-1011K111112L121213M1313With such techniques, a graph can be divided up into its connected com-
386CHAPTER 29ponents for later processing by more sophisticated algorithms.MazesThis systematic way of examining every vertex and edge of a graph has adistinguished history: depth-first search was first stated formally hundredsof years ago as a method for traversing mazes. For example, at left in thediagram below is a popular maze, and at right is the graph constructed byputting a vertex at each point where there is more than one path to take,then connecting the vertices according to the paths:This is significantly more complicated than early English garden mazes,which were constructed as paths through tall hedges. In these mazes, allwalls were connected to the outer walls, so that gentlemen and ladies couldstroll in and clever ones could find their way out by simply keeping their
right hand on the wall (laboratory mice have reportedly learned this trick).
When independent inside walls can occur, it is necessary to resort to a moresophisticated strategy to get around in a maze, which leads to depth-firstsearch.To use depth-first search to get from one place to another in a maze, weuse visit, starting at the vertex on the graph corresponding to our startingpoint. Each time visit ﬁfollowsﬂ an edge via a recursive call, we walk along
the corresponding path in the maze. The trick in getting around is that we
must walk back along the path that we used to enter each vertex when visitfinishes for that vertex. This puts us back at the vertex one step higher upin the depth-first search tree, ready to follow its next edge.The maze graph given above is an interesting ﬁmedium-sizedﬂ graphwhich the reader might be amused to use as input for some of the algorithms inlater chapters. To fully capture the correspondence with the maze, a weighted
ELEMENTARY GRAPH ALGORITHMS387version of the graph should be used, with weights on edges corresponding todistances (in the maze) between vertices.PerspectiveIn the chapters that follow we™ll consider a variety of graph algorithms largelyaimed at determining connectivity properties of both undirected and directedgraphs. These algorithms are fundamental ones for processing graphs, butare only an introduction to the subject of graph algorithms. Many interestingand useful algorithms have been developed which are beyond the scope ofthis book, and many interesting problems have been studied for which goodalgorithms have not yet been found.Some very efficient algorithms have been developed which are much toocomplicated to present here. For example, it is possible to determine efficientlywhether or not a graph can be drawn on the plane without any intersectinglines. This problem is called the planarity problem, and no efficient algorithmfor solving it was known until 1974, when R. E. Tarjan developed an ingenious(but quite intricate) algorithm for solving the problem in linear time, usingdepth-first search.Some graph problems which arise naturally and are easy to state seemto be quite difficult, and no good algorithms are known to solve them. Forexample, no efficient algorithm is known for finding the minimum-cost tourwhich visits each vertex in a weighted graph. This problem, called thetraveling salesman problem, belongs to a large class of difficult problems thatwe™ll discuss in more detail in Chapter 40. Most experts believe that noefficient algorithms exist for these problems.Other graph problems may well have efficient algorithms, though none hasbeen found. An example of this is the graph isomorphism problem: determinewhether two graphs could be made identical by renaming vertices. Efficientalgorithms are known for this problem for many special types of graphs, butthe general problem remains open.In short, there is a wide spectrum of problems and algorithms for dealingwith graphs. We certainly can™t expect to solve every problem which comesalong, because even some problems which appear to be simple are still bafflingthe experts. But many problems which are relatively easy to solve do arise
quite often, and the graph algorithms that we will study serve well in a great
variety of applications.n
388Exercises1.Which undirected graph representation is most appropriate for determin-ing quickly whether a vertex is isolated (is connected to no other vertices)?2.Suppose depth-first search is used on a binary search tree and the rightedge taken before the left out of each node. In what order are the nodesvisited?3.How many bits of storage are required to represent the adjacency matrixfor an undirected graph with V nodes and E edges, and how many are
required for the adjacency list representation?4.Draw a graph which cannot be written down on a piece of paper withouttwo edges crossing.5. Write a program to delete an edge from a graph represented with ad-jacency lists.6.Write a version of adjlist that keeps the adjacency lists in sorted order ofvertex index. Discuss the merits of this approach.7.Draw the depth-first search forests that result for the example in the textwhen dfs scans the vertices in reverse order (from V down to l), for bothrepresentations.8. Exactly how many times is visit called in the depth-first search of anundirected graph, in terms of the number of vertices V, the number ofedges E, and the number of connected components C?9.Find the shortest path which connects all the vertices in the maze graphexample, assuming each edge to be of length 1.10.Write a program to generate a ﬁrandomﬂ graph of V vertices and E edgesas follows: for each pair of integers i < j between 1 and V, include anedge from i to j if and only if randomint(V*(V-l)div 2) is less thanE. Experiment to determine about how many connected components arecreated for V = E = 10,100, and 1000.
30. ConnectivityThe fundamental depth-first search procedure in the previous chapterfinds the connected components of a given graph; in this section we™llexamine related algorithms and problems concerning other graph connectivityproperties.As a first example of a non-trivial graph algorithm we™ll look at a generali-zation of connectivity called biconnectivity. Here we are interested in knowingif there is more than one way to get from one vertex to another in the graph.A graph is biconnected if and only if there are at least two different pathsconnecting each pair of vertices.Thus even if one vertex and all the edgestouching it are removed, the graph is still connected. If it is important thata graph be connected for some application, it might also be important thatit stay connected. We™ll look at a method for testing whether a graph isbiconnected using depth-first search.Depth-first search is certainly not the only way to traverse the nodes ofa graph. Other strategies are appropriate for other problems. In particular,we™ll look at breadth-first search, a method appropriate for finding the shortestpath from a given vertex to any other vertex. This method turns out to differfrom depth-first search only in the data structure used to save unfinished pathsduring the search. This leads to a generalized graph traversal program thatencompasses not just depth-first and breadth-first search, but also classical
algorithms for finding the minimum spanning tree and shortest paths in the
graph, as we™ll see in Chapter 31.One particular version of the connectivity problem which arises frequentlyinvolves a dynamic situation where edges are added to the graph one by one,interspersed with queries as to whether or not two particular vertices belongto the same connected component.We™ll look at an interesting family ofalgorithms for this problem. The problem is sometimes called the ﬁunion-findﬂproblem, a nomenclature which comes from the application of the algorithms389
390CHAPTER 30to processing simple operations on sets of elements.BiconnectivityIt is sometimes reasonable to design more than one route between points on agraph, so as to handle possible failures at the connection points (vertices). For
example, we can fly from Providence to Princeton even if New York is snowed
in by going through Philadelphia instead. Or the main communications lines
in an integrated circuit might be biconnected, so that the rest of the circuit
still can function if one component fails. Another application, which is not
particularly realistic but which illustrates the concept is to imagine a wartime
stituation where we can make it so that an enemy must bomb at least two
stations in order to cut our rail lines.An articulation point in a connected graph is a vertex which, if deleted,would break the graph into two or more pieces. A graph with no articulationpoints is said to be biconnected. In a biconnected graph, there are two distinctpaths connecting each pair of vertices. If a graph is not biconnected, itdivides into biconnected components, sets of nodes mutually accessible via twodistinct paths. For example, consider the following undirected graph, whichis connected but not biconnected:(This graph is obtained from the graph of the previous chapter by addingthe edges GC, GH, JG, and LG. In our examples, we™ll assume that thesefours edges are added in the order given at the end of the input, so that(for example) the adjacency lists are similar to those in the example of theprevious chapter with eight new entries added to the lists to reflect the fournew edges.) The articulation points of this graph are A (because it connects
B to the rest of the graph), H (because it connects I to the rest of the graph),J (because it connects K to the rest of the graph), and G (because the graphwould fall into three pieces if G were deleted). There are six biconnectedcomponents: ACGDEF, GJLM, and the individual nodes B, H, I, and K.Determining the articulation points turns out to be a simple extension
CONNECTIVITY391of depth-first search. To see this, consider the depth-first search tree for thisgraph (adjacency list representation):Deleting node E will not disconnect the graph because G and D both havedotted links that point above E, giving alternate paths from them to F (E™s
father in the tree). On the other hand, deleting G will disconnect the graphbecause there are no such alternate paths from L or H to E (L™s father).A vertex x is not an articulation point if every son y has some nodelower in the tree connected (via a dotted link) to a node higher in the treethan x, thus providing an alternate connection from x to y. This test doesn™t
quite work for the root of the depth-first search tree, since there are no nodesﬁhigher in the tree.ﬂ The root is an articulation point if it has two or moresons, since the only path connecting sons of the root goes through the root.These tests are easily incorporated into depth-first search by changing thenode-visit procedure into a function which returns the highest point in thetree (lowest val value) seen during the search, as follows:
CHAPTER 30function visit (k: integer): integer;var t: link;m, min: integer;beginnow:=now+l; val[k]:=now; min:=now;t:=adj[k];while t<>z dobeginif val[tt.v]=O thenbeginm:=visit(tt.v);if m<min then min:=m;if m>=val[k] then write(name(k));endelse if val[tt.v]<min then min:=val[tt.v];t:=tf.nextendvisit:=min;end ;This procedure recursively determines the highest point in the tree reach-able (via a dotted link) from any descendant of vertex k and uses this infor-mation to determine if k is an articulation point. Normally this calculationsimply involves testing whether the minimum value reachable from a son ishigher up in the tree, but we need an extra test to determine whether k is theroot of a depth-first search tree (or, equivalently, whether this is the first callto visit for the connected component containing k), since we™re using the samerecursive program for both cases. This test is properly performed outside therecursive visit, so it does not appear in the code above.The program above simply prints out the articulation points. Of course,as before, it is easily extended to do additional processing on the articulationpoints and biconnected components.Also, since it is a depth-first searchprocedure, the running time is proportional to V + E.Besides the ﬁreliabilityﬂ sort of application mentioned above, biconnected-ness can be helpful in decomposing large graphs into manageable pieces. It isobvious that a very large graph may be processed one connected componentat a time for many applications; it is somewhat less obvious but sometimes asuseful that a graph can sometimes be processed one biconnected componentat a time.
CONNECTMTYGraph Traversal AlgorithmsDepth-first search is a member of a family of graph traversal algorithms thatare quite natural when viewed nonrecursively. Any one of these methods can
be used to solve the simple connectivity problems posed in the last chapter.
In this section, we™ll see how one program can be used to implement graph
traversal methods with quite different characteristics, merely by changing the
value of one variable. This method will be used to solve several graph problems
in the chapters which follow.Consider the analogy of traveling through a maze. Any time we face achoice of several vertices to visit, we can only go along a path t,o one of them,so we must ﬁsaveﬂ the others to visit later. One way to implement a programbased on this idea is to remove the recursion from the recursive depth-firstalgorithm given in the previous chapter. This would result in a program thatsaves, on a stack, the point in the adjacency list of the vertex being visitedat which the search should resume after all vertices connected to previousvertices on the adjacency list have been visited. Instead of examining this
implementation in more detail, we™ll look at a more general framework which
encompasses several algorithms.We begin by thinking of the vertices as being divided into three classes:tree (or visited) vertices, those connected together by paths that we™ve trav-ersed; fringe vertices, those adjacent to tree vertices but not yet visited; andunseen vertices, those that haven™t been encountered at all yet. To search aconnected component of a graph systematically (implement the visit procedure
of the previous chapter), we begin with one vertex on the fringe, all others
unseen, and perform the following step until all vertices have been visited:ﬁmove one vertex (call it X) from the fringe to the tree, and put any unseenvertices adjacent to x on the fringe.ﬂGraph traversal methods differ in howit is decided which vertex should be moved from the fringe to the tree.For depth-first search, we always want to choose the vertex from thefringe that was most recently encountered. This can be implemented byalways moving the first vertex on the fringe to the tree, then putting the
unseen vertices adjacent to that vertex (x) at the front of the fringe andmoving vertices adjacent to z which happen to be already on the fringe to thefront. (Note carefully that a completely different traversal method results ifwe leave untouched the vertices adjacent to x which are already on the fringe.)For example, consider the undirected graph given at the beginning ofthis chapter. The following table shows the contents of the fringe each timea vertex is moved to the tree; the corresponding search tree is shown at the
right:
CHAPTER 30394AGEDFCHIJMLKBAG B C FECHJLBF
DFCHJLB
FCHJLB
CHJLB
H J L BI JLBJ L BMLKBLKBK BBIn this algorithm, the fringe essentially operates as a pushdown stack: weremove a vertex (call it 5) from the beginning of the fringe, then go throughx™s edge list, adding unseen vertices to the beginning of the fringe, and movingfringe vertices to the beginning. Note that this is not strictly a stack, since
we use the additional operation of moving a vertex to the beginning. The
algorithm can be efficiently implemented by maintaining the fringe as a linkedlist and keeping pointers into this list in an array indexed by vertex number:we™ll omit this implementation in favor of a program that can implement other
traversal strategies as well.This gives a different depth-first search tree than the one drawn in thebiconnectivity section above because x™s edges are put on the stack one at atime, so their order is reversed when the stack is popped. The same tree as
for recursive depth-first search would result if we were to append all of z™s
edge list on the front of the stack, then go through and delete from the stack
any other occurrences of vertices from x™s edge list. The reader might find it
interesting to compare this process with the result of directly removing the
recursion from the visit procedure of the previous chapter.By itself, the fringe table does not give enough information to reconstructthe search tree. In order to actually build the tree, it is necessary to store,with each node in the fringe table, the name of its father in the tree. Thisis available when the node is entered into the table (it™s the node that causedthe entry), it is changed whenever the node moves to the front of the fringe,
and it is needed when the node is removed from the table (to determine where
in the tree to attach it).A second classic traversal method derives from maintaining the fringeas a queue: always pick the least recently encountered vertex. This can bemaintained by putting the unseen vertices adjacent to x at the end of the fringe
COivNECTNITY395in the general strategy above. This method is called breadth-first search: firstwe visit a node, then all the nodes adjacent to it, then all the nodes adjacentto those nodes, etc. This leads to the following fringe table and search treefor our example graph:AFCBGEDLJHMKIAF C B GC B G EB G E DG E D
E D L J
D L J HL J HJHMHMKMKIK IIDHWe remove a vertex (call it X) from the beginning of the fringe, then gothrough z™s edge list, putting unseen vertices at the end of the fringe. Again,an efficient implementation is available using a linked list representation forthe fringe, but we™ll omit this in favor of a more general method.A fundamental feature of this general graph traversal strategy is that thefringe is actually operating as a priority queue: the vertices can be assignedpriorities with the property that the ﬁhighest priorityﬂ vertex is the one moved
from the fringe to the tree. That is, we can directly use the priority queue
routines from Chapter 11 to implement a general graph searching program.
For the applications in the next chapter, it is convenient to assign the highest
priority to the lowest value, so we assume that the inequalities are switched
in the programs from Chapter 11. The following program is a ﬁpriority firstsearchﬂ routine for a graph represented with adjacency lists (so it is mostappropriate for sparse graphs).
396CHAPTER 30procedure sparsepfs;var now, k: integer;t: link;beginnow:=O;for k:=l to V dobegin vaI[k] :=unseen; dad[k] :=O end;pqconstruct;repeatk:=pqremove;if val[k]=unseen thenbegin val[k] :=O;now:=now+l endt:=adj[k];while t<>z dobeginif val[tt.v]=unseen then now:=now+l;if onpq(t1.v) and (val[tf.v]>priority) thenbegin pqchange(tt.v, priority); dad[tt.v] :=k end;t:=tf.nextenduntil pqempty;end;(The functions onpq and pqempty are priority queue utility routines whichare easily implemented additions to the set of programs given in Chapter 11:pqempty returns true if the priority queue is empty; onpq returns true if thegiven vertex is currently on the priority queue.) Below and in Chapter 31, we™ll
see how the substitution of various expressions for priority in this program
yields several classical graph traversal algorithms. Specifically, the program
operates as follows: first, we give all the vertices the sentinel value unseen(which could be maxi&) and initialize the dad array, which is used to storethe search tree. Next we construct an indirect priority queue containing allthe vertices (this construction is trivial because the values are initially all thesame). In the terminology above, tree vertices are those which are not onthe priority queue, unseen vertices are those on the priority queue with valueunseen, and fringe vertices are the others on the priority queue. With theseconventions understood, the operation of the program is straightforward: itrepeatedly removes the highest priority vertex from the queue and puts it onthe tree, then updates the priorities of all fringe or unseen vertices connectedto that vertex.If all vertices on the priority queue are unseen, then no vertex previously
CONNECTNlTY397encountered is connected to any vertex on the queue: that is, we™re enteringa new connected component. This is automatically handled by the priorityqueue mechanism, so there is no need for a separate visit procedure inside amain procedure. But note that maintaining the proper value of now is morecomplicated than for the recursive depth-first search program of the previous
chapter. The convention of this program is to leave the val entry unseen andzero for the root of the depth-first search tree for each connected component:it might be more convenient to set it to zero or some other value (for example,now) for various applications.Now, recall that now increases from 1 to V during the execution of thealgorithm so it can be used to assign unique priorities to the vertices. If wechange the two occurrences of priority in sparsepfs to V-now, we get depth-first search, because newly encountered nodes have the highest priority. Ifwe use now for priority we get breadth-first search, because old nodes havethe highest priority. These priority assignments make the priority queuesoperate like stacks and queues as described above. (Of course, if we were onlyinterested in using depth-first or breadth-first search, we would use a directimplementation for stacks or queues, not priority queues as in sparsepfs.)In the next chapter, we™ll see that other priority assignments lead to otherclassical graph algorithms.The running time for graph traversal when implemented in this waydepends on the method of implementing the priority queue. In general, wehave to do a priority queue operation for each edge and for each vertex, so the
worst case running time should be proportional to (E + V) log V if the priorityqueue is implemented as a heap as indicated. However, we™ve already notedthat for both depth-first and breadth-first search we can take advantage ofthe fact that each new priority is the highest or the lowest so far encountered
to get a running time proportional to E + V. Also, other priority queueimplementations might sometimes be appropriate: for example if the graph isdense then we might as well simply keep the priority queue as an unordered
array. This gives a worst case running time proportional to E + V2 (or justV2), since each edge simply requires setting or resetting a priority, but eachvertex now requires searching through the whole queue to find the highestpriority vertex. An implementation which works in this way is given in thenext chapter.The difference between depth-first and breadth-first search is quite evi-dent when a large graph is considered. The diagram at left below shows theedges and nodes visited when depth-first search is halfway through the maze
graph of the previous chapter starting at the upper left corner; the diagram
at right is the corresponding picture for breadth-first search:
398CHAPTER 30Tree nodes are blackened in these diagrams, fringe nodes are crossed, andunseen nodes are blank. Depth-first search ﬁexploresﬂ the graph by lookingfor new vertices far away from the start point, taking closer vertices only whendead ends are encountered; breadth-first search completely covers the area
close to the starting point, moving farther away only when everything close
has been looked at. Depth-first search is appropriate for one person looking
for something in a maze because the ﬁnext place to lookﬂ is always close by;
breadth-first search is more like a group of people looking for something by
fanning out in all directions.Beyond these operational differences, it is interesting to reflect on thefundamental differences in the implementations of these methods. Depth-firstsearch is very simply expressed recursively (because its underlying data struc-
ture is a stack), and breadth-first search admits to a very simple nonrecursive
implementation (because its underlying data structure is a queue). But we™ve
seen that the true underlying data structure for graph algorithms is a priority
queue, and this admits a wealth of interesting properties to consider. Again,
we™ll see more examples in the next chapter.Union-Find AlgorithmsIn some applications we wish to know simply whether a vertex x is connectedto a vertex y in a graph; the actual path connecting them may not berelevant. This problem has been carefully studied in recent years; someefficient algorithms have been developed which are of independent interest
because they can also be used for processing sets (collections of objects).Graphs correspond to sets of objects in a natural way, with verticescorresponding to objects and edges have the meaning ﬁis in the same set as.ﬂThus, the sample graph in the previous chapter corresponds to the sets {A BC D E F G}, {H I} and {J K L M}.Eac connected component correspondsh
CONNECTIVITY399to a different set. For sets, we™re interested in the fundamental question 3sx in the same set as y?ﬂ This clearly corresponds to the fundamental graphquestion ﬁis vertex x connected to vertex y?ﬂGiven a set of edges, we can build an adjacency list representation of thecorresponding graph and use depth-first search to assign to each vertex theindex of its connected component, so the questions of the form ﬁis x connectedto y?ﬂcan be answered with just two array accesses and a comparison. Theextra twist in the methods that we consider here is that they are dynamic: theycan accept new edges arbitrarily intermixed with questions and answer the
questions correctly using the information received. From the correspondencewith the set problem, the addition of a new edge is called a union operation,and the queries are called jind operations.Our objective is to write a function which can check if two vertices x andy are in the same set (or, in the graph representation, the same connectedcomponent) and, if not, can put them in the same set (put an edge between
them in the graph). Instead of building a direct adjacency list or other
representation of the graph, we™ll gain efficiency by using an internal structure
specifically oriented towards supporting the union and find operations. The
internal structure that we will use is a forest of trees, one for each connectedcomponent. We need to be able to find out if two vertices belong to the sametree and to be able to combine two trees to make one. It turns out that bothof these operations can be implemented efficiently.To illustrate the way this algorithm works, we™ll look at the forest con-structed when the edges from the sample graph that we™ve been using inthis chapter are processed in some arbitrary order. Initially, all nodes are inseparate trees. Then the edge AG causes a two node tree to be formed, withA at the root. (This choice is arbitrary -we could equally well have put G atthe root.) The edges AB and AC add B and C to this tree in the same way,
leavingThe edges LM, JM, JL, and JK build a tree containing J, K, L, and M thathas a slightly different structure (note that JL doesn™t contribute anything,
since LM and JM put L and J in the same component), and the edges ED,
FD, and HI build two more trees, leaving the forest:
400CHAPTER 30This forest indicates that the edges processed to this point describe a graphwith four connected components, or, equivalently, that the set union opera-tions processed to this point have led to four sets {A B C G}, {J K L M}, {D EF} and {H I}. Now the edge FE doesn™t contribute anything to the structure,since F and E are in the same component, but the edge AE combines thefirst two trees; then GC doesn™t contribute anything, but GH and JG resultin everything being combined into one tree:It must be emphasized that, unlike depth-first search trees, the onlyrelationship between these union-find trees and the underlying graph withthe given edges is that they divide the vertices into sets in the same way. For
example, there is no correspondence between the paths that connect nodes in
the trees and the paths that connect nodes in the graph.We know that we can represent these trees in exactly the same way thatwe represented graph search trees: we keep an array of integers dad [l ..v]which contains, for each vertex, the index of its father (with a 0 entry fornodes which are at the root of a tree). To find the father of a vertex j, wesimply set j : =dad b] ,and to find the root of the tree to which j belongs, werepeat this operation until reaching 0. The union and find operations are then
COiViVECTMTY401very easily implemented:function find(x, y: integer; union: boolean): boolean;var i, j: integer;begini:=x; while dad[i]>O do i:=dad[i];j:=y; while dadb]>O do j:=dadlj];if union and (i<>j) then dadb] :=i;find:=(i<>j)end ;This function returns true if the two given vertices are in the same component.In addition, if they are not in the same component and the union flag is set,
they are put into the same component. The method used is simple: Use the
dad array to get to the root of the tree containing each vertex, then check tosee if they are the same. To merge the tree rooted at j with the tree rootedat i, we simply set dadb]= .I as shown in the following table:ABCDEFGH IJKLMAG:AAB: AAAC: AAALM: A AALJM: AAAJ LJL: AAAJL *JK: AAAJ J LED:AAEAJ J LFD:AAEF AJ J LHI:AAEF A HJ J LFE:AAEF A HJJL *AF:AAEFAA HJ J LGE:AAEFAA HJJL*GC:AAEFAA HJJL *GH:AAEFAAAHJ J LJG: JAAEFAAAHJ J LLG: JAAEFAAAHJJL *An asterisk at the right indicates that the vertices are already in the samecomponent at the time the edge is processed. As usual, we are assuming
402CHAPTER 30that we have available functions index and name to translate between ver-tex names and integers between 1 and V each table entry is the name ofthe corresponding dad array entry.Also, for example, the function callf?nd(index(x), index(y), f 1a se would be used to test whether a vertex named)x is in the same component as a vertex named y (without introducing an edgebetween them).The algorithm described above has bad worst-case performance becausethe trees formed could be degenerate. For example, taking the edges Al3 BCCD DE EF FG GH HI IJ . . .YZ in that order will produce a long chainwith Z pointing to Y, Y pointing to X, etc. This kind of structure takes timeproportional to V2 to build, and has time proportional to V for an averageequivalence test.Several methods have been suggested to deal with this problem. Onenatural method, which may have already occurred to the reader, is to try todo the ﬁrightﬂ thing when merging two trees rather than arbitrarily settingdadIj]=i. When a tree rooted at i is to be merged with a tree rooted at j, oneof the nodes must remain a root and the other (and all its descendants) mustgo one level down in the tree. To minimize the distance to the root for the
most nodes, it makes sense to take as the root the node with more descendant,s.This idea, called weight balancing, is easily implemented by maintaining thesize of each tree (number of descendants of the root) in the dad array entryfor each root node, encoded as a nonpositive number so that the root nodecan be detected when traveling up the tree in find.Ideally, we would like every node to point directly to the root of its tree.No matter what strategy we use, achieving this ideal would require examiningat least all the nodes in the smaller of the two trees to be merged, and thiscould be quite a lot compared to the relatively few nodes on the path to theroot that find usually examines. But we can approach the ideal by makingall the nodes that we do examine point to the root! This seems like a drasticstep at first blush, but it is relatively easy to do, and it must be rememberedthat there is nothing sacrosanct about the structure of these trees: if theycan be modified to make the algorithm more efficient, we should do so. Thismethod, called path compression, is easily implemented by making anotherpass through each tree after the root has been found, and setting the dadentry of each vertex encountered along the way to point to the root.The combination of weight balancing and path compression ensures thatthe algorithms will run very quickly. The following implementation showsthat the extra code involved is a small price to pay to guard against degeneratecases.
CONNECTIVITY403function fastfind(x, y: integer; union: boolean): boolean;var i, j, t: integer;begini:=x; while dad[i]>O do i:=dad[i];j:=y; while dadlj]>0 do j:=dadb];while dad [x] > 0 dobegin t:=x; x:=dad[x]; dad[t]:=i end;while dad [y] > 0 dobegin t:=y; y:=dad[y]; dad[t]:=j end;if union and (i<>j) thenif dad b] <dad [i]then begin dadlj]:=dadb]+dad[i]-I; dad[i]:=j endelse begin dad[i]:=dad[i]+dadb]-1; dadlj]:=i end;fastfind:=(i<>j)end ;The dad array is assumed to be initialized to 0. (We™ll assume in later chaptersthat this is done in a separate procedure findinit.) For our sample set of edges,this program builds the following trees from the first ten edges:The trees containing DEF and JKLM are flatter than before because ofpath compression. Now FE doesn™t contribute anything, as before, then AFcombines the first two trees (with A at the root, since its tree is larger), theGC doesn™t contribute anything, then GH puts the HI tree below A, then JGputs the JKLM tree below A, resulting in the following tree:The followingconstructed:table gives the contents of the dad array as this forest is
404CHAPTER 30ABCDEFGH I JKLMAG: 100000A000000AB: 2AOOOOA000000AC: 3AAOOOAOOOOO0LM:3AA00OA00 001LJM:3AA00OA0OL02LJL:3AAOOOAOOLO2L*JK: 3AAOOOAOOLL3LED: 3AAElOAOOLL3LFD: 3AAE2EAOOLL3LHI:3AAE 2EA 1HLL 3 LFE: 3AAE2EAlHLL3L*AF: GAAEAEAlHLL 3LGE: GAAEAEAlHLL 3L *GC: GAAEAEAlHLL 3L *GH: 8AAEAEAAHLL3LJG:12AAEAEAAHLLALLG:12AAEAEAAHLLAL *For clarity in this table, each positive entry i is replaced by the ith letter of thealphabet (the name of the father), and each negative entry is complementedto give a positive integer (the weight of the tree).Several other techniques have been developed to avoid degenerate struc-tures. For example, path compression has the disadvantage that it requiresanother pass up through the tree. Another technique, called halving, is tomake each node point to its granddad on the way up the tree. Still anothertechnique, splitting, is like halving, but is applied only to every other nodeon the search path. Either of these can be used in combination with weight
balancing or with height balancing, which is similar but uses tree height in-stead of tree size to decide which way to merge trees.How is one to choose from among all these methods? And exactly howﬁflatﬂ are the trees produced? Analysis for this problem is quite difficultbecause the performance depends not only on the V and E parameters, butalso on the number of find operations and, what™s worse, on the order in whichthe union and find operations appear. Unlike sorting, where the actual filesthat appear in practice are quite often close to ﬁrandom,ﬂ it™s hard to see
how to model graphs and request patterns that might appear in practice. For
this reason, algorithms which do well in the worst case are normally preferred
for union-find (and other graph algorithms), though this may be an overlyccnservative approach.
CONNECTMTY405Even if only the worst case is being considered, the analysis of union-findalgorithms is extremely complex and intricate. This can be seen even from thenature of the results, which do give us clear indications of how the algorithmswill perform in a practical situation.If either weight balancing or heightbalancing is used in combination with either path compression, halving, orsplitting, then the total number of operations required to build up a structurewith E edges is proportional to Es(E), where a(E) is a function that is soslowly growing that o(E) < 4 unless E is so large that taking lg E, thentaking lg of the result, then taking lg of that result, and continuing 16 timesstill gives a number bigger than 1. This is a stunningly large number; for allpractical purposes, it is safe to assume that the average amount of time toexecute each union and find operation is constant. This result is due to R. E.Tarjan, who further showed that no algorithm for this problem (from a certaingeneral class) can do better that E&(E), so that this function is intrinsic tothe problem.An important practical application of union-find algorithms is that theycan be used to determine whether a graph with V vertices and E edges isconnected in space proportional to V (and almost linear time). This is anadvantage over depth-first search in some situations: here we don™t need toever store the edges. Thus connectivity for a graph with thousands of vertices
and millions of edges can be determined with one quick pass through theedges.
406Exercises1.Give the articulation points and the biconnected components of the graphformed by deleting GJ and adding IK to our sample graph.2.Write a program to print out the biconnected components of a graph.3.Give adjacency lists for one graph where breadth-first search would find acycle before depth first search would, and another graph where depth-firstsearch would find the cycle first.4.Draw the search tree that results if, in the depth-first search we ignorenodes already on the fringe (as in breadth-first search).5.Draw the search tree that results if, in the breadth-first search we changethe priority of nodes already on the fringe (as in depth-first search).6.Draw the union-find forest constructed for the example in the text, butassuming that find is changed to set a[i]=j rather than a b]=i.7. Solve the previous problem, assuming further that path compression isused.8.Draw the union-find forests constructed for the edges AB BC CD DE EF. . .YZ, assuming first that weight balancing without path compression isused, then that path compression without weight balancing is used, thenthat both are used.9.Implement the union-find variants described in the text, and empiricallydetermine their comparative performance for 1000 union operations with
both arguments random integers between 1 and 100.10. Write a program to generate a random connected graph on V verticesby generating random pairs of integers between 1 and V. Estimate howmany edges are needed to produce a connected graph as a function of V.
3 1. Weighted GraphsIt is often necessary to model practical problems using graphs in whichweights or costs are associated with each edge. In an airline map whereedges represent flight routes, these weights might represent distances or fares.In an electric circuit where edges represent wires, the length or cost of the wire
are natural weights to use. In a job-scheduling chart, weights could represent
time or cost of performing tasks or of waiting for tasks to be performed.Questions entailing minimizing costs naturally arise for such situations.In this chapter, we™ll examine algorithms for two such problems in detail: ﬁfindthe lowest-cost way to connect all of the points,ﬂ and ﬁfind the lowest-cost
path between two given points.ﬂThe first, which is obviously useful for graphsrepresenting something like an electric circuit, is called the minimzlm spanningtree problem; the second, which is obviously useful for graphs representingsomething like an airline route map, is called the shortest path problem. Theseproblems are representative of a variety of problems that arise on weightedgraphs.Our algorithms involve searching through the graph, and sometimes ourintuition is supported by thinking of the weights as distances: we speak of ﬁtheclosest vertex to 5,ﬂetc. In fact, this bias is built into the nomenclature forthe shortest path problem. Despite this, it is important to remember that theweights need not be proportional to any distance at all; they might represent
time or cost or something else entirely different. When the weights actuallydo represent distances, other algorithms may be appropriate. This issue isdiscussed in further detail at the end of the chapter.A typical weighted undirected graph is diagramed below, with edgescomprising a minimum spanning tree drawn with double lines. Note thatthe shortest paths in the graph do not necessarily use edges of the minimum
spanning tree: for example, the shortest path from vertex A to vertex G isAF™EG.407
408CHAPTER 31It is obvious how to represent weighted graphs: in the adjacency matrixrepresentation, the matrix can contain edge weights rather than boolean
values, and in the adjacency structure representation, each list element (which
represents an edge) can contain a weight.We™ll start by assuming that all of the weights are positive. Some ofthe algorithms can be adapted to handle negative weights, but they becomesignificantly more complicated. In other cases, negative weights change thenature of the problem in an essential way, and require far more sophisticatedalgorithms than those considered here. For an example of the type of difficulty
that can arise, suppose that we have a situation where the sum of the weights
of the edges around a cycle is negative:an infinitely short path could begenerated by simply spinning around the cycle.Minimum Spanning TreeA minimum spanning tree of a weighted graph is a collection of edges thatconnects all the vertices such that the sum of the weights of the edges is atleast as small as the sum of the weights of any other collection of edges that
connects all the vertices. The minimum spanning tree need not be unique: forexample, the following diagram shows three other minimum spanning treesfor our sample graph.
WEIGHTED GRAPHS409It™s easy to prove that the ﬁcollection of edgesﬂ referred to in the definitionabove must form a spanning tree: if there™s any cycle, some edge in the cycle
can be deleted to give a collection of edges which still connects the vertices
but has a smaller weight.We™ve seen in previous chapters that many graph traversal procedurescompute a spanning tree for the graph. How can we arrange things for aweighted graph so that the tree computed is the one with the lowest total
weight? The answer is simple: always visit next the vertex which can be
connected to the tree using the edge of lowest weight. The following sequence
of diagrams illustrates the sequence in which the edges are visited when this
strategy is used for our example graph.The implementation of this strategy is a trivial application of the prioritygraph search procedure in the previous chapter: we simply add a weight fieldto the edge record (and modify the input code to read in weights as well),then use tt.weight for priority in that program. Thus we always visit next thevertex in the fringe which is closest to the tree. The traversal is diagramed asabove for comparison with a completely different method that we™ll examinebelow; we can also redraw the graph in our standard search tree format:
410CHAPTER 31This method is based on the following fundamental property of minimumspanning trees: ﬁGiven any division of the vertices of a graph into two sets,the minimum spanning tree contains the shortest of the edges connecting a
vertex in one of the sets to a vertex in the other set.ﬂ For example if wedivide the vertices into the sets ABCD and EFG in our sample graph, thissays that DF must be in any minimum spanning tree. This is easy to prove by
contradiction. Call the shortest edge connecting the two sets s, and assumethat s is not in the minimum spanning tree. Then consider the graph formedby adding s to the purported minimum spanning tree. This graph has acycle; furthermore, that cycle must have some other edge besides s connectingthe two sets. Deleting this edge and adding s gives a shorter spanning tree,contradicting the assumption that s is not in the minimum spanning tree.When we use priority-first searching, the two sets of nodes in question arethe visited nodes and the unvisited ones. At each step, we pick the shortestedge from a visited node to a fringe node (there are no edges from visitednodes to unseen nodes). By the property above every edge that is picked ison the minimum spanning tree.As described in the previous chapter, the priority graph traversal algerithm has a worst-case running time proportional to (E + V)logV, thougha different implementation of the priority queue can give a V2 algorithm,which is appropriate for dense graphs. Later in this chapter, we™ll examinethis implementation of the priority graph traversal for dense graphs in fulldetail. For minimum spanning trees, this reduces to a method discovered by
R. Prim in 1956 (and independently by E. Dijkstra soon thereafter). Though
the methods are the same in essence (just the graph representation and im-
plementation of priority queues differ), we™ll refer to the sparsepfs program ofthe previous chapter with priority replaced by tf.weight as the ﬁpriority-firstsearch solutionﬂ to the minimum spanning tree problem and the adjacencymatrix version given later in this chapter (for dense graphs) as ﬁPrim™s al-
WEIGHTED GRAPHS411gorithm.ﬂ Note that Prim™s algorithm takes time proportional to V2 evenfor sparse graphs (a factor of about V2/E 1ogV slower than the priority-firstsearch solution, and that the priority-first search solution is a factor of 1ogVslower than Prim™s algorithm for dense graphs.A completely different approach to finding the minimum spanning tree isto simply add edges one at a time, at each step using the shortest edge thatdoes not form a cycle. This algorithm gradually builds up the tree one edge at
a time from disconnected components, as illustrated in the following sequence
of diagrams for our sample graph:D8F™The correctness of this algorithm also follows from the general property ofminimum spanning trees that is proved above.The code for this method can be pieced together from programs thatwe™ve already seen. A priority queue is obviously the data structure to use toconsider the edges in order of their weight, and the job of testing for cycles can
be obviously done with union-find structures. The appropriate data structure
to use for the graph is simply an array edge with one entry for each edge. The
indirect priority queue procedures pqconstruct and pqremove from Chapter 11
can be used to maintain the priority queue, using the weight fields in the edgearray for priorities. Also, the program uses the findinit and fastfind proceduresfrom Chapter 30. The program simply prints out the edges which comprisethe spanning tree; with slightly more work a dad array or other representationcould be computed:
412CHAPTER 31program kruskaI(input, output);const maxV=50; maxE=2500;type edge=record x, y, weight: integer end;var i, j, m, x, y, V, E: integer;edges: array [O..maxE] of edge;beginreadln (V, E) ;forj:=l toEdobeginreadln (c, d, edges/j] . weight) ;edgesb].x:=index(c);edgesb].y:=index(d);end ;findinit; pqconstruct; i:=O;repeatm:=pqremove; x:=edges[m].x; y:=edges[m].y;if not fastfind(x, y, true) thenbeginwriteln(name(x), name(y), edges[m].weight);i:=i+lenduntil i=V-I;end.The running time of this program is dominated by the time spent processingedges in the priority queue. Suppose that the graph consists of two clusters ofvertices all connected together by very short edges, and only one edge which
is very long connecting the two clusters. Then the longest edge in the graph is
in the minimum spanning tree, but it will be the last edge out of the priority
queue. This shows that the running time could be proportional to ElogE inthe worst case, although we might expect it to be much smaller for typicalgraphs (though it always takes time proportional to E to build the priorityqueue initially).An alternate implementation of the same strategy is to sort the edges byweight initially, then simply process them in order. Also, the cycle testingcan be done in time proportional to Elog E with a much simpler strategythan union-find, to give a minimum spanning tree algorithm that always takesE log E steps. This method was proposed by J. Kruskal in 1956, even earlierthan Prim™s algorithm. We™ll refer to the modernized version above, whichuses priority queues and union-find structures, as ﬁKruskal™s algorithm.ﬂThe performance characteristics of these three methods indicate that the
WEIGHTED GRAPHS413priority-first search method will be faster for some graphs, Prim™s for someothers, Kruskal™s for still others. As mentioned above, the worst case for the
priority-first search method is (E + V)logV while the worst case for Prim™sis V2 and the worst case for Kruskal™s is Elog E. But it is unwise to choosebetween the algorithms on the basis of these formulas because ﬁworstrcaseﬂgraphs are unlikely to occur in practice.In fact, the priority-first searchmethod and Kruskal™s method are both likely to run in time proportional toE for graphs that arise in practice: the first because most edges do not reallyrequire a priority queue adjustment that takes 1ogV steps and the secondbecause the longest edge in the minimum spanning tree is probably sufficientlyshort that not many edges are taken off the priority queue. Of course, Prim™s
method also runs in time proportional to about E for dense graphs (but itshouldn™t be used for sparse graphs).Shortest PathThe shortest path problem is to find the path in a weighted graph connectingtwo given vertices x and y with the property that the sum of the weights ofall the edges is minimized over all such paths.If the weights are all 1, then the problem is still interesting: it is to findthe path containing the minimum number of edges which connects x and y.Moreover, we™ve already considered an algorithm which solves the problem:
breadth-first search. It is easy to prove by induction that breadth-first searchstarting at x will first visit all vertices which can be reached from z with 1edge, then al: vertices which can be reached from x with 2 edges, etc., visitingall vertices which can be reached with k edges before encountering any thatrequire k + 1 edges. Thus, when y is first encountered, the shortest path fromx has been found (because no shorter paths reached y).In general, the path from z to y could touch all the vertices, so we usuallyconsider the problem of finding the shortest paths connecting a given vertexx with each of the other vertices in the graph. Again, it turns out that theproblem is simple to solve with the priority graph traversal algorithm of theprevious chapter.If we draw the shortest path from x to each other vertex in the graph,then we clearly get no cycles, and we have a spanning tree. Each vertex leadsto a different spanning tree; for example, the following three diagrams show
the shortest path spanning trees for vertices A, B, and E in the example graphthat we™ve been using.
414CHAPTER 31The priority-first search solution to this problem is very similar to thesolution for the minimum spanning tree: we build the tree for vertex z byadding, at each step, the vertex on the fringe which is closest to z (before,we added the one closest to the tree). To find which fringe vertex is closestto CC, we use the val array: for each tree vertex k, val[k] will be the distancefrom that vertex to z, using the shortest path (which must be comprised oftree nodes). When k is added to the tree, we update the fringe by goingthrough k™s adjacency list. For each node t on the list, the shortest distanceto z through k from tf.v is val[k]+tf.weight. Thus, the algorithm is triviallyimplemented by using this quantity for priority in the priority graph traversalprogram. The following sequence of diagrams shows the construction of theshortest path search tree for vertex A in our example.1b-0B'CA1kB'C2 2D0F
WEIGHTED GRAPHS415First we visit the closest vertex to A, which is B. Then both C and F aredistance 2 from A, so we visit them next (in whatever order the priority queuereturns them). Then D can be attached at F or at B to get a path of distance
3 to A. (The algorithm attaches it to B because it was put on the tree beforeF, so D was already on the fringe when F was put on the tree and F didn™tprovide a shorter path to A.) Finally, E and G are visited. As usual, the tree
is represented by the dad array of father links. The following table shows thearray computed by the priority graph traversal procedure for our example:ABCDEFGdad:ABBFAEval:0123425Thus the shortest path from A to G has a total weight of 5 (found in the valentry for G) and goes from A to F to E to G (found by tracing backwardsin the dad array, starting at G). Note that the correct operation of this
program depends on the val entry for the root being zero, the convention that
we adopted for sparsepfs.As before, the priority graph traversal algorithm has a worst-case runningtime proportional to (E + V) log V, though a different implementation of thepriority queue can give a V2 algorithm, which is appropriate for dense graphs.Below, we™ll examine this implementation of priority graph traversal for densegraphs in full detail. For the shortest path problem, this reduces to a method
discovered by E. Dijkstra in 1956.Though the methods are the same inessence, we™ll refer to the sparsepfs program of the previous chapter withpriority replaced by val [k] + tt . weight as the ﬁpriority-first search solutionﬂ tothe shortest paths problem and the adjacency matrix version given below asﬁDijkstra™s algorithm.ﬂDense GraphsAs we™ve discussed, when a graph is represented with a adjacency matrix, it isbest to use an unordered array representation for the priority queue in orderto achieve a V2 running time for any priority graph traversal algorithm. Thatis, this provides a linear algorithm for the priority first search (and thus theminimum spanning tree and shortest path problems) for dense graphs.Specifically, we maintain the priority queue in the val array just as insparsepfs but we implement the priority queue operations directly rather thanusing heaps. First, we adopt the convention that the priority values in theval array will be negated, so that the sign of a val entry tells whether thecorresponding vertex is on the tree or the priority queue. To change the
416CRAPTER 31priority of a vertex, we simply assign the new priority to the vaJ entry for thatvertex. To remove the highest priority vertex, we simply scan through thevaJ array to find the vertex with the largest negative (closest to 0) vaJ value(then complement its vaJ entry). After making these mechanical changes tothe sparsepfs program of the previous chapter, we are left with the followingcompact program.procedure densepfs;var k, min, t: integer;beginfor k:=l to Vdobegin vaJ[k]:=-unseen; dad[k]:=O end;vaJ[O]:=-(unseen+l);min:=l;repeatk:=min; vaJ[k]:=-vaJ[k]; min:=O;if vaJ[k]=unseen then vaJ[k] :=O;for t:=l to Vdoif vaJ[t]<O thenbeginif (a[k, t]<>O) and (vaJ[t]<-priority) thenbegin vaJ[t] :=-priority;dad [ t] :=k end;if vaJ[t]>vaJ[min] then min:=t;enduntil min=O;end ;Note that, the loop to update the priorities and the loop to find the minimumare combined: each time we remove a vertex from the fringe, we pass through
all the vertices, updating their priority if necessary, and keeping track of theminimum value found. (Also, note that unseen must be slightly less thanmaxint since a value one higher is used as a sentinel to find the minimum,and the negative of this value must be representable.)If we use a[k, t] for priority in this program, we get Prim™s algorithmfor finding the minimum spanning tree; if we use vaJ[k]+a[k, t] for prioritywe get Dijkstra™s algorithm for the shortest path problem. As in Chapter30, if we include the code to maintain now as the number of vertices so farsearched and use V-now for priority, we get depth-first search; if we use nowwe get breadth-first search. This program differs from the sparsepfs programof Chapter 30 only in the graph representation used (adjacency matrix instead
of adjacency list) and the priority queue implementation (unordered array
WEIGHTED GRAPHS417instead of indirect heap). These changes yield a worst-case running timeproportional to V2,as opposed to (E + V)logV for sparsepfs. That is, therunning time is linear for dense graphs (when E is proportional to V2), butsparsepfs is likely to be much faster for sparse graphs.Geometric ProblemsSuppose that we are given N points in the plane and we want to find theshortest set of lines connecting all the points. This is a geometric problem,called the Euclidean minimum spanning tree problem. It can be solved us-ing the graph algorithm given above, but it seems clear that the geometryprovides enough extra structure to allow much more efficient algorithms to bedeveloped.The way to solve the Euclidean problem using the algorithm given aboveis to build a complete graph with N vertices and N(N - 1)/2 edges, oneedge connecting each pair of vertices weighted with the distance between thecorresponding points. Then the minimum spanning tree can be found with
the algorithm above for dense graphs in time proportional to N2.It has been proven that it, is possible to do better. The point is that thegeometric structure makes most of the edges in the complete graph irrelevantto the problem, and we can eliminate most of the edges before even startingto construct the minimum spanning tree. In fact, it has been proven that
the minimum spanning tree is a subset of the graph derived by taking only
the edges from the dual of the Voronoi diagram (see Chapter 28). We knowthat this graph has a number of edges proportional to N, and both Kruskal™salgorithm and the priority-first search method work efficiently on such sparse
graphs. In principle, then, we could compute the Voronoi dual (which takes
time proportional to Nlog N), then run either Kruskal™s algorithm or thepriority-first search method to get a Euclidean minimum spanning tree algo-rithm which runs in time proportional to N log N. But writing a programto compute the Voronoi dual is quite a challenge even for an experiencedprogrammer.Another approach which can be used for random point sets is to takeadvantage of the distribution of the points to limit the number of edgesincluded in the graph, as in the grid method used in Chapter 26 for rangesearching. If we divide up the plane into squares such that each squareis likely to contain about 5 points, and then include in the graph only the
edges connecting each point to the points in the neighboring squares, then we
are very likely (though not guaranteed) to get all the edges in the minimum
spanning tree, which would mean that Kruskal™s algorithm or the priority-first
search method would efficiently finish the job.It is interesting to reflect on the relationship between graph and geometricalgorithms brought out by the problem posed in the previous paragraphs. It
CHAPTER 31is certainly true that many problems can be formulated either as geometricproblems or as graph problems. If the actual physical placement of objectsis a dominating characteristic, then the geometric algorithms of the previoussection may be appropriate, but if interconnections between objects are offundamental importance, then the graph algorithms of this section may bebetter. The Euclidean minimum spanning tree seems to fall at the interface
between these two approaches (the input involves geometry and the output
involves interconnections) and the development of simple, straightforward
methods for this and related problems remains an important though elusivegoal.Another example of the interaction between geometric and graph algo-rithms is the problem of finding the shortest path from z to y in a graphwhose vertices are points in the plane and whose edges are lines connectingthe points. For example, the maze graph at the end of Chapter 29 might be
viewed as such a graph. The solution to this problem is simple: use priority
first searching, setting the priority of each fringe vertex encountered to the
distance in the tree from z to the fringe vertex (as in the algorithm given) plusthe Euclidean distance from the fringe vertex to y. Then we stop when y isadded to the tree. This method will very quickly find the shortest path from
x to y by always going towards y, while the standard graph algorithm has toﬁsearchﬂ for y. Going from one corner to another of a large maze graph likethat one at the end of Chapter 29 might require examining a number of nodesproportional to @, while the standard algorithm has to examine virtuallyall the nodes.
WEIGHTED GRAPHS419Exercises1.Give another minimum spanning tree for the example graph at the begin-ning of the chapter.2.Give an algorithm to find the minimum spanning forest of a connectedgraph (each vertex must be touched by some edge, but the resulting graphdoesn™t have to be connected).3.Is there a graph with V vertices and E edges for which the priority-firstsolution to the minimum spanning tree problem algorithm could requiretime proportional to (E + V) log V? Give an example or explain youranswer.4.Suppose we maintained the priority queue as a sorted list in the generalgraph traversal implementations.What would be the worst-case run-ning time, to within a constant factor? When would this method beappropriate, if at all?5. Give counterexamples which show why the following ﬁgreedyﬂ strategydoesn™t work for either the shortest path or the minimum spanning treeproblems: ﬁat each step visit the unvisited vertex closest to the one justvisited.ﬂ6.Give the shortest path trees for the other nodes in the example graph.7. Find the shortest path from the upper right-hand corner to the lowerleft-hand corner in the maze graph of Chapter 29, assuming all edgeshave weight 1.8.Write a program to generate random connected graphs with V vertices,then find the minimum spanning tree and shortest path tree for somevertex. Use random weights between 1 and V. How do the weights of thetrees compare for different values of V?9. Write a program to generate random complete weighted graphs with Vvertices by simply filling in an adjacency matrix with random numbers be-tween 1 and V. Run empirical tests to determine which method finds theminimum spanning tree faster for V = 10, 25, 100: Prim™s or Kruskal™s.10.Give a counterexample to show why the following method for finding theEuclidean minimum spanning tree doesn™t work: ﬁSort the points on theirx coordinates, then find the minimum spanning trees of the first half andthe second half, then find the shortest edge that connects them.ﬂ

32. Directed GraphsDirected graphs are graphs in which edges connecting nodes are one-way; this added structure makes it more difficult to determine variousproperties. Processing such graphs is akin to traveling around in a city withmany one-way streets or to traveling around in a country where airlines rarelyrun round-trip routes: getting from one point to another in such situationscan be a challenge indeed.Often the edge direction reflects some type of precedence relationship inthe application being modeled. For example, a directed graph might be usedto model a manufacturing line, with nodes corresponding to jobs to be done
and with an edge from node x to node y if the job corresponding to node x
must be done before the job corresponding to node y. How do we decide when
to perform each of the jobs so that none of these precedence relationships areviolated?In this chapter, we™ll look at depth-first search for directed graphs, as wellas algorithms for computing the transitive closure (which summarizes con-nectivity information) and for topological sorting and for computing stronglyconnected components (which have to do with precedence relationships).As mentioned in Chapter 29, representations for directed graphs aresimple extensions of representations for undirected graphs. In the adjacencylist representation, each edge appears only once: the edge from z to y isrepresented as a list node containing y in the linked list corresponding to x.In the adjacency matrix representation, we need to maintain a full V-by-Vmatrix, with a 1 bit in row x and column y (but not necessarily in row y andcolumn Z) if there is an edge from x to y.A directed graph similar to the undirected graph that we™ve been con-sidering is drawn below. This graph consists of the edges AG AI3 CA LM JMJLJKEDDFHIFEAFGEGCHGGJLGMML.421
422CHAPTER 32The order in which the edges appear is now significant: the notation AGdescribes an edge which points from A to G, but not from G to A. But it ispossible to have two edges between two nodes, one in either direction (we haveboth HI and IH and both LM and ML in the above graph).Note that, in these representations, no difference could be perceivedbetween an undirected graph and a directed graph with two opposite directededges for each edge in the undirected graph. Thus, some of algorithms in this
chapter can be considered generalizations of algorithms in previous chapters.Depth-First SearchThe depth-first search algorithm of Chapter 29 works properly for directedgraphs exactly as given. In fact, its operation is a little more straightforwardthan for undirected graphs because we don™t have to be concerned with doubleedges between nodes unless they™re explicitly included in the graph. However,the search trees have a somewhat more complicated structure. For example,the following depth-first search structure describes the operation of the recur-sive algorithm of Chapter 29 on our sample graph.As before, this is a redrawn version of the graph, with solid edges correspond-
DIRECTED GRAPHSing to those edges that were actually used to visit vertices via recursive callsand dotted edges corresponding to those edges pointing to vertices that had
already been visited at the time the edge was considered. The nodes are
visited in the order A F E D B G J K L M C H I.Note that the directions on the edges make this depth-first search forestquite different from the depth-first search forests that we saw for undirectedgraphs. For example, even though the original graph was connected, thedepth-first search structure defined by the solid edges is not connected: it isa forest, not a tree.For undirected graphs, we had only one kind of dotted edge, one thatconnected a vertex with some ancestor in the tree. For directed graphs, thereare three kinds of dotted edges: up edges, which point from a vertex to someancestor in the tree, down edges, which point from a vertex to some descendant
in the tree, and cross edges, which point from a vertex to some vertex which
is neither a descendant nor an ancestor in the tree.As with undirected graphs, we™re interested in connectivity properties ofdirected graphs. We would like to be able to answer questions like ﬁIs therea directed path from vertex x to vertex y (a path which only follows edges inthe indicated direction)?ﬂand ﬁWhich vertices can we get to from vertex xwith a directed path?ﬂand ﬁIs there a directed path from vertex x to vertexy and a directed path from y to x.7ﬂ Just as with undirected graphs, we™ll beable to answer such questions by appropriately modifying the basic depth-firstsearch algorithm, though the various different types of dotted edges make the
modifications somewhat more complicated.Transitive ClosureIn undirected graphs, simple connectivity gives the vertices that can be reachedfrom a given vertex by traversing edges from the graph: they are all those in
the same connected component. Similarly, for directed graphs, we™re ofteninterested in the set of vertices which can be reached from a given vertex bytraversing edges from the graph in the indicated direction.It is easy to prove that the recursive visit procedure from the depth-firstsearch method in Chapter 29 visits all the nodes that can be reached from thestart node. Thus, if we modify that procedure to print out the nodes that it isvisiting (say, by inserting write(name(k)) just upon entering), we are printingout all the nodes that can be reached from the start node. But note carefullythat it is not necessarily true that each tree in the depth-first search forestcontains all the nodes that can be reached from the root of that tree (in ourexample, all the nodes in the graph can be reached from H, not just I). Toget all the nodes that can be visited from each node, we simply call visit Vtimes, once for each node:
424CHAPTER 32for k:=l to Vdobeginnow:=&for j:=1 to V do vaIli] :=O;visit(k);wri telnend ;This program produces the following output for our sample graph:AFEDBG JKLMCBCAFEDBGJKLMDFEEDFFEDGJKLMCAFEDBHGJKLMCAFEDBIIHGJKLMCAFEDBJKLGCAFEDBMKLGJKMCAFEDBMLGJKCAFEDBFor undirected graphs, this computation would produce a table with theproperty that each line corresponding to the nodes in a connected component
lists all the nodes in that component. The table above has a similar property:certain of the lines list identical sets of nodes. Below we shall examine thegeneralization of connectedness that explains this property.As usual, we could add code to do extra processing rather than justwriting out the table. One operation we might want to perform is to add anedge directly from 3: to y if there is some way to get from z to y. The graphwhich results from adding all edges of this form to a directed graph is calledthe transitive closure of the graph. Normally, a large number of edges will beadded and the transitive closure is likely to be dense, so an adjacency matrix
representation is called for. This is an analogue to connected components in
an undirected graph; once we™ve performed this computation once, then we
can quickly answer questions like ‚5s there a way to get from x to y?ﬂUsing depth-first search to compute the transitive closure requires V3steps in the worst case, since we may have to examine every bit of the
DIRECTED GRAPHS425adjacency matrix for the depth-first search from each vertex. There is aremarkably simple nonrecursive program for computing the transitive closureof a graph represented with an adjacency matrix:for y:=l to V dofor x:=1 to V doif a[x, y] thenfor j:=l to Vdoif a[y, j] then a[x, j]:=true;S. Warshall invented this method in 1962, using the simple observation thatﬁif there™s a way to get from node x to node y and a way to get from node y tonode j then there™s a way to get from node x to node j.ﬂ The trick is to makethis observation a little stronger, so that the computation can be done in only
one pass through the matrix, to wit:ﬁif there™s a way to get from node x tonode y using only nodes with indices less than x and a way to get from nodey to node j then there™s a way to get from. node x to node j using only nodeswith indices less than x+1.ﬂThe above program is a direct implementationof this.Warshall™s method converts the adjacency matrix for our sample graph,given at left in the table below, into the adjacency matrix for its transitiveclosure, given at the right:ABCDEFGHIJKLMA1100011000000BOlOOOOOOOOOOOc1010000000000DOOOlOlOOOOOOOEOOOllOOOOOOOOFOOOOllOOOOOOOGOOlOlOlOOlOOOHOOOOOOlllOOOO10000000110000JOOOOOOOOOllllKOOOOOOOOOOlOOL0000001000011MOOOOOOOOOOOllABCDEFGHI JKLMA1111111001111BOlOOOOOOOOOOOc1111111001111DOOOlllOOOOOOOEOOOlllOOOOOOOFOOOlllOOOOOOOGlllllllOOllllHlllllllllllll11111111111111JlllllllOOllllKOOOOOOOOOOlOOL1111111001111MlllllllOOllll
426CHAPTER 32For very large graphs, this computation can be organized so that theoperations on bits can be done a computer word at a time, which will lead tosignificant savings in many environments. (As we™ve seen, it is not intendedthat such optimizations be tried with Pascal.)Topological SortingFor many applications involving directed graphs, cyclic graphs do arise. If,however, the graph above modeled a manufacturing line, then it would imply,say, that job A must be done before job G, which must be done before job
C, which must be done before job A. But such a situation is inconsistent:
for this and many other applications, directed graphs with no directed cycles(cycles with all edges pointing the same way) are called for. Such graphs arecalled directed acyclic graphs, or just dags for short. Dags may have manycycles if the directions on the edges are not taken into account; their definingproperty is simply that one should never get in a cycle by following edges inthe indicated direction. A dag similar to the directed graph above, with afew edges removed or directions switched in order to remove cycles, is givenbelow.The edge list for this graph is the same as for the connected graph of Chapter30, but here, again, the order in which the vertices are given when the edgeis specified makes a difference.Dags really are quite different objects from general directed graphs: ina sense, they are part tree, part graph. We can certainly take advantage oftheir special structure when processing them. Viewed from any vertex, a dag
looks like a tree; put another way, the depth-first search forest for a dag has
no up edges. For example, the following depth-first search forest describes
the operation of dfs on the example dag above.
DIRECTED GRAPHS427A fundamental operation on dags is to process the vertices of the graphin such an order that no vertex is processed before any vertex that pointsto it. For example, the nodes in the above graph could be processed in the
following order:JKLMAGHIFEDBCIf edges were to be drawn with the vertices in these positions, all the edgeswould go from left to right. As mentioned above, this has obvious application,
for example, to graphs which represent manufacturing processes, for it gives aspecific way to proceed within the constraints represented by the graph. Thisoperation is called topological sorting, because it involves ordering the verticesof the graph.In general, the vertex order produced by a topological sort is not unique.For example, the orderAJGFKLEMBHCIDis a legal topological ordering for our example (and there are many others).In the manufacturing application mentioned, this situation occurs when onejob has no direct or indirect dependence on another and thus they can beperformed in either order.It is occasionally useful to interpret the edges in a graph the other wayaround: to say that an edge directed from x to y means that vertex xﬁdependsﬂ on vertex y. For example, the vertices might represent terms to bedefined in a programming language manual (or a book on algorithms!) withan edge from x to y if the definition of x uses y. In this case, it would be
useful to find an ordering with the property that every term is defined before
it is used in another definition. This corresponds to positioning the vertices
in a line so that edges would all go from right to left. A reverse topologicalorder for our sample graph is:DEFCBIHGAKMLJ
CHAPTER 32The distinction here is not crucial: performing a reverse topological sort on agraph is equivalent to performing a topological sort on the graph obtained byreversing all the edges.But we™ve already seen an algorithm for reverse topological sorting, thestandard recursive depth-first search procedure of Chapter 29! Simply chang-ing visit to print out the vertex visited just before exiting, for example byinserting write(name[k] ) right at the end, causes dfs to print out the verticesin reverse topological order, when the input graph is a dag. A simple inductionargument proves that this works: we print out the name of each vertex afterwe™ve printed out the names of all the vertices that it points to. When visitis changed in this way and run on our example, it prints out the vertices inthe reverse topological order given above.Printing out the vertex name onexit from this recursive procedure is exactly equivalent to putting the vertexname on a stack on entry, then popping it and printing it on exit. It would
be ridiculous to use an explicit stack in this case, since the mechanism for
recursion provides it automatically; we mention this because we do need a
stack for the more difficult problem to be considered next.Strongly Connected ComponentsIf a graph contains a directed cycle, (if we can get from a node back to itselfby following edges in the indicated direction), then it it is not a dag and itcan™t be topologically sorted: whichever vertex on the cycle is printed out firstwill have another vertex which points to it which hasn™t yet been printed out.The nodes on the cycle are mutually accessible in the sense that there is away to get from every node on the cycle to another node on the cycle andback. On the other hand, even though a graph may be connected, it is notlikely to be true that any node can be reached from any other via a directed
path. In fact, the nodes divide themselves into sets called strongly connectedcomponents with the property that all nodes within a componenl are mutuallyaccessible, but there is no way to get from a node in one component to a nodein another component and back. The strongly connected components of thedirected graph at the beginning of this chapter are two single nodes B and K,one pair of nodes H I, one triple of nodes D E F, and one large component withsix nodes A C G J L M. For example, vertex A is in a different componentfrom vertex F because though there is a path from A to F, there is no way toget from F to A.The strongly connected components of a directed graph can be foundusing a variant of depth-first search, as the reader may have learned to expect.The method that we™ll examine was discovered by R. E. Tarjan in 1972. Sinceit is based on depth-first search, it runs in time proportional to V + E, but it isactually quite an ingenious method. It requires only a few simple modificationsto our basic visit procedure, but before Tarjan presented the method, no linear
DLRECTED GRAPHS429time algorithm was known for this problem, even though many people hadworked on it.The modified version of depth first search that we use to find the stronglyconnected components of a graph is quite similar to the program that westudied in Chapter 30 for finding biconnected components. The recursive
visit function given below uses the same min computation to find the highestvertex reachable (via an up link) from any descendant of vertex k, but usesthe value of min in a slightly different way to write out the strongly connectedcomponents:function visit(k: integer): integer;var t: link;m, min : integer;beginnow:=now+l; val[k] :=now; min:=now;stack[p] :=k; p:=p+I;t:=adj[k] ;while t<>z dobeginif vaJ[tr.v]=Othen m:=visit(tf.v)else m:=vaJ[tf.v];if m<min then min:=m;t:=tt.nextend ;if min=vaJ[k] thenbeginrepeatp:=p-1; write(name(stack[p]));vaJ[stack[p]]:=V+Iuntil stack[p]=k;wri telnend ;visit:=min;end ;This program pushes the vertex names onto a stack on entry to visit, thenIpops them and prints them on exit from visiting the last member of eachstrongly connected component.The point of the computation is the testwhether min=vaJ[k] at the end: if so, all vertices encountered since entry(except those already printed out) belong to the same strongly connected
430CHAPTER 32component as k. As usual, this program could easily be modified to do moresophisticated processing than simply writing out the components.The method is based on two observations that we™ve actually alreadymade in other contexts. First, once we reach the end of a call to visit fora vertex, then we won™t encounter any more vertices in the same stronglyconnected component (because all the vertices which can be reached from thatvertex have been processed, as we noted above for topological sorting). Second,
the ﬁupﬂ links in the tree provide a second path from one vertex to another and
bind together the strong components. As with the algorithm in Chapter 30 for
finding articulation points, we keep track of the highest ancestor reachable
via one ﬁupﬂ link from all descendants of each node. Now, if a vertex xhas no descendants or ﬁupﬂ links in the depth-first search tree, or if it has adescendant in the depth-first search tree with an ﬁupﬂ link that points to x,and no descendants with ﬁupﬂ links that point higher up in the tree, then itand all its descendants (except those vertices satisfying the same property andtheir descendants) comprise a strongly connected component. In the depth-first search tree at the beginning of the chapter, nodes B and K satisfy thefirst condition (so they represent strongly connected components themselves)
and nodes F(representing F E D), H (representing H I), and A (representingA G J L M C) satisfy the second condition. The members of the componentrepresented by A are found by deleting B K F and their descendants (they
appear in previously discovered components). Every descendant y of x thatdoes not satisfy this same property has some descendant that has an ﬁupﬂlink that points higher than y in the tree. There is a path from x to y downthrough the tree; and a path from y to x can be found by going down fromy to the vertex with the ﬁupﬂ link that reaches past y, then continuing thesame process until x is reached. A crucial extra twist is that once we™re donewith a vertex, we give it a high val, so that ﬁcrossﬂ links to that vertex willbe ignored.This program provides a deceptively simple solution to a relatively difficultproblem. It is certainly testimony to the subtleties involved in searchingdirected graphs, subtleties which can be handled (in this case) by a carefully
crafted recursive program.- -r-l
DIRECTED GRAPHS431Exercises1.Give the adjacency matrix for the transitive closure of the example daggiven in this chapter.2.What would be the result of running the transitive closure algorithms onan undirected graph which is represented with an adjacency matrix?3.Write a program to determine the number of edges in the transitive closureof a given directed graph, using the adjacency list representation.4. Discuss how Warshall™s algorithm compares with the transitive closurealgorithm derived from using the depth-first search technique describedin the text, but using the adjacency matrix form of visit and removing
the recursion.5. Give the topological ordering produced for the example dag given inthe text when the suggested method is used with an adjacency matrixrepresentation, but dfs scans the vertices in reverse order (from V downto 1) when looking for unvisited vertices.6. Does the shortest path algorithm from Chapter 31 work for directedgraphs? Explain why or give an example for which it fails.7.Write a program to determine whether or not a given directed graph is adag.8.How many strongly connected components are there in a dag? In a graphwith a directed cycle of size V?9. Use your programs from Chapters 29 and 30 to produce large randomdirected graphs with V vertices.How many strongly connected com-ponents do such graphs tend to have?10. Write a program that is functionally analogous to find from Chapter30, but maintains strongly connected components of the directed graphdescribed by the input edges. (This is not an easy problem: you certainlywon™t be able to get as efficient a program as find.)

33. Network FlowqWeighted directed graphs are useful models for several types of applica-tions involving commodities flowing through an interconnected network.Consider, for example, a network of oil pipes of varying sizes, interconnectedin complex ways, with switches controlling the direction of flow at junctions.
Suppose further that the network has a single source (say, an oil field) and asingle destination (say, a large refinery) to which all of the pipes ultimatelyconnect. What switch settings will maximize the amount of oil flowing fromsource to destination? Complex interactions involving material flow at junc-
tions make this problem, called the networkflow problem, a nontrivial problemto solve.This same general setup can be used to describe traffic flowing alonghighways, materials flowing through factories, etc. Many different versionsof the problem have been studied, corresponding to many different practical
situations where it has been applied. There is clearly strong motivation to
find an efficient algorithm for these problems.This type of problem lies at the interface between computer scienceand the field of operations research. Operations researchers are generallyconcerned with mathematical modeling of complex systems for the purposeof (preferably optimal) decision-making. Network flow is a typical example
of an operations research problem; we™ll briefly touch upon some others in
Chapters 37-40.As we™ll see, the modeling can lead to complex mathematical equationsthat require computers for solution. For example, the classical solution to thenetwork flow problem given below is closely related to the graph algorithms
that we have been examining. But this problem is one which is still actively
being studied: unlike many of the problems that we™ve looked at, the ﬁbestﬂsolution has not yet been found and good new algorithms are still beingdiscovered.433
434CRAPTER 33The Network Flow ProblemConsider the following rather idealized drawing of a small network of oil pipes:The pipes are of fixed capacity proportional to their size and oil can Ilowin them only in the direction indicated (perhaps they run downhill or haveunidirectional pumps ). Furthermore, switches at each junction control howmuch of the oil goes in each direction. No matter how the switches are set,the system reaches a state of equilibrium when the amount of oil flowing into
the system at the left is equal to the amount flowing out of the system at the
right (this is the quantity that we want to maximize) and when the amount
of oil flowing in at each junction is equal to the amount of oil flowing out. We
measure both flow and pipe capacity in terms of integral ﬁunitsﬂ (say, gallons
per second).It is not immediately obvious that the switch settings can really affect thetotal flow: the following example will illustrate that they can. First, supposethat all switches are open so that the two diagonal pipes and the top andbottom pipes are full. This gives the following configuration:The total flow into and out of the network in this case is less than half thecapacity of the input pipe, only slightly more than half the capacity of theoutput pipe. Now suppose that the upward diagonal pipe is shut off. Thisshuts flow equal to its capacity out of the bottom, and the top is unaffectedbecause there™s room to replace its flow from the input pipe; thus we have:
NETWORK FLOW435The total flow into and out of the network is increased to substantially.This situation can obviously be modeled using a directed graph, and itturns out that the programs that we have studied can apply. Define a networkas a weighted directed graph with two distinguished vertices: one with noedges pointing in (the source); one with no edges pointing out (the sink). Theweights on the edges, which we assume to be non-negative, are called the edgecapacities. Now, a flow is defined as another set of weights on the edges suchthat the how on each edge is equal to or less than the capacity, and the flowinto each vertex is equal to the flow out of that vertex. The value of the flowis the flow into the source (or out of the sink). The network flow problem isto find a flow with maximum value for a given network.Networks can obviously be represented using either the adjacency matrixor adjacency list representations that we have used for graphs in previouschapters. Instead of a single weight, two weights are associated with each
edge, the size and the Aow. These could be represented as two fields in an
adjacency list node, as two matrices in the adjacency matrix representation,
or as two fields within a single record in either representation. Even though
networks are directed graphs, the algorithms that we™ll be examining need
to traverse edges in the ﬁwrongﬂ direction, so we use an undirected graph
representation: if there is an edge from x to y with size s and flow f, we alsokeep an edge from y to x with size -s and flow -f. In an adjacency listrepresentation, it is necessary to maintain links connecting the two list nodeswhich represent each edge, so that when we change the flow in one we can
update it in the other.Ford-Fulkerson MethodThe classical approach to the network flow problem was developed by L. R.Ford and D. R. Fulkerson in 1962. They gave a method to improve any legalflow (except, of course, the maximum). Starting with a zero flow, we applythe method repeatedly; as long as the method can be applied, it produces anincreased flow; if it can™t be applied, the maximum flow has been found.Consider any directed path through the network (from source to sink).Clearly, the flow can be increased by at least the smallest amount of unusedcapacity on any edge on the path, by increasing the flow in all edges on the
436CRAPTER 33path by that amount. In our example, this rule could be applied along thepath ADEBCF:then along the path ABCDEF:CU4*2/3FE2/54/5and then along the path ABCF:Now all directed paths through the network have at least one edge whichis filled to capacity. But there is another way to increase the flow: we can
consider arbitrary paths through the network which can contain edges which
point the ﬁwrong wayﬂ (from sink to source along the path). The flow can
NETWORK FLOW437be increased along such a path by increasing the flow on edges from sourceto sink and decreasing the flow on edges from sink to source by the same
amount. To simplify terminology, we™ll call edges which flow from source to
sink along a particular path forward edges and edges which flow from sink tosource backward edges. For example, the flow in the network above can beincreased by 2 along the path ABEF.This corresponds to shutting off the oil on the pipe from E to B; this allows 2units to be redirected from E to F without losing any flow at the other end,because the 2 units which used to come from E to B can be replaced by 2units from A.Notice that the amount by which the flow can be increased is limited bythe minimum of the unused capacities in the forward edges and the minimumof the flows in the backward edges.Put another way, in the new flow, atleast one of the forward edges along the path becomes full or at least one ofthe backward edges along the path becomes empty. Furthermore, the flow
can™t be increased on any path containing a full forward edge or an empty
backward edge.The paragraph above gives a method for increasing the flow on anynetwork, provided that a path with no full forward edges or empty backwardedges can be found. The crux of the Ford-Fulkerson method is the observationthat if no such path can be found then the flow is maximal. The proof ofthis fact goes as follows: if every path from the source to the sink has a fullforward edge or an empty backward edge, then go through the graph andidentify the first such edge on every path. This set of edges cuts the graph intwo parts, as shown in the diagram below for our example.
438CHAF™TER 33For any cut of the network into two parts, we can measure the flow ﬁacrossﬂthe cut: the total of the flow on the edges which go from the source to the sinkminus the total of the flow on the edges which go the other way. Our examplecut has a value of 8, which is equal to the total flow for the network. It turns
out that whenever the cut flow equals the total flow, we know not only that
the flow is maximal, but also that the cut is minimal (that is, every othercut has at least as high a flow ﬁacrossﬂ). This is called the maxfiow-mincuttheorem: the flow couldn™t be any larger (otherwise the cut would have to belarger also); and no smaller cuts exist (otherwise the flow would have to besmaller also).Network SearchingThe Ford-Fulkerson method described above may be summarized as follows:ﬁstart with zero flow everywhere and increase the flow along any path fromsource to sink with no full forward edges or empty backward edges, continuinguntil there are no such paths in the network.ﬂ But this is not an algorithm inthe sense to which we have become accustomed, since the method for findingpaths is not specified. The example above is based on the intuition that the
longer the path, the more the network is filled up, and thus that long pathsshould be preferred. But the following classical example shows that some careshould be exercised:0/1000B0/1000@AO/l co/loo0D0/1000Now, if the first path chosen is ABDC, then the flow is increased by only one.Then the second path chosen might be ADBC, again increasing the flow by
NETWORK FLOW439one, and leaving an situation identical to the initial situation, except that theflows on the outside edges are increased only by 1. Any algorithm which chose
those two paths (for example, one that looks for long paths) would continue
to do so, thus requiring 1000 pairs of iterations before the maximum flow isfound. If the numbers on the sides were a billion, then a billion iterationswould be used. Obviously, this is an undesirable situation, since the pathsABC and ADC would give the maximum flow in just two steps. For thealgorithm to be useful, we must avoid having the running time so dependenton the magnitude of the capacities.Fortunately, the problem is easily eliminated. It was proven by Edmondsand Karp that if breadth-first search were used to find the path, then thenumber of paths used before the maximum flow is found in a network of Vvertices and E edges must be less than VE. (This is a worstccase bound: atypical network is likely to require many fewer steps.) In other words, simplyuse the shortest available path from source to sink in the Ford-Fulkerson
method.With the priority graph traversal method of Chapters 30 and 31, wecan implement another method suggested by Edmonds and Karp: find thepath through the network which increases the flow by the largest amount.
This can be achieved simply by using a variable for priority (whose valueis set appropriately) in either the adjacency list sparsepfs of Chapter 30 orthe adjacency matrix densepfs of Chapter 31. For example, the followingstatements compute the priority assuming a matrix representation:if size[k, t]>O then priority:=size[k, t]-Aow[k, t]else priority:=-flow[k, t] ;if priority>val[k] then priority:=val[k] ;Then, since we want to take the node with the highest priority value, we musteither reorient the priority queue mechanisms in those programs to returnthe maximum instead of the minimum or use them as is with priority setto maxim?-l-priority (and the process reversed when the value is removed).Also, we modify the priority first search procedure to take the source and sinkas arguments, then to start at the source and stop when a path to the sink
has been found. If such a path is not found, the partial priority search treedefines a mincut for the network. Finally, the val for the source should be setto maxi& before the search is started, to indicate that any amount of flowcan be achieved at the source (though this is immediately restricted by thetotal capacity of all the pipes leading directly out of the source).With densepfs implemented as described in the previous paragraph, find-ing the maximum flow is actually quite simple, as shown by the following
440CHAPTER 33program:repeatdensepfs(l, V);y:=V, x:=dad[q;while xc>0 dobeginAow[x,y]:=Aow[x,y]+val[Vl;Aow[y, x] :=-Aow[x, y] ;y:=x; x:=dad[y]enduntil val [v] = unseenThis program assumes that the adjacency matrix representation is being usedfor the network. As long as densepfs can find a path which increases the
flow (by the maximum amount), we trace back through the path (using thedad array constructed by densepfs) and increase the how as indicated. If Vremains unseen after some call to densepfs, then a mincut has been found andthe algorithm terminates.For our example network, the algorithm first increases the flow along thepath ABCF, then along ADEF, then along ABCDEF. No backwards edgesare used in this example, since the algorithm does not make the unwise choiceADEBCF that we used to illustrate the need for backwards edges. In the nextchapter we™ll see a graph for which this algorithm uses backwards edges tofind the maximum how.Though this algorithm is easily implemented and is likely to work wellfor networks that arise in practice, the analysis of this method is quite com-plicated. First, as usual, densepfs requires V2 steps in the worst case, or wecould use sparsepfs to run in time proportional to (E + V) log V per iteration,though the algorithm is likely to run somewhat faster than this, since it stopswhen it reaches the sink. But how many iterations are required? Edmonds
and Karp show the worst case to be 1 + logMIMP1 f * where f * is the costof the flow and M is the maximum number of edges in a cut of the network.This is certainly complicated to compute, but it is not likely to be large forreal networks. This formula is included to give an indication not of how long
the algorithm might take on an actual network, but rather of the complexity
of the analysis. Actually, this problem has been quite widely studied, andcomplicated algorithms with much better worst-case time bounds have beendeveloped.The network flow problem can be extended in several ways, and manyvariations have been studied in some detail because they are important in
NETWORK FLOW441actual applications. For example, the multicommodity flow problem involvesintroducing multiple sources, sinks, and types of material in the network. Thismakes the problem much more difficult and requires more advanced algorithmsthan those considered here: for example, no analogue to the max-flow min-cut theorem is known to hold for the general case. Other extensions to thenetwork flow problem include placing capacity constraints on vertices (easily
handled by introducing artificial edges to handle these capacities), allowing
undirected edges (also easily handled by replacing undirected edges by pairs
of directed edges), and introducing lower bounds on edge flows (not so easily
handled). If we make the realistic assumption that pipes have associated costs
as well as capacities, then we have the min-cost flow problem, a quite difficult
nroblem from onerations research.1Irl
442Exercises1.Give an algorithm to solve the network flow problem for the case that thenetwork forms a tree if the sink is removed.2.What paths are traced by the algorithm given in the text when findingthe maximum flow in the following network?3.Draw the priority search trees computed on each call to densepfs for theexample discussed in the text.4.True or false: No algorithm can find the maximum flow without examiningevery edge in the network.5.What happens to the Ford-Fulkerson method in the case that the networkhas a directed cycle?6.Give an example where a shortest-path traversal would produce a differentset of paths than the method given in the text.7. Give a counterexample which shows why depth-first search is not ap-propriate for the network flow problem.8.Find an assignment of sizes that would make the algorithm given in thetext use a backward edge on the example graph, or prove that none exists.9.Implement the breadth-first search solution to the network flow problem,using sparsepfs.10. Write a program to find maximum flows in random networks with Vnodes and about 1OV edges. How many calls to sparsepfs are made, forV = 25, 50, lOO?
34. MatchingA problem which often arises is to ﬁpair upﬂ objects according to prefer-ence relationships which are likely to conflict. For example, a quitecomplicated system has been set up in the U. S. to place graduating medicalstudents into hospital residence positions. Each student lists several hospitalsin order of preference, and each hospital lists several students in order ofpreference. The problem is to assign students to positions in a fair way,respecting all the stated preferences.A sophisticated algorithm is requiredbecause the best students are likely to be preferred by several hospitals, andthe best hospital positions are likely to be preferred by several students. It™s
not even clear that each hospital position can be filled by a student that thehospital has listed and each student can be assigned to a position that thestudent has listed, let alone respect the order in the preference lists. Actuallythis frequently occurs: after the algorithm has done the best that it can,there is a last minute scramble among unmatched hospitals and students tocomplete the process.This example is a special case of a difficult fundamental problem ongraphs that has been widely studied. Given a graph, a matching is a subsetof the edges in which no vertex appears more than once. That is, each vertextouched by one of the edges in the matching is paired with the other vertex
of that edge, but some vertices may be left unmatched. Even if we insist
that there should be no edges connecting unmatched vertices, different waysof choosing the edges could lead to different numbers of leftover (unmatched)vertices.Of particular interest is a mazimum matching, which contains as manyedges as possible or, equivalently, which minimizes the number of unmatchedvertices. The best that we could hope to do would be to have a set of edges
in which each vertex appears exactly once (such a matching in a graph with2V vertices would have V edges), but it is not always possible to achieve this.443
444CHAPTER 34For example, consider our sample undirected graph:The edges AF DE CG Hl JK LM make a maximum matching for this graph,which is the best that can be done, but there™s no three-edge matching forthe subgraph consisting of just the first six vertices and the edges connectingthem.For the medical student matching problem described above, the studentsand hospitals would correspond to nodes in the graph; their preferences toedges. If they assign values to their preferences (perhaps using the time-honored ﬁl-10ﬂ scale), then we have the weighted matching problem: givena weighted graph, find a set of edges in which no vertex appears more thanonce such that the sum of the weights on the edges in the set chosen is
maximized. Below we™ll see another alternative, where we respect the order in
the preferences, but do not require (arbitrary) values to be assigned to them.The matching problem has attracted attention because of its intuitivenature and its wide applicability. Its solution in the general case involvesintricate and beautiful combinatorial mathematics beyond the scope of this
book. Our intent here is to provide the reader with an appreciation for the
problem by considering some interesting special cases while at the same time
developing some useful algorithms.Bipartite GraphsThe example mentioned above, matching medical students to residencies, iscertainly representative of many other matching applications. For example,we might be matching men and women for a dating service, job applicants toavailable positions, courses to available hours, or congressmen to committeeassignments. The graphs resulting from modeling such cases are called bipar-tite graphs, which are defined to be graphs in which all edges go between twosets of nodes (that is, the nodes divide into two sets and no edges connecttwo nodes in the same set). Obviously, we wouldn™t want to ﬁmatchﬂ one jobapplicant to another or one committee assignment to another.
The reader might be amused to search for a maximum matching in thetypical Lipartite graph drawn below:In an adjacency matrix representation for bipartite graphs, one can achieveobvious savings by including only rows for one set and only columns for the
other set. In an adjacency list representation, no particular saving suggests
itself, except naming the vertices intelligently so that it is easy to tell which
set a vertex belongs to.In our examples, we use letters for nodes in one set, numbers for nodesin t.he other. The maximum matching problem for bipartite graphs can besimply expressed in this representation:ﬁFind the largest subset of a set ofletter-number pairs with the property that no two pairs have the same letteror number.ﬂFinding the maximum matching for our example bipartite graphcorresponds to solving this puzzle on the pairs E5 A2 Al Cl B4 C3 D3 B2 A4D5 E3 Bl.It is an interesting exercise to attempt to find a direct solution to thematching problem for bipartite graphs. The problem seems easy at firstglance, but subtleties quickly become apparent. Certainly there are far too
many pairings to try all possibilities: a solution to the problem must be clever
enough to try only a few of the possible ways to match the vertices.The solution that we™ll examine is an indirect one: to solve a particularinstance of the matching problem, we™ll construct an instance of the networkflow problem, use the algorithm from the previous chapter, then use thesolution to the network flow problem to solve the matching problem. That is,we reduce the matching problem to the network flow problem. Reduction is arnethod of algorithm design somewhat akin to the use of a library subroutine
by a systems programmer. It is of fundamental importance in the theoryof advanced combinatorial algorithms (see Chapter 40). For the moment,reduction will provide us with an efficient solution to the bipartite matchingproblem.The construction is straightforward: given an instance of bipartite match-
CHAPTER 34ing, construct an instance of network flow by creating a source vertex withedges pointing to all the members of one set in the bipartite graph, then makeall the edges in the bipartite graph point from that set to the other, then adda sink vertex pointed to by all the members of the other set. All of the edges
in the resulting graph are given a capacity of 1. For example, the bipartite
graph given above corresponds to the network below: the darkened edges showthe first four paths found when the network flow algorithm of the previouschapter is run on this graph.Note that the bipartite property of the graph, the direction of the flow, andthe fact that all capacities are 1 force each path through the network tocorrespond to an edge in a matching: in the example, the paths found so farcorrespond to the partial matching Al B2 C3 D5. Each time the network flow
algorithm calls pfs it either finds a path which increases the flow by one orterminates.Now all forward paths through the network are full, and the algorithmmust use backward edges. The path found in this example is the path04AlC3EZ. This path clearly increases the flow in the network, as described inthe previous chapter. In the present context, we can think of the path as a setof instructions to create a new partial matching (with one more edge) from the
current one. This construction follows in a natural way from tracing through
the path in order: ﬁ4Aﬂ means to add A4 to the matching, which requires
MATCHINGthat ﬁAlﬂ be deleted; ﬁ1Cﬂ means to add Cl to the matching, which requiresthat ﬁC3ﬂ be deleted; ﬁ3Eﬂ means to add E3 to the matching. Thus, afterthis path is processed, we have the matching A4 B2 Cl D5 E3; equivalently,the flow in the network is given by full pipes in the edges connecting those
nodes, and all pipes leaving 0 and entering Z full.The proof that the matching is exactly those edges which are filled tocapacity by the maxflow algorithm is straightforward. First, the network flowalways gives a legal matching: since each vertex has an edge of capacity 1either coming in (from the sink) or going out (to the source), at most one unitof flow can go through each vertex, which implies that each vertex will beincluded at most once in the matching. Second, no matching can have more
edges, since any such matching would lead directly to a better flow than thatproduced by the maxflow algorithm.Thus, to compute the maximum matching for a bipartite graph we simplyformat the graph so as to be suitable for input to the network flow algorithmof the previous chapter. Of course, the graphs presented to the network flow
algorithm in this case are much simpler than the general graphs the algorithm
is designed to handle, and it turns out that the algorithm is somewhat more
efficient for this case. The construction ensures that each call to pfs addsone edge to the matching, so we know that there are at most V/2 calls topfs during the execution of the algorithm. Thus, for example, the total timeto find the maximum matching for a dense bipartite graph with V vertices(using the adjacency matrix representation) is proportional to V3.Stable Marriage ProblemThe example given at the beginning of this chapter, involving medical studentsand hospitals, is obviously taken quite seriously by the participants. Butthe method that we™ll examine for doing the matching is perhaps betterunderstood in terms of a somewhat whimsical model of the situation. We
assume that we have N men and N women who have expressed mutual
preferences (each man must say exactly how he feels about each of the N
women and vice versa). The problem is to find a set of N marriages that
respects everyone™s preferences.How should the preferences be expressed? One method would be to usethe ﬁ1-10ﬂ scale, each side assigning an absolute score to certain members ofthe other side. This makes the marriage problem the same as the weightedmatching problem, a relatively difficult problem to solve. Furthermore, use ofabsolute scales in itself can lead to inaccuracies, since peoples™ scales will beinconsistent (one woman™s 10 might be another woman™s 7). A more naturalway to express the preferences is to have each person list in order of preferenceall the people of the opposite sex.The following two tables might show
448CHAPTER 34preferences among a set of five women and five men. As usual (and to protectthe innocent!) we assume that hashing or some other method has been used totranslate actual names to single digits for women and single letters for men:A:251341:EADBCB:123452:DEBACc:235413:ADBCED:132454:CBDAEE:532145:DBCEAClearly, these preferences often conflict: for example, both A and C list 2 astheir first choice, and nobody seems to want 4 very much (but someone mustget her). The problem is to engage all the women to all the men in such away as to respect all their preferences as much as possible, then perform Nmarriages in a grand ceremony. In developing a solution, we must assume thatanyone assigned to someone less than their first choice will be disappointed
and will always prefer anyone higher up on the list. A set of marriages is
called unstable if two people who are not married both prefer each other totheir spouses. For example, the assignment Al B3 C2 D4 E5 is unstablebecause A prefers 2 to 1 and 2 prefers A to C. Thus, acting according to their
preferences, A would leave 1 for 2 and 2 would leave C for A (leaving 1 andC with little choice but to get together).Finding a stable configuration seems on the face of it to be a difficultproblem, since there are so many possible assignments. Even determiningwhether a configuration is stable is not simple, as the reader may discover
by looking (before reading the next paragraph) for the unstable couple in the
example above after the new matches A2 and Cl have been made. In general,
there are many different stable assignments for a given set of preference lists,
and we only need to find one. (Finding all stable assignments is a much more
difficult problem.)One possible algorithm for finding a stable configuration might be toremove unstable couples one at a time. However, not only is this slow becauseof the time required to determine stability, but also the process does not
even necessarily terminate! For example, after A2 and Cl have been matched
in the example above, B and 2 make an unstable couple, which leads to
the configuration A3 B2 Cl D4 E5. In this arrangement, B and 1 make an
unstable couple, which leads to the configuration A3 Bl C2 D4 E5. Finally,A and 1 make an unstable configuration which leads back to the originalconfiguration. An algorithm which attempts to solve the stable marriageproblem by removing stable pairs one by one is bound to get caught in thistype of loop.
MATCHING449Instead, we™ll look at an algorithm which tries to build stable pairingssystematically using a method based on what might happen in the somewhatidealized ﬁreal-lifeﬂ version of the problem. The idea is to have each man,
in turn, become a ﬁsuitorﬂ and seek a bride. Obviously, the first step in his
quest is to propose to the first woman on his list. If she is already engaged
to a man whom she prefers, then our suitor must try the next woman on hislist, continuing until he finds a woman who is not engaged or who prefershim to her current fiancee. If this women is not engaged, then she becomesengaged to the suitor and the next man becomes the suitor. If she is engaged,
then she breaks the engagement and becomes engaged to the suitor (whom
she prefers). This leaves her old fiancee with nothing to do but become thesuitor once again, starting where he left off on his list. Eventually he finds anew fiancee, but another engagement may need to be broken. We continue inthis way, breaking engagements as necessary, until some suitor finds a womanwho has not yet been engaged.This method may model what happens in some 19th-century novels, butsome careful examination is required to show that it produces a stable set ofassignments. The diagram below shows the sequence of events for the initial
stages of the process for our example. First, A proposes to 2 (his first choice)
and is accepted; then B proposes to 1 (his first choice) and is accepted; then C
proposes to 2, is turned down, and proposes to 3 and is accepted, as depictedin the third diagram:Each diagram shows the sequence of events when a new man sets out as thesuitor to seek a fiancee. Each line gives the ﬁusedﬂ preference list for thecorresponding man, with each link labeled with an integer telling when thatlink was used by that man to propose to that woman. This extra informationis useful in tracking the sequence of proposals when D and E become thesuitor, as shown in the following figure:
450CWTER 34When D proposes to 1, we have our first broken engagement, since 1 prefersD to B. Then B becomes the suitor and proposes to 2, which gives our second
broken engagement, since 2 prefers B to A. Then A becomes the suitor and
proposes to 5, which leaves a stable situation. The reader might wish to trace
through the sequence of proposals made when E becomes the suitor. Things
don™t settle down until after eight proposals are made. Note that E takes onthe suitor role twice in the process.To begin the implementation, we need data structures to represent thepreference lists. Different structures are appropriate for the men and thewomen, since they use the preference lists in different ways. The men simply
go through their preference lists in order, so a straightforward implementation
as a two-dimensional array is called for: we™ll maintain a two-dimensionalarray for the preference list so that, for example, prefer[m, w] will be the wthwoman in the preference list of the mth man. In addition, we need to keeptrack of how far each man has progressed on his list. This can be handledwith a one-dimensional array next, initialized to zero, with next[m]+1 theindex of the next woman on man m™s preference list: her identifier is found inprefer[m, next[m]+l].For each woman, we need to keep track of her fiancee (fiancee[w] willbe the man engaged to woman w) and we need to be able to answer thequestion ﬁIs man s preferable to fiancee [ w]?ﬂ This could be done by searchingthe preference list sequentially until either s or fiancee[w] is found, but thismethod would be rather inefficient if they™re both near the end. What is calledfor is the ﬁinverseﬂ of the preference list: rank[w, s] is the index of man s onwoman w™s preference list. For the example above this array is
MATCHING4511: 2 4 5 3 12: 4 3 5 1 23: 1 3 4 2 54: 4 2 1 3 55: 5 2 3 1 4The suitability of suitor s can be very quickly tested by the statement ifrank[w, s]<rank[w, fiancee[w]] . . . .These arrays are easily constructed di-rectly from the preference lists. To get things started, we use a ﬁsentinelﬂ man0 as the initial suitor, and put him at the end of all the women™s preferencelists.With the data structures initialized in this way, the implementation asdescribed above is straightforward:for m:=l to N dobegins:=m;repeatnext[s]:=next[s]+l; w:=prefer[s,next[s]];if rank[w, s]<rank[w, fiancee[w]] thenbegin t:=fiancee[w]; fiancee[w]:=s; s:=t end;until s=O;end ;Each iteration starts with an unengaged man and ends with an engagedwoman. The repeat loop must terminate because every man™s list containsevery woman and each iteration of the loop involves incrementing some man™slist, and thus an unengaged woman must be encountered before any man™s
list is exhausted. The set of engagements produced by the algorithm is stable
because every woman whom any man prefers to his fiancee is engaged tosomeone that she prefers to him.There are several obvious built-in biases in this algorithm. First, themen go through the women on their lists in order, while the women mustwait for the ﬁright manﬂ to come along. This bias may be corrected (in asomewhat easier manner than in real life) by interchanging the order in whichthe preference lists are input. This produces the stable configuration 1E 2D3A 4C 5B, where every women gets her first choice except 5, who gets hersecond. In general, there may be many stable configurations: it can be shownthat this one is ﬁoptimalﬂ for the women, in the sense that no other stableconfiguration will give any woman a better choice from her list. (Of course,the first stable configuration for our example is optimal for the men.)
452CHAPTER 34Another feature of the algorithm which seems to be biased is the order inwhich the men become the suitor: is it better to be the first man to propose(and therefore be engaged at least for a little while to your first choice) or
the last (and therefore have a reduced chance to suffer the indignities of abroken engagement)? The answer is that this is not a bias at all: it doesn™tmatter in what order the men become the suitor. As long as each man makesproposals and each woman accepts according to their lists, the same stableconfiguration results.Advanced AlgorithmsThe two special cases that we™ve examined give some indication of how com-plicated the matching problem can be. Among the more general problemsthat have been studied in some detail are: the maximum matching problemfor general (not necessarily bipartite) graphs; weighted matching for bipartitegraphs, where edges have weights and a matching with maximum total weight
is sought; and weighted matching for general graphs. Treating the many tech-
niques that have been tried for matching on general graphs would fill an entirevolume: it is one of the most extensively studied problems in graph theory.
453Exercises1.2.3.4.5.6.7.8.9.10.Find all the matchings with five edges for the given sample bipartitegraph.Use the algorithm given in the text to find maximum matchings forrandom bipartite graphs with 50 vertices and 100 edges. About how many
edges are in the matchings?Construct a bipartite graph with six nodes and eight edges which has athree-edge matching, or prove that none exists.Suppose that vertices in a bipartite graph represent jobs and people andthat each person is to be assigned to two jobs. Will reduction to networkflow give an algorithm for this problem? Prove your answer.Modify the network flow program of Chapter 33 to take advantage of thespecial structure of the O-l networks which arise for bipartite matching.Write an efficient program for determining whether an assignment for themarriage problem is stable.Is it possible for two men to get their last choice in the stable marriagealgorithm? Prove your answer.Construct a set of preference lists for N = 4 for the stable marriageproblem where everyone gets their second choice, or prove that no suchset exists.Give a stable configuration for the stable marriage problem for the casewhere the preference lists for men and women are all the same: in ascend-
ing order.Run the stable marriage program for N = 50, using random permutationsfor preference lists. About how many proposals are made during theexecution of the algorithm?
454SOURCES for Graph AlgorithmsThere are several textbooks on graph algorithms, but the reader shouldbe forewarned that there is a great deal to be learned about graphs, thatthey still are not fully understood, and that they are traditionally studiedfrom a mathematical (as opposed to an algorithmic) standpoint. Thus, manyreferences have more rigorous and deeper coverage of much more difficulttopics than our treatment here.Many of the topics that we™ve treated here are covered in the book byEven, for example, our network flow example in Chapter 33. Another sourcefor further material is the book by Papadimitriou and Steiglitz. Though mostof that book is about much more advanced topics (for example, there is a full
treatment of matching in general graphs), it has up-to-date coverage of many
of the algorithms that we™ve discussed, including pointers to further reference
material.The application of depth-first search to solve graph connectivity and otherproblems is the work of R. E. Tarjan, whose original paper merits furtherstudy. The many variants on algorithms for the union-find problem of Chapter30 are ably categorized and compared by van Leeuwen and Tarjan. Thealgorithms for shortest paths and minimum spanning trees in dense graphsin Chapter 31 are quite old, but the original papers by Dijkstra, Prim, andKruskal still make interesting reading. Our treatment of the stable marriage
problem in Chapter 34 is based on the entertaining account given by Knuth.E. W. Dijkstra, ﬁA note on two problems in connexion with graphs,ﬂ Numer-ishe Muthemutik, 1 (1959).S. Even, Graph Algorithms, Computer Science Press, Rockville, MD, 1980.D. E. Knuth, Marriages stables, Les Presses de L™Universite de Montreal,Montreal, 1976.J. R. Kruskal Jr.,ﬁOn the shortest spanning subtree of a graph and thetraveling salesman problem,ﬂ Proceedings AMS, 7, 1 (1956).C. H. Papadimitriou and K. Steiglitz, Combinatorial Optimization: Algorithmsand Complexity, Prentice-Hall, Englewood Cliffs, NJ, 1982.R. C. Prim, ﬁShortest connection networks and some generalizations,ﬂ BellSystem Technical Journal, 36 (1957).R. E. Tarjan, ﬁDepth-first search and linear graph algorithms,ﬂ SIAM Journalon Computing, 1, 2 (1972).J. van Leeuwen and R. E. Tarjan,ﬁWorst-case analysis of set-union algo-rithms,ﬂ Journal of the ACM, to appear.
ADVANCED TOPICS

35. Algorithm MachinesThe algorithms that we have studied are, for the most part, remarkablyrobust in their applicability. Most of the methods that we have seenare a decade or more old and have survived many quite radical changes incomputer hardware and software.New hardware designs and new softwarecapabilities certainly can have a significant impact on specific algorithms, butgood algorithms on old machines are, for the most part, good algorithms onnew machines.One reason for this is that the fundamental design of ﬁconventionalﬂcomputers has changed little over the years. The design of the vast majorityof computing systems is guided by the same underlying principle, which wasdeveloped by the mathematician J. von Neumann in the early days of moderncomputing. When we speak of the von Neumann model of computation, werefer to a view of computing in which instructions and data are stored in thesame memory and a single processor fetches instructions from the memoryand executes them (perhaps operating on the data), one by one. Elaboratemechanisms have been developed to make computers cheaper, faster, smaller(physically), and larger (logically), but the architecture of most computersystems can be viewed as variations on the von Neumann theme.Recently, however, radical changes in the cost of computing componentshave made it plausible to consider radically different types of machines, onesin which a large number of instructions can be executed at each time instant
or in which the instructions are ﬁwired inﬂ to make special-purpose machines
capable of solving only one problem or in which a large number of smaller
machines can cooperate to solve the same problem. In short, rather thanhaving a machine execute just one instruction at each time instant, we canthink about having a large number of actions being performed simultaneously.
In this chapter, we shall consider the potential effect of such ideas on some of
the problems and algorithms we have been considering.457
458CHAPTER 35General ApproachesCertain fundamental algorithms are used so frequently or for such large prob-lems that there is always pressure to run them on bigger and faster com-
puters. One result of this has been a series of ﬁsupercomputersﬂ which em-
body the latest technology; they make some concessions to the fundamental
von Neumann concept but still are designed to be general-purpose and usefulfor all programs. The common approach to using such a machine for the typeof problem we have been studying is to start with the algorithms that are
best on conventional machines and adapt them to the particular features of
the new machine. This approach encourages the persistence of old algorithms
and old architecture in new machines.Microprocessors with significant computing capabilities have become quiteinexpensive. An obvious approach is to try to use a large number of processorstogether to solve a large problem. Some algorithms can adapt well to beingﬁdistributedﬂ in this way; others simply are not appropriate for this kind ofimplementation.The development of inexpensive, relatively powerful processors has in-volved the appearance of general-purpose tools for use in designing and build-ing new processors. This has led to increased activity in the developmentof special-purpose machines for particular problems. If no machine is par-ticularly well-suited to execute some important algorithm, then we can designand build one that is! For many problems, an appropriate machine can bedesigned and built that fits on one (very-large-scale) integrated circuit chip.A common thread in all of these approaches is parallelism: we try tohave as many different things as possible happening at any instant. This canlead to chaos if it is not done in an orderly manner. Below, we™ll consider
two examples which illustrate some techniques for achieving a high degree of
parallelism for some specific classes of problems. The idea is to assume that
we have not just one but M processors on which our program can run. Thus,if things work out well, we can hope to have our program run M times fasterthan before.There are several immediate problems involved in getting M processorsto work together to solve the same problem. The most important is that theymust communicate in some way: there must be wires interconnecting themand specific mechanisms for sending data back and forth along those wires.Furthermore, there are physical limitations on the type of interconnectionallowed. For example, suppose that our ﬁprocessorsﬂ are integrated circuitchips (these can now contain more circuitry than small computers of the past)which have, say, 32 pins to be used for interconnection. Even if we had 1000such processors, we could connect each to at most 32 others. The choiceof how to interconnect the processors is fundamental in parallel computing.
ALGORITHM MACHINES459Moreover, it™s important to remember that this decision must be made aheadof time: a program can change the way in which it does things depending onthe particular instance of the problem being solved, but a machine generally
can™t change the way its parts are wired together.This general view of parallel computation in terms of independent proces-sors with some fixed interconnection pattern applies in each of the threedomains described above: a supercomputer has very specific processors and
interconnection patterns that are integral to its architecture (and affect many
aspects of its performance); interconnected microprocessors involve a relatively
small number of powerful processors with simple interconnections; and very-large-scale integrated circuits themselves involve a very large number of simpleprocessors (circuit elements) with complex interconnections.Many other views of parallel computation have been studied extensivelysince von Neumann, with renewed interest since inexpensive processors havebecome available. It would certainly be beyond the scope of this book to
treat all the issues involved. Instead, we™ll consider two specific machines
that have been proposed for some familiar problems. The machines that we
consider illustrate the effects of machine architecture on algorithm design andvice versa. There is a certain symbiosis at work here: one certainly wouldn™tdesign a, new computer without some idea of what it will be used for, and onewould like to use the best available computers to execute the most importantfundamental algorithms.Perfect ShuflesTo illustrate some of the issues involved in implementing algorithms as ma-chines instead of programs, we™ll look at an interesting method for mergingwhich is suitable for hardware implementation. As we™ll see, the same generalmethod can be developed into a design for an ﬁalgorithm machineﬂ whichincorporates a fundamental interconnection pattern to achieve parallel opera-tion of M processors for solving several problems in addition to merging.As mentioned above, a fundamental difference between writing a programto solve a problem and designing a machine is that a program can adapt itsbehavior to the particular instance of the problem being solved, while themachine must be ﬁwiredﬂ ahead of time always to perform the same sequence
of operations. To see the difference, consider the first sorting program that we
studied, sort3 from Chapter 8. No matter what three numbers appear in thedata, the program always performs the same sequence of three fundamentalﬁcompare-exchangeﬂ operations.None of the other sorting algorithms thatwe studied have this property. They all perform a sequence of comparisonsthat depends on the outcome of previous comparisons, which presents severeproblems for hardware implementation.
460CRAPTER 35Specifically, if we have a piece of hardware with two input wires and twooutput wires that can compare the two numbers on the input and exchangethem if necessary for the output, then we can wire three of these togetheras follows to produce a sorting machine with three inputs (at the top in thefigure) and three outputs (at the bottom):Thus, for example, if C B A were to appear at the top, the first box wouldexchange the C and the B to give B C A, then the second box would exchangethe B and the A to give A C B, then the third box would exchange the C andthe B to produce the sorted result.Of course, there are many details to be worked out before an actualsorting machine based on this scheme can be built. For example, the methodof encoding the inputs is left unspecified: one way would be to think of eachwire in the diagram above as a ﬁbusﬂ of enough wires to carry the data withone bit per wire; another way is to have the compare-exchangers read theirinputs one bit at a time along a single wire (most significant bit first). Alsoleft unspecified is the timing: mechanisms must be included to ensure thatno compare-exchanger performs its operation before its input is ready. We
clearly won™t be able to delve much deeper into such circuit design questions;instead we™ll concentrate on the higher level issues concerning interconnectingsimple processors such as compare-exchangers for solving larger problems.To begin, we™ll consider an algorithm for merging together two sortedfiles, using a sequence of ﬁcompare-exchangeﬂ operations that is independentof the particular numbers to be merged and is thus suitable for hardwareimplementation. Suppose that we have two sorted files of eight keys to bemerged together into one sorted file. First write one file below the other, thencompare those that are vertically adjacent and exchange them if necessary to
put the larger one below the smaller one.
ALGORITHM MACHINES461AEGGIMNRABEEIMNRABEELMPXAEGGLMPXNext, split each line in half and interleave the halves, then perform the samecompare-exchange operations on the numbers in the second and third lines.(Note that comparisons involving other pairs of lines are not necessary becauseof previous sorting.)A B E EABEEIMNRAEGGAEGGIMNRL M P XLMPXThis leaves both the rows and the columns of the table sorted. This fact isa fundamental property of this method: the reader may wish to check that
it is true, but a rigorous proof is a trickier exercise than one might think. It
turns out that this property is preserved by the same operation: split eachline in half, interleave the halves, and do compare-exchanges between itemsnow vertically adjacent that came from different lines.A BE EA EG GI MN RL MP xA BA EE EG GI ML MN R
P xWe have doubled the number of rows, halved the number of columns, and stillkept the rows and the columns sorted. One more step completes the merge:
462CHAPTER 35AABAABEEEEEEGGGGIIMLLMMMNNRPPRXXAt last we have 16 rows and 1 column, which is sorted. This method obviouslyextends to merge files of equal lengths which are powers of two. Other sizescan be handled by adding dummy keys in a straightforward manner, though
the number of dummy keys can get large (if N is just larger than a power of2).The basic ﬁsplit each line in half and interleave the halvesﬂ operation inthe above description is easy to visualize on paper, but how can it be translatedinto wiring for a machine? There is a surprising and elegant answer to thisquestion which follows directly from writing the tables down in a differentway. Rather than writing them down in a two-dimensional fashion, we™ll
write them down as a simple (one-dimensional) list of numbers, organized
in column-major order: first put the elements in the first column, then put
the elements in the second column, etc. Since compare-exchanges are onlydone between vertically adjacent items, this means that each stage involvesa group of compare-exchange boxes, wired together according to the ﬁsplit-and-interleaveﬂ operation which is necessary to bring items together into thecompare-exchange boxes.This leads to the following diagram, which corresponds precisely to thedescription using tables above, except that the tables are all written in column-major order (including an initial 1 by 16 table with one file, then the other).The reader should be sure to check the correspondence between this diagramand the tables given above. The compare-exchange boxes are drawn explicitly,and explicit lines are drawn showing how elements move in the ﬁsplit-and-interleaveﬂ operation:
ALGORITHM MACHINES463AEGGIMNRABEELMPXIllA I A L B M E M E IN G\ P E It3 GI XAXAXAXBAEEEGGIMLMNRP™XABEEEGGILMMNPRXAASurprisingly, in this representation each ﬁsplit-and-interleaveﬂ operation re-duces to precisely the same interconnection pattern. This pattern is called
the perfect shufle because the wires are exactly interleaved, in the same waythat cards from the two halves would be interleaved in an ideal mix of a deckof cards.This method was named the odd-even merge by K. E. Batcher, whoinvented it in 1968. The essential feature of the method is that all of thecompare-exchange operations in each stage can be done in parallel. It clearly
demonstrates that two files of N elements can be merged together in 1ogNparallel steps (the number of rows in the table is halved at every step), usingless than N log N compare-exchange boxes. From the description above, thismight seem like a straightforward result: actually, the problem of finding sucha machine had stumped researchers for quite some time.Batcher also developed a closely related (but more difficult to understand)merging algorithm, the bitonic merge, which leads to an even simpler machine.
464CHAF™TER 35This method can be described in terms of the ﬁsplit-and-interleaveﬂ operationon tables exactly as above, except that we begin with the second file in reverse
sorted order and always do compare-exchanges between vertically adjacentitems that came from the same lines. We won™t go into the proof that thismethod works: our interest in it is that it removes the annoying feature in the
odd-even merge that the compare-exchange boxes in the first stage are shifted
one position from those in following stages. As the following diagram shows,
each stage of the bitonic merge has exactly the same number of comparators,in exactly the same positions:AEGGIMNRXPMLEEBAAEGGIMNRXPMLEEBAAXEPGMGLIEMENBRAAXEPGMGLIEMENBRAAXEPGMGLEIEMBNARAXEPGMGLEIEMBNARI3ABEGIMXNEAEGMLPRABEGIMXNEAEGMLPRABEGlMNXAE,EGLMPRABEGlMNXAE,EGLMPRI \\\w///I \\\w///AABEEEGGILMMNPRXAABEEEGGILMMNPRXNow there is regularity not only in the interconnections but in the positions ofthe compare-exchange boxes. There are more compare-exchange boxes thanfor the odd-even merge, but this is not a problem, since the same numberof parallel steps is involved. The importance of this method is that it leadsdirectly to a way to do the merge using only N compare-exchange boxes. The
ALGORITHM MACHINES465idea is to simply collapse the rows in the table above to just one pair of rows,and thus produce a cycling machine wired together as follows:I,I™ I I ™ ™1Such a machine can do log N compare-exchange-shuffle ﬁcycles,ﬂ one for eachof the stages in the figure above.Note carefully that this is not quite ﬁidealﬂ parallel performance: sincewe can merge together two files of N elements using one processor in a numberof steps proportional to N, we would hope to be able to do it in a constant
number of steps using N processors. In this case, it has been proven that it
is not possible to achieve this ideal and that the above machine achieves the
best possible parallel performance for merging using compare-exchange boxes.The perfect shuffle interconnection pattern is appropriate for a variety ofother problems. For example, if a 2n-by-2n square matrix is kept in row-majororder, then n perfect shuffles will transpose the matrix (convert it to column-major order). More important examples include the fast Fourier transform(which we™ll examine in the next chapter); sorting (which can be developed byapplying either of the methods above recursively); polynomial evaluation; and
a host of others. Each of these problems can be solved using a cycling perfect
shuffle machine with the same interconnections as the one diagramed above
but with different (somewhat more complicated) processors. Some researchers
have even suggested the use of the perfect shuffle interconnection for ﬁgeneral-purposeﬂ parallel computers.
466CHAPTER 35Systolic ArraysOne problem with the perfect shuffle is that the wires used for interconnectionare long. Furthermore, there are many wire crossings: a shuffle with N wiresinvolves a number of crossings proportional to N2. These two properties turnout to create difficulties when a perfect shuffle machine is actually constructed:long wires lead to time delays and crossings make the interconnection expen-sive and inconvenient.A natural way to avoid both of these problems is to insist that processorsbe connected only to processors which are physically adjacent. As above, weoperate the processors synchronously: at each step, each processor reads inputs
from its neighbors, does a computation, and writes outputs to its neighbors.
It turns out that this is not necessarily restrictive, and in fact H. T. Kung
showed in 1978 that arrays of such processors, which he termed systolic arrays(because the way data flows within them is reminiscent of a heartbeat), allowvery efficient use of the processors for some fundamental problems.As a typical application, we™ll consider the use of systolic arrays formatrix-vector multiplication. For a particular example, consider the matrixoperation(L/ -3 ‚X)-(g)This computation will be carried out on a row of simple processors each ofwhich has three input lines and two output lines, as depicted below:Five processors are used because we™ll be presenting the inputs and readingthe outputs in a carefully timed manner, as described below.During each step, each processor reads one input from the left, one fromthe top, and one from the right; performs a simple computation; and writesone output to the left and one output to the right. Specifically, the rightoutput gets whatever was on the left input, and the left output gets the resultcomputed by multiplying together the left and top inputs and adding the rightinput. A crucial characteristic of the processors is that they always perform adynamic transformation of inputs to outputs; they never have to ﬁrememberﬂ
computed values. (This is also true of the processors in the perfect shuffle
machine.) This is a ground rule imposed by low-level constraints on the
ALGORITHA4 MACHTNES467hardware design, since the addition of such a ﬁmemoryﬂ capability can be(relatively) quite expensive.The paragraph above gives the ﬁprogramﬂ for the systolic machine; tocomplete the description of the computation, we need to also describe exactlyhow the input values are presented. This timing is an essential feature of thesystolic machine, in marked contrast to the perfect shuffle machine, whereall the input values are presented at one time and all the output values are
available at some later time.The general plan is to bring in the matrix through the top inputs of theprocessors, reflected about the main diagonal and rotated forty-five degrees,and the vector through the left input of processor A, to be passed on to theother processors. Intermediate results are passed from right to left in thearray, with t,he output eventually appearing on the left output of processorA. The specific timing for our example is shown in the following table, whichgives the values of the left, top, and right inputs for each processor at eachstep:ABCDE ABCDEABCD1 12 13 5 1145 13 115 2 5 1 -4 1 -1 16 162 5-2 -2 8 6 -172 552-11822-192-110-1The input vector is presented to the left input of processor A at steps 1, 3,and 5 and passed right to the other processors in subsequent steps. The inputmatrix is presented to the top inputs of the processors starting at steps 3,skewed so the right-tcFleft diagonals of the matrix are presented in successivesteps. The output vector appears as the left output of processor A at steps6, 8, and 10. (In the table, this appears as the right input of an imaginaryprocessor to the left of A, which is collecting the answer.)The actual computation can be traced by following the right inputs (leftoutputs) which move from right to left through the array. All computationsproduce a zero result until step 3, when processor C has 1 for its left inputand 1 for its top input, so it computes the result 1, which is passed along
CHAPTER 35as processor B™s right input for step 4. At step 4, processor B has non-zerovalues for all three of its inputs, and it computes the value 16, to be passedon to processor A for step 5. Meanwhile, processor D computes a value 1 forprocessor C™s use at step 5. Then at step 5, processor A computes the value8, which is presented as the first output value at step 6; C computes the value6 for B™s use at step 6, and E computes its first nonaero value (-1) for use byD at step 6. The computation of the second output value is completed by Bat step 6 and passed through A for output at step 8, and the computation ofthe third output value is completed by C at step 7 and passed through B andA for output at step 10.Once the process has been checked at a detailed level as in the previousparagraph, the method is better understood at a somewhat higher level. Thenumbers in the middle part of the table above are simply a copy of the input
matrix, rotated and reflected as required for presentation to the top inputsof the processors. If we check the numbers in the corresponding positions atthe left part of the table, we find three copies of the input vector, located in
exactly the right positions and at the right times for multiplication against
the rows of the matrix. And the corresponding positions on the right give
the intermediate results for each multiplication of the input vector with each
matrix row. For example, the multiplication of the input vector with the
middle matrix row requires the partial computations 1™1 = 1, 1 + 1*5 = 6,and 6 + (-a)*2 = 2, which appear in the entries 1 6 2 in the reflected middlerow on the right-hand side of the table. The systolic machine manages to timethings so that each matrix element ﬁmeetsﬂ the proper input vector entry andthe proper partial computation at the processor where it is input, so that itcan be incorporated into the partial result.The method extends in an obvious manner to multiply an N-by-N matrixby an N-by-l vector using 2N - 1 processors in 4N - 2 steps. This does comeclose to the ideal situation of having every processor perform useful work atevery step: a quadratic algorithm is reduced to a linear algorithm using alinear number of processors.One can appreciate from this example that systolic arrays are at oncesimple and powerful. The output vector at the edge appears almost as ifby magic! However, each individual processor is just performing the simplecomputation described above: the magic is in the interconnection and thetimed presentation of the inputs. As before, we™ve only described a generalmethod of parallel computation.Many details in the logical design need tobe worked out before such a systolic machine can be constructed.As with perfect shuffle machines, systolic arrays may be used in manydifferent types of problems, including string matching and matrix multiplica-tion among others. Some researchers have even suggested the use of this
ALGORITMM h4ACHIAJES469interconnection pattern for ﬁgeneral-purposeﬂ parallel machines.Certainly, the study of the perfect shuffle and systolic machines illustratesthat hardware design can have a significant effect on algorithm design, suggest-ing changes that can provide interesting new algorithms and fresh challengesfor the algorithm designer. While this is an interesting and fruitful area forfurther research, we must conclude with a few sobering notes. First, a greatdeal of engineering effort is required to translate general schemes for parallelcomputation such as those sketched above to actual algorithm machines withgood performance. For many applications, the resource expenditure requiredis simply not justified, and a simple ﬁalgorithm machineﬂ consisting of a con-ventional (inexpensive) microprocessor running a conventional algorithm willdo quite well. For example, if one has many instances of the same problemto solve and several microprocessors with which to solve them, then idealparallel performance can be achieved by having each microprocessor (using aconventional algorithm) working on a different instance of the problem, withno interconnection at all required. If one has N files to sort and N proces-sors available on which to sort them, why not simply use one processor foreach sort, rather than having all N processors labor together on all N sorts?Techniques such as those discussed in this chapter are currently justified onlyfor applications with very special time or space requirements. In studyingvarious parallel computation schemes and their effects on the performance ofvarious algorithms, we can look forward to the development of general-purposeparallel computers that will provide improved performance for a wide varietyof algorithms.t-l
470Exercises1.2.3.4.
5.6.7.8.9.10.Outline two possible ways to use parallelism in Quicksort.Write a conventional Pascal program which merges files using Batcher™sbitonic method.Write a conventional Pascal program which merges files using Batcher™sbitonic method, but doesn™t actually do any shuffles.Does the program of the previous exercise have any advantage over con-ventional merging?How many perfect shuffles will bring all the elements in an array of size2% back to their original positions?Draw a table like the one given in the text to illustrate the operation ofthe systolic matrix-vector multiplier for the following problem:Write a conventional Pascal program which simulates the operation ofthe systolic array for multiplying a N-by-N matrix by an N-by-l vector.Show how to use a systolic array to transpose a matrix.
How many processors and how many steps would be required for a systolicmachine which can multiply an M-by-N matrix by an N-by-l vector?Give a simple parallel scheme for matrix-vector multiplication using proces-sors which have the capability to ﬁrememberﬂ computed values.
36. The Fast Fourier TransformqOne of the most widely used arithmetic algorithms is the fast Fouriertransform, which (among many other applications) can provide a sub-stantial reduction in the time required to multiply two polynomials. TheFourier transform is of fundamental importance in mathematical analysis and
is the subject of volumes of study. The emergence of an efficient algorithm
for this computation was a milestone in the history of computing.It would be beyond the scope of this book to outline the mathematicalbasis for the Fourier transform or to survey its many applications. Our pur-pose is to learn the characteristics of a fundamental algorithm within the
context of some of the other algorithms that we™ve been studying. In par-ticular, we™ll examine how to use the algorithm for polynomial multiplication,a problem that we studied in Chapter 4. Only a very few elementary facts
from complex analysis are needed to show how the Fourier transform can be
used to multiply polynomials, and it is possible to appreciate the fast Fourier
transform algorithm without fully understanding the underlying mathematics.The divide-and-conquer technique is applied in a way similar to other impor-tant algorithms that we™ve seen.Evaluate, Multiply, InterpolateThe general strategy of the improved method for polynomial multiplicationthat we™ll be examining takes advantage of the fact that a polynomial of degreeN - 1 is completely determined by its value at N different points. When wemultiply two polynomials of degree N - 1 together, we get a polynomial ofdegree 2N - 2: if we can find that polynomial™s value at 2N - 1 points, then itis completely determined. But we can find the value of the result at any pointsimply by evaluating the two polynomials to be multiplied at that point and
then multiplying those numbers. This leads to the following general scheme
for multiplying two polynomials of degree N - 1:471
472CHAPTER 36Evaluate the input polynomials at 2N - 1 distinct points.Multiply the two values obtained at each point.Interpolate to find the unique result polynomial that has the given valueat the given points.For example, to compute T(Z) = p(x)q(x) with p(z) = 1+x+x2 and q(x) =2 -x+x2, we can evaluate p(x) and q(x) at any five points, say -2,-1,0,1,2,to get the values[P(-%P(-l),P(O),P(l),P(2)1 = [3,1,1,3,71,[4(-2), 4(-i), do), 4(l), 4641 = [8,4,2,2,41.Multiplying these together term-by-term gives enough values for the productpolynomial,[r(-2), 7(-l), r(O), r(l), r(2)] = [24,4,2,6,281,that its coefficients can be found by interpolation. By the Lagrange formula,x+1x-ox-lx-2r(x) = 24- - - --2+1 -2-o -2-l -2-2x+2x-ox-lx-2+4-----1+2 -1-o -1-1 -1-2x+2 x+1 z-1 x-2+2- ~ - -0+2 0+1 o-1 o-2x+2 x+1 x-o x-2+6- - - -1+2 1Sl 1-o l-2x+2 x+1 x-o x-l+28- - - -2+2 2fl 2-o 2-l™which simplifies to the resultr(x)=2+x+2x2+x4.As described so far, this method is not a good algorithm for polynomial multi-plication since the best algorithms we have so far for both evaluation (repeatedapplication of Horner™s method) and interpolation (Lagrange formula) requireN2 operations. However, there is some hope of finding a better algorithm be-cause the method works for any choice of 2N - 1 distinct points whatsoever,and it is reasonable to expect that evaluation and interpolation will be easierfor some sets of points than for others.
THE FAST FOURIER TRANSFORM473Complex Roots of UnityIt turns out that the most convenient points to use for polynomial interpolationand evaluation are complex numbers, in fact, a particular set of complex
numbers called the complex roots of unity.A brief review of some facts about complex analysis is necessary. Thenumber i = fl is an imaginary number: though \/-i is meaningless asa real number, it is convenient to give it. a name, i, and perform algebraicmanipulations with it, replacing i2 with -1 whenever it appears. A complexnumber consists of two parts, real and imaginary, usually written as a + bi,where a and b are reals. To multiply complex numbers, apply the usual rules,but replace i2 with -1 whenever it appears. For example,(CL + bi)(c + di) = (ac - bd) + (ad + bc)i.Sometimes the real or imaginary part can cancel out when a complex multi-plication is performed. For example,(1 - i)(l -i) = -2i,(1 + i)ﬂ = -4,(1 + i)* = 16.Scaling this last equation by dividing through by 16 = a*), we find thatIn general, there are many complex numbers that evaluate to 1 when raisedto a power. These are the so-called complex roots of unity. In fact, it turns
out that for each N, there are exactly N complex numbers z with zN = 1.One of these, named WN, is called the principal Nth root of unity; the othersare obtained by raising WN to the kth power, for k = 0,1,2,. . . ,N - 1. Forexample, we can list the eighth roots of unity as follows:The first root, w&,is 1 and the second, wj~,is the principal root. Also, forN even, the root wEI2 is -1 (because (w:‚~)~ = 1).The precise values of the roots are unimportant for the moment. We™ll beusing only simple properties which can easily be derived from the basic factthat the Nth power of any Nth root of unity must be 1.
474CXAPTER 36Evaluation at the Roots of UnityThe crux of our implementation will be a procedure for evaluating a poly-nomial of degree N - 1 at the Nth roots of unity. That is, this proceduretransforms the N coefficients which define the polynomial into the N valuesresulting from evaluating that polynomial at all of the Nth roots of unity.This may not seem to be exactly what we want, since for the first step ofthe polynomial multiplication procedure we need to evaluate polynomials ofdegree N - 1 at 2N - 1 points. Actually, this is no problem, since we can viewa polynomial of degree N - 1 as a polynomial of degree 2N - 2 with N - 1coefficients (those for the terms of largest degree) which are 0.The algorithm that we™ll use to evaluate a polynomial of degree N - 1at N points simultaneously will be based on a simple divide-and-conquerstrategy. Rather than dividing the polynomials in the middle (as in themultiplication algorithm in Chapter 4) we™ll divide them into two parts byputting alternate terms in each part. This division can easily be expressed in
terms of polynomials with half the number of coefficients. For example, forN = 8, the rearrangement of terms is as follows:p(s)=po+p1a:+pzx2 +p3x3 +p4x4+p5x5 +psx6+p7x7=(p~+p~~2+~4~4+p~~6)+~(~l +p3x2 +p5x4+p7x6)= &(X2) + xp,(x2).The Nth roots of unity are convenient for this decomposition because if yousquare a root of unity, you get another root of unity. In fact, even more istrue: for N even, if you square an Nth root of unity, you get an +Nth root ofunity (a number which evaluates to 1 when raised to the ;Nth power). Thisis exactly what is needed to make the divide-and-conquer method work. Toevaluate a polynomial with N coefficients on N points, we split it into two
polynomials with ;N coefficients. These polynomials need only be evaluatedon ;N points (the ;Nth roots of unity) to compute the values needed for thefull evaluation.To see this more clearly, consider the evaluation of a degree-7 polynomialp(x) on the eighth roots of unityw~:w~,w~,w~,w~,w~,w~,w~,w~.Since wi = -1, this is the same as the sequencew* : w;, w;, w;, w;, -w;, -w;, -w;, -w;.Squaring each term of this sequence gives two copies of the sequence (W4) ofthe fourth roots of unity:
THE FAST FOURLEX TRAhBFORM475Now, our equationtells us immediately how to evaluate p(z) at the eighth roots of unity fromthese sequences. First, we evaluate p,(x) and pO(x) at the fourth roots of unity.Then we substitute each of the eighth roots of unity for x in the equationabove, which requires adding the appropriate p, value to the product of theappropriate p, value and the eighth root of unity:P(4) = P&4, + w:Po(w:),Pm = P&4 + w;P&J:),P(4) = Pe(W,ﬁ, + w:Po(w.f),PM3 = P&3 + w;Po(w:),P(4) = Pew2 - w:Po(w:),PO-4 = Pebi, - w;P&J~),P(4) = P&4, - w;Po(w:),P(4) = P&3 - w:Pob4In general, to evaluate p(x) on the Nth roots of unity, we recursively evaluatep,(x) and pO(x) on the ;Nth roots of unity and perform the N multiplicationsas above. This only works when N is even, so we™ll assume from now on thatN is a power of two, so that it remains even throughout the recursion. Therecursion stops when N = 2 and we have po + pix to be evaluated at 1 and-1, with the results po + pi and pc -pi.The number of multiplications used satisfies the ﬁfundamental divide-and-conquerﬂ recurrenceM(N) = 2M(N/2) + N,which has the solution M(N) = N lg N. This is a substantial improvementover the straightforward N2 method for interpolation but, of course, it worksonly at the roots of unity.This gives a method for transforming a polynomial from its representationas N coefficients in the conventional manner to its representation in terms ofits values at the roots of unity. This conversion of the polynomial from the
first representation to the second is the Fourier transform, and the efficient
recursive calculation procedure that we have described is called the ﬁfastﬂ
Fourier transform (FFT). (These same techniques apply to more generalfunctions than polynomials. More precisely we™re doing the ﬁdiscreteﬂ Fouriertransform.)
476CHAPTER 36Interpolation at the Roots of UnityNow that we have a fast way to evaluate polynomials at a specific set of points,all that we need is a fast way to interpolate polynomials at those same points,and we will have a fast polynomial multiplication method. Surprisingly, it
works out that, for the complex roots of unity, running the evaluation program
on a particular set of points will do the interpolation! This is a specific instanceof a fundamental ﬁinversionﬂ property of the Fourier transform, from whichmany important mathematical results can be derived.For our example with N = 8, the interpolation problem is to find thepolynomialr(x) = To + TlX + %X2 + r3x3 + r4x4 + r5x5 + QX6 + r7x7which has the valuesr(w;)= so, r(wk)= Sl, r(wi)= s2, r(wg)= sg,?(w;)= $4, T(tﬂ;)= 85, T(w;)= ~96, +;)= ~97.As we™ve said before, the interpolation problem is the ﬁinverseﬂ of the evalua-tion problem. When the points under consideration are the complex roots ofunity, this is literally true. If we letthen we can get the coefficientsjust by evaluating the polynomial s(x) at the inverses of the complex roots ofunityw,l : w;,wi1,w-2,w-3 -4@+-68 81w8 8-18 yw8which is the same sequence as the complex roots of unity, but in a differentorder:w,l : w;, w;, w;, w;, w;, w;, w;, w18'In other words, we can use exactly the same routine for interpolation asfor evaluation: only a simple rearrangement of the points to be evaluated isrequired.The proof of this fact requires some elementary manipulations with finitesums: those unfamiliar with such manipulations may wish to skip to the endof this paragraph. Evaluating s(z) at the inverse of the tth Nth root of unity
THE FAST FOURLER TRANSFORM477givess(w$) = c Sj(W$)t)O<j<N= c r(wg(wj$O<j<N= c c Ti(W$J(Wf;t)JOQ<N O<i<NNearly everything disappears in the last term because the inner sum is triviallyN if i = t: if i # t then it evaluates tocW(Z-W _ 1j(i-t) _ NwN -O<l<NNote that an extra scaling factor of N arises. This is the ﬁinversion theoremﬂfor the discrete Fourier transform, which says that the same method will
convert a polynomial both ways: between its representation as coefficients and
its representation as values at the complex roots of unity.While the mathematics may seem complicated, the results indicated arequite easy to apply: to interpolate a polynomial on the Nth roots of unity,use the same procedure as for evaluation, using the interpolation values as
polynomial coefficients, then rearrange and scale the answers.ImplementationNow we have all the pieces for a divide-and-conquer algorithm to multiplytwo polynomials using only about N lg N operations. The general scheme isto:Evaluate the input polynomials at the (2N - 1)st roots of unity.Multiply the two values obtained at each point.Interpolate to find the result by evaluating the polynomial defined bythe numbers just computed at the (2N - 1)st roots of unity.The description above can be directly translated into a program which uses aprocedure that can evaluate a polynomial of degree N - 1 at the Nth rootsof unity. Unfortunately, all the arithmetic in this algorithm is to be complexarithmetic, and Pascal has no built-in type complex. While it is possible
478CHAPTER 36to have a user-defined type for the complex numbers, it is then necessaryto also define procedures or functions for all the arithmetic operations onthe numbers, and this obscures the algorithm unnecessarily. The followingimplementation assumes a type complex for which the obvious arithmeticfunctions are defined:eval(p, outN, 0);eval(q, outN, 0);for i:=O to outNdo r[i]:=p[i]*q[i];eval(r, outN, 0);for i:=l to N dobegin t:=r[i]; r[i]:=r[outN+1-i]; r[outN+l-i]:=t end;for i:=O to outN do r[i] :=r[i]/(outN+l);This program assumes that the global variable outN has been set to 2N-1,and that p, q, and r are arrays indexed from 0 to 2N - 1 which hold complexnumbers. The two polynomials to be multiplied, p and q are of degree N - 1,and the other coefficients in those arrays are initially set to 0. The procedureeval replaces the coefficients of the polynomial given as the first argument bythe values obtained when the polynomial is evaluated at the roots of unity.The second argument specifies the degree of the polynomial (one less than thenumber of coefficients and roots of unity) and the third argument is describedbelow. The above code computes the product of p and q and leaves the resultin r.Now we are left with the implementation of eval. As we™ve seen before,recursive programs involving arrays can be quite cumbersome to implement. Itturns out that for this algorithm it is possible to get around the usual storage
management problem by reusing the storage in a clever way. What we would
like to do is have a recursive procedure that takes as input a contiguous array
of N + 1 coefficients and returns the N + 1 values in the same array. But
the recursive step involves processing two noncontiguous arrays: the odd andeven coefficients. On reflection, the reader will see that the ﬁperfect shuffleﬂof the previous chapter is exactly what is needed here. We can get the odd
coefficients in a contiguous subarray (the first half) and the even coefficientsin a contiguous subarray (the second half) by doing a ﬁperfect unshuffleﬂ ofthe input, as diagramed below for N = 15:
THE FAST FOURlER TRANSFORM479PO p, P2 P3 p4 P5 P6 p7 &I p!3 PlO PI1 p12 P13 P14 P15This leads to the following implementation of the FFT:procedure eval(var p: poly; N, k: integer);var i, j: integer;begin
if N=l thenbegint:=p[k]; pl:=p[k+l];:I] :=t+pl; p[k+l] :=t-plelsebeginfori:=Oto Ndiv 2dobeginj:=k+2*i;t[i]:=pb]; t[i+l+Ndiv 2]:=p[j+l]end;for i:=O to N do p[k+i] := t [i] ;eval(p, N div 2, k) ;eval(p, N div 2, k+l+N div 2);j:=(outN+l) div (Nfl);fori:=Oto Ndiv 2dobegint:=w[i*j]*p[k+(N div 2)+l+i];t[i]:=p[k+i]+t; t[i+(Ndiv 2)+1]:=p[k+i]-tend ;for i:=O to N do p[k+i]:=t[i]endend ;This program transforms the polynomial of degree N inplace in the subarrayp[k..k+N] using the recursive method outlined above. (For simplicity, thecode assumes that N+l is a power of two, though this dependence is not hardto remove.) If N = 1, then the easy computation to evaluate at 1 and -1 is
480CHAPTER 36performed. Otherwise the procedure first shuffles, then recursively calls itselfto transform the two halves, then combines the results of these computations
as described above. Of course, the actual values of the complex roots of unity
are needed to do the implementation. It is well known thatthese values are easily computed using conventional trigonometric functions.In the above program, the array w is assumed to hold the (outN+l)st roots ofunity. To get the roots of unity needed, the program selects from this arrayat an interval determined by the variable i. For example, if outhJ were 15,the fourth roots of unity would be found in w[O], w[4],w[8], and w[12]. Thiseliminates the need to recompute roots of unity each time they are used.As mentioned at the outset, the scope of applicability of the FFT is fargreater than can be indicated here; and the algorithm has been intensivelyused and studied in a variety of domains.Nevertheless, the fundamentalprinciples of operation in more advanced applications are the same as for thepolynomial multiplication problem that we™ve discussed here. The FFT is
a classic example of t.he application of the. ﬁdivide-and-conquerﬂ algorithmdesign paradigm to achieve truly significant computational savings.rl
THE FAST FOURLER TRANSFORM481Exercises1.Explain how you would improve the simple evaluate-multiply-interpolatealgorithm for multiplying together two polynomials p(z) and q(z) withknown roots ~0, ~1,. . . #N-I and 40, 41,. . . ,qN-1.2.Find a set of N real numbers at which a polynomial of degree N can beevaluated using substantially fewer than N2 operations.3.Find a set of N real numbers at which a polynomial of degree N can beinterpolated using substantially fewer than N2 operations.4.What is the value of WE for M > N?5.Would it be worthwhile to multiply sparse polynomials using the FFT?6.The FFT implementation has three calls to eval, just as the polynomialmultiplication procedure in Chapter 4 has three calls to mult. Why is theFFT implementation more efficient?7.Give a way to multiply two complex numbers together using fewer thanfour integer multiplication operations.8.How much storage would be used by the FFT if we didn™t circumvent theﬁstorage management problemﬂ with the perfect shuffle?9.Why can™t some technique like the perfect shuffle be used to avoid theproblems with dynamically declared arrays in the polynomial multiplica-tion procedure of Chapter 4?10. Write an efficient program to multiply a polynomial of degree N by apolynomial of degree M (not necessarily powers of two).

37. Dynamic ProgrammingThe principle of divide-and-conquer has guided the design of many ofthe algorithms we™ve studied: to solve a large problem, break it up intosmaller problems which can be solved independently. In dynamic programmingthis principle is carried to an extreme: when we don™t know exactly whichsmaller problems to solve, we simply solve them all, then store the answersaway to be used later in solving larger problems.There are two principal difficulties with the application of this technique.First, it may not always be possible to combine the solutions of two problemsto form the solution of a larger one. Second, there may be an unacceptably
large number of small problems to solve. No one has precisely characterized
which problems can be effectively solved with dynamic programming; there are
certainly many ﬁhardﬂ problems for which it does not seem to be applicable(see Chapters 39 and 40), as well as many ﬁeasyﬂ problems for which it isless efficient than standard algorithms. However, there is a certain class ofproblems for which dynamic programming is quite effective. We™ll see several
examples in this section. These problems involve looking for the ﬁbestﬂ way to
do something, and they have the general property that any decision involved
in finding the best way to do a small subproblem remains a good decision even
when that subproblem is included as a piece of some larger problem.Knapsack ProblemSuppose that a thief robbing a safe finds N items of varying size and valuethat he could steal, but has only a small knapsack of capacity A4 which hecan use to carry the goods. The knapsack problem is to find the combinationof items which the thief should choose for his knapsack in order to maximize
the total take. For example, suppose that he has a knapsack of capacity 17
and the safe contains many items of each of the following sizes and values:483
CHAPTER 37name A B C D Esize34789value4 5 10 11 13(As before, we use single letter names for the items in the example and integerindices in the programs, with the knowledge that more complicated names
could be translated to integers using standard searching techniques.) Thenthe thief could take five A™s (but not six) for a total take of 20, or he couldfill up his knapsack with a D and an E for a total take of 24, or he could trymany other combinations.Obviously, there are many commercial applications for which a solutionto the knapsack problem could be important. For example, a shipping com-pany might wish to know the best way to load a truck or cargo plane with
items for shipment. In such applications, other variants to the problem might
arise: for example, there might be a limited number of each kind of item
available. Many such variants can be handled with the same approach that
we™re about to examine for solving the basic problem stated above.In a dynamic programming solution to the knapsack problem, we calcu-late the best combination for all knapsack sizes up to M. It turns out that wecan perform this calculation very efficiently by doing things in an appropriateorder, as in the following program:for j:=l to N dobeginfor i:=l to M doif i-sizeb]>=O thenif cost[i]<(cost[i-sizeb]]+valIj]) thenbegincost[i]:=cost[i-sizeb]]+valb];best[i] :=jend ;end ;In this program, cost[i] is the highest value that can be achieved with aknapsack of capacity i and best [i] is the last item that was added to achievethat maximum (this is used to recover the contents of the knapsack, asdescribed below). First, we calculate the best that we can do for all knapsacksizes when only items of type A are taken, then we calculate the best that we
can do when only A™s and B™s are taken, etc. The solution reduces to a simplecalculation for cost [il. Suppose an item j is chosen for the knapsack: then thebest value that could be achieved for the total would be va1b] (for the item)
DYNAMIC PROGRAMMING485plus cost [i-sizeb]] (to fill up the rest of the knapsack). If this value exceedsthe best value that can be achieved without an item j, then we update cost [i]and best[i]; otherwise we leave them alone. A simple induction proof showsthat this strategy solves the problem.The following table traces the computation for our example. The firstpair of lines shows the best that can be done (the contents of the cost andbest arrays) with only A™s, the second pair of lines shows the best that can bedone with only A™s and B™s, etc.:1234567891011121314151617004448881212 12 16 16 16 202020AAAAAAAAAAAAAAA0045589101213 14 16 17 18 20 21 22ABBABBABBABBABB00455810101214 15 16 18 20 20 22 24ABBACBACCACCACC00455810111214 15 16 18 20 21 22 24ABBACDACCACCDCC00455810111314 15 17 18 20 21 23 24ABBACDECCECCDECThus the highest value that can be achieved with a knapsack of size 17 is 24.In order to compute this result, we also solved many smaller subproblems.For example, the highest value that can be achieved with a knapsack of size16 using only A™s B™s and C™s is 22.The actual contents of the optimal knapsack can be computed with theaid of the best array. By definition, best [M] is included, and the remainingcontents are the same as for the optimal knapsack of size M-size[best [Ml].Therefore, best [M-size [ best [Ml]]is included, and so forth. For our example,best[l7]=C, then we find another type C item at size 10, then a type A itemat size 3.It is obvious from inspection of the code that the running time of thisalgorithm is proportional to NM. Thus, it will be fine if M is not large,but could become unacceptable for large capacities. In particular, a crucialpoint that should not be overlooked is that the method does not work at all ifM and the sizes or values are, for example, real numbers instead of integers.This is more than a minor annoyance: it is a fundamental difficulty. No goodsolution is known for this problem, and we™ll see in Chapter 40 that many
486CHAPTER 37people believe that no good solution exists. To appreciate the difficulty of theproblem, the reader might wish to try solving the case where the values areall 1, the size of the jth item is & and M is N/2.But when capacities, sizes and values are all integers, we have the fun-damental principle that optimal decisions, once made, do not need to bechanged. Once we know the best way to pack knapsacks of any size with thefirst j items, we do not need to reexamine those problems, regardless of whatthe next items are. Any time this general principle can be made to work,dynamic programming is applicable.In this algorithm, only a small amount of information about previousoptimal decisions needs to be saved. Different dynamic programming applica-tions have widely different requirements in this regard: we™ll see other examplesbelow.Matrix Chain ProductSuppose that the six matricesare to be multiplied together. Of course, for the multiplications to be valid,the number of columns in one matrix must be the same as the number of rowsin the next. But the total number of scalar multiplications involved dependson the order in which the matrices are multiplied. For example, we couldproceed from left to right: multiplying A by B, we get a 4-by-3 matrix afterusing 24 scalar multiplications.Multiplying this result by C gives a 4-by-1matrix after 12 more scalar multiplications. Multiplying this result by D givesa 4-by-2 matrix after 8 more scalar multiplications. Continuing in this way,
we get a 4-by-3 result after a grand total of 84 scalar multiplications. But if
we proceed from right to left instead, we get the same 4-by-3 result with only
69 scalar multiplications.Many other orders are clearly possible. The order of multiplication can beexpressed by parenthesization: for example the left-Wright order describedabove is the ordering (((((A*B)*C)*D)*E)*F), and the right-to-left order is(A*(B*(C*(D*(E*F))))). Any legal parenthesization will lead to the correct
answer, but which leads to the fewest scalar multiplications?Very substantial savings can be achieved when large matrices are involved:for example, if matrices B, C, and F in the example above were to each havea dimension of 300 where their dimension is 3, then the left-to-right order
will require 6024 scalar multiplications but the right-to-left order will use an
DMVAMlC PROGRAhdMING487astronomical 274,200. (In these calculations we™re assuming that the standardmethod of matrix multiplication is used. Strassen™s or some similar methodcould save some work for large matrices, but the same considerations aboutthe order of multiplications apply.Thus, multiplying a p-by-q matrix bya q-by-r matrix will produce a pby-r matrix, each entry computed with qmultiplications, for a total of pqr multiplications.)In general, suppose that N matrices are to be multiplied together:where the matrices satisfy the constraint that Mi has ri rows and ri+i columnsfor 1 5 i < N. Our task is to find the order of multiplying the matricesthat minimizes the total number of multiplications used. Certainly tryingall possible orderings is impractical. (The number of orderings is a well-studied combinatorial function called the Catalan number: the number ofways to parenthesize N variables is about 4N-‚/Nm.) But it is certainlyworthwhile to expend some effort to find a good solution because N is generallyquite small compared to the number of multiplications to be done.As above, the dynamic programming solution to this problem involvesworking ﬁbottom up,ﬂsaving computed answers to small partial problems toavoid recomputation. First, there™s only one way to multiply Ml by Mz, Mzby MS, . . . , MN-~ by MN; we record those costs. Next, we calculate the bestway to multiply successive triples, using all the information computed so far.For example, to find the best way to multiply MlMzMs, first we find the costof computing MI MZ from the table that we saved and then add the cost ofmultiplying that result by Ms. This total is compared with the cost of firstmultiplying MzM3 then multiplying by Ml, which can be computed in thesame way. The smaller of these is saved, and the same procedure followed forall triples. Next, we calculate the best way to multiply successive groups of
four, using all the information gained so far. By continuing in this way we
eventually find the best way to multiply together all the matrices.In general, for 1 5 j 5 N - 1, we can find the minimum cost of computingMiMi+l* * *Mt+jfor 1 5 i 5 N - j by finding, for each k between i and i + j, the cost ofcomputing MiMi+l*** Mk-1 and MkMk+i.ﬂ Mi+j and then adding the costof multiplying these results together. Since we always break a group into twosmaller groups, the minimum costs for the two groups need only be looked
up in a table, not recomputed. In particular, if we maintain an array with
entries cost [1, r] giving the minimum cost of computing MLML+I**.M,, thenthe cost of the first group above is cost [i, k-l] and the cost of the second
488CHAPTER 37group is cost [k, i+j]. The cost of the final multiplication is easily determined:M,M,+I...Mk-1 is a rz-by-rk matrix, and MkMk+l* * * Mi+j is a rk-by-ri+j+lmatrix, so the cost of multiplying these two is rirkri+j+l. This gives a wayto compute cost[i, i+j] for 1 5 i 5 N-j with j increasing from 1 to N - 1.When we reach j = N - 1 (and i = l), then we™ve found the minimum cost ofcomputing Ml Mze +. MN, as desired. This leads to the following program:for i:=l to N dofor j:=i+l to N do cost [i, j] :=maxint;for i:=l to N do cost[i, i]:=O;for j:=l to N-l dofor i:=l to N-j dofor k:=i+1 to i+j dobegint:=cost[i, k-l]+cost[k, i+j]+r[i]*r[k]*r[i+j+l];if t<cost[i, i+j] thenbegin cost[i,i+j]:=t; best[i, i+j]:=k end;end ;As above, we need to keep track of the decisions made in a separate arraybest for later recovery when the actual sequence of multiplications is to begenerated.The following table is derived in a straightforward way from the cost andbest arrays for the sample problem given above:B C D EA24142226AB AB CD CDB61014BC CD CDC610CD CDD4DEEF36CD22CD19CD10EF12EFFor example, the entry in row A and column F says that 36 scalar multiplica-tions are required to multiply matrices A through F together, and that this can
DYNAMIC PROGR.AMMlNG489be achieved by multiplying A through C in the optimal way, then multiply-ing D through F in the optimal way, then multiplying the resulting matrices
together. (Only D is actually in the best array: the optimal splits are indicatedby pairs of letters in the table for clarity.) To find how to multiply A throughC in the optimal way, we look in row A and column C, etc. The followingprogram implements this process of extracting the optimal parenthesizationfrom the cost and best arrays computed by the program above:procedure order(i, j: integer);beginif i=j then write(name(i)) elsebeginwrite( ‚( ‚);order(i, best [i, j]-1);write(‚*‚); order(best[i, j], j);write( ‚) ‚)endend ;For our example, the parenthesization computed is ((A*(B*C))*((D*E)*F))which, as mentioned above, requires only 36 scalar multiplications. For the
example cited earlier with the dimensions cf 3 in B, C and F changed to 300,the same parenthesization is optimal, requiring 2412 scalar multiplications.The triple loop in the dynamic programming code leads to a running timeproportional to N3 and the space required is proportional to N2, substantiallymore than we used for the knapsack problem. But this is quite palatablecompared to the alternative of trying all 4N-‚/Na possibilities.Optimal Binary Search TreesIn many applications of searching, it is known that the search keys may occurwith widely varying frequency. For example, a program which checks thespelling of words in English text is likely to look up words like ﬁandﬂ and ﬁtheﬂfar more often than words like ﬁdynamicﬂ and ﬁprogramming.ﬂ Similarly,a Pascal compiler is likely to see keywords like ﬁendﬂ and ﬁdoﬂ far moreoften than ﬁlabelﬂ or ﬁdownto.ﬂ If binary tree searching is used, it is clearlyadvantageous to have the most frequently sought keys near the top of the tree.A dynamic programming algorithm can be used to determine how to arrangethe keys in the tree so that the total cost of searching is minimized.Each node in the following binary search tree on the keys A through G islabeled with an integer which is assumed to be proportional to its frequencyof access:
490CHAPTER 37That is, out of every 18 searches in this tree, we expect 4 to be for A, 2 tobe for B, 1 to be for C, etc. Each of the 4 searches for A requires two nodeaccesses, each of the 2 searches for B requires 3 node accesses, and so forth.
We can compute a measure of the ﬁcostﬂ of the tree by simply multiplyingthe frequency for each node by its distance to the root and summing. This isthe weighted internal path length of the tree. For the example tree above, theweighted internal path length is 4*2 + 2*3 + l*l + 3*3 + 5*4 + 2*2 + 1*3 = 51.We would like to find the binary search tree for the given keys with the givenfrequencies that has the smallest internal path length over all such trees.This problem is similar to the problem of minimizing weighted externalpath length that we saw in studying Huffman encoding, but in Huffmanencoding it was not necessary to maintain the order of the keys: in the binarysearch tree, we must preserve the property that all nodes to the left of theroot have keys which are less, etc. This requirement makes the problem verysimilar to the matrix chain multiplication problem treated above: virtuallythe same program can be used.Specifically, we assume that we are given a set of search keys K1 < Kz <. .. < KN and associated frequencies rc, rl , . . . , TN, where ri is the anticipatedfrequency of reference to key Ki. We want to find the binary search tree thatminimizes the sum, over all keys, of these frequencies times the distance ofthe key from the root (the cost of accessing the associated node).We proceed exactly as for the matrix chain problem: we compute, foreach j increasing from 1 to N - 1, the best way to build a subtree containingK,, J&+1,. .. ,Ki+j for 1 2 i 2 N-j. This computation is done by trying eachnode as the root and using precomputed values to determine the best way todo the subtrees. For each k between i and i + j, we want to find the optimaltree containing K,, Ki+l,. . . ,Ki+j with Kk at the root. This tree is formedby using the optimal tree for K,, Ki+l,. . . ,Kk-r as the left subtree and theoptimal tree for Kk+r, Kk+z,. . . ,K2+3as the right subtree. The internal pathlength of this tree is the sum of the internal path lengths for the two subtrees
DYNMC PROGRAMMING491plus the sum of the frequencies for all the nodes (since each node is one stepfurther from the root in the new tree). This leads to the following program:for i:=l to N dofor j:=i+l to N+l do cost[i, j] :=maxint;for i:=l to Ndo cost[i,i]:=f[i];for i:=l to N+l do cost[i, i-l] :=O;for j:=l to N-l dofor i:=l to N-j dobeginfor k:=i to i+j dobegint:=cost[i,k-l]+cost[k+l,i+j];if t<cost [i, i+j] thenbegin cost[i, i+j] :=t; best[i, i+j] :=k end;end ;t:=O; for k:=i to i+j do t:=t+f[k];cost[i, i+j] :=cost[i, i+j]+t;end ;Note that the sum of all the frequencies would be added to any cost so it is notneeded when looking for the minimum. Also, we must have cost [i, i-l]=0 tocover the possibility that a node could just have one son (there was no analogto this in the matrix chain problem).As before, a short recursive program is required to recover the actual treefrom the best array computed by the program. For the example given above,the optimal tree computed isD3AﬂY;B2C™ES2F73G™which has a weighted internal path length of 41.
492CHAPTER 37As above, this algorithm requires time proportional to N3 since it workswith a matrix of size N2 and spends time proportional to N on each entry.It is actually possible in this case to reduce the time requirement to N2 bytaking advantage of the fact that the optimal position for the root of a treecan™t be too far from the optimal position for the root of a slightly smaller
tree, so that k doesn™t have to range over all the values from i to i + j in theprogram above.Shortest PathsIn some cases, the dynamic programming formulation of a method to solvea problem produces a familiar algorithm. For example, Warshall™s algorithm
(given in Chapter 32) for finding the transitive closure of a directed graph
follows directly from a dynamic programming formulation. To show this,
we™ll consider the more general all-pairs shortest paths problem: given a graphwith vertices { 1,2,. . .,V} determine the shortest distance from each vertexto every other vertex.Since the problem calls for V2 numbers as output, the adjacency matrixrepresentation for the graph is obviously appropriate, as in Chapters 31 and32. Thus we™ll assume our input to be a V-by-V array a of edge weights, witha[i, j] :=w if there is an edge from vertex i to vertex j of weight w. If a[i, j]=a b, i] for all i and j then this could represent an undirected graph, otherwise itrepresents a directed graph. Our task is to find the directed path of minimumweight connecting each pair of vertices. One way to solve this problem is tosimply run the shortest path algorithm of Chapter 31 for each vertex, for atotal running time proportional toV3.An even simpler algorithm with thesame performance can be derived from a dynamic programming approach.The dynamic programming algorithm for this problem follows directlyfrom our description of Warshall™s algorithm in Chapter 32. We compute,1 5 k 5 N, the shortest path from each vertex to each other vertex whichuses only vertices from {1,2,. . ., k}. The shortest path from vertex i to vertexj using only vertices from 1,2, . . ., k is either the shortest path from vertex ito vertex j using only vertices from 1,2,. . . , k - 1 or a path composed of theshortest path from vertex i to vertex k using only vertices from 1,2, . . . , k - 1and the shortest path from vertex k to vertex j using only vertices from1,2,. . ., k - 1. This leads immediately to the following program.
DYNAMlC PROGRAMMlNG493for y:=l to Vdofor x:=1 to Vdoif a[x,y]<>maxint div 2 thenfor j:=l to Vdoif a[x,jl>(a[x,Yl+a[y,jl)then a[x,j]:=a[x,y]+a[y,j];The value maxint div 2 is used as a sentinel in matrix positions correspondingto edges not present in the graph. This eliminates the need to test explicitlyin the inner loop whether there is an edge from x to j or from y to j. A ﬁsmallﬂsentinel value is used so that there will be no overflow.This is virtually the same program that we used to compute the transitiveclosure of a directed graph: logical operations have been replaced by arithmeticoperations. The following table shows the adjacency matrix before and afterthis algorithm is run on directed graph example of Chapter 32, with all edgeweights set to 1:ABCDEFGHIJKLMA011 1B 0Cl0D0 1E10F10G1101H101I10J0111K0L10 1M10ABCDEFGHIJKLMA01232112 33 3B 0Cl2043223444D021E102F210G2312130122 2H342324101233314534352103444J45343520111K0L3423241230 1M45343523410Thus the shortest path from M to B is of length 5, etc. Note that, for thisalgorithm, the weight corresponding to the edge between a vertex and itself
is 0. Except for this, if we consider nonzero entries as 1 bits, we have exactlythe bit matrix produced by the transitive closure algorithm of Chapter 32.From a dynamic programming standpoint, note that the amount of in-formation saved about small subproblems is nearly the same as the amountof information to be output, so little space is wasted.
CHAPTER 37One advantage of this algorithm over the shortest paths algorithm ofChapter 31 is that it works properly even if negative edge weights are allowed,as long as there are no cycles of negative weight in the graph (in which case
the shortest paths connecting nodes on the cycle are not defined). If a cycleof negative weight is present in the graph, then the algorithm can detect thatfact, because in that case a[i, i] will become negative for some i at some pointduring the algorithm.Time and Space RequirementsThe above examples demonstrate that dynamic programming applications canhave quite different time and space requirements depending on the amount ofinformation about small subproblems that must be saved. For the shortestpaths algorithm, no extra space was required; for the knapsack problem,space proportional to the size of the knapsack was needed; and for the other
problems N2 space was needed. For each problem, the time required was afactor of N greater than the space required.The range of possible applicability of dynamic programming is far largerthan covered in the examples. From a dynamic programming point of view,divide-and-conquer recursion could be thought of as a special case in whicha minimal amount of information about small cases must be computed and
stored, and exhaustive search (which we™ll examine in Chapter 39) could be
thought of as a special case in which a maximal amount of information about
small cases must be computed and stored. Dynamic programming is a natural
design technique that appears in many guises to solve problems throughout
this range.
DYNAMIC PROGRAMMING495Exercises1.In the example given for the knapsack problem, the items are sorted bysize. Does the algorithm still work properly if they appear in arbitrary
order?2. Modify the knapsack program to take into account another constraintdefined by an array num [1..N] which contains the number of items ofeach type that are available.3.What would the knapsack program do if one of the values were negative?4.True or false: If a matrix chain involves a l-by-k by k-by-l multiplication,then there is an optimal solution for which that multiplication is last.
Defend your answer.5.Write a program which actually multiplies together N matrices in an op-timal way. Assume that the matrices are stored in a three-dimensional ar-
ray matrices[l..Nmax, 1..Dmax, 1..Dmax], where Dmax is the maximumdimension, with the ith matrix stored in matrices[i, l..r[i], l..r[i+l]].6.Draw the optimal binary search tree for the example in the text, but withall the frequencies increased by 1.7. Write the program omitted from the text for actually constructing theoptimal binary search tree.8.Suppose that we™ve computed the optimum binary search tree for someset of keys and frequencies, and say that one frequency is incremented by
1. Write a program to compute the new optimum tree.9.Why not solve the knapsack problem in the same way as the matrix chainand optimum binary search tree problems, by minimizing, for k from 1to M, the sum of the best value achievable for a knapsack of size k and
the best value achievable for a knapsack of size M-k?10.Extend the program for the shortest paths problem to include a procedurepaths(i, j: integer) that will fill an array path with the shortest path fromi to j. This procedure should take time proportional to the length of thepath each time it is called, using an auxiliary data structure built up bya modified version of the program given in the text.

3 8. Linear ProgrammingMany practical problems involve complicated interactions between anumber of varying quantities. One example of this is the network flowproblem discussed in Chapter 33: the flows in the various pipes in the networkmust obey physical laws over a rather complicated network. Another example
is scheduling various tasks in (say) a manufacturing process in the face of
deadlines, priorities, etc. Very often it is possible to develop a precise math-
ematical formulation which captures the interactions involved and reduces
the problem at hand to a more straightforward mathematical problem. Thisprocess of deriving a set of mathematical equations whose solution implies thesolution of a given practical problem is called mathematical programming. Inthis section, we consider a fundamental variant of mathematical programming,linear programming, and an efficient algorithm for solving linear programs, thesimplex method.Linear programming and the simplex method are of fundamental impor-tance because a wide variety of important problems are amenable to formula-tion as linear programs and efficient solution by the simplex method. Betteralgorithms are known for some specific problems, but few problem-solvingtechniques are as widely applicable as the process of first formulating theproblem as a linear program, then computing the solution using the simplex
method.Research in linear programming has been extensive, and a full under-standing of all the issues involved requires mathematical maturity somewhatbeyond that assumed for this book. On the other hand, some of the basic ideas
are easy to comprehend, and the actual simplex algorithm is not difficult to
implement, as we™ll see below. As with the fast Fourier transform in Chapter
36, our intent is not to provide a full practical implementation, but rather
to learn some of the basic properties of the algorithm and its relationship to
other algorithms that we™ve studied.497
498CHAPTER 38Linear ProgramsMathematical programs involve a set of variables related by a set of mathe-matical equations called constraints and an objective function involving thevariables that are to be maximized subject to the constraints.If all ofthe equations involved are simply linear combinations of the variables, wehave the special case that we™re considering called linear programming. Theﬁprogrammingﬂ necessary to solve any particular problem involves choosingthe variables and setting up the equations so that a solution to the equationscorresponds to a solution to the problem. This is an art that we won™t pursue
in any further detail, except to look at a few examples. (The ﬁprogrammingﬂ
that we™ll be interested in involves writing Pascal programs to find solutionsto the mathematical equations.)The following linear program corresponds to the network flow problemthat we considered in Chapter 33.Maximize XAB + XADsubject to the constraints2~858xCD<2xAD<2XCF-5 4xBC<6XEBI 3xDE<sxEF<sxAB+xEB=xBC,xAD+xCD=xDE,xEF+xEB=xDE,%D+xCF=xBC,~AB,~AC,~BC,~CD,~CF,~DE,~EB,~EF~0.There is one variable in this linear program corresponding to the flow ineach of the pipes. These variables satisfy two types of equations: inequalities,corresponding to capacity constraints on the pipes, and equalities, correspond-ing to flow constraints at every junction.Thus, for example, the inequalityXAB 5 8 says that pipe m has capacity 8, and the equation XAB + XEB = XBCsays that the inflow must equal the outflow at junction B. Note that adding allthe equalities together gives the implicit constraint XAB + XAD = XCF + XEFwhich says that the inflow must equal the outflow for the whole network. Also,of course, all of the flows must be positive.This is clearly a mathematical formulation of the network flow problem: asolution to this particular mathematical problem is a solution to the particular
LINEAR PROGRAMMING499instance of the network flow problem.The point of this example is notthat linear programming will provide a better algorithm for this problem,but rather that linear programming is a quite general technique that can beapplied to a variety of problems. For example, if we were to generalize thenetwork flow problem to include costs as well as capacities, or whatever, the
linear programming formulation would not look much different, even though
the problem might be significantly more difficult to solve directly.Not only are linear programs richly expressive but also there exists analgorithm for solving them (the simplex algorithm) which has proven to bequite efficient for many problems arising in practice. For some problems
(such as network flow) there may be an algorithm specifically oriented to that
problem which can perform better than linear programming/simplex; for other
problems (including various extensions of network flow), no better algorithms
are known. Even if there is a better algorithm, it may be complicated or
difficult to implement, while the procedure of developing a linear program
and solving it with a simplex library routine is often quite straightforward.
This ﬁgeneral-purposeﬂ aspect of the method is quite attractive and has led
to its widespread use. The danger in relying upon it too heavily is that it may
lead to inefficient solutions for some simple problems (for example, many of
those for which we have studied algorithms in this book).Geometric InterpretationLinear programs can be cast in a geometric setting. The following linearprogram is easy to visualize because only two variables are involved.Maximize x1 + 52subject to the constraints-x1 +x2 55,X1 +4X2 5 45,2x1 +x2 i 27,3x1 - 4x2 5 24,X1,X2 2 0.It corresponds to the following diagram:
500CIIAPTER 38Each inequality defines a halfplane in which any solution to the linear programmust lie. For example, xi 2 0 means that any solution must lie to the rightof the 22 axis, and -xi + x2 I 5 means that any solution must lie below andto the right of the line -xi + x2 = 5 (which goes through (0,5) and (5,lO)).Any solution to the linear program must satisfy all of these constraints, so theregion defined by the intersection of all these halfplanes (shaded in the diagramabove) is the set of all possible solutions. To solve the linear program we must
find the point within this region which maximizes the objective function.It is always the case that a region defined by intersecting halfplanes isconvex (we™ve encountered this before, in one of the definitions of the convexhull in Chapter 25). This convex region, called the simplex, forms the basisfor an algorithm to find the solution to the linear program which maximizesthe objective function.A fundamental property of the simplex, which is exploited by the algo-rithm, is that the objective function is maximized at one of the vertices of thesimplex: thus only these points need to be examined, not all the points inside.
To see why this is so for our example, consider the dotted line at the right,which corresponds to the objective function. The objective function can bethought of as defining a line of known slope (in this case -1) and unknownposition. We™re interested in the point at which the line hits the simplex, as it
is moved in from infinity. This point is the solution to the linear program: itsatisfies all the inequalities because it is in the simplex, and it maximizes theobjective function because no points with larger values were encountered. For
LINEAR PROGRAMMINGour example, the line hits the simplex at (9,9) which maximizes the objectivefunction at 18.Other objective functions correspond to lines of other slopes, but alwaysthe maximum will occur at one of the vertices of the simplex. The algorithmthat we™ll examine below is a systematic way of moving from vertex to vertex
in search of the minimum. In two dimensions, there™s not much choice aboutwhat to do, but, as we™ll see, the simplex is a much more complicated objectwhen more variables are involved.From the geometric representation, one can also appreciate why math-ematical programs involving nonlinear functions are so much more difficultto handle. For example, if the objective function is nonlinear, it could be a
curve that could strike the simplex along one of its edges, not at a vertex. If
the inequalities are also nonlinear, quite complicated geometric shapes which
correspond to the simplex could arise.Geometric intuition makes it clear that various anomalous situations canarise. For example, suppose that we add the inequality ~1 2 13 to the linearprogram in the example above. It is quite clear from the diagram above thatin this case the intersection of the half-planes is empty. Such a linear program
is called infeasible: there are no points which satisfy the inequalities, let alone
one which maximizes the objective function. On the other hand the inequality~1 5 13 is redundant: the simplex is entirely contained within its halfplane,so it is not represented in the simplex. Redundant inequalities do not affectthe solution at all, but they need to be dealt with during the search for the
solution.A more serious problem is that the simplex may be an open (unbounded)region, in which case the solution may not be well-defined. This would be thecase for our example if the second and third inequalities were deleted. Even if
the simplex is unbounded the solution may be well-defined for some objective
functions, but an algorithm to find it might have significant difficulty getting
around the unbounded region.It must be emphasized that, though these problems are quite easy tosee when we have two variables and a few inequalities, they are very muchless apparent for a general problem with many variables and inequalities.Indeed, detection of these anomalous situations is a significant part of thecomputational burden of solving linear programs.The same geometric intuition holds for more variables. In 3 dimensionsthe simplex is a convex 3-dimensional solid defined by the intersection ofhalfspaces defined by the planes whose equations are given by changing theinequalities to equalities. For example, if we add the inequalities x3 5 4 andx3 2 0 to the linear program above, the simplex becomes the solid objectdiagramed below:
502CHAPTER 38(8,070) );To make the example more three-dimensional, suppose that we change theobjective function to ~1 + ~2 + 2s.This defines a plane perpendicular to theline zl = x2 = x3. If we move a plane in from infinity along this line, wehit the simplex at the point (9,9,4) which is the solution. (Also shown inthe diagram is a path along the vertices of the simplex from (O,O, 0) to thesolution, for reference in the description of the algorithm below.)In n dimensions, we intersect halfspaces defined by (n - 1)-dimensionalhyperplanes to define the n-dimensional simplex, and bring in an (n - l)-dimensional hyperplane from infinity to intersect the simplex at the solutionpoint. As mentioned above, we risk oversimplification by concentrating onintuitive two- and three-dimensional situations, but proofs of the facts aboveinvolving convexity, intersecting hyperplanes, etc.involve a facility withlinear algebra somewhat beyond the scope of this book. Still, the geometricintuition is valuable, since it can help us to understand the fundamental
characteristics of the basic method that is used in practice to solve higher-dimensional problems.
LINEAR PROGRAMMINGThe Simplex MethodSimplex is the name commonly used to describe a general approach to solvinglinear programs by using pivoting, the same fundamental operation used inGaussian elimination. It turns out that pivoting corresponds in a natural way
to the geometric operation of moving from point to point on the simplex, in
search of the solution. The several algorithms which are commonly used differ
in essential details having to do with the order in which simplex vertices aresearched. That is, the well-known ﬁalgorithmﬂ for solving this problem couldmore precisely be described as a generic method which can be refined in any
of several different ways. We™ve encountered this sort of situation before, for
example Gaussian elimination or the Ford-Fulkerson algorithm.First, as the reader surely has noticed, linear programs can take onmany different forms. For example, the linear program above for the networkflow problem has a mixture of equalities and inequalities, but the geometric
examples above use only inequalities. It is convenient to reduce the number
of possibilities somewhat by insisting that all linear programs be presented in
the same standard form, where all the equations are equalities except for aninequality for each variable stating that it is nonnegative. This may seem likea severe restriction, but actually it is not difficult to convert general linearprograms to this standard form. For example, the following linear program isthe standard form for the three-dimensional example given above:Maximize x1 +x2 + x3subject to the constraints-21+zz+y1=5zl+422+yz=45&+zz+yg=273x1-4x2+y4=24x3 + y5 = 4xl,x2,x3,Yl,Y2,Y3,Y4,Y5 2 0.Each inequality involving more than one variable is converted into an equalityby introducing a new variable. The y™s are called slack variables because theytake up the slack allowed by the inequality. Any inequality involving only onevariable can be converted to the standard nonnegative constraint simply byrenaming the variable. For example, a constraint such as x3 < -1 would behandled by replacing x3 by -1 - xj everywhere that it appears.This formulation makes obvious the parallels between linear programmingand simultaneous equations. We have N equations in M unknown variables,all constrained to be positive.In this case, note that there are N slackvariables, one for each equation (since we started out with all inequalities).
504CHAPTER 38We assume that M > N which implies that there are many solutions tothe equations: the problem is to find the one which maximizes the objectivefunction.For our example, there is a trivial solution to the equations: take z1 =xz = x3 = 0, then assign appropriate values to the slack variables to satisfy theequalities. This works because (0, 0,O) is a point on the simplex. Although thisneed not be the case in general, to explain the simplex method, we™ll restrictattention for now to linear programs where it is known to be the case. Thisis still a quite large class of linear programs: for example, if all the numberson the right-hand side of the inequalities in the standard form of the linear
program are positive and slack variables all have positive coefficients (as in
our example) then there is clearly a solution with all the original variableszero. Later we™ll return to the general case.Given a solution with M-N variables set to 0, it turns out that we canfind another solution with the same property by using a familiar operation,pivoting. This is essentially the same operation used in Gaussian elimination:an element a[p, q] is chosen in the matrix of coefficients defined by the equa-tions, then the pth row is multiplied by an appropriate scalar and added to allother rows to make the qth column all 0 except for the entry in row q, whichis made 1. For example, consider the following matrix, which represents thelinear program given above:-1.00 -1.00 -1.00 0.00 0.00 0.00 0.00 0.00 0.00-1.001.000.00 1.00 0.00 0.00 0.00 0.00 5.001.004.000.00 0.00 1.00 0.00 0.00 0.00 45.002.001.000.00 0.00 0.00 1.00 0.00 0.00 27.003.00 -4.000.00 0.00 0.00 0.00 1.00 0.00 24.000.000.001.00 0.00 0.00 0.00 0.00 1.004.00This (N + 1)-by-(M + 1)matrix contains the coefficients of the linear programin standard form, with the (M + 1)st column containing the numbers on theright-hand sides of the equations (as in Gaussian elimination), and the 0th rowcontaining the coefficients of the objective function, with the sign reversed.The significance of the 0th row is discussed below; for now we™ll treat it justlike all of the other rows.For our example, we™ll carry out all computations to two decimal places.Obviously, issues such as computational accuracy and accumulated error arejust as important here as they are in Gaussian elimination.The variables which correspond to a solution are called the basis variablesand those which are set to 0 to make the solution are called non-basis variables.In the matrix, the columns corresponding to basis variables have exactly one 1with all other values 0, while non-basis variables correspond to columns withmore than one nonzero entry.
LINEAR PROGRAMMTNG505Now, suppose that we wish to pivot this matrix for p = 4 and q = 1. Thatis, an appropriate multiple of the fourth row is added to each of the otherrows to make the first column all 0 except for a 1 in row 4. This produces the
following result:0.00-2.33-1.000.000.000.000.330.008.000.00-0.330.001.000.000.000.330.0013.000.005.330.000.001.000.00-0.330.0037.000.003.670.000.000.001.00-0.670.0011.001.00-1.330.000.000.000.000.330.008.000.000.001.000.000.000.000.001.004.00.This operation removes the 7th column from the basis and adds the 1st columnto the basis. Exactly one basis column is removed because exactly one basis
column has a 1 in row p.By definition, we can get a solution to the linear program by setting all thenon-basis variables to zero, then using the trivial solution given in the basis.In the solution corresponding to the above matrix, both x2 and 2s are zerobecause they are non-basis variables and xi = 8, so the matrix correspondsto the point (8,0,0) on the simplex. (We™re not interested particularly in thevalues of the slack variables.) Note that the upper right hand corner of thematrix (row 0, column M + 1) contains the value of the objective function atthis point. This is by design, as we shall soon see.Now suppose that we perform the pivot operation for p = 3 and q = 2:f0.000.00-1.000.000.000.64-0.090.0015.000.000.000.001.000.000.090.270.0014.000.000.000.000.001.00-1.450.640.0021.000.001.000.000.000.000.27-0.180.003.001.000.000.000.000.000.360.090.0012.00\0.000.001.000.000.000.000.001.004.00This removes column 6 from the basis and adds column 2. By setting non-basisvariables to 0 and solving for basis variables as before, we see that this matrix
corresponds to the point (12,3,0)on the simplex, for which the objectivefunction has the value 15. Note that the value of the objective function isstrictly increasing. Again, this is by design, as we shall soon see.How do we decide which values of p and q to use for pivoting? Thisis where row 0 comes in. For each non-basis variable, row 0 contains theamount by which the objective function would increase if that variable werechanged from 0 to 1, with the sign reversed. (The sign is reversed so that thestandard pivoting operation will maintain row 0, with no changes.) Pivotingusing column q amounts to changing the value of the corresponding variable
506CRAPTER 38from 0 to some positive value, so we can be sure the objective function willincrease if we use any column with a negative entry in row 0.Now, pivoting on any row with a positive entry for that column willincrease the objective function, but we also must make sure that it will resultin a matrix corresponding to a point on the simplex. Here the central concernis that one of the entries in column M + 1 might become negative. This can beforestalled by finding, among the positive elements in column q (not includingrow 0), the one that gives the smallest value when divided into the (M + 1)stelement in the same row. If we take p to be the index of the row containingthis element and pivot, then we can be sure that the objective function willincrease and that none of the entries in column M + 1 will become negative;this is enough to ensure that the resulting matrix corresponds to a point onthe simplex.There are two potential problems with this procedure for finding thepivot row. First, what if there are no positive entries in column q? This isan inconsistent situation: the negative entry in row 0 says that the objectivefunction can be increased, but there is no way to increase it. It turns out thatthis situation arises if and only if the simplex is unbounded, so the algorithmcan terminate and report the problem. A more subtle difficulty arises in thedegenerate case when the (M + 1)st entry in some row (with a positive entryin column q) is 0. Then this row will be chosen, but the objective functionwill increase by 0. This is not a problem in itself: the problem arises whenthere are two such rows. Certain natural policies for choosing between such
rows lead to cycling: an infinite™sequence of pivots which do not increase the
objective function at all. Again, several possibilities are available for avoiding
cycling. One method is to break ties randomly. This makes cycling extremely
unlikely (but not mathematically impossible). Another anti-cycling policy isdescribed below.We have been avoiding difficulties such as cycling in our example to makethe description of the method clear, but it must be emphasized that suchdegenerate cases are quite likely to arise in practice. The generality offered byusing linear programming implies that degenerate cases of the general problemwill arise in the solution of specific problems.In our example, we can pivot again with q = 3 (because of the -1 in row0 and column 3) and p = 5 (because 1 is the only positive value in column 3).This gives the following matrix:0.00 0.00 0.00 0.00 0.000.64 -0.09 1.0019.000.00 0.00 0.00 1.00 0.000.090.27 0.0014.000.00 0.00 0.00 0.00 1.00 -1.450.64 0.0021.000.00 1.00 0.00 0.00 0.000.27 -0.18 0.003.001.00 0.00 0.00 0.00 0.000.360.09 0.0012.000.00 0.00 1.00 0.00 0.000.000.00 1.004.00
LIhJEAR PROGRAMMING507This corresponds to the point (12,3,4) on the simplex, for which the value ofthe objective function is 19.In general, there might be several negative entries in row 0, and severaldifferent strategies for choosing from among them have been suggested. Wehave been proceeding according to one of the most popular methods, called
the greatest increment method: always choose the column with the smallestvalue in row 0 (largest in absolute value). This does not necessarily lead to thelargest increase in the objective function, since scaling according to the row p
chosen has to be done. If this column selection policy is combined with the rowselection policy of using, in case of ties, the row that will result in the columnof lowest index being removed from the basis, then cycling cannot happen.
(This anticycling policy is due to R. G. Bland.) Another possibility for column
selection is to actually calculate the amount by which the objective function
would increase for each column, then use the column which gives the largest
result. This is called the steepest descent method. Yet another interestingpossibility is to choose randomly from among the available columns.Finally, after one more pivot at p = 2 and q = 7, we arrive at the solution:I0.000.000.000.000.140.430.001.0022.000.000.000.001.00-0.430.710.000.005.000.000.000.000.001.57-2.291.000.0033.000.001.000.000.000.29-0.140.000.009.001.000.000.000.00-0.140.570.000.009.00\0.000.001.000.000.000.000.001.004.00This corresponds to the point (9,9,4) on the simplex, which maximizes theobjective function at 22. All the entries in row 0 are nonnegative, so any pivotwill only serve to decrease the objective function.The above example outlines the simplex method for solving linear pro-grams. In summary, if we begin with a matrix of coefficients correspondingto a point on the simplex, we can do a series of pivot steps which move to
adjacent points on the simplex, always increasing the objective function, until
the maximum is reached.There is one fundamental fact which we have not yet noted but is crucialto the correct operation of this procedure: once we reach a point where nosingle pivot can improve the objective function (a ﬁlocalﬂ maximum), thenwe have reached the ﬁglobalﬂ maximum.This is the basis for the simplexalgorithm. As mentioned above, the proof of this (and many other factswhich may seem obvious from the geometric interpretation) in general is quitebeyond the scope of this book. But the simplex algorithm for the generalcase operates in essentially the same manner as for the simple problem tracedabove.
508CHAPTER 38ImplementationThe implementation of the simplex method for the case described aboveis quite straightforward from the description. First, the requisite pivoting
procedure uses code similar to our implementation of Gaussian elimination in
Chapter 5:procedure pivot(p, q: integer);var j, k: integer;beginfor j:=O to N dofor k:=M+l downto 1 doif (j<>p) and (k<>q) then4.i kl:=dL kl-ab, kl*d.L d/ah 41;for j:=O to N do if j<>p then ab, q] :=O;for k:=l to M+l do if k<>q then a[p, k] :=a[p, k]/a[p, q];4-3 41 :=Iend ;This program adds multiples of row p to each row as necessary to make columnq all zero except for a 1 in row q as described above. As in Chapter 5, it isnecessary to take care not to change the value of a[p, q] before we™re doneusing it.In Gaussian elimination, we processed only rows below p in the matrixduring forward elimination and only rows above p during backward substitu-tion using the Gauss-Jordan method. A system of N linear equations in Nunknowns could be solved by calling pivot(i, i) for i ranging from 1 to N thenback down to 1 again.The simplex algorithm, then, consists simply of finding the values of pand q as described above and calling pivot, repeating the process until theoptimum is reached or the simplex is determined to be unbounded:repeatq:=O; repeat q:=q+l until (q=M+l) or (a[O, q]<O);p:=O; repeat p:=p+l until (p=N+l) or (a[p, q]>O);for i:=p+l to N doif a[& q]>O thenif (a[& M+l]/a[i, q])<(a[p, M+l]/a[p, q]) then p:=i;if (q<M+l) and (p<N+l) then pivot(p, q)until (q=M+l) or (p=N+l);
LINEAR PROGRAMMING509If the program terminates with q=M+1 then an optimal solution has beenfound: the value achieved for the objective function will be in a[& M+1] andthe values for the variables can be recovered from the basis. If the programterminates with p=N+l, then an unbounded si:uation has been detected.This program ignores the problem of cycle avoidance. To implementBland™s method, it is necessary to keep track of the column that would leavethe basis, were a pivot to be done using row p. This is easily done by settingoutb[p]:=q after each pivot. Then the loop to calculate p can be modifiedto set p:=i also if equality holds in the ratio test and outb[p]<outb[q].Alternatively, the selection of a random element could be implemented bygenerating a random integer x and replacing each array reference a[p, q](or a[i, q]) by a[(p+x)mod(N+l), q] (or a[(i+x)mod(N+l), q]).This hasthe effect of searching through the column q in the same way as before,but starting at a random point instead of the beginning. The same sort of
technique could be used to choose a random column (with a negative entry in
row 0) to pivot on.The program and example above treat a simple case that illustrates theprinciple behind the simplex algorithm but avoids the substantial complica-tions that can arise in actual applications. The main omission is that the
program requires that the matrix have a feasible basis: a set of rows andcolumns which can be permuted into the identity matrix. The program startswith the assumption that there is a solution with the M - N variables ap-pearing in the objective function set to zero and that the N-by-N submatrixinvolving the slack variables has been ﬁsolvedﬂ to make that submatrix the
identity matrix. This is easy to do for the particular type of linear program
that we stated (with all inequalities on positive variables), but in general weneed to find some point on the simplex. Once we have found one solution, wecan make appropriate transformations (mapping that point to the origin) tobring the matrix into the required form, but at the outset we don™t even know
whether a solution exists. In fact, it has been shown that detecting whether asolution exists is as difficult computationally as finding the optimum solution,given that one exists.Thus it should not be surprising that the technique that is commonly usedto detect the existence of a solution is the simplex algorithm! Specifically, weadd another set of artificial variables ~1, ~2,. . . , sN and add variable si to theith equation. This is done simply by adding N columns to the matrix, filledwith the identity matrix. Now, this gives immediately a feasible basis for thisnew linear program. The trick is to run the above algorithm with the objectivefunction -sl -s2 -. . ‚-SN. If there is a solution to the original linear program,then this objective function can be maximized at 0. If the maximum reachedis not zero, then the original linear program is infeasible. If the maximumis zero, then the normal situation is that ~1, ~2,. . . , sN all become non-basis
510CRAPTER 38variables, so we have computed a feasible basis for the original linear program.In degenerate cases, some of the artificial variables may remain in the basis,so it is necessary to do further pivoting to remove them (without changing
the cost).To summarize, a two-phase process is normally used to solve general linearprograms. First, we solve a linear program involving the artificial s variablesto get a point on the simplex for our original problem. Then, we dispose ofthe s variables and reintroduce our original objective function to proceed fromthis point to the solution.The analysis of the running time of the simplex method is an extremelycomplicated problem, and few results are available. No one knows the ﬁbestﬂpivot selection strategy, because there are no results to tell us how many pivotsteps to expect, for any reasonable class of problems. It is possible to constructartificial examples for which the running time of the simplex could be very
large (an exponential function of the number of variables). However, those
who have used the algorithm in practical settings are unanimous in testifying
to its efficiency in solving actual problems.The simple version of the simplex algorithm that we™ve considered, whilequite useful, is merely part of a general and beautiful mathematical frameworkproviding a complete set of tools which can be used to solve a variety of very
important practical problems.rl-
LINEARPROGRAh4MlNG511Exercises1.2.
3.
4.5.6.7.8.9.10.Draw the simplex defined by the inequalities ~1 2 0, 52 > 0, x3 2 0,x1 + 2x2 < 20, and x1 + 52 +x3 5 10.Give the sequence of matrices produced for the example in the text if thepivot column chosen is the largest q for which a[O, q] is negative.Give the sequence of matrices produced for the example in the text forthe objective function x1 + 5x2 + 2s.Describe what happens if the simplex algorithm is run on a matrix witha column of all 0™s.Does the simplex algorithm use the same number of steps if the rows ofthe input matrix are permuted?Give a linear programming formulation of the example in the previouschapter for the knapsack problem.How many pivot steps are required to solve the linear program ﬁMaximizeXl +... +x~ subject to the constraints xl,.. .,x~ 5 1 and x1 ,..., x~ 20ﬂ ?Construct a linear program consisting of N inequalities on two variablesfor which the simplex algorithm requires at least N/2 pivots.Give a three-dimensional linear programming problem which illustratesthe difference between the greatest increment and steepest descent column
selection methods.Modify the implementation given in the text to actually write out thecoordinates of the optimal solution point.

39. Exhaustive SearchSome problems involve searching through a vast number of potentialsolutions to find an answer, and simply do not seem to be amenable tosolution by efficient algorithms. In this chapter, we™ll examine some charac-teristics of problems of this sort and some techniques which have proven tobe useful for solving them.To begin, we should reorient our thinking somewhat as to exactly whatconstitutes an ﬁefficientﬂ algorithm.For most of the applications that wehave discussed, we have become conditioned to think that an algorithm mustbe linear or run in time proportional to something like NlogN or N3/2 tobe considered efficient. We™ve generally considered quadratic algorithms to bebad and cubic algorithms to be awful. But for the problems that we™ll consider
in this and the next chapter, any computer scientist would be absolutely
delighted to know a cubic algorithm. In fact, even an N5™ algorithm would bepleasing (from a theoretical standpoint) because these problems are believedto require exponential time.Suppose that we have an algorithm that takes time proportional to 2N. Ifwe were to have a computer 1000 times faster than the fastest supercomputeravailable today, then we could perhaps solve a problem for N = 50 in an
hour™s time under the most generous assumptions about the simplicity of the
algorithm. But in two hour™s time we could only do N = 51, and even in
a year™s time we could only get to N = 59. And even if a new computer
were to be developed with a million times the speed, and we were to havea million such computers available, we couldn™t get to N = 100 in a year™stime. Realistically, we have to settle for N on the order of 25 or 30. A ﬁmoreefficientﬂ algorithm in this situation may be one that could solve a problemfor N = 100 with a realistic amount of time and money.The most famous problem of this type is the traveling salesman problem:given a set of N cities, find the shortest route connecting them all, with no513
514CHAPTER 39city visited twice. This problem arises naturally in a number of important ap-plications, so it has been studied quite extensively. We™ll use it as an example
in this chapter to examine some fundamental techniques. Many advanced
methods have been developed for this problem but it is still unthinkable to
solve an instance of the problem for N = 1000.The traveling salesman problem is difficult because there seems to be noway to avoid having to check the length of a very large number of possibletours. To check each and every tour is exhaustive search: first we™ll see howthat is done. Then we™ll see how to modify that procedure to greatly reducethe number of possibilities checked, by trying to discover incorrect decisions
as early as possible in the decision-making process.As mentioned above, to solve a large traveling salesman problem is un-thinkable, even with the very best techniques known. As we™ll see in the nextchapter, the same is true of many other important practical problems. Butwhat can be done when such problems arise in practice? Some sort of answer isexpected (the traveling salesman has to do something): we can™t simply ignore
the existence of the problem or state that it™s too hard to solve. At the end of
this chapter, we™ll see examples of some methods which have been developed
for coping with practical problems which seem to require exhaustive search.
In the next chapter, we™ll examine in some detail the reasons why no efficientalgorithm is likely to be found for many such problems.Exhaustive Search in GraphsIf the traveling salesman is restricted to travel only between certain pairs ofcities (for example, if he is traveling by air), then the problem is directlymodeled by a graph: given a weighted (possibly directed) graph, we want tofind the shortest simple cycle that connects all the nodes.This immediately brings to mind another problem that would seem tobe easier: given an undirected graph, is there any way to connect all thenodes with a simple cycle? That is, starting at some node, can we ﬁvisitﬂ allthe other nodes and return to the original node, visiting every node in thegraph exactly once? This is known as the Hamilton cycle problem. In thenext chapter, we™ll see that it is computationally equivalent to the travelingsalesman problem in a strict technical sense.In Chapters 30-32 we saw a number of methods for systematically visitingall the nodes of a graph. For all of the algorithms in those chapters, it waspossible to arrange the computation so that each node is visited just once, and
this leads to very efficient algorithms. For the Hamilton cycle problem, such
a solution is not apparent: it seems to be necessary to visit each node many
times. For the other problems, we were building a tree: when a ﬁdead endﬂ
was reached in the search, we could start it up again, working on another
EXHAUSTIVE SEARCH515part of the tree. For this problem, the tree must have a particular structure(a cycle): if we discover during the search that the tree being built cannot be
a cycle, we have to go back and rebuild part of it.To illustrate some of the issues involved, we™ll look at the Hamilton cycleproblem and the traveling salesman problem for the example graph fromChapter 31:Depth-first search would visit the nodes in this graph in the order A B C ED F G (assuming an adjacency matrix or sorted adjacency list representation).This is not a simple cycle: to find a Hamilton cycle we have to try another wayto visit the nodes. It turns out the we can systematically try all possibilitieswith a simple modification to the visit procedure, as follows:procedure visit(k: integer);var t: integer;beginnow:=now+l; val[k] :=now;for t:=l to Vdoif a[k, t] thenif val[t]=O then visit(t);now:=now-1; va1[k] :=Oend ;Rather than leaving every node that it touches marked with a nonzeroval entry, this procedure ﬁcleans up after itselfﬂ and leaves now and the valarray exactly as it found them. The only marked nodes are those for whichvisit hasn™t completed, which correspond exactly to a simple path of lengthnow in the graph, from the initial node to the one currently being visited. Tovisit a node, we simply visit all unmarked adjacent nodes (marked ones wouldnot correspond to a simple path). The recursive procedure checks all simple
paths in the graph which start at the initial node.
516CHAPTER 39The following tree shows the order in which paths are checked by theabove procedure for the example graph given above. Each node in the treecorresponds to a call of visit: thus the descendants of each node are adjacentnodes which are unmarked at the time of the call. Each path in the tree from
a node to the root corresponds to a simple path in the graph:Thus, the first path checked is A B C E D F. At this point all vertices adjacentto F are marked (have non-zero val entries), so visit for F unmarks F andreturns. Then visit for D unmarks D and returns. Then visit for E tries Fwhich tries D, corresponding to the path A B C E F D. Note carefully thatin depth-first search F and D remain marked after they are visited, so that Fwould not be visited from E. The ﬁunmarkingﬂ of the nodes makes exhaustivesearch essentially different from depth-first search, and the reader should besure to understand the distinction.As mentioned above, now is the current length of the path being tried,and val[k] is the position of node k on that path. Thus we can make the visitprocedure given above test for the existence of a Hamilton cycle by havingit test whether there is an edge from k to 1 when val[k]=V. In the exampleabove, there is only one Hamilton cycle, which appears twice in the tree,traversed in both directions. The program can be made to solve the travelingsalesman problem by keeping track of the length of the current path in theval array, then keeping track of the minimum of the lengths of the Hamilton
EXhXJSTIVE SEARCH517cycles found.BacktrackingThe time taken by the exhaustive search procedure given above is proportionalto the number of calls to visit, which is the number of nodes in the exhaustivesearch tree. For large graphs, this will clearly be very large. For example, ifthe graph is complete (every node connected to every other node), then there
are V! simple cycles, one corresponding to each arrangement of the nodes.(This case is studied in more detail below.) Next we™ll examine techniques togreatly reduce the number of possibilities tried. All of these techniques involveadding tests to visit to discover that recursive calls should not be made forcertain nodes. This corresponds to pruning the exhaustive search tree: cuttingcertain branches and deleting everything connected to them.One important pruning technique is to remove symmetries. In the aboveexample, this is manifested by the fact that we find each cycle twice, traversedin both directions. In this case, we can ensure that we find each cycle justonce by insisting that three particular nodes appear in a particular order. For
example, if we insist that node C appear after node A but before node B inthe example above, then we don™t have to call visit for node B unless node Cis already on the path. This leads to a drastically smaller tree:This technique is not always applicable: for example, suppose that we™re tryingto find the minimum-cost path (not cycle) connecting all the vertices. In the
above example, A G E F D B C is a path which connects all the vertices, but
CHAPTER 39it is not a cycle. Now the above technique doesn™t apply, since we can™t knowin advance whether a path will lead to a cycle or not.Another important pruning technique is to cut off the search as soon as itis determined that it can™t possibly be successful. For example, suppose thatwe™re trying to find the minimum cost path in the graph above. Once we™ve
found A F D B C E G, which has cost 11, it™s fruitless, for example, to search
anywhere further along the path A G E B, since the cost is already 11. This
can be implemented simply by making no recursive calls in visit if the cost
of the current partial path is greater than the cost of the best full path foundso far. Certainly, we can™t miss the minimum cost path by adhering to sucha policy.The pruning will be more effective if a low-cost path is found early inthe search; one way to make this more likely is to visit the nodes adjacentto the current node in order of increasing cost. In fact, we can do evenbetter: often, we can compute a bound on the cost of all full paths that beginwith a given partial path. For example, suppose that we have the additionalinformation that all edges in the diagram have a weight of at least 1 (this couldbe determined by an initial scan through the edges). Then, for example, weknow that any full path starting with AG must cost at least 11, so we don™thave to search further along that path if we™ve already found a solution whichcosts 11.Each time that we cut off the search at a node, we avoid searching theentire subtree below that node. For very large trees, this is a very substantialsavings. Indeed, the savings is so significant that it is worthwhile to do as muchas possible within visit to avoid making recursive calls. For our example, we
can get a much better bound on the cost of any full path which starts with the
partial path made up of the marked nodes by adding the cost of the minimumspanning tree of the unmarked nodes. (The rest of the path is a spanning treefor the unmarked nodes; its cost will certainly not be lower than the cost ofthe minimum spanning tree of those nodes.) In particular, some paths might
divide the graph in such a way that the unmarked nodes aren™t connected;
clearly we stop the search on such paths also. (This might be implemented by
returning an artificially high cost for the spanning tree.) For example, there
can™t be any simple path that starts with ABE.Drawn below is the search tree that results when all of these rules areapplied to the problem of finding the best Hamilton path in the sample graphthat we™ve been considering:
EXHAUSTIVE SEARCH5196GAgain the tree is drastically smaller. It is important to note that the savingsachieved for this toy problem is only indicative of the situation for largerproblems. A cutoff high in the tree can lead to truly significant savings;missing an obvious cutoff can lead to truly significant waste.The general procedure of solving a problem by systematically generatingall possible solutions as described above is called backtracking. Whenever wehave a situation where partial solutions to a problem can be successively aug-mented in many ways to produce a complete solution, a recursive implemen-tation like the program above may be appropriate. As above, the process
can be described by an exhaustive search tree whose nodes correspond to thepartial solutions. Going down in the tree corresponds to forward progresstowards creating a more complete solution; going up in the tree correspondsto ﬁbacktrackingﬂ to some previously generated partial solution, from whichpoint it might be worthwhile to proceed forwards again. The general techniqueof calculating bounds on partial solutions in order to limit the number of fullsolutions which need to be examined is sometimes called branch-and-bound.For another example, consider the knapsack problem of the previouschapter, where the values are not necessarily restricted to be integers. Forthis problem, the partial solutions are clearly some selection of items for theknapsack, and backtracking corresponds to taking an item out to try someother combination. Pruning the search tree by removing symmetries is quiteeffective for this problem, since the order in which objects are put into theknapsack doesn™t affect the cost.Backtracking and branch-and-bound are quite widely applicable as general
520CHAPTER 39problem-solving techniques. For example, they form the basis for many pro-grams which play games such as chess or checkers. In this case, a partialsolution is some legal positioning of all the pieces on the board, and the de-scendant of a node in the exhaustive search tree is a position that can bethe result of some legal move. Ideally, it would be best if a program couldexhaustively search through all possibilities and choose a move that will lead
to a win no matter what the opponent does, but there are normally far too
many possibilities to do this, so a backtracking search is typically done with
quite sophisticated pruning rules so that only ﬁinterestingﬂ positions are ex-
amined. Exhaustive search techniques are also used for other applications in
artificial intelligence.In the next chapter we™ll see several other problems similar to thosewe™ve been studying that can be attacked using these techniques. Solvinga particular problem involves the development of sophisticated criteria whichcan be used to limit the search. For the traveling salesman problem we™vegiven only a few examples of the many techniques that have been tried,
and equally sophisticated methods have been developed for other important
problems.However sophisticated the criteria, it is generally true that the runningtime of backtracking algorithms remains exponential. Roughly, if each nodein the search tree has cr sons, on the average, and the length of the solutionpath is N, then we expect the number of nodes in the tree to be proportionalto oN. Different backtracking rules correspond to reducing the value of (Y,the number of choices to try at each node. It is worthwhile to expend effortto do this because a reduction in [Y will lead to an increase in the size of theproblem that can be solved. For example, an algorithm which runs in timeproportional to 1.1 Ncan solve a problem perhaps eight times a large as onewhich runs in time proportional to 2N.Digression: Permutation GenerationAn interesting computational puzzle is to write a program that generates allpossible ways of rearranging N distinct items. A simple program for thispermutation generation problem can be derived directly from the exhaustivesearch program above because, as noted above, if it is run on a complete graph,then it must try to visit the vertices of that graph in all possible orders.
EXHAUSTIVE SEARCH521procedure visit(k: integer);var t: integer;beginnow:=now+l; vaI[k] :=now;if now= V then writeperm;for t:=l to Vdoif vaI[t]=O then visit(t);now:=now-I; val[k] :=Oend ;This program is derived from the procedure above by eliminating all referenceto the adjacency matrix (since all edges are present in a complete graph). Theprocedure writeperm simply writes out the entries of the val array. This isdone each time now=V, corresponding to the discovery of a complete pathin the graph. (Actually, the program can be improved somewhat by skippingthe for loop when now=V, since at that point is known that all the val entriesare nonzero.) To print out all permutations of the integers 1 through N, weinvoke this procedure with the call visit(O) with now initialized to -1 and theval array initialized to 0. This corresponds to introducing a dummy node tothe complete graph, and checking all paths in the graph starting with node0. When invoked in this way for N=4, this procedure produces the followingoutput (rearranged here into two columns):1 2 3 41 2 4 3
1 3 2 4
1 4 2 31 3 4 21 4 3 2
2 1 3 42 1 4 33 1 2 44 1 2 33 1 4 24 1 3 22 3 1 42 4 1 33 2 1 44 2 1 33 4 1 24 3 1 22 3 4 12 4 3 13 2 4 14 2 3 13 4 2 14 3 2 1Admittedly, the interpretation of the procedure as generating paths in acomplete graph is barely visible. But a direct examination of the procedurereveals that it generates all N! permutations of the integers 1 to N by
first generating all (N - l)! permutations with the 1 in the first position
522CRAPTER 39(calling itself recursively to place 2 through N), then generating the (N - l)!permutations with the 1 in the second position, etc.Now, it would be unthinkable to use this program even for N = 16,because 16! > 250. Still, it is important to study because it can form the basisfor a backtracking program to solve any problem involving reordering a setof elements.For example, consider the Euclidean traveling salesman problem: givena set of N points in the plane, find the shortest tour that connects themall. Since each ordering of the points corresponds to a legal tour, the above
program can be made to exhaustively search for the solution to this problemsimply by changing it to keep track of the cost of each tour and the minimumof the costs of the full tours, in the same manner as above.Then thesame branch-and-bound technique as above can be applied, as well as variousbacktracking heuristics specific to the Euclidean problem. (For example, it iseasy to prove that the optimal tour cannot cross itself, so the search can be cut
off on all partial paths that cross themselves.) Different search heuristics mightcorrespond to different ways of ordering the permutations. Such techniquescan save an enormous amount of work but always leave an enormous amountof work to be done. It is not at all a simple matter to find an exact solution
to the Euclidean traveling salesman problem, even for N as low as 16.Another reason that permutation generation is of interest is that thereare a number of related procedures for generating other combinatorial objects.In some cases, the number of objects generated are not quite so numerous are
as permutations, and such procedures can be useful for larger N in practice.An example of this is a procedure to generate all ways of choosing a subset ofsize k out of a set of N items. For large N and small k, the number of waysof doing this is roughly proportional toNk.Such a procedure could be usedas the basis for a backtracking program to solve the knapsack problem.Approximation AlgorithmsSince finding the shortest tour seems to require so much computation, it isreasonable to consider whether it might be easier to find a tour that is almost
as short as the shortest. If we™re willing to relax the restriction that we
absolutely must have the shortest possible path, then it turns out that we can
deal with problems much larger than is possible with the techniques above.For example, it™s relatively easy to find a tour which is longer by at most afactor of two than the optimal tour. The method is based on simply finding theminimum spanning tree: this not only, as mentioned above, provides a lower
bound on the length of the tour but also turns out to provide an upper boundon the length of the tour, as follows. Consider the tour produced by visitingthe nodes of the minimum spanning tree using the following procedure: to
EXHAUSTIVE SEARCH523process node x, visit x, then visit each son of x, applying this visiting procedurerecursively and returning to node x after each son has been visited, ending upat node x. This tour traverses every edge in the spanning tree twice, so itscost is twice the cost of the tree. It is not a simple tour, since a node may bevisited many times, but it can be converted to a simple tour simply by deleting
all but the first occurrence of each node. Deleting an occurrence of a node
corresponds to taking a shortcut past that node: certainly it can™t increase
the cost of the tour. Thus, we have a simple tour which has a cost less than
twice that of the minimum spanning tree. For example, the following diagram
shows a minimum spanning tree for our set of sample points (computed as
described in Chapter 31) along with a corresponding simple tour.This tour is clearly not the optimum, because it self-intersects. For a largerandom point set, it seems likely that the tour produced in this way willbe close to the optimum, though no analysis has been done to support thisconclusion.Another approach that has been tried is to develop techniques to im-prove an existing tour in the hope that a short tour can be found by ap-plying such improvements repeatedly. For example, if we have (as above)a Euclidean traveling salesman problem where graph distances are distances
524CHAPTER 39between points in the plane, then a self-intersecting tour can be improved byremoving each intersection as follows. If the line Al3 intersects the line CD,the situation can be diagramed as at left below, without loss of generality.But it follows immediately that a shorter tour can be formed by deleting AB
and CD and adding AD and CB, as diagramed at right:Applying this procedure successively will, given any tour, produce a tour thatis no longer and which is not self-intersecting. For example, the procedureapplied to the tour produced from the minimum spanning tree in the exampleabove gives the shorter tour AGOENLPKFJMBDHICA. In fact, one of the
most effective approaches to producing approximate solutions to the Euclidean
traveling salesman problem, developed by S. Lin, is to generalize the procedure
above to improve tours by switching around three or more edges in an existing
tour. Very good results have been obtained by applying such a procedure
successively, until it no longer leads to an improvement, to an initially randomtour. One might think that it would be better to start with a tour that isalready close to the optimum, but Lin™s studies indicate that this may not bethe case.The various approaches to producing approximate solutions to the travel-ing salesman problem which are described above are only indicative of thetypes of techniques that can be used in order to avoid exhaustive search. Thebrief descriptions above do not do justice to the many ingenious ideas that
have been developed: the formulation and analysis of algorithms of this type
is still a quite active area of research in computer science.One might legitimately question why the traveling salesman problem andthe other problems that we have been alluding to require exhaustive search.Couldn™t there be a clever algorithm that finds the minimal tour as easilyand quickly as we can find the minimum spanning tree? In the next chapterwe™ll see why most computer scientists believe that there is no such algorithmand why approximation algorithms of the type discussed in this section musttherefore be studied.
EXHAUSTAL!? SEARCH525Exercises1.2.3.4.5.6.7.8.9.10.11.Which would you prefer to use, an algorithm that requires N5 steps orone that requires 2N steps?Does the ﬁmazeﬂ graph at the end of Chapter 29 have a Hamilton cycle?Draw the tree describing the operation of the exhaustive search procedurewhen looking for a Hamilton cycle on the sample graph starting at vertex
B instead of vertex A.How long could exhaustive search take to find a Hamilton cycle in a graphwhere all nodes are connected to exactly two other nodes? Answer thesame question for the case where all nodes are connected to exactly threeother nodes.How many calls to visit are made (as a function of V) by the permutationgeneration procedure?Derive a nonrecursive permutation generation procedure from the pro-gram given.Write a program which determines whether or not two given adjacencymatrices represent the same graph, except with different vertex names.Write a program to solve the knapsack problem of Chapter 37 when thesizes can be real numbers.Define another cutoff rule for the Euclidean traveling salesman problem,and show the search tree that it leads to for the first six points of oursample point set.Write a program to count the number of spanning trees of a set of Ngiven points in the plane with no intersecting edges.Solve the Euclidean traveling salesman problem for our sixteen samplepoints.

40. NP-complete ProblemsThe algorithms we™ve studied in this book generally are used to solvepractical problems and therefore consume reasonable amounts of re-sources. The practical utility of most of the algorithms is obvious: for manyproblems we have the luxury of several efficient algorithms to choose from.
Many of the algorithms that we have studied are routinely used to solve actual
practical problems. Unfortunately, as pointed out in the previous chapter,
many problems arise in practice which do not admit such efficient solutions.
What™s worse, for a large class of such problems we can™t even tell whether or
not an efficient solution might exist.This state of affairs has been a source of extreme frustration for pro-grammers and algorithm designers, who can™t find any efficient algorithm fora wide range of practical problems, and for theoreticians, who have been un-able to find any reason why these problems should be difficult. A great dealof research has been done in this area and has led to the development ofmechanisms by which new problems can be classified as being ﬁas difficult asﬂold problems in a particular technical sense. Though much of this work isbeyond the scope of this book, the central ideas are not difficult to learn. Itis certainly useful when faced with a new problem to have some appreciationfor the types of problems for which no one knows any efficient algorithm.Sometimes there is quite a fine line between ﬁeasyﬂ and ﬁhardﬂ problems.For example, we saw an efficient algorithm in Chapter 31 for the followingproblem: ﬁFind the shortest path from vertex z to vertex y in a given weightedgraph.ﬂ But if we ask for the longest path (without cycles) from x to y, wehave a problem for which no one knows a solution substantially better thanchecking all possible paths. The fine line is even more striking when we
consider similar problems that ask for only ﬁyes-noﬂ answers:527
528CHAPTER 40Easy:Is there a path from x to y with weight 5 M?Hard(?):Is there a path from x to y with weight 2 M?Breadth-first search will lead to a solution for the first problem in linear time,but all known algorithms for the second problem could take exponential time.We can be much more precise than ﬁcould take exponential time,ﬂ butthat will not be necessary for the present discussion. Generally, it is usefulto think of an exponential-time algorithm as one which, for some input ofsize N, takes time proportional to 2N(at least). (The substance of theresults that we™re about to discuss is not changed if 2 is replaced by anynumber CI: > 1.) This means, for example, that an exponential-time algorithmcould not be guaranteed to work for all problems of size 100 (say) or greater,because no one could wait for an algorithm to take 2ﬂ™ steps, regardless ofthe speed of the computer. Exponential growth dwarfs technological changes:a supercomputer may be a trillion times faster than an abacus, but neithercan come close to solving a problem that requires 21°0 steps.Deterministic and Nondeterministic Polynomial- Time AlgorithmsThe great disparity in performance between ﬁefficientﬂ algorithms of the typewe™ve been studying and brute-force ﬁexponentialﬂ algorithms that check eachpossibility makes it possible to study the interface between them with a simpleformal model.In this model, the efficiency of an algorithm is a function of the numberof bits used to encode the input, using a ﬁreasonableﬂ encoding scheme. (Theprecise definition of ﬁreasonableﬂ includes all common methods of encodingthings for computers: an example of an unreasonable coding scheme is unary,where M bits are used to represent the number M.Rather, we wouldexpect that the number of bits used to represent the number M should beproportional to log M.) We™re interested merely in identifying algorithmsguaranteed to run in time proportional to some polynomial in the number ofbits of input. Any problem which can be solved by such an algorithm is said
to belong toP:the set of all problems which can be solved by deterministicalgorithms in polynomial time.By deterministic we mean that at any time, whatever the algorithm is doing,there is only one thing that it could do next. This very general notion coversthe way that programs run on actual computers. Note that the polynomialis not specified at all and that this definition certainly covers the standard
algorithms that we™ve studied so far.Sorting belongs to P because (for
NP-COMPLETE PROBLEMS529example)1 insertion sort runs in time proportional to N2: the existence ofN log N sorting algorithms is not relevant to the present discussion. Also, thetime taken by an algorithm obviously depends on the computer used, but itturns out that using a different computer will affect the running time by onlya polynomial factor (again, assuming reasonable limits), so that also is notparticularly relevant to the present discussion.Of course, the theoretical results that we™re discussing are based on acompletely specified model of computation within which the general state-ments that we™re making here can be proved. Our intent is to examine some of
the central ideas, not to develop rigorous definitions and theorem statements.The reader may rest assured that any apparent logical flaws are due to theinformal nature of the description, not the theory itself.One ﬁunreasonableﬂ way to extend the power of a computer is to endow itwith the power of nondeterminism: when an algorithm is faced with a choiceof several options, it has the power to ﬁguessﬂ the right one. For the purposes
of the discussion below, we can think of an algorithm for a nondeterministic
machine as ﬁguessingﬂ the solution to a problem, then verifying that thesolution is correct. In Chapter 20, we saw how nondeterminism can be usefulas a tool for algorithm design; here we use it as a theoretical device to helpclassify problems. We haveNP:the set of all problems which can be solved by nondeterministicalgorithms in polynomial time.Obviously, any problem in P is also in NP. But it seems that there should bemany other problems in NP: to show that a problem is in NP, we need onlyfind a polynomial-time algorithm to check that a given solution (the guessedsolution) is valid.For example, the ﬁyes-noﬂ version of the longest-pathproblem is in NP. Another example of a problem in NP is the satisfiabilityproblem. Given a logical formula of the form(Xl + 23 + %)*(Icl + z2 + x4)*(23 + x4 + %)*(x2 + :3 + x5)where the zz™s represent variables which take on truth values (true or false),ﬁ+ﬂ represents or,ﬁ*ﬂ represents and, and z represents not, the satisfiabilityproblem is to determine whether or not there exists an assignment of truthvalues to the variables that makes the formula true (ﬁsatisfiesﬂ it). We™ll seebelow that this particular problem plays a special role in the theory.Nondeterminism is such a powerful operation that it seems almost ab-surd to consider it seriously. Why bother considering an imaginary tool thatmakes difficult problems seem trivial? The answer is that, powerful as non-determinism may seem, no one has been able to prove that it helps for anyparticular problem! Put another way, no one has been able to find a single
530CHAPTER 40example of a problem which can be proven to be in NP but not in P (or evenprove that one exists): we do not know whether or not P = NP. This is aquite frustrating situation because many important practical problems belongto NP (they could be solved efficiently on a non-deterministic machine) butmay or may not belong to P (we don™t know any efficient algorithms forthem on a deterministic machine). If we could prove that a problem doesn™tbelong to P, then we could abandon the search for an efficient solution toit. In the absence of such a proof, there is the lingering possibility that someefficient algorithm has gone undiscovered.In fact, given the current stateof our knowledge, it could be the case that there is some efficient algorithmfor every problem in NP, which would imply that many efficient algorithmshave gone undiscovered. Virtually no one believes that P = NP, and a con-siderable amount of effort has gone into proving the contrary, but this remainsthe outstanding open research problem in computer science.NP-CompletenessBelow we™ll look at a list of problems that are known to belong to NP butwhich might or might not belong to P. That is, they are easy to solve on anon-deterministic machine, but, despite considerable effort, no one has beenable to find an efficient algorithm on a conventional machine (or prove that
none exists) for any of them.These problems have an additional propertythat provides convincing evidence that P # NP: if any of the problems can besolved in polynomial time on a deterministic machine, then so can all problemsin NP (i.e., P = NP). That is, the collective failure of all the researchersto find efficient algorithms for all of these problems might be viewed as acollective failure to prove that P = NP. Such problems are said to be NP-complete. It turns out that a large number of interesting practical problemshave this characteristic.The primary tool used to prove that problems are NP-complete usesthe idea of polynomial reducibility. We show that any algorithm to solve anew problem in NP can be used to solve some known NP-complete problemby the following process: transform any instance of the known NP-completeproblem to an instance of the new problem, solve the problem using the given
algorithm, then transform the solution back to a solution of the NP-complete
problem. We saw an example of a similar process in Chapter 34, where we
reduced bipartite matching to network flow. By ﬁpolynomiallyﬂ reducible,we mean that the transformations can be done in polynomial time: thus theexistence of a polynomial-time algorithm for the new problem would imply the
existence of a polynomial-time algorithm for the NP-complete problem, and
this would (by definition) imply the existence of polynomial-time algorithmsfor all problems in NP.
NP-COMPLETE PROBLEMS531The concept of reduction provides a useful mechanism for classifyingalgorithms. For example, to prove that a problem in NP is NP-complete,we need only show that some known NP-complete problem is polynomiallyreducible to it: that is, that a polynomial-time algorithm for the new problemcould be used to solve the NP-complete problem, and then could, in turn, beused to solve all problems in NP. For an example of reduction, consider thefollowing two problems:TRAVELING SALESMAN: Given a set of cities, and distances betweenall pairs, find a tour of all the cities of distance less than M.HAMILTON CYCLE: Given a graph, find a simple cycle that includesall the vertices.Suppose that we know the Hamilton cycle problem to be NP-complete andwe wish to determine whether or not the traveling salesman problem is alsoNP-complete. Any algorithm for solving the traveling salesman problemcan be used to solve the Hamilton cycle problem, through the following
reduction: given an instance of the Hamilton cycle problem (a graph) construct
an instance of the traveling salesman problem (a set of cities, with distancesbetween all pairs) as follows: for cities for the traveling salesman use the setof vertices in the graph; for distances between each pair of cities use 1 if thereis an edge between the corresponding vertices in the graph, 2 if there is no
edge. Then have the algorithm for the traveling salesman problem find a tour
of distance less than or equal to N, the number of vertices in the graph. That
tour must correspond precisely to a Hamilton cycle. An efficient algorithm for
the traveling salesman problem would also be an efficient algorithm for the
Hamilton cycle problem. That is, the Hamilton cycle problem reduces to the
traveling salesman problem, so the NP-completeness of the Hamilton cycle
problem implies the NP-completeness of the traveling salesman problem.The reduction of the Hamilton cycle problem to the traveling salesmanproblem is relatively simple because the problems are so similar. Actually,polynomial-time reductions can be quite complicated indeed and can connect
problems which seem to be quite dissimilar. For example, it is possible toreduce t™he satisfiability problem to the Hamilton cycle problem. Withoutgoing into details, we can look at a sketch of the proof. We wish to showthat if we had a polynomial-time solution to the Hamilton cycle problem,then we could get a polynomial-time solution to the satisfiability problem bypolynomial reduction. The proof consists of a detailed method of construc-tion showing how, given an instance of the satisfiability problem (a Booleanformula) to construct (in polynomial time) an instance of the Hamilton cycleproblem (a graph) with the property that knowing whether the graph has aHamilton cycle tells us whether the formula is satisfiable. The graph is builtfrom small components (corresponding to the variables) which can be traversed
532ChXPTER 40by a simple path in only one of two ways (corresponding to the truth or falsityof the variables). These small components are attached together as specified
by the clauses, using more complicated subgraphs which can be traversed by
simple paths corresponding to the truth or falsity of the clauses. It is quite
a large step from this brief description to the full construction: the pointis to illustrate that polynomial reduction can be applied to quite dissimilarproblems.Thus, if we were to have a polynomial-time algorithm for the travelingsalesman problem, then we would have a polynomial-time algorithm for theHamilton cycle problem, which would also give us a polynomial-time algorithm
for the satisfiability problem.Each problem that is proven NP-completeprovides another potential basis for proving yet another future problem NP-complete. The proof might be as simple as the reduction given above from theHamilton cycle problem to the traveling salesman problem, or as complicated
as the transformation sketched above from the satisfiability problem to the
Hamilton cycle problem, or somewhere in between. Literally thousands of
problems have been proven to be NP-complete over the last ten years bytransforming one to another in this way.Cook™s TheoremReduction uses the NP-completeness of one problem to imply the NP-com-pleteness of another. There is one case where it doesn™t apply: how was thefirst problem proven to be NP-complete? This was done by S. A. Cook in1971. Cook gave a direct proof that satisfiability is NP-complete: that ifthere is a polynomial time algorithm for satisfiability, then all problems inNP can be solved in polynomial time.The proof is extremely complicated but the general method can be ex-plained. First, a full mathematical definition of a machine capable of solvingany problem in NP is developed. This is a simple model of a general-purposecomputer known as a Turing machine which can read inputs, perform certainoperations, and write outputs. A Turing machine can perform any computa-tion that any other general purpose computer can, using the same amount oftime (to within a polynomial factor), and it has the additional advantage that
it can be concisely described mathematically. Endowed with the additional
power of nondeterminism, a Turing machine can solve any problem in NP.The next step in the proof is to describe each feature of the machine, includ-ing the way that instructions are executed, in terms of logical formulas such
as appear in the satisfiability problem. In this way a correspondence is estab-lished between every problem in NP (which can be expressed as a program onthe nondeterministic Turing machine) and some instance of satisfiability (thetranslation of that program into a logical formula). Now, the solution to the
satisfiability problem essentially corresponds t,o a simulation of the machine
W-COMPLETE PROBLEMSrunning the given program on the given input, so it produces a solution to aninstance of the given problem. Further details of this proof are well beyond
the scope of this book. Fortunately, only one such proof is really necessary:
it is much easier to use reduction to prove NP-completeness.Some NP- Complete ProblemsAs mentioned above, literally thousands of diverse problems are known to beNP-complete. In this section, we list a few for purposes of illustrating the
wide range of problems that have been studied. Of course, the list beginswith satisfiability and includes traveling salesman and Hamilton cycle, as wellas longest path. The following additional problems are representative:PARTITION: Given a set of integers, can they be divided into two setswhose sum is equal?INTEGER LINEAR PROGRAMMING: Given a linear program, is therea solution in integers?MULTIPROCESSOR SCHEDULING: Given a deadline and a set oftasks of varying length to be performed on two identical processors canthe tasks be arranged so that the deadline is met?VERTEX COVER: Given a graph and an integer N, is there a set ofless than N vertices which touches all the edges?These and many related problems have important natural practical applica-tions, and there has been strong motivation for some time to find good algo-
rithms to solve them. The fact that no good algorithm has been found for any
of these problems is surely strong evidence that P # NP, and most research-ers certainly believe this to be the case. (On the other hand, the fact thatno one has been able to prove that any of these problem do not belong to Pcould be construed to comprise a similar body of circumstantial evidence onthe other side.) Whether or not P = NP, the practical fact is that we have atpresent no algorithms that are guaranteed to solve any of the NP-completeproblems efficiently.As indicated in the previous chapter, several techniques have been devel-oped to cope with this situation, since some sort of solution to these variousproblems must be found in practice. One approach is to change the problemand find an ﬁapproximationﬂ algorithm that finds not the best solution buta solution that is guaranteed to be close to the best. (Unfortunately, this issometimes not sufficient to fend off NP-completeness.) Another approach is
to rely on ﬁaverage-timeﬂ performance and develop an algorithm that finds
the solution in some cases, but doesn™t necessarily work in all cases. That is,while it may not be possible to find an algorithm that is guaranteed to workwell on all instances of a problem, it may well be possible to solve efficientlyvirtually all of the instances that arise in practice. A third approach is to work
534CHAPTER 40with ﬁefficientﬂ exponential algorithms, using the backtracking techniquesdescribed in the previous chapter. Finally, there is quite a large gap betweenpolynomial and exponential time which is not addressed by the theory. Whatabout an algorithm that runs in time proportional to NlﬂsN or ‚2m?All of the application areas that we™ve studied in this book are touchedby NP-completeness: there are NP-complete problems in numerical applica-tions, in sorting and searching, in string processing, in geometry, and in graphprocessing. The most important practical contribution of the theory of NP-completeness is that it provides a mechanism to discover whether a new prob-lem from any of these diverse areas is ﬁeasyﬂ or ﬁhard.ﬂ If one can find anefficient algorithm to solve a new problem, then there is no difficulty. If not,
a proof that the problem is NP-complete at least gives the information that
the development of an efficient algorithm would be a stunning achievement
(and suggests that a different approach should perhaps be tried). The scores
of efficient algorithms that we™ve examined in this book are testimony that wehave learned a great deal about efficient computational methods since Euclid,but the theory of NP-completeness shows that, indeed, we still have a greatdeal to learn.
535Exercises1.2.3.4.5.6.7.8.9.10.Write a program to find the longest simple path from x to y in a givenweighted graph.Could there be an algorithm which solves an NP-complete problem inan average time of N log N, if P # NP? Explain your answer.Give a nondeterministic polynomial-time algorithm for solving the PARTI-TION problem.Is there an immediate polynomial-time reduction from the traveling sales-man problem on graphs to the Euclidean traveling salesman problem, orvice versa?What would be the significance of a program that could solve the travelingsalesman problem in time proportional to l.lN?Is the logical formula given in the text satisfiable?Could one of the ﬁalgorithm machinesﬂ with full parallelism be used tosolve an NP-complete problem in polynomial time, if P # NP? Explainyour answer.How does the problem ﬁcompute the exact value of 2Nﬂ fit into the P-NP classification scheme?Prove that the problem of finding a Hamilton cycle in a directed graph isNP-complete, using the NP-completeness of the Hamilton cycle problemfor undirected graphs.Suppose that two problems are known to be NP-complete. Does thisimply that there is a polynomial-time reduction from one to the other, ifP#NP?
536SOURCES for Advanced TopicsEach of the topics covered in this section is the subject of volumes ofreference material. From our introductory treatment, the reader seeking moreinformation should anticipate engaging in serious study; we™ll only be able toindicate some basic references here.The perfect shuffle machine of Chapter 35 is described in the 1968 paperby Stone, which covers many other applications. One place to look for moreinformation on systolic arrays is the chapter by Kung and Leiserson in Meadand Conway™s book on VLSI. A good reference for applications and implemen-tation of the FFT is the book by Rabiner and Gold. Further information ondynamic programming (and topics from other chapters) may be found in thebook by Hu. Our treatment of linear programming in Chapter 38 is based onthe excellent treatment in the book by Papadimitriou and Steiglitz, where allthe intuitive arguments are backed up by full mathematical proofs. Furtherinformation on exhaustive search techniques may be found in the books byWells and by Reingold, Nievergelt, and Deo. Finally, the reader interestedin more information on NP-completeness may consult the survey article byLewis and Papadimitriou and the book by Garey and Johnson, which has afull description of various types of NP-completeness and a categorized listingof hundreds of NP-complete problems.M. R. Garey and D. S. Johnson, Computers and Intractability: a Guide to theTheory of NP-Completeness, Freeman, San Francisco, CA, 1979.T. C. Hu, Combinatorial Algorithms, Addison-Wesley, Reading, MA, 1982.H. R. Lewis and C. H. Papadimitriou, ﬁThe efficiency of algorithms,ﬂ ScientificAmerican, 238, 1 (1978).C. A. Mead and L. C. Conway, Introduction to VLSI Design, Addison-Wesley,Reading, MA, 1980.C. H. Papadimitriou and K. Steiglitz, Combinatorial Optimization: Algorithmsand Complexity, Prentice-Hall, Englewood Cliffs, NJ, 1982.E. M. Reingold, J. Nievergelt, and N. Deo, Combinatorial Algorithms: Theoryand Practice, Prentice-Hall, Englewood Cliffs, NJ, 1982.L. R. Rabiner and B. Gold, Digital Signal Processing, Prentice-Hall, EnglewoodCliffs, NJ, 1974.H. S. Stone, ﬁParallel processing with the perfect shuffle,ﬂ IEEE Transactionson Computing, C-20, 2 (February, 1971).M. B. Wells, Elements of Combinatorial Computing, Pergaman Press, Oxford,1971.
IndexAbacus, 528.Abstract data structures, 30, 88,128, 136.adapt (integration, adaptivequadrature), 85.Additive congruential generator(randomint), 38-40.add (polynomials representedwith linked lists), 27.add (sparse polynomials), 28.Adjacency lists, 3788381, 3822383, 391-392, 410-411, 435.Adjacency matrix, 3777378, 384,410-411, 425, 435, 493, 515.Adjacency structure; see ad-jacency lists.adjlist (graph input, adjacencylists), 379.adjmatrix (graph input, ad-jacency matrix), 378.Adleman, L., 301, 304.Aho, A. V., 304.Algorithm machines, 4577469.All-nearest-neighbors, 366.All-pairs shortest paths, 4922494.Analysis of algorithms, 12-16, 19.Approximation algorithms, 522-524, 533.Arbitrary numbers, 33.Arithmetic, 23-30.Arrays, 24.Articulation points, 390-392,430.Artificial (slack) variables, 503,509.Attributes, 335.Average case, 12-13.AVL trees, 198.B-trees, 228-231, 237.Backtracking, 517-522.Backward substitution, 60, 62(substitute), 64.Balanced multiway merging,1566161.Balanced trees, 187-199, 237,355.Basis variables, 504.Batcher, K. E., 4633465.Bayer, R., 228.
Bentley, J. L., 370.
Biconnectivity, 390-392, 429.537
538Binary search, 175-177, 176(binarysearch), 336.Binary search trees, 169, 178%185, 204, 210, 336, 343-346,353, 3566359.array representation, 1844185.indirect representation, 184-185, 353.optimal, 489-492.standard representation, 178-179.weighted internal path length,490.Binary trees, 179, 237.Binomial queues, 167.Bipartite graphs, 444-447.Bitonic merge, 463-465.bits, 116, 118, 122, 214, 215, 221,222.Bland, R. G., 507.Bland™s method (for cycleavoidance in simplex), 509.Borodin, A,, 88.Bottom-up parsing, 275-276.
Boyer, R. S., 242, 304.
Boyer-Moore string searching,250-251.Branch-and-bound, 519-520.Breadth-first search, 395, 397-398, 439.Brown, M. R., 167.brutesearch (brute-force stringsearching), 243.b&delete (binary search tree dele-tion), 185, 355.bstinsert (binary search tree in-sertion), 184, 353, 355.b&range (one-dimensional rangesearch), 337, 355.bubblesort, 99.Caesar cipher, 297.Catalan numbers, 487.Chi-square (x2) test (c&square),41-42.Ciphers, 297-300.Caesar, 297.Vernam, 299.Vigenere, 298.product, 300.Ciphertext, 297.Clancy, M., 19.Closest-pair problem, 362-366,368.Closest-point problems, 361-368,370.Closure, 258, 261.Clustering, 207.Comer, D., 237.Compare-exchange, 93, 460-465.Compilers, 247, 269, 276-279,304.Complete binary tree, 130.Complete graphs, 376.Complex numbers, 473-478.Complex roots of unity, 473-477.Computational accuracy, 61, 63,86, 504.Concatenation, 258, 261.Connected components, 375.Connected graph, 375.
Connectivity, 389-405, 454.Conquer-and-divide, 152.Constant running time, 14.
Constraints, 498.Context-free grammars, 270-272.
Contextrsensitive grammars, 272.Convex hull, 321.Convex hull algorithms, 321-333,368, 370.
INDEXdivide-and-conquer, 368.Floyd-Eddy method, 331-332.Graham scan, 326-330, 329(grahamscan), 332.hull selection, 331-332.package wrapping, 323-326,325 (wrap), 332.Convex polygons, 321.Convexity, 321.Conway, L. C., 536.Cook, S. A., 242, 532.
Cook™s theorem (satisfiability isNP-complete), 532-533.Cooper, D., 19.Counting, 455.Cross edges, 423, 430.Cryptanalysis, 295-296.Cryptography, 295-296.Cryptology, 295-302, 304.Cryptosystem, 296.Cryptovariables, 299.Cubic running time, 15.Curve fitting, 67-76.
Cycle, 375, 384.Cycling in the simplex method,506-507, 509.Dags (directed acyclic graphs),426-428.Data fitting, 67-76.Data structures.abstract, 30, 128, 136.adjacency lists, 378-381.adjacency matrix, 377-378.adjacency structure, 378-381array, 24.Btree, 228-231, 237.binary search tree, 178-185.deque, 263-267.539heap, 129-140.indirect binary search tree,184-185.indirect heap, 138-139.linked list, 27-28, 202-203,379.priority queue, 127-140.queue, 264, 395.red-black tree, 192-199.sorted list, 129.stack, 109-110, 264, 394, 428,429.string, 241.top-down 2-3-4 tree, 187-199.unordered list, 129.Database, 226, 237, 335.Decryption, 297, 301.
Deletion in binary search trees,183-184.Deletion in hash tables, 208.Dense graphs, 376, 378, 397-398,411, 413, 415-417.densepfs (priority graph traver-sal), 416, 439-440.Deo, N., 536.Depth-first search, 371, 381-387,391-395, 397-399, 422-423,428-430, 454, 515.Depth-first search forest, 382,384, 394, 422-423.Derivation, 270.Deterministic algorithm, 528.dfs (recursive depth-first search),382-385.Dictionaries, 171.Diffie, W., 301.Digital search trees, 213-216.digitalinsert, 215.digitalsearch, 214.
540Dijkstra™s algorithm (for findingthe shortest path), 415.Dijkstra, E. W., 410, 415, 454.Directed acyclic graphs (dags),426-428.Directed cycle, 428.Directed graphs, 376, 380, 421-430.Directed path, 423.Directory, 233.Discrete mathematics, 19.Disk searching, 225-235.Distribution counting, 99-101,116, 122-123.Divide-and-conquer, 48, 51, 104,152, 175, 362, 474, 477-480,483.Divide-and-conquer recurrence,51, 108, 149, 475, 363.Dot product, 74.Double buffering, 161.Double hashing, 207-210.Double rotation, 198.Down edges, 423.downheap (top-down heaprepair), 134.Drawing lines, 310 (draw), 311.Dual of Voronoi diagram, 367-368.Dummy node; see z.Duplicate keys; see equal keys.Dynamic programming, 483-494,536.Eddy, W. F., 331, 370.Edges, 374.backward, 437.capacities, 435.cross, 423, 430.down, 423.forward, 437.negative weight, 494.up, 423, 430.Edmonds, J., 439-440.eliminate (forward elimination),62.Encryption, 297, 301.eof, 9.Equal keys, 172, 177, 193, 204,214, 227-228, 234.Escape sequence, 286.Euclid™s algorithm (for findingthe gcd), 10-11, 19, 302.Euclidean minimum spanningtree, 417.Euclidean shortest path problem,418.Euclidean traveling salesmanproblem, 522-524.eval (fast Fourier transform), 479.eval (spline evaluation), 72.Even, S., 454.Exception dictionary, 210.Exhaustive graph traversal(visit), 515.Exhaustive search, 513-524, 536.Exponential running time, 15,513, 520, 528, 534.Exponentiation, 46-47, 301.expression (top-down compiler),277.expression (top-down parser),273.Extendible hashing, 231-235,237.External nodes, 180, 230, 289,490.External searching, 225-235.External sorting, 155-165.
INDEXfactor (top-down compiler), 278.factor (top-down parser), 274.Fagin, R., 231, 237.fastfind (union-find with com-pression and balancing), 403,411.Fast Fourier transform, 465, 471-480, 479 (eval), 536.Feasible basis, 509-510.File compression, 283-293.Huffman encoding, 286-293.run-length encoding, 284-286.variable-length encoding, 286-293.Find, 399.find (union-find, quick union),401.findinit (fastfind initialization),403, 411.Finite-state machine.deterministic, 248, 259.nondeterministic, 259-267.Flow, 435.Floyd, R. W., 331.
Ford, L. R., 435.
Forecasting, 161.Forest, 375.Forsythe, G. E., 88.Forward elimination, 59, 60-62,62 (eliminate), 64.Cnode, 188.Fourier transform, 471-480.Fredkin, E., 216.Friedman, J. H., 370.Fringe vertices, 393, 410.Fulkerson, D. R., 435.Garey, M. R., 536.Gauss-Jordan method, 63, 65,508.541Gaussian elimination, 57-65, 60(gauss), 71, 76, 504, 508.gcd (greatest common divisor,Euclid™s algorithm), 11, 12.General regular-expression pat-tern matching, 265 (match),279.Geometric algorithms, 307-370.closest pair, 362-366.convex hull, 321-333, 368.elementary, 307-319.grid method, 339-342.inside polygon test, 316-318.intersection, 349-359.line drawing, 310-311.range searching, 336-347.simple closed path, 313-315.2D-trees, 343-346.Gerrymandering, 307.Gold, B., 536.Gosper, R. W., 242.Graham, R. L., 326, 370.Graham scan, 326-330, 329(grahamscan).Grammars, 270-272.Graph algorithms, 373-454.all-pairs shortest paths, 492-494.biconnectivity, 390-392.bipartite matching, 444-447.
breadth-first search, 395.connected components, 384.cycle testing, 384.depth-first search, 381-387.elementary, 373-387.
exhaustive search for cycles,515-520.maximum tlow in a network,439-440.
542minimum spanning tree, 408-413.priority traversal, 395-397.shortest path, 413-415.
stable marriage, 447-452.strongly connected com-ponents, 428-430.topological sorting, 426-428.transitive closure, 423-426.
union-find, 398-405.Graph input, adjacency lists, 379(adjlist).Graph input, adjacency matrix,378 (adjmatrix).Graph isomorphism, 387.Graph traversal, 393-398.
Graphs, 492-494.adjacency list, 416.adjacency matrix, 416.bipartite, 444-447.complete, 376.connected, 375.
connectivity, 389-405.dense, 376.directed, 376, 421-430, 421&430.directed acyclic, 426-428.representation, 376-381, 416,421, 435.sparse, 376.traversal, 393-398.undirected, 376.
weighted, 376.Greatest common divisor (gcd),9-12.Greatest increment method, 507.Grid method, 339-342, 341g7ngegrid), 342 (gridrange),Guibas, L., 237.Hamilton cycle problem, 514-520, 531-532.Hash functions, 202.Hashing, 201-210, 234.double hashing, 207-210.initialization for open address-ing, 205 (ha&initialize).linear probing, 2055207, 205(hashinsert).open addressing, 205-210.separate chaining, 202-204.Head node, 1744175, 180, 181,199, 203-204, 214, 222, 352-353.Heaps, 89, 129-140, 289-290,397.Heap algorithms, 129-140.change, 135.construct, 136-137.downheap, 134, 136.insert, 132, 135.join, 139-140.pqconstruct, 138.pqdownheap, 139, 289-290.pqinsert, 139, 158, 160.
pqremove, 139, 290.pqreplace, 159, 160.remove, 134, 135.replace, 135.upheap, 132.Heap condition, 130.Heapsort, 135-137, 136(heapsort).Hellman, M. E., 301.Hoare, C. A. R., 103, 167.Hoey, D., 349, 370.Holt, R., 19.Horner™s rule, 45-46.
Hu, T. C., 536.Huffman, D. A., 304.
INDEXHuffman™s algorithm (for filecompression), 239, 286-293,490.Hume, J. P., 19.Hybrid searching, 219.Increment sequence, 98.Indexed sequential access, 226-228.index (convert from name to in-teger), 227, 230, 231, 376.Indirect binary search trees, 184-185.Indirect heaps, 138-139, 159-160,289-290.Infeasible linear program, 501.Inner loop, 13-14, 106, 124.Insertion sort, 95-96, 96(insertion), 112, 123-124.inside (point inside test), 318.insiderect (point inside rectangletest), 338.Integer linear programming, 533.Integration, 79-86.adaptive quadrature, 85-86, 85(adapt).rectangle method, 80-82, 81(intrect), 85.Romberg, 84.Simpson™s method, 83-84, 84(intsimp), 85-86.spline quadrature, 85.symbolic, 79-80.trapezoid method, 82-83, 83(i&trap), 85.Internal nodes, 180, 230, 289,490.Interpolation search, 177-178.Interpolation.polynomial, 68.543spline, 68-72.Intersection, 349-359, 370.Manhattan geometry, 350-356.circles, 359.horizontal and vertical lines,305, 350-356.lines, 356-359.rectangles, 359.two lines, 312-313, 313(intersect).interval, 337.Inverse, 138, 385, 450-451.Jarvis, R. A., 370.Jensen, K., 19.
Johnson, D. S., 536.Kahn, D., 304.Karp, R. M., 243, 439-440.Key generation, 299.Keys.binary representation, 119.cryptology, 297.searching, 171.strings, 254.Knapsack problem, 483-486, 519.Knuth, D. E., 19, 36, 88, 167, 209,237, 242, 304, 454.Knuth-Morris-Pratt string search-ing, 244-249.Kruskal, J. B. Jr., 412, 454.Kruskal™s algorithm (minimumspanning tree), 411-413, 412(kruskal), 417.Kung, H. T., 466.Lagrange™s interpolation formula,47, 472.Leading term, 14, 15.
544Leaf pages, 233.Least-squares data fitting, 73-76.
Lewis, H. R., 536.IgN, 16.Lin, S., 524.Line, 308.Line drawing, 310-311.Line intersection, 312-313, 349%359.one pair, 312-313.initialization (buildytree), 353.Manhattan (scan), 355.Linear congruential generator,35-38, 37 (random).Linear feedback shift registers,38.Linear probing, 205-207, 209.Linear programming, 497-510,536.Linear running time, 14.Linked lists, 25-28.create and add node, 27(listadd).input and construction, 26(readlist).merging, 148 (listmerge).output, 26 (writelist).sequential search, 174 (listin-sert, listsearch), 203, 341,343.sorting, 149-152, 149 (sort),151 (mergesort).InN, 16.Logarithm, 16.Logarithmic running time, 14.
Longest path, 527.
Lookahead, 273.MACSYMA, 88.Malcomb, M. A., 88.Master index, 227.Matching, 443-452, 454.
match (general regular-expres-sion pattern matching), 265.Mathematical algorithms, 23-88.Mathematical programming, 497.
Matrices.addition, 28-29 (matradd).band, 64.chain product, 486-489.inverse, 65.multiplication, 29, 53-54, 487.
multiplication by vector, 466-469.representation, 28-30.sparse, 30, 63.Strassen™s multiplication me-thod, 53-54, 65, 487.transposition, 465.tridiagonal, 64, 71.Maxflow-mincut theorem, 438.Maximum flow, 435-438.
Maximum matching, 443.Mazes, 385-386, 398, 418.McCreight, E., 228.Mead, C. A., 536.Merging, 146-152, 156-164, 363-366.mergesort (non-recursive),150-152, 151 (mergesort),366.mergesort (recursive), 148-149,148 (sort), 363.multiway, 156-162.polyphase, 163.Microprocessors, 458, 469.Minimum cut, 438.
Minimum spanning trees, 408-413, 417, 454, 518, 522-524.
INDEXmischarsearch (Boyer-Moorestring searching), 251.mod, 10-12, 34-40, 301-302.Moler, C. B., 88.Moore, J. S., 242, 304.
Morris, J. H., 242, 304.
Morrison, D. R., 219.
Multidimensional range search-ing, 346-347.Multiplication.large integers, 37 (mult).matrices, 27-28, 51-52.polynomials (divide-and-con-quer), 48-50 (mult).polynomials (fast Fouriertransform), 471-480.Multiprocessor scheduling, 533.Multiway merging, 156-162.Multiway radix searching, 218-219.Munro, I., 88.N log A; running time, 15.name (convert from integer toname), 376, 428, 429.Nearest-neighbor problem, 366.Network flow, 433-441, 445-447,454, 497-499.Networks, 376, 435.Nievergelt, J., 231, 237, 536.Node transformations, 189-191.Non-basis variables, 504.Nondeterminism, 259-267, 529.Nonterminal symbol, 270.NP, 529.
NP-complete problems, 527-534,536.Numerical analysis, 88.Objective function, 498.545Odd-even merge, 459-463.One-dimensional range search(bstrange), 337.One-way branching, 218.Open addressing, 205-210.Operations research, 433, 441.Optimal binary search trees, 489-492.Or, 258, 261.Ordered hashing, 210.P, 528.Package wrapping, 323-326.
Pages, 226-239.Papadimitriou, C. H., 454, 536.Parallel computation, 457-469.Parse tree, 271.Parser generator, 280.Parsing, 269-280, 304.bottom-up, 275-276.recursive descent, 272-275.shift-reduce, 276.top-down, 272-275.Partition, 533.Partitioning, 104-105 (partition),112, 145.Pascal, 9, 19, 271-272.Path compression, 403.Paths in graphs, 374-423.Patricia, 219-223, 254.patriciainsert, 222.patriciasearch, 221.Pattern matching, 241, 257-267,279.Perfect shuffle, 459-465, 468-469, 478-480, 536.Permutation generation, 520-522.Pippenger, N., 231, N., 237.
546Pivoting, 5044510, 508 (pivot).Plaintext, 296.Planarity, 387.
Point, 308.Polygon, 308.convex, 321.simple closed, 313-315.standard representation, 318.test if point inside, 316-318.Voronoi, 367.Polynomials, 45-54.addition, 24-28.evaluation, 45-46, 465, 471-472, 474-475.interpolation, 47-48, 471-472,475-477.multiplication, 24-25, 48-50,471-472, 477-480.representation, 23-28.Polyphase merging, 163.Pop, 109, 439.
pqchange (change priority inpriority queue), 396.pqconstruct (heap construction,indirect), 138, 396, 411.pqdownheap (top-down heaprepair, indirect), 139, 289,290.pqinsert, 139.pqreznove (remove largest itemfrom priority queue), 396,139, 290, 411.Pratt, V. R., 242, 304.Preprocessing, 335.
Prim, R. C., 410, 454.
Prim™s algorithm (minimumspanning tree), 410-411, 413.Print binary search tree(treeprint), 336.Priority graph traversal (priority-first search).breadth-first search, 397, 416.densepfs, 416.
depth-first search, 397, 416.Euclidean shortest path, 418.minimum spanning tree, 409-411, 416.network flow, 439-440.shortest path, 413-416.sparsepfs, 395-397.Priority queues, 127-140, 144,158-161, 167, 395-397.Probe, 205.Projection, 339.
Pruning, 517-522.
Pseudo-angle calculation (theta),316.Public-key cryptosystems, 300-302, 304.Push, 109.Pushdown stack, 109-110, 394.Quadrature; see integration.Queue, 109, 395.Quicksort, 103-113, 118, 124,135, 144, 152, 165, 167, 183,218.Rabin, M. O., 243.Rabin-Karp string searching(rksearch), 252-253.Rabiner, L. R., 536.radixexchange (radix exchangesort), 118.Radix searching, 213-223.digital search trees, 213-216.multiway, 218-219.
Patricia, 219-223.
INDEXtries, 216-218, 291-293,Radix sorting, 115-124, 165, 218.radix exchange, 117-121.straight radix, 121-124.Random integer in a fixed range(randomint), 38, 40.Random number generation, 88,202, 299.Random numbers, 33-42, 112.additive congruential generator,38-40, 42.linear congruential generator,35-38, 42.pseudo-, 33.quasi-, 34.uniform, 34.Range searching.grid method, 339-342, 346./CD trees, 346-347.multidimensional, 346-347.one-dimensional, 336-337.projection, 339.sequential search, 338.2D trees, 343-346.rbtreeinsert (red-black tree inser-tion), 194.readlist (linked list input andconstruction), 26, 148.readln, 9.Records.database 335.searching, 171-172.sorting, 93-94.Records/database, 335.Records/searching, 171.
Recursion, 11-12, 176, 363-366,381-382, 398, 465, 479, 489,491, 515, 517-522.removal, 110-111, 145-146,152, 176, 179-180, 275, 366,12.547two-dimensional, 356, 361,363-367.Red-black trees, 192-199.Reduction, 445, 530-532.Regular expression, 258.Regular-expression patternmatching, 258, 279, 304.Reingold, E. M., 536.remove (delete largest element inheap), 134.Replacement selection, 158-161.replace (replace largest elementin heap), 135.Representation.binary search trees, 178-179,184-185.finite state machines, 247, 262-263.functions, 65.graphs, 376-381.lines, 308.matrices, 28-30.points, 308.polygons, 306, 318.polynomials, 23, 28.trees (father link), 290-202,395-396, 400-404, 411, 415.Rivest, R. L., 167, 301, 304.rksearch (Rabin-Karp stringsearching), 253.Root node, 230, 233.Roots of unity, 473-477.Rotation, 196-197.Run-length encoding, 284-286.RSA public-key cryptosystem,301-302.same (test if two points are on thesame side of a line), 313.Satisfiability, 529, 531-532.
548Scan conversion, 310-311.scan (line intersection, Manhat-tan), 355.Scheduling, 373.Searching, 171-237.binary search, 175-177.binary tree search, 178-185.digital search trees, 213-216.disk searching, 225-235.elementary methods, 171-185.extendible hashing, 231-235.external searching, 225-235.hashing, 201-210.indexed dequential access,226-228.Patricia, 221-222.radix search tries, 216-218.radix searching, 213-223.sequential, 172.sequential list, 174.varying length keys, 223.Sedgewick, R., 167, 237.Selection, 144-146.select (selection, nonrecursive),146.select (selection, recursive), 145.Selection sort, 95 (selection), 144,326.Self-organizing search, 175.Seminumerical algorithms, 88.Sentinel, 106, 173, 273, 309, 329,96, 247, 254, 493.Separate chaining, 202-204, 209.Sequential searching, 172-174,339.Sets, 398-405.Shamir, A., 301, 304.Shamos, M. I., 349, 370.Shellsort (shellsort), 97-99, 329.Shortest path, 413-415, 418, 454,492-494.Simple closed path, 313-315.Simplex method, 497-510.Simultaneous equations, 58, 75,503-504.Single rotation, 196-197.Sink, 435.Slack (artificial) variables, 503.Sort-merge, 156.sort3 (sorting three elements), 93,459-460.Sorting, 91-167.bubble, 99.disk, 162, 165, 155-165.
distribution counting, 99-101.elementary methods, 91-101.
external, 92.Heapsort, 135-137.insertion, 95-96.internal, 92.linear, 123-124.
mergesort (non-recursive),150-152.mergesort (recursive), 148-149.Quicksort, 103-114.radix exchange, 117-121.relationship to convex hull,323.selection, 94-95.shellsort, 97-99.stability, 92-93, 121, 152.straight radix, 121-124.tape, 155-165.three elements (sort3), 93.Source, 435.Spanning trees, 375, 408-413.Sparse graphs, 376, 378, 396,397-398, 411, 413.
INDEXsparsepfs (priority graph traver-sal), 396, 410, 415-417, 439-440.Spline interpolation, 68872, 71(makespline), 72 (eval).Spline quadrature, 85.Splitting, 189-191, 1944199, 228-229.Stable marriage problem, 447-452, 454.Stack, 394, 428, 429.Standard form of linear pro-grams, 503.Standish, T. A., 304.Steepest descent method, 507.Steiglitz, K., 454, 536.Stone, H. S., 536.straightradix (straight radixsort), 121-124.Strassen™s method, 53-54, 65, 88,487.String processing, 241-304.String searching, 241-254.Boyer-Moore, 2499252.brute-force, 243.Knuth-Morris-Pratt, 244-249.mismatched character, 250-251.multiple searches, 254.Rabin-Karp, 252-253.Strings, 241, 283, 284-285.Strong, H. R., 231, 237, 231.Strongly connected components,428-430.substitute (backward substitu-tion), 62.Supercomputer, 458, 513, 528.Symbol tables, 171.
Systolic arrays, 466, 536.549Tail node, 25-28, 174-175, 180,203.Tarjan, R. E., 387, 405, 428, 454.Terminal symbol, 270.term (top-down compiler), 278.term (top-down parser), 273.theta (pseudo-angle calculation),316, 324, 325.Thompson, K., 304.3-node, 188.
Top-down 2-3-4 trees, 187-199.
Top-down compiler (expression,term, factor), 277-278.Top-down parsing, 272-275(expression, term, factor),273-274.Topological sorting, 426-428,430.Transitive closure, 423-426, 493.Traveling salesman problem, 387,513-524, 531-532.Tree vertices, 393.treeinitialize (binary search treeinitialization), 181.treeinsert (binary search tree in-sertion), 181.treeprint (binary search treesorted output), 182, 346, 354.Trees.AVL, 198.balanced, 187-199.binary, 179, 237.
binary search, 1788185.
breadth-first search, 395.depth-first search, 382, 384,394, 422-423.exhaustive search, 516-519.father link representation,290-292, 395-396, 4OOC404,411, 415.
550parse, 271.red-black, 192-199.spanning, 375, 408-413.top-down 2-3-4, 187-199.2-3, 198.
2-3-4, 188.
union-find, 399-404.treesearch (binary tree search),180, 193.Tries, 216-218, 291-293.2D (two-dimensional) trees, 343%346.twoDinsert (insertion into 2Dtrees), 345.twoDrange (range searching with2D trees), 346.2-node, 188.2-3 trees, 198.
2-3-4 tree, 188.Ullman, J. D., 237, 304.Undirected graphs, 376.
Union, 399.Union-find, 454.Union-find algorithms, 398-405.analysis, 405.(fastfind), 403.(find), 401.halving, 404.height balancing, 404.path compression, 403.
quick union, 401.
splitting, 404.weight balancing, 402.Unseen vertices, 393, 410.Up edges, 423, 430.upheap, insert (heap insertion atbottom), 132.van Leeuwan, J., 454.Variable-length encoding, 286-293.Vernam cipher, 299.Vertex cover, 533.
Vertex visit, adjacency lists(visit), 382.Vertex visit, adjacency matrix(visit), 384.Vertices, 374.fringe, 393.tree, 393.unseen, 393.Very large scale integrated cir-cuits, 458.Vigenere cipher, 298.Virtual memory, 165, 234.
Visited vertices, 410.visit.vertex visit for graph search-ing, adjacency lists, 382.vertex visit for graph search-ing, adjacency matrix, 384.graph search to test biconnec-tivity, 392.graph traversal to find strongcomponents, 429.exhaustive graph traversal,515.permutation generation, 521.Von Neumann, J., 457.Von Neumann model of computa-tion, 457.Voronoi diagram, 366-368.Voronoi dual, 417.Warshall, S., 425.Warshall™s algorithm (computingtransitive closure), 425, 492-493.Wegner, P., 88.
INDEX551Weight balancing, 402.Weighted graphs, 376, 380, 407-418.Weighted internal path length,490.Weighted matching, 444.Wells, M. B., 536.Wirth, N., 19.Worst case, 13.wrap (convex hull by packagewrapping), 325.writelist (linked list output), 26,148.writeln, 9.z,25-28,174-175,180-181,194,203,214-215,221-222,341,345,352-353,364-365.
DESIGNSCoverPage 12189169239305
371455BackInsertion sort: Color represents the key value; the ith column (fromright to left) shows result of ith insertion.Relatively prime numbers: A mark is in positions i,j for which thegreatest common divisor of i and j is not 1.Random points: A mark is in position i, j with i and j generated bya linear congruential random number generator.A heap: Horizontal coordinate is position in heap, vertical coordinateis value.A binary search tree laid out in the manner of an H-tree.Huffman™s algorithm before and after: run on the initial part of thetext file for Chapter 22.One intersecting pair among a set of random horizontal and verticallines.Depth first search on a grid graph: each node is adjacent to itsimmediate neighbors; adjacency lists are in random order.Counting to 28: eight cyclic rotations.Random permutation: Color represents the key value; the ith column(from right to left) shows result of exchanging ith item with onehaving a random index greater than i.Heap design inspired by the movie ﬁSorting out Sorting,ﬂ R. Baecker, Uni-versity of Toronto.Pictures printed by Tom Freeman, using programs from the text.
