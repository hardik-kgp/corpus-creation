Chapter 15Member Objects and Static Members297
Member Objects298
Member Initializers300

Constant Member Objects302

Static Data Members304

Accessing Static Data Members306

Enumeration308

Exercises310

Solutions314
Chapter 16Arrays321
Defining Arrays322
Initializing Arrays324

Arrays326

Class Arrays328

Multidimensional Arrays330

Member Arrays332

Exercises334

Solutions338
Chapter 17Arrays and Pointers349
Arrays and Pointers (1)350
Arrays and Pointers (2)352

Pointer Arithmetic354

Arrays as Arguments356

Pointer Versions of Functions358

Read-Only Pointers360

Returning Pointers362

Arrays of Pointers364

Command Line Arguments366

Exercises368

Solutions372
Chapter 18Fundamentals of File Input and Output379
Files380
File Streams382

Creating File Streams384

Open Modes386

Closing Files388

Reading and Writing Blocks390

Object Persistence392

Exercises394

Solutions398
CONTENTSxv
Chapter 19Overloading Operators411
Generals412
Operator Functions (1)414

Operator Functions (2)416

Using Overloaded Operators418

Global Operator Functions420

Friend Functions422

Friend Classes424

Overloading Subscript Operators426

Overloading Shift-Operators for I/O428

Exercises430

Solutions432
Chapter 20Type Conversion for Classes441
Conversion Constructors442
Conversion Functions444

Ambiguities of Type Conversions446

Exercise448

Solution450
Chapter 21Dynamic Memory Allocation453
The Operator new454
The Operator delete456

Dynamic Storage Allocation for Classes458

Dynamic Storage Allocation for Arrays460

Application: Linked Lists462

Representing a Linked List464

Exercises466

Solutions468
Chapter 22Dynamic Members477
Members of Varying Length478
Classes with a Dynamic Member480

Creating and Destroying Objects482

Implementing Methods484

Copy Constructor486

Assignment488

Exercises490

Solutions492
Chapter 23Inheritance499
Concept of Inheritance500
Derived Classes502
xviCONTENTS
Members of Derived Classes504
Member Access506

Redefining Members508

Constructing and Destroying Derived Classes510

Objects of Derived Classes512

Protected Members514

Exercises516

Solutions520
Chapter 24Type Conversion in Class Hierarchies529
Converting to Base Classes530
Type Conversions and Assignments532

Converting References and Pointers534

Explicit Type Conversions536

Exercises538

Solutions540
Chapter 25Polymorphism543
Concept of Polymorphism544
Virtual Methods546

Destroying Dynamically Allocated Objects548

Virtual Method Table550

Dynamic Casts552

Exercises554

Solutions558
Chapter 26Abstract Classes565
Pure Virtual Methods566
Abstract and Concrete Classes568

Pointers and References to Abstract Classes570

Virtual Assignment572

Application: Inhomogeneous Lists574

Implementing an Inhomogeneous List576

Exercises578

Solutions580
Chapter 27Multiple Inheritance587
Multiply-Derived Classes588
Multiple Indirect Base Classes590

Virtual Base Classes592

Constructor Calls594

Initializing Virtual Base Classes596

Exercises598

Solutions602
CONTENTSxvii
Chapter 28Exception Handling607
Traditional Error Handling608
Exception Handling610

Exception Handlers612

Throwing and Catching Exceptions614

Nesting Exception Handling616

Defining Your Own Error Classes618

Standard Exception Classes620

Exercises622

Solutions626
Chapter 29More About Files637
Opening a File for Random Access638
Positioning for Random Access640

File State644

Exception Handling for Files646

Persistence of Polymorphic Objects648

Application: Index Files652

Implementing an Index File654

Exercises656

Solutions660
Chapter 30More About Pointers681
Pointer to Pointers682
Variable Number of Arguments684

Pointers to Functions688

Complex Declarations690

Defining Typenames692

Application: Dynamic Matrices694

Exercises696

Solutions698
Chapter 31Manipulating Bits705
Bitwise Operators706
Bitwise Shift Operators708

Bit Masks710

Using Bit Masks712

Bit-Fields714

Exercises716

Solutions718
Chapter 32Templates721
Function and Class Templates722
Defining Templates724
xviiiCONTENTS
Template Instantiation726
Template Parameters728

Template Arguments730

Specialization732

Default Arguments of Templates734

Explicit Instantiation736

Exercises738

Solutions742
Chapter 33Containers749
Container Types750
Sequences752

Iterators754

Declaring Sequences756

Inserting in Sequences758

Accessing Objects760

Length and Capacity762

Deleting in Sequences764

List Operations766

Associative Containers768

Sets and Multisets770

Maps and Multimaps772

Bitsets774

Exercise778

Solution780
Appendix783
Binary Numbers784

Preprocessor Directives787

Pre-Defined Standard Macros792

Binding C Functions793

Operators Overview795

Operator Precedence Table797

ASCII Code Table798

Screen Control Sequences800

Literature801
Index803
CONTENTSxix
This page intentionally left blank 
1FundamentalsThis chapter describes the fundamental characteristics of the object-
oriented C++ programming language.In addition,you will be introduced

to the steps necessary for creating a fully functional C++ program.The

examples provided will help you retrace these steps and also

demonstrate the basic structure of a C++ program.
chapter
1
2CHAPTER 1FUNDAMENTALS
DEVELOPMENT AND PROPERTIES OF C++
CharacteristicsC++C-universal-efficient

-close to the machine
-portableOOP-data abstraction-data hiding
-inheritance
-polymorphismExtensions-exception handling-templates
DEVELOPMENT AND PROPERTIES OF C++3Historical Perspective
The C++ programming language was created by Bjarne Stroustrup and his team at BellLaboratories (AT&T, USA) to help implement simulation projects in an object-ori-
ented and efficient way. The earliest versions, which were originally referred to as “C
with classes,” date back to 1980. As the name C++ implies, C++ was derived from the C
programming language: ++ is the increment operator in C.As early as 1989 an ANSI Committee (AmericanNationalStandardsInstitute) wasfounded to standardize the C++ programming language. The aim was to have as many
compiler vendors and software developers as possible agree on a unified description of
the language in order to avoid the confusion caused by a variety of dialects.In 1998 the ISO (InternationalOrganization for Standardization) approved a stan-dard for C++ (ISO/IEC 14882).Characteristics of C++C++ is not a purely object-oriented language but a hybrid that contains the functionalityof the C programming language. This means that you have all the features that are avail-
able in C:universally usable modular programsefficient, close to the machine programmingportable programs for various platforms.The large quantities of existing C source code can also be used in C++ programs.C++ supports the concepts of object-oriented programming (or OOP for short),which are:data abstraction,that is, the creation of classes to describe objectsdata encapsulationfor controlled access to object datainheritanceby creating derived classes (including multiple derived classes)polymorphism(Greek for multiform), that is, the implementation of instructionsthat can have varying effects during program execution.Various language elements were added to C++, such as references, templates, and excep-tion handling. Even though these elements of the language are not strictly object-ori-
ented programming features, they are important for efficient program implementation.
4CHAPTER 1FUNDAMENTALS
function1data1data2function2function3object1PropertiesCapacitiesobject2PropertiesCapacitiesOBJECT-ORIENTED PROGRAMMING
Traditional concept
Object-oriented concept
OBJECT-ORIENTED PROGRAMMING5Traditional Procedural Programming
In traditional, procedural programming, data and functions (subroutines, procedures) arekept separate from the data they process. This has a significant effect on the way a pro-
gram handles data:the programmer must ensure that data are initialized with suitable values before
use and that suitable data are passed to a function when it is calledif the data representation is changed, e.g. if a record is extended, the correspon-
ding functions must also be modified.Both of these points can lead to errors and neither support low program maintenancerequirements.ObjectsObject-oriented programming shifts the focus of attention to the objects, that is, to theaspects on which the problem is centered. A program designed to maintain bank
accounts would work with data such as balances, credit limits, transfers, interest calcula-
tions, and so on. An object representing an account in a program will have properties
and capacities that are important for account management.OOP objects combine data (properties) and functions (capacities). A class defines acertain object type by defining both the properties and the capacities of the objects of
that type. Objects communicate by sending each other “messages,” which in turn acti-
vate another object’s capacities.Advantages of OOP
Object-oriented programming offers several major advantages to software development:reduced susceptibility to errors: an object controls access to its own data. Morespecifically, an object can reject erroneous access attemptseasy re-use: objects maintain themselves and can therefore be used as buildingblocks for other programslow maintenance requirement: an object type can modify its own internal datarepresentation without requiring changes to the application.
6CHAPTER 1FUNDAMENTALS
EditorCompilerLinkerExecutablefileSource fileHeader file
StandardlibraryOtherlibraries,object filesObject fileDEVELOPING A C++ PROGRAM
Translating a C++ program

If the source file contains just one syntax error, the compiler will report an error. Additional errormessages may be shown if the compiler attempts to continue despite having found an error. So when
you are troubleshooting a program, be sure to start with the first error shown.DEVELOPING A C++ PROGRAM7NOTE
The following three steps are required to create and translate a C++ program:1.First, a text editor is used to save the C++ program in a text file. In other words,
thesource codeis saved to a source file.In larger projects the programmer will nor-
mally use modularprogramming
. This means that the source code will be stored inseveral source files that are edited and translated separately.2.The source file is put through a 
compilerfor translation. If everything works asplanned, an object file made up of machine codeis created. The object file is alsoreferred to as a module.3.Finally, the 
linkercombines the object file with other modules to form an exe-cutable file. These further modules contain functions from standard libraries orparts of the program that have been compiled previously.It is important to use the correct file extension for the source file’s name.Althoughthe file extension depends on the compiler you use, the most commonly found file exten-
sions are .cppand.cc.Prior to compilation, header files, which are also referred to as include files, can becopied to the source file. Header files are text files containing information needed by var-
ious source files, for example, type definitions or declarations of variables and functions.
Header files can have the file extension .h, but they may not have any file extension.TheC++ standard library contains predefined and standardized functions that areavailable for any compiler.Modern compilers normally offer an integrated software development environment, whichcombines the steps mentioned previously into a single task. A graphical user interface is
available for editing, compiling, linking, and running the application. Moreover, addi-
tional tools, such as a debugger, can be launched.In addition to error messages, the compiler will also issue warnings. A warning doesnot indicate a syntax error but merely draws your attention to a possible error in the pro-
gram’s logic, such as the use of a non-initialized variable.
8CHAPTER 1FUNDAMENTALS
#include <iostream>using namespace std;int main(){cout <<  "Enjoy yourself with C++!"  << endl;
return 0;}A BEGINNER’S C++ PROGRAM
Sample program
Screen output
Enjoy yourself with C++! Structure of function 
main()Function nameWhat the program does(satements)Type of function
End of functionBeginning offunctionFunction blockint main(){}....What the program does(statements)
A BEGINNER’S C++ PROGRAM9A C++ program is made up of objects with their accompanying memberfunctions
andglobal functions, which do not belong to any single particular class. Each function fulfillsits own particular task and can also call other functions. You can create functions your-
self or use ready-made functions from the standard library. You will always need to write
the global function main()yourself since it has a special role to play; in fact it is themain program.The short programming example on the opposite page demonstrates two of the mostimportant elements of a C++ program. The program contains only the function main()and displays a message.The first line begins with the number symbol, #, which indicates that the line isintended for the preprocessor.The preprocessor is just one step in the first translationphase and no object code is created at this time. You can type#include <filename> to have the preprocessor copy the quoted file to this position in the source code. This
allows the program access to all the information contained in the header file. The header
fileiostreamcomprises conventions for input and output streams. The word streamindicates that the information involved will be treated as a flow of data.Predefined names in C++ are to be found in the std(standard) namespace. Theusingdirective allows direct access to the names of the stdnamespace.Program execution begins with the first instruction in function main(), and this iswhy each C++ program must have a main function. The structure of the function is
shown on the opposite page. Apart from the fact that the name cannot be changed, this
function’s structure is not different from that of any other C++ function.In our example the function main()contains two statements. The first statementcout << "Enjoy yourself with C++!" << endl; outputs the text string Enjoy yourself with C++!on the screen. The name cout(console output) designates an object responsible for output.The two less-than symbols, <<, indicate that characters are being “pushed” to the out-put stream. Finally endl(end of line) causes a line feed. The statementreturn 0; terminates the function main()and also the program, returning a value of 0as an exitcode to the calling program. It is standard practice to use the exit code 0to indicate thata program has terminated correctly.Note that statements are followed by a semicolon. By the way, the shortest statementcomprises only a semicolon and does nothing.
10CHAPTER 1FUNDAMENTALS
/******************************************************A program with some functions and comments******************************************************/#include <iostream>using namespace std;void line(), message();             // Prototypes
int main(){cout << "Hello! The program starts in main()."<< endl;line();
message();
line();
cout << "At the end of main()." << endl;return 0;}void line()                       // To draw a line.{cout << "--------------------------------" << endl;}void message()               // To display a message.{cout << "In function message()." << endl;}STRUCTURE OF SIMPLE C++ PROGRAMS
A C++ program with several functions
Screen output
Hello! The program starts in main().-----------------------------------
In function message().
-----------------------------------
At the end of main(). 
STRUCTURE OF SIMPLE C++ PROGRAMS11The example on the opposite page shows the structure of a C++ program containingmultiple functions. In C++, functions do not need to be defined in any fixed order. For
example, you could define the function message()first, followed by the functionline(), and finally the main()function.However, it is more common to start with the main()function as this function con-trols the program flow. In other words, main()calls functions that have yet to bedefined. This is made possible by supplying the compiler with a function prototypethatincludes all the information the compiler needs.This example also introduces comments.Strings enclosed in /* . . . */or start-ing with//are interpreted as comments.EXAMPLES:/* I can coverseveral lines */// I can cover just one lineIn single-line comments the compiler ignores any characters following the //signs upto the end of the line. Comments that cover several lines are useful when troubleshoot-
ing, as you can use them to mask complete sections of your program. Both comment
types can be used to comment out the other type.As to the layoutof source files, the compiler parses each source file sequentially,breaking the contents down into tokens, such as function names and operators. Tokens
can be separated by any number of whitespace characters, that is, by spaces, tabs, or
new line characters. The order of the source code is important but it is not important
to adhere to a specific layout, such as organizing your code in rows and columns. For
examplevoid message(   ){ cout  <<"In function message()."  <<endl;}might be difficult to read, but it is a correct definition of the function message().Preprocessor directives are one exception to the layout rule since they always occupy asingle line. The number sign, #, at the beginning of a line can be preceded only by a
space or a tab character.To improve the legibility of your C++ programs you should adopt a consistent style,using indentation and blank lines to reflect the structure of your program. In addition,
make generous use of comments.
exercises
12CHAPTER 1FUNDAMENTALS
#include <iostream>using namespace std;void pause();        // Prototype
int main(){cout << endl << "Dear reader, "<< endl << "have a ";pause();
cout << "!" << endl;return 0;}void pause(){cout << "BREAK";}EXERCISESProgramlisting of exercise 3

EXERCISES13Exercise 1
Write a C++ program that outputs the following text on screen:
Oh whata happy day!
Oh yes,
what a happy day! Use the manipulator endlwhere appropriate.
Exercise2
The following program contains several errors:
*/ Now you should not forget your glasses //
#include <stream>
int main
{cout << "If this text",
cout >> " appears on your display, ";
cout << " endl;"
cout << 'you can pat yourself on '<< " the back!"  << endl.return 0;)Resolve the errors and run the program to test your changes.
Exercise 3
What does the C++ program on the opposite page output on screen?

solutions
14CHAPTER 1FUNDAMENTALS
SOLUTIONSExercise 1
// Let's go !#include <iostream>using namespace std;int main(){cout << " Oh what " << endl;
cout << " a happy day! " << endl;
cout << " Oh yes, " << endl;
cout << " what a happy day! " << endl;return 0;}Exercise 2
The corrected places are underlined.
/*Now you should not forget your glasses */#include <iostream>using namespace std;int main(){cout << " If this text ";cout <<" appears on your display, ";cout << endl;cout << "you can pat yourself on "<< " the back!" << endl;return 0;}Exercise 3
The screen output begins on a new line:
Dear reader,
have a BREAK! 
15Fundamental Types,
Constants,and Variables
This chapter introduces you to the basic types and objects used by C++
programs.
chapter
2
16CHAPTER 2FUNDAMENTAL TYPES, CONSTANTS, AND VARIABLES
* without type void, which will be introduced later.FUNDAMENTAL TYPES
Overview
*boolcharwchar_tshortintlongfloatdoublelong doubleFor integersFor floating-pointvaluesFor boolean valuesFor characters
FUNDAMENTAL TYPES17A program can use several data to solve a given problem, for example, characters, inte-gers, or floating-point numbers. Since a computer uses different methods for processing
and saving data, the data typemust be known. The type defines1.the internal representation of the data, and
2.the amount of memory to allocate.
A number such as -1000can be stored in either 2 or 4 bytes. When accessing thepart of memory in which the number is stored, it is important to read the correct number
of bytes. Moreover, the memory content, that is the bit sequence being read, must be
interpreted correctly as a signed integer.The C++ compiler recognizes the fundamentaltypes,
also referred to as built-in types,shown on the opposite page, on which all other types (vectors, pointers, classes, ...) are
based.The Type 
boolThe result of a comparison or a logical association using AND or OR is a booleanvalue,which can be true or false. C++ uses the booltype to represent boolean values. Anexpression of the type boolcan either be trueorfalse, where the internal value fortruewill be represented as the numerical value 1 and falseby a zero.Thecharandwchar_tTypes
These types are used for saving character codes. A character codeis an integer associatedwith each character. The letter Ais represented by code 65, for example. The charactersetdefines which code represents a certain character. When displaying characters onscreen, the applicable character codes are transmitted and the “receiver,” that is the
screen, is responsible for correctly interpreting the codes.The C++ language does not stipulate any particular characters set, although in gen-eral a character set that contains the ASCII code(AmericanStandardCode for Informa-tionInterchange) is used. This 7-bit code contains definitions for 32 control characters(codes 0 – 31) and 96 printable characters (codes 32 – 127).Thechar(character) type is used to store character codes in one byte (8 bits). Thisamount of storage is sufficient for extended character sets, for example, the ANSI char-
acter set that contains the ASCII codes and additional characters such as German
umlauts.Thewchar_t(wide character type) type comprises at least 2 bytes (16 bits) and isthus capable of storing modern Unicode characters. Unicodeis a 16-bit code also used inWindows NT and containing codes for approximately 35,000 characters in 24 languages.
18CHAPTER 2FUNDAMENTAL TYPES, CONSTANTS, AND VARIABLES
#include <iostream>#include <climits>       // Definition of INT_MIN, ...
using namespace std;int main(){cout << "Range of types int and unsigned int"<< endl << endl;cout << "Type             Minimum           Maximum"<< endl
<< "--------------------------------------------"
<< endl;cout << "int            " <<  INT_MIN << "        "<<  INT_MAX << endl;cout << "unsigned int   " <<  "          0        "<< UINT_MAX << endl;return 0;}FUNDAMENTAL TYPES (CONTINUED)
Integral types
Sample program
TypeSizeRange of Values (decimal)
charunsigned charsigned charshortunsigned shortlongunsigned longintunsigned int1 byte1 byte
1 byte2 byte resp.4  byte
2 byte resp.
4 byte2 byte2 byte4 byte4 byte—128 to +127 or 0 to 255               0 to 255
         —128 to +127          —32768 to +32767 resp.—2147483648 to +2147483647                    0 to 65535 resp.
                    0 to 4294967295—2147483648 to +2147483647                    0 to 4294967295—32768 to +32767          0 to 65535

FUNDAMENTAL TYPES (CONTINUED)19Integral Types
The types short,int,and 
longare available for operations with integers. These typesare distinguished by their ranges of values. The table on the opposite page shows the
integer types, which are also referred to as integral types,with their typical storagerequirements and ranges of values.Theint(integer) type is tailor-made for computers and adapts to the length of a reg-ister on the computer. For 16-bit computers, intis thus equivalent to short, whereasfor 32-bit computers intwill be equivalent to long.C++ treats character codes just like normal integers. This means you can perform cal-culations with variables belonging to the charorwchar_ttypes in exactly the sameway as with inttype variables. charis an integral type with a size of one byte. Therange of values is thus –128 to +127 or from 0 to 255, depending on whether the com-
piler interprets the chartype as signed or unsigned. This can vary in C++.Thewchar_ttype is a further integral type and is normally defined as unsignedshort.ThesignedandunsignedModifiersTheshort,int, and longtypes are normally interpreted as signed with the highest bitrepresenting the sign. However, integral types can be preceded by the keywordunsigned. The amount of memory required remains unaltered but the range of valueschanges due to the highest bit no longer being required as a sign. The keywordunsignedcan be used as an abbreviation for unsigned int.Thechartype is also normally interpreted as signed. Since this is merely a conven-tion and not mandatory, the signedkeyword is available. Thus three types are avail-able:char, signed char,and
unsigned char.The current value ranges are available in the climitsheader file. This file definesconstants such as CHAR_MIN,CHAR_MAX,INT_MIN, and INT_MAX,which represent
the smallest and greatest possible values. The program on the opposite page outputs the
value of these constants for the intandunsigned inttypes.In ANSI C++ the size of integer types is not preset. However, the following order applies:char <= short <= int <= long Moreover, the shorttype comprises at least 2 bytes and the longtype at least 4 bytes.NOTE

20CHAPTER 2FUNDAMENTAL TYPES, CONSTANTS, AND VARIABLES
IEEE format (IEEE = Institute of Electrical and ElectronicEngineers) is normally used to representfloating-point types. The table above makes use of this representation.NOTE
FUNDAMENTAL TYPES (CONTINUED)
Floating-point types
Arithmetic typesArithmetic operators are defined for arithmetic types, i.e. you can perform calculations with variables ofthis type.NOTE
Type
SizeRange ofValues
Lowest PositiveValue
Accuracy(decimal)floatdoublelong double4 bytes8 bytes10 bytes–3.4E+38–1.7E+308–1.1E+49321.2E—382.3E—3083.4E—49326 digits15 digits19 digitsboolchar, signed char, unsigned char, wchar_tshort, unsigned shortint, unsigned int
long, unsigned longfloatdouble
long doubleFloating-point typesIntegral types
FUNDAMENTAL TYPES (CONTINUED)21Floating-Point Types
Numbers with a fraction part are indicated by a decimal point in C++ and are referred toas floating-point numbers. In contrast to integers, floating-point numbers must be stored
to a preset accuracy. The following three types are available for calculations involving
floating-point numbers:floatfor simple accuracydoublefor double accuracylong doublefor high accuracyThe value range and accuracy of a type are derived from the amount of memory allocatedand the internal representation of the type.Accuracyis expressed in decimal places. This means that “six decimal places” allows aprogrammer to store two floating-point numbers that differ within the first six decimal
places as separate numbers. In reverse, there is no guarantee that the figures 12.3456 and
12.34561 will be distinguished when working to a accuracy of six decimal places. And
remember, it is not a question of the position of the decimal point, but merely of the
numerical sequence.If it is important for your program to display floating-point numbers with an accuracysupported by a particular machine, you should refer to the values defined in the cfloatheader file.Readers interested in additional material on this subject should refer to the Appendix,which contains a section on the representation of binary numbers on computers for both
integers and floating-point numbers.ThesizeofOperator
The amount of memory needed to store an object of a certain type can be ascertainedusing the sizeofoperator:sizeof(name)yields the size of an object in bytes, and the parameter nameindicates the object type orthe object itself. For example, sizeof(int)represents a value of 2 or 4 depending onthe machine. In contrast, sizeof(float)will always equal 4.Classification
The fundamental types in C++ are integer types,floating-point types,and the voidtype.The types used for integers and floating-point numbers are collectively referred to as
arithmetic types, as arithmetic operators are defined for them.Thevoidtype is used for expressions that do not represent a value. A function callcan thus take a voidtype.
22CHAPTER 2FUNDAMENTAL TYPES, CONSTANTS, AND VARIABLES
In each line of the above table, the same value is presented in a different way.NOTE
CONSTANTS
Examples for integral constants
Sample program
// To display hexadecimal integer literals and// decimal integer literals.//
#include <iostream>using namespace std;int main(){// cout outputs integers as decimal integers:
cout << "Value of 0xFF = " << 0xFF << " decimal"<< endl;                 // Output: 255 decimal// The manipulator hexchanges output to hexadecimal// format (decchanges to decimal format):cout << "Value of 27 = " << hex << 27 <<" hexadecimal"<< endl;              // Output: 1b hexadecimalreturn 0;}DecimalOctalType
Hexadecimal162553276732768U10000010L27UL214748364802003770777770100000U0303240012L033UL020000000000intintintunsigned intint (32 bit-)long (16 bit-
           CPU)
longunsigned longunsigned long0x10OXff
0x7FFF0x8000U0x186A00xAL0x1bUL0x80000000
CONSTANTS23The boolean keywords trueandfalse, a number, a character, or a character sequence(string) are all constants, which are also referred to as a literals. Constants can thus besubdivided intoboolean constantsnumerical constantscharacter constantsstring constants.Every constant represents a value and thus a type—as does every expression in C++. Thetype is defined by the way the constant is written.Boolean ConstantsA boolean expression can have two values that are identified by the keywords trueandfalse. Both constants are of the booltype. They can be used, for example, to set flagsrepresenting just two states.Integral Constants
Integral numerical constants can be represented as simple decimal numbers, octals, orhexadecimals:adecimal constant(base 10) begins with a decimal number other than zero, suchas 109 or 987650anoctal constant(base 8) begins with a leading 0, for example 077 or 01234567ahexadecimal constant(base 16) begins with the character pair 0x or 0X, forexample 0x2A0 or 0X4b1C. Hexadecimal numbers can be capitalized or non-
capitalized.Integral constants are normally of type int. If the value of the constant is too largefor the inttype, a type capable of representing larger values will be applied. The rankingfor decimal constants is as follows:int, long, unsigned long You can designate the type of a constant by adding the letter Lorl(forlong), or Uoru(forunsigned). For example,12Land12lcorrespond to the type long12Uand12ucorrespond to the type unsigned int12ULand12ulcorrespond to the type unsigned long
24CHAPTER 2FUNDAMENTAL TYPES, CONSTANTS, AND VARIABLES
'H''e''1''1''o''!''\0'
"Hello!"String literal:
Stored byte sequence:
CONSTANTS (CONTINUED)
Examples for floating-point constants
Examples for character constantsInternal representation of a string literal
5.190.519E10.0519e2519.OE-212.12.0.12E+212e00.75.757.5e-175E-20.000040.4e-4.4E-44E-5ConstantCharacterConstant Value
(ASCII code decimal)Capital ALowercase a
Blank
Dot
Digit 0
Terminating null character
6597
32
46
480'A''a'' ''.'
'0''\0'
CONSTANTS (CONTINUED)25Floating-Point Constants
Floating-point numbers are always represented as decimals, a decimal point being used todistinguish the fraction part from the integer part. However, exponential notation is also
permissible.EXAMPLES:27.1     1.8EÐ2     // Type: double Here,1.8EÐ2represents a value of 1.8*10Ð2.Ecan also be written with a small lettere. A decimal point or E(e) must always be used to distinguish floating-point constantsfrom integer constants.Floating-point constants are of type doubleby default. However, you can add Forfto designate the floattype, or add Lorlfor the long doubletype.Character ConstantsA character constant is a character enclosed in singlequotes. Character constants takethe type char.EXAMPLE:'A'// Type: char
The numerical value is the character code representing the character. The constant 'A'thus has a value of 65in ASCII code.String ConstantsYou already know string constants, which were introduced for text output using thecoutstream. A string constant consists of a sequence of characters enclosed in doublequotes.EXAMPLE:"Today is a beautiful day!"A string constant is stored internally without the quotes but terminated with a null char-acter,\0,represented by a byte with a numerical value of 
0— that is, all the bits in thisbyte are set to 0. Thus, a string occupies one byte more in memory than the number ofcharacters it contains. An empty string,"",therefore occupies a single byte.
The terminating null character \0is not the same as the number zero and has a differ-ent character code than zero. Thus, the stringEXAMPLE:"0"comprises two bytes, the first byte containing the code for the character zero 0(ASCIIcode 48) and the second byte the value 0.The terminating null character \0is an example of an escape sequence. Escapesequences are described in the following section.
26CHAPTER 2FUNDAMENTAL TYPES, CONSTANTS, AND VARIABLES
#include <iostream>using namespace std;
int main()
{cout << "\nThis is\t a string\n\t\t"" with \"many\" escape sequences!\n";return 0;}ESCAPE SEQUENCES
Overview
Sample program
Program output:
This is         a stringwith "many" escape sequences! Single characterMeaningASCII code
(decimal)alert (BEL)backspace (BS)horizontal tab (HT)line feed (LF)vertical tab (VT)form feed (FF)carriage return (CR)" (double quote)' (single quote)? (question mark)\ (backslash)string terminating characternumerical value of a character78
910111213
343963
920ooo (octal!)\a\b
\t\n\v
\f\r\"
\'
\?\\\0\ooo(up to 3 octal digits)(hexadecimal digits)hh (hexadecimal!)numerical value of a character\xhh
ESCAPE SEQUENCES27Using Control and Special Characters
Nongraphic characters can be expressed by means of escape sequences, for example \t,which represents a tab.The effect of an escape sequence will depend on the device concerned. The sequence\t, for example, depends on the setting for the tab width, which defaults to eight blanksbut can be any value.An escape sequence always begins with a \(backslash) and represents a single charac-ter. The table on the opposite page shows the standard escape sequences, their decimal
values, and effects.You can use octal and hexadecimal escape sequences to create any character code.Thus, the letter A(decimal 65) in ASCII code can also be expressed as \101(threeoctals) or \x41(two hexadecimals). Traditionally, escape sequences are used only torepresent non-printable characters and special characters. The control sequences for
screen and printer drivers are, for example, initiated by the ESC character (decimal 27),
which can be represented as \33or\x1b.Escape sequences are used in character and string constants.EXAMPLES:'\t'"\tHello\n\tMike!"
The characters ', ", and \have no special significance when preceded by a backslash, i.e.they can be represented as \',\",and 
\\respectively.When using octal numbers for escape sequences in strings, be sure to use three digits,for example, \033and not \33. This helps to avoid any subsequent numbers being eval-uated as part of the escape sequence. There is no maximum number of digits in a hexa-
decimal escape sequence. The sequence of hex numbers automatically terminates with
the first character that is not a valid hex number.The sample program on the opposite page demonstrates the use of escape sequences instrings. The fact that a string can occupy two lines is another new feature. String
constants separated only by white spaces will be concatenated to form a singlestring.To continue a string in the next line you can also use a backslash \as the lastcharacter in a line, and then press the Enter key to begin a new line, where you can
continue typing the string.EXAMPLE:"I am a very, very \long string"Please note, however, that the leading spaces in the second line will be evaluated as partof the string. It is thus generally preferable to use the first method, that is, to terminate
the string with " and reopen it with ".
28CHAPTER 2FUNDAMENTAL TYPES, CONSTANTS, AND VARIABLES
NAMESKeywords in C++
Examples for namesasmauto
bool
break
case
catch
char
class
const
const_cast
continue
default
deletedodouble
dynamic_cast
else
enum
explicit
extern
false
float
for
friend
goto
ifinlineint
long
mutable
namespace
new
operator
private
protected
public
register
reinterpret_cast
returnshortsigned
sizeof
static
static_cast
struct
switch
template
this
throw
true
try
typedeftypeidtypename
union
unsigned
using
virtual
void
volatile
wchar_t
whilevalid:a           US          us      VOID_var        SetTextColor
B12         top_of_window
a_very_long_name123467890invalid:goto   586_cpu    object-orientedUS$    true       ”cu
NAMES29Valid Names
Within a program namesare used to designate variables and functions. The followingrules apply when creating names, which are also known as identifiers:a name contains a series of letters, numbers, or underscore characters ( _ ). Ger-man umlauts and accented letters are invalid. C++ is case sensitive; that is,
upper- and lowercase letters are different.the first character must be a letter or underscorethere are no restrictions on the length of a name and all the characters in the
name are significantC++ keywords are reserved and cannot be used as names.The opposite page shows C++ keywords and some examples of valid and invalid names.The C++ compiler uses internal names that begin with one or two underscores fol-lowed by a capital letter. To avoid confusion with these names, avoid use of the under-
score at the beginning of a name.Under normal circumstances the linker only evaluates a set number of characters, forexample, the first 8 characters of a name. For this reason names of global objects, such as
functions, should be chosen so that the first eight characters are significant.Conventions
In C++ it is standard practice to use small letters for the names of variables and func-tions. The names of some variables tend to be associated with a specific use.EXAMPLES:c, chfor charactersi, j, k, l, m, nfor integers, in particular indicesx, y, zfor floating-point numbersTo improve the readability of your programs you should choose longer and more self-
explanatory names, such as start_indexorstartIndexfor the first index in a rangeof index values.In the case of software projects, naming conventions will normally apply. For exam-ple, prefixes that indicate the type of the variable may be assigned when naming vari-
ables.
30CHAPTER 2FUNDAMENTAL TYPES, CONSTANTS, AND VARIABLES
Both strings and all other values of fundamental types can be output with cout. Integers are printed indecimal format by default.HINTVARIABLES
Sample program
Screen output 
Value of gVar1:  0 Value of gVar2:  2 Character in ch: A 
Value of sum:    8 // Definition and use of variables
#include <iostream>
using namespace std;int gVar1;                 // Global variables,int gVar2 = 2;             // explicit initializationint main(){char ch('A');  // Local variable being initialized// or:  char ch = 'A';cout << "Value of gVar1:    " << gVar1  << endl;cout << "Value of gVar2:    " << gVar2  << endl;
cout << "Character in ch:   " << ch     << endl;int sum, number = 3; // Local variables with// and without initializationsum = number + 5;
cout << "Value of sum:      " << sum  << endl;return 0;}
VARIABLES31Data such as numbers, characters, or even complete records are stored in variablestoenable their processing by a program. Variables are also referred to as objects, particularlyif they belong to a class.Defining Variables
A variable must be defined before you can use it in a program. When you definea vari-able the type is specified and an appropriate amount of memory reserved. This memory
space is addressed by reference to the name of the variable. A simple definition has the
following syntax:SYNTAX:
typ name1 [name2 ... ];This defines the names of the variables in the list name1 [, name2 ...]as variablesof the type type. The parentheses [ ... ]in the syntax description indicate that thispart is optional and can be omitted. Thus, one or more variables can be stated within a
single definition.EXAMPLES:char c;int i, counter;
double x, y, size;In a program, variables can be defined either within the program’s functions or out-side of them. This has the following effect:a variable defined outside of each function is global, i.e. it can be used by all func-tionsa variable defined within a function is local, i.e. it can be used only in that func-tion.Local variables are normally defined immediately after the first brace—for example atthe beginning of a function. However, they can be defined wherever a statement is per-
mitted. This means that variables can be defined immediately before they are used by the
program.Initialization
A variable can be initialized, i.e. a value can be assigned to the variable, during its defini-tion. Initialization is achieved by placing the following immediately after the name of
the variable:an equals sign ( =) and an initial value for the variable orround brackets containing the value of the variable.EXAMPLES:char c = 'a';float x(1.875);Anyglobalvariables not explicitly initialized default to zero. In contrast, the initialvalue for any local variables that you fail to initialize will have an undefined initial value.
32CHAPTER 2FUNDAMENTAL TYPES, CONSTANTS, AND VARIABLES
// Circumference and area of a circle with radius 2.5#include <iostream>using namespace std;const double pi = 3.141593;
int main(){double area, circuit, radius = 1.5;area = pi * radius * radius;circuit = 2 * pi * radius;cout << "\nTo Evaluate a Circle\n" << endl;cout << "Radius:        " << radius    << endl<< "Circumference: " << circuit   << endl
<< "Area:          " << area      << endl;return 0;}By default coutoutputs a floating-point number with a maximum of 6 decimal places without trailingzeros.NOTE
THE KEYWORDS 
constANDvolatileSample program
Screen output
To Evaluate a CircleRadius:         1.5Circumference:  9.42478
Area:           7.06858 
THE KEYWORDS CONST AND VOLATILE 33A type can be modified using the constandvolatilekeywords.Constant ObjectsTheconstkeyword is used to create a “read only” object. As an object of this type isconstant, it cannot be modified at a later stage and must be initialized during its defini-
tion.EXAMPLE:const double pi = 3.1415947;Thus the value of picannot be modified by the program. Even a statement such as thefollowing will merely result in an error message:pi = pi + 2.0;               // invalid Volatile Objects
The keyword volatile, which is rarely used, creates variables that can be modified notonly by the program but also by other programs and external events. Events can be initi-
ated by interrupts or by a hardware clock, for example.EXAMPLE:volatile unsigned long  clock_ticks;Even if the program itself does not modify the variable, the compiler must assume that
the value of the variable has changed since it was last accessed. The compiler therefore
creates machine code to read the value of the variable whenever it is accessed instead of
repeatedly using a value that has been read at a prior stage.It is also possible to combine the keywords constandvolatilewhen declaring avariable.EXAMPLE:volatile const unsigned time_to_live;Based on this declaration, the variable time_to_livecannot be modified by the pro-gram but by external events.
exercises
34CHAPTER 2FUNDAMENTAL TYPES, CONSTANTS, AND VARIABLES
I"RUSH"\TO\AND/FRO/EXERCISESScreen output for exercise 2
For exercise 3
Defining and initializing variables:int a(2.5);const long large;
int b = '?';char c('\'');

char z(500);unsigned char ch = '\201';

int big = 40000;unsigned size(40000);

double he's(1.2E+5);float val = 12345.12345;

EXERCISES35Exercise 1
Thesizeofoperator can be used to determine the number of bytes occupied
in memory by a variable of a certain type.For example,
sizeof(short)isequivalent to 2.Write a C++ program that displays the memory space required by each
fundamental type on screen.
Exercise 2
Write a C++ program to generate the screen output shown on the opposite
page.
Exercise 3
Which of the variable definitions shown on the opposite page is invalid or does

not make sense?
Exercise 4
Write a C++ program that two defines variables for floating-point numbers and

initializes them with the values123.456and76.543Then display the sum and the difference of these two numbers on screen.

solutions
36CHAPTER 2FUNDAMENTAL TYPES, CONSTANTS, AND VARIABLES
SOLUTIONSExercise 1
#include <iostream>using namespace std;int main(){cout << "\nSize of Fundamental Types\n"<< "  Type           Number of Bytes\n"
<< "----------------------------------" << endl;cout << "  char:           " << sizeof(char) << endl;
cout << "  short:          " << sizeof(short)<< endl;
cout << "  int:            " << sizeof(int)  << endl;
cout << "  long:           " << sizeof(long) << endl;
cout << "  float:          " << sizeof(float)<< endl;
cout << "  double:         " << sizeof(double)<<endl;
cout << "  long double:    " << sizeof(long double)<< endl;return 0;}Exercise 2
// Usage of escape sequences#include <iostream>using namespace std;int main(){cout << "\n\n\t I"                 // Instead of tabs"\n\n\t\t \"RUSH\""        // you can send the
"\n\n\t\t\t \\TO\\"        // suited number
"\n\n\t\t AND"             // of blanks to
"\n\n\t /FRO/" << endl;    // the output.return 0;}
SOLUTIONS37Exercise 3
Incorrect:
int a(2.5);               // 2.5 is not an integer valueconst long large;         // Without initialization
char z(500);              // The value 500 is too large// to fit in a byteint big = 40000;          // Attention! On 16-bit systems// int values are <= 32767double he's(1.2E+5);      // The character ' is not// allowed in namesfloat val = 12345.12345;  // The accuracy of float// is only 6 digits Exercise 4
// Defining and initializing variables#include <iostream>using namespace std;int main(){float x = 123.456F,               // or doubley = 76.543F,sum;sum = x + y;
cout << "Total:        "<< x << " + " << y << " = " << sum << endl;cout << "Difference:  "<< x << " Ñ " << y << " = " << (x Ñ y) << endl;return 0;}
This page intentionally left blank 
39Using Functions andClassesThis chapter describes how to
declare and call standard functions anduse standard classes.This includes using standard header files.In addition,we will be working

with string variables,i.e.objects belonging to the standard class 
stringfor the first time.
Functions and classes that you define on your own will not be
introduced until later in the book.chapter
3
40CHAPTER 3USING FUNCTIONS AND CLASSES
DECLARING FUNCTIONSExample of a function prototype
The prototype above yields the following information to the compiler:funcis the function namethe function is called with two arguments: the first argument is of type int, thesecond of type doublethe return value of the function is of type long.Mathematical standard functions
Function nameFunction type= type of return valueTypes of arguments
long func (int, double);double sin (double);double cos (double);
double tan (double);double atan (double);double cosh (double);
double sqrt (double);
double pow (double, double);
double exp (double);
double log (double);
double log10 (double);// Sine// Cosine
// Tangent// Arc tangent// Hyperbolic Cosine
// Square Root
// Power
// Exponential Function
// Natural Logarithm
// Base-ten Logarithm
DECLARING FUNCTIONS41Declarations
Each name (identifier) occurring in a program must be known to the compiler or it willcause an error message. That means any names apart from keywords must be declared, i.e.introduced to the compiler, before they are used.Each time a variable or a function is defined it is also declared. But conversely, notevery declaration needs to be a definition. If you need to use a function that has already
been introduced in a library, you must declare the function but you do not need to rede-
fine it.Declaring FunctionsA function has a name and a type, much like a variable. The function’s type is defined byitsreturn value, that is, the value the function passes back to the program. In addition,the type of arguments required by a function is important. When a function is declared,
the compiler must therefore be provided with information onthe name and type of the function andthe type of each argument.This is also referred to as the function prototype.Examples:int toupper(int);double pow(double, double);This informs the compiler that the function toupper()is of type int, i.e. its returnvalue is of type int, and it expects an argument of type int. The second functionpow()is of type doubleand two arguments of type doublemust be passed to thefunction when it is called. The types of the arguments may be followed by names, how-
ever, the names are viewed as a comment only.Examples:int toupper(int c);double pow(double base, double exponent);From the compiler’s point of view, these prototypes are equivalent to the prototypesin the previous example. Both junctions are standard junctions.Standard function prototypes do not need to be declared, nor should they be, as theyhave already been declared in standard header files. If the header file is included in the
program’s source code by means of the #includedirective, the function can be usedimmediately.Example:#include <cmath>Following this directive, the mathematical standard functions, such as sin(),cos(),andpow(), are available. Additional details on header files can be found later in thischapter.
42CHAPTER 3USING FUNCTIONS AND CLASSES
//  Calculating powers with//  the standard function pow()#include <iostream>    // Declaration of cout#include <cmath>       // Prototype of pow(), thus:// double pow( double, double);using namespace std;int main(){double x = 2.5, y;// By means of a prototype, the compiler generates// the correct call or an error message!// Computes x raised to the power 3:y = pow("x", 3.0);   // Error! String is not a numbery = pow(x + 3.0);    // Error! Just one argument
y = pow(x, 3.0);     // ok!y = pow(x, 3);       // ok! The compiler converts the// int value 3 to double.cout << "2.5 raised to 3 yields:       "<< y << endl;// Calculating with pow() is possible:cout << "2 + (5 raised to the power 2.5) yields: "<<  2.0 + pow(5.0, x) << endl;return 0;}FUNCTION CALLS
Sample program
Screen output
2.5 raised to the power 3 yields:         15.6252 + (5 raised to the power 2.5) yields:   57.9017 
Function CallsAfunction call is an expression of the same type as the function and whose value corre-sponds to the return value. The return value is commonly passed to a suitable variable.Example:y = pow( x, 3.0);In this example the function pow()is first called using the arguments xand3.0,and
the result, the power x3, is assigned to y.As the function call represents a value, other operations are also possible. Thus, thefunctionpow()can be used to perform calculations for doublevalues.Example:cout  <<  2.0 + pow( 5.0, x);This expression first adds the number 2.0to the return value of pow(5.0,x),then
outputs the result using cout.Any expression can be passed to a function as an argument, such as a constant or anarithmetical expression. However, it is important that the types of the arguments corre-
spond to those expected by the function.The compiler refers to the prototype to check that the function has been called cor-rectly. If the argument type does not match exactly to the type defined in the prototype,
the compiler performs type conversion, if possible.Example:y = pow( x, 3);            // also ok!The value 3 of type intis passed to the function as a second argument. But since thefunction expects a doublevalue, the compiler will perform type conversion from inttodouble.If a function is called with the wrong number of arguments, or if type conversionproves impossible, the compiler generates an error message. This allows you to recognize
and correct errors caused by calling functions at the development stage instead of causing
runtime errors.Example:float x = pow(3.0 + 4.7);     // Error!The compiler recognizes that the number of arguments is incorrect. In addition, the
compiler will issue a warning, since a double, i.e. the return value of pow(), is assignedto a floattype variable.FUNCTION CALLS43
44CHAPTER 3USING FUNCTIONS AND CLASSES
TYPEvoidFOR FUNCTIONSSample program
// Outputs three random numbers#include <iostream>  // Declaration of cin and cout#include <cstdlib>   // Prototypes of srand(), rand():// void srand( unsigned int seed );// int rand( void );using namespace std;int main(){unsigned int seed;
int z1, z2, z3;cout << "   --- Random Numbers  --- \n" << endl;cout << "To initialize the random number generator, "<< "\n please enter an integer value: ";cin  >> seed;      // Input an integersrand( seed);      // and use it as argument for a// new sequence of random numbers.z1 = rand();       // Compute three random numbers.z2 = rand();z3 = rand();cout << "\nThree random numbers: "<< z1 << "   " << z2 << "   " << z3 << endl;return 0;}The statement cin>> seed;
reads an integer from the keyboard, because seedis of theunsignedint
type.NOTE
Sample screen output
--- Random Numbers  ---To initialize the random number generator,please enter an integer value: 7777Three random numbers: 25435   6908   14579 
TYPE VOID FOR FUNCTIONS45Functions without Return Value
You can also write functions that perform a certain action but do not return a value tothe function that called them. The type voidis available for functions of this type,which are also referred to as procedures in other programming languages.Example:void srand( unsigned int seed );The standard function srand()initializes an algorithm that generates random num-bers. Since the function does not return a value, it is of type void. An unsignedvalueis passed to the function as an argument to seed the random number generator. The
value is used to create a series of random numbers.Functions without Arguments
If a function does not expect an argument, the function prototype must be declared asvoidor the braces following the function name must be left empty.Example:int rand( void );      // or   int rand();The standard function rand()is called without any arguments and returns a randomnumber between 0 and 32767. A series of random numbers can be generated by repeating
the function call.Usage of srand()andrand()The function prototypes for srand()andrand()can be found in both the cstdlibandstdlib.hheader files.Calling the function rand()without previously having called srand()creates thesame sequence of numbers as if the following statement would have been proceeded:srand(1);If you want to avoid generating the same sequence of random numbers whenever the
program is executed, you must call srand()with a different value for the argumentwhenever the program is run.It is common to use the current time to initialize a random number generator. SeeChapter 6 for an example of this technique.
46CHAPTER 3USING FUNCTIONS AND CLASSES
HEADER FILESUsing header filesiostreamHeader fileCopyCopymyheader.hHeader fileapplication.cppSource file// Declaration// of cin, cout,// . . .#include <iostream>#include "myheader.h"int main(){   int a;   . . .   cin >> a;   cout << myfunc (a);   . . .   return 0;}// Declaration// of self-defined// functions// and classeslong myfunc(int);
HEADER FILES47Using Header FilesHeader files are text files containing declarations and macros. By using an #includedirective these declarations and macros can be made available to any other source file,even in other header files.Pay attention to the following points when using header files:header files should generally be included at the start of a program before any
other declarationsyou can only name oneheader file per #includedirectivethe file name must be enclosed in angled brackets < ... >or double quotes " ... ".Searching for Header Files
The header files that accompany your compiler will tend to be stored in a folder of theirown—normally called include. If the name of the header file is enclosed by angledbrackets< ... >, it is common to search for header files in the includefolder only.The current directory is not searched to increase the speed when searching for header
files.C++ programmers commonly write their own header files and store them in the cur-rent project folder. To enable the compiler to find these header files, the #includedirective must state the name of the header files in double quotes.Example:#include "project.h"The compiler will then also search the current folder. The file suffix .his normally usedfor user-defined header files.Standard Class Definitions
In addition to standard function prototypes, the header files also contain standard classdefinitions. When a header file is included, the classes defined and any objects declared
in the file are available to the program.Example:#include <iostream>using namespace std;Following these directives, the classes istreamandostreamcan be used with the cinandcoutstreams.cinis an object of the istreamclass and coutan object of theostreamclass.
48CHAPTER 3USING FUNCTIONS AND CLASSES
Some IDE’s put the old-fashioned iostream.handiomanip.hheader files at your disposal. Withinthese header files the identifiers of iostreamandiomanipare not contained in the stdnamespacebut are declared globally.NOTE
STANDARD HEADER FILES
Header files of the C++ standard library
Header files of the C standard library
algorithmiosmapstack
bitsetiosfwdmemorystdexcept
complexiostreamnewstreambuf

dequeueistreamnumericstring
exceptioniteratorostreamtypeinfo
fstreamlimitsqueueutility
functionallistsetvalarray

iomaniplocalesstreamvector
assert.hlimits.hstdarg.htime.h
ctype.hlocale.hstddef.hwchar.h
errno.hmath.hstdio.hwctype.h

float.hsetjmp.hstdlib.h
iso646.hsignal.hstring.h

STANDARD HEADER FILES49The C++ standard library header files are shown opposite. They are notindicated by thefile extension .hand contain all the declarations in their own namespace, std. Name-spaces will be introduced in a later chapter. For now, it is sufficient to know that identi-
fiers from other namespaces cannot be referred to directly. If you merely stipulate the
directiveExample:#include <iostream>the compiler would not be aware of the cinandcoutstreams. In order to use the iden-tifiers of the stdnamespace globally, you must add a usingdirective.Example:#include <iostream>#include <string>using namespace std;You can then use cinandcoutwithout any additional syntax. The header filestringhas also been included. This makes the stringclass available and allows user-friendly string manipulations in C++. The following pages contain further details on this
topic.Header Files in the C Programming Language
The header files standardized for the C programming language were adopted for the C++standard and, thus, the complete functionality of the standard C libraries is available to
C++ programs.Example:#include <math.h>Mathematical functions are made available by this statement.The identifiers declared in C header files are globally visible. This can cause nameconflicts in large programs. For this reason each C header file, for example name.h, isaccompanied in C++ by a second header file, cname, which declares the same identifiersin the stdnamespace. Including the file math.his thus equivalent toExample:#include <cmath>using namespace std;Thestring.horcstringfiles must be included in programs that use standard func-tions to manipulate C strings. These header files grant access to the functionality of the
C string library and are to be distinguished from the stringheader file that defines thestringclass.Each compiler offers additional header files for platform dependent functionalities.These may be graphics libraries or database interfaces.
50CHAPTER 3USING FUNCTIONS AND CLASSES
// To use strings.#include <iostream>    // Declaration of cin, cout#include <string>      // Declaration of class string
using namespace std;int main(){// Defines four strings:string prompt("What is your name:  "),name,                  // An emptyline( 40, '-'),        // string with 40 '-'
total = "Hello ";      // is possible!cout << prompt;          // Request for input.getline( cin, name);     // Inputs a name in one linetotal = total + name;     // Concatenates and// assigns strings.cout << line << endl      // Outputs line and name<< total << endl;cout << " Your name is "  // Outputs length<< name.length() << " characters long!" << endl;cout << line << endl;return 0;}Both the operators +and+=for concatenation and the relational operators <,<=,>,>=,==,
and!=are defined for objects of class string. Strings can be printed with coutand the operator <<.The class stringwill be introduced in detail later on.NOTE
USING STANDARD CLASSES
Sample program using class 
stringSample screen output
What is your name: Rose Summer---------------------------------------
Hello Rose Summer
Your name is 11 characters long!
---------------------------------------
USING STANDARD CLASSES51Several classes are defined in the C++ standard library. These include stream classes forinput and output, but also classes for representing strings or handling error conditions.Each class is a type with certain properties and capacities. As previously mentioned,the properties of a class are defined by its datamembers
and the class’s capacities aredefined by its methods. Methods are functions that belong to a class and cooperate withthe members to perform certain operations. Methods are also referred to as memberfunc-
tions.Creating Objects
Anobjectis a variable of a class type, also referred to as an instanceof the class. When anobject is created, memory is allocated to the data members and initialized with suitable
values.Example:string s("I am a string");In this example the object s,an instance of the standard class 
string(or simply astring), is defined and initialized with the string constant that follows. Objects of thestringclass manage the memory space required for the string themselves.In general, there are several ways of initializing an object of a class. A string can thusbe initialized with a certain number of identical characters, as the example on the oppo-
site page illustrates.Calling MethodsAll the methods defined as publicwithin the corresponding class can be called for anobject. In contrast to calling a global function, a method is always called for one particularobject. The name of the object precedes the method and is separated from the method bya period.Example:s.length(); // object.method();
The method length()supplies the length of a string, i.e. the number of characters in astring. This results in a value of 13 for the string sdefined above.Classes and Global FunctionsGlobally defined functionsexist for some standard classes. These functions perform certainoperations for objects passed as arguments. The global function getline(), for exam-ple, stores a line of keyboard input in a string.Example:getline(cin, s);The keyboard input is terminated by pressing the return key to create a new-line charac-
ter,'\n', which is not stored in the string.
exercises
52CHAPTER 3USING FUNCTIONS AND CLASSES
NumberSquare Root
4212.253.5
0.01210.11
EXERCISESScreen output for exercise 1
Listing for exercise 2
// A program containing errors!# include <iostream>, <string># include <stdlib># void srand( seed);int main(){string message "\nLearn from your mistakes!";cout << message << endl;int len = length( message);cout << "Length of the string: " << len << endl;// And a random number in addition:int a, b;
a = srand(12.5);b = rand( a );cout << "\nRandom number: " << b << endl;return 0;}
EXERCISES53Exercise 1
Create a program to calculate the square roots of the numbers
412.250.0121

and output them as shown opposite.Then read a number from the keyboard and
output the square root of this number.
To calculate the square root,use the function 
sqrt(),which is defined by the
following prototype in the 
math.h(orcmath) header file:double sqrt( double x); The return value of the 
sqrt()function is the square root of 
x.Exercise 2
The program on the opposite page contains several 
errors
! Correct the errors
and ensure that the program can be executed.
Exercise 3
Create a C++ program that defines a string containing the following character

sequence:I have learned something new again! and displays the length of the string on screen.
Read two lines of text from the keyboard.Concatenate the strings using 
" * "to separate the two parts of the string.Output the new string on screen.

solutions
54CHAPTER 3USING FUNCTIONS AND CLASSES
SOLUTIONSExercise 1
// Compute square roots#include <iostream>#include <cmath>using namespace std;int main(){double x1 = 4.0, x2 = 12.25, x3 = 0.0121;cout << "\n   Number  \t Square Root" << endl;cout << "\n    " << x1 << "   \t " << sqrt(x1)<< "\n   "  << x2 << "   \t " << sqrt(x2)<< "\n    " << x3 << "   \t " << sqrt(x3) << endl;cout << "\nType a number whose square root is to be"" computed. ";cin  >> x1;cout << "\n   Number  \t Square Root" << endl;cout << "\n   " << x1 << "  \t " << sqrt(x1) << endl;return 0;}Exercise 2
// The corrected program:#include <iostream>      // Just one header file in a line#include <string>#include <cstdlib>       // Prototypes of functions// void srand( unsigned int seed);// int rand(void);// or:
// #include <stdlib.h>using namespace std;   // Introduces all names of namespace// std into the global scope.int main(){string message = "\nLearn from your mistakes!";...// =cout << message << endl;
SOLUTIONS55int len = message.length();// instead of: length(message);cout << "Length of the string: " << len << endl;// And another random number:int b;                  // Variable a is not needed.srand(12);              // instead of:  a = srand(12.5);
b = rand();             // instead of:  b = rand(a);cout << "\nRandom number: " << b << endl;return 0;}Exercise 3
#include <iostream>    // Declaration of cin, cout#include <string>      // Declaration of class string
using namespace std;int main(){string message("I have learned something new again!\n"),prompt("Please input two lines of text:"),
str1, str2, sum;cout << message << endl;   // Outputs the message
cout << prompt << endl;    // Request for inputgetline( cin, str1);      // Reads the firstgetline( cin, str2);      // and the second line of textsum = str1 + " * " + str2;   // Concatenates, assignscout << sum << endl;         // and outputs strings.return 0;}
This page intentionally left blank 
57Input and Output withStreamsThis chapter describes the use of streams for input and output,focusing
on formatting techniques.
chapter
4
58CHAPTER 4INPUT AND OUTPUT WITH STREAMS
iosistreamostream
iostreamSTREAMSStream classes for input and output
The four standard streams
cinObject of class istreamto control standard inputcoutObject of class ostreamto control standard outputcerrObject of class ostreamto control unbuffered error outputclogObject of class ostreamto control buffered error output
STREAMS59I/O Stream Classes
During the development of C++ a new class-based input/output system was imple-mented. This gave rise to the I/O stream classes, which are now available in a library oftheir own, the so-called iostream library.The diagram on the opposite page shows how a so-called class hierarchy develops dueto inheritance. The class iosis the base class of all other stream classes. It contains theattributes and abilities common to all streams. Effectively, the iosclassmanages the connection to the physical data stream that writes your program’s
data to a file or outputs the data on screencontains the basic functions needed for formatting data. A number of flags that
determine how character input is interpreted have been defined for this purpose.Theistreamandostreamclasses derived from iosform a user-friendly interfacefor stream manipulation. The istreamclass is used for reading streams and theostreamclass is used for writing to streams. The operator >>is defined in istreamand<<is defined in ostream, for example.Theiostreamclass is derived by multiple inheritance from istreamandostreamand thus offers the functionality of both classes.Further stream classes, a file management class, for example, are derived from theclasses mentioned above. This allows the developer to use the techniques described for
file manipulation. These classes, which also contain methods for opening and closing
files, will be discussed in a later chapter.Standard Streams
The streams cinandcout,which were mentioned earlier, are instances of the
istreamorostreamclasses. When a program is launched these objects are automati-cally created to read standard inputor write to standard output.Standard input is normally the keyboard and standard output the screen. However,standard input and output can be redirected to files. In this case, data is not read from
the keyboard but from a file, or data is not displayed on screen but written to a file.The other two standard streams cerrandclogare used to display messages whenerrors occur. Error messages are displayed on screen even if standard output has been
redirected to a file.
60CHAPTER 4INPUT AND OUTPUT WITH STREAMS
Here the manipulator showposis called.cout << showpos << 123;   // Output:  +123The above statement is equivalent tocout.setf( ios::showpos);cout << 123;The other positive numbers are printed with their sign as well:cout << 22;               // Output:  +22The output of a positive sign can be canceled by the manipulatornoshowpos:cout << noshowpos << 123;  // Output:  123The last statement is equivalent tocout.unsetf( ios::showpos);
cout << 123;The operators >>and<<format the input and/or output according to how the flags in the base classiosare setThe manipulator showposis a function that calls the method cout.setf(ios::showpos);,ios::showposbeing the flag showposbelonging to the iosclassUsing manipulators is easier than directly accessing flags. For this reason, manipulators are described inthe following section, whereas the methods setf()andunsetf()are used only under exceptionalcircumstances.Old compilers only supply some of the manipulators. In this case, you have to use the methods setf()andunsetf().HINTSFORMATTING AND MANIPULATORS
Example:Calling a manipulator

FORMATTING AND MANIPULATORS61Formatting
When reading keyboard input, a valid input format must be used to determine how inputis to be interpreted. Similarly, screen output adheres to set of rules governing how, for
example, floating-point numbers are displayed.The stream classes istreamandostreamoffer various options for performing thesetasks. For example, you can display a table of numeric values in a simple way.In previous chapters we have looked at the cinandcoutstreams in statements suchas:cout << "Please enter a number: ";cin  >> x; The following sections systematically describe the abilities of the stream classes. Thisincludes:the>>and<<operators for formatted input and output. These operators aredefined for expressions with fundamental types—that is, for characters, boolean
values, numbers and strings.manipulators, which can be inserted into the input or output stream. Manipula-
tors can be used to generate formats for subsequent input/output. One manipula-
tor that you are already familiar with is endl, which generates a line feed at theend of a line.other methods for determining or modifying the state of a stream and unformat-
ted input and output.Flags and Manipulators
Formatting flagsdefined in the parent class iosdetermine how characters are input oroutput. In general, flags are represented by individual bits within a special integral vari-
able. For example, depending on whether a bit is set or not, a positive number can be
output with or without a plus sign.Each flag has a defaultsetting. For example, integral numbers are output as decimals bydefault, and positive numbers are output without a plus sign.It is possible to modify individual formatting flags. The methods setf()andunsetf()can be used for this purpose. However, the same effect can be achieved sim-ply by using so-calledmanipulators, which are defined for all important flags. Manipula-tors are functions that can be inserted into the input or output stream and thus be called.
62CHAPTER 4INPUT AND OUTPUT WITH STREAMS
// Reads integral decimal values and// generates octal, decimal, and hexadecimal output.#include <iostream>     // Declarations of cin, cout andusing namespace std;    // manipulators oct, hex, ...int main(){int number;cout << "Please enter an integer: ";cin >> number;cout << uppercase// for hex-digits<< " octal  \t decimal  \t hexadecimal\n "<<oct<< number << "       \t "<<dec<< number << "       \t "<<hex<< number << endl;return 0;}FORMATTED OUTPUT OF INTEGERS
Manipulators formatting integers
Sample program
ManipulatorEffects
Octal baseHexadecimal baseDecimal base (by default)Generates a + sign in non-negative numericoutput.Generates capital letters in hexadecimaloutput.Generates non-negative numeric outputwithout a + sign (by default).Generates lowercase letters in hexadecimaloutput (by default).octhexdecshowposnoshowposuppercase
nouppercase
FORMATTED OUTPUT OF INTEGERS63Formatting Options
The<<operator can output values of type short,int,longor a correspondingunsignedtype. The following formatting options are available:define the numeric system in which to display the number: decimal, octal, orhexadecimaluse capitals instead of small letters for hexadecimalsdisplay a sign for positive numbers.In addition, the field width can be defined for the above types. The field width canalso be defined for characters, strings, and floating-point numbers, and will be discussed
in the following sections.Numeric SystemIntegral numbers are displayed as decimals by default. The manipulators oct,hex,and
deccan be used for switching from and to decimal display mode.Example:cout << hex << 11;            // Output: bHexadecimals are displayed in small letters by default, that is, using a,b, ..., f. Themanipulatoruppercaseallows you to use capitals.Example:cout << hex << uppercase << 11; //Output: BThe manipulator nouppercasereturns the output format to small letters.Negative Numbers
When negative numbers are output as decimals, the output will always include a sign.You can use the showposmanipulator to output signed positive numbers.Example:cout << dec << showpos << 11; //Output: +11You can use noshowposto revert to the original display mode.Whenoctalorhexadecimalnumbers are output, the bits of the number to be output arealways interpreted as unsigned! In other words, the output shows the bit pattern of a
number in octal or hexadecimal format.Example:cout << dec << -1 << "   " << hex << -1;This statement causes the following output on a 32-bit system:-1   ffffffff 
64CHAPTER 4INPUT AND OUTPUT WITH STREAMS
#include <iostream>using namespace std;int main(){double x = 12.0;cout.precision(2);// Precision 2cout << " By default:   " << x << endl;cout << " showpoint:  " << showpoint<< x << endl;cout << " fixed:      " << fixed<< x << endl;cout << " scientific: " << scientific<< x << endl;return 0;}The key word constwithin the prototype of precision()signifies that the method performs onlyread operations.NOTE
FORMATTED OUTPUT OF FLOATING-POINT NUMBERS
Manipulators formatting floating-point numbers
Methods for precision
Sample program
ManipulatorEffects
Sets the precision to n.Returns the used precision.int precision (int n);int precision() const;ManipulatorEffects
Generates a decimal point charactershown in floating-point output. The

number of digits after the decimal point
corresponds to the used precision.Output in fixed point notationOutput in scientific notationSets the precision to n.Trailing zeroes after the decimal point
are not printed.
If there are no digits after the decimal
point, the  decimal point is not printed
(by default).showpointnoshowpointfixedscientificsetprecision (int n)
FORMATTED OUTPUT OF FLOATING-POINT NUMBERS65Standard Settings
Floating-points are displayed to six digits by default. Decimals are separated from theintegral part of the number by a decimal point. Trailing zeroes behind the decimal point
are not printed. If there are no digits after the decimal point, the decimal point is not
printed (by default).Examples:cout << 1.0;       // Output: 1cout << 1.234;     // Output: 1.234
cout << 1.234567;  // Output: 1.23457The last statement shows that the seventh digit is not simply truncated but rounded.Very large and very small numbers are displayed in exponential notation.Example:cout << 1234567.8;// Output: 1.23457e+06
Formatting
The standard settings can be modified in several ways. You canchange the precision, i.e. the number of digits to be outputforce output of the decimal point and trailing zeroesstipulate the display mode (fixed point or exponential).Both the manipulator setprecision()and the method precision()can be used toredefine precision to be used.Example:cout << setprecision(3);  // Precision: 3// or:  cout.precision(3);
cout  << 12.34;           // Output: 12.3Note that the header file iomanipmust be included when using the manipulator set-precision(). This also applies to all standard manipulators called with at least oneargument.The manipulator showpointoutputs the decimal point and trailing zeroes. Thenumber of digits being output (e.g. 6) equals the current precision.Example:cout << showpoint << 1.0; // Output: 1.00000However,fixed pointoutput with a predetermined number of decimal places is often moreuseful. In this case, you can use the fixedmanipulator with the precision defining thenumber of decimal places. The default value of 6 is assumed in the following example.Example:cout << fixed << 66.0;   // Output: 66.000000In contrast, you can use the scientificmanipulator to specify that floating-pointnumbers are output as exponential expressions. 
66CHAPTER 4INPUT AND OUTPUT WITH STREAMS
The manipulators setw()andsetfill()are declared in the header file iomanip.NOTE
OUTPUT IN FIELDSElement functions for output in fieldsManipulators for output in fields
Examples#include <iostream>         // Obligatory#include <iomanip>          // declarations
using namespace std; 1st Example:cout << '|' << setw(6) << 'X' << '|';Output:|     X|          // Field width 62nd Example:cout << fixed << setprecision(2)<< setw(10) << 123.4 << endl<< "1234567890" << endl;Output:123.40          // Field width 101234567890MethodEffects
Returns the minimum field width usedSets the minimum field width to nReturns the fill character used
Sets the fill character to chint width() const;int width(int n);
int fill() const;int fill(int ch);ManipulatorEffects
Sets the minimum field width to nSets the fill character to chLeft-aligns output in fieldsRight-aligns output in fieldsLeft-aligns output of the sign andright-aligns output of the numeric
valuesetw(int n)setfill(int ch)leftrightinternal
OUTPUT IN FIELDS67The<<operator can be used to generate formatted output in fields. You canspecify the field widthset the alignment of the output to right- or left-justifiedspecify a fill-characterwith which to fill the field.Field WidthThe field width is the number of characters that can be written to a field. If the outputstring is larger than the field width, the output is not truncated but the field is extended.
The output will always contain at least the number of digits specified as the field width.You can either use the width()method or the setw()manipulator to define fieldwidth.Example:cout.width(6);    // or:  cout << setw(6);One special attribute of the field width is the fact that this value is non-permanent:the field width specified applies to the next output only, as is illustrated by the examples
on the opposite page. The first example outputs the character 'X'to a field with widthof 6, but does not output the '|'character.The default field width is 0. You can also use the width()method to get the currentfield width. To do so, call width()without any other arguments.Example:int fieldwidth = cout.width();Fill Characters and Alignment
If a field is larger than the string you need to output, blanks are used by default to fill thefield. You can either use the fill()method or the setfill()manipulator to specifyanother fill character.Example:cout << setfill('*') << setw(5) << 12;// Output: ***12The fill character applies until another character is defined.As the previous example shows, output to fields is normally right-aligned. The otheroptions available are left-aligned and internal, which can be set by using the manipula-
torsleftandinternal. The manipulator internalleft-justifies the sign and right-justifies the number within a field.Example:cout.width(6); cout.fill('0');cout << internal << -123; // Output: -00123
68CHAPTER 4INPUT AND OUTPUT WITH STREAMS
// Enters a character and outputs its// octal, decimal, and hexadecimal code.#include <iostream>    // Declaration of cin, cout#include <iomanip>     // For manipulators being called// with arguments.#include <string>
using namespace std;int main(){int number = ' ';cout << "The white space code is as follows: "<< number << endl;char ch;string prompt ="\nPlease enter a character followed by "" <return>: ";cout << prompt;cin >> ch;                     // Read a characternumber = ch;cout << "The character " << ch<< " has code" << number << endl;cout << uppercase              // For hex-digits<< "     octal  decimal  hexadecimal\n "<< oct << setw(8) << number
<< dec << setw(8) << number<< hex << setw(8) << number << endl;return 0;}OUTPUT OF CHARACTERS,STRINGS,AND BOOLEAN VALUES
Sample program

OUTPUT OF CHARACTERS, STRINGS, AND BOOLEAN VALUES69Outputting Characters and Character CodesThe>>operator interprets a number of type charas the character code and outputs thecorresponding character:Example:char ch = '0';cout << ch << ' ' << 'A';
// Outputs three characters: 0 AIt is also possible to output the character code for a character. In this case the charactercode is stored in an intvariable and the variable is then output.Example:int code = '0';cout << code;         // Output: 48The'0'character is represented by ASCII Code 48. The program on the opposite pagecontains further examples.Outputting StringsYou can use the >>operator both to output string literals, such as "Hello", and stringvariables, as was illustrated in previous examples. As in the case of other types, strings
can be positioned within output fields.Example:string s("spring flowers ");cout << left            // Left-aligned<< setfill('?')    // Fill character ?
<< setw(20) << s ; // Field width 20This example outputs the string "spring flowers??????". The manipulatorrightcan be used to right-justify the output within the field.Outputting Boolean Values
By default the <<operator outputs boolean values as integers, with the value 0represent-ingfalseand1true
. If you need to output the strings trueorfalseinstead, theflagios::boolalphamust be set. To do so, use either the setf()method or themanipulatorboolalpha.Example:bool ok = true;cout << ok << endl                // 1<< boolalpha << ok << endl;  // trueYou can revert this setting using the noboolalphamanipulator.
70CHAPTER 4INPUT AND OUTPUT WITH STREAMS
// Inputs an article label and a price#include <iostream>    // Declarations of cin, cout,...#include <iomanip>     // Manipulator setw()
#include <string>
using namespace std;int main(){string label;double price;cout << "\nPlease enter an article label: ";// Input the label (15 characters maximum):cin >> setw(16);        // or:  cin.width(16);cin >> label;cin.sync();    // Clears the buffer and resetscin.clear();   // any error flags that may be setcout << "\nEnter the price of the article: ";cin >> price;           // Input the price// Controlling output:cout << fixed << setprecision(2)<< "\nArticle:"<< "\n  Label:  " << label<< "\n  Price:  " << price << endl;// ... The program to be continuedreturn 0;}The input buffer is cleared and error flags are reset by calling the sync()andclear()methods. Thisensures that the program will wait for new input for the price, even if more than 15 characters have
been entered for the label.NOTE
FORMATTED INPUT
Sample program

FORMATTED INPUT71The>>operator, which belongs to the istreamclass, takes the current number baseand field width flags into account when reading input:the number base specifies whether an integer will be read as a decimal, octal, or
hexadecimalthe field width specifies the maximum number of characters to be read for a
string.When reading from standard input, cinis buffered by lines. Keyboard input is thusnot read until confirmed by pressing the <Return> key. This allows the user to press the
backspace key and correct any input errors, provided the return key has not been pressed.
Input is displayed on screen by default.Input FieldsThe>>operator will normally read the next inputfield, convert the input by reference tothe type of the supplied variable, and write the result to the variable. Any white space
characters (such as blanks, tabs, and new lines) are ignored by default.Example:char ch;cin >> ch;        // Enter a characterWhen the following keys are pressed<return> <tab> <blank> <X> <return> the character 'X'is stored in the variable ch.An input field is terminated by the first white space character or by the first characterthat cannot be processed.Example:int i;cin >> i;Typing123FF<Return>stores the decimal value 123in the variable i. However, thecharacters that follow, FFand the newline character, remain in the input buffer and willbe read first during the next read operation.When reading strings, only one word is read since the first white space character willbegin a new input field.Example:string city;cin >> city;     // To read just one word!IfLao Kaiis input, only Laowill be written to the citystring. The number of charac-ters to be read can also be limited by specifying the field width. For a given field width ofn,a maximum of 
nÐ1characters will be read, as one byte is required for the null charac-ter. Any initial white space will be ignored. The program on the opposite page illustrates
this point and also shows how to clear the input buffer.
72CHAPTER 4INPUT AND OUTPUT WITH STREAMS
// Enter hexadecimal digits and a floating-point number//
#include <iostream>
#include <iomanip>
using namespace std;int main(){int number = 0;cout << "\nEnter a hexadecimal number: "<< endl;cin >> hex >> number;      // Input hex-numbercout << "Your decimal input: " << number << endl;
// If an invalid input occurred:cin.sync();              // Clears the buffer
cin.clear();             // Reset error flagsdouble x1 = 0.0, x2 = 0.0;
cout << "\nNow enter two floating-point values: "<< endl;cout << "1. number: ";cin  >> x1;                     // Read first numbercout << "2. number: ";cin  >> x2;                     // Read second numbercout << fixed << setprecision(2)<< "\nThe sum of both numbers:   "
<< setw(10) << x1 + x2 << endl;cout << "\nThe product of both numbers: "<< setw(10) << x1 * x2 << endl;return 0;}FORMATTED INPUT OF NUMBERS
Sample program

FORMATTED INPUT OF NUMBERS73Inputting Integers
You can use the hex,oct,and 
decmanipulators to stipulate that any charactersequence input is to processed as a hexadecimal, octal, or decimal number.Example:int n;cin >> oct >> n;An input value of 10will be interpreted as an octal, which corresponds to a decimalvalue of 8.Example:cin >> hex >> n;Here, any input will be interpreted as a hexadecimal, enabling input such as f0aor-F7.Inputting Floating-Point Numbers
The>>operator interprets any input as a decimal floating-point number if the variable isa floating-point type, i.e. float,double,or 
long double. The floating-point num-ber can be entered in fixed point or exponential notation.Example:double x;cin >> x;The character input is converted to a doublevalue in this case. Input, such as 123,-22.0,or 
3e10is valid.Input Errors
But what happens if the input does not match the type of variable defined?Example:int i, j;    cin >> i >> j;Given input of 1A5the digit 1will be stored in the variable i. The next input fieldbegins with A. But since a decimal input type is required, the input sequence will not beprocessed beyond the letter A. If, as in our example, no type conversion is performed, thevariable is not written to and an internal error flag is raised.It normally makes more sense to read numerical values individually, and clear theinput buffer and any error flags that may have been set after each entry.Chapter 6, “Control Flow,” and Chapter 28, “Exception Handling,” show how a pro-gram can react to input errors.
74CHAPTER 4INPUT AND OUTPUT WITH STREAMS
//  Reads a text with the operator >>//  and the function getline().#include <iostream>#include <string>using namespace std;string header ="   --- Demonstrates Unformatted Input ---";int main(){string word, rest;cout << header<< "\n\nPress <return> to go on" << endl;cin.get();                  // Read the new line// without saving.cout << "\nPlease enter a sentence with several words!"<< "\nEnd with <!> and <return>."
<< endl;cin >> word;                // Read the first wordgetline( cin, rest, '!');   // and the remaining text// up to the character !cout << "\nThe first word:   " << word<< "\nRemaining text: " << rest << endl;return 0;}1.A text of more than one line can be entered.
2.The sample program requires that at least one word and a following white space are entered.
NOTE
UNFORMATTED INPUT/OUTPUT
Sample program

UNFORMATTED INPUT/OUTPUT75Unformatted input and output does not use fields, and any formatting flags that havebeen set are ignored. The bytes read from a stream are passed to the program “as is.”
More specifically, you should be aware that any white space characters preceding the
input will be processed.Reading and Writing CharactersYou can use the methods get()andput()to read or write single characters. Theget()method reads the next character from a stream and stores it in the given charvariable.Example:char ch;cin.get(ch);If the character is a white space character, such as a newline, it will still be stored in thechvariable. To prevent this from happening you can usecin >> ch; to read the first non-white space character.Theget()method can also be called without any arguments. In this case, get()returns the character code of type int.Example:int c = cin.get();Theput()method can be used for unformatted output of a character. The character tobe output is passed to put()as an argument.Example:cout.put('A');This statement is equivalent to cout << 'A';, where the field width is undefined orhas been set to 1.Reading a LineThe>>operator can only be used to read one word into a string. If you need to read awhole line of text, you can use the global function getline(), which was introducedearlier in this chapter.Example:getline(cin, text);This statement reads characters from cinand stores them in the string variable textuntil a new line character occurs. However, you can specify a different delimiting charac-
ter by passing the character to the getline()function as a third argument.Example:getline(cin, s, '.');The delimiting character is read, but not stored in the string. Any characters subsequent
to the first period will remain in the input buffer of the stream.
exercises
76CHAPTER 4INPUT AND OUTPUT WITH STREAMS
// A program with resistant mistakes#include <iostream>using namespace std;int main(){char ch;string word;cin >> "Let's go! Press the return key: " >> ch;cout << "Enter a word containingthree characters at most: ";cin  >> setprecision(3) >> word;cout >> "Your input: " >> ch >> endl;
return 0;}EXERCISESScreen output for exercise 3
Article Number   Number of Pieces  Price per piece.......         ......      ...... Dollar Program listing for exercise 5

EXERCISES77The variable type defines whether a character or a number is to be read or output.TIPExercise 1
What output is generated by the program on the page entitled “
Formatted output
of floating-point numbers
” in this chapter?
Exercise 2
Formulate statements to perform the following:
a.Left-justify the number 0.123456 in an output field with a width of 15.
b.Output the number 23.987 as a fixed point number rounded to two dec-
imal places,right-justifying the output in a field with a width of 12.
c.Output the number –123.456 as an exponential and with four decimal
spaces.How useful is a field width of 10?
Exercise 3
Write a C++ program that reads an article number,a quantity,and a unit price

from the keyboard and outputs the data on screen as displayed on the opposite

page.
Exercise 4
Write a C++ program that reads any given character code (a positive integer)

from the keyboard and displays the corresponding character and the character

code as a decimal,an octal,and a hexadecimal on screen.
Why do you think the character P is output when the number 336 is entered?
Exercise 5
Correct the mistakes in the program on the opposite page.

solutions
78CHAPTER 4INPUT AND OUTPUT WITH STREAMS
SOLUTIONSExercise 1
Output of a sample program formatting floating-point numbers:
By default: 12showpoint:  12.
fixed:      12.00
scientific: 1.20e+001 Exercise 2
#include <iostream>#include <iomanip>     // For setw() and setprecision()using namespace std;int main(){double x1 = 0.123456,  x2 = 23.987,  x3 = -123.456;//a)cout << left << setw(15) << x1 << endl;//b)cout << fixed << setprecision(2) << right << setw(12)<< x2 << endl;//c)cout << scientific << setprecision(4) << x3 << endl;// Output: -1.2346e+002// A field width of 12 or more would be convenient!return 0;}Exercise 3
// Input and formatted output of article characteristics.#include <iostream>#include <iomanip>using namespace std;int main(){long number = 0;int  count = 0;double price = 0.0;// Input:cout << "\nPlease enter article characteristics.\n";
cout << "Article number:  ";
cin  >> number;
SOLUTIONS79cout << "Number of pieces:      ";cin  >> count;cout << "Price per piece:     ";cin  >> price;// Output:cout <<
"\n\tArticle Number    Quantity    Price per piece ";cout << "\n\t"<< setw(8)  << number<< setw(16) << count
<< fixed    << setprecision(2)<< setw(16) << price << " Dollar" << endl;return 0;}Exercise 4
#include <iostream>#include <iomanip>        // Manipulator setw()using namespace std;int main(){unsigned char c = 0;unsigned int  code = 0;cout << "\nPlease enter a decimal character code: ";cin  >> code;c = code;                         // Save for output
cout << "\nThe corresponding character: " << c << endl;
code = c;           // Character code. Is only// necessary, if input is > 255.cout << "\nCharacter codes"<< "\n  decimal:     " << setw(3) << dec << code<< "\n  octal:       " << setw(3) << oct << code<< "\n  hexadecimal: " << setw(3) << hex << code
<< endl;return 0;}
80CHAPTER 4INPUT AND OUTPUT WITH STREAMS
When entering 336,the value 80 is stored in the low byte of variable 
code(336 = 256 + 80).Thus after the assignment,the variable 
ccontains the value 80,representing the character P.
Exercise 5
The corrected program:
// Corrections are commented.//
#include <iostream>
#include <iomanip>       // Manipulator setw()
#include <string>        // Class string
using namespace std;int main(){string word;          // To read a word.// char ch; is not needed.// cout << ...instead of  cin >> .cout << "Let's go! Press the return key: ";cin.get();            // Input newline charactercout << " Enter a word "                            // ""containing three characters at the most: ";// "cin  >> setw(3) >> word;           // setw(3) instead of// setprecision(3)cout << "Your input: "             // <<<< word << endl;              // instead of  >> chreturn 0;}
81Operators forFundamental Types
In this chapter,operators needed for calculations and selections are
introduced.Overloading and other operators,such as those needed for

bit manipulations,are introduced in later chapters.
chapter
5
82CHAPTER 5OPERATORS FOR FUNDAMENTAL TYPES
#include <iostream>using namespace std;int main(){double x, y;cout << "\nEnter two floating-point values: ";cin >> x >> y;cout << "The average of the two numbers is: "<< (x + y)/2.0 << endl;return 0;}BINARY ARITHMETIC OPERATORS
Binary operator and operands
The binary arithmetic operators
Sample program
Sample output for the program
Enter two floating-point values:  4.75   12.3456The average of the two numbers is: 8.5478 OperatorLeft  operandRight  operand
a+b
+-*/%OperatorSignificance
AdditionSubraction
Multiplication
Division
Remainder
BINARY ARITHMETIC OPERATORS83If a program is to be able to process the data input it receives, you must define the opera-tions to be performed for that data. The operations being executed will depend on the
type of data — you could add, multiply, or compare numbers, for example. However, it
would make no sense at all to multiply strings.The following sections introduce you to the most important operators that can beused for arithmetic types. A distinction is made between unaryandbinaryoperators. Aunary operator has only one operand, whereas a binary operator has two.Binary Arithmetic Operators
Arithmetic operatorsare used to perform calculations. The opposite page shows anoverview. You should be aware of the following:Divisionsperformed with integral operands will produce integral results; for exam-ple,7/2computes to 3. If at least one of the operands is a floating-point number,the result will also be a floating-point number; e.g., the division 7.0/2producesan exact result of 3.5.Remainder divisionis only applicable to integral operands and returns the remain-der of an integral division. For example, 7%2computes to 1.Expressions
In its simplest form an expression consists of only one constant, one variable, or onefunction call. Expressions can be used as the operands of operators to form more complex
expressions. An expression will generally tend to be a combination of operators and
operands.Each expression that is not a voidtype returns a value. In the case of arithmeticexpressions, the operands define the type of the expression.Examples:int a(4);  double x(7.9);a * 512        // Type int
1.0 + sin(x)   // Type double
x Ð 3          // Type double, since one// operand is of type doubleAn expression can be used as an operand in another expression.Example:2 + 7 * 3              // Adds 2 and 21Normalmathematical rules(multiplication before addition) apply when evaluating anexpression, i.e. the *,/,%operators have higher precedence than +and-. In our exam-ple,7*3is first calculated before adding 2. However, you can use parentheses to apply adifferent precedence order.Example:(2 + 7) * 3        // Multiplies 9 by 3.
84CHAPTER 5OPERATORS FOR FUNDAMENTAL TYPES
#include <iostream>using namespace std;int main(){int i(2), j(8);cout << i++ << endl;       // Output:  2cout << i   << endl;       // Output:  3cout << j-- << endl;       // Output:  8
cout << --j << endl;       // Output:  6return 0;}UNARY ARITHMETIC OPERATORS
The unary arithmetic operators
Precedence of arithmetic operators
Effects of prefix and postfix notation
+-++--OperatorSignificance
Unary sign operatorsIncrement operator
Decrement operatorPrecedenceOperator
GroupingHighLow++   --++   --+    -*/%+-(postfix)left to right
left to rightleft to rightright to left(prefix)(sign)(addition)(subtraction)
UNARY ARITHMETIC OPERATORS85There are four unary arithmetic operators: the sign operators +and-, the incrementoperator++,and the decrement operator 
--.Sign Operators
Thesign operator Ðreturns the value of the operand but inverts the sign.Example:int n = Ð5;   cout << -n;    // Output: 5Thesign operator+performs no useful operation, simply returning the value of itsoperand.Increment / Decrement Operators
The increment operator ++modifies the operand by adding 1 to its value and cannot beused with constants for this reason.Given that iis a variable, both i++(postfix notation) and ++i(prefix notation) raisethe value of iby1. In both cases the operation i=i+1is performed.However, prefix ++and postfix ++are two different operators. The differencebecomes apparent when you look at the value of the expression; ++imeans that thevalue of ihas already been incremented by 1, whereas the expression i++retains theoriginal value of i. This is an important difference if ++iori++forms part of a morecomplex expression:++ii
is incremented first and the new value of iis then applied,i++the original value of iis applied before iis incremented.The decrement operator --modifies the operand by reducing the value of theoperand by 1. As the sample program opposite shows, prefix or postfix notation can beused with --.Precedence
How is an expression with multiple operators evaluated?Example:float val(5.0);  cout << val++ Ð 7.0/2.0;Operator precedence determines the order of evaluation, i.e. how operators andoperands are grouped. As you can see from the table opposite, ++has the highest prece-dence and /has a higher precedence than -. The example is evaluated as follows:(val++)–(7.0/2.0). The result is 1.5, as valis incremented later.If two operators have equal precedence, the expression will be evaluated as shown incolumn three of the table.Example:3 * 5 % 2is equivalent to(3 * 5) % 2
86CHAPTER 5OPERATORS FOR FUNDAMENTAL TYPES
// Demonstration of compound assignments#include <iostream>#include <iomanip>
using namespace std;int main(){float x, y;cout << "\n Please enter a starting value:    ";cin >> x;cout << "\n Please enter the increment value: ";cin >> y;x += y;cout << "\n And now multiplication! ";cout << "\n Please enter a factor:  ";cin >> y;x *= y;cout << "\n Finally division.";cout << "\n Please supply a divisor: ";cin >> y;x /= y;
cout << "\n And this is "<< "your current lucky number: "// without digits after// the decimal point:<< fixed << setprecision(0)
<< x << endl;return 0;}ASSIGNMENTSSample program

ASSIGNMENTS87Simple AssignmentsAsimpleassignment uses the assignment operator =to assign the value of a variable to anexpression. In expressions of this type the variable must be placed on the left and the
assigned value on the right of the assignment operator.Examples:z = 7.5;y = z;
x = 2.0 + 4.2 * z;The assignment operator has low precedence. In the case of the last example, the rightside of the expression is first evaluated and the result is assigned to the variable on the
left.Each assignment is an expression in its own right, and its value is the value assigned.Example:sin(x = 2.5);In this assignment the number 2.5is assigned to xand then passed to the function as anargument.Multipleassignments, which are always evaluated from right to left, are also possible.Example:i = j = 9;In this case the value 9is first assigned to jand then to i.Compound AssignmentsIn addition to simple assignment operators there are also compound assignment opera-tors that simultaneously perform an arithmetic operation and an assignment, for exam-
ple.Examples.i += 3;is equivalent toi = i + 3;i *= j + 2;is equivalent toi = i * (j+2);The second example shows that compound assignments are implicitly placed in paren-theses, as is demonstrated by the fact that the precedence of the compound assignment is
just as low as that of the simple assignment.Compound assignment operators can be composed from any binary arithmetic opera-tor (and, as we will see later, with bit operators). The following compound operators are
thus available: +=,-=,*=,/=, and %=.You can modify a variable when evaluating a complex expression by means of anassignment or the ++,--operators. This technique is referred to as a side effect. Avoiduse of side effects if possible, as they often lead to errors and can impair the readability of
your programs.
88CHAPTER 5OPERATORS FOR FUNDAMENTAL TYPES
RELATIONAL OPERATORS
The relational operators
Precedence of relational operators
Examples for comparisons:OperatorSignificance
less thanless than or equal togreater thangeater than or equal toequalunequal<><=>===!=arithmetic operators<   <=   >   >===   !=assignment operatorsPrecedenceOperator
HighLow5 >= 6false
truefalsetrue1.7 < 1.84 + 2 == 52 * 4 != 7ComparisonResult

RELATIONAL OPERATORS89The Result of ComparisonsEach comparison in C++ is a booltype expression with a value of trueorfalse,wheretruemeans that the comparison is correct and falsemeans that the compari-son is incorrect.Example:length == circuit // false or true
If the variables lengthandcircuitcontain the same number, the comparison istrueand the value of the relational expression is true. But if the expressions containdifferent values, the value of the expression will be false.When individual characters are compared, the character codes are compared. Theresult therefore depends on the character set you are using. The following expression
results in the value truewhen ASCII code is used.Example:'A' < 'a'// true, since 65 < 97
Precedence of Relational Operators
Relational operators have lower precedence than arithmetic operators but higher prece-dence than assignment operators.Example:bool flag = index < max Ð 1;In our example, max–1is evaluated first, then the result is compared to index,and the
value of the relational expression (falseortrue) is assigned to the flagvariable.Similarly, in the followingExample:int result;result = length + 1 == limit;length+1
is evaluated first, then the result is compared to limit, and the value ofthe relational expression is assigned to the resultvariable. Since resultis an inttype, a numerical value is assigned instead of falseortrue, i.e. 0forfalseand1fortrue.It is quite common to assign a value before performing a comparison, and parenthesesmust be used in this case.Example:(result = length + 1) == limitOur example stores the result of length+1
in the variable resultand then comparesthis expression with limit.You cannot use the assignment operator =to compare two expressions. The compiler will not generatean error message if the value on the left is a variable. This mistake has caused headaches for lots of
beginners when troubleshooting their programs.NOTE

90CHAPTER 5OPERATORS FOR FUNDAMENTAL TYPES
A numeric value, such as xorx+1, is interpreted as “false” if its value is 0. Any value other than 0 isinterpreted as “true.”NOTE
LOGICAL OPERATORS
“Truth”table for logical operators
Examples for logical expressions  
truetruetrue
falsefalsetruefalsefalsefalsetruetruefalsefalsetruetruefalseABA && BA || B
truefalsetrue
falseA!A
10-10-1001falsetruetruefalsex <= y || y >=0x > -2 && y == 0x && !y!(x+1) || y - 1 > 0xyResult
Logical Expression 
LOGICAL OPERATORS91The logical operators comprise the boolean operators&&(AND),||(OR), and !(NOT).They can be used to create compound conditions and perform conditional execution of a
program depending on multiple conditions.A logical expression results in a value falseortrue, depending on whether the log-ical expression is correct or incorrect, just like a relational expression.Operands and Order of Evaluation
The operands for boolean type operators are of the booltype. However, operands of anytype that can be converted to boolcan also be used, including any arithmetic types. Inthis case the operand is interpreted as false, or converted to false, if it has a value of0. Any other value than 0is interpreted as true.TheORoperator||will return trueonly if at least one operand is true, so the valueof the expressionExample:(length < 0.2) || (length > 9.8)istrueiflengthis less than 0.2or greater than 9.8.TheANDoperator&&will return trueonly if both operands are true, so the logicalexpressionExample:(index < max) && (cin >> number)istrue, provided indexis less than maxand a number is successfully input. If the con-ditionindex<max
is not met, the program will not attempt to read a number! Oneimportant feature of the logical operators &&and||is the fact that there is a fixed orderof evaluation. The left operand is evaluated first and if a result has already been ascer-
tained, the right operand will not be evaluated!TheNOToperator!will return trueonly if its operand is false. If the variable flagcontains the value false(or the value 0),!flagreturns the boolean value true.Precedence of Boolean Operators
The&&operator has higher precedence than ||. The precedence of both these operatorsis higher than the precedence of an assignment operator, but lower than the precedence
of all previously used operators. This is why it was permissible to omit the parentheses in
the examples earlier on in this chapter.The!operator is a unary operator and thus has higher precedence. Refer to the tableof precedence in the Appendix for further details.
exercises
92CHAPTER 5OPERATORS FOR FUNDAMENTAL TYPES
// Evaluating operands in logical expressions.#include <iostream>using namespace std;
int main(){cout << boolalpha; // Outputs boolean values// as true or falsebool res = false;int y = 5;res = 7 || (y = 0);
cout << "Result of (7 || (y = 0)): " << res<< endl;cout << "Value of y: " << y << endl;int  a, b, c;a = b = c = 0;res = ++a || ++b && ++c;cout << '\n'<< "  res = " << res<< ",   a = " << a
<< ",   b = " << b<< ",   c = " << c << endl;a = b = c = 0;res = ++a && ++b || ++c;cout << "  res = " << res<< ",   a = " << a<< ",   b = " << b<< ",   c = " << c << endl;return 0;}EXERCISESProgram listing for exercise 4

EXERCISES93Exercise 1
What values do the following arithmetic expressions have?
a.3/10b.11%4c.15/2.0d.3 + 4 % 5e.3 * 7 % 4f.7 % 4 * 3Exercise 2
a.How are operands and operators in the following expression associated?
x = Ð4 * i++ Ð 6 % 4; Insert parentheses to form equivalent expressions.
b.What value will be assigned in part a to the variable 
xif the variable ihas avalue of Ð2?Exercise 3
Theintvariablexcontains the number 
7.Calculate the value of the following
logical expressions:
a.x < 10 && x >= Ð1b.!x && x >= 3c.x++ == 8 || x == 7Exercise 4
What screen output does the program on the opposite page generate?

solutions
94CHAPTER 5OPERATORS FOR FUNDAMENTAL TYPES
SOLUTIONSExercise 1
a.0b.3c.7.5d.7e.1f.9Exercise 2
a.x = ( ((Ð4) * (i++)) Ð (6 % 4) ) b.The value 
6will be assigned to the variable x.Exercise 3
a.trueb.falsec.falseExercise 4
Result of (7 || (y = 0)): trueValue of y: 5res = true,   a = 1,   b = 0,   c = 0res = true,   a = 1,   b = 1,   c = 0 
95Control Flow
This chapter introduces the statements needed to control the flow of a
program.These are
loops with while,do-while,and 
forselections with if-else,switch,and the conditional operator
jumps with goto,continue,and 
break.chapter
6
96CHAPTER 6CONTROL FLOW
// average.cpp// Computing the average of numbers#include <iostream>using namespace std;int main(){int x, count = 0;
float sum = 0.0;cout << "Please enter some integers:\n""(Break with any letter)"<< endl;while( cin >> x )
{sum += x;++count;}cout << "The average of the numbers: "<< sum / count << endl;return 0;}As long as the expression is true
statementTHEwhileSTATEMENT
Structogram for 
whileSample program
Sample output from the above program
Please enter some integers:(Break with any letter)
9  10  12q
The average of the numbers: 10.3333 
THE WHILE STATEMENT97Loops are used to perform a set of instructions repeatedly. The set of instructions to beiterated is called the loop body.C++ offers three language elements to formulate iterationstatements:while,do-while,and 
for. The number of times a loop is repeated isdefined by a controlling expression. In the case of whileandforstatements this expres-sion is verified before the loop body is executed, whereas a do-whileloop is performedonce before testing.Thewhilestatement takes the following format:Syntax:while( expression )statement       // loop bodyWhen entering the loop, the controlling expression is verified, i.e. the expressionisevaluated. If this value is true, the loop body is then executed before the controllingexpression is evaluated once more.If the controlling expression is false, i.e. expressionevaluates to false, the pro-gram goes on to execute the statement following the whileloop.It is common practice to place the loop body in a new line of the source code and toindent the statement to improve the readability of the program.Example:int count = 0;while( count < 10)cout << ++count << endl;As this example illustrates, the controlling expression is normally a boolean expression.However, the controlling expression might be any expression that can be converted to
thebooltype including any arithmetic expressions. As we already learned from the sec-tion on boolean operators, the value 0converts to falseand all other values convert totrue.Building BlocksIf you need to repeat more than one statement in a program loop, you must place thestatements in a blockmarked by parentheses { }. A block is syntactically equivalent to astatement, so you can use a block wherever the syntax requires a statement.The program on the opposite page calculates the average of a sequence of integersinput via the keyboard. Since the loops contains two statements, the statements must be
placed in a block.The controlling expression cin >> xis true provided the user inputs an integer.The result of converting the expression cin >> xto a booltype will be truefor anyvalid input and falsein any other case. Invalid input, if the user types a letter insteadof an integer, for example, terminates the loop and executes the next statement.
98CHAPTER 6CONTROL FLOW
// Euro1.cpp#include <iostream>#include <iomanip>using namespace std;int main(){double rate = 1.15;   // Exchange rate:// one Euro to one Dollarcout << fixed << setprecision(2);cout << "\tEuro \tDollar\n";
for( int euro = 1; euro <= 5; ++euro)cout << "\t " << euro<< "\t " << euro*rate << endl;return 0;}THEforSTATEMENT
Structogram for 
forSample program
Screen output
Euro    Dollar1       0.952       1.903       2.85
4       3.80
5       4.75 expression1statementexpression3As long as expression2 is true
THE FOR STATEMENT99Initializing and ReinitializingA typical loop uses a counterthat is initialized, tested by the controlling expression andreinitialized at the end of the loop.Example:int count = 1;// Initialization
while( count <= 10)// Controlling

{// expression
cout << count<< ". loop" << endl;++count;// Reinitialization
}In the case of a forstatement the elements that control the loop can be found in theloop header. The above example can also be expressed as a forloop:Example:int count;for( count = 1; count <= 10; ++count)cout << count<< ". loop" << endl;Any expression can be used to initialize and reinitialize the loop. Thus, a forloop hasthe following form:Syntax:for( expression1; expression2; expression3 )statementexpression1is executed first and only once to initialize the loop. expression2isthe controlling expression, which is always evaluated prior to executing the loop body:ifexpression2isfalse, the loop is terminatedifexpression2istrue, the loop body is executed. Subsequently, the loop isreinitialized by executing expression3andexpression2is re-tested.You can also define the loop counter in expression1. Doing so means that thecounter can be used within the loop, but not after leaving the loop.Example:for( int i = 0; i < 10; cout << i++ );As this example illustrates, the loop body can be an empty statement. This is always thecase if the loop header contains all necessary statements. However, to improve readabil-
ity, even the empty statement should occupy a line of its own.
100CHAPTER 6CONTROL FLOW
// EuroDoll.cpp// Outputs a table of exchange:  Euro and US-$#include <iostream>#include <iomanip>using namespace std;int main(){long   euro, maxEuro;     // Amount in Eurosdouble rate;              // Exchange rate Euro <-> $cout << "\n* * * TABLE OF EXCHANGE "<<  " Euro Ð US-$ * * *\n\n";cout << "\nPlease give the rate of exchange: "" one Euro in US-$: ";cin >> rate;
cout << "\nPlease enter the maximum euro: ";cin >> maxEuro;//  --- Outputs the table  ---// Titles of columns:cout << '\n'<< setw(12) << "Euro" << setw(20) << "US-$"<< "\t\tRate: " << rate << endl;// Formatting US-$:cout << fixed << setprecision(2) << endl;long lower, upper,         // Lower and upper limitstep;                 // Step width// The outer loop determines the actual// lower limit and the step width:for( lower=1, step=1; lower <= maxEuro;step*= 10, lower = 2*step)// The inner loop outputs a "block":for( euro = lower, upper = step*10;euro <= upper && euro <= maxEuro; euro+=step)cout << setw(12) << euro<< setw(20) << euro*rate << endl;return 0;}THEforSTATEMENT (CONTINUED)
Sample program

THE FOR STATEMENT (CONTINUED)101Any of the three expressions in a forstatement can be omitted, however, you must typeat least two semicolons. The shortest loop header is therefore:Example:for(;;)This statement causes an infinite loop, since the controlling expression is assumed to be
true if expression2is missing. In the followingExample:for( ; expression; )the loop header is equivalent to while(expression). The loop body is executed aslong as the test expression is true.The Comma Operator
You can use the comma operator to include several expressions where a single expressionis syntactically correct. For example, several variables can be initialized in the loop
header of a forstatement. The following syntax applies for the comma operatorSyntax:expression1, expression2 [, expression3 ...]The expressions separated by commas are evaluated from left to right.Example:int x, i, limit;for( i=0, limit=8;  i < limit;  i += 2)x = i * i,  cout << setw(10) << x;The comma operator separates the assignments for the variables iandlimitand isthen used to calculate and output the value of xin a singlestatement.The comma operator has the lowest precedence of all operators — even lower thanthe assignment operators. This means you can leave out the parentheses in the above
example.Like any other C++ expression, an expression containing the comma operator has avalue and belongs to a certain type. The type and value are defined by the last expression
in a statement separated by commas.Example:x = (a = 3, b = 5, a * b);In this example the statements in brackets are executed before the value of the product
ofa * bis assigned to x.
102CHAPTER 6CONTROL FLOW
As long as the expression is true
statement// tone.cpp#include <iostream>using namespace std;const long delay = 10000000L;int main(){int tic;cout << "\nHow often should the tone be output? ";cin >> tic;do{for( long i = 0; i < delay; ++i );cout << "Now the tone!\a" << endl;}
while( --tic > 0 );cout << "End of the acoustic interlude!\n";
return 0;}THEdo-whileSTATEMENT
Structogram for 
do-whileSample program

THE DO-WHILE STATEMENT103In contrast to whileandforloops, which are controlled by their headers, the do-whileloop is controlled by its footer, i.e. the controlling expression is evaluated afterexecuting the first loop. This results in the loop body being performed at least once.Syntax:dostatementwhile( expression);When a do-whileloop is executed, the loop body is processed first. Only then is thecontrollingexpressionevaluated. The loop body is iterated again if the result istrue, otherwise the loop is terminated.Thedo-whileloop must be followed by a semicolon.NOTE
Nesting LoopsLoops can be nested, that is, the loop body can also contain a loop. The ANSI standardstipulates a maximum depth of 256 nested loops.The program on the opposite page outputs a number of tones with the number beingdefined by user input.The program contains two loops — one of which is nested in the other. Each time theouterdo-whileloop is repeated a short break occurs. The break is caused by the innerforloop where the variable iis incremented from 0to the value of delay.Text and a tone are subsequently output. The tone is generated by outputting thecontrol character BELL (ASCII code 7), which is represented by the escape sequence\a.Since a do-whilestatement is used, the program outputs a tone even if the usertypes0or a negative number.
104CHAPTER 6CONTROL FLOW
truefalse
statement1statement2
if (expression)// if_else.cpp// Demonstrates the use of if-else statements#include <iostream>using namespace std;int main(){float x, y, min;cout << "Enter two different numbers:\n";if( cin >> x && cin >> y)  // If both inputs are{                          // valid, computeif( x < y )              // the lesser.min = x;elsemin = y;cout << "\nThe smaller number is: " << min << endl;}
elsecout << "\nInvalid Input!" << endl;return 0;}SELECTIONS WITH if-elseStructogram for the 
if-elsestatement
Sample program
Sample output for this program
Enter two different numbers:7.5  5.7
The smaller number is: 5.7 
SELECTIONS WITH IF-ELSE 105Theif-elsestatement can be used to choose between two conditional statements.Syntax:if( expression )statement1[ elsestatement2 ]When the program is run, expressionis first evaluated and the program controlbranches accordingly. If the result is true,statement1is executed and statement2is executed in all other cases, provided an elsebranch exists. If there is no elseandexpressionisfalse, the control jumps to the statement following the ifstatement.Nestedif-elseStatements
As the program opposite illustrates, multiple if-elsestatements can be nested. Butnot every ifstatement has an elsebranch. To solve the resulting problem, an elsebranch is always associated with the nearest preceding ifstatement that does not haveanelsebranch.Example:if( n > 0 )if( n%2 == 1 )cout << " Positive odd number ";elsecout << "Positive even number";In this example, the elsebranch belongs to the second if, as is indicated by the factthat the statement has been indented. However, you can use a code block to redefine the
association of an elsebranch.Example:if( n > 0 ){  if( n%2 == 1 )cout << " Positive odd number \n";}
elsecout << " Negative number or zero\n";Defining Variables in 
ifStatements
You can define and initialize a variable within an ifstatement. The expression is true ifconverting the variable’s value to a booltype yields true. In this case the variable isavailable within the ifstatement.Example:if( int x = func() ){ . . . }           // Here to work with x.The return value of the function, func(), is used to initialize the variable x. If thisvalue is not 0, the statements in the next block are executed. The variable xno longerexists after leaving the ifstatement.
106CHAPTER 6CONTROL FLOW
if(expression)if(expression)if(expression)truefalse
truetruefalse
falsestatement1statement(n)statement(n+1)
statement2. . .// speed.cpp// Output the fine for driving too fast.#include <iostream>using namespace std;int main(){float limit, speed, toofast;cout << "\nSpeed limit: ";cin >> limit;
cout << "\nSpeed: ";cin >> speed;if( (toofast = speed Ð limit ) < 10)cout << "You were lucky!" << endl;else if( toofast < 20)cout << "Fine payable: 40,-. Dollars" << endl;else if( toofast < 30)cout << "Fine payable: 80,-. Dollars" << endl;elsecout << "Hand over your driver's license!" << endl;return 0;}Else-ifCHAINSStructogram for an 
else-ifchainSample program

ELSE-IF CHAINS107Layout and Program Flow
You can use an else-ifchain to selectively execute one of several options. An else-ifchain implies a series of embedded if-elsestatements whose layout is normally asfollows:if ( expression1 )statement1else if( expression2 )statement2.
.
.else if( expression(n) )statement(n)[ else statement(n+1)] When the else-ifchain is executed, expression1,expression2,...areevaluated in the order in which they occur. If one of the expressions proves to be true,
the corresponding statement is executed and this terminates the else-ifchain.If none of the expressions are true, the elsebranch of the last ifstatement is exe-cuted. If this elsebranch is omitted, the program executes the statement following theelse-ifchain.The Sample Program
The program opposite uses an else-ifchain to evaluate the penalty for driving too fastand outputs the fine on screen.The speed limit and the actual speed are read from the keyboard. If the user types 60as the speed limit and 97.5 as the actual speed, the first three expressions are not true,
and the last elsebranch is executed. This outputs the message "Hand over yourdriver's license!"on a new line.
108CHAPTER 6CONTROL FLOW
truefalse
expression1expression2
expression// greater.cpp#include <iostream>
using namespace std;int main(){float x, y;cout << "Type two different numbers:\n";if( !(cin >> x && cin >> y) ) // If the input was{                             // invalid.cout << "\nInvalid input!" << endl;}
else{cout << "\nThe greater value is: "<<(x > y ? x : y)<< endl;}return 0;}CONDITIONAL EXPRESSIONSStructogram for a conditional expression
Sample program
Sample output for this program
Type two different numbers:173.2
216.7
The greater value is: 216.7 
CONDITIONAL EXPRESSIONS109Conditional Operator
The conditional operator ?:is used to form an expression that produces either of twovalues, depending on the value of some condition. Because the value produced by such
an expression depends on the value of a condition, it is called conditional expression.In contrast to the if-elsestatement the selection mechanism is based on expres-sions: one of two possible expressions is selected. Thus, a conditional expression is often
a concise alternative to an if-elsestatement.Syntax:expression ? expression1 : expression2expressionis evaluated first. If the result is true,expression1is evaluated; if notexpression2is executed. The value of the conditional expression is therefore eitherthe value of expression1orexpression2.Example:z = (a >= 0) ? a : -a;This statement assigns the absolute value of ato the variable z. If ahas a positive valueof12, the number 12is assigned to z. But if ahas a negative value, for example Ð8, thenumber8is assigned to z.Since this sample program stores the value of the conditional expression in the vari-ablez, the statement is equivalent toif( a > 0 )z = a;elsez = -a; Precedence
The conditional operator is the only C++ operator with three operands. Its precedence ishigher than that of the comma and assignment operators but lower than all other opera-
tors. In other words, you could omit the brackets in the first example.You can use the result of a conditional evaluation without assigning it, as the sampleprogram on the opposite page shows. In this example, xis printed on screen if xisgreater than y, and yis printed otherwise.However, you should assign the result of complex expressions to a variable explicitlyto improve the readability of your program.
110CHAPTER 6CONTROL FLOW
case Const1:case Const2:statementsbreakstatementsbreakstatementsbreakdefault:. . .switch(expression)// Evaluates given input.int command = menu();      // The function menu() reads// a command.switch( command )          // Evaluate command.{case 'a':case 'A':action1();        // Carry out 1st action.break;case 'b':
case 'B':action2();        // Carry out 2nd action.break;default:cout << '\a' << flush; // Beep on}                                  // invalid input SELECTING WITH switchStructogram for the 
switchstatement
Example
SELECTING WITH SWITCH 111TheswitchStatement
Just like the else-ifchain, the switchstatement allows you to choose between mul-tiple alternatives. The switchstatement compares the value of oneexpression withmultiple constants.switch( expression ){case const1: [ statement ][ break; ]case const2: [ statement ][ break; ].
.
.[default:  statement ]}First, the expressionin the switchstatement is evaluated. It must be an integraltype. The result is then compared to the constants, const1,const2,..., in the caselabels. The constants must be different and can only be integral types (boolean values
and character constants are also integral types).If the value of an expression matches one of the caseconstants, the programbranches to the appropriate case label. The program then continues and the caselabelslose their significance.You can use breakto leave the switchstatement unconditionally. The statement isnecessary to avoid executing the statements contained in any caselabels that follow.If the value of the expression does not match any of the caseconstants, the programbranches to the defaultlabel, if available. If you do not define a defaultlabel, noth-ing happens. The defaultdoes not need to be the last label; it can be followed by addi-tionalcaselabels.Differences between 
switchandelse-ifChainsTheelse-ifchain is more versatile than the switchstatement. Every selection canbe programmed using an else-ifchain. But you will frequently need to compare thevalue of an integral expression with a series of possible values. In this case (and only this
case), you can use a switchstatement.As the example opposite shows, a switchstatement is more easily read than anequivalentelse-ifchain, so use the switchstatement whenever possible.
112CHAPTER 6CONTROL FLOW
As long as expression is true
break;statement, which follows the loop.
// ascii.cpp : To output an ASCII Code Table#include <iostream>
#include <iomanip>using namespace std;int main(){int ac = 32;          // To begin with ASCII Code 32// without control characters.while(true){ cout << "\nCharacter   Decimal   Hexadecimal\n\n";int upper;for( upper =ac + 20; ac < upper && ac < 256; ++ac)cout << "      " << (char)ac     // as character<< setw(10) << dec << ac<< setw(10) << hex << ac << endl;if( upper >= 256)   break;
cout <<"\nGo on -> <return>,Stop -> <q>+<return>";char answer;cin.get(answer);if( answer == 'q' || answer == 'Q' )break;cin.sync();            // Clear input buffer}return 0;}The expression (char)acyields the value acof type char.NOTE
JUMPS WITH break,continue,AND 
gotoStructogram for 
breakwithin a whilestatement
Sample program containing a 
breakstatement

JUMPS WITH BREAK, CONTINUE, AND GOTO 113breakThebreakstatement exits from a switchor loop immediately. You can use the breakkeyword to jump to the first statement that follows the switchor loop.The program on the opposite page, which outputs a group of 20 ASCII characters andtheir corresponding codes, uses the breakkeyword in two places. The first breakexitsfrom an infinite while(true) { ... }loop when a maximum value of 256 has beenreached. But the user can also opt to continue or terminate the program. The secondbreakstatement is used to terminate the whileloop and hence the program.continueThecontinuestatement can be used in loops and has the opposite effect to break,that is, the next loop is begun immediately. In the case of a whileordo-whileloopthe program jumps to the test expression, whereas a forloop is reinitialized.Example:for( int i = 0; i < 100; i++ ){. . .  // Processes all integers.
if( i % 2 == 1)continue;. . .              // Process even// numbers only.}gotoand LabelsC++ also offers a gotostatement and labels. This allows you to jump to any given pointmarked by a label within a function. For example, you can exit from a deeply embedded
loop construction immediately.Example:for( . . . )for( . . . )if (error) goto errorcheck;. . .errorcheck: . . .       // Error handlingAlabelis a name followed by a colon. Labels can precede any statement.Any program can do without gotostatements. If you need to use a gotostatement,do so to exit from a code block, but avoid entering code blocks by this method.
exercises
114CHAPTER 6CONTROL FLOW
12345678910
12
3
4
5
6
7
8
910121024203630..
...
...
.1020100..
..           .           .            .           .            
..           .           .            .           .            
.************
MULTIPLICATION TABLE
EXERCISESScreen output for exercise 2
Note on exercise 4
Use the function time()to initialize the random number generator:
#include <time.h>       // Prototype of time()#include <stdlib.h>     // Prototypes of srand()// and rand()long sec;
time( &sec );           // Take the number of seconds and
srand( (unsigned)sec ); // use it to initialize. 
EXERCISES115Use the system time to seed the random number generator as shown opposite. The time()functionreturns the number of seconds since 1/1/1970, 0:0. The longvalue of the secvariable is converted tounsignedbyunsigned(sec)and then passed to the srand()function.NOTE
Exercise 1
Rewrite the 
EuroDoll.cppprogram in this chapter to replace both the 
forloops with whileloops.Exercise 2
Write a C++ program that outputs a complete multiplication table (as shown
opposite) on screen.
Exercise 3
Write a C++ program that reads an integer between 0 and 65535 from the

keyboard and uses it to seed a random number generator.Then output 20

random numbers between 1 and 100 on screen.
Exercise 4
Write a program for the following numerical game:
The computer stores a random number between 1 and 15 and the player 
(user) attempts to guess it.The player has a total of three attempts.After each

wrong guess,the computer tells the user if the number was too high or too low.

If the third attempt is also wrong,the number is output on screen.
The player wins if he or she can guess the number within three attempts.
The player is allowed to repeat the game as often as he or she wants.

solutions
116CHAPTER 6CONTROL FLOW
SOLUTIONSExercise 1
Theforloops of program 
EuroDoll.cppare equivalent to the following 
whileloops:// The outer loop sets the lower// limit and the step width used:lower=1, step=1;while( lower <= maxEuro)
{// The inner loop outputs a block:euro = lower;upper = step*10;
while( euro <= upper && euro <= maxEuro){cout << setw(12) << euro<< setw(20) << euro*rate << endl;euro += step;}step *= 10, lower = 2*step;}Exercise 2
//  MultTable.cpp
//  Outputs a multiplication table.#include <iostream>#include <iomanip>
using namespace std;int main(){int  factor1, factor2;cout << "\n\n            "<< "  ******  MULTIPLICATION TABLE  ******"
<< endl;//  Outputs the first and second line:cout << "\n\n\n        ";                 // 1. line
for( factor2 = 1 ; factor2 <= 10 ; ++factor2 )cout << setw(5) << factor2;cout << "\n        "                      // 2. line<< "-------------------------------------------"<< endl;
SOLUTIONS117//  Outputs the remaining lines of the table:for( factor1 = 1 ; factor1 <= 10 ; ++factor1 ){cout << setw(6) << factor1 << " |";
for( factor2 = 1 ; factor2 <= 10 ; ++factor2 )cout << setw(5) << factor1 * factor2;cout << endl;}
cout << "\n\n\n";            // To shift up the tablereturn 0;}Exercise 3
// random.cpp
// Outputs 20 random numbers from 1 to 100.#include <stdlib.h>   // Prototypes of srand() and rand()#include <iostream>
#include <iomanip>
using namespace std;int main(){unsigned int  i, seed;cout << "\nPlease type an integer between ""0 and 65535: ";cin >> seed;     // Reads an integer.srand( seed);    // Seeds the random// number generator.cout << "\n\n            ""******   RANDOM NUMBERS   ******\n\n";for( i = 1 ; i <= 20 ; ++i)cout << setw(20) << i << ". random number = "<< setw(3)  << (rand() % 100 + 1) << endl;return 0;}
118CHAPTER 6CONTROL FLOW
Exercise 4
//  NumGame.cpp  :  A numerical game against the computer#include <cstdlib>    // Prototypes of srand() and rand()#include <ctime>      // Prototype of time()
#include <iostream>
using namespace std;int main(){int  number, attempt;char wb = 'r';            // Repeat or finish.long sec;
time( &sec);              // Get the time in seconds.srand((unsigned)sec);     // Seeds the random// number generatorcout << "\n\n          "<< " *******   A NUMERICAL GAME   *******" << endl;cout << "\n\nRules of the game:" << endl;
while( wb == 'r')
{cout << "I have a number between 1 and 15 in mind \n"<< "You have three chances to guess correctly!\n"
<< endl;number = (rand() % 15) + 1;
bool found = false;     int count = 0;while( !found  && count < 3 ){cin.sync();             // Clear input buffer
cin.clear();cout << ++count << ". attempt:   ";cin >> attempt;
if(attempt < number)   cout << "too small!"<< endl;
else if(attempt > number) cout <<"too big!"<< endl;else                    found = true;}
if( !found)cout << "\nI won!"<< " The number in question was: "
<< number << endl;elsecout << "\nCongratulations! You won!" << endl;cout << "Repeat Ñ> <r>    Finish Ñ> <f>\n";
docin.get(wb);while( wb != 'r' &&  wb != 'f');}return 0;}
119Symbolic Constants andMacrosThis chapter introduces you to the definition of symbolic constants and
macros illustrating their significance and use.In addition,standard macros

for character handling are introduced.
chapter
7
120CHAPTER 7SYMBOLIC CONSTANTS AND MACROS
// sintab.cpp// Creates a sine function table#include <iostream>#include <iomanip>#include <cmath>using namespace std;#define PI        3.1415926536#define START     0.0// Lower limit#define END     (2.0 * PI)// Upper limit#define STEP  (PI / 8.0)// Step width#define HEADER   (cout << \"  *****  Sine Function Table *****\n\n")int main(){HEADER;                        // Title// Table Head:cout << setw(16) << "x" << setw(20) << "sin(x)\n"<< "   -----------------------------------------"
<< fixed << endl;double x;for( x = START; x < END + STEP/2; x += STEP)cout << setw(20) << x << setw(16) << sin(x)<< endl;cout << endl << endl;return 0;}MACROS
Sample program
Screen output
******  Table for the Sine Function  ******x                  sin(x)--------------------------------------------0.000000             0.000000
0.392699             0.382683
0.785398             0.707107.                    .
.                    .
.                    . 
MACROS121C++ has a simple mechanism for naming constants or sequences of commands, that is fordefiningmacros. You simply use the preprocessor’s #definedirective.Syntax:#define  name  substitutetextThis defines a macro called name. The preprocessor replaces namewithsubstitute-textthroughout the subsequent program. For example, in the program on the oppositepage, the name PIis replaced by the number 3.1415926536throughout the programin the first phase of compilation.There is one exception to this general rule: substitution does not take place withinstrings. For example, the statementcout << "PI"; outputs only PIand not the numerical value of PI.Symbolic ConstantsMacros that are replaced by constants, such as the PImacro, are also known as symbolicconstants. You should note that neither an equals sign nor a semicolon is used, as thesewould become part of the substitute text.You can use any macros you have previously defined in subsequent #definedirec-tives. The program opposite uses the symbolic constant PIto define other constants.More about Working with Macros
Any preprocessor directive, and this includes the #definedirective, must be placed in aline of its own. If the substitute text is longer than one line, you can terminate the line
with a backslash \and continue the substitute text in the next line, as is illustrated bythe macro HEADERon the opposite page.The rules that apply to naming variables also apply to naming macros. However, it isstandard practice to capitalize symbolic constants to distinguish them from the names of
variables in a program.Using macros makes a C++ program more transparent and flexible. There are twomain advantages:1.good readability:You can name a macro to indicate the use of the macro2.easy to modify:If you need to change the value of a constant throughout a pro-gram, you simply change the value of the symbolic constant in the #definedirective.
122CHAPTER 7SYMBOLIC CONSTANTS AND MACROS
//  ball1.cpp//  Simulates a bouncing ball// ---------------------------------------------------#include <iostream>
#include <string>using namespace std;#define DELAY  10000000L           // Output delay#define CLS   (cout << "\033[2J") // Clear screen#define LOCATE(z,s) (cout <<"\033["<< z <<';'<< s <<'H')// Position the cursor in row z and column svoid main(){int x = 2, y = 3, dx = 1, speed = 0;
string floor(79, '-'),header = "****  JUMPING BALL  ****";CLS;LOCATE(1,25);  cout << header;LOCATE(25,1);  cout << floor;while(true)      // Let the ball "always" bounce{                // Terminate by interrupt key (^C)LOCATE(y,x);  cout << 'o' << endl; // Show the ballfor( long wait = 0; wait < DELAY; ++wait);if(x == 1 || x == 79) dx = -dx;   // Bounce off// a wall?if( y == 24 )                     // On the floor?{speed = - speed;
if( speed == 0 ) speed = -7;    // Restart}speed += 1;                  // Acceleration = 1LOCATE(y,x); cout <<  ' ';   // Clear outputy += speed;  x += dx;        // New Position}}MACROS WITH PARAMETERS
Sample program

MACROS WITH PARAMETERS1231These escape sequences are valid for all standard UNIX terminals. The driver ansi.sysmust beloaded for DOS or a DOS box in Win95 or Win98. For Win NT and Win 2000, corresponding
functions based on system calls are offered for download.It is possible to call macros with arguments. To do so, you must supply the appropriateparameters when defining the macro. The parameters are replaced by valid arguments at
run time.Example:#define SQUARE(a)   ((a) * (a))This defines a macro called SQUARE()with a parameter a. The name of the macro mustbe followed immediately by a left bracket. When the macro is called, for exampleExample:z = SQUARE(x+1);the preprocessor inserts the substitute text with the current arguments, which will beexpandedas follows, in this casez = ((x+1) * (x+1)); This example also shows that you must be careful when using brackets to indicate param-eters for macros. Omitting the brackets in the previous example, SQUARE, would causethe expression to be expanded as follows z = x + 1 * x + 1.The outer brackets in the definition ensure that even when the macro is used in acomplex expression, the square is calculated before the result can be used for any further
calculations.Macros for Screen Control
The program opposite uses macros to change the appearance of the screen. Peripheraldevices, such as the screen or printers, can be controlled by special character sequences
that normally begin with the ESC character (decimal 27, octal 033) and are thus knownasescape sequences. A number of ANSI standard escape sequences exists for screen con-trol.1See the appendix on Escape Sequences for Screen Control for an overview of themost important sequences.CLSis a macro without any parameters that uses the escape sequence \033[2Jtoclear the screen. LOCATEis just one example of a macro with two parameters. LOCATEuses the escape sequence \033[z;sHto place the cursor at the position of the nextscreen output. The values zfor the line and sfor the column require decimal input withz=1,s = 1representing the top left corner of the screen or window.The ball is “thrown in” at the coordinates x = 2,y = 3and bounces off the “floor”and the “walls.” In direction x (horizontally) the ball has a constant speed of dx = 1or-1. In direction y (vertically) the ball is subject to a constant acceleration of 1,expressed as speed += 1.
124CHAPTER 7SYMBOLIC CONSTANTS AND MACROS
#include "proj.h"..
.#include "proj.h"...#include "proj.h"......Header file proj.hMacrosClassesand other typedefinitionsPrototypes ofglobal functionsSourcefile 1Sourcefile 2Sourcefile nWORKING WITH THE 
#defineDIRECTIVEUsing macros in different source files

WORKING WITH THE #DEFINE DIRECTIVE125You can place the #definedirective in any line of a program as long as it is placed priorto using the macro. However, it is recommended to place all definitions at the beginning
of the source file for ease of location and modification.If you need to use the same macros in different source files, it makes sense to create aheader file. You can then include the header file in your source files. This method also
lends itself to large-scale software projects. The programmers working on the project
then have access to the same set of macro definitions and other declarations. This con-
cept is illustrated opposite using the header file proj.has an example.Macros with parameters can be called just like functions. You should note the follow-ing important differences, however:Macros: A macro definition must be visibleto the compiler. The substitute text isinserted and re-compiled each time the macro is called. For this reason, a macro
should contain only a few statements to avoid inflating the object file each time
the macro is called. The speed of program execution will, however, improve since
the program does not need to branch to sub-routines in contrast to normal func-
tion calls. This can become apparent when macros are used within loops, for
example.Side effects of macros are possible if the substitute text contains multipleinstances of a parameter. The statement SQUARE( ++x )expands to ((++x)* (++x)), for example. The variable xis incremented twice and the productdoes not represent the square of the incremented number.Functions: Functions are compiled independently. The linker then links theminto the executable file. The program branchesto the function whenever it iscalled, and this can reduce the speed of execution in comparison to a macro.
However, the executable file will be shorter as it contains only one instance of
the function code.The compiler checks the argument types, and the side effects seen withmacros cannot occur.Inlinefunctions, which are introduced in the chapter on functions, are an alterna-tive to macros.
126CHAPTER 7SYMBOLIC CONSTANTS AND MACROS
Header filebasis.hSource fileapplication.cppHeader filestatist.hHeader filegraph.h#include <iostream>#include "basis.h"#ifndef_BASIS_H_#define_BASIS_H_#define BSIZE 1000#endif//content of basis,//ex.. . .. . .#include <iostream>#include "basis.h". . .#include "statist.h"#include "graph.h"int main(){   return 0;}. . .CONDITIONAL INCLUSIONMultiple inclusions of header files
CONDITIONAL INCLUSION127Redefining Macros
A macro cannot simply be redefined. A macro definition is valid until it is removed byusing an #undefdirective. However, you do not need to supply the parameter list of amacro with parameters.Example:#define MIN(a,b)  ((a)<(b)? (a) : (b)). . . // Here MIN can be called
#undef MINThe macro MINcannot be used after this point, but it can be defined again, possibly witha different meaning, using the #definedirective.Conditional InclusionYou can use the preprocessor directives #ifdefand#ifndefto allow the compiler tocheck whether a macro has been defined.Syntax:#ifdef name. . .  // Block, which will be compiled
// if name is defined.#endifIn the case of the #ifndefdirective, the code block is compiled up to the next #endifonly if the macro namehasnotbeen previously defined.On conditional inclusion elsebranching and nesting is also permissible. See Pre-processor Directivesin the appendix for further information.A macro definition does not need to include a substitute text to be valid.Example:#define MYHEADERA symbol without a substitute text is often used to identify header files and avoid multi-
ple inclusion.If you have a header file named "article.h", you can identify the header by defin-ing a symbol, such as _ARTICLE_, within that file.Example:#ifndef _ARTICLE_#define _ARTICLE_. . . // Content of the header file
#endifIf you have already included the header, _ARTICLE_will already be defined, and thecontents of the header file need not be compiled. This technique is also employed by
standard header files.
128CHAPTER 7SYMBOLIC CONSTANTS AND MACROS
//  toupper.cpp: A filter that converts to capitals.//  ---------------------------------------------------#include <iostream>#include <cctype>
using namespace std;int main(){char c;long nChar = 0,         // Counts all charactersnConv = 0;         // and converted characterswhile ( cin.get(c) )    // As long as a character
{  ++nChar;             // can be read, to increment.if( islower(c))      // Lowercase letter?{ c = toupper(c);    // Converts the character++nConv;           // and counts it.}cout.put(c);         // Outputs the character.}clog << "\nTotal of characters:     " << nChar<< "\nTotal of converted characters: " << nConv
<< endl;return 0;}The program reads characters from a file until end-of-file. When reading keyboard input, end-of-file issimulated by Ctrl+Z (DOS) or Ctrl+D (UNIX).NOTE
STANDARD MACROS FOR CHARACTER MANIPULATION
Sample program
Macros for character classification
isalpha(c)islower(c)
isupper(c)
isdigit(c)
isalnum(c)
isspace(c)isprint(c)cis a lettercis a small lettercis a capital lettercis a decimal digitcis a letter or a digitcis a space lettercis a printable letterMacroReturn value 
true means:
STANDARD MACROS FOR CHARACTER MANIPULATION129The following section introduces macros that classify or convert single characters. Themacros are defined in the header files ctype.handcctype.Case Conversion
You can use the macro toupperto convert lowercase letters to uppercase. If c1andc2are variables of type charorintwherec1contains the code for a lowercase letter, youcan use the following statementExample:c2 = toupper(c1);to assign the corresponding uppercase letter to the variable c2. However if c1is not alowercase letter, toupper(c1)returns the character “as is.”The sample program on the opposite page reads standard input, converts any lettersfrom lower- to uppercase, and displays the letters. As toupperonly converts the lettersof the English alphabet by default, any national characters, such as accentuated charac-
ters in other languages, must be dealt with individually. A program of this type is known
as a filterand can be applied to files. Refer to the next section for details.The macro toloweris available for converting uppercase letters to lowercase.Testing Characters
A number of macros, all of which begin with is..., are available for classifying charac-ters. For example, the macro islower(c)checks whether ccontains a lowercase letterreturning the value true, in this case, and falsein all other cases.Example:char c;  cin >> c;      // Reads and// classifiesif( !isdigit(c) )       // a character.cout << "The character is no digit \n";The following usage of islower()shows a possible definition of the toupper()macro:Example:#define toupper(c) \(islower(c) ? ((c)-'a'+'A') : (c))This example makes use of the fact that the codes of lower- and uppercase letters differby a constant, as is the case for all commonly used character sets such as ASCII and
EBCDIC.The opposite page contains an overview of macros commonly used to classify char-acters.

130CHAPTER 7SYMBOLIC CONSTANTS AND MACROS
// lines.cpp// A filter that numbers lines.#include <iostream>#include <iomanip>
#include <string>
using namespace std;int main(){string line;int number = 0;while( getline( cin, line))   // As long as a line{                             // can be read.cout << setw(5) << ++number << ": "<< line << endl;}
return 0;}REDIRECTING STANDARD INPUT AND OUTPUT
Sample program
How to call the program
1.Redirecting the standard input:
lines < text.dat | moreThis outputs the text file text.datwith line numbers. In addition, the datastream is sent to the standard filter more, which pauses screen output if the pageis full.2.Redirecting the standard output:
lines > new.dat Here the program reads from the keyboard and adds the output to the new filenew.dat. Please note, if the file already exists, it will be overwritten!You can uselines >> text.dat toappendprogram output to the file text.dat. If the file text.datdoes notalready exist, it will be created.Type Ctrl+Z (DOS) or Ctrl+D (UNIX) to terminate keyboard input.
REDIRECTING STANDARD INPUT AND OUTPUT131These examples assume that the compiled program lines.exeis either in the current directory or ina directory defined in your system’s PATH variable.NOTE
Filter Programs
The previous program, toupper.cpp, reads characters from standard input, processesthem, and sends them to standard output. Programs of this type are known as filters.In the program toupper.cpp, the loopwhile( cin.get(c)) { ... } is repeated while the test expression cin.get(c)yields the value true, that is, as longas a valid character can be read for the variable c. The loop is terminated by end-of-fileor if an error occurs since the test expression cin.get(c)will then be false.The program on the opposite page, lines.cpp, is also a filter that reads a text andoutputs the same text with line numbers. But in this case standard input is read line by
line.while( getline(cin,line)) { ... } The test expression getline(cin,line)istruewhile a line can be read.Using Filter Programs
Filter programs are extremely useful since various operating systems, such as DOS,Win**, WinNT, and UNIX are capable of redirecting standard input and output. This
allows easy data manipulation.For example, if you need to output text.datwith line numbers on screen, you canexecute the program linesby typing the following command:Example:lines < text.datThis syntax causes the program to read data from a file instead of from the keyboard. In
other words, the standard input is redirected.The opposite page contains additional examples. You can redirect input and outputsimultaneously:Example:lines < text.dat > new.datIn this example the contents of text.datand the line numbers are stored in new.dat.The program does not generate any screen output.
exercises
132CHAPTER 7SYMBOLIC CONSTANTS AND MACROS
When a function key, such as F1, F2, ..., Ins, Del, etc. was pressed, the functiongetch()initially returns 0. A second call yields the key number.NOTE
EXERCISESHints for Exercise 2
You can use the function 
kbhit()to test whether the user has pressed a key.If
so,the function 
getch()can be used to read the character.This avoids
interrupting the program when reading from the keyboard.
These functions have not been standardized by ANSI but are available on
almost every system.Both functions use operating system routines and are

declared in the header file 
conio.h.The function kbhit()Prototype
:int kbhit();Returns:0,if no key was pressed,otherwise 
!= 0.When a key has been pressed,the corresponding character can be read by
getch().The function getch()Prototype
:int getch();Returns:The character code.There is no special return value on reaching
end-of-file or if an error occurs.
In contrast to cin.get(),getch()does not use an input buffer when
reading characters,that is,when a character is entered,it is passed directly to

the program and not printed on screen.Additionally,control characters,such as

return ( = 13),Ctrl+Z ( = 26),and Esc ( = 27),are passed to the program “as is.”
Example:int c;if( kbhit() != 0)  // Key was pressed?
{c = getch();    // Yes -> Get character
if( c == 27 )   // character == Esc?
// . . .}
EXERCISES133Since the program must not immediately output a single character following a control character, you willneed to store the predecessor of this character. You may want to use two counters to count thenumber of characters and control characters in the current string.NOTE
Exercise 1
Please writea.the macro 
ABS,which returns the absolute value of a number,
b.the macro 
MAX,which determines the greater of two numbers.
In both cases use the conditional operator ?:.Add these macros and other macros from this chapter to the header file
myMacros.hand then test the macros.
If your system supports screen control macros,also add some screen control
macros to the header.For example,you could write a macro named
COLOR(f,b)to define the foreground and background colors for the following
output.Exercise 2
Modify the program 
ball1.cpptoa.display a white ball on a blue background,
b.terminate the program when the Esc key is pressed,

c.increase the speed of the ball with the + key and decrease the speed
with the – key.
You will need the functions 
kbhit()andgetch()(shown opposite) to solve
parts b and c of this problem.
Exercise 3
Write a filter program to display the text contained in any given file.The

program should filter any control characters out of the input with the exception

of the characters \n(end-of-line) and \t(tabulator),which are to be treated as
normal characters for the purpose of this exercise.Control characters are

defined by codes 
0to31.A sequence of control characters is to be represented by a single space
character.
A single character,that is,a character appearing between two control
characters,is not to be output!

solutions
134CHAPTER 7SYMBOLIC CONSTANTS AND MACROS
SOLUTIONSExercise 1
// ------------------------------------------------------// myMacros.h
// Header file contains the Macros// ABS, MIN, MAX, CLS, LOCATE, COLOR, NORMAL, INVERS
// and symbolic constants for colors.// ------------------------------------------------------#ifndef _MYMACROS_
#define _MYMACROS_#include <iostream>using namespace std;// ------------------------------------------------------// Macro ABS// Call:  ABS( val)
// Returns the absolute value of val#define ABS(a) ( (a) >= 0 ? (a) : -(a))// ------------------------------------------------------// Macro MIN// Call:  MIN(x,y)
// Returns the minimum of x and y
#define MIN(a,b) ( (a) <= (b) ? (a) : (b))// ------------------------------------------------------// Macro MAX// Call:  MAX(x,y)// Returns the maximum of x and y
#define MAX(a,b) ( (a) >= (b) ? (a) : (b))// ------------------------------------------------------// Macros for controlling the screen
// ------------------------------------------------------// Macro CLS// Call:  CLS;
// Clears the screen#define CLS   (cout << "\033[2J")// ------------------------------------------------------// Macro LOCATE// Call:  LOCATE(row, column);// Positions the cursor to (row,column).
// (1,1) is the upper left corner.
#define LOCATE(r,c) (cout <<"\033["<< (r) <<';'<<(c)<<'H')
SOLUTIONS135// ------------------------------------------------------// Macro COLOR
// Call:  COLOR(foreground, background);// Sets the foreground and background color// for the following output.
#define COLOR( f, b) (cout << "\033[1;3"<< (f) \<<";4"<< (b) <<'m' << flush)//  1: light foreground
// 3x: foreground x// 4x: background x// Color values for the macro COLOR// To call ex.: COLOR( WHITE,BLUE);#define BLACK  0#define RED      1
#define GREEN    2#define YELLOW   3#define BLUE     4
#define MAGENTA  5#define CYAN     6#define WHITE    7// ------------------------------------------------------// Macro INVERS
// Call:  INVERS;
// The following output is inverted.#define INVERS  (cout << "\033[7m")// ------------------------------------------------------// Macro NORMAL// Call:  NORMAL;
// Sets the screen attributes on default values.#define NORMAL  (cout << "\033[0m")#endif     //  _MYMACROS_ Exercise 2
// ---------------------------------------------------//  ball2.cpp
//  Simulates a bouncing ball// ---------------------------------------------------#include <iostream>#include <string>using namespace std;
#include <conio.h>             // For kbhit() and getch()
#include "myMacros.h"
136CHAPTER 7SYMBOLIC CONSTANTS AND MACROS
#define  ESC   27          // ESC terminates the programunsigned long delay = 5000000;         // Delay for outputint main(){int x = 2, y = 2, dx = 1, speed = 0;bool end = false;string floor(80, '-'),header   = "****  BOUNCING BALL ****",
commands = "[Esc] = Terminate     ""[+] = Speed up     [-] = Slow down";COLOR(WHITE,BLUE);    CLS;LOCATE(1,25);  cout << header;
LOCATE(24,1);  cout << floor;
LOCATE(25,10); cout << commands;while( !end)          // As long as the flag is not set{LOCATE(y,x);  cout << 'o';         // Show the ballfor( long wait = 0; wait < delay; ++wait);if(x == 1 || x == 79) dx = -dx;  // Bounce off a wall?if( y == 23 )                       // On the floor?
{speed = - speed;if( speed == 0 ) speed = -7;      // Kick}
speed += 1;                         // Speed up = 1LOCATE(y,x); cout <<  ' ';          // Clear screeny += speed;  x += dx;               // New positionif( kbhit() != 0 )                  // Key pressed?{switch(getch())                  // Yes{case '+':  delay -= delay/5;   // Speed upbreak;case '-':  delay += delay/5;   // Slow downbreak;case ESC:  end = true;         // Terminate}}}
NORMAL;  CLS;return 0;}
SOLUTIONS137Exercise 3
// ---------------------------------------------------//  NoCtrl.cpp
//  Filter to ignore control characters
//  To call e.g.:  NoCtrl < file
// ---------------------------------------------------#include <iostream>using namespace std;#define isCtrl(c)    ( c >= 0  &&  c <= 31  \&& c != '\n' && c != '\t')int main(){char c, prec = 0;           // Character and predecessor
long nCtrl = 0, nChar = 0;  // Number of the following// control characters or
// other characterswhile( cin.get(c))
{if( isCtrl(c))            // Control characters
{++nCtrl;nChar = 0;}
else                      // Normal character
{if( nCtrl > 0)
{cout.put(' ');
nCtrl = 0;}
switch( ++nChar)
{case 1:   break;
case 2:   cout.put(prec);   // Predecessor and
default:  cout.put(c);      // current character}
prec = c;}}
return 0;}
This page intentionally left blank 
139Converting Arithmetic
Types
This chapter introduces implicit type conversions,which are performed in
C++ whenever different arithmetic types occur in expressions.
Additionally,an operator for explicit type conversion is introduced.
chapter
8
140CHAPTER 8CONVERTING ARITHMETIC TYPES
IMPLICIT TYPE CONVERSIONS
Integer promotions
boolshortchar, signed char, unsigned charintintunsigned intunsigned shortifint equals longifint equals shortType hierarchy
Exampleshort size(512);  double res, x = 1.5;res = size / 10 * x;    // short -> int -> doubleintlong doubledoublefloatunsigned longlongunsigned intintnot-existent,  if intequalslong
IMPLICIT TYPE CONVERSIONS141C++ allows you to mix arithmetic types in a single expression — in other words, theoperands of an operator can belong to different types. The compiler automatically per-
formsimplicit type conversion, where a common type, which allows the operation in ques-tion to be performed, is assigned for the values of both operands. You can generally
assume that the “smaller” type will be converted to the “larger” type. The assignment
operator is an exception to this rule and will be discussed separately.The result of an arithmetic operation belongs to the common type used to performthe calculation. However, comparison expressions will be booltypes no matter whattype of operands are involved.Integer Promotion
Integer promotionis first performed for any expression:bool,char,signed char,unsigned char,and 
shortare converted tointunsigned shortis also converted to intif the inttype is greater thanshort, and to unsigned intin all other cases.This type conversion is performed so as to preserve the original values. The booleanvaluefalseis converted to 0andtrueis converted to 1.Thus, C++ will always use inttype values or greater when performing calculations.Given a char variablec, the values of cand'a'in the expressionExample:c < 'a'will be converted to intbefore being compared.Usual Arithmetic Type Conversions
If operands of different arithmetic types still occur after integer promotion, furtherimplicit type conversions along the lines of the hierarchy on the opposite page will be
necessary. In this case, the type of the operand with the highest rank in the hierarchy is
applied. These type conversions and integer promotions are collectively known as usualarithmetic type conversions.In our example, size/10 * x, the value of sizeis first promoted to intbefore aninteger division size/10is performed. The interim result 50is then converted to dou-bleand multiplied by x.Usual arithmetic type conversions are performed for all binary operators and the con-ditional operator ?:provided the operands belong to an arithmetic type, the only excep-tions being the assignment operator and the logical operators &&and||.
142CHAPTER 8CONVERTING ARITHMETIC TYPES
Sign bit(= 0 not negative)Sign bit(= 0 not negative)00001010
Extension  to int  (here 16 bit)
The value 10 is preserved.0000
0000
00001010
2621421328272120252423222120•        •••         •         •         •        •Binary representaion of the integer 10as value of type signed char (8 bits):••Sign bit(= 1 negative)Sign bit(= 1  negative)11110110
Extension  to int  (here 16 bit)
The value –10 is preserved.1111
1111
11110110
2621421328272120252423222120••••••••
Binary representaion of the integer –10as value of type signed char (8 bits):••The value of a negative number changes if the bit pattern is interpreted as unsigned. The bit pattern1111 0110 of –10, for example, corresponds to the unsigned charvalue246 == 0*20+ 1*21+ 1*22+ 0*23+ 1*24+ 1*25+ 1*26+ 1*27NOTE
PERFORMING USUAL ARITHMETIC TYPE CONVERSIONS
Converting signed integers
a) Converting a positive number
b) Converting a negative number
The bit pattern of –10is computed by starting with the bit pattern of 10and generat-ing the binary complement (see Binary Representation of Numbersin the appendix).
PERFORMING USUAL ARITHMETIC TYPE CONVERSIONS143Usual arithmetic type conversions retain the value of a number provided it can be repre-sented by the new type. The procedure for type conversion depends on the types
involved:1.Conversion of an unsigned type to a larger integral typeExamples:unsigned char tointorunsigned intZero extension is performed first. During this process, the bit pattern of the num-ber to be converted is expanded to match the length of the new type by adding
zeros from the left.2.Conversion of a signed type to a larger integral typeThe new type is also signedExamples:chartoint,shorttolongSigned integers are represented by generating the binary complement. Thevalue is retained by performing sign extension. As shown in the example on theopposite page, the original bit pattern is expanded to match the length of the
new type by padding the sign bit from the left.The new type is unsignedExamples:chartounsigned int,longtounsigned longIn this case the value of negative numbers is not retained. If the new type is of
the same length, the bit pattern is retained. However, the bit pattern will beinterpreted differently. The sign bit loses its significance (see the note oppo-
site).If the new type is longer, sign extension is performed first and the new bitpattern is then interpreted as unsigned.3.Conversion of an integral type to a floating-point typeExamples:inttodouble,unsigned longtofloatThe number is converted to an exponential floating-point type and the valueretained. When converting from longorunsigned longtofloat,some
rounding may occur.4.Conversion of a floating-point type to a larger floating-point typeExamples:floattodouble,doubletolong doubleThe value is retained during this type conversion.
144CHAPTER 8CONVERTING ARITHMETIC TYPES
IMPLICIT TYPE CONVERSIONS IN ASSIGNMENTS
Example 1:int i = 100;long lg = i + 50;// Result of type int is
// converted to long.Example 2:long lg = 0x654321;  short st;
st = lg;//0x4321 is assigned to st.
Example 3:int i = Ð2;  unsigned int ui = 2;
i = i * ui;
// First the value contained in i is converted to
// unsigned int (preserving the bit pattern) and
// multiplied by 2 (overflow!).
// While assigning the bit pattern the result// is interpreted as an int value again,// i.e. Ð4  is stored in i.Example 4:double db = Ð4.567;
int i;  unsigned int ui;
i = db;          // Assigning Ð4.
i = db Ð 0.5;    // Assigning Ð5.
ui = db;         // Ð4 is incompatible with ui.Example 5:double d = 1.23456789012345;
float f;
f = d;           // 1.234568 is assigned to f.
IMPLICIT TYPE CONVERSIONS IN ASSIGNMENTS145Arithmetic types can also be mixed in assignments. The compiler adjusts the type of thevalue on the right of the assignment operator to match the type of the variable on the
left.In the case of compoundassignments, calculations using normal arithmetic type con-versions are performed first before type conversion is performed following the rule for
simple assignments.Two different cases can occur during type conversion in assignments:1.If the type of the variable is larger than the type of the value to be assigned, the
type of the value must be promoted. The rules for usual arithmetic type conver-
sions are applied in this case (see Example 1).2.If the type of the value to be assigned is larger, this type must be “demoted.” The
following procedures are followed depending on individual circumstances:a.Conversion of an integral type to a smaller type:the type is converted to a smaller type by removing the most significantbyte(s). The bit pattern that remains will be interpreted as unsigned, if the
new type is also unsigned,and as signed in all other cases. The value can
only be retained if it can be represented by the new type (see Example 2).when converting an unsignedtype to a signedtype of the same scale,the bit pattern is retained and will be interpreted as signed (see Example
3).b.Conversion of a floating-point type to an integral typeThe decimal part of the floating-point number is removed. For example, 1.9converts to the integer 1. Rounding can be achieved by adding 0.5to a posi-tive floating-point number or subtracting 0.5from a negative floating-pointnumber. This would allow for converting (1.9 + 0.5)to2.If the resulting integer is too large or too small for the new type, the resultis unpredictable. This particularly applies to converting negative floating-
point numbers to unsignedintegers (see Example 4).c.Conversion of a floating-point type to a smaller typeIf the floating-point number falls within the range of the new type, the valuewill be retained, although the accuracy may be compromised. If the value is
too large to be represented by the new type, the result is unpredictable (see
Example 5).
146CHAPTER 8CONVERTING ARITHMETIC TYPES
// Ellipse.cpp// The program draws an ellipse.
// The points (x,y) on an ellipse with center (0,0)
// and axes A and B satisfy:
//   x = A*cos(t), y = B*sint(t)  for 0 <= t <= 2*PI .//------------------------------------------------------#include <iostream>#include <cmath>      // Prototypes of sin() and cos()
using namespace std;#define CLS         (cout << "\033[2J")#define LOCATE(z,s) (cout <<"\033["<<(z)<<';'<<(s)<<'H')#define DOT(x,y)    (LOCATE(y,x) << '*')#define  PI  3.1416#define  Mx  40           // The point (Mx, My) is the
#define  My  12           // center of the ellipse.#define  A   25           // Length of main axis#define  B   10           // Length of subsidiary axisint main(){int x, y;             // Screen coordinates.CLS;// 0 <= t <= PI/2 is a 1/4-circle:for( double t = 0.0 ; t <= PI/2 ; t += 0.03){x = (int) (A * cos(t) + 0.5);
y = (int) (B * sin(t) + 0.5);
DOT( x+Mx, y+My);DOT( x+Mx,-y+My);DOT(-x+Mx, y+My);
DOT(-x+Mx,-y+My);}LOCATE(24,0);
return 0;}MORE TYPE CONVERSIONS
Sample program

MORE TYPE CONVERSIONS147Implicit Type Conversions in Function Calls
In the case of function calls, arguments with arithmetic types are converted to the types ofthe corresponding parameters, similarly to conversions in assignments.Example:void func( short, double);    // Prototypeint size = 1000;
// . . .
func( size, 77);              // CallThe function func()has two parameters belonging to the shortanddoubletypes.However, the function is called using two intarguments. This leads to implicit conver-sion of the value of sizetoshortand the integer 77todouble.When an intis converted to shortthe compiler issues a warning, since some dataloss may occur. You can use explicit type conversion to avoid warnings during type con-
version.Explicit Type Conversion
It is possible to convert the type of an expression explicitly using the cast operator(type).Syntax:(type) expressionThis converts the value of an expression to the given type. Explicit type conversion isalso known as casting.The cast operator (type)is a unary operator and thus has a higher precedence thanthe arithmetic operators.Example:int a = 1, b = 4;double x;
x = (double)a/b;In this example the value of ais explicitly converted to a double. Following the con-ventions of usual implicit type conversion, bis also converted to doubleand a floating-point division is performed. The exact result, 0.25, is assigned to the variable x.Without casting, an integer division with a result of 0would have occurred.C++ has additional operators for explicit type conversion—the cast operatordynamic_cast<>, for example. These operators, which are described in later chapters,are required for special circumstances, for example, to perform type checking at runtime
when converting classes.
exercises
148CHAPTER 8CONVERTING ARITHMETIC TYPES
// Convert.cpp Ñ> Demonstrates type conversions.#include <iostream>#include <iomanip>
using namespace std;int main(){char v_char = 'A';
cout << "v_char:       " << setw(10) << v_char<< setw(10) << (int)v_char
<< endl;short v_short = Ð2;cout << "v_short:      " << dec << setw(10) << v_short<< hex << setw(10) << v_short<< endl;unsigned short  v_ushort = v_short;cout << "v_ushort:     " << dec << setw(10) << v_ushort<< hex << setw(10) << v_ushort
<< endl;unsigned long  v_ulong = v_short;cout << "v_ulong:      " << hex << setw(20) << v_ulong<< endl;float  v_float = Ð1.99F;cout << "v_float:      " << setw(10) << v_float << endl;
cout << "(int)v_float: " << setw(10)<< dec << (int)v_float << endl;return 0;}EXERCISESProgram listing for exercise 3
Graphic for exercise 4
-------TheSineFunction-------
sin(x)
1*******
******
****
******
******
**2PIx

*
*
*******
******
******
******
-1*******

EXERCISES1491.Plot one point of the curve in columns 10,10+1,...,10+64 respectively.This leads to a
step value of 2*PI/64 for x.
2.Use the following extended ASCII code characters to draw the axes:
Example:cout << '\020';       // up arrowheadNOTE
CharacterDecimalOctal
–+19619716
30304305
020
036Exercise 1
A function has the following prototype
void func( unsigned int n); What happens when the function is called with 
Ð1as an argument?Exercise 2
How often is the following loop executed?
unsigned int limit = 1000;for (int i = Ð1; i < limit; i++)//  . . . Exercise 3
What is output when the program opposite is executed?
Exercise 4
Write a C++ program to output the sine curve on screen as in the graphic
shown on the opposite page.

solutions
150CHAPTER 8CONVERTING ARITHMETIC TYPES
SOLUTIONSExercise 1
When called,the value 
Ð1is converted to parameter 
n,i.e.to 
unsigned int.The pattern of Ð1is interpreted as unsigned,which yields the greatest 
unsignedvalue.
On a 32-bit system,Ð1has the bit pattern 0xFFFFFFFF,which,when
interpreted as unsigned,corresponds to the decimal value 4 294 967 295.
Exercise 2
The statement within the loop is not executed at all! In the expression
i < limit the value of variable i,Ð1
,is implicitly converted to 
unsigned intand thus itrepresents the greatest 
unsignedvalue (see Exercise 1).
Exercise 3
The screen output of the program
v_char:                A        65v_short:              -2      fffe
v_ushort:          65534      fffe
v_ulong:                  fffffffe
v_float:           -1.99(int)v_float:         -1 Exercise 4
// -----------------------------------------------------//   sinCurve.cpp
//   Outputs a sine curve
// -----------------------------------------------------#include <iostream>#include <cmath>                  // Prototypes of sin()
using namespace std;#define CLS         (cout << "\033[2J")#define LOCATE(z,s) (cout <<"\033["<<(z)<<';'<<(s)<<'H')
#define PI        3.1415926536
#define START     0.0               // Lower limit
#define END     (2.0 * PI)          // Upper limit
SOLUTIONS151#define PNT       64       // Number of points on the curve#define STEP  ((END-START)/PNT)
#define xA        14                   // Row  of x-axis#define yA        10                   // Column of y-axisint main(){int  row, column;CLS;LOCATE(2,25);
cout << "-------  The Sine Function  -------";//    ---  Draws the coordinate system: ---LOCATE(xA,1);                               // x-axisfor( column = 1 ; column < 78  ; ++column){cout << ((column - yA) % 8  ?  '\304' : '\305');}cout << '\020';                             // topLOCATE(xA-1, yA+64);  cout << "2PI  x";for( row = 5 ; row < 24 ; ++row)            // y-axis{LOCATE(row, yA);  cout << '\305';}LOCATE( 4, yA);  cout << "\036 sin(x)";     // topLOCATE( xA-8, yA+1);  cout << " 1";LOCATE( xA+8, yA+1);  cout << " -1";//     --- Displays the sine function:  ---
int begpt = yA,endpt = begpt + PNT;for( column = begpt ;  column <= endpt  ;  ++column){double x = (column-yA) * STEP;
row = (int)(xA - 8 * sin(x) + 0.5);
LOCATE( row, column);  cout << '*';}LOCATE(25,1);              // Cursor to the last rowreturn 0;}
This page intentionally left blank 
153The Standard ClassstringThis chapter introduces the standard class string,which is used to
represent strings.Besides defining strings we will also look at the various

methods of string manipulation.These include inserting and erasing,

searching and replacing,comparing,and concatenating strings.
chapter
9
154CHAPTER 9THE STANDARD CLASS STRING
'G''o''o''o''r''n''n''!'
g''i''d'' ''M'
13Stringliteral:Length:String message in memory:// string1.cpp: Using strings#include <iostream>#include <string>
using namespace std;string prompt("Enter a line of text: "),    // Globalline( 50, '*');                      // stringsint main(){string text;                      // Empty string
cout << line << endl << prompt << endl;getline( cin, text);        // Reads a line of textcout << line << endl<< "Your text is " << text.size()<< " characters long!" << endl;// Two new strings:string copy(text),            // a copy and thestart(text,0,10);      // first 10 characters// starting with
// position 0.cout << "Your text:\n" << copy << endl;text = "1234567890";          // Assignment
cout << line << endl<< "The first 10 characters:\n" << start << endl<< text << endl;return 0;}DEFINING AND ASSIGNING STRINGS
Initializingstring message = "Good Morning!";Sample program
Objects of class stringdo not necessarily contain the string terminating character '\0', as is the casewith C strings.NOTE

DEFINING AND ASSIGNING STRINGS155C++ uses the standard class stringto represent and manipulate strings allowing forcomfortable and safe string handling. During string operations the required memory
space is automatically reserved or modified. The programmer does not need to concern
himself or herself with internal memory allocation.Thestringclass is defined in the stringheader file and was mentioned in Chap-ter 3 as an example for the use of classes. Several operators are overloaded for strings,
that is, they were also defined for the stringclass. This allows for easy copying, con-catenation, and comparison. Additionally, various methods for string manipulation such
as insertion, erasing, searching, and replacing are available.Initializing StringsA string, that is, an object belonging to the stringclass, can be initialized when youdefine it usinga predefined string constanta certain number of charactersa predefined string or part of a string.If a string is not initialized explicitly, an empty string with a length of 0is created.The length of a string, that is, the current number of characters in the string, is stored
internally and can be accessed using the length()method or its equivalent size().Example:string message("Good morning!");cout << message.length();   // Output: 13String AssignmentsWhen you assign a value to a string, the current contents are replaced by a new charactersequence. You can assign the following to a stringobject:another stringa string constant ora single character.The memory space required is adjusted automatically.The program on the opposite page uses the function getline(), which was intro-duced in an earlier chapter, to store a line of text from the keyboard in a string. In con-
trast, the >>operator reads only one word, ignoring any leading white space. In bothcases the original content of the string is lost.
156CHAPTER 9THE STANDARD CLASS STRING
// string2.cpp: Reads several lines of text and//              outputs in reverse order.#include <iostream>#include <string>
using namespace std;string prompt("Please enter some text!\n"),line( 50, '-');int main()
{prompt+="Terminate the input with an empty line.\n ";cout << line << '\n' << prompt << line << endl;string text, line;          // Empty stringswhile( true)
{getline( cin, line);     // Reads a line of textif( line.length() == 0)  // Empty line?break;                 // Yes ->end of the looptext = line + '\n' + text;   // Inserts a new// line at the beginning.}// Output:cout << line << '\n'<< "Your lines of text in reverse order:"<< '\n' << line << endl;cout << text << endl;return 0;}CONCATENATING STRINGS
Sample program
Sample output for this program
---------------------------------------Please enter some text!Terminate the input with an empty line.
---------------------------------------
Babara, Bobby, and Susan
will go to the movies today---------------------------------------Your lines of text in reverse order:
---------------------------------------
will go to the movies today
Babara, Bobby, and Susan 
CONCATENATING STRINGS157At least one operand must be a stringclass object. The expression "Good morning " +"mister X"would be invalid!NOTE
Within the stringclass the operators +and+=are defined for concatenating, and theoperators==,!=,<,<=,>, and >=are defined for comparing strings. Although theseoperators are being applied to strings, the well-known rules apply: the +has precedenceover the comparative operators, and these in turn have higher precedence than the
assignment operators =and+=.Using+to Concatenate Strings
You can use the +operator to concatenate strings, that is, to join those strings together.Example:string sum, s1("sun"), s2("flower");sum = s2 + s3;This example concatenates the strings s1ands2. The result, "sunflower"is thenassigned to sum.Two strings concatenated using the +operator will form an expression of the stringtype. This expression can in turn be used as an operand in a more complex expression.Example:string s1("sun"),s2("flower"),s3("seed");cout << s1 + s2 + s3;Since the +operator has precedence over the <<operator, the strings are concatenatedbefore the “sum” is output. Concatenation takes place from left to right. String constants
and single characters are also valid as operands in expressions containing strings:Example:string s("Good morning ");cout << s + "mister X" + '!';Using+=to Concatenate Strings
Strings can also be concatenated by first performing concatenation and then assigningthe result.Example:string s1("Good "),s2("luck!");s1 = s1 + s2;          // To concatenate s2 and s1This example creates a temporary object as a result of s1 + s2and then assigns theresult to s1. However, you can obtain the same result using the assignment operator +=,which is far more efficient.Example:s1 += s2;            // To concatenate s2 and s1.s1 += "luck!";       // Also possibleThis adds the content of the second string directly to s1. Thus, the +=operator is prefer-able to a combination of the +and=operators.
158CHAPTER 9THE STANDARD CLASS STRING
// string3.cpp: Inputs and compares lines of text.#include <iostream>#include <string>
using namespace std;
string prompt = "Please enter two lines of text!\n",line( 30, '-');int main(){string line1, line2, key = "y";
while( key == "y" || key == "Y"){cout << line << '\n' << prompt << line << endl;getline( cin, line1);        // Read the firstgetline( cin, line2);        // and second line.if( line1 == line2)cout << " Both lines are the same!" << endl;else{cout << "The smaller line is:\n\t";
cout << (line1 < line2 ? line1 : line2)<< endl;int len1 = line1.length(),len2 = line2.length();if( len1 == len2)cout << "Both lines have the same length! \n";else{ cout << "The shorter line is:\n\t";cout << (len1 < len2 ? line1 : line2)<< endl;}}cout << "\nRepeat? (y/n) ";dogetline( cin, key);while(    key != "y" && key != "Y"&& key != "n" && key != "N");}return 0;}The relational operators yield the desired result for strings only if at least one operand is an object ofclassstring. See Chapter 17, Pointers and Arrays, for more information.NOTE
COMPARING STRINGS
Sample program

COMPARING STRINGS159The comparative operators==   !=   <    <=    >    >= were overloaded in the stringclass to allow easy comparison of strings. This alsoallows you to use strings to formulate the conditions for branches and loops.Example:// str1 and str2 are objects of type stringif( str1 < str2)  // str1 is less than str2?. . .Results of ComparisonsStrings are compared lexicographically, that is character by character,beginning at thefirst character. To decide whether a single character is smaller, greater, or identical to
another character, the character codes of the character set are compared. Thus, if you are
using the ASCII character set, the letter 'A'(ASCII code 65) is smaller than the letter'a'(ASCII code 97).A comparison results in a booltype value. Given two strings s1ands2:s1 == s2istrueonly if both strings are identical; this requires that both stringsare exactly the same length.s1 < s2istrueonly if the first character in s1that differs from the correspon-ding character in s2is smaller than the corresponding character in s2,or if s2is simply an extension of s1.All other comparative operations can be deduced from the above rules. For example, theexpressions1 > s2istrueonly if s2 < s1is also true.In an expression comparing strings, one operand can again be a string constant or asingle character.Example:while( key == 'y' ) { . . . }This example compares the string keywith the single character 'y'. This is an alterna-tive method of expressing the comparison key == "y".String comparisons can also be combined to form more complex expressions.Example:while( key == "y" || key == "Y"){ . . . }The controlling expression is valid if the string keycontains only the letter 'Y'or'y'.Due to the higher precedence of the comparative operator versus the ||operator, noparentheses are required in this example.
160CHAPTER 9THE STANDARD CLASS STRING
Position:String s1012345678910
'M''i''s''s''  ''S''u''e''r'
'm''m'
'A''s''h''l''e''y''  '
Position:String sbeforeString safterwards012345678910
'T''h'
'e''  ''s''u''m''m''e''r''-''t''i''m''e''T''h''e''i''e'
't''m'
'  '11121314
INSERTING AND ERASING IN STRINGS
Inserting a string
string s1("Miss Summer");s1.insert(5, "Ashley "); // Insert at position: 5 Effect of the statement:
Erasing a substringstring s("The summer-time");
s.erase(4,7);     // Start position: 4, Quantity: 7 Effect of the statement:

INSERTING AND ERASING IN STRINGS161Thestringclass contains numerous methods for performing string manipulations. Amethod exists for each operation, such as inserting, erasing, searching, and replacing.
These methods generally allow passing a string constant instead of a second string. A sin-
gle character can also be used wherever appropriate.Insertion
The method insert()inserts a string at a certain position of another string. The posi-tion is passed as the first argument and defines the character before which to insert the
string. The first character in a string occupies position 0, the second character position 1,
and so on.Example:string s1("Miss Summer");s1.insert(5, "Ashley ");The string "Ashley "is inserted into the string s1at position 5, that is in front of the'S'character in "Summer". Following this, the string "Miss Ashley Summer"isassigned to s1.If you need to insert only part of a string into another string, you can pass two addi-tional arguments to the insert()method, the starting position and the length of thestring.Example:string s1("Ashley is a devil"),s2(" sweetheart");s1.insert(12, s2, 0, 12);This example inserts the first 12 characters from the string s2at position 13 in string s1.Strings1then contains the string “Ashley is a sweetheart".ErasingYou can use the erase()method to delete a given number of characters from a string.The starting position is supplied as the first argument and the number of characters to be
erased is the second argument.Example:string s("The summer-time");s.erase(4,6);     // Result: "The time"This statement deletes 7 characters from string sstarting at position 4. The erase()method can also be called without specifying a length and will then delete all the charac-ters in the string up to the end of the string.Example:string s("winter-story");s.erase(6);      // s now contains "winter"You can also call erase()without any arguments to delete all the characters in astring.
162CHAPTER 9THE STANDARD CLASS STRING
SEARCHING AND REPLACING IN STRINGS
Replacing substringsa.Example “Bob and Bill”
string s1("There they go again!"),s2("Bob and Bill");s1.replace(6, 4, s2); Effect of the statement:
b.Example “my love”
string s1("Here comes Mike!"), s2("my love?");
s1.replace(11, 4, s2, 0, 7); Effect of the statement:
012345678910111213141516171819
s1s2'T''B''B'
'o''b''a''i''l''l'
'd''n'' '' '
'h''h'
'e''r''e''e''y''o''a''i''n''!'
'a''g''g'
' '' '''
't'0123456789101112131415
s1s2'H''e''r''e'' ''c''o''m''e''s'' ''M''i''k''e''!'
'm''y'' ''l''o''v''e''?'

SEARCHING AND REPLACING IN STRINGS163Searching
You can search strings to find the first or last instance of a substring. If the string con-tains the required substring, the position of the substring found by the search is returned.
If not, a pseudo-position npos, or Ð1, is returned. Since the nposconstant is defined inthestringclass, you can reference it as string::npos.Thefind()method returns the position at which a substring was first found in thestring. The method requires the substring to be located as an argument.Example:string youth("Bill is so young, so young");int first = youth.find("young");The variable firsthas a value of 11in this example.You can use the “right find” method rfind()to locate the last occurrence of a sub-string in a string. This initializes the variable lastwith a value of 21in our example.Example:int last = youth.rfind("young");ReplacingWhen replacing in strings, a string overwrites a substring. The string lengths need not beidentical.You can use the replace()method to perform this operation. The first two argu-ments supply the starting position and the length of the substring to be replaced. The
third argument contains the replacement string.Example:string s1("There they go again!"),s2("Bob and Bill");int pos = s1.find("they");      // pos == 6
if( pos != string::npos )s1.replace(pos, 2, s2);This example uses the string s2to replace 4 characters, "they", starting at position 6 ins1. After this operation s1contains the string "There Bob and Bill goagain!".If you only need to insert part of a string, you can use the fourth argument to definethe starting position and the fifth to define the length of the substring.Example:string s1("Here comes Mike!"),s2("my love?");s1.replace(11, 4, s2, 0, 7);The string s1is changed to "Here comes my love!".
164CHAPTER 9THE STANDARD CLASS STRING
//  string4.cpp//  The program counts words and white space characters.// (A word is the maximum sequence of characters//  containing no white space characters.)//---------------------------------------------------------------#include <iostream>
#include <string>
#include <cctype>            // Macro isspace()
using namespace std;int main(){string header("     **** Counts words   ****\n"),prompt("Enter a text and terminate"" with a period and return:"),line( 60, '-'),text;                  // Empty stringcout << header << endl << prompt << endl<< line  << endl;getline( cin, text, '.');     // Reads a text up to// the first '.'// Counts words and white space charactersint  i,              // IndexnSpace = 0,     // Number of white spacesnWord  = 0;     // Number of wordsbool fSpace = true;  // Flag for white spacefor( i = 0; i < text.length(); ++i){if( isspace( text[i]) )  // white space?
{++nSpace;  fSpace = true;}else if( fSpace)    // At the beginning of a word?{++nWord;   fSpace = false;}}cout << line                 // Outputs the result.<< "\nYour text contains (without periods)"<< "\n           characters: " << text.length()<< "\n                words: " << nWord<< "\n         white spaces: " << nSpace<< endl;return 0;}ACCESSING CHARACTERS IN STRINGSSample program

ACCESSING CHARACTERS IN STRINGS165When manipulating strings it is often important to access the individual characters thatform the string. C++ has the operator []and the method at()for this purpose. Anindividual character is always identified by its index, also referred to as subscript, that is,its position in the string. The first character will always have an index value of 0, thesecond an index of 1, and so on.Subscript Operator
The easiest way to access a single character in the string is to use the subscript operator[]. If you define a string as follows,Example:string s = "Let";the individual characters in the string are:s[0] == 'L',  s[1] == 'e',  s[2] == 't' The last character in a string always has an index of s.length() Ð 1. You can usethe subscript operator to read any character in a string and also to overwrite a character,
provided the string was not defined as a constant.Example:char c = s[0];This statement copies the first character from sto the variable c. In contrastExample:s[s.length() Ð1] = 'g';overwrites the last character in the string s. Following this, swill contain the string"Leg".Invalid Indices
Any integral expression can be used as an index. However, no error message occurs if theboundaries of a valid index are overstepped.Example:cout << s[5];// Error
Your program’s reaction to an invalid index is undefined; this requires careful atten-tion by the programmer! You can call the at()method if you need to perform rangechecks.Theat()methodYou can also use the at()method to access a single character.Example:s.at(i) = 'X';is 
equivalent tos[i] = 'X';In contrast to the subscript operator, the at()method performs range checking. If aninvalid index is found an exceptionoccurs and the program will normally be terminated atthis point. However, you can specify how a program should react to an exception.
exercises
166CHAPTER 9THE STANDARD CLASS STRING
// timeStr.cpp// Demonstrates operations on a string containing
// the present time.#include <iostream>#include <string>#include <ctime>         // For time(), ctime(), ...using namespace std;int main(){long sec;time( &sec);            // Reads the present time// (in seconds) into sec.string tm = ctime( &sec);     // Converts the// seconds to a string.cout << "Date and time: " << tm << endl;string hr(tm, 11, 2);  // Substring of tm starting at// position 11, 2 characters long.string greeting("Have a wonderful ");if( hr < "10")             // Compares stringsgreeting += "Morning!";else if( hr < "17")greeting += "Day!";elsegreeting += "Evening!";cout << greeting << endl;return 0;}EXERCISESFor exercise 3

EXERCISES167The function time()returns the current time as the number of seconds since 1/1/1970, 0:0. Thenumber of seconds is stored in the variable sec, whose address was supplied as &secwhen thefunction was called.The function ctime()converts the number of seconds to a string with a date and time and returnsthis string. The string comprises exactly 26 characters including the null character \0and has thefollowing format:Weekday Month Day Hr:Min:Sec Year\n\0Example:Wed Jan 05 02:03:55 2000\n\0NOTE
Exercise 1
Write a C++ program to
initialize a string s1with the string "As time by ..."and a secondstrings2with the string "goes",insert string 
s2in front of 
"by"in string s1,erase the remainder of string 
s1after the substring "by",replace the substring 
"time"ins1with"Bill".In each case,your program should determine the position of the substring.
Output string s1on screen at the beginning of the program and after every
modification.Exercise 2
Write a C++ program that reads a word from the keyboard,stores it in a string,

and checks whether the word is a palindrome.A palindrome reads the same

from left to right as from right to left.The following are examples of

palindromes:“OTTO,” “deed,” and “level.”
Use the subscript operator [].Modify the program to continually read and
check words.
Exercise 3
Write down the screen output for the program on the opposite page.

solutions
168CHAPTER 9THE STANDARD CLASS STRING
SOLUTIONSExercise 1
// ------------------------------------------------------// strDemo.cpp: Insert, search, and replace in strings.
// ------------------------------------------------------#include <iostream>
#include <string>using namespace std;string header = "Demonstrating the use of strings\n",s1 = "As time by ...",
s2 = "goes ";int main(){int pos = 0;cout << header << endl;cout << "s1 : " << s1 << endl;// To insert:cout << "\nInserting in string \"" << s2 <<"\""<< endl;pos = s1.find("by");if( pos != string::npos )s1.insert(pos,s2);cout << "s1 : " << s1 << endl;              // Result// To erase:cout << "\nTo erase remaining characters behind \"by\":"<< endl;pos = s1.find("by");if( pos != string::npos )s1.erase(pos + 3);cout << "s1 : " << s1 << endl;              // Result// To replace:cout << "\nTo replace \"time\" by \"Bill\":"<< endl;pos = s1.find("time");if( pos != string::npos )s1.replace(pos, 4, "Bill");cout << "s1 : " << s1 << endl;             // Result
return 0;}
SOLUTIONS169Exercise 2
// -----------------------------------------------------// palindrome.cpp: Reads and compares lines of text.// -----------------------------------------------------#include <iostream>#include <string>using namespace std;string header = " * * * Testing palindromes * * * ",prompt = "Enter a word: ",
line( 50, '-');int main(){string word;                        // Empty stringchar key = 'y';cout << "\n\t" << header << endl;while( key == 'y' || key == 'Y'){cout << '\n' << line  << '\n'<< prompt;cin >> word;// Compares the first and last character,// the second and the second to last etc.
int i = 0, j = word.length() - 1;for( ; i <= j ; ++i, --j)if( word[i] != word[j] )break;if( i > j)                   // All characters equal?cout << "\nThe word " << word<< " is a P A L I N D R O M E !" << endl;elsecout << "\nThe word " << word<< " is not a palindrome" << endl;cout << "\nRepeat? (y/n) ";docin.get(key);while(    key != 'y' && key != 'Y'&& key != 'n' && key != 'N');cin.sync();}
return 0;}
170CHAPTER 9THE STANDARD CLASS STRING
Exercise 3
The program outputs the date and time first.Then a greeting is printed
according the time of day.For example:
Date and time: Thu Nov 28 09:01:37 2001Have a wonderful morning! 
171FunctionsThis chapter describes how to write functions of your own.Besides the
basic rules,the following topics are discussed:
passing arguments
definition of 
inlinefunctionsoverloading functions and default arguments
the principle of recursion.
chapter
10
172CHAPTER 10FUNCTIONS
C++ programCore elements ofC++(built-in types,operators,control structures)Functions andclasses of thestandard librarySelf-definedfunctions andclasses andother librariesSIGNIFICANCE OF FUNCTIONS IN C++
Elements of a C++ program

SIGNIFICANCE OF FUNCTIONS IN C++173C++ supports efficient software development on the lines of the top-down principle. Ifyou are looking to provide a solution for a more complex problem, it will help to divide
the problem into smaller units. After identifying objects you will need to define classes
that describe these objects. You can use available classes and functions to do so. In addi-
tion, you can make use of inheritance to create specialized classes without needing to
change any existing classes.When implementing a class you must define the capacities of those objects, that is,the member functions, in your program. However, not every function is a member func-
tion.Functions can be defined globally, such as the function main()for example. Func-tions of this type do not belong to any particular class but normally represent algorithms
of a more general nature, such as the search or sort functions of the standard library.LibrariesYou will not need to program each “building block” yourself. Many useful global func-tions and classes are available from the C++ standard library. In addition, you can use
other libraries for special purposes. Often a compiler package will offer commercial class
libraries or graphical user interfaces. Thus, a C++ program will be made up oflanguage elements of the C++ coreglobal functions and classes from the C++ standard libraryfunctions and classes you have programmed yourself and other libraries.Classes and functions that belong together are normally compounded to form separatesource files, which can be compiled and tested independently. Using software compo-
nents that you have already tested makes programming a complex solution much easier
and improves the reliability of your programs. You can enhance the reusability of your
source code by compiling your own libraries, but be sure to include comments for ease of
readability.Compiled source files, also known as modules,are compounded by the linker to anexecutable file by reference to the libraries you include. If you modify a source file, you
may also need to recompile other files. In large scale projects it is recommended to use
theMAKEutility for module management. An integrated developer environment willoffer the functionality of this utility when you create a new project. This includes your
own source files, the libraries used, and the compiler/linker settings for program com-
pilation.
174CHAPTER 10FUNCTIONS
// func1.cpp#include <iostream>using namespace std;void test( int, double );               // Prototypeint main(){cout << "\nNow function test() will be called.\n";
test( 10, -7.5);                      // Callcout << "\nAnd back again in main()." << endl;return 0;}void test(int arg1, double arg2 )       // Definition{cout << "\nIn function test()."<< "\n  1. argument: " << arg1
<< "\n  2. argument: " << arg2 << endl;}[type] name([declaration_list]) // Function header{                               // Beginning..
What will be done// Function block..}                               // End DEFINING FUNCTIONSExample of a function definitionGeneral form of a function
DEFINING FUNCTIONS175The following section describes how to program global functions. Chapter 13, DefiningClasses, describes the steps for defining member functions.DefinitionFunctions can be defined in any order, however, the first function is normally main.This makes the program easier to understand, since you start reading at the point wherethe program starts to execute.The function test()is shown opposite as an example and followed by the generalform of a function. The example can be read as follows:typeis the function type, that is, the type of the return value.nameis the function name, which is formed like a variable name
and should indicate the purpose of the function.declaration_listcontains the names of the parameters and declares their
types. The list can be empty, as for the function main(),for example. A list of declarations that contains only the
wordvoidis equivalent to an empty list.Theparametersdeclared in a list are no more than local variables. They are createdwhen the function is called and initialized by the values of the arguments.Example:Whentest( 10, -7.5); is called, the parameterarg1is initialized with a value of 10andarg2with-7.5.The left curved bracket indicates the start of a function block, which contains the state-ments defining what the function does.Prototype and Definition
In a function definition the function header is similar in form to the prototype of a func-tion. The only difference when a function is defined is that the name and declaration list
arenotfollowed by a semicolon but by a function code block.The prototype is the declaration of the function and thus describes only the formalinterface of that function. This means you can omit parameter names from the proto-
type, whereas compiling a function definition will produce machine code.
176CHAPTER 10FUNCTIONS
// area.cpp// Example for a simple function returning a value.
//-----------------------------------------------------
#include <iostream>
#include <iomanip>using namespace std;double area(double, double);         // Prototype
int main(){double  x = 3.5, y = 7.2,  res;res = area( x, y+1);             // Call// To output to two decimal places:cout << fixed << setprecision(2);cout << "\n The area of a rectangle "<< "\n with width  " << setw(5)  << x<< "\n and length  " << setw(5) << y+1<< "\n is          " << setw(5) << res<< endl;return 0;}// Defining the function area():// Computes the area of a rectangle.double area( double width, double len){return (width * len);   // Returns the result.}RETURN VALUE OF FUNCTIONS
Defining and calling the function area()Screen output:
The area of a rectanglewith width   3.50and length   8.20is          28.70 
RETURN VALUE OF FUNCTIONS177The program opposite shows how the function area()is defined and called. As previ-ously mentioned, you must declare a function before calling it. The prototypeprovidesthe compiler with all the information it needs to perform the following actions when a
function is called:check the number and type of the arguments correctly process the return value of the function.A function declaration can be omitted only if the function is defined within the samesource file immediately before it is called. Even though simple examples often define and
call a function within a single source file, this tends to be an exception. Normally the
compiler will not see a function definition as it is stored in a different source file.When a function is called, an argument of the same type as the parameter must bepassed to the function for each parameter. The arguments can be any kind of expressions,
as the example opposite with the argument y+1shows. The value of the expression isalways copied to the corresponding parameter.Return Statement
When the program flow reaches a return statementor the end of a function code block, itbranches back to the function that called it. If the function is any type other than void,thereturnstatement will also cause the function to return a value to the function thatcalled it.Syntax:return [expression]Ifexpressionis supplied, the value of the expression will be the return value. If thetype of this value does not correspond to the function type, the function type is con-
verted, where possible. However, functions should always be written with the returnvalue matching the function type.The function area()makes use of the fact that the returnstatement can containany expression. The returnexpression is normally placed in parentheses if it containsoperators.If the expression in the returnstatement, or the returnstatement itself, is miss-ing, the return value of the function is undefined and the function type must be void.Functions of the voidtype, such as the standard function srand(), will perform anaction but not return any value.
178CHAPTER 10FUNCTIONS
On call“push”On return“pop”Stackfurther local objectsreturn addressfirst parameterlast parameter•  •  ••  •  •PASSING ARGUMENTS
Calling function and called functionStack content after calling a functionlong func2(int, double);          // Prototype//  . . .void func1()
{
   int x = 1.1;
   double y;
   . . .   long a = func2(x,y);          // Call of func2().   . . .}                                // Pass by value               long func2(int a, double b) // Definition{ double x = 2.2;
 long result;  .        // Here the result   .        // is computed.  .return result;}
PASSING ARGUMENTS179Passing by Value
Passing values to a function when the function is called is referred to as passing by value.Of course the called function cannot change the values of the arguments in the calling
function, as it uses copies of the arguments.However, function arguments can also be passed by reference. In this case, the functionis passed a reference to an object as an argument and can therefore access the object
directly and modify it.An example of passing by reference was provided in the example containing the func-tiontime(). When time(&sek);is called, the address of the variable sekis passedas an argument, allowing the function to store the result in the variable. We will see how
to create functions of this type later.Passing by value does, however, offer some important advantages:function arguments can be any kind of expression, even constants, for examplethe called function cannot cause accidental modifications of the arguments in
the calling functionthe parameters are available as suitable variables within the functions. Additional
indirect memory access is unnecessary.However, the fact that copying larger objects is difficult can be a major disadvantage,and for this reason vectors are passed by reference to their starting address.Local ObjectsThe scope of function parameters and the objects defined within a function applies onlyto the function block. That is, they are valid within the function only and not related to
any objects or parameters of the same name in any other functions.For example, the program structure opposite contains a variable ain the functionfunc1()and in the function func2(). The variables do not collide because they refer-ence different memory addresses. This also applies to the variables xinfunc1()andfunc2().A function’s local objects are placed on the stack—the parameters of the function areplaced first and in reverse order. The stack is an area of memory that is managed accord-
ing to the LIFO (last in first out) principle. A stack of plates is a good analogy. The lastplate you put on the stack has to be taken off first. The LIFO principle ensures that the
last local object to be created is destroyed first.
180CHAPTER 10FUNCTIONS
ProgramFunction
Branching// 1st Call// 2nd Callfunc();void func()func();{}ProgramInline function
// 1st Call// 2nd Callfunc();inline void func()func();{}CopyThe executable file only contains one instance of the function’s machine code.HINTThe machine code of the function is stored in the executable file wherever the function is called.HINTINLINE FUNCTIONSCall to a function not defined as inlineCall to an inline function
INLINE FUNCTIONS181Jumping to Sub-RoutinesWhen a function is called, the program jumps to a sub-routine, which is executed as fol-lows:the function parameters are placed on the stack and initialized with appropriate
argumentsthe so-called return address, that is, the place where the function was called, isstored on the stack and the program flow branches to the functionafter executing the function the program uses the return address it stored previ-
ously to return to the calling function. The part of the stack occupied by the
function is then released.All this jumping back and forth can affect the run time of your program, especially if thefunction contains only a few instructions and is called quite often. The time taken to
branch to a small function can be greater than the time needed to execute the function
itself. However, you can define inlinefunctions to avoid this problem.Inline DefinitionThe compiler inserts the code of an inline function at the address where the function iscalled and thus avoids jumping to a sub-routine. The definitionof an inline function isintroduced by the inlinekeyword in the function header.Example:inline int max( int x, int y){  return  (x >= y ? x : y );  }The program code will expand each time an inlinefunction is called. This is whyinlinefunctions should contain no more than one or two instructions. If an inlinefunction contains too many instructions, the compiler may ignore the inlinekeywordand issue a warning.Aninlinefunction must be defined in the source file in which it is called. You can-not simply supply a prototype of the function. The code containing the instructions must
also be available to the compiler. It therefore makes sense to define inlinefunctions inheader files, in contrast to “normal” functions. This means the function will be available
in several source files.Inline Functions and Macros
Inline functions are an alternative to macros with parameters. When a macro is called,the preprocessor simply replaces a block of text. In contrast, an inlinefunctionbehaves like a normal function, although the program flow is not interrupted by the
function branching. The compiler performs a type check, for example.
182CHAPTER 10FUNCTIONS
// Computes the final capital with interest and// compound interest.
// Formula:  capital = k0 * (1.0 + p/100)n// where  k0 = start capital, p = rate, n = run time
// ----------------------------------------------------#include <math.h>double capital( double k0, double p, double n)
{return (k0 * pow(1.0+p/100, n));}// Function capital() with two default arguments// Prototype:double capital( double k0, double p=3.5, double n=1.0);double endcap;endcap = capital( 100.0, 3.5, 2.5);  // okendcap = capital( 2222.20, 4.8);     // okendcap = capital( 3030.00);          // okendcap = capital( );                 // not ok// The first argument has no default value.endcap = capital( 100.0, , 3.0);     // not ok// No gap!endcap = capital( , 5.0);            // not ok// No gap either. A function defined with default arguments is always called with the full number of arguments. Forreasons of efficiency it may be useful to define several versions of the same function.NOTE
DEFAULT ARGUMENTS
Defining the function capital()Possible calls

DEFAULT ARGUMENTS183So-calleddefault argumentscan be defined for functions. This allows you to omit somearguments when calling the function. The compiler simply uses the default values for any
missing arguments.Defining Default Arguments
The default values of a function’s arguments must be known when the function is called.In other words, you need to supply them when you declare the function.Example:void moveTo( int x = 0, int y = 0);Parameter names can be omitted, as usual.Example:void moveTo( int = 0, int = 0);The function moveTo()can then be called with or without one or two arguments.Example:moveTo ();moveTo (24);moveTo(24, 50);
The first two calls are equivalent to moveTo(0,0);ormoveTo(24,0);.
It is also possible to define default arguments for only some of the parameters. The fol-lowing general rules apply:the default arguments are defined in the function prototype. They can also be
supplied when the function is defined, if the definition occurs in the same source
file and before the function is calledif you define a default argument for a parameter, all following parameters must
have default argumentsdefault arguments must not be redefined within the prototype scope (the next
chapter gives more details on this topic).Possible Calls
When calling a function with default arguments you should pay attention to the follow-ing points:you must first supply any arguments that do not have default valuesyou can supply arguments to replace the defaultsif you omit an argument, you must also omit any following arguments.You can use default arguments to call a function with a different number of argumentswithout having to write a new version of the function.
184CHAPTER 10FUNCTIONS
// random.cpp// To generate and output random numbers.//-----------------------------------------------------
#include <iostream>#include <iomanip>#include <cstdlib>     // For rand(), srand()#include <ctime>       // For time()using namespace std;bool setrand = false;inline void init_random()  // Initializes the random{                          // number generator with the// present time.if( !setrand ){  srand((unsigned int)time(NULL));setrand = true;}}inline double myRandom()// Returns random number x{                            // with  0.0 <= x <= 1.0init_random();return  (double)rand() / (double)RAND_MAX;}
inline int myRandom(int start, int end)// Returns the{                               // random number n withinit_random();               // start <= n <= end
return (rand() % (end+1 - start) + start);}// Testing myRandom() and myRandom(int,int):int main()
{int i;cout << "5 random numbers between 0.0 and 1.0 :"<< endl;for( i = 0; i < 5; ++i)cout << setw(10) << myRandom();cout << endl;cout << "\nAnd now 5 integer random numbers ""between -100 and +100 :" << endl;for( i = 0; i < 5; ++i)cout << setw(10) << myRandom(-100, +100);cout << endl;return 0;}OVERLOADING FUNCTIONS
Sample program

OVERLOADING FUNCTIONS185Functions in traditional programming languages, such as C, which perform the same taskbut have different arguments, must have different names. To define a function that cal-
culated the maximum value of two integers and two floating-point numbers, you would
need to program two functions with different names.Example:int    int_max( int x, int y);double dbl_max( double x, double y);Of course this is detrimental to efficient naming and the readability of your program—but luckily, this restriction does not apply to C++.Overloading
C++ allows you to overload functions, that is, different functions can have the samename.Example:int    max( int x, int y);double max( double x, double y);In our example two different function share the same name, max.The function max()was overloaded for intanddoubletypes. The compiler uses a function’s signature todifferentiate between overloaded functions.Function Signatures
A function signature comprises the number and type of parameters. When a function iscalled, the compiler compares the arguments to the signature of the overloaded functions
and simply calls the appropriate function.Example:double maxvalue, value = 7.9;maxvalue = max( 1.0, value);In this case the doubleversion of the function max()is called.When overloaded functions are called, implicit type conversion takes place. However,this can lead to ambiguities, which in turn cause a compiler error to be issued.Example:maxvalue = max( 1, value);   // Error!The signature does not contain the function type, since you cannot deduce the type by
calling a function. It is therefore impossible to differentiate between overloaded func-
tions by type.Example:int    search(string key);string search(string name);Both functions have the same signature and cannot be overloaded.
186CHAPTER 10FUNCTIONS
// recursive.cpp// Demonstrates the principle of recursion by a// function, which reads a line from the keyboard
// and outputs it in reverse order.// ----------------------------------------------------#include <iostream>using namespace std;void getput(void);
int main(){cout << "Please enter a line of text:\n";getput();cout << "\nBye bye!" << endl;
return 0;}void getput(){char c;if( cin.get(c)  &&  c != '\n')getput();cout.put(c);}RECURSIVE FUNCTIONSUsing a recursive function
Program flow after typing ok<return>
1st Execution 2nd Execution 3rd Execution
main() getput() getput() getput()
{ { { {
   ...   ...   ...   ...
 // c = 'o'// c = 'k'// c = '\n'

  getput();   getput();   getput(); // No call of
   // getput()
}   cout.put(c); cout.put(c);  cout.put(c);

 } } } 

RECURSIVE FUNCTIONS187RecursionA function that calls itself is said to be recursive. This process can also be performed indi-rectly if the function first calls another function or multiple functions before it is called
once more. But a break criterion is always necessary to avoid having the function call
itself infinitely.The concept of local objects makes it possible to define recursive functions in C++.Recursion requires local objects to be created each time the function is called, and these
objects must not have access to any other local objects from other function calls. What
effectively happens is that the local objects are placed on the stack, and thus the object
created last is destroyed first.A Sample Program
Let’s look at the principle of recursion by referring to the sample program opposite. Theprogram contains the recursive function getput()that reads a line of text from thekeyboard and outputs it in reverse order.The function getput()is first called by main()and reads a character from the key-board, storing it in the local variable c. If the character is not '\n', the function get-put()calls itself again and thus reads a further character from the keyboard beforestoring it in the local variable c.The chain of recursive function calls is terminated by the user pressing the Returnkey. The last character to be read, '\n'(line feed), is output and the program flowbranches to the previous getput()instance. This outputs the second to last character,and so on. When the first character to have been read has finally been output, the pro-
gram flow is handed back to main().Practical UsageThe logic of various solutions to common problems results in a recursive structure, forexample, browsing directory trees, using binary trees for data management, or some sort-
ing algorithms, such as the quick sort algorithm. Recursive functions allow you to formu-
late this kind of logic in an efficient and elegant manner. However, always make sure
that sufficient memory is available for the stack.
exercises
188CHAPTER 10FUNCTIONS
EXERCISESHint for exercise 1
Working with several source files:Within an integrated development environment a project,containing all source
files of the program,first has to be created.This ensures that all the source files

will be compiled and linked automatically.
However,when calling the compiler/linker from the command line,it is
sufficient to declare the source files,for example:
cc  sum_t.cpp  sum.cppScreen output for exercise 3
nFactorial of n
012
345
67..
.19
20112
6241207205040.  .  ..  .  .  ..  .  .  .  .  .  .1216451004088320002432902008176640000
EXERCISES189Exercise 1
a.Write the function 
sum()with four parameters that calculates the argu-
ments provided and returns their sum.
Parameters
:Four variables of type 
long.Returns:The sum of type 
long.Use the default argument 0 to declare the last two parameter of the
functionsum().Test the function 
sum()by calling it by all three possible
methods.Use random integers as arguments.
b.Now restructure your program to store the functions 
main()andsum()in individual source files,for example,
sum_t.cppandsum.cpp.Exercise 2
a.Write an 
inlinefunction,Max(double x, double y),which returns
the maximum value of 
xandy.(Use 
Maxinstead of maxto avoid a colli-
sion with other definitions of max.) Test the function by reading values
from the keyboard.
Can the function Max()also be called using arguments of the typeschar,int,or 
long?b.Now overload 
Max()by adding a further 
inlinefunctionMax(char x,char y) for arguments of type 
char.Can the function Max()still be called with two arguments of type
int?Exercise 3
Thefactorial
n!of a positive integer 
nis defined asn! = 1*2*3 . . . * (n-1) * nWhere 
0! = 1Write a function to calculate the factorial of a number.
Argument:A number 
nof type unsigned int.Returns:The factorial 
n!of type long double.Formulate two versions of the function,where the factorial is
a.calculated using a loop
b.calculated recursively
Test both functions by outputting the factorials of the numbers 0 to 20 as shown
opposite on screen.

190CHAPTER 10FUNCTIONS
1.The power 
x0is defined as 1.0for a given number 
x.2.The power 
xnis defined as (1/x)-nfor a negative exponent 
n.3.The power 
0nwhere 
n> 0
will always yield 
0.0.The power 
0nis not defined for 
n < 0.In this case,your function should return the
valueHUGE_VAL.This constant is defined in 
math.hand represents a large 
doublevalue.Mathematical functions return 
HUGE_VALwhen the result is too large for a
double.NOTE
Exercise 4
Write a function pow(double base, int exp)to calculate integral powers of
floating-point numbers.
Arguments:The base of type 
doubleand the exponent of type int.Returns:The power 
baseexpof type double.For example,calling 
pow(2.5, 3)returns the value
2.53=  2.5 * 2.5 * 2.5  =  15.625This definition of the function pow()means overloading the standard function
pow(),which is called with two 
doublevalues.Test your function by reading one value each for the base and the exponent
from the keyboard.Compare the result of your function with the result of the

standard function.

solutions
SOLUTIONS191SOLUTIONSExercise 1
// -----------------------------------------------------// sum_t.cpp
// Calls function sum() with default arguments.// -----------------------------------------------------#include <iostream>#include <iomanip>#include <ctime>
#include <cstdlib>using namespace std;long sum( long a1, long a2, long a3=0, long a4=0);int main()             // Several calls to function sum(){cout << "  **** Computing sums  ****\n"<< endl;srand((unsigned int)time(NULL));  // Initializes the// random number generator.long res, a = rand()/10, b = rand()/10,c = rand()/10, d = rand()/10;res = sum(a,b);cout << a << " + " << b << " = " << res << endl;res = sum(a,b,c);cout << a << " + " << b << " + " << c<< " = " << res << endl;res = sum(a,b,c,d);cout << a << " + " << b << " + " << c << " + " << d<< " = " << res << endl;return 0;}// -----------------------------------------------------// sum.cpp
// Defines the function sum()// -----------------------------------------------------long sum( long a1, long a2, long a3, long a4){return (a1 + a2 + a3 + a4);}
192CHAPTER 10FUNCTIONS
Exercise 2
// -----------------------------------------------------// max.cpp// Defines and calls the overloaded functions Max().
// ------------------------------------------------------// As long as just one function Max() is defined, it can// be called with any arguments that can be converted to
// double, i.e. with values of type char, int or long.
// After overloading no clear conversion will be possible.#include <iostream>#include <string>
using namespace std;inline double Max(double x, double y){return (x < y ? y : x);}inline char Max(char x, char y){return (x < y ? y : x);}string header("To use the overloaded function Max().\n"),line(50,'-');int main()     // Several different calls to function Max(){double x1 = 0.0, x2 = 0.0;line += '\n';cout << line << header << line << endl;cout << "Enter two floating-point numbers:"<< endl;if( cin >> x1  &&  cin >> x2){cout << "The greater number is " << Max(x1,x2)<< endl;}elsecout << "Invalid input!" << endl;cin.sync(); cin.clear();   // Invalid input// was entered.
SOLUTIONS193cout << line<< "And once more with characters!"
<< endl;cout << "Enter two characters:"<< endl;char c1, c2;if( cin >> c1  &&  cin >> c2){cout << "The greater character is " << Max(c1,c2)<< endl;}elsecout << "Invalid input!" << endl;cout << "Testing with int arguments." << endl;int  a = 30, b = 50;
cout << Max(a,b) << endl;     // Error! Which// function Max()?return 0;}Exercise 3
// -----------------------------------------------------
// factorial.cpp
// Computes the factorial of an integer iteratively,// i.e. using a loop, and recursively.// -----------------------------------------------------
#include <iostream>#include <iomanip>using namespace std;#define N_MAX   20long double fact1(unsigned int n);  // Iterative solutionlong double fact2(unsigned int n);  // Recursive solutionint main(){unsigned int n;// Outputs floating-point values without// decimal places:cout << fixed << setprecision(0);
194CHAPTER 10FUNCTIONS
//  ---  Iterative computation of factorial  ---cout << setw(10) << "n" << setw(30) << "Factorial of n"<< "           (Iterative solution)\n"<< "    -----------------------------------------"
<< endl;for( n = 0; n <= N_MAX;  ++n)cout << setw(10) << n << setw(30) << fact1(n)<< endl;cout << "\nGo on with <return>";cin.get();//  ---  Recursive computation of factorial  ----
cout << setw(10) << "n" << setw(30) << "Factorial of n"<< "           (Recursive solution)\n"
<< "    -----------------------------------------"
<< endl;for( n = 0; n <= N_MAX;  ++n)cout << setw(10) << n << setw(30) << fact2(n)<< endl;cout << endl;return 0;}long double fact1(unsigned int n)       // Iterative{                                       // solution.long double result = 1.0;for( unsigned int i = 2; i <= n; ++i)result *= i;return result;}long double fact2(unsigned int n)       // Recursive{                                       // solution.if( n <= 1)return 1.0;elsereturn fact2(n-1) * n;}
SOLUTIONS195Exercise 4
// -----------------------------------------------------// power.cpp// Defines and calls the function pow() to
// compute integer powers of a floating-point number.
// Overloads the standard function pow().// -----------------------------------------------------#include <iostream>
#include <cmath>using namespace std;double pow(double base, int exp);int main()     // Tests the self-defined function pow(){double base    = 0.0;int    exponent = 0;cout << "  **** Computing Integer Powers ****\n"<< endl;cout << "Enter test values.\n"<< "Base (floating-point): ";  cin >> base;cout << "Exponent (integer):     ";  cin >> exponent;cout << "Result of " << base << " to the power of "<< exponent << " = " << pow( base, exponent)<< endl;cout << "Computing with the standard function: "<< pow( base, (double)exponent) << endl;return 0;}double pow(double base, int exp)
{if( exp == 0)     return 1.0;if( base == 0.0)if( exp > 0)  return 0.0;
else          return HUGE_VAL;if( exp < 0){base = 1.0 / base;exp = -exp;}
double power = 1.0;
for( int n = 1; n <= exp; ++n)power *= base;return power;}
This page intentionally left blank 
197Storage Classes andNamespacesThis chapter begins by describing storage classes for objects and
functions.The storage class is responsible for defining those parts of a

program where an object or function can be used.Namespaces can be

used to avoid conflicts when naming global identifiers.
chapter
11
198CHAPTER 11ST0RAGE CLASSES AND NAMESPACES
file scopeblock scopeprogram scopeFunctionModule 1Module 2file scopeblock scopeFunctionblock scopeFunctionSTORAGE CLASSES OF OBJECTS
Availability of Objects
C++ program
Storage Class SpecifiersThe storage class of an object is determined bythe position of its declaration in the source filethe storage class specifier, which can be supplied optionally.The following storage class specifiers can be usedexternstaticautoregister

STORAGE CLASSES OF OBJECTS199When an object is declared, not only are the object’s type and name defined but also itsstorage class. The storage class specifies the lifetimeof the object, that is, the period oftime from the construction of the object until its destruction. In addition, the storage
class delimits the part of the program in which the object can be accessed directly by its
name, the so-called object scope.Essentially, an object is only available after you have declared it within a translationunit. A translation unit, also referred to as module,comprises the source file you are com-piling and any header files you have included.As a programmer, you can define an object with:block scopeThe object is only available in the code block in which it was
defined. The object is no longer visible once you have left
the code block.file scopeThe object can be used within a 
singlemodule. Only thefunctions within this module can reference the object. Other
modules cannot access the object directly.program scopeThe object is available throughout the program, providing a
common space in memory that can be referenced by any pro-
gram function. For this reason, these objects are often
referred to as global.Access to an object as defined by the object’s storage class is independent of anyaccess controls for the elements of a class. Namespaces that subdivide program scope and
classes will be introduced at a later stage.LifetimeObjects with block scope are normally created automatically within the code block thatdefines them. Such objects can only be accessed by statements within that block and are
calledlocalto that block. The memory used for these objects is freed after leaving thecode block. In this case, the lifetime of the objects is said to be automatic.However, it is possible to define objects with block scope that are available through-out the runtime of a program. The lifetime of these objects is said to be static. When theprogram flow re-enters a code block, any pre-existing conditions will apply.Objects with program and file scope are always static. These objects are created whena program is launched and are available until the program is terminated.Four storage classes are available for creating objects with the scope and lifetime youneed. These storage classes will be discussed individually in the following sections.
200CHAPTER 11ST0RAGE CLASSES AND NAMESPACES
// Cutline1.cpp// A filter to remove white-space characters// at the ends of lines.
// --------------------------------------------------
#include <iostream>
#include <string>
using namespace std;void cutline( void );         // Prototypestring line;                  // Global stringint main(){while( getline(cin, line)) // As long as a line
{                          // can be read.cutline();               // Shorten the line.cout << line << endl;    // Output the line.}
return 0;}// Cutline2.cpp// Containing the function cutline(), which removes// tabulator characters at the end of the string line.// The string line has to be globally defined in another
// source file.// --------------------------------------------------#include <string>using namespace std;extern string line;             // extern declarationvoid cutline(){int i = line.size();         // Position after the// last character.while( i-- >= 0 )if(   line[i] != ' '       // If no blank and&& line[i] != '\t' )    // no tab ->break;                   // stop the loop.line.resize(++i);            // Fix new length.}THE STORAGE CLASS 
externSource file 1
Source file 2

THE STORAGE CLASS extern201Defining Global ObjectsIf an object is not defined within a function, it belongs to the externstorage class.Objects in this storage class have program scope and can be read and, provided they have
not been defined as const, modified at any place in the program. External objects thusallow you to exchange information between any functions without passing any argu-
ments. To demonstrate this point, the program on the opposite page has been divided
into two separate source files. The string line, which has a global definition, is used toexchange data.Global objects that are not explicitly initialized during definition receive an initialvalue of 0(that is, all bits = 0) by default. This also applies to objects belonging to classtypes, if not otherwise stipulated by the class.Using Global ObjectsAn object belonging to the externstorage class is initially only available in the sourcefile where it was defined. If you need to use an object before defining it or in another
module, you must first declare the object. If you do not declare the object, the compiler
issues a message stating that the object is unknown. The declaration makes the name and
type of the object known to the compiler.In contrast to a definition, the storage class identifier externprecedes the objectname in a declaration.Example:extern long position;     // DeclarationThis statement declares positionas an external object of type long. The externdeclaration thus allows you to “import” an object from another source file.A global object must be defined once, and once only, in a program. However, it canbe declared as often as needed and at any position in the program. You will normally
declare the object before the first function in a source file or in a header file that you can
include when needed. This makes the object available to any functions in the file.
Remember, if you declare the object within a code block, the object can only be used
within the same block.Anexterndeclaration only refers to an object and should therefore not be used toinitialize the object. If you do initialize the object, you are defining that object!Global objects affect the whole program and should be used sparingly. Large programs in particularshould contain no more than a few central objects defined as extern.NOTE

202CHAPTER 11ST0RAGE CLASSES AND NAMESPACES
// Passw1.cpp// The functions getPassword() and timediff()
// to read and examine a password.// -----------------------------------------------------#include <iostream>
#include <iomanip>#include <string>#include <ctime>using namespace std;long timediff(void);                      // Prototypestatic string secret = "ISUS"; // Passwordstatic long  maxcount = 3, maxtime = 60;// Limitsbool getPassword()     // Enters and checks a password.{              // Return value: true, if password is ok.bool ok_flag = false;       // For return valuestring word;                // For inputint count = 0, time = 0;timediff();                 // To start the stop watchwhile( ok_flag != true &&++count <= maxcount)   // Number of attempts{cout << "\n\nInput the password:  ";
cin.sync();                // Clear input buffercin >> setw(20) >> word;time += timediff();
if( time >= maxtime )      // Within time limit?break;                  // No!if( word != secret)cout << "Invalid password!" << endl;elseok_flag = true;       // Give permission}return ok_flag;            // Result}long timediff()          // Returns the number of{                        // seconds after the last call.static long  sec = 0;// Time of last call.long  oldsec = sec;      // Saves previous time.time( &sec);             // Reads new time.return (sec - oldsec);   // Returns the difference.}THE STORAGE CLASS 
static
THE STORAGE CLASS static203In contrast to objects with an externdefinition, the name of an external static object is unknown tothe linker and thus retains its private nature within a module.NOTE
Static Objects
If an object definition is preceded by the statickeyword, the object belongs to thestatic storage class.Example:static int count;The most important characteristic of static objects is their static(or permanent) lifetime.Static objects are not placed on the stack, but are stored in the data area of a program
just like external objects.However, in contrast to external objects, access to static objects is restricted. Twoconditions apply, depending on where the object is defined:1.Definition external to all program functionsIn this case, the object is external static, that is, the object can be designated usingits name within the module only, but will not collide with any objects using the
same name in other modules.2.Definition within a code blockThis means that the object is internal static, that is, the object is only visiblewithin a single block. However, the object is created only once and is not
destroyed on leaving the block. On re-entering the block, you can continue to
work with the original object.The same rules apply to initializing static objects as they do to external objects. If theobject is not initialized explicitly, a default value of 0applies.Notes on the Sample Programs Opposite
The function getPassword()checks a password that is entered. Permission is refusedfollowing three unsuccessful attempts or when 60 seconds have elapsed. You could use
the following instructions to call the function in another source file:Example:if( !getPassword() )cout << "No authorization!\n"; exit(1);The string secretand the thresholds maxcountandmaxtimeare external static,whereas the variable secin the function timediff()is internal static. Its value is zeroonly when the function is first called.It makes sense to add a further function to these source files providing for passwordchanges.
204CHAPTER 11ST0RAGE CLASSES AND NAMESPACES
// StrToL.cpp// The function strToLong() converts a string containing
// a leading integer into an integer of type long.
// Argument:     A string.
// Return value: An integer of type long.// --------------------------------------------------// The digits are interpreted with base 10. White spaces
// and a sign can precede the sequence of digits.// The conversion terminates when the end of the string is// reached or when a character that cannot be converted is// reached.// --------------------------------------------------#include <string>           // Type string#include <cctype>           // isspace() and isdigit()
using namespace std;long strToLong( string str){register int i = 0;// Indexlong vz = 1, num = 0;         // Sign and number// Ignore leading white spaces.for(i=0; i < str.size() && isspace(str[i]); ++i);// Is there a sign?if( i < str.size()){if( str[i] == '+' ) { vz = 1;  ++i; }if( str[i] == '-' ) { vz = ---1; ++i; }}// Sequence of digits -> convert to integerfor( ; i < str.size() && isdigit(str[i]); ++i)num = num * 10 + (str[i] - '0');return vz * num;}THE SPECIFIERS autoANDregisterSample function with a register variable

THE SPECIFIERS autoANDregister205autoObjectsThe storage class auto(automatic) includes all those objects defined within a functionbut without the statickeyword. The parameters of a function are also autoobjects.Youcanuse the autokeyword during a definition.Example:auto float radius;// Equivalent to:
// float radius;When the program flow reaches the definition, the object is created on the stack, but incontrast to a statictype object, the object is destroyed on leaving the block.autoobjects have no specific initial value if they are not initialized explicitly. How-ever, objects belonging to a class type are normally initialized with default values, which
can be specified in the class definition.Using CPU Registers
To increase the speed of a program, commonly used autovariables can be stored inCPUregistersinstead of on the stack. In this case, the registerkeyword is used todeclare the object.A register is normally the size of an intvariable. In other words, it only makes senseto define registervariables if the variable is not too large, as in the case of types suchaschar,short,intor pointers. If you omit the type when defining a register variable,anintis assumed.However, the compiler can ignore the registerkeyword. The number of registersavailable for register variables depends on your hardware, although two registers are nor-
mally available. If a program defines too many registervariables in a code block, thesuperfluous variables are placed in the autostorage class.Sample FunctionThe function strToLong()illustrates an algorithm that converts a sequence of digitsto a binary number. This is useful if you need to perform calculations with a number con-
tained in a string.The algorithm using the string "37"and the longvariablenum:Step 0:num = 0;
Step 1:1st character  '3'   
number 3 = ('3'-'0')num = num * 10 + 3;        // = 3Step 2:2nd character '7'   
number 7 = ('7'-'0')num = num * 10 + 7;        // = 37 This pattern is followed for every number in a longer string.
206CHAPTER 11ST0RAGE CLASSES AND NAMESPACES
extern bool getPassword(void);// Prototypeint main(){// The function permission(),// but not the function timediff()
// can be called here....}static long timediff(void);// Prototypebool getPassword(void)// Definition{// timediff() can be called here....}static long timediff(void) // Definition{...}THE STORAGE CLASSES OF FUNCTIONS
Example of a Program Structure
Source file 1
Source file 2

THE STORAGE CLASSES OF FUNCTIONS207Only two storage classes are available for functions: externandstatic. Functionswith block scope are invalid: you cannot define a function within another function.The storage class of a function defines access to the function, as it does for an object.External functions have program scope, whereas static functions have file scope.External Functions
If the keyword staticis not used when defining a function, the function must belongto the externstorage class.In a similar manner to external objects, external functions can be used at any positionin a program. If you need to call a function before defining it, or in another source file,
you will need to declare that function.Example:extern bool getPassword(void); // PrototypeAs previously seen, you can omit the externkeyword, since functions belong to theexternstorage class by default.Static Functions
To define a static function, simply place the keyword staticbefore the functionheader.Example:static long timediff(){  . . .  }Functions in the staticstorage class have “private” character: they have file scope,just like external static objects. They can only be called in the source file that defines
them. The name of a staticfunction will not collide with objects and functions of thesame name in other modules.If you need to call a staticfunction before defining it, you must first declare thefunction in the source file.Example:static long timediff( void );The program structure opposite takes up the example with the functionsgetPassword()andtimediff()once more. The function timediff()is an aux-iliary function and not designed to be called externally. The function is declared asstaticfor this reason.
208CHAPTER 11ST0RAGE CLASSES AND NAMESPACES
// namesp1.cpp// Defines and tests namespaces.// ----------------------------------------------------
#include <string>       // Class string defined within// namespace stdnamespace MySpace{std::string mess = "Within namespace MySpace";
int count = 0;         // Definition: MySpace::count
double f( double);     // Prototype:   MySpace::f()}
namespace YourSpace{std::string mess = "Within namespace YourSpace";void f( )                     // Definition of{                             // YourSpace::f()mess += '!';}}
namespace MySpace // Back in MySpace.{int g(void);            // Prototype of MySpace::g()
double f( double y)           // Definition of{                             // MySpace::f()return y / 10.0;}}
int MySpace::g( )              // Separate definition{                              // of MySpace::g()return ++count;}#include <iostream>   // cout, ... within namespace stdint main(){std::cout << "Testing namespaces!\n\n"<< MySpace::mess << std::endl;MySpace::g();
std::cout << "\nReturn value g(): " << MySpace::g()<< "\nReturn value f(): " << MySpace::f(1.2)<< "\n---------------------" << std::endl;YourSpace::f();std::cout << YourSpace::mess << std::endl;return 0;}NAMESPACES
Defining namespaces
NAMESPACES209Using global names in large-scale software projects can lead to conflicts, especially whenmultiple class libraries are in operation.C++ provides for the use of namespaces in order to avoid naming conflicts with globalidentifiers. Within a namespace, you can use identifiers without needing to check
whether they have been defined previously in an area outside of the namespace. Thus,
the global scope is subdivided into isolated parts.A normal namespace is identified by a name preceded by the namespacekeyword.The elements that belong to the namespace are then declared within braces.Example:namespace myLib{int count;
double calculate(double, int);
// . . .}This example defines the namespace myLibthat contains the variable countand thefunctioncalculate().Elements belonging to a namespace can be referenced directly by name withinthenamespace. If you need to reference an element from outsideof the namespace, you mustadditionally supply the namespace. To do so, place the scope resolution operator, ::,before the element name.Example:myLib::count = 7;     // Outside of myLibThis allows you to distinguish between identical names in different namespaces. You can
also use the scope resolution operator ::to reference global names, that is, namesdeclared outside of any namespaces. To do so, simply omit the name of the namespace.
This technique is useful when you need to access a global name that is hidden by an
identical name defined in the current namespace.Example:::demo();  // Not belonging to any namespaceBe aware of the following when using namespaces:namespaces do not need to be defined contiguously. You can reopen and expand
a namespace you defined previously at any point in the programnamespaces can be nested, that is, you can define a namespace within another
namespace.Global identifiers belonging to the C++ standard library automatically belong to thestandard namespacestd.
210CHAPTER 11ST0RAGE CLASSES AND NAMESPACES
// namesp2.cpp// Demonstrates the use of using-declarations and
// using-directives.
// ----------------------------------------------------
#include <iostream>      // Namespace stdvoid message()           // Global function ::message(){std::cout << "Within function ::message()\n";}namespace A{using namespace std; // Names of std are visible here
void message()       // Function A::message(){cout << "Within function A::message()\n";}}namespace B{using std::cout;      // Declaring cout of std.void message(void);   // Function B::message()}
void B::message(void)    // Defining B::message(){cout << "Within function B::message()\n";}int main(){using namespace std;  // Names of namespace std
using B::message;     // Function name without// braces!cout << "Testing namespaces!\n";
cout << "\nCall of A::message()" << endl;A::message();cout << "\nCall of B::message()" << endl;message();           // ::message() is hidden because// of the using-declaration.cout << "\nCall of::message()" << endl;::message();              // Global functionreturn 0;}THE KEYWORD 
usingSample program

THE KEYWORD using211You can simplify access to the elements of a namespace by means of a using declarationorusing directive. In this case, you do not need to repeatedly quote the namespace. Just likenormal declarations, usingdeclarations and usingdirectives can occur at any part ofthe program.usingDeclarations
Ausingdeclaration makes an identifier from a namespace visible in the current scope.Example:using myLib::calculate;    // DeclarationYou can then call the function calculate()from the myLibnamespace.double erg = calculate( 3.7, 5); This assumes that you have not previously used the name calculatein the samescope.usingDirective
Theusing directiveallows you to import allthe identifiers in a namespace.Example:using namespace myLib;This statement allows you to reference the identifiers in the myLibnamespace directly.IfmyLibcontains an additional namespace and a usingdirective, this namespace isalso imported.If identical identifiers occur in the current namespace and an imported namespace,theusingdirective does not automatically result in a conflict. However, referencing anidentifier can lead to ambiguities. In this case, you should use the scope resolution opera-
tor to resolve the situation.C++ header files without file extensions are used to declare the global identifiers inthe standard namespace std. The usingdirective was used in previous examples toimport any required identifiers to the global scope:Example:#include <string>using namespace std;When developing large-scale programs or libraries, it is useful to declare the elements ofany proprietary namespaces in header files. Normal source files are used to define these
elements.
exercises
212CHAPTER 11ST0RAGE CLASSES AND NAMESPACES
// scope.cpp// Accessing objects with equal names// ---------------------------------------------------#include <iostream>#include <iomanip>using namespace std;int var = 0;
namespace Special {  int var = 100; }int main(){int var = 10;cout << setw(10) << var;                   // 1.{int var = 20;cout << setw(10) << var << endl;        // 2.{++var;
cout << setw(10) << var;              // 3.cout << setw(10) << ++ ::var;         // 4.
cout << setw(10) << Special::var * 2  // 5.<< endl;}cout << setw(10) << var - ::var;        // 6.}
cout << setw(10) << var << endl;           // 7.return 0;}EXERCISESProgram listing for exercise 1

EXERCISES213Exercise 1
In general,you should use different names for different objects.However,if you
define a name for an object within a code block and the name is also valid for

another object,you will reference only the new object within the code block.

The new declaration hides any object using the same name outside of the block.

When you leave the code block,the original object once more becomes visible.
The program on the opposite page uses identical variable names in different
blocks.What does the program output on screen?
Exercise 2
You are developing a large-scale program and intend to use two commercial

libraries,tool1andtool2.The names of types,functions,macros,and so on are
declared in the header files 
tool1.handtool2.hfor users of these libraries.
Unfortunately,the libraries use the same global names in part.In order to use
both libraries,you will need to define namespaces.

Write the following program to simulate this situation:
Define an inline function called calculate()that returns the sum of two
numbers for the header file 
tool1.h.The function interface is as follows:
double calculate(double num1, double num2); Define an inline function called calculate()that returns the product of
two numbers for a second header file 
tool2.h.This function has the
same interface as the function in tool1.h.Then write a source file containing a 
mainfunction that calls both func-tions with test values and outputs the results.
To resolve potential naming conflicts,define the namespaces 
TOOL1andTOOL2that include the relevant header files.

214CHAPTER 11ST0RAGE CLASSES AND NAMESPACES
// static.cpp// Tests an internal static variable// ---------------------------------------------------
#include <iostream>#include <iomanip>using namespace std;double x = 0.5,fun(void);int main(){while( x < 10.0 ){x += fun();cout << "     Within main(): "<< setw(5) << x << endl;}return 0;}double fun(){static double x = 0;cout << "      Within fun():"<< setw(5) << x++;return x;}Program listing for exercise 3

EXERCISES215The modified password is only available during runtime as it is not stored permanently.NOTE
Exercise 3
Test your knowledge of external and static variables by reference to the
program on the opposite page.What screen output does the program generate?
Exercise 4
a.The function 
getPassword(),which checks password input,was intro-
duced previously as an example of the use of static variables.Modify the

source file 
Passw1.cpp,which contains the function 
getPassword(),by
adding the function 
changePassword().This function allows the user to
change his or her password.Save the modified source file as
Passw2.cpp.b.A large-scale program with several users is used to perform bookings.
Only authorized users,that is,users that have access to the password,are

allowed to perform bookings.
In the initial stages of program development,you need to test the
functionality of the source file,
Passw2.cpp.To do so,create a new
source file with a 
mainfunction that contains only the following menu
items in its main loop:B = BookingE = End of program WhenBis typed,the password is first checked.If the user enters the
correct password,he or she can change the password.The program does

not need to perform any real bookings.

solutions
216CHAPTER 11ST0RAGE CLASSES AND NAMESPACES
SOLUTIONSExercise 1
Screen output of the program
10        2021         1       200
20        10 Exercise 2
// ----------------------------------------------------
// tool1.h
// Defining first function calculate() inline.// ----------------------------------------------------#ifndef _TOOL1_H_#define _TOOL1_H_inline double calculate( double num1, double num2){return num1 + num2;}#endif  // End of _TOOL1_H_// ----------------------------------------------------// tool2.h// Defining second function calculate() inline.
// ----------------------------------------------------#ifndef _TOOL2_H_#define _TOOL2_H_inline double calculate( double num1, double num2){return num1 * num2;}#endif  // End of _TOOL2_H_
SOLUTIONS217// --------------------------------------------------------// tool_1_2.cpp
// Uses two "libraries" and tests name lookup conflicts.// --------------------------------------------------------#include <iostream>namespace TOOL1{#include "tool1.h"}
namespace TOOL2
{#include "tool2.h"}#include <iostream>int main()
{using namespace std;double x = 0.5, y = 10.5, res = 0.0;cout << "Calling function of Tool1!" << endl;res = TOOL1::calculate( x, y);cout << "Result:  " << res<< "\n---------------------------------" << endl;cout << "Calling function of Tool2!" << endl;res = TOOL2::calculate( x, y);cout << "Result:  " << res << endl;return 0;}Exercise 3
Screen output of the program
In fun():    0     In main():   1.5
In fun():    1     In main():   3.5
In fun():    2     In main():   6.5In fun():    3     In main():  10.5 
218CHAPTER 11ST0RAGE CLASSES AND NAMESPACES
Exercise 4
// -----------------------------------------------------// Passw2.cpp// Defines the functions getPassword(), timediff() and
// changePassword() to examine and change a password.
// -----------------------------------------------------#include <iostream>#include <iomanip>
#include <string>#include <ctime>using namespace std;static long timediff(void);              // Prototypestatic string secret = "guest";          // Password
static long  maxcount = 3, maxtime = 60; // Limitsbool getPassword()  // Read and verify a password.{// As before.// . . .}// Auxiliary function timediff() --> defining staticstatic long timediff()   // Returns the number of seconds
{                        // since the last call.// As before.// . . .}bool changePassword()    // Changes password.{                        // Returns: true, if the// password has been changedstring word1,word2;          // For input// To read a new passwordcout <<"\nEnter a new password (2 - 20 characters): ";cin.sync();                   // Discards former input
cin >> setw(20) >> word1;
SOLUTIONS219if( word1.size() > 1){cout << "\nEnter the password once more: ";cin >> setw(20) >> word2;
if( word1 == word2)       // Password confirmed?{                         // Yes!secret = word1;return true;}}return false;                // No new password}// -----------------------------------------------------// Password.cpp// Testing the functions getPassword() and// changePassword().
//
// After entering the password correctly (max. three// attempts within 60 seconds), the user can change it.// -----------------------------------------------------
#include <iostream>
#include <iomanip>
#include <string>#include <cctype>using namespace std;bool getPassword(void);            // Read a password.bool changePassword(void);         // Change a password.// Inline functions:
inline void cls()  { cout << "\033[2J"; }
inline void go_on()
{cout << "\n\nGo on with return! ";cin.sync();  cin.clear();          // Only new input
while( cin.get() != '\n');}inline char getYesOrNo()   // Read character Y or N.
{char c = 0;cin.sync();  cin.clear();          // Just new inputdo
{cin.get(c);c = toupper(c); // Permitting lower case letters also.}
while( c != 'Y'  && c != 'N');
return c;}
220CHAPTER 11ST0RAGE CLASSES AND NAMESPACES
static string header ="\n\n      ****  Test password handling  ****\n\n";static string menu ="\n\n              B = Booking "
"\n\n              E = End of program""\n\n Your choice:   ";int main(){char choice = 0;
while( choice != 'E')
{cls();   cout << header << menu;  // Header and Menucin.get(choice);   choice = toupper(choice);
cls();   cout << header << endl;  // Headerswitch( choice){case 'B':                       // Bookingif( !getPassword() ){cout << "Access denied!" << endl;go_on();}
else
{ cout << "Welcome!\n\n"<< "Do you want to change the password? (y/n)";if( getYesOrNo() == 'Y'){if( changePassword() )cout << "Password changed!" << endl;elsecout << "Password unchanged!" << endl;go_on();}
// Place statements for booking here.}break;case 'E':cls();  cout << "\n    Bye Bye!" << endl;break;}} // End of whilereturn 0;}
221References and Pointers
This chapter describes how to define references and pointers and how
to use them as parameters and/or return values of functions.In this

context,passing by reference and read-only access to arguments are

introduced.chapter
12
222CHAPTER 12REFERENCES AND POINTERS
// Ref1.cpp// Demonstrates the definition and use of references.
// ---------------------------------------------------#include <iostream>#include <string>
using namespace std;float x = 10.7F;                           // Global
int main(){float  &rx = x;// Local reference to x// double &ref = x;         // Error: different type!rx *= 2;cout << "   x = " <<  x << endl    //  x = 21.4<< "  rx = " << rx << endl;   // rx = 21.4const float& cref = x; // Read-only referencecout << "cref = " <<  cref << endl;   // ok!// ++cref;                   // Error: read-only!const string str = "I am a constant string!";// str = "That doesn't work!";  // Error: str constant!// string& text = str;          // Error: str constant!const string& text = str;// ok!cout << text << endl;        // ok! Just reading.return 0;}Object names:The object in
memory10.7x, rx. . .. . .DEFINING REFERENCESExamplefloat x = 10.7,  &rx = x; Sample program

DEFINING REFERENCES223A reference is another name, or alias, for an object that already exists. Defining a refer-ence does not occupy additional memory. Any operations defined for the reference are
performed with the object to which it refers. References are particularly useful as parame-
ters and return values of functions.DefinitionThe ampersand character, &, is used to define a reference. Given that Tis a type, T&denotes a reference to T.Example:float x = 10.7;float& rx = x;   // or:  float &rx = x;rxis thus a different way of expressing the variable xand belongs to the type “referencetofloat”. Operations with rx, such asExample:--rx;            // equivalent to  --x;will automatically affect the variable x. The &character, which indicates a reference,only occurs in declarations and is not related to the address operator &!The addressoperator returns the address of an object. If you apply this operator to a reference, it
returns the address of the referenced object.Example:&rx    // Address of x, thus is equal to &xA reference must be initializedwhen it is declared, and cannot be modified subse-quently. In other words, you cannot use the reference to address a different variable at a
later stage.Read-Only References
A reference that addresses a constant object must be a constant itself, that is, it must bedefined using the constkeyword to avoid modifying the object by reference. However,it is conversely possible to use a reference to a constantto address a non-constant object.Example:int a;    const int& cref = a;  // ok!The reference crefcan be used for read-only access to the variable a, and is said to be aread-only identifier.A read-only identifier can be initialized by a constant, in contrast to a normal refer-ence:Example:const double& pi = 3.1415927;Since the constant does not take up any memory space, the compiler creates atemporary object which is then referenced. 
224CHAPTER 12REFERENCES AND POINTERS
// Ref2.cpp// Demonstrating functions with parameters
// of reference type.
// --------------------------------------------------#include <iostream>#include <string>using namespace std;// Prototypes:bool getClient( string& name, long& nr);void putClient( const string& name, const long& nr);int main(){string clientName;
long   clientNr;cout << "\nTo input and output client data \n"<< endl;if(getClient( clientName, clientNr))
// CallsputClient( clientName, clientNr);elsecout << "Invalid input!" << endl;return 0;}bool getClient( string& name, long& nr) // Definition{cout << "\nTo input client data!\n"<< " Name:   ";if( !getline( cin, name))  return false;cout << " Number: ";if( !( cin >> nr))  return false;return true;}// Definitionvoid putClient( const string& name, const long& nr){                      // name and nr can only be read!cout << "\n-------- Client Data ---------\n"<< "\n Name:   ";  cout << name
<< "\n Number: ";  cout << nr << endl;}REFERENCES AS PARAMETERS
Sample program

REFERENCES AS PARAMETERS225Passing by Reference
Apass by referencecan be programmed using references or pointers as function parame-ters. It is syntactically simpler to use references, although not always permissible.A parameter of a reference type is an alias for an argument. When a function is called,a reference parameter is initialized with the object supplied as an argument. The function
can thus directly manipulate the argument passed to it.Example:void test( int& a) { ++a; }Based on this definition, the statementtest( var);     // For an int variable var increments the variable var. Within the function, any access to the reference aauto-matically accesses the supplied variable, var.If an object is passed as an argument when passing by reference, the object is notcopied. Instead, the address of the object is passed to the function internally, allowing
the function to access the object with which it was called.Comparison to Passing by Value
In contrast to a normal pass by valuean expression, such as a+b, cannot be used as anargument. The argument must have an address in memory and be of the correct type.Using references as parameters offers the following benefits:arguments are not copied. In contrast to passing by value, the run time of a pro-gram should improve, especially if the arguments occupy large amounts of mem-
orya function can use the reference parameter to return multiplevalues to the callingfunction. Passing by value allows only one result as a return value, unless you
resort to using global variables.If you need to read arguments, but not copy them, you can define a read-only referenceas a parameter.Example:void display( const string& str);The function display()contains a string as an argument. However, it does not gener-ate a new string to which the argument string is copied. Instead, stris simply a refer-ence to the argument. The caller can rest assured that the argument is not modified
within the function, as stris declared as a const.
226CHAPTER 12REFERENCES AND POINTERS
// Ref3.cpp// Demonstrates the use of return values with// reference type.
// --------------------------------------------------#include <iostream>#include <string>using namespace std;// Returns adouble& refMin( double&, double&);// reference to// the minimum.int main(){double x1 = 1.1,  x2 = x1 + 0.5,  y;y = refMin( x1, x2);// Assigns the minimum to y.cout << "x1 = " << x1 << "     "<< "x2 = " << x2 << endl;cout << "Minimum: " << y  << endl;++refMin( x1, x2);// ++x1, as x1 is minimalcout << "x1 = " << x1 << "     "      // x1 = 2.1<< "x2 = " << x2 << endl;        // x2 = 1.6++refMin( x1, x2);// ++x2, because x2 is// the minimum.cout << "x1 = " << x1 << "     "      // x1 = 2.1<< "x2 = " << x2 << endl;        // x2 = 2.6refMin( x1, x2) = 10.1; // x1 = 10.1, because// x1 is the minimum.cout << "x1 = " << x1 << "     "      // x1 = 10.1<< "x2 = " << x2 << endl;        // x2 = 2.6refMin( x1, x2) += 5.0;// x2 += 5.0, because// x2 is the minimum.cout << "x1 = " << x1 << "     "      // x1 = 10.1<< "x2 = " << x2 << endl;        // x2 = 7.6return 0;}double& refMin( double& a, double& b)// Returns a{                                      // reference toreturn a <= b ? a : b;             // the minimum.}The expression refMin(x1,x2)represents either the object x1or the object x2, that is, the objectcontaining the smaller value.NOTE
REFERENCES AS RETURN VALUE
Sample program

REFERENCES AS RETURN VALUE227Returning References
The return type of a function can also be a reference type. The function call then repre-sents an object, and can be used just like an object.Example:string& message()           // Reference!{static string str ="Today only cold cuts!";

return str;}This function returns a reference to a staticstring,str. Pay attention to the followingpoint when returning references and pointers:The object referenced by the return value must exist after leaving the function.
It would be a critical error to declare the string stras a normal autovariable in thefunctionmessage(). This would destroy the string on leaving the function and the ref-erence would point to an object that no longer existed.Calling a Reference Type Function
The function message()(mentioned earlier in this section) is of type “reference tostring.”Thus, calling
message()represents a stringtype object, and the following statements are valid:message() = "Let's go to the beer garden!";message() += " Cheers!";
cout << "Length: " << message().length();In these examples, a new value is first assigned to the object referenced by the functioncall. Then a new string is appended before the length of the referenced string is output in
the third statement.If you want to avoid modifying the referenced object, you can define the function typeas a read-only reference.Example:const string& message();     // Read-only!References are commonly used as return types when overloading operators. The oper-ations that an operator has to perform for a user-defined type are always implemented by
an appropriate function. Refer to the chapters on overloading operators later in this book
for more details. However, examples with operators from standard classes can be pro-
vided at this point.
228CHAPTER 12REFERENCES AND POINTERS
Reference to coutcout << "Good morning"<<'!';// Ref4.cpp// Expressions with reference type exemplified by
// string assignments.// --------------------------------------------------#include <iostream>#include <string>#include <cctype>                // For toupper()
using namespace std;void strToUpper( string& );// Prototypeint main()
{string text("Test with assignments \n");strToUpper(text);cout << text << endl;strToUpper( text = "Flowers");cout << text << endl;strToUpper( text += " cheer you up!\n");cout << text << endl;
return 0;}void strToUpper( string& str)// Converts the content{                              // of str to uppercase.int len = str.length();
for( int i=0; i < len; ++i)str[i] = toupper( str[i]);}EXPRESSIONS WITH REFERENCE TYPE
Example:Operator 
<<of class ostreamcout << "Good morning" << '!';Sample assignments of class string
EXPRESSIONS WITH REFERENCE TYPE229Every C++ expression belongs to a certain type and also has a value, if the type is notvoid. Reference types are also valid for expressions.The Stream Class Shift Operators
The<<and>>operators used for stream input and output are examples of expressionsthat return a reference to an object.Example:cout << " Good morning "This expression is not a voidtype but a reference to the object cout, that is, it repre-sents the object cout. This allows you to repeatedly use the <<on the expression:cout << "Good morning" << '!'The expression is then equivalent to(cout << " Good morning ") << '!'Expressions using the <<operator are composed from left to right, as you can see fromthe table of precedence contained in the appendix.Similarly, the expression cin >> variablerepresents the stream cin. This allowsrepeated use of the >>operator.Example:int a;  double x;cin >> a >> x;       // (cin >> a) >> x;Other Reference Type Operators
Other commonly used reference type operators include the simple assignment operator =and compound assignments, such as +=and*=. These operators return a reference to theoperand on the left. In an expression such asa = bora += bamust therefore be an object. In turn, the expression itself represents the object a. Thisalso applies when the operators refer to objects belonging to class types. However, the
class definition stipulates the available operators. For example, the assignment operators=and+=are available in the standard class string.Example:string name("Jonny ");name += "Depp";          //Reference to nameSince an expression of this type represents an object, the expression can be passed asan argument to a function that is called by reference. This point is illustrated by the
example on the opposite page.
230CHAPTER 12REFERENCES AND POINTERS
100456FD4ptrvar456FD0456FD4Address(hexadecimal)
VariableValue of the Variable
. . .. . .// pointer1.cpp// Prints the values and addresses of variables.
// --------------------------------------------------#include <iostream>using namespace std;int var, *ptr;// Definition of variables var and ptrint main()        // Outputs the values and addresses{                 // of the variables var and ptr.var = 100;
ptr = &var;cout << " Value of var:      " <<  var<< "   Address of var: " <<  &var
<< endl;cout << " Value of ptr: "      <<  ptr<< "   Address of ptr: " <<  &ptr<< endl;return 0;}DEFINING POINTERSSample program
Sample screen output
Value of var:      100   Address of var: 00456FD4Value of ptr: 00456FD4   Address of ptr: 00456FD0The variables 
varandptrin memory

DEFINING POINTERS231Efficient program logic often requires access to the memory addresses used by a program’sdata, rather than manipulation of the data itself. Linked lists or trees whose elements are
generated dynamically at runtime are typical examples.Pointers
Apointeris an expression that represents both the addressandtypeof another object.Using the address operator, &, for a given object creates a pointer to that object. Giventhatvaris an intvariable,Example:&var         // Address of the object varis the address of the intobject in memory and thus a pointer to var. A pointer pointsto a memory address and simultaneously indicates by its type how the memory address
can be read or written to. Thus, depending on the type, we refer to pointers to char,point-ers to int, and so on, or use an abbreviation, such as char pointer, int pointer, and so on.Pointer Variables
An expression such as &varis a constant pointer; however, C++ allows you to definepointer variables, that is, variables that can store the address of another object.Example:int *ptr;            // or:  int* ptr;This statement defines the variable ptr,which is an 
int*type (in other words, a pointerto int).ptrcan thus store the address of an intvariable. In a declaration, the star char-acter*always means “pointer to.”Pointer typesare derived types. The general form is T*, where Tcan be any given type.In the above example Tis an inttype.Objects of the same base type Tcan be declared together.Example:int a, *p, &r = a;  // Definition of a, p, rAfter declaring a pointer variable, you must point the pointer at a memory address. Theprogram on the opposite page does this using the statementptr = &var;.References and Pointers
References are similar to pointers: both refer to an object in memory. However, a pointeris not merely an alias but an individual object that has an identity separate from the
object it references. A pointer has its own memory address and can be manipulated by
pointing it at a new memory address and thus referencing a different object.
232CHAPTER 12REFERENCES AND POINTERS
AddressofpxAddress of x= value of pxValue of 
xpx&px&x
pxx*pxxdouble x, y, *px;px = &x;          // Let px point to x.*px = 12.3;        // Assign the value 12.3 to x*px += 4.5;        // Increment x by 4.5.y  = sin(*px);    // To assign sine of x to y.THE INDIRECTION OPERATOR
Using the indirection operator
Address and value of the variables 
xandpxNotes on addresses in a program
Each pointer variable occupies the same amount of space, independent of thetype of object it references. That is, it occupies as much space as is necessary to
store an address. On a 32-bit computer, such as a PC, this is four bytes.The addresses visible in a program are normally logic addresses that are allocated
and mapped to physical addresses by the system. This allows for efficient storage
management and the swapping of currently unused memory blocks to the hard
disk.C++ guarantees that any valid address will not be equal to 0. Thus, the special
value 0 is used to indicate an error. For pointers, the symbolic constant NULL is
defined as 0 in standard header files. A pointer containing the value NULL is
also called NULL pointer.
THE INDIRECTION OPERATOR233Using Pointers to Access Objects
Theindirection operator *is used to access an object referenced by a pointer:Given a pointer, ptr,*ptris the object referenced by ptr.As a programmer, you must always distinguish between the pointer ptrand theaddressed object *ptr.Example:long  a = 10, b,      // Definition of a, b*ptr;            // and pointer ptr.ptr = &a;             // Let ptr point to a.
b = *ptr;This assigns the value of atob, since ptrpoints to a. The assignment b=a;
wouldreturn the same result. The expression *ptrrepresents the object a, and can be usedwhereveracould be used.The star character *used for defining pointer variables is not an operator but merelyimitates the later use of the pointer in expressions. Thus, the definitionlong *ptr;has the following meaning: ptris a long*(pointer to long) type and *ptris a longtype.The indirection operator *has high precedence, just like the address operator &. Bothoperators are unary, that is, they have only one operand. This also helps distinguish the
redirection operator from the binary multiplication operator *,which always takes twooperands.L-values
An expression that identifies an object in memory is known as an L-valuein C++. Theterm L-value occurs commonly in compiler error messages and is derived from the assign-
ment. The leftoperand of the =operator must always designate a memory address.Expressions other than an L-value are often referred to as R-values.A variable name is the simplest example of an L-value. However, a constant or anexpression, such as x + 1,is an R-value. The indirection operator is one example of an
operator that yields L-values. Given a pointer variable p, both pand*pare L-values, as*pdesignates the object to which ppoints.
234CHAPTER 12REFERENCES AND POINTERS
POINTERS AS PARAMETERS
Sample function// pointer2.cpp// Definition and call of function swap().// Demonstrates the use of pointers as parameters.// ----------------------------------------------------
#include <iostream>
using namespace std;void swap( float *, float *);   // Prototype of swap()
int main(){   float x = 11.1F;
   float y = 22.2F;
      .
      .
      . swap( &x, &y );      .
      . // p2 = &y      .} // p1 = &xvoid swap( float *p1, float *p2){
   float temp;          // Temporary variable   temp = *p1;          // At the above call p1 points   *p1  = *p2;          // to x and p2 to y.   *p2  = temp;
}
POINTERS AS PARAMETERS235Objects as Arguments
If an object is passed as an argument to a function, two possible situations occur:the parameter in question is the same type as the object passed to it. The func-tion that is called is then passed a copy of the object (passing by value)the parameter in question is a reference. The parameter is then an alias for the
argument, that is, the function that is called manipulates the object passed by the
calling function (passing by reference).In the first case, the argument passed to the function cannot be manipulated by thefunction. This is not true for passing by reference. However, there is a third way of pass-
ing by reference—passing pointers to the function.Pointers as Arguments
How do you declare a function parameter to allow an address to be passed to the functionas an argument? The answer is quite simple: The parameter must be declared as a pointervariable.If, for example, the function func()requires the address of an intvalue as an argu-ment, you can use the following statementExample:long func( int *iPtr ){// Function block}to declare the parameter iPtras an intpointer. If a function knows the address of anobject, it can of course use the indirection operator to access and manipulate the object.In the program on the opposite page, the function swap()swaps the values of thevariablesxandyin the calling function. The function swap()is able to access the vari-ables since the addresses of these variables, that is &xand&y, are passed to it as argu-ments.The parameters p1andp2inswap()are thus declared as floatpointers. Thestatementswap( &x, &y);initializes the pointers p1andp2with the addresses of xory. When the functionmanipulates the expressions *p1and*p2, it really accesses the variables xandyin thecalling function and exchanges their values.
exercises
236CHAPTER 12REFERENCES AND POINTERS
// A version of swap() with incorrect logic.// Find the error!void swap(float *p1, float *p2){float *temp;                   // Temporary variabletemp = p1;p1   = p2;p2   = temp;}EXERCISESListing for exercise 3
Solutions of quadratic equations
The quadratic equation:a*x2+ b*x + c = 0has real solutions:
x12= (-b ±(b2- 4ac)) / 2aif the discriminant satisfies:b2-4ac >= 0If the value of (b2- 4ac)is negative,no real solution exists.
Test values
Quadratic EquationSolutions2x2- 2x - 1.5 = 0x
1= 1.5,  x2= -0.5x2- 6x + 9 = 0X
1= 3.0,  x2= 3.02x2+ 2 = 0none
EXERCISES237Given a circle with radius r:Area = * r * r and circumference = 2 * * r where = 3.1415926536NOTE
Exercise 1
What happens if the parameter in the sample function 
strToUpper()isdeclared as a 
string&instead of a string?Exercise 2
Write a voidtype function called circle()to calculate the circumference and
area of a circle.The radius and two variables are passed to the function,which

therefore has three parameters:
Parameters
:A read-only reference to 
doublefor the radius and two
references to 
doublethat the function uses to store the area
and circumference of the circle.
Test the function 
circle()by outputting a table containing the radius,the
circumference,and the area for the radii 
0.5,1.0,1.5,. . .,10.0.Exercise 3
a.The version of the function 
swap()opposite can be compiled withoutproducing any error messages.However,the function will not swap the

values of xandywhenswap(&x,&y);is called.What is wrong?
b.Test the correct pointer version of the function 
swap()found in this
chapter.Then write and test a version of the function 
swap()that usesreferences instead of pointers.
Exercise 4
Create a function 
quadEquation()that calculates the solutions to quadraticequations.The formula for calculating quadratic equations is shown opposite.
Arguments:The coefficients 
a,b,cand two pointers to both solutions.
Returns:false,if no real solution is available,otherwise 
true.Test the function by outputting the quadratic equations on the opposite page
and their solutions.
solutions
238CHAPTER 12REFERENCES AND POINTERS
SOLUTIONSExercise 1
The call to function strToUpper()is left unchanged.But instead of passing by
reference,a passing by value occurs,i.e.,the function manipulates a local copy.

Thus,only a local copy of the string is changed in the function,but the string in

the calling function remains unchanged.
Exercise 2
// ----------------------------------------------------// circle.cpp
// Defines and calls the function circle().// ----------------------------------------------------#include <iostream>
#include <iomanip>#include <string>using namespace std;// Prototype of circle():void circle( const double& rad, double& um, double& fl);const double startRadius =  0.5,     // Start, end andendRadius   = 10.0,     // step width ofstep        =  0.5;     // the tablestring header = "\n      ***** Computing Circles ***** \n",line( 50, '-');int main(){double rad, circuit, plane;cout << header << endl;cout << setw(10) << "Radius"<< setw(20) << "Circumference"
<< setw(20) << "Area\n" << line << endl;cout << fixed;           // Floating point presentationfor( rad = startRadius;rad < endRadius + step/2;  rad += step){circle( rad, circuit, plane);
cout << setprecision(1)<< setw(8)  << rad<< setprecision(5)<< setw(22) << circuit<< setw(20) << plane <<endl;}
return 0;}
SOLUTIONS239// Function circle(): Compute circumference and area.void circle( const double& r, double& u, double& f)
{const double pi = 3.1415926536;u = 2 * pi * r;
f = pi * r * r;}Exercise 3
// ----------------------------------------------------// swap.cpp
// Definition and call of the function swap().
// 1. version: parameters with pointer type,
// 2. version: parameters with reference type.
// ----------------------------------------------------
#include <iostream>
using namespace std;void swap( float*, float*);      // Prototypes of swap()void swap( float&, float&);int main(){float x = 11.1F;
float y = 22.2F;cout << "x and y before swapping:   "<< x << "   " << y << endl;swap( &x, &y);           // Call pointer version.
cout << "x and y after 1. swapping: "<< x << "   " << y << endl;swap( x, y);             // Call reference version.
cout << "x and y after 2. swapping: "<< x << "   " << y << endl;return 0;}void swap(float *p1, float *p2)     // Pointer version{float temp;                       // Temporary variabletemp = *p1;                      // Above call points p1*p1  = *p2;                      // to x and p2 to y.
*p2  = temp;}
240CHAPTER 12REFERENCES AND POINTERS
void swap(float& a, float& b)     // Reference version{float temp;                     // Temporary variabletemp = a;                       // For above calla    = b;                // a equals x and b equals yb    = temp;}Exercise 4
// ----------------------------------------------------
// quadEqu.cpp
// Defines and calls the function quadEquation(),
// which computes the solutions of quadratic equations
//            a*x*x + b*x + c = 0
// The equation and its solutions are printed by
// the function printQuadEquation().
// ----------------------------------------------------#include <iostream>#include <iomanip>
#include <string>
#include <cmath>              // For the square root sqrt()
using namespace std;string header =" *** Solutions of Quadratic Equations ***\n",line( 50, '-');// -----  Prototypes -----// Computing solutions:bool quadEquation( double a, double b, double c,double* x1Ptr, double* x2Ptr);// Printing the equation and its solutions:void printQuadEquation( double a, double b, double c);int main(){cout << header << endl;printQuadEquation( 2.0, -2.0, -1.5);printQuadEquation( 1.0, -6.0, 9.0);
printQuadEquation( 2.0,  0.0, 2.0);return 0;}
SOLUTIONS241// Prints the equation and its solutions:void printQuadEquation( double a, double b, double c)
{double x1 = 0.0, x2 = 0.0;           // For solutionscout << line << '\n'<< "\nThe quadratic equation:\n\t "
<< a << "*x*x + " << b << "*x + " <<  c << " = 0"<< endl;if( quadEquation( a, b, c, &x1, &x2) ){cout << "has real solutions:"<< "\n\t x1 = " << x1<< "\n\t x2 = " << x2 << endl;}elsecout << "has no real solutions!" << endl;cout << "\nGo on with return. \n\n";cin.get();}bool quadEquation( double a, double b, double c,double* x1Ptr, double* x2Ptr)// Computes the solutions of the quadratic equation://            a*x*x + b*x + c = 0// Stores the solutions in the variables to which
// x1Ptr and x2Ptr point.// Returns: true, if a solution exists,//                otherwise false.
{bool return_flag = false;double help = b*b - 4*a*c;if( help >= 0)            // There are real solutions.{help = sqrt( help);*x1Ptr = (-b + help) / (2*a);*x2Ptr = (-b - help) / (2*a);return_flag = true;}return return_flag;}
This page intentionally left blank 
243Defining ClassesThis chapter describes how classes are defined and how instances of
classes,that is,objects,are used.In addition,structs and unions are

introduced as examples of special classes.chapter
13
244CHAPTER 13DEFINING CLASSES
Real World
A Car
AbstractionInstantiationClass CARObjectsProperties (Data Members):  Date when built
  Capacity (PS)
  Serial number
     . . .Properties:  Date when built  = 1990
  Capacity = 100
  Chassis number = 11111     . . .Methods     . . .Methods (Member functions):  to run, to brake,
  to park, to turn off

     . . .car1Properties:  Date when built  = 2000
  Capacity = 200
  Chassis number = 22222
     . . .Methods     . . .car2• • •THE CLASS CONCEPT
THE CLASS CONCEPT245Classes are the language element in C++ most important to the support object-orientedprogramming (OOP). A class defines the properties and capacities of an object.Data Abstraction
Humans use abstractionin order to manage complex situations. Objects and processes arereduced to basics and referred to in generic terms. Classes allow more direct use of the
results of this type of abstraction in software development.The first step towards solving a problem is analysis.In object-oriented programming,analysis comprises identifying and describing objects and recognizing their mutual rela-
tionships. Object descriptions are the building blocks of classes.In C++, a class is a user-defined type. It contains data members, which describe theproperties of the class, and member functions, or methods, which describe the capacities ofthe objects. Classes are simply patterns used to instantiate, or create, objects of the class
type. In other words, an object is a variable of a given class.Data Encapsulation
When you define a class, you also specify the private members, that is, the members thatare not available for external access, and the public members of that class. An applica-
tion program accesses objects by using the public methods of the class and thus activat-
ing its capacities.Access to object data is rarely direct, that is, object data is normally declared as pri-vate and then read or modified by methods with public declarations to ensure correct
access to the data.One important aspect of this technique is the fact that application programs need notbe aware of the internal structure of the data. If needed, the internal structure of the pro-
gram data can even be modified. Provided that the interfaces of the public methods
remain unchanged, changes like these will not affect the application program. This
allows you to enhance an application by programming an improved class version without
changing a single byte of the application.An object is thus seen to encapsulate its private structure, protecting itself from exter-nal influences and managing itself by its own methods. This describes the concept of data
encapsulation concisely.
246CHAPTER 13DEFINING CLASSES
classDemo{private:// Private data members and methods herepublic:// Public data members and methods here};// account.h// Defining the class Account.// ---------------------------------------------------#ifndef _ACCOUNT_       // Avoid multiple inclusions.
#define _ACCOUNT_#include <iostream>#include <string>using namespace std;class Account{private:// Sheltered members:string name;                // Account holder
unsigned long nr;           // Account numberdouble balance;             // Account balancepublic://Public interface:bool init( const string&, unsigned long, double);void display();};#endif   //  _ACCOUNT_DEFINING CLASSESDefinition schemeExample of a class
DEFINING CLASSES247A class definition specifies the name of the class and the names and types of the classmembers.The definition begins with the keyword classfollowed by the class name. The datamembers and methods are then declared in the subsequent code block. Data members
and member functions can belong to any valid type, even to another previously defined
class. At the same time, the class members are divided into:privatemembers, which cannot be accessed externallypublicmembers, which are available for external access.Thepublicmembers form the so-called public interface of the class.The opposite page shows a schematic definition of a class. The privatesection gen-erally contains data members and the publicsection contains the access methods forthe data. This provides for data encapsulation.The following example includes a class named Accountused to represent a bankaccount. The data members, such as the name of the account holder, the account num-
ber, and the account balance, are declared as private. In addition, there are two publicmethods,init()for initialization purposes and display(),which is used to display
the data on screen.The labels private:a
ndpublic:can be used at the programmer’s discretionwithin a class:you can use the labels as often as needed, or not at all, and in any order. A sec-
tion marked as private:orpublic:is valid until the next public:orpri-vate:label occursthe default value for member access is private. If you omit both the privateandpubliclabels, all the class members are assumed to be private.NamingEvery piece of software uses a set of naming rules. These rules often reflect the targetplatform and the class libraries used. For the purposes of this book, we decided to keep to
standard naming conventions for distinguishing classes and class members. Class names
begin with an uppercase letter and member names with a lowercase letter.Members of different classes can share the same name. A member of another classcould therefore also be named display().
248CHAPTER 13DEFINING CLASSES
//account.cpp// Defines methods init() and display().
// ---------------------------------------------------
#include "account.h" // Class definition#include <iostream>#include <iomanip>using namespace std;// The method init() copies the given arguments// into the private members of the class.boolAccount::init(const string& i_name,unsigned long i_nr,
double        i_balance){if( i_name.size() < 1)            // No empty namereturn false;name    = i_name;nr      = i_nr;balance = i_balance;return true;}// The method display() outputs private data.voidAccount::display(){cout << fixed << setprecision(2)<< "--------------------------------------\n"<< "Account holder:    " << name  << '\n'<< "Account number:    " << nr    << '\n'<< "Account balance:   " << balance << '\n'<< "--------------------------------------\n"
<< endl;}DEFINING METHODSMethods of class Account
DEFINING METHODS249A class definition is not complete without method definitions. Only then can the objectsof the class be used.SyntaxWhen you define a method, you must also supply the class name, separating it from thefunction name by means of the scope resolution operator ::.Syntax:typeclass_name::function_name(parameter_list)
{. . . }
Failure to supply the class name results in a global function definition.Within a method, allthe members of a class can be designated directly using theirnames. The class membership is automatically assumed. In particular, methods belonging
to the same class can call each other directly.Access to private members is only possible within methods belonging to the sameclass. Thus, privatemembers are completely controlled by the class.Defining a class does not automatically allocate memory for the data members of thatclass. To allocate memory, you must define an object. When a method is called for a
given object, the method can then manipulate the data of this object.Modular Programming
A class is normally defined in several source files. In this case, you will need to place theclass definition in a header file. If you place the definition of the class Accountin thefileAccount.h, any source file including the header file can use the class Account.Methods must always be defined within a source file. This would mean defining themethods for the class Accountin a source file named Account.cpp, for example.The source code of the application program, for example, the code containing thefunctionmain, is independent of the class and can be stored in separate source files. Sep-arating classes from application programs facilitates re-use of classes.In an integrated development environment, a programmer will define a projectto helpmanage the various program modules by inserting all the source files into the project.
When the project is compiled and linked, modified source files are automatically re-com-
piled and linked to the application program.
250CHAPTER 13DEFINING CLASSES
"Cheers,  Mary"12345672002.22"Dylan, Bob"87654321–1300.13currentnamenrbalancesavingsnamenrbalanceDEFINING OBJECTSThe objects currentandsavingsin memory

DEFINING OBJECTS251Defining a class also defines a new type for which variables, that is, objects, can bedefined. An object is also referred to as an instanceof a class.Defining ObjectsAn object is defined in the usual way by supplying the type and the object name.Syntax:class_name object_name1 [, object_name2,...]The following statement defines an object currentof type Account:Example:Account current;  // or: class Account ...Memory is now allocated for the data members of the currentobject. The currentobject itself contains the members name,nr, and balance.Objects in Memory
If multiple objects of the same class type are declared, as inExample:Account current, savings;each object has its own data members. Even the object savingscontains the membersname,nr,and 
balance. However, these data members occupy a different position inmemory than the data members belonging to current.The same methods are called for both objects. Only one instance of the machine codefor a method exists in memory—this applies even if no objects have been defined for the
class.A method is always called for a particular instance and then manipulates the datamembers of thisobject. This results in the memory content as shown on the oppositepage, when the method init()is called for each object with the values shown.Initializing ObjectsThe objects belonging to the Accountclass were originally defined but not initialized.Each member object is thus defined but not explicitly initialized. The string name,isempty, as it is thus defined in the class string. The initial values of the members nrandbalanceare unknown, however. As is the case for other variables, these data mem-bers will default to 0if the object is declared global or static.You can define exactly how an object is created and destroyed. These tasks are per-formed by constructorsanddestructors. Constructors are specifically responsible for initial-izing objects—more details are given later.
252CHAPTER 13DEFINING CLASSES
// account_t.cpp// Uses objects of class Account.// ---------------------------------------------------#include "Account.h"int main(){Account current1, current2;current1.init("Cheers, Mary", 1234567, -1200.99);current1.display();//   current1.balance += 100; // Error: private membercurrent2 = current1;       // ok: Assignment of// objects is possible.current2.display();        // ok// New values for current2current2.init("Jones, Tom", 3512347, 199.40);current2.display();// To use a reference:Account& mtr = current1;     // mtr is an alias name// for object current1.mtr.display();               // mtr can be used just// as object current1.return 0;}USING OBJECTSSample program

USING OBJECTS253Class Member Access Operator
An application program that manipulates the objects of a class can access only the pub-licmembers of those objects. To do so, it uses the class member access operator(in short:dot operator).Syntax:object.memberWherememberis a data member or a method.Example:Account current;current.init("Jones, Tom",1234567,-1200.99);The expression current.initrepresents the publicmethodinitof the Accountclass. This method is called with three arguments for current.Theinit()call cannot be replaced by direct assignments.Example:current.name  = "Dylan, Bob";  // Error:current.nr    = 1234567;       // private
current.balance = -1200.99;    // membersAccess to the privatemembers of an object is not permissible outside the class. It istherefore impossible to display single members of the Accountclass on screen.Example:cout << current.balance;         // Errorcurrent.display();               // okThe method display()displays all the data members of current. A method such asdisplay()can only be called for one object. The statementdisplay();would result in an error message, since there is no global function called display().What data would the function have to display?Assigning ObjectsThe assignment operator =is the only operator that is defined for all classes by default.However, the source and target objects must both belong to the same class. The assign-
ment is performed to assign the individual data members of the source object to the cor-
responding members of the target object.Example:Account current1, current2;current2.init("Marley, Bob",350123, 1000.0);
current1 = current2;This copies the data members of current2to the corresponding members ofcurrent1.
254CHAPTER 13DEFINING CLASSES
// ptrObj.cpp// Uses pointers to objects of class Account.
// ---------------------------------------------------
#include "Account.h"   // Includes <iostream>, <string>
bool getAccount( Account *pAccount);       // Prototypeint main(){Account current1, current2,*ptr = &current1;ptr->init("Cheer, Mary",        // current1.init(...)3512345, 99.40);ptr->display();// current1.display()ptr = &current2;// Let ptr point to current2if(getAccount( ptr))    // Input and output a newptr->display();// account.elsecout << "Invalid input!" << endl;return 0;}
// --------------------------------------------------// getAccount() reads data for a new account// and adds it into the argument.
bool getAccount( Account *pAccount ){string name, line(50,'-');        // Local variables
unsigned long nr;double startcapital;cout << line << '\n'<< "Enter data for a new account: \n"
<< "Account holder: ";if( !getline(cin,name) || name.size() == 0)return false;cout << "Account number:  ";if( !(cin >> nr))           return false;cout << "Starting capital: ";
if( !(cin >> startcapital)) return false;// All input okpAccount->init( name, nr, startcapital);return true;}POINTERS TO OBJECTS
Sample program

POINTERS TO OBJECTS255An object of a class has a memory address—just like any other object. You can assign thisaddress to a suitable pointer.Example:Account savings("Mac, Rita",654321, 123.5);Account *ptrAccount = &savings;This defines the object savingsand a pointer variable called ptrAccount. ThepointerptrAccountis initialized so that it points to the object savings. This makes*ptrAccountthe object savingsitself. You can then use the statementExample:(*ptrAccount).display();to call the method display()for the object savings. Parentheses must be used inthis case, as the operator .has higher precedence than the *operator.Arrow Operator
You can use the class member access operator ->(in short: arrow operator) instead of acombination of*and..Syntax:objectPointer->memberThis expression is equivalent to(*objectPointer).memberThe operator ->is made up of a minus sign and the greater than sign.Example:ptrAccount->display();This statement calls the method display()for the object referenced by ptrAccount,that is, for the object savings. The statement is equivalent to the statement in the pre-vious example.The difference between the class member access operators.and->is that the leftoperand of the dot operator must be an object, whereas the left operand of the arrow
operator must be a pointer to an object.The Sample Program
Pointers to objects are often used as function parameters. A function that gets theaddress of an object as an argument can manipulate the referenced object directly. The
example on the opposite page illustrates this point. It uses the function getAccount()to read the data for a new account. When called, the address of the account is passed:getAccount(ptr) // or: getAccount(&current1)The function can then use the pointer ptrand the init()method to write new datato the referenced object.
256CHAPTER 13DEFINING CLASSES
// structs.cpp// Defines and uses a struct.
// ---------------------------------------------------
#include <iostream>
#include <iomanip>#include <string>using namespace std;
struct Representative // Defining struct Representative{string name;         // Name of a representative.double sales;        // Sales per month.};
inline void print( const Representative& v){cout << fixed << setprecision(2)<< left  << setw(20) << v.name
<< right << setw(10) << v.sales << endl;}int main(){Representative rita, john;rita.name    = "Strom, Rita";
rita.sales  = 37000.37;john.name   = "Quick, John";john.sales = 23001.23;rita.sales += 1700.11;            // More Salescout << "  Representative            Sales\n"<< "-------------------------------" << endl;print( rita);print( john);
cout << "\nTotal of sales: "<< rita.sales + john.sales << endl;Representative *ptr = &john;// Pointer ptr.// Who gets theif( john.sales < rita.sales)         // most sales?ptr = &rita;cout << "\nSalesman of the month: "<< ptr->name << endl;   // Representative's name// pointed to by ptr.return 0;}structsSample program

structs257Records
In a classical, procedural language like C, multiple data that belong together logically areput together to form a record. Extensive data such as the data for the articles in an auto-mobile manufacturer’s stocks can be organized for ease of viewing and stored in files.From the viewpoint of an object-oriented language, a record is merely a class contain-ing only public data members and no methods. Thus, you can use the classkeyword todefine the structure of a record in C++.Example:class Date{ public:   short month, day, year; };However, it is common practice to use the keyword struct, which is also availablein the C programming language, to define records. The above definition of Datewiththe members day,month,and 
yearis thus equivalent to:Example:struct Date { short month, day, year; };The Keywords 
classandstructYou can also use the keyword structto define a class, such as the class Account.Example:struct Account {private:     //  . . .   as before
public:      //  . . .};The keywords classandstructonly vary with respect to data encapsulation; thedefault for access to members of a class defined as a structispublic. In contrast to aclass defined using the classkeyword, all the class members are publicunless a pri-vatelabel is used. This allows the programmer to retain C compatibility.Example:Date future;
future.year = 2100;    // ok! Public dataRecords in the true sense of the word, that is, objects of a class containing only pub-licmembers, can be initialized by means of a list during definition.Example:Date birthday = { 1, 29, 1987};The first element in the list initializes the first data member of the object, and so on.
258CHAPTER 13DEFINING CLASSES
w (16 bit word)Low byteb[0]High byteb[1]// unions.cpp// Defines and uses a union.// ---------------------------------------------------#include <iostream>
using namespace std;union WordByte{private:unsigned short w;         // 16 bits
unsigned char b[2];       // Two bytes: b[0], b[1]public:// Word- and byte-access:unsigned short& word()    { return w; }
unsigned char&  lowByte() { return b[0]; }unsigned char&  highByte(){ return b[1]; }};int main(){WordByte wb;wb.word() = 256;
cout << "\nWord:      " << (int)wb.word();cout << "\nLow-byte:  " << (int)wb.lowByte()<< "\nHigh-byte: " << (int)wb.highByte()
<< endl;return 0;}UNIONSAn object of union WordBytein memory
Defining and using union WordByteScreen output of the program
Word:      256Low-Byte:  0
High-Byte: 1
UNIONS259Memory Usage
In normal classes, each data member belonging to an object has its own separate memoryspace. However, a unionis a class whose members are stored in the same memory space.Each data member has the same starting address in memory. Of course, a union cannot
store various data members at the same address simultaneously.However, a union doesprovide for more versatile usage of memory space.DefinitionSyntactically speaking, a union is distinguished from a class defined as a classorstructonly by the keyword union.Example:union Number{long   n;
double x;};
Number number1, number2;This example defines the union Numberand two objects of the same type. The unionNumbercan be used to store either integral or floating-point numbers.Unless a privatelabel is used, all union members are assumed to be public. Thisis similar to the default setting for structures. This allows direct access to the members nandxin the union Number.Example:number1.n = 12345; // Storing an integernumber1.n *= 3;    // and multiply by 3.
number2.x = 2.77;  // Floating point numberThe programmer must ensure that the current content of the union is interpreted cor-rectly. This is normally achieved using an additional type field that identifies the current
content.The size of a union type object is derived from the longest data member, as all datamembers begin at the same memory address. If we look at our example, the unionNumber, this size is defined by the doublemember, which defaults to 8 ==sizeof(double)byte.The example opposite defines the union WordBytethat allows you to read or writeto a 16-bit memory space byte for byte or as a unit.
exercise
260CHAPTER 13DEFINING CLASSES
struct tm{int tm_sec;         // 0 - 59(60)
int tm_min;         // 0 - 59
int tm_hour;        // 0 - 23
int tm_mday;        // Day of month: 1 - 31
int tm_mon;         // Month: 0 - 11 (January == 0)
int tm_year;        // Years since 1900 (Year - 1900)
int tm_wday;        // Weekday: 0 - 6 (Sunday == 0)
int tm_yday;        // Day of year: 0 - 365
int tm_isdst;       // Flag for summer-time};#include <iostream>#include <ctime>using namespace std;struct tm *ptr;          // Pointer to struct tm.time_t sec;              // For seconds.. . .time(&sec);              // To get the present time.ptr = localtime(&sec);   // To initialize a struct of// type tm and return a// pointer to it.cout << "Today is the "      <<ptr->tm_yday + 1<< ". day of the year " << ptr->tm_year<< endl;. . .EXERCISEStruct 
tmin header file ctimeSample calls to functions time( )andlocaltime( ) 
EXERCISE261Use the functions declared in ctimetime_t  time(time_t *ptrSec)struct tm *localtime(const time_t *ptrSec);NOTE
Exercise
A program needs a class to represent the date.
Define the class Datefor this purpose using three integral data members
for day,month,and year.Additionally,declare the following methods:
void init( int month, int day, int year);void init(void);
void print(void);Store the definition of the class 
Datein a header file.
Implement the methods for the class 
Datein a separate source file:
1.The method 
print()outputs the date to standard output using the
format 
Month-Day-Year.2.The method 
init()uses three parameters and copies the values
passed to it to corresponding members.A range check is not required

at this stage,but will be added later.
3.The method 
init()without parameters writes the current date 
to thecorresponding members.
The structure 
tmand sample calls to this function are included oppo-
site.The type 
time_tis defined as longinctime.The function time()returns the system time expressed as a num-
ber of seconds and writes this value to the variable referenced by 
ptr-Sec.This value can be passed to the function 
localtime()thatconverts the number of seconds to the local type 
tmdate and returns
a pointer to this structure.
Test the class 
Dateusing an application program that once more is stored
in a separate source file.To this end,define two objects for the class and

display the current date.Use object assignments and—as an additional

exercise—references and pointers to objects.

solution
262CHAPTER 13DEFINING CLASSES
SOLUTION// ----------------------------------------------------// date.h
// First Definition of class Date.// ----------------------------------------------------#ifndef _DATE_             // Avoid multiple inclusion.#define  _DATE_class Date{private:                       // Sheltered members:short month, day, year;public:                        // Public interface:void init(void);
void init( int month, int day, int year);void print(void);};#endif   //  _DATE_// ----------------------------------------------------// date.cpp// Implementing the methods of class Date.// ----------------------------------------------------#include "date.h"#include <iostream>#include <ctime>using namespace std;// ---------------------------------------------------void Date::init(void)    // Get the present date and{                        // assign it to data members.struct tm *ptr;              // Pointer to struct tm.time_t sec;                  // For seconds.time(&sec);               // Get the present date.ptr = localtime(&sec);    // Initialize a struct of// type tm and return a
// pointer to it.month = (short) ptr->tm_mon + 1;day   = (short) ptr->tm_mday;year  = (short) ptr->tm_year + 1900;}
SOLUTION263// ---------------------------------------------------void Date::init( int m, int d, int y)
{month = (short) m;day   = (short) d;
year  = (short) y;}// ---------------------------------------------------void Date::print(void)           // Output the date{cout << month << '-' << day << '-' << year<< endl;}// ----------------------------------------------------// date_t.cpp// Using objects of class Date.
// ----------------------------------------------------
#include "date.h"
#include <iostream>using namespace std;int main(){Date today, birthday, aDate;today.init();birthday.init( 12, 11, 1997);cout << "Today's date: ";today.print();cout << "\n Felix' birthday: ";birthday.print();cout << "----------------------------------\n""Some testing outputs:" << endl;aDate = today;                 // Assignment okaDate.print();Date *pDate = &birthday;       // Pointer to birthdaypDate->print();Date &holiday = aDate;         // Reference to aDate.holiday.init( 1, 5, 2000);     // Writing to aDate.
aDate.print();                 // holiday.print();return 0;}
This page intentionally left blank 
265MethodsThis chapter describes
how constructors and destructors are defined to create and
destroy objects
how 
inlinemethods,access methods,and read-only methods
can be usedthe pointer this,which is available for all methods,and
what you need to pay attention to when passing objects as

arguments or returning objects.
chapter
14
266CHAPTER 14METHODS
// account.h// Defining class Account with two constructors.// ---------------------------------------------------
#ifndef _ACCOUNT_#define _ACCOUNT_#include <string>using namespace std;class Account{private:// Sheltered members:string name;                // Account holderunsigned long nr;           // Account number
double state;               // State of the accountpublic:// Public interface:Account( const string&, unsigned long, double );
Account( const string& );bool init( const string&, unsigned long, double);void display();};#endif   //  _ACCOUNT_// Within file account.cpp:Account::Account( const string& a_name,unsigned long a_nr, double a_state){nr    = a_nr;name  = a_name;state = a_state;}Account::Account( const string& a_name ){name = a_name;nr = 1111111;  state = 0.0;}CONSTRUCTORS
ClassAccountwith constructors
Defining the constructors

CONSTRUCTORS267The Task of a Constructor
Traditional programming languages only allocate memory for a variable being defined.The programmer must ensure that the variable is initialized with suitable values.An object of the class Account, as described in the previous chapter, does not possessany valid values until the method init()is called. Non-initialized objects can lead toserious runtime errors in your programs.To avoid errors of this type, C++ performs implicit initialization when an object isdefined. This ensures that objects will always have valid data to work on. Initialization is
performed by special methods known as constructors.Declaration
Constructors can be identified by their names. In contrast to other member functions,the following applies:the name of the constructor is also the class namea constructor does not possess a return type—not even void.Constructors are normally declared in the publicsection of a class. This allows you tocreate objects wherever the class definition is available.Constructors can be overloaded, just like other functions. Constructors belonging to aclass must be distinguishable by their signature(that is, the number, order, and type ofparameters). This allows for different methods of object initialization. The example
opposite shows an addition to the Accountclass. The class now has two constructors.DefinitionSince a constructor has the same name as its class, the definition of a constructor alwaysbegins withClass_name::Class_nameIn the definition itself, the arguments passed can be checked for validity before they are
copied to the corresponding data members. If the number of arguments is smaller than
the number of data members, the remaining members can be initialized using default val-
ues.Constructors can also perform more complex initialization tasks, such as opening files,allocating memory, and configuring interfaces.
268CHAPTER 14METHODS
// account2_t.cpp// Using the constructors of class Account.// ---------------------------------------------------#include "account.h"int main(){Account giro("Cheers, Mary", 1234567, -1200.99 ),save("Lucky, Luke");Account depot;   // Error: no default constructor//        defined.giro.display();         // To outputsave.display();Account temp("Funny, Susy", 7777777, 1000000.0);save = temp;           // ok: Assignment of//     objects possible.save.display();// Or by the presently available method init():save.init("Lucky, Luke", 7654321, 1000000.0);save.display();return 0;}CONSTRUCTOR CALLS
Sample program

CONSTRUCTOR CALLS269Unlike other methods, constructors cannot be called for existing objects. For this reason,a constructor does not have a return type. Instead, a suitable constructor is called once
only when an object is created.Initialization
When an object is defined, initial values can follow the object name in parentheses.Syntax:class object( initializing_list);During initialization the compiler looks for a constructor whose signature matches theinitialization list. After allocating sufficient memory for the object, the constructor is
called. The values in the initialization list are passed as arguments to the constructor.Example:account nomoney("Poor, Charles");This statement calls the constructor with one parameter for the name. The other data
members will default to standard values.If the compiler is unable to locate a constructor with a suitable signature, it will notcreate the object but issue an error message.Example:account somemoney("Li, Ed",10.0); // Error!The class Accountdoes not contain a constructor with two parameters.If a constructor with only oneparameter is defined in the class, the statement can bewritten with an equals sign =.Example:account nomoney = "Poor, Charles";This statement is equivalent to the definition in the example before last. Initialization
with parentheses or the = sign was introduced previously for fundamental types. For
example,int i(0); is equivalent to int i=0;
.Default Constructor
A constructor withoutparameters is referred to as a default constructor. The default con-structor is only called if an object definition does not explicitly initialize the object. A
default constructor will use standard values for all data members.If a class does not contain a constructor definition, the compiler will create a minimalversion of the default constructor as a publicmember. However, this constructor willnot perform initialization. By contrast, if a class contains at leastone constructor, adefault constructor must be defined explicitly, if it is needed. The definition of theAccountclass does not specify a default constructor; thus a new account object can becreated with initialization only.
270CHAPTER 14METHODS
// demo.cpp// Outputs constructor and destructor calls.
// ---------------------------------------------------
#include <iostream>
#include <string>using namespace std;int count = 0;                   // Number of objects.class Demo{private:string name;public:Demo( const string& );    // Constructor~Demo();                   // Destructor};Demo::Demo( const string& str){++count;  name = str;cout << "I am the constructor of "<< name << '\n'<< "This is the " << count << ". object!\n"}Demo:: ~Demo()              // Defining the destructor
{cout << "I am the destructor of " << name << '\n'<< "The " << count << ". object "
<< "will be destroyed " << endl;--count;}// -- To initialize and destroy objects of class Demo --Demo globalObject("the global object");
int main(){cout << "The first statement in main()." << endl;
Demo firstLocalObject("the 1. local object");{Demo secLocalObject("the 2. local object");
static Demo staticObject("the static object");cout << "\nLast statement within the inner block"<< endl;}cout << "Last statement in main()." << endl;
return 0;}DESTRUCTORS
Sample program

DESTRUCTORS271Cleaning Up ObjectsObjects that were created by a constructor must also be cleaned up in an orderly manner.The tasks involved in cleaning up include releasing memory and closing files.Objects are cleaned up by a special method called a destructor,whose name is made upof the class name preceded by (tilde).Declaration and Definition
Destructors are declared in the publicsection and follow this syntax:Syntax:class_name(void);Just like the constructor, a destructor does not have a return type. Neither does ithave any parameters, which makes the destructor impossible to overload. Each class thus
hasonedestructor only.If the class does not define a destructor, the compiler will create a minimal versionof
a destructor as a publicmember, called the default destructor.It is important to define a destructor if certain actions performed by the constructorneed to be undone. If the constructor opened a file, for example, the destructor should
close that file. The destructor in the Accountclass has no specific tasks to perform. Theexplicit definition is thus:Account::Account(){}        // Nothing to doThe individual data members of an object are always removed in the order opposite ofthe order in which they were created. The first data member to be created is therefore
cleaned up last. If a data member is also a class type object, the object’s own destructor
will be called.Calling Destructors
A destructor is called automatically at the end of an object’s lifetime:for local objects except objects that belong to the staticstorage class, at theend of the code block defining the objectfor global or staticobjects, at the end of the program.The sample program on the opposite page illustrates various implicit calls to constructorsand destructors.
272CHAPTER 14METHODS
// account.h// New definition of class Account with inline methods
// ----------------------------------------------------
#ifndef _ACCOUNT_
#define _ACCOUNT_#include <iostream>#include <iomanip>#include <string>
using namespace std;class Account{private:// Sheltered members:
string name;             // Account holder
unsigned long nr;        // Account numberdouble state;            // State of the accountpublic://Public interface:
// Constructors: implicit inlineAccount( const string& a_name = "X",unsigned long a_nr   = 1111111L,double  a_state      = 0.0){name = a_name;  nr = a_nr;  state = a_state;}~Account(){ }  // Dummy destructor: implicit inlinevoid display();};// display() outputs data of class Account.inline void Account::display()    // Explicit inline
{cout << fixed << setprecision(2)<< "--------------------------------------\n"
<< "Account holder:   " << name  << '\n'<< "Account number:   " << nr    << '\n'<< "Account state:    " << state << '\n'<< "--------------------------------------\n"<< endl;}#endif   //  _ACCOUNT_INLINE METHODSSample class Account
INLINE METHODS273A class typically contains multiple methods that fulfill simple tasks, such as reading orupdating data members. This is the only way to ensure data encapsulation and class func-
tionality.However, continually calling “short” methods can impact a program’s runtime. Infact, saving a re-entry address and jumping to the called function and back into the call-
ing function can take more time than executing the function itself. To avoid this over-
head, you can define inlinemethods in a way similar to defining inlineglobalfunctions.Explicit and Implicit inlineMethodsMethods can be explicitly or implicitly defined as inline. In the first case, the methodis declared within the class, just like any other method. You simply need to place theinlinekeyword before the method name in the function header when defining themethod.Example:inline void Account::display(){. . .}Since the compiler must have access to the code block of an inlinefunction, theinlinefunction should be defined in the header containing the class definition.Short methods can be defined within the class. Methods of this type are known asimplicitinlinemethods, although the inlinekeyword is not used.Example:// Within class Account:bool isPositive(){ return state > 0; }Constructors and Destructors with 
inlineDefinitionsConstructors and destructors are special methods belonging to a class and, as such, canbe defined as inline. This point is illustrated by the new definition of the Accountclass opposite. The constructor and the destructor are both implicit inline. The con-structor has a default value for each argument, which means that we also have a default
constructor. You can now define objects without supplying an initialization list.Example:Account temp;Although we did not explicitly supply values here, the object tempwas correctly initial-ized by the default constructor we defined.
274CHAPTER 14METHODS
// account.h// Class Account with set- and get-methods.// ----------------------------------------------------
#ifndef _ACCOUNT_#define _ACCOUNT_#include <iostream>#include <iomanip>#include <string>
using namespace std;class Account{private:// Sheltered members:string name;           // Account holder
unsigned long nr;      // Account numberdouble state;          // State of the accountpublic://Public interface:// constructors, destructor:Account( const string& a_name = "X",unsigned long a_nr   = 1111111L,double  a_state      = 0.0){ name = a_name;  nr = a_nr;  state = a_state; }
Account(){ }// Access methods:const string& getName() { return name; }bool          setName( const string& s){if( s.size() < 1)     // No empty namereturn false;name = s;
return true;}unsigned long getNr(){ return nr; }void          setNr( unsigned long n){ nr = n; }double getState(){ return state; }void   setState(double x){ state = x; }void display();};
// inline definition of display() as before.#endif   //  _ACCOUNT_ACCESS METHODSAccess methods for the Accountclass
ACCESS METHODS275Accessing Private Data Members
An object’s data members are normally found in the privatesection of a class. Toallow access to this data, you could place the data members in the publicsection of theclass; however, this would undermine any attempt at data encapsulation.Access methods offer a far more useful way of accessing the private data members.Access methods allow data to be read and manipulated in a controlled manner. If the
access methods were defined as inline, access is just as efficient as direct access to thepublicmembers.In the example opposite, several access methods have been added to the Accountclass. You can now use thegetName(), getNr(), getState()methods to read the individual data members. As is illustrated in getName(), referencesshould be read-only when used as return values. Direct access for write operations could
be possible otherwise. To manipulate data members, the following methods can be used:setName(), setNr(), setState().This allows you to define a new balance, as follows:Example:save.setState( 2199.0);Access Method BenefitsDefining access methods for reading and writing to each data member may seem like alot of work—all that typing, reams of source code, and the programmer has to remember
the names and tasks performed by all those methods.So, you may be asking yourself how you benefit from using access methods. There aretwo important issues:Access methods can prevent invalid access attempts at the onset by performing
sanity checks. If a class contains a member designed to represent positive num-
bers only, an access method can prevent processing negative numbers.Access methods also hide the actual implementation of a class. It is therefore pos-
sible to modify the internal structure of your data at a later stage. If you detect
that a new data structure will allow more efficient data handling, you can add
this modification to a new version of the class. Provided the public interface to
the class remains unchanged, an application program can be leveraged by the
modification without needing to modify the application itself. You simply re-
compile the application program.
276CHAPTER 14METHODS
// account.h// Account class with read-only methods.// ----------------------------------------------------#ifndef _ACCOUNT_
#define _ACCOUNT_#include <iostream>#include <iomanip>#include <string>
using namespace std;class Account{private:// Sheltered members// Data members:  as beforepublic:// Public interface// Constructors and destructor. . .  // as before// Get-methods:const string& getName()const{ return name; }unsigned long getNr()const{ return nr; }double        getState() const{ return state; }// Set-methods:. . .  // as before// Additional methods:
void display() const;};// display() outputs the data of class Account.inline void Account::display() const{cout << fixed << setprecision(2)<< "--------------------------------------\n"<< "Account holder:   " << name  << '\n'
<< "Account number:   " << nr    << '\n'<< "Account state:    " << state << '\n'<< "--------------------------------------\n"<< endl;}
#endif   //  _ACCOUNT_constOBJECTS AND METHODS
Read-only methods in the Accountclass
constOBJECTS AND METHODS277AccessingconstObjectsIf you define an object as const, the program can only read the object. As mentionedearlier, the object must be initialized when you define it for this reason.Example:const Account inv("YMCA, FL", 5555, 5000.0);The object invcannot be modified at a later stage. This also means that methods suchassetName()cannot be called for this object. However, methods such as getNameordisplay()will be similarly unavailable although they only perform read access withthe data members.The reason for this is that the compiler cannot decide whether a method performswrite operations or only read operations with data members unless additional informa-
tion is supplied.Read-Only MethodsMethods that perform only read operations and that you need to call for constant objectsmust be identified as read-only. To identify a method as read-only, append the constkeyword in the method declaration and in the function header for the method defini-
tion.Example:unsigned long getNr() const;This declares the getNr()method as a read-only method that can be used for constantobjects.Example:cout << "Account number: " << inv.getNr();Of course, this does not prevent you from calling a read-only method for a non-constant
object.The compiler issues an error message if a read-only method tries to modify a datamember. This also occurs when a read-only method calls another method that is not
defined as const.constand Non-constVersions of a Method
Since the constkeyword is part of the method’s signature, you can define two versionsof the method: a read-only version, which will be called for constant objects by default,
and a normal version, which will be called for non-constobjects.
278CHAPTER 14METHODS
// stdMeth.cpp// Using standard methods.// ---------------------------------------------------#include <iostream>
#include <iomanip>#include <string>using namespace std;class CD{private:string interpret, title;
long   seconds;              // Time duration of a songpublic:CD( const string& i="", const string& t="", long s = 0L)
{interpret = i;    title = t;    seconds = s;}
const string& getInterpret() const{ return interpret; }const string& getTitle() const    { return title; }long  getSeconds() const          { return seconds; }};
// Generate objects of class CD and output it in tabular formvoid printLine( CD cd) ;            // A row of the tableint main()
{CD cd1( "Mister X", "Let's dance", 30*60 + 41),cd2( "New Guitars", "Flamenco Collection", 2772 ),
cd3 = cd1,                   // Copy constructor!cd4;// Default constructor.cd4 = cd2;                   // Assignment!string line( 70,'-');   line += '\n';
cout << line << left<< setw(20) << "Interpreter" << setw(30) << "Title"<< "Length (Min:Sec)\n" << line << endl;printLine(cd3);// Call by value ==>printLine(cd4);// Copy constructor!return 0;}void printLine( CD cd){   cout << left  << setw(20) << cd.getInterpret()<< setw(30) << cd.getTitle()<< right << setw(5)  << cd.getSeconds() / 60
<< ':'   << setw(2)  << cd.getSeconds() % 60 << endl;}STANDARD METHODS
Sample program

STANDARD METHODS279Every class automaticallycontains four standard methods:the default constructorthe destructorthe copy constructor andthe assignment.You can use your own definitions to replace these standard methods. As illustrated bythe sample class Account, the compiler only uses the pre-defined default constructor ifno other constructor is available.The default constructor and the implicit, minimal version of a destructor were intro-duced earlier.Copy Constructor
The copy constructor initializes an object with another object of the same type. It iscalled automatically when a second, already existing object is used to initialize an object.Example:Account myAccount("Li, Ed", 2345, 124.80);Account yourAccount(myAccount);In this example, the object yourAccountis initialized by calling the copy constructorwith the myAccountobject. Each member is copied individually, that is, the followinginitialization process takes place:yourAccount.name  = myAccount.name;yourAccount.nr    = myAccount.nr;
yourAccount.state = myAccount.state;The copy constructor is also called when an object is passed to a function by value.When the function is called, the parameter is created and initialized with the object used
as an argument.AssignmentAssignment has been used in several previous examples. An object can be assigned toanother object of the same type.Example:hisAccount = yourAccount;The data members of the yourAccountobject are copied to the corresponding mem-bers of hisAccountin this case also. In contrast to initialization using the copy con-structor, assignment requires two existingobjects.Later in the book, you will be introduced to situations where you need to define thecopy constructor or an assignment yourself, and the necessary techniques will be dis-
cussed.
280CHAPTER 14METHODS
// DayTime.h// The class DayTime represents the time in
// hours, minutes and seconds.
// ---------------------------------------------------
#ifndef _DAYTIME_#define _DAYTIME_class DayTime
{private:short hour, minute, second;bool overflow;public:DayTime( int h = 0, int m = 0, int s = 0){overflow = false;if( !setTime( h, m, s))       // this->setTime(...)hour = minute = second = 0; // houris equivalent}                               // to this->houretc.bool setTime(int hour, int minute, int second = 0){if(    hour   >= 0  &&  hour < 24&& minute >= 0  &&  minute < 60
&& second >= 0  &&  second < 60 ){this->hour= (short)hour;this->minute= (short)minute;this->second= (short)second;return true;}elsereturn false;}int getHour()   const { return hour;   }int getMinute() const { return minute; }
int getSecond() const { return second; }int asSeconds() const      // daytime in seconds{   return (60*60*hour + 60*minute + second);   }bool isLess( DayTime t) const  // compare *this and t{return  asSeconds() < t.asSeconds();}      //this->asSeconds()< t.asSeconds();};#endif   // _DAYTIME_thisPOINTERSample class DayTime
thisPOINTER281Accessing the Current Object
A method can access any member of an object without the object name being suppliedin every case. A method will always reference the object with which it was called.But how does a method know which object it is currently working with? When amethod is called, it is passed a hidden argument containing the address of the current
object.The address of the current object is available to the method via the constant pointerthis. Given that actObjis the current object of type Class_id, for which a methodwas called, the pointer thishas the following declaration:Class_id* const this = &actObj;The name thisis a keyword. As thisis a constant pointer, it cannot be redirected.In other words, the pointer thisallows you to access the current object only.Using the thisPointer
You can use the thispointer within a method to address an object member as follows:Example:this->data     // Data member: datathis->func()   // Calling member functionThe compiler implicitly creates an expression of this type if only a member of the currentobject is supplied.Example:data = 12;  // Corresponds to this->data=12;Write operations of this type are permissible since the pointer thisis a constant, butthe referenced object is not. However, the above statement would be invalid for a read-
only method.Thethispointer can be used explicitly to distinguish a method’s local variables fromclass members of the same name. This point is illustrated by the sample methodsetTime()on the opposite page.Thethispointer is always necessary to access the current object, *this, collec-tively. This situation often occurs when the current object needs to be returned as a copy
or by reference. Then the return statement is as follows:return  *this;
282CHAPTER 14METHODS
#include "DayTime.h". . .DayTime depart1( 11, 11, 11), depart2;
. . .depart2.setTime(12, 0, 0);if(depart1.isLess( depart2))cout << "\nThe 1st plane takes off earlier" << endl;. . .#include "DayTime.h"//Definesthe global function swap():void swap( DayTime& t1, DayTime& t2) // Two{                                         // parameters!DayTime temp(t1);  t1 = t2;  t2 = temp; // To swap}                                         // t1 and t2.//A call(e.g. in function main()):DayTime arrival1( 14, 10), arrival2( 15, 20);. . .
swap( arrival1, arrival2);// To swap. . .//Definesthe method swap():class DayTime               // With a new method swap()
{  . . .public:
void swap( DayTime& t)// One parameter!{                            // To swap *this and t:DayTime temp(t);  t = *this;  *this = temp;}};
//A call(e.g. in function main()):#include "DayTime.h"DayTime arrival1( 10, 10), arrival2( 9, 50);
. . .arrival1.swap(arrival2);. . .PASSING OBJECTS AS ARGUMENTS
Calling methods setTime()andisLess()Global function swap()Implementingswap()as a method
PASSING OBJECTS AS ARGUMENTS283Passing by Value
As you already know, passing by value copies an object that was passed as an argument tothe corresponding parameter of a function being called. The parameter is declared as an
object of the class in question.Example:bool isLess( DayTime t) const;When the method isLess()is called, the copy constructor executes and initializes thecreated object, t, with the argument.depart1.isLess( depart2)    // Copy constructorThe function uses a copy of the object depart2. The copy is cleaned up when leavingthe function, that is, the destructor is called.Passing by Reference
The overhead caused by creating and cleaning up objects can be avoided by passing argu-ments by reference. In this case, the parameter is declared as a reference or pointer.Example:bool isLess( const DayTime& t) const;This new declaration of the isLess()method is preferable to the previous declaration.There is no formal difference to the way the method is called. However, isLess()nolonger creates an internal copy, but accesses directly the object being passed. Of course,
the object cannot be changed, as the parameter was declared read-only.Methods Versus Global Functions
Of course, it is possible to write a global function that expects oneobject as an argument.However, this rarely makes sense since you would normally expect an object’s function-
ality to be defined in the class itself. Instead, you would normally define a method for the
class and the method would perform the task in hand. In this case, the object would not
be passed as an argument since the method would manipulate the members of the cur-
rent object.A different situation occurs where operations with at least twoobjects need to be per-formed, such as comparing or swapping. For example, the method isLess()could bedefined as a global function with two parameters. However, the function could only
access the public interface of the objects. The function swap()on the opposite pageadditionally illustrates this point.The major advantage of a globally defined function is its symmetry. The objectsinvolved are peers, since both are passed as arguments. This means that conversion rules
are applied to both arguments when the function is called.
284CHAPTER 14METHODS
#include "DayTime.h"#include <ctime>        // Functions time(), localtime()using namespace std;const DayTime&currentTime()      // Returns the{                                 // present time.static DayTime curTime;
time_t sec;  time(&sec);  // Gets the present time.// Initializes the structstruct tm *time = localtime(&sec);  // tm with it.curTime.setTime( time->tm_hour, time->tm_min,time->tm_sec );return curTime;}// DayTim_t.cpp// Tests class DayTime and function currentTime()// ---------------------------------------------------#include "DayTime.h"             // Class definition
#include <iostream>using namespace std;const DayTime& currentTime();    // The current time.int main(){DayTime cinema( 20,30);cout << "\nThe movie starts at ";cinema.print();DayTime now(currentTime());    // Copy constructorcout << "\nThe current time is ";
now.print();cout << "\nThe movie has ";if( cinema.isLess( now) )cout << "already begun!\n" << endl;elsecout << "not yet begun!\n" << endl;return 0;}RETURNING OBJECTSGlobal function currentTime()Sample program

RETURNING OBJECTS285A function can use the following ways to return an object as a return value: It can createa copy of the object, or it can return a reference or pointer to that object.Returning a Copy
Returning a copy of an object is time-consuming and only makes sense for small-scaleobjects.Example:DayTime startMeeting(){DayTime start;
. . .    // Everyone has time at 14:30:
start.setTime( 14, 30);
return( start);}On exiting the function, the local object startis destroyed. This forces the compiler tocreate a temporary copy of the local object and return the copy to the calling function.Returning a Reference
Of course, it is more efficient to return a reference to an object. But be aware that thelifetime of the referenced object must not be local.If this is the case, the object is destroyed on exiting the function and the returned ref-erence becomes invalid. If you define the object within a function, you must use astaticdeclaration.The global function currentTime()on the opposite page exploits this option byreturning a reference to the current time that it reads from the system each time the
function is called. The sample program that follows this example uses the current time to
initialize the new object nowand then outputs the time. In order to output the time, anadditional method, print(), was added to the class.Using Pointers as Return Values
Instead of returning a reference, a function can also return a pointer to an object. In thiscase too, you must ensure that the object still exists after exiting the function.Example:const DayTime* currentTime() // Read-only pointer{                            // to the current time. . . // Unchanged
return &curTime;}
exercises
286CHAPTER 14METHODS
Private members:Type
Article number:
longArticle name:
stringSales price:doublePublic members:
Article(long, const string&, double);~Article();void print();     // Formatted outputset- and get-methods for any data memberAn object of type Article . . . is created.This is the . . .. Article.The object of type Article  . . . is destroyed.There are still . . . articles.EXERCISESClass Article
Output from constructor
Output from destructor

EXERCISES287Exercise 1
A warehouse management program needs a class to represent the articles in
stock.Define a class called Articlefor this purpose using the data members
and methods shown opposite.Store the class definition for 
Articlein aseparate header file.Declare the constructor with default arguments for

each parameter to ensure that a default constructor exists for the class.

Access methods for the data members are to be defined as 
inline.Neg-
ative prices must not exist.If a negative price is passed as an argument,
the price must be stored as 
0.0.Implement the constructor,the destructor,and the method 
print()in aseparate source file.Also define a global variable for the number of
Articletype objects.The constructor must use the arguments passed to it to initialize the data
members,additionally increment the global counter,and issue the message

shown opposite.
The destructor also issues a message and decrements the global counter.

The method print()displays a formatted object on screen.After
outputting an article,the program waits for the return key to be pressed.
The application program (again use a separate source file) tests the 
Arti-cleclass.Define four objects belonging to the 
Articleclass type:1.A global object and a local object in the 
mainfunction.2.Two local objects in a function 
test()that is called twice by 
main().One object needs a static definition.The function 
test()displays
these objects and outputs a message when it is terminated.Use articles of your own choice to initialize the objects.Additionally,call
the access methods to modify individual data members and display the

objects on screen.
Test your program.Note the order in which constructors and destruc-

tors are called.
Supplementary question
:Suppose you modify the program by declaring a function
calledtest()with a parameter of type Articleand calling the function withan article type object.The counter for the number of objects is negative after

running the program.Why?

288CHAPTER 14METHODS
Public Methods:
Date();Date( int month, int day, int year);
void setDate();
bool setDate( int mn, int da, int yr);int getMonth() const;int getDay() const;
int getYear() const;bool isEqual( const Date&) const;bool isLess( const Date&) const;const string& asString() const;void  print() const;// Example: Converting a number to a string.#include <sstream>            // Class stringstream#include <iomanip>            // Manipulatorsdouble x = 12.3;            // Numberstring str;                 // Destination stringstringstream iostream; // For conversion// number -> string.iostream << setw(10) << x; // Add to the stream.iostream >> str;// Read from the stream.Methods for class DateConverting a number to a string
The class stringstreamoffers the same functionality for reading and writing to
character buffer as the classes 
istreamandostreamdo.Thus,the operators 
>>and<<,just as all manipulators,are available.
Notices for exercise 3
A year is a leap year if it is divisible by 4 but not by 100.In addition,all

multiples of 400 are leap years.February has 29 days in a leap year.
Use a switchstatement to examine the number of days for months con-
taining less than 31 days.

EXERCISES289Exercise 2
In the exercises for chapter 13,an initial version of the 
Dateclass containingmembers for day,month,and year was defined.Now extend this class to add

additional functionality.The methods are shown on the opposite page.
The constructors and the method setDate()replace the 
initmethodused in the former version.The default constructor uses default values,

for example,
1.1.1,to initialize the objects in question.The 
setDate()method without any parameters writes the current date to the object.
The constructor and the setDate()method with three parameters do
not need to perform range checking.This functionality will be added in

the next exercise.
The methods isEqual()andisLess()enable comparisons with a datepassed to them.The method asString()returns a reference to a string containing the
date in the format 
mm-dd-year,e.g.
03-19-2006.You will therefore need
to convert any numerical values into their corresponding decimal strings.

This operation is performed automatically when you use the 
<<operatorto output a number to the standard output 
cout.In addition to the 
cinandcoutstreams,with which you are already familiar,so-called 
string
streams
with the same functionality also exist.However,a string stream
does not read keyboard input or output data on screen.Instead,the tar-

get,or source,is a buffer in main memory.This allows you to perform for-

matting and conversion in main memory.
Use an application program that calls all the methods defined in the class

to test the Dateclass.Exercise 3
TheDateclass does not ensure that an object represents a valid date.To avoid
this issue,add range checking functionality to the class.Range checking is

performed by the constructor and the 
setDate()method with three
parameters.First,write a function called 
isLeapYear()that belongs to the booltype and checks whether the year passed to it is a leap year.Define the

function as a global inlinefunction and store it in the header file
Date.h.Modify the setDate()method to allow range checking for the date
passed to it.The constructor can call 
setDate().Test the new version of the 
Dateclass.To do so,and to test 
set-Date(...),read a date from the keyboard.

solutions
290CHAPTER 14METHODS
SOLUTIONSExercise 1
// ----------------------------------------------------//article.h// Defines a simple class, Article.// ----------------------------------------------------
#ifndef _ARTICLE_#define _ARTICLE_#include <string>using namespace std;class Article{private:long nr;                // Article numberstring name;            // Article name
double sp;              // Selling pricepublic:Article( long nr=0, const string& name="noname",double sp=0.0);~Article();void print();const string& getName() const { return name; }long          getNr()   const { return nr; }
double        getSP()   const { return sp; }bool setName( const string& s){if( s.size() < 1)              // No empty namereturn false;name = s;
return true;}void setNr( long n) { nr = n; }
void setSP(double v)
{                                 // No negative pricesp = v > 0.0 ? v : 0.0;}};#endif   // _ARTICLE_
SOLUTIONS291// ------------------------------------------------------//article.cpp// Defines those methods of Article, which are
// not defined inline.
// Screen output for constructor and destructor calls.
// ------------------------------------------------------
#include "Article.h"         // Definition of the class
#include <iostream>
#include <iomanip>
using namespace std;// Global counter for the objects:int count = 0;// ------------------------------------------------------// Define constructor and destructor:
Article::Article( long nr, const string& name, double sp)
{setNr(nr);   setName(name);   setSP(sp);
++count;
cout << "Created object for the article " << name<< ".\n"
<< "This is the " << count << ". article!\n"}
Article::~Article()
{cout << "Cleaned up object for the article " << name<< ".\n"
<< "There are still " << --count << " articles!"
<< endl;}
// ------------------------------------------------------
// The method print() outputs an article.
void Article::print()
{long savedFlags = cout.flags();      // To mark the// flags of cout.cout << fixed << setprecision(2)<< "-----------------------------------------\n"
<< "Article data:\n"
<< "  Number ....:  " << nr    << '\n'
<< "  Name   ....:  " << name  << '\n'
<< "  Sales price:  " << sp    << '\n'
<< "-----------------------------------------"
<< endl;cout.flags(savedFlags);               // To restore// old flags.cout << "  --- Go on with return --- ";
cin.get();}
292CHAPTER 14METHODS
// ------------------------------------------------------//article_t.cpp// Tests the Article class.// ------------------------------------------------------#include "Article.h"      // Definition of the class
#include <iostream>
#include <string>
using namespace std;void test();// -- Creates and destroys objects of Article class --Article Article1( 1111,"volley ball", 59.9);int main(){cout << "\nThe first statement in main().\n" << endl;Article Article2( 2222,"gym-shoes", 199.99);Article1.print();
Article2.print();Article& shoes = Article2;          // Another nameshoes.setNr( 2233);
shoes.setName("jogging-shoes");shoes.setSP( shoes.getSP() - 50.0);cout << "\nThe new values of the shoes object:\n";shoes.print();cout << "\nThe first call to test()." << endl;test();
cout << "\nThe second call to test()." << endl;test();cout << "\nThe last statement in main().\n" << endl;
return 0;}void test(){Article shirt( 3333, "T-Shirt", 29.9);shirt.print();
static Article net( 4444, "volley ball net", 99.0);net.print();cout << "\nLast statement in function test()"<< endl;}
SOLUTIONS293Answer to the supplementary question:The copy constructor is called on each “passing by value,” although this
constructor has not been defined explicitly.In other words,the implicitly defined

copy constructor is used and of course does not increment the object counter.

However,the explicitly defined destructor,which decrements the counter,is still

called for each object.
Exercises 2 and 3
// ------------------------------------------------------//Date.h// Defining class Date with optimized
// functionality, e.g. range check.// ------------------------------------------------------#ifndef _DATE_   // Avoids multiple inclusions.
#define _DATE_#include <string>using namespace std;class Date{private:short month, day, year;public:Date()                       // Default constructor
{  month = day = year = 1;  }Date( int month, int day, int year){if( !setDate( month,  day, year) )month = day = year = 1;  // If date is invalid}
void setDate();              // Sets the current datebool setDate( int month, int day, int year);int getMonth() const { return month; }
int getDay()   const { return day;   }int getYear()  const { return year;  }bool isEqual( const Date& d) const
{return month == d.month && day == d.day&& year  == d.year ;}
bool isLess( const Date& d) const;const string& asString() const;void print(void) const;};
294CHAPTER 14METHODS
inline bool Date::isLess( const Date& d) const{if( year != d.year)         return year < d.year;else if( month != d.month)  return month < d.month;else                        return day < d.day;}inline bool isLeapYear( int year){return (year%4 == 0 && year%100 != 0) || year%400 == 0;}
#endif   //  _DATE_// ------------------------------------------------------//Date.cpp// Implements those methods of Date class,// which are not defined inline.
// ------------------------------------------------------
#include "Date.h"               // Class definition#include <iostream>#include <sstream>
#include <iomanip>#include <string>#include <ctime>
using namespace std;// -----------------------------------------------------void Date::setDate()     // Get the present date and
{                        // assign it to the data members.struct tm *dur;           // Pointer to struct tm.time_t sec;               // For seconds.time(&sec);               // Get the present time.dur = localtime(&sec);    // Initialize a struct of// type tm and return a// pointer to it.day   = (short) dur->tm_mday;
month = (short) dur->tm_mon + 1;
year  = (short) dur->tm_year + 1900;}
SOLUTIONS295// -----------------------------------------------------bool Date::setDate( int mn, int da, int yr)
{if( mn < 1 ||  mn > 12 ) return false;if( da < 1 ||  da > 31 ) return false;switch(mn)             // Month with less than 31 days{case 2:  if( isLeapYear(yr)){if( da > 29)return false;}else if( da > 28)return false;break;case 4:case 6:
case 9:case 11:if( da > 30)  return false;}month = (short) mn;day   = (short) da;
year  = (short) yr;
return true;}// -----------------------------------------------------void Date::print() const              // Output a date{cout << asString() << endl;}// -----------------------------------------------------const string& Date::asString() const   // Return a date{                                      // as string.static string dateString;
stringstream iostream;              // For conversion// number -> stringiostream << setfill('0')            // and formatting.<< setw(2) << month << '-'
<< setw(2) << day   << '-' << year;iostream >> dateString;return dateString;}
296CHAPTER 14METHODS
// ------------------------------------------------------//date_t.cpp// Using objects of class Date.// ------------------------------------------------------#include "Date.h"
#include <iostream>
using namespace std;int main(){Date  today, birthday( 1, 29, 1927);
const Date d2010(1,1,2010);cout << "\n Brigit's birthday: "<< birthday.asString() << endl;today.setDate();cout << "\nToday's date: " << today.asString()<< endl;;if( today.isLess( d2010))cout << " Good luck for this decade \n"<< endl;elsecout << " See you next decade \n" << endl;Date holiday;int month, day, year;   char c;cout << "\nWhen does your next vacation begin?\n"<< "Enter in Month-Day-Year format: ";if( !(cin >> month >> c >> day >> c >> year) )cerr << "Invalid input!\n" << endl;else if ( !holiday.setDate( month, day,  year))cerr << "Invalid date!\n" << endl;else{cout << "\nYour first vacation: ";
holiday.print();if( today.getYear() < holiday.getYear())cout << "You should go on vacation this year!\n"<< endl;elsecout << "Have a nice trip!\n" << endl;}
return 0;}
297Member Objects andStatic MembersThe major topics discussed in this chapter aremember objects and how they are initialized
data members that are created once only for all the objects in a
class.In addition,this chapter describes constant members and enumerated

types.chapter
15
298CHAPTER 15MEMBER OBJECTS AND STATIC MEMBERS
// result.h// Class Result to represent a measurement
// and the time of measurement.
// ---------------------------------------------------
#ifndef _RESULT_#define _RESULT_#include "DayTime.h"                // Class DayTimeclass Result{private:double val;DayTime time;public:Result();                     // Default constructorResult(double w, const DayTime& z = currentTime());
Result(double w, int hr, int min, int sec);double getVal() const { return val; }void   setVal( double w ) { val = w; }const DayTime& getTime() const  { return time; }void  setTime( const DayTime& z) { time = z; }
bool  setTime(int hr, int min, int sec){  return  time.setTime( hr, min, sec); }void print() const;       // Output result and time.};#endif  //  _RESULT_#include "result.h"Result::Result() { val = 0.0; }Result::Result( double w, const DayTime& z){val = w;    time = z;}Result::Result( double w, int hr, int min, int sec){  val = w;time = DayTime(hr, min, sec);  // Assign a temporary// object of type}                                 // DayTime to time.MEMBER OBJECTSA class representing measurement results
A first implementation of constructors

MEMBER OBJECTS299“Has-A”Relationship
Data members belonging to one class can be objects of a different class. In our example,theAccountclass, we already made use of this feature. The name of the account holderis stored in a stringtype data member. An object of the Accountclass therefore has astringtypemember sub-object, or member object for short.If a class contains a data member whose type is of a different class, the relationshipbetween the classes is referred to as a “Has-A” relationship.Calling Constructors
When an object containing member objects is initialized, multiple constructor calls areto be executed. One of these is the constructor for the complete object, and the others
are constructors for the member objects. The order of the constructor calls is significant inthis case. First, the member objects are created and initialized; this then allows the con-
structor to create the whole object. Unless otherwise stated, the default constructor will
be called for each member object.The Constructors for the Sample Class 
ResultThe example on the opposite page defines a sample class called Result. In addition to adoubletype measurement, the time of each measurement is recorded. For ease of read-ing, the constructors were defined separately, rather than as inline.The default constructor only sets the value of the measurement to 0. However, initial-ization is complete since the default constructor is called for the member object time.Example:Result current;The default constructor for the member object timefirst sets the hours, minutes andseconds to 0. Then the constructor for the Resultclass is called and a value of 0.0isassigned to val.The other constructors can be used to initialize an object explicitly.Example:Result temperature1(15.9); // Current TimeResult temperature2(16.7, 14, 30, 35);Since the compiler has no information on the relation of initial values and memberobjects, it first calls the default constructor for the member object time. Subsequentlythe instructions for the Resultclass constructor can be executed, and values areassigned to the data members.
300CHAPTER 15MEMBER OBJECTS AND STATIC MEMBERS
#include "result.h"Result::Result(): val(0.0){ /* ... */ }Result::Result( double w, const DayTime& z): val(w), time(z){ /* ... */ }Result::Result( double w, int hr, int min, int sec): val(w), time(hr, min, sec){/* ... */}You can replace the comment /* ... */with statements, if needed. However, in the case of theResultclass there is nothing to do at present.NOTE
// result_t.cpp// Tests constructors of class Result// ---------------------------------------------------#include "Result.h"
#include <iostream>using namespace std;int main()        // Some air temperature measurements{DayTime  morning(6,30);Result t1,                // Default constructort2( 12.5, morning),
t3( 18.2, 12,0,0),t4(17.7);          // at current timecout << "Default values: ";   t1.print();cout << "\n Temperature   Time  \n"<< "-------------------------" << endl;t2.print();t3.print();t4.print();cout << endl;
return 0;}MEMBER INITIALIZERSNew implementation of constructors
Sample program

MEMBER INITIALIZERS301Initializing Member ObjectsCalling default constructors to create member objects raises several issues:A member object is initialized first with default values. Correct values areassigned later. This additional action can impact your program’s performance.Constant objects or references cannot be declared as member objects since it is
impossible to assign values to them later.Classes that do not have a default constructor definition cannot be used as types
for member objects.When defining a constructor, you can use memberinitializers
to ensure general andefficient use of member objects.Syntax for Member Initializers
A member initializer contains the name of the data member, followed by the initial val-ues in parentheses.Example:time(hr,min,sec)      // Member initializerMultiple member initializers are separated by commas. A list of member initializersdefined in this way follows the constructor header and is separated from the header by a
colon.Example:Result::Result( /* Parameters */ ): val(w), time(hr, min, sec)
{  /* Function block  */ }This ensures that a suitable constructor will be called for data members with member ini-tializers and avoids calls to the default constructor with subsequent assignments. As the
example shows, you can also use member initializers for data members belonging to fun-
damental types.The argument names of the member initializers are normally constructor parameters.This helps pass the values used to create an object to the right memberobject.
Member initializers can only be stated in a constructor definition.The constructor declaration remainsunchanged.NOTE

302CHAPTER 15MEMBER OBJECTS AND STATIC MEMBERS
// result2.h// The class Result with a constant data member.
// ---------------------------------------------------
#ifndef  _RESULT_
#define  _RESULT_#include "DayTime.h"             // Class DayTimeclass Result{private:double val;const DayTime time;public:Result(double w, const DayTime& z = currentTime());Result(double w, int hr, int min, int sec);
double getVal() const { return val; }void   setVal( double w ) { val = w; }const DayTime& getTime() const  { return time; }void print() const;};
#endif  //  _RESULT_// result2_t.cpp  :     Tests the new class Result.// ---------------------------------------------------#include "result2.h"#include <iostream>
using namespace std;int main(){DayTime  start(10,15);Result m1( 101.01, start),m2( m1),             // Copy constructor ok!m3( 99.9);           // At current time.// m2 = m3;     // Error! Standard assignment incorrect.m2.setVal(100.9);          // Corrected value for m2cout << "\n Result     Time  \n"<< "-------------------------" << endl;m1.print();    m2.print();   m3.print();return 0;}CONSTANT MEMBER OBJECTS
New version of class 
ResultUsing the new class 
Result
CONSTANT MEMBER OBJECTS303DeclaringconstMember ObjectsIf a class contains data members that need to keep their initial values, you can definethese members as const. For example, you could set the time for a measurement onceand not change this time subsequently. However, you need to be able to edit the meas-
urement value to correct systematic errors. In this case, the member object timecan bedeclared as follows:Example:const DayTime time;Since the const member object timecannot be modified by a later assignment, the cor-rect constructor must be called to initialize the object. In other words, when you define a
constructor for a class, you mustalso define a member initializer for each const memberobject.The Sample Class ResultIf the member object timeisconst, the first version of the constructors are invalidsince they modify timeby means of a later assignment.Example:time = DayTime(st, mn, sk);   // Error!However, the later versions of these constructors are ok. The member initializer ensures
that the desired initial values are used to create the member object time.One further effect of the const member object is the fact that the setTime(...)methods can no longer be applied. The compiler will issue an error message at this point
and for any statement in the current program that attempts to modify the static member,time. This means that a programmer cannot accidentally overwrite a member declaredas a const.The new version of the Resultclass no longer contains a default constructor, since adefault value for the time of the measurement does not make sense.Example with Fundamental Type
Data members with fundamental types can also be defined as const. The class Clientcontains a number, nr, which is used to identify customers. Since the client numbernever changes, it makes sense to define the number as const.The constructor forClientwould then read as follows:Example:Client::Client( /*...*/ ) : nr(++id){ /*...*/ }The member initializer nr(++id)initializes the constdata member nrwith theglobal value id, which is incremented prior to use.
304CHAPTER 15MEMBER OBJECTS AND STATIC MEMBERS
// result3.h// The class Result with static data members.// ---------------------------------------------------#ifndef  _RESULT_
#define  _RESULT_#include "DayTime.h"            // Class DayTimeclass Result
{private:double val;const  DayTime time;// Declaration of static members:
static double min, max;    // Minimum, maximumstatic bool first; // true, if it is the first value.void setMinMax(double w);  // private functionpublic:Result(double w, const DayTime& z = currentTime());Result(double w, int hr, int min, int sec);// ...  The other member functions as before};
#endif  //  _RESULT_// result3.cpp// Defining static data members and// methods, which are not defined inline.// ---------------------------------------------------
#include "result3.h"double Result::min = 0.0;double Result::max = 0.0;bool   Result::first = true;void Result::setMinMax(double w)   // Help function
{ if(first) {  min = max = w;   first = false; }else if( w < min)  min = w;else if( w > max)  max = w;}// Constructors with member initializer.Result::Result( double w, const DayTime& z)
: val(w), time(z){  setMinMax(w);  }Result::Result( double w, int hr, int min, int sec): val(w), time(hr, min, sec){  setMinMax(w);  }
// Implements the other member functions.STATIC DATA MEMBERS
ClassResultwith static members
Implementation and initialization

STATIC DATA MEMBERS305Class-Specific Data
Every object has its own characteristics. This means that the data members of two differ-ent objects will be stored at different memory addresses.However, sometimes it is useful to keep some common data that can be accessed by allthe objects belonging to a class, for example:figures such as exchange rates, interest rates or time limits which have the same
value for every objectstatus information, such as the number of objects, current minimum or maximum
threshold values, or pointers to some objects; for example, a pointer to an active
window in a window class.This kind of data needs to be stored once only, no matter how many objects exist.Since a programmer will also need to manage the data from within the class, it should be
represented within the class rather than globally. Static data memberscan be used for thispurpose. In contrast to normal data members, static data members occur only once in
memory.Declaration
Static data members are declared within a class, that is, the keyword staticis used todeclare members of this type. On the opposite page, the following statementExample:static double min, max;   // Declarationdefines two static data members called minandmaxthat record the minimum and maxi-mum values for the measurements.Definition and Initialization
Static data members occupy memory space even if no objects of the class in questionhave been created. Just like member functions, which occur only once, static data mem-
bers must be defined and initialized in an external source file. The range operator ::isthen used to relate the data members to the class.Example:double Result::min = 0.0;  // DefinitionAs the example illustrates, the statickeyword is not used during the definition. Staticdata members and member functions belonging to the same class are normally defined in
one source file.
306CHAPTER 15MEMBER OBJECTS AND STATIC MEMBERS
class Result{private:double val;
const  DayTime time;
static double min, max;    // Minimum, Maximum
static bool first;         // true, if first resultstatic void setMinMax(double w);// Help functionpublic:// ... Member functions as before, plus:static double getMin() { return min; }static double getMax() { return max; }};// result3_t.cpp// Uses the new class Result.// ---------------------------------------------------#include "result3.h"
#include <iostream>using namespace std;int main()         //Some air temperature measurements{DayTime  morning(6,45);
Result temp1( 6.45, morning),temp2( 11.2, 12,0,0);double temp = 0.0;
cout << "\nWhat is the air temperature now? ";cin >> temp;Result temp3(temp);           // At current time.
cout << "\n Temperature   Time  \n"<< "-------------------------" << endl;temp1.print();  temp2.print();  temp3.print();cout<< "\n Minimum Temperature: " << Result::getMin()<< "\n Maximum Temperature: " << Result::getMax()<< endl;return 0;}ACCESSING STATIC DATA MEMBERS
ClassResultwith static methods
Application program

ACCESSING STATIC DATA MEMBERS307Static Data Members and Encapsulation
The normal rules for data encapsulation also apply to static data members. A static datamember declared as publicis therefore directly accessible to any object.If the static data members minandmaxin the Resultclass are declared publicrather than private, and given that temperatureis an object belonging to the class,the following statementExample:cout << temperature.max;outputs the maximum measured value. You can also use the range operator:Example:cout << Result::max;This syntax is preferable to the previous example, since it clearly shows that a static data
member exists independently of any objects.Static Member Functions
Of course, you can use class methods to access a static data member with a privatedeclaration. However, normal methods can be used for class objects only. Since staticdata members are independent of any objects, access to them should also be independent
of any objects. Static member functions are used for this purpose. For example, you can calla static member function for a class even though no objects exist in that class.Thestatickeyword is used to define static member functions.Example:static double getMin();   // Within class.As the Resultclass, which was modified to include the static member functionsgetMin(),setMin(), etc. shows, an inlinedefinition is also permissible. Defini-tions outside of the class do not need to repeat the statickeyword.A static member function can be called using any object belonging to the class or,preferably, using a range operator.Example:temperature.setMax(42.4);    // EquivalentResult::setMax(42.4);        // Calls.Calling a static member function does not bind the function to any class object. Thethispointer is therefore unavailable, in contrast to normal member functions. This alsomeans that static member functions cannot access data members and methods that are
not static themselves.
308CHAPTER 15MEMBER OBJECTS AND STATIC MEMBERS
// enum.cpp// Uses enum-constants within a class.
// ---------------------------------------------------
#include <iostream>
using namespace std;class Lights{public:             // Enumeration for class Lightsenum State { off, red, green, amber };private:State state;public:Lights(State s = off) : state(s) {}State getState() const {  return state; }
void setState( State s){ switch(s){case off:cout << "    OFF      ";  break;case red:cout << "    RED      ";  break;case green:cout << "    GREEN    ";  break;case amber: cout << "    AMBER    ";  break;default:     return;}
state = s;}};int main(){cout << "Some statements with objects "<< "of type Lights!\n"Lights A1, A2(Lights::red);Lights::State as;as = A2.getState();
if( as == Lights::red){A1.setState(Lights::red);A2.setState(Lights::amber);}cout << endl;return 0;}ENUMERATION
Sample program

ENUMERATION309DefinitionAn enumeration is a user-definable, integral type. An enumeration is defined using theenumkeyword. A range of values and a name for these values are also defined at thesame time.Example:enum Shape{ Line, Rectangle, Ellipse};This statement defines the enumerated type Shape. The names quoted in the list iden-tify integral constants. Their values can be deduced from the list order. The first constant
has a value of 0, and each subsequent constant has a value that is one higher than itspredecessor.In the previous example, Linethus represents a value of 0,Rectanglea value of 1,andEllipsea value of 2. A Shapetype variable can only assume one of these values.Example:Shape shape = Rectangle;  // Variable shape// ...
switch(shape)          // To evaluate shape
{case Line:   // ...  etc.However, you can also define the values of the constants explicitly.Example:enum Bound { Lower = -100, Upper = 100};You can leave out the type name, if you only need to define the constants.Example:enum { OFF, OUT=0, ON, IN=1 };This statement defines the constants OFFandOUT, setting their value to 0, and the con-stantsONandINwith a value of 1. The values for OFFandONare implicit.Class-Specific ConstantsEnumeration can be used to define integral symbolic constants in a simple way. In con-trast to #definedirectives, which merely replace text strings, enumconstants are partof a declaration and thus have a valid range. This allows you to define constants that are
visible within a namespace or class only.The example on the opposite page shows the enumerated type State, which wasdefined within the Lightsclass. This means that the type and enumconstant are onlyavailable for direct use within the class. The enumeration itself is declared as public,however, and access from outside the class is therefore possible.Example:if(Lights.getState() == Lights::red)// ...
exercises
310CHAPTER 15MEMBER OBJECTS AND STATIC MEMBERS
Article( const Article& );EXERCISESCopy constructor of class 
ArticleThe copy constructor creates a copy of an existing object.The parameter is thus
a read-only reference to the object that needs to be copied.The copy

constructor in the Articleclass is thus declared as follows:
Declaration of copy constructor:
The default copy constructor simply transfers the data members to the new
object.The Member Classintstring
const DateMember NumberName
Birthday//Possibly more information, such as an address, telephone number,  ...
Constructor with one parameter for each data memberAccess methods for each data member. The birthday is read-only.

A method for formatted screen output  of all  data members
Private Data MembersPublic MethodsType

EXERCISES311Exercise 1
In the first exercise of the last chapter you defined a simple class called
Article.This involved using a global counter to log object creation and
destruction.Improve and extend the 
Articleclass as follows:
Use a static data member instead of a global variable to count the current

number of objects.
Declare a static access method called 
getCount()for the 
Articleclass.The method returns the current number of objects.
Define a copy constructor that also increments the object counter by 1

and issues a message.This ensures that the counter will always be accu-

rate.
Tip:Use member initializers.
Test the new version of the class.To do so,call the function 
test()bypassing an article type object to the function.
Exercise 2
A sports club needs a program to manage its members.Your task is to define

and test a class called Memberfor this purpose.
Define the Memberclass using the data members shown opposite.Use
theDateclass defined in the last chapter for your definition.Since a
member’s birthday will not change,the data member for birthdays must

be defined as a const.Overload the constructor to allow for entering a date as an object as
well as three values for day,month,and year.
Implement the necessary methods.
Test the new 
Memberclass by creating at least two objects with the data
of your choice and calling the methods you defined.
Add a static member called 
ptrBossto the class.This pointer indicates
the member who has been appointed as chairperson.If no chairperson

has been appointed,the pointer should point to 
NULL.Additionally,define the static access methods 
getBoss()andsetBoss().Use a pointer to set and return the object in question.
Test the enhanced 
Memberclass by reading the number of an existing
member,making the member the new chairperson and displaying the

chairperson using getBoss().
312CHAPTER 15MEMBER OBJECTS AND STATIC MEMBERS
Simulation of two traffic lights!Terminate this program with <Ctrl>+<C>!1. Light     2. Light---------------------------RED          AMBERGREEN
AMBERAMBER          RED
GREEN
AMBER
RED          AMBERGREEN// . . .Sample outputHints for implementing the function wait()1.The function 
time()is declared in the header file 
ctime.The call
time(NULL)determines the number of seconds of type 
time_tsince1.1.1970,0:0 hours.The type 
time_tis defined as long.2.Instead of calling the function 
time()in a loop,you can use the function
Sleep()for Windows or the function 
sleep()for Unix.These system
calls are not standardized,yet they are much more effective because they

send a process to sleep instead of using a waiting loop.

EXERCISES313Exercise 3
Create a program to simulate the signal positions for two sets of traffic lights at
a junction.Use the class 
Lightsas defined in this chapter for your program.
Each set of lights is switched through the phases red,amber,green,amber,

red,and so on.You must ensure that one set of lights can be only in the

amber or green state when the other set of lights is red.
The lights operate in an infinite loop that can be terminated by interrupt-

ing the program.You can use the key combination <Ctrl>+<C> for DOS

and Windows and the Interrupt key,i.e.,normally the <Del> key,for

UNIX.The status of the lights is constant for a certain number of seconds.For

example,the green phase can take 20 seconds and the amber phase 1

second.These values can be different for each set of lights.Define an

auxiliary function
inline void wait( int sec)The function returns after the stipulated number of seconds.To do so,

you can call the standard function 
time()in a loop.Don’t forget to read
the notes on the opposite page.

solutions
314CHAPTER 15MEMBER OBJECTS AND STATIC MEMBERS
SOLUTIONSExercise 1
// ----------------------------------------------------//article.h// Defines a simple class - Article.// ----------------------------------------------------#ifndef _ARTICLE_H_
#define _ARTICLE_H_#include <string>
using namespace std;class Article{private:long nr;                  // Article numberstring name;              // Article namedouble sp;                // Sales price
// Static data member:static int countObj;    // Number of objectspublic:Article( long nr=0, const string& name="noname",double sp=0.0);// Copy constructor:
Article( const Article& anArticle);~Article();void print();
// Access methods:const string& getName() const { return name; }long          getNr()   const { return nr; }
double        getSP()   const { return sp; }
static int getCount() { return countObj; }bool setName( const string& s){if( s.size() < 1)        // No empty Namereturn false;name = s;
return true;}void setNr( long n) { nr = n; }
void setSP(double v){                            // No negative pricesp = v > 0.0 ? v : 0.0;}};
#endif   // _ARTICLE_
SOLUTIONS315// ---------------------------------------------------//article.cpp// Methods of Article, which are not defined as inline.
// Constructor and destructor output when called.
// ---------------------------------------------------#include "article.h"            // Definition of the class
#include <iostream>#include <iomanip>
using namespace std;// Defining the static data member:int Article::countObj = 0;         // Number of objects// Defining the constructor and destructor:
Article::Article( long nr, const string& name, double sp){setNr(nr);   setName(name);   setSP(sp);++countObj;
cout << "An article \"" << name<< "\" is created.\n"
<< "This is the " << countObj << ". article!"
<< endl;}
// Defining the copy constructor:
Article::Article( const Article& art)
:nr(art.nr), name(art.name), sp(art.sp)
{++countObj;
cout << "A copy of the article \"" << name<< "\" is generated.\n"
<< "This is the " << countObj << ". article!"
<< endl;}Article::~Article(){cout << "The article \"" << name<< "\" is destroyed.\n"
<< "There are still " << --countObj << " articles!"
<< endl;}// The method print() outputs an article.void Article::print()
{// As before! Compare to the solutions of chapter 14.}
316CHAPTER 15MEMBER OBJECTS AND STATIC MEMBERS
// ------------------------------------------------------//article_t.cpp// Tests the class Article including a copy constructor.// ------------------------------------------------------#include "article.h"           // Definition of the class#include <iostream>#include <string>using namespace std;void test( Article a);                      // PrototypeArticle article1( 1111,"tent", 159.9);      // Globalint main(){cout << "\nThe first statement in main().\n" << endl;Article article2( 2222,"jogging shoes", 199.99);cout << "\nThe first call of test()." << endl;test(article1);                      // Passing by Valuecout << "\nThe second call of test()." << endl;test(article2);                      // Passing by Valuecout << "\nThe last statement in main().\n"<< "\nThere are still " << Article::getCount()
<< " objects\n" << endl;return 0;}void test( Article a)        // Calls the copy constructor{cout << "\nThe given object:" << endl;a.print();static Article bike( 3333, "bicycle", 999.0);cout << "\nThe static object in function test():"<< endl;bike.print();cout << "\nThe last statement in function test()"<< endl;}
SOLUTIONS317Exercise 2
TheDateclass from the last chapter ( see files 
Date.handDate.cpp) can beleft unchanged.But it makes sense to define the function 
isLeapYear()as astatic member function of class Daterather than globally.
The other files:// ------------------------------------------------------//member.h// Defines the Member class containing a constant
// and a static member.
// ------------------------------------------------------#ifndef _MEMBER_H_#define _MEMBER_H_#include "Date.h"#include <string>
using namespace std;class Member{private:int nr;                       // Member numberstring name;                  // Name
const Date birth;             // Birthday// ... more datastatic Member *ptrBoss;       // Pointer to boss,// NULL = no boss.public:Member( long m_nr, const string& m_name,const Date& m_birth): nr(m_nr), birth(m_birth){if( !setName(m_name))  name = "Unknown";}Member( long m_nr, const string& m_name,int day, int month, int year): nr(m_nr), birth(day,month,year)
{if( !setName(m_name))  name = "Unknown";}int           getNr()    const { return nr; }const string& getName()  const { return name; }const Date&  getBirthday() const { return birth; }void setNr( int n) { nr = n; }
318CHAPTER 15MEMBER OBJECTS AND STATIC MEMBERS
bool setName( const string& s){if( s.size() < 1)           // No empty namereturn false;name = s;
return true;}void display() const;// static methods:static Member* getBoss()
{return ptrBoss;}static void setBoss( Member* ptrMem)
{ptrBoss = ptrMem;}};#endif   // _MEMBER_H_// ---------------------------------------------------//member.cpp// Members of class Member not defined inline.
// ---------------------------------------------------#include "member.h"               // Class definition#include <iostream>using namespace std;// Pointer to the boss:Member* Member::ptrBoss = NULL;void Member::display() const{string line( 50, '-');cout << line<< "\n  Member number: " << nr
<< "\n  Member:        " << name<< "\n  Birthday       " << birth.asString()<< '\n' << line << endl;}
SOLUTIONS319// ----------------------------------------------------//member_t.cpp// Using the class Member.// ----------------------------------------------------#include "member.h"                // Class definition
#include <iostream>
#include <string>
using namespace std;int main(){Date today;  today.setDate();
cout << "Date: " << today.asString() << endl;Member fran( 0, "Quick, Fran", 17,11,81),kurt( 2222, "Rush, Kurt", Date(3,5,77) );franzi.setNr(1111);cout << "\nTwo members of the sports club:\n" << endl;
fran.display();kurt.display();cout << "\nSomething changed!" << endl;
fran.setName("Rush-Quick");fran.display();Member benny( 1122,"Rush, Benny", 1,1,2000);
cout << "The youngest member of the sports club: \n";
benny.display();// Who is the boss?int nr;
Member *ptr = NULL;cout << "\nWho is the boss of the sports club?\n"<< "Enter the member number: ";if( cin >> nr){if( nr == fran.getNr())ptr = &fran;else if( nr == kurt.getNr())ptr = &kurt;Member::setBoss( ptr);}cout << "\nThe Boss of the sports club:" << endl;ptr = Member::getBoss();
if( ptr != NULL)ptr->display();elsecout << "No boss existing!" << endl;return 0;}
320CHAPTER 15MEMBER OBJECTS AND STATIC MEMBERS
Exercise 3
The definition of class Lights from this chapter remainsunchanged.// -----------------------------------------------------
//Lights_t.cpp: Simulates two traffic lights.// -----------------------------------------------------#include "lights.h"       // Definition of class Lights#include <iostream>
#include <ctime>          // Standard function time()using namespace hr;inline void wait( int sec)           // Wait sec seconds.{  time_t end = time(NULL) + sec;while( time(NULL) < end)   ;}// Alternative for Windows:
// #include <windows.h>// inline void wait( int sec) {  Sleep( 1000 * sec); }
Lights A1, A2;                        // Traffic lights andenum { greenTime1 = 10 , amberTime1 = 1,  // time to wait.greenTime2 = 14 , amberTime2 = 2  };int main(){  cout << "Simulating two traffic lights!\n\n"<< "Terminate this program with <Ctrl>+<C>!\n"
<< endl;cout << "  1. Light     2. Light\n"<< "---------------------------" << endl;while(true)
{  A1.setState( Lights::red);           // A1 = redA2.setState( Lights::amber);   cout << endl;wait( amberTime2);
cout << "             ";A2.setState( Lights::green);  cout << endl;wait(greenTime2);
cout << "             ";A2.setState( Lights::amber);   cout << endl;wait(amberTime2);
A1.setState( Lights::amber);          // A2 = redA2.setState( Lights::red);    cout << endl;wait(amberTime1);
A1.setState( Lights::green);  cout << endl;
wait(greenTime1);A1.setState( Lights::amber);   cout << endl;wait(amberTime1);}return 0;}
321Arrays
This chapter describes how to define and use arrays,illustrating one-
dimensional and multidimensional arrays,C strings and class arrays.
chapter
16
322CHAPTER 16ARRAYS
// array.cpp// To input numbers into an array and output after.// ----------------------------------------------------#include <iostream>
#include <iomanip>using namespace std;int main(){const int MAXCNT = 10;// Constantfloat arr[MAXCNT], x;        // Array, temp. variableint i, cnt;                  // Index, quantitycout << "Enter up to 10 numbers \n"<< "(Quit with a letter):" << endl;for( i = 0; i < MAXCNT&&  cin >> x; ++i)arr[i] = x;cnt = i;cout << "The given numbers:\n" << endl;for( i = 0; i < cnt;++i)cout << setw(10) << arr[i];cout << endl;return 0;}arr[0]arr[1]arr[2]arr[9]....     .     .DEFINING ARRAYS
The array 
arrin memory
Sample program

DEFINING ARRAYS323Anarraycontains multiple objects of identical types stored sequentially in memory. Theindividual objects in an array, referred to as array elements, can be addressed using a num-ber, the so-called indexorsubscript. An array is also referred to as a vector.Defining Arrays
An array must be defined just like any other object. The definition includes the arraynameand the typeandnumberofarray elements.Syntax:type name[count];        // Array nameIn the above syntax description, countis an integral constant or integral expressioncontaining only constants.Example:float arr[10];         // Array arrThis statement defines the array arrwith10elements of floattype. The object arritself is of a derived type, an “array of floatelements” or “floatarray.”An array always occupies a contiguousmemory space. In the case of the array arr,this
space is 10*sizeof(float) = 40bytes.Index for Array Elements
The subscript operator []is used to access individual array elements. In C++ an indexalways begins at zero. The elements belonging to the array arrare thusarr[0], arr[1] , arr[2], ... , arr[9]The index of the last array element is thus 1 lower than the number of array elements.
Anyintexpression can be used as an index. The subscript operator []has high prece-dence, just like the class member operators .and->.No error message is issued if the index exceeds the valid index range. As a program-mer, you need to be particularly careful to avoid this error! However, you can define a
class to perform range checking for indices.You can create an array from any type with the exception of some special types, suchasvoidand certain classes. Class arrays are discussed later.Example:short number[20];          // short arrayfor( int i=0; i < 20; i++ )number[i] = (short)(i*10);This example defines an array called numberwith 20 shortelements and assigns thevalues0, 10, 20, ... , 190to the elements.
324CHAPTER 16ARRAYS
// fibo.cpp// The program computes the first 20 Fibonacci// numbers and the corresponding Fibonacci quotients.
// -----------------------------------------------------#include <iostream>#include <iomanip>#include <cmath>               // Prototype of sqrt()#include <string>using namespace std;#define COUNT 20long fib[COUNT + 1] = { 0, 1 };string header =" Index  Fibonacci number Fibonacci quotient  Deviation""\n                                       of limit ""\n---------------------------------------------------";int main(){int i;double q, lim;for( i=1; i < COUNT; ++i )        // Computing thefib[i+1] = fib[i] + fib[i-1];   // Fibonacci numberslim = ( 1.0 + sqrt(5.0)) / 2.0;   // Limit// Title and the first two Fibonacci numbers:cout << header << endl;cout << setw(5) << 0 << setw(15) << fib[0] << endl;
cout << setw(5) << 1 << setw(15) << fib[1] << endl;// Rest of the table:for( i=2; i <= COUNT; i++ ){                                 // Quotient:q = (double)fib[i] / (double)fib[i-1];
cout << setw(5)  << i << setw(15) << fib[i]<< setw(20) << fixed << setprecision(10) << q<< setw(20) << scientific << setprecision(3)
<< lim - q  << endl;}return 0;}INITIALIZING ARRAYS
Sample program

INITIALIZING ARRAYS325Initialization List
Arrays can be initialized when you define them. A listcontaining the values for the indi-vidual array elements is used to initialize the array:Example:int num[3] = { 30, 50, 80 };A value of 30is assigned to num[0],50tonum[1], and 80tonum[2]. If you initializean array when you define it, you do not need to state its length.Example:int num[] = { 30, 50, 80 };In this case, the length of the array is equal to the number of initial values. If the array
length is explicitly stated in the definition and is larger than the number of initial values,
any remaining array elements are set to zero. If, in contrast, the number of initial values
exceeds the array length, the surplus values are ignored.Locally defined arrays are created on the stack at program runtime. You should there-fore be aware of the following issues when defining arrays:Arrays that occupy a large amount of memory (e.g., more than one kbyte) should
be defined as globalorstatic.Unless they are initialized, the elements of a local array will not necessarily havea definite value. Values are normally assigned by means of a loop.You cannot assign a vector to another vector. However, you can overload the assign-ment operator within a class designed to represent arrays. This topic will be discussed in
depth later.The Sample Program Opposite
The example on the opposite page contains the first twenty Fibonacci numbers and theirquotients. Fibonacci numbers are useful for representing natural growth. In computer sci-
ence, Fibonacci numbers are used for things like memory management and hashing.
Their definition is as follows:the first Fibonacci number is 0, the second is 1each subsequent Fibonacci number is the sum of its two immediate predecessors.This results in the following sequence: 0, 1, 1, 2, 3, 5, 8, 13, ....The quotient of a Fibonacci number and its predecessor is referred to as a Fibonacciquotient. The sequence of Fibonacci quotients, 1/1,2/1,3/2, ..., converges towardsthe threshold value (1 + 5)/2.
326CHAPTER 16ARRAYS
String textIndex:01234567891011
'H''e''l''l''o''  ''E''v''e''\0'..
The array texthas length of 40, whereas the string “Hello Eve"only occupies the first 9bytes.NOTE
// C-string.cpp  :  Using C strings.// -----------------------------------------------------#include <iostream>#include <iomanip>
#include <cstring>using namespace std;char header[] = "\n    ***  C Strings  ***\n\n";int main(){char hello[30] = "Hello ", name[20], message[80];cout << header << "Your first name: ";cin  >> setw(20) >> name;   // Enter a word.strcat( hello, name);       // Append the name.cout << hello << endl;
cin.sync();                 // No previous input.cout << "\nWhat is the message for today?"<< endl;cin.getline( message, 80);  // Enter a line with a// max of 79 characters.if( strlen( message) > 0)   // If string length is{                           // longer than 0.for( int i=0; message[i] != '\0'; ++i)cout << message[i] << ' ';   // Output withcout << endl;                  // white spaces.}
return 0;}C STRINGSInitializingchar text[40] = "Hello Eve";String text in memory:
Sample program

C STRINGS327charArrays
Arrays whose elements are of chartype are often used as data communication buffers.Example:char buffer[10*512];    // 5 Kbyte bufferHowever, their most common use is for string storage. One way of representing astring is to store the string and the terminating null character '\0'in a chararray.When you define an array, you can use a string constant to initialize the array.Example:char name[] = "Hugo";This definition is equivalent tochar name[] = { 'H','u','g','o','\0' };As you can see, the string nameoccupies five bytes, including an additional byte for thenull character. If you need to allocate more memory, you can state the size of the array
explicitly as shown opposite.In the C language, strings are usually represented as charvectors with a terminatingnull character. In C++, strings of this type are referred to as C stringsto distinguish themfrom objects of the stringclass.C Strings and the stringClassC strings are simple chararrays, which means that the functionality of the stringclass is not available for them. Thus, for example, assignments and comparisons are notdefined.Example:char str1[20], str2[20] = "A string";str1 = str2;                     // Error!
strcpy( str1, str2);             // ok!The standard functions of the C language, such as strlen(),strcpy(),strcmp(),and others, are available for C strings. These global functions all begin with the strpre-fix.As the program on the opposite page shows, I/O streams are overloaded for chararrays, too. Input and output are as easily achieved as with stringclass objects. How-ever, the program must make sure not to overrun the end of the chararray when read-ing data into the array. You can use the width()method or the setw()manipulatorfor this purpose.Example:cin >> setw(20) >> name; // 19 charactersC strings are preferable to the stringclass if only a few operations are needed andyou want to avoid unnecessary overheads.
328CHAPTER 16ARRAYS
// AccountTab.cpp// An array containing objects of class Account.
// ---------------------------------------------------#include "account.h"      // Definition of class Account#include <iostream>using namespace std;Account giro("Lucky, Peter", 1234567, -1200.99 );Account accountTab[] ={Account("Tang, Sarah", 123000, 2500.0),
Account("Smith, John", 543001),Account(),                    // Default constructor"Li, Zhang",                  // Account("Li, Zhang"),
giro                          // Account(giro)};int cnt = sizeof(accountTab) / sizeof(Account);int main(){// To set some values:
accountTab[1].setState( 10000.00);// Assignment ok:accountTab[2]=Account("Pit, Dave", 727003, 200.00);cout << "The accounts in the table:" << endl;for( int i = 0; i < cnt; ++i)
{accountTab[i].display();if( i % 3 == 2){cout << "Press return to go on!\n";
cin.get();}}
cout << endl;return 0;}CLASS ARRAYS
Sample program

CLASS ARRAYS329Declaring Class Arrays
Array elements can also be objects of a class type. The array is known as a class array inthis case. When you declare an array of this type, you only need to state the type of the
array elements.Example:Result temperatureTab[24];This statement defines the class array temperatureTabthat stores 24 objects of typeResult. This class was introduced at the beginning of the last chapter.As the statement does not initialize the array explicitly, the default constructor isautomatically called for each arrayelement. 
Thus, the previous example is only valid for the first version of the Resultclass asthis class contains a default constructor.Explicit Initialization
A class array is initialized as usual by an initialization list. The list contains a constructorcall for each array element.Example:Result temperatureTab[24] ={Result( -2.5, 0,30,30),
Result( 3.5),       // At present time
4.5,                // Just so
Result( temp1),     // Copy constructor
temp2               // Just so};The first five array elements are initialized by the constructor calls implicitly containedin these statements. Instead of using a constructor with one argument, you can simply
supply the argument. The default constructor is then called for the remaining elements.If the size of an array is not stated explicitly, the number of values in the initializationlist defines the size of the array.The public interface of the objects in the array is available for use as usual.Example:temperatureTab[2].setTime( 2,30,21);No additional parentheses are needed in this statement since the subscript operator []and the class member operator .are read from left to right, although they have the sameprecedence.Class arrays can only be defined without explicit initialization if a default constructor exists for the class.NOTE

330CHAPTER 16ARRAYS
// multidim.cpp// Demonstrates multidimensional arrays.
// ----------------------------------------------------
#include <iostream>
#include <iomanip>using namespace std;char representative[2][20]= {"Armstrong, Wendy","Beauty, Eve"};// Each representative has five different// articles available, having sold the following:int articleCount[2][5]= { { 20,  51, 30,  17, 44},{150, 120, 90, 110, 88}};int main(){for( int i=0; i < 2; i++ ){cout <<"\nRepresentative:  " << representative[i];cout << "\nNumber of items sold: ";for( int j = 0; j < 5; j++ )cout << setw(6) << articleCount[i][j];cout << endl;}return 0;}MULTIDIMENSIONAL ARRAYS
Sample program
Screen output:
Representative:  Armstrong, WendyItems sold:     20   51   30   17   44Representative:  Beauty, EveItems sold:     150  120   90  110   88
MULTIDIMENSIONAL ARRAYS331Defining Multidimensional Arrays
In C++ you can define multidimensional arrays with any number of dimensions. TheANSI standard stipulates a minimum of 256 dimensions but the total number of dimen-
sions is in fact limited by the amount of memory available.The most common multidimensional array type is the two-dimensional array, the so-calledmatrix.Example:float number[3][10];    // 3 x 10 matrixThis defines a matrix called numberthat contains 3 rowsand 10 columns. Each of the 30(310) elements is a floattype. The assignmentExample:number[0][9] = 7.2;     // Row 0, column 9stores the value 7.2in the last element of the first row.Arrays as Array Elements
C++ does not need any special syntax to define multidimensional arrays. On the con-trary, an n-dimensional array is no different than an array with only one dimension
whose elements are (n–1)-dimensional arrays.The array numberthus contains the following three elements:number[0]number[1]number[2].
Each of these elements is a floatarray with a size of 10, which in turn forms the rows ofthe two-dimensional array, number.This means that the same rules apply to multidimensional arrays as to one-dimen-sional arrays. The initialization list of a two-dimensional array thus contains the values of
the array elements, that is, the one-dimensional rows.Examples:int arr[2][3] = { {5, 0, 0}, {7, 0, 0} };int arr[][3]  = { {5}, {7} };These two definitions are equivalent. When you initialize an array, you can only omitthe size of the first dimension. It is necessary to define any other dimensions since they
define the size of array elements.The Example on the Opposite Page
The program opposite defines the two-dimensional arrays representativeandarticleCount,which have two rows each. The 
representative[i]rows arechararrays used for storing the names of the representatives. You can also use a one-dimensionalstringarray.Example:string representative[2] = {"La..","Fo.."};
332CHAPTER 16ARRAYS
// telList.h// Class TelList to represent a list// containing names and telephone numbers.
// ----------------------------------------------------#ifndef _TelList_#define _TelList_#include <string>using namespace std;
#define PSEUDO -1          // Pseudo position#define MAX 100            // Maximal number of elements// Type of a list element:struct Element { string name, telNr; };class TelList{private:Element v[MAX];// The array and the currentint count;             // number of elementspublic:TelList(){ count = 0;}intgetCount() const { return count; }Element*retrieve( int i ){return (i >= 0 && i < count)? &v[i] : NULL;}boolappend( const Element& el ){return append( el.name, el.telNr);}boolappend( const string& name,const string& telNr);boolerase( const string& name);intsearch( const string& name);voidprint();intprint( const string& name);intgetNewEntries();};#endif  // _TelList_MEMBER ARRAYS
ClassTelList
MEMBER ARRAYS333Encapsulating Arrays
A programmer often needs to handle objects of the same type, such as company employ-ees, bank accounts, or the articles in stock. A class designed to perform this task can use
an array for ease of data management. An array allows you to access individual objects
directly and perform searches.A class that encapsulates an array will provide methods for simple array operations,such as inserting and deleting objects. When you design a class of this type, one aim will
be to perform automatic range checking. This helps avoid overrunning the end of an
array when performing read or write operations. The resulting class will contain a com-
fortable and safe interface for object data management.The Class TelListThe class TelListon the opposite page is designed to manage a simple telephone list.Each entry in the list contains a dataset containing a name and a phone number. TheElementtype, which comprises two strings, was defined for this purpose. The array vcan store up to MAXentries of the Elementtype. The data member countrecords thenumber of elements currently stored in the array. When a phone list is created, this num-
ber will initially be 0. When an element is inserted or deleted, the number is modified
correspondingly.TheTelListclass uses a single default constructor that sets the counter, count, tozero. It is not necessary to provide an initial value for the MAXelements in the array vsince the default constructor of the stringclass is executed for all strings.The tasks performed by the other methods are easily deduced from their names. Theretrieve()method returns to a given index a pointer to the corresponding element.Using a pointer makes it possible to return a NULL pointer if the index is invalid.Theappend()methods add a new entry to the list. The data passed to a method iscopied to the next free array element and the counter is incremented. If there is no space
available, the name field is empty, or the name is already in use, nothing happens. In this
case, the method returns falseinstead of true.The exercises for this chapter contain further details on these methods. You canimplement the methods for the TelListyourself and go on to test them.
exercises
334CHAPTER 16ARRAYS
Original array:
After the first loop:After the second loop:100503070405030704010030504070100second largest elementlargest element0123456789
. . .. . .false
Array
Index
falsetruetruefalsetruefalsetruefalsefalse
* * B R E A K * * * *---  Press interrupt key to terminate (^C) ---The output of a scrolling string has to be performed at the same cursor position.The screen control characters make it possible to locate the cursor, and that
independent of the current compiler (see appendix).NOTE
EXERCISESExample of a bubble sort algorithm
Sieve of Eratosthenes
For this task you can define an array of boolean values in which each element is
initially 
true.To eliminate a number 
nyou simply set the 
nthelement in the array
tofalse.Result:Screen shot of exercise 4

EXERCISES335Use the bubble sort algorithm to sort the array. This algorithm repeatedly accesses the array, comparingneighboring array elements and swapping them if needed. The sorting algorithm terminates when there
are no more elements that need to be swapped. You use a flag to indicate that no elements have been
swapped.NOTE
Exercise 1
Write a C++ program that reads a maximum of 100 integers from the keyboard,
stores them in a 
longarray,sorts the integers in ascending order,and displays
sorted output.Input can be terminated by any invalid input,such as a letter.
Exercise 2
Chapter 14 introduced the sample class 
DayTimeand the isLess()method.Define and initialize an array with four 
DayTimeclass objects.Then write a mainfunction that first uses the print()method to display the
four elements.Finally,find the largest and smallest elements and output them on

screen.
Exercise 3
Write a program that outputs all prime numbers less than 1000.The program

should also count the number of prime numbers less than 1000.An integer >= 2

is a prime number if it is not divisible by any number except 1 and itself.Use the

Sieve of Eratosthenes
:To find primary numbers simply eliminate multiples of any primary numbers
you have already found,i.e.:
first eliminate any multiples of 2 ( 4,6,8,...),
then eliminate any multiples of 3 ( 6,9,12,...),

then eliminate any multiples of 5 ( 10,15,20,..) // 4 has already been eliminated

and so on.Exercise 4
Write a C++ program to create the screen output shown opposite.The
following banner
* * *  B R E A K  * * *is to be displayed in the center of the window and scrolled left.You can scroll

the banner by beginning string output with the first character,then the second,

and so on.Handle the string like a loop where the first letter follows the last

letter and output continues until the starting position is reached.
You can use a wait loop to modify the speed of the banner after each string is
output.
336CHAPTER 16ARRAYS
boolappend( const string& name,const string& telNr);boolerase( const string& name);intsearch( const string& name);voidprint();intprint( const string& name);intgetNewEntries();*****  Telephone List  *****D = Display all entriesF = Find a telephone numberA = Append an entryE = Erase an entry
Q = Quit the programYour choice:Exercise 5
Methods to be implemented for the TelList class
Menu of the application program

EXERCISES337The phone list will not be stored permanently in a file. This is just one of the enhancements (anotherwould be variable length) that will be added at a later stage.NOTE
Exercise 5
The sample class TelListwas introduced in this chapter;however,some
methods still need to be implemented and tested.Implement the TelListclass methods shown opposite.
The name is used as an unambiguous key.This means the 
append()method can only be used to append an entry provided the name is nei-
ther blank nor already in use.
The method erase()deletes an array element.The position of the ele-
ment to be deleted is first located using the search()method.If the ele-
ment does not exist,erase()returns a value of 
false.In any other case,
the last element in the array is used to overwrite the element that is to

be deleted and the counter countis decremented.
Thesearch()method finds the position in the array that contains the
search name.If the search operation is unsuccessful,the value 
PSEUDOisreturned.
Theprintmethod without parameters outputs all available entries.You
can pass the first letter or letters of a name to the second method to
output any entries beginning with these letters.Use the method 
com-pare()from the 
stringclass to help you with this task.
Example:str1.compare( 0, 5, str2) == 0This expression is true if the five characters subsequent to position 0 in
the strings str1andstr2are identical.
ThegetNewEntries()method is used to read new phone list entries
from the keyboard.Each new entry is appended using the 
append()method.Reading should be terminated if the user types an empty string.

The method returns the number of new entries.
Write an application program that creates a phone list of type 
TelListand displays the menu shown on the opposite page.
The menu must be placed in a function of your own that can return the
command input.The menu must be called in the main loop of the pro-

gram.Depending on the command input,one of the methods defined in

the class TelListshould be called.If the menu item “Erase” or “Search”
is chosen,you must also read a name or the first letters of a name from

the keyboard.

solutions
338CHAPTER 16ARRAYS
SOLUTIONSExercise 1
// ---------------------------------------------------//bubble.cpp// Inputs integers into an array,
// sorts in ascending order, and outputs them.// ---------------------------------------------------
#include <iostream>#include <iomanip>
using namespace std;#define MAX  100                     // Maximum numberlong number[MAX];int main(){int i, cnt;                       // Index, quantitycout << "\nS o r t i n g  I n t e g e r s \n"<< endl;// To input the integers:cout << "Enter up to 100 integers \n"<< "(Quit with any letter):" << endl;for( i = 0; i < MAX  &&  cin >> number[i]; ++i);cnt = i;
// To sort the numbers:bool sorted = false;            // Not yet sorted.long help;                      // Swap.
int  end = cnt;                 // End of a loop.while( !sorted)                 // As long as not{                               // yet sorted.sorted = true;--end;
for( i = 0; i < end; ++i)     // Compares{                             // adjacent integers.if( number[i] > number[i+1])
{sorted = false;          // Not yet sorted.help     = number[i];    // Swap.number[i]  = number[i+1];
number[i+1]= help;}}}
SOLUTIONS339// Outputs the numberscout << "The sorted numbers:\n" << endl;for( i = 0; i < cnt; ++i)cout << setw(10) << number[i];cout << endl;return 0;}Exercise 2
// ----------------------------------------------------//DayTime.h// The class DayTime represents the time in hours,// minutes and seconds.// ----------------------------------------------------
#ifndef _DAYTIME_
#define _DAYTIME_
#include <iostream>
#include <iomanip>using namespace std;class DayTime{private:short hour, minute, second;bool overflow;public:DayTime( int h = 0, int m = 0, int s = 0){overflow = false;if( !setTime( h, m, s))         // this->setTime(...)hour = minute = second = 0;}
bool setTime(int hour, int minute, int second = 0)
{if(    hour   >= 0  &&  hour < 24&& minute >= 0  &&  minute < 60&& second >= 0  &&  second < 60 ){this->hour   = (short)hour;this->minute = (short)minute;this->second = (short)second;return true;}elsereturn false;}
340CHAPTER 16ARRAYS
int getHour()   const { return hour;   }int getMinute() const { return minute; };
int getSecond() const { return second; };int asSeconds() const      // Daytime in seconds{return (60*60*hour + 60*minute + second);}bool isLess( DayTime t) const  // Compares// *this and t.{return  asSeconds() < t.asSeconds();}      // this->sSeconds() < t.asSeconds();void print() const{cout << setfill('0')<< setw(2) << hour    << ':'<< setw(2) << minute  << ':'<< setw(2) << second  << " Uhr" << endl;cout << setfill(' ');}
void swap( DayTime& t)       // Just one parameter!
{                            // Swaps *this and t:DayTime temp(t);  t = *this;  *this = temp;}};#endif   // _DAYTIME_// -----------------------------------------------------//TimeTab.cpp// An array containing objects of class DayTime.// -----------------------------------------------------
#include "DayTime.h"      // Definition of class DayTime#include <iostream>using namespace std;
char header[] ="\n\n      ***  Table with Daytimes ***\n\n";int main(){DayTime timeTab[4] ={ 18, DayTime(10,25), DayTime(14,55,30)};int i;timeTab[3].setTime( 8,40,50);          // Last element.cout << header << endl;
SOLUTIONS341// Output:for( i = 0; i < 4; ++i)
{timeTab[i].print();cout << endl;}// To compute shortest and longest time:int i_min = 0, i_max = 0;        // Indices for shortest// and longest elements.for( i = 1; i < 4; ++i)
{if( timeTab[i].isLess( timeTab[i_min]) )i_min = i;if( timeTab[i_max].isLess( timeTab[i]) )i_max = i;}cout << "\nShortest time: ";  timeTab[i_min].print();cout << "\nLongest time: ";   timeTab[i_max].print();return 0;}
342CHAPTER 16ARRAYS
Exercise 3
// ------------------------------------------------------//sieve.cpp// Identifies prime numbers using the Sieve of
// Eratosthenes.
// ------------------------------------------------------#include <iostream>#include <iomanip>
using namespace std;#define LIMIT  1000                   // Upper limitbool flags[LIMIT] = { false, false};  // Array with flagsint main(){register int i, j;                 // Indicesfor( i = 2; i < LIMIT; ++i)flags[i] = true;               // Sets flags to true// Sieving:
for( i = 2; i < LIMIT/2; ++i){if( flags[i])             // Is i a prime number?
{                         // Yes -> Delete multiples.for( j = i+i; j < LIMIT; j += i)flags[j] = false;}}
// To count:int count = 0;               // Counter
for( i = 2; i < LIMIT; ++i)if(flags[i])              // If i is a prime number++count;                // -> count// Output:cout << "There are"<< count <<" prime numbers less than"<< LIMIT << endl;cout << "\nTo output prime numbers? (y/n) ";char reply;  cin.get(reply);if( reply == 'y' || reply == 'Y')
{  for( i = 2; i < LIMIT; ++i)if(flags[i])            // If i is a prime number{                       // -> to output it.cout.width(8);  cout << i;}}cout << endl;    return 0;}
SOLUTIONS343Exercise 4
// ----------------------------------------------------//scroll.cpp// Scrolling a message.
// ----------------------------------------------------#include <iostream>#include <iomanip>
using namespace std;
#define DELAY  10000000L                // Output delayinline void cls()                       // Clear screen{cout << "\033[2J\n";}inline void locate(int z, int s)   // Put cursor in row z{                                  // and column scout << "\033[" << z << ';' << s << 'H';}char msg[] = "* * *  B R E A K  * * * ";
int main(){int i, start = 0, len = strlen(msg);cls();  locate(24, 20);        // Row 24, column 20cout << "--- Press interrupt key to terminate (^C) ---";while( true ){locate( 12, 25);            // Row 12, column 25i = start;                  // Output from index startdo
{cout << msg[i++];i = i % len;            // if( i == len) i = 0;}
while( i != start);
cout << endl;              // Outputs buffer to screen
// Wait in shortfor( int count = 0; count < DELAY; ++count);++start;                     // For next output
start %= len;                // start = start % len;}cls();
return 0;}
344CHAPTER 16ARRAYS
Exercise 5
// ----------------------------------------------------//telList.h// The class TelList representing a list
// with names and telephone numbers.
// -----------------------------------------------------//// As before in this chapter.// ----------------------------------------------------//telList.cpp// Implements the methods of class TelList.
// -----------------------------------------------------
#include "telList.h"      // Definition of class TelList
#include <iostream>
#include <iomanip>
using namespace std;boolTelList::append( const string& name,const string& telNr){if( count < MAX                // Space available,&& name.length() > 1       // 2 characters at least&& search(name) == PSEUDO) // not yet existing{v[count].name  = name;v[count].telNr = telNr;
++count;
return true;}return false;}boolTelList::erase( const string& key ){int i = search(key);if( i != PSEUDO )
{                               // Copies the lastv[i] = v[count-1];  --count;  // element to position ireturn true;}
return false;}
SOLUTIONS345intTelList::search(const string& key ) {for( int i = 0; i < count; i++ )        // Searching.if( v[i].name == key )return i;                           // Foundreturn PSEUDO;                          // Not found}
// Functions to support the output:
inline void tabHeader()              // Title of the table
{cout << "\n  Name                        Telephone #\n""----------------------------------------------"<< endl;}
inline void printline( const Element& el)
{cout << left << setw(30) << el.name.c_str()<< left << setw(20) << el.telNr.c_str()<< endl;}voidTelList::print()// Outputs all entries{if( count == 0)cout << "\nThe telephone list  is empty!" << endl;else
{tabHeader();
for( int i = 0; i < count; ++i)printline( v[i]);}}
intTelList::print( const string& name) const // Entries{                                   // beginning with name.int matches = 0, len = name.length();for( int i = 0; i < count; ++i){if( v[i].name.compare(0, len, name) == 0)
{if( matches == 0) tabHeader();  // Title before// first output.++matches;
printline( v[i]);}}
if( matches == 0)cout << "No corresponding entry found!" << endl;return matches;}
346CHAPTER 16ARRAYS
intTelList::getNewEntries()          // Input new entries{int inputCount = 0;cout << "\nEnter new names and telephone numbers:""\n(Terminate by empty input) "<< endl;Element el;while( true)
{cout << "\nNew last name, first name:  ";cin.sync(); getline( cin, el.name);
if( el.name.empty())break;cout << "\nTelephone number: ";
cin.sync(); getline( cin, el.telNr);
if( !append( el)){cout << "Name has not been found!" << endl;
if( count == MAX){cout << "The Table is full!" << endl;
break;}if( search( el.name) != PSEUDO)cout << "Name already exists!" << endl;}else{++inputCount;cout << "A new element has been inserted!"<< endl;}}return inputCount;}// --------------------------------------------------------//telList_t.cpp// Manages a telephone list.// --------------------------------------------------------#include "telList.h"      // Definition of class TelList
#include <iostream>#include <string>#include <cctype>
using namespace std;inline void cls(){  cout << "\033[2J\n";// Output only new-lines, if ANSI 
}                      // control characters are not available.
SOLUTIONS347inline void go_on(){cout << "\n\nGo on with return! ";cin.sync();  cin.clear();           // No previous input
while( cin.get() != '\n');}int menu();                            // Reads a command
char header[] ="\n\n                *****  Telephone List  *****\n\n";TelList myFriends;               // A telephone list
int main(){int action = 0;                // Command
string name;                   // Reads a namemyFriends.append("Lucky, Peter", "0203-1234567");while( action != 'B'){action = menu();
cls();cout << header << endl;switch( action){case 'D':                          // Show allmyFriends.print();go_on();
break;case 'F':                          // Searchcout <<"\n--- To search for a phone number ---\n"
"\nEnter the beginning of a name: ";
getline( cin, name);if( !name.empty()){myFriends.print( name);
go_on();}break;case 'A':                          // InsertmyFriends.getNewEntries();
break;
348CHAPTER 16ARRAYS
case 'E':                          // Deletecout <<
"\n--- To delete a telephone entry. ---\n ""\nEnter the complete name: ";getline( cin, name);
if( !name.empty())
{if( !myFriends.erase( name))cout << name << " not found!"<< endl;elsecout << "Entry for " << name<< " deleted!" << endl;go_on();}
break;case 'T':  cls();                  // To terminatebreak;}} // End of whilereturn 0;}int menu(){static char menuStr[] =
"\n\n             D = Display all entries""\n\n             F = Find a telephone number""\n\n             A = Append a new entry "
"\n\n             E = Erase an entry ""\n\n             Q = Quit the program""\n\n Your choice:  ";cls();cout << header << menuStr;char choice;cin.sync(); cin.clear();      // No previous inputif( !cin.get(choice))choice = 'B';elsechoice = toupper(choice);cin.sync();                   // Clear input bufferreturn choice;}
349Arrays and Pointers
This chapter describes the relationship between pointers and arrays.This
includes:pointer arithmetic
pointer version of functions
pointers as return values and read-only pointers
pointer arrays
Operations that use C strings illustrate how to use pointers for efficient

programming.String access via the command line of an application

program is used to illustrate pointer arrays.
chapter
17
350CHAPTER 17ARRAYS AND POINTERS
// textPtr.cpp// Using arrays of char and pointers to char// -----------------------------------------------------
#include <iostream>using namespace std;int main(){cout << "Demonstrating arrays of char "<< "and pointers to char.\n"<< endl;char text[] = "Good morning!",name[] = "Bill!";char *cPtr = "Hello ";          // Let cPtr point// to "Hello ".cout << cPtr << name << '\n'<< text << endl;cout << "The text \"" << text<< "\" starts at address " << (void*)text<< endl;cout << text + 6      // What happens now?<< endl;cPtr = name;    // Let cPtr point to name, i.e. *cPtr// is equivalent to name[0]cout << "This is the " << *cPtr << " of " << cPtr<< endl;*cPtr = 'k';
cout << "Bill can not " << cPtr << "!\n" << endl;return 0;}ARRAYS AND POINTERS (1)
Sample program
Sample output:Demonstrating arrays of char and pointers to char.Hello Bill!
Good morning!
The text "Good morning!" starts at address 00451E40
morning!
This is the B of Bill!
Bill can not kill!
ARRAYS AND POINTERS (1)351Name and Address of an Array
In C++ the name of an array is also the starting address for that array. To be more pre-cise, an array name is a pointer to the first array element.Example:char town[] = "Beijing";In this case, townis a charpointer to town[0], that is, a pointer to the memoryaddress that stores the 'B'character. Expressions townand&town[0]are thus equiva-lent.Example:cout << town; // or:  cout << &town[0];A pointer to the first character of the string townis passed. The characters forming thestring are read and displayed from this point onward until the terminating null character,'\0', is reached.Pointer Variables and Arrays
An array name is not a pointer variable but a constant that cannot be modified. How-ever, you can assign this constant to a pointer variable.Example:char *cPtr;cPtr = town;        // or: cPtr = &town[0];
cout << cPtr;       // To output "Beijing"NowcPtrpoints to the array element town[0]just like town. But, in contrast totown,cPtris a variable that can be moved.Example:cPtr = "Hello!";After this statement, cPtrpoints to the ‘H'character. String constants such as“Hello!"are also chararrays and thus represent the address of the first array element.Typeless Pointers
If you need to display the address rather than the string, you should pass a void*typepointer rather than a charpointer.Example:cout << (void *)town;This casts the charpointer to a void *type pointer and passes it as an argument tothe << operator, which in turn outputs the address in hexadecimal format. The << oper-
ator belongs to the ostreamclass and is overloaded for void *types for this purpose.Avoid *pointer represents a memory address without establishing a certain type.void *pointers are also referred to as typeless pointers for this reason. When you use atypeless pointer for memory access, you must therefore name the type being accessed
explicitly by means of type casting.
352CHAPTER 17ARRAYS AND POINTERS
0102030arrarr[0]
arr[1]arr[0]arr[3]arr + 1arr + 2arr + 3// arrPtr.cpp// Outputs addresses and values of array elements.// ---------------------------------------------------#include <iostream>using namespace std;int arr[4] = { 0, 10, 20, 30 };int main(){cout << "\nAddress and value of array elements:\n"<< endl;for( int i = 0; i < 4; i++ )cout << "Address: " << (void*)(arr+i)// &arr[i]<< "   Value: " << *(arr+i)// arr[i]<< endl;return 0;}ARRAYS AND POINTERS (2)
Sample program
Interrelation between pointers and array elements

ARRAYS AND POINTERS (2)353Addressing Array Elements
Access to individual array elements in C++ is very closely related to pointer arithmetic.Now let’s look at an intarray to illustrate this point.Example:int arr[4] = { 0, 10, 20, 30 };As you already know, the name of the array arris an intpointer to arr[0].Now it is possible to add or subtract pointers and integral values. The size of theobject referenced by the pointer is automatically taken into consideration.Sincearris an intpointer to arr[0],arr+1points to the next array elementarr[1], i.e., to an address that is sizeof(int)bytes higher in memory. The memoryspace between the two entries will be two or four bytes, depending on the size of the typeint. Thus the following applies to any given number, i:arr + i points to the array element arr[i],*(arr + i) is the array element arr[i],This technique can also be used to address memory spaces outside of the array. Thus,arr - 1addresses the word that precedes arr[0]. But generally this does not makemuch sense, since you have no means of knowing what is stored at this memory address.Addressing with Pointer Variables
Array elements can also be addressed using pointer variables.Example:int *ptr = arr;   // ptr points to arr[0]In this case, both ptrandarrare pointers to the array element arr[0]. Thus, ptr + 1,ptr + 2,. . .point to the array elements arr[1],arr[2],....For any given integer, i, the following expressions are thus equivalent:&arr[i]      arr + i       ptr + iThe following thus represent equivalent values:arr[i]    *(arr + i)    *(ptr + i)    ptr[i]At first it might seem surprising that you can use the array notation ptr[i]for pointers.The compiler translates arr[i]to*(arr + i)—in other words: “Start at addressarr, move iobjects up, and access the object!” This also applies to ptr[i].
354CHAPTER 17ARRAYS AND POINTERS
float v[6] = { 0.0, 0.1, 0.2, 0.3, 0.4, 0.5 },*pv, x;pv = v + 4;      // Let pv point to v[4].*pv = 1.4;       // Assign 1.4 to v[4].pv -= 2;         // Reset pv to v[2].++pv;            // Let pv point to v[3].x = *pv++;       // Assign v[3] to x and// increment pv.x += *pv--;      // Increment x by v[4] and let// pv point to v[3] again.--pv;            // Reset pv to v[2].// Searches for a given account number in a table of// accounts and outputs the found account.// --------------------------------------------------#include "account.h"     // Definition of class Account.Account accountTab[100]; // Table containing accounts.
int main(){int cnt;              // Actual number of accounts.Account *aPtr; // Pointer to Account-objects.// To input data into accountTab and actualize cnt.
// To search for the account number 1234567:bool found = false;for(aPtr = accountTab; aPtr < accountTab+cnt;++aPtr)if(aPtr->getNr()== 1234567 ){  found = true;break;}if( found)                     // Found?aPtr->display();// Yes -> display.// To continue}POINTER ARITHMETICExamples for arithmetic with pointersTo step through an array of classes

POINTER ARITHMETIC355In C++ you can perform arithmetic operations and comparisons with pointers, providedthey make sense. This primarily means that the pointer must always point to the ele-
ments of an array. The following examples show some of your options with pointer arith-
metic:Example:float v[6], *pv = v;  // pv points to v[0]int i = 3;Moving a Pointer in an Array
As you already know, the addition pv + iresults in a pointer to the array elementv[i].You can use a statement such aspv = pv + i;to store the pointer in the vari-ablepv. This moves the pointer pv iobjects, that is, pvnow points to v[i].You can also use the operators++,--,and+=or-=with pointer variables. Someexamples are shown opposite. Please note that the indirection operator, *, and the oper-ators++and--have the same precedence. Operators and operands thus are groupedfrom right to left:Example:*pv++is equivalent to*(pv++)The++operator increments the pointer and not the variable referenced by the pointer.Operations of this type are not possible using the pointer vsincevis a constant.Subtracting Pointers
An addition performed with two pointers does not return anything useful and is there-fore invalid. However, it does make sense to perform a subtractionwith two pointers,resulting in an intvalue that represents the number of array elements between thepointers. You can use this technique to compute the index of an array element refer-
enced by a pointer. To do so, you simply subtract the starting address of the array. For
example, if pvpoints to the array element v[3], you can use the following statementExample:int index = pv - v;to assign a value of 3to the variable index.Comparing Pointers
Finally,comparisonscan be performed with two pointers of the same type.Example:for( pv = v + 5; pv >= v; --pv)cout << setw(10) << *pv;This loop outputs the numbers contained in vin reverse order. In the example on theopposite page, the pointer aPtrwalks through the first cntelements of the arrayaccountTab, as long as aPtr < accountTab + cnt.
356CHAPTER 17ARRAYS AND POINTERS
// reverse.cpp// Defines and calls the function reverse().// reverse() copies a C string into another C string
// and reverses the order of characters.// -----------------------------------------------------#include <iostream>using namespace std;#include <string.h>      // Header-File for Cstrings,// here for strlen().void reverse( char str[], char umstr[]);// Prototypeint main()               // Read a word and{                        // output in reversed order.const int CNT = 81;
char word[CNT], revword[CNT];cout << "Enter a word: ";cin.width(CNT);       // maximal CNT-1 characterscin >> word;reverse( word, revword); // Callcout << "\nThe \"reversed\" word:   " << revword<< endl ;return 0;}void reverse( char s1[], char s2[]) // Copies the{                         // reversed C string s1 to s2int j = 0;for( int i = strlen(s1)-1; i >= 0; i--, j++)s2[j] = s1[i];s2[j] = '\0';                // Terminating character}ARRAYS AS ARGUMENTS
Sample program
Sample output:Enter a word: REGALThe "reversed" word:   LAGER
ARRAYS AS ARGUMENTS357If an array name is passed as an argument when calling a function, the function actuallyreceives the address of the first array element. The called function can then perform read
or write operations for any element in the array.Declaring Parameters
If the argument is an array, there are two equivalent methods of declaring parameters.This point is illustrated by the example using strlen()to return the length of a Cstring. For example, calling strlen("REGAL")returns a value of 5.1.You can declare the parameter as an array.
Example:int strlen( char str[])    // Compute length of{  int i;                  // str without '\0'.for( i = 0;  str[i] != '\0';  ++i);return (i);}2.You can declare the parameter as a pointer.
Example:int strlen( char *str){   /*  as above  */  }In both cases the parameter stris a pointer that stores the starting address of thearray. Array notation is preferable if you intend to use an index to access the elements of
an array. Calling strlen("REGAL");leads to the following situation:As you can see, the length of a C string is equal to the index of the element containingthe terminating null character.The function reverse()on the opposite page copies the characters of a C string toa second chararray in reverse order, first copying the last character in s1, that is, thecharacter with the index strlen(s1)-1, to s2[0], then the second to last characters2[1], and so on.Array Length
A function to which an array is passed initially knows only the starting address of thearray but not its length. In the case of C strings, the length is derived implicitly from the
position of the terminating null character. In most other cases the length must be sup-
plied explicitly.Example:void sort( Account aTab[], int len ){ /* To sort array aTab of length len */}str[0]str[1]str[2]str[3]str[4]str[5]
'R''E''G''A''L''\0'

358CHAPTER 17ARRAYS AND POINTERS
void strcpy( char s1[], char s2[])    // Copies s2 to s1{int i;                             // Index
for( i = 0;  s2[i] != '\0';  ++i)  // Copy.s1[i] = s2[i];s1[i] = '\0';                 // Append terminating}                                // character.void strcpy( char *s1, char *s2)      // Copies s2 to s1{for( ;  *s2 != '\0';  ++s1, ++s2)  // Copy*s1 = *s2;*s1 = '\0';                   // Append terminating}                                // character.void strcpy( char *s1, char *s2)      // Copy s2 to s1.{while( (*s1++ = *s2++) != '\0' )   // Copy and append;                               // terminating}                                     // character.POINTER VERSIONS OF FUNCTIONS
FunctionstrcpyThe standard function strcpy()copies C strings.Example:char dest[30], source[] = "A string";strcpy( dest, source);Here the string sourceis copied to dest“from left to right” just like an assignment.The following function strcpy()is somewhat simpler than the standard functionsince it has no return value.Index Version of 
strcpy()Pointer version 1 of 
strcpy()Pointer version 2 of 
strcpy()
POINTER VERSIONS OF FUNCTIONS359Using Pointers Instead of Indices
As we have already seen, a parameter for an array argument is always a pointer to thefirst array element. When declaring parameters for a given type T:T name[]is always equivalent toT *name.So far, in previous sample functions, the pointer has been used like a fixed baseaddress for the array, with an index being used to access the individual array elements.
However, it is possible to use pointers instead of indices.Example:A new version of the standard function strlen():int strlen( char *str)     // Computes length{                          // of str without '\0'.char* p = str;
for( p = str;  *p != '\0'; ++p)  // Search;                              // for  \0return (p - str);}In this case, the difference between two pointers results in the string length.The Sample Functions OppositeThe first version of the function strcpy()“string copy” opposite uses an index,whereas the second does not. Both versions produce the same results: the string s2iscopied to s1. When you call the function, you must ensure that the chararray refer-enced by s1is large enough.As the parameters s1ands2are pointer variables, they can be shifted. The second“pointer version” of strcpy(), which is also shown opposite, uses this feature, althoughthe function interface remains unchanged.Generally, pointer versions are preferable to index versions as they are quicker. In anexpression such as s1[i]the values of the variables s1andiare read and added tocompute the address of the current object, whereas s1in the pointer version alreadycontains the required address.Multidimensional Arrays as Parameters
In a parameter declaration for multidimensionalarrays, you need to state every dimensionwith the exception of the first. Thus, a parameter declaration for a two-dimensional array
will always contain the number of columns.Example:long func( int num[][10] );   // ok.long func( int *num[10] );    // also ok.
360CHAPTER 17ARRAYS AND POINTERS
// accountFct.cpp// Defines and calls a function, which outputs// a list of overdrawn accounts.
// --------------------------------------------------#include "account.h"     // Definition of class Account.Account accountTab[] =   // Table with Account-objects.{  Account("Twain, Mark", 1234567, -3434.30),Account("Crusoe, Robinson", 200000, 0.00),
Account("Temple, Shirley", 543001, +777.70),Account("Valentin, Carl", 543002, -1111.10),};
int cnt = sizeof(accountTab) / sizeof(Account);// Prototype:int displayOverdraw( const Account *aTab, int cnt,double limit);int main(){double limit = 0.0;cout << "Output the overdrawn accounts!\n"<< "These are the accounts, which fell below \n"<< "the limit, ex. -1000.00.\n" << endl;cout << "What is the limit? ";
cin >> limit;cout << "Listing the overdrawn accounts:\n" << endl;if( displayOverdraw( accountTab, cnt, limit) == 0)cout << "\nNo account found!"<< endl;return 0;}int displayOverdraw( const Account *aTab, int cnt,double limit){  int count = 0;const Account* aPtr;for( aPtr = aTab;  aPtr < aTab + cnt;  ++aPtr)if( aPtr->getState() < limit ) // Below the limit?{aPtr->display();            // Yes -> display.++count;}return count;}READ-ONLY POINTERS
Sample program

READ-ONLY POINTERS361Pointers to 
constObjectsYou can use a normal pointer for both read and write access to an object. However, justlike the definition used for a reference, you can also define a read-only pointer, that is, apointer that can be used for read operations only. In fact, a read-only pointer is obliga-
tory if you need to point to a constant object.Declaration
You use the keyword constto define a read-only pointer.Example:const int a = 5, b = 10,  *p = &a;This statement defines the constants aandb, and a pointer pto a constant object oftypeint. The referenced object *pcan be read but not modified.Example:cout << *p;       // To read is ok.*p = 1;           // Error!The pointer itself is not a constant, so it can be modified:Example:p = &b;           // ok!The referenced object also does not need to be a constant. In other words, a read-onlypointer can also point to a non-constant object.Example:Account depo("Twain, Mark", 1234, 4321.90);const Account* ptr = &depo;      // ok!
ptr->display();                  // ok!
prt->setState( 7777.70);         // Error!Butptrcan only be used for read access to the non-constant object depo.Read-Only Pointers as Parameters
Read-only pointers are most commonly found in parameter lists. This guarantees thatarguments cannot be modified.Example:int strlen( const char *s);In this example, the parameter sis a read-only pointer. This allows you to pass constantC strings to the standard function strlen(). You cannot remove the “write protection”by assigning the read-only pointer sto a normal pointer.Example:char *temp = s;         // Error!You need to declare a read-only pointer if a constant object may be passed as an argu-
ment.
362CHAPTER 17ARRAYS AND POINTERS
// search1.cpp// A filter to output all lines containing a given// pattern. The function strstr() is called.// Call:    search1  [ < text.dat ]
// ----------------------------------------------------#include <iostream>using namespace std;#define MAXL  200              // Maximum length of linenamespace MyScope
{          // Self-defined version of function strstr():char *strstr( const char *str, const char *patt);}
char line[500],               // For a line of text.patt[] = "is";           // The search pattern.int main()
{  int lineNr = 0; // As long as a line is left over:while( cin.getline( line, MAXL)){++lineNr;if( MyScope::strstr( line, patt) != NULL){                       // If the pattern is found:cout.width(3);cout << lineNr << ": "   // Output the line<< line << endl;    // number and the line}}return 0;}// strstr.cpp// A self-defined version of the function strstr()// ---------------------------------------------------#include <string.h>       // For strlen() and strncmp()
namespace MyScope{char *strstr( const char *s1, const char *s2){             // To search for the string s2 within s1.int len = strlen( s2);
for( ; *s1 != '\0'; ++s1)if( strncmp( s1, s2, len) == 0)   // s2 found?return (char *)s1;    // Yes -> return pointer// to this position, orreturn NULL;               // else the NULL pointer.}}RETURNING POINTERSSample program

RETURNING POINTERS363A function can return a pointer to an object. This makes sense for a function thatsearches for a particular object, for example. Such a function will return either a pointer
to the required object or a NULL pointer if the object cannot be found.The standard C library functions often use pointers as return values. For example, thefunctionsstrcpy(),strcat(), and strstr()each return a pointer to the first char-acter in a C string.The Functions strcpy()andstrcat()In contrast to the example on the page entitled “Pointer versions of functions,” the stan-dard function strcpy()has a return value. The function returns its first argument, thatis, a pointer to the target string and leads to the following:Prototype:
char* strcpy( char* s1, const char* s2);The second parameter is a read-only pointer, since the source string is read-only.The standard function strcat()concatenates two C strings, adding the C stringpassed as the second argument to the first argument. When you call this function, make
sure that the chararray for the first string is large enough to store both strings. Thereturn value is the first argument. The following example shows one possible implemen-
tation.Example:char *strcat( char *s1, const char *s2 ){char *p = s1 + strlen(s1); // End of s1
strcpy(p, s2);
return s1;}Notes on the Sample Program
The program on the opposite page shows a self-defined version of the standard functionstrstr(). This version was placed in the MyScopenamespace to distinguish it fromthe standard function.The function strstr()searches for a given character sequence within a string. Thestandard function strncmp()is used to compare two strings. This function returns zeroif the first ncharacters are identical.The program uses the strstr()function to display all the lines in the text contain-ing the letters “is"with line numbers. The exercises for this chapter contain a programcalledsearch.cppwhere you can supply a search pattern.
364CHAPTER 17ARRAYS AND POINTERS
accPtr[0]"Novack,..",  1234,"Davis, ..", 2345,accPtr[1]accPtr[2]accPtr[3]accPtr[4]ArrayaccPtrAccount objects// The function displayError() outputs an error message// to a corresponding error number.// --------------------------------------------------#include <iostream>
using namespace std;void displayError ( int errorNr){staticchar* errorMsg[]= {"Invalid error number",
"Error 1: Too much data ","Error 2: Not enough memory ","Error 3: No data available "  };if( errorNr < 1 || errorNr > 3)errorNr = 0;cerr << errorMsg[errorNr] << endl;}A string literal, such as “Error..."is a charpointer to the first character in the string. Thus, such apointer can be used to initialize another charpointer.Due to its staticdeclaration, the array is generated only once and remains valid until the programends.NOTE
ARRAYS OF POINTERS
Pointers in the array 
accPtrSample function with pointers to char
ARRAYS OF POINTERS365Pointers offer various possibilities for simple and efficient handling of large amounts ofdata. For example, when you are sorting objects it makes sense to define pointers to those
objects and simply place the pointers in order, instead of rearranging the actual order of
the objects in memory.Defining Arrays of Pointers
Whenever you need a large number of pointers, you can define an array whose elementsare pointers. An array of this type is referred to as a pointer array.Example:Account* accPtr[5];The array accPtrcontains five AccountpointersaccPtr[0],accPtr[1], ... ,accPtr[4]. The individual pointers in the array can now be assigned object addresses.Any pointers not currently in use should have the value NULL.Example:Account save("Novack, Kim", 1111, 9999.90);Account depo("Davis, Sammy", 2222, 1000.);
accPtr[0] = &save;
accPtr[1] = &depo;
for( int i=2; i<5; ++i) accPtr[i] = NULL;Initialization
As usual, an initialization list is used to initialize the array. In the case of a pointer array,the list contains either valid addresses or the value NULL.Example:Account* accPtr[5] = { &depo, &save, NULL};The value NULL is automatically assigned to any objects for which the list does not con-
tain a value. This produces the same result as in the previous example.UsageThe individual objects addressed by the pointers in an array do not need to occupy acontiguous memory space. Normally these objects will be created and possibly destroyed
dynamically at runtime (this will be discussed in detail in a later chapter). This allows for
extremely flexible object handling. The order is defined only by the pointers.Example:for( int i=0; i<5; ++i)if( accPtr[i] != NULL)accPtr[i]->display();  // To outputThe function displayError()opposite displays the error message for a correspon-ding error number, using an array of charpointers to the error messages.
366CHAPTER 17ARRAYS AND POINTERS
"C:\...\HELLO.EXE""Vivi""Jeany"argv[0]argvargv[1]argv[2]NULL// hello.cpp// Demonstrates the command line arguments.// Call:  hello name1 name2// ----------------------------------------------------
#include <iostream>using namespace std;int main( int argc, char *argv[]){if( argc != 3 ){cerr << "Use: hello name1 name2" << endl;
return 1;}cout << "Hello " << argv[1] << '!' << endl;
cout << "Best wishes \n"<< "\tyours " << argv[2] << endl;return 0;}COMMAND LINE ARGUMENTS
Sample program
Example of calling the program:
hello Jeany ViviScreen output
Hello Jeany!Best wishesYours ViviArray 
argvin memory

COMMAND LINE ARGUMENTS367Arguments for a Program
When you launch a program, you can use the command line to supply additional charac-ter sequences other than the program name. These command line arguments are typicallyused to govern how a program is executed or to supply the data a program will work with.Example:copy file1 file2In this case, the program copyis launched with the arguments file1andfile2. Theindividual arguments are separated by spaces. Characters used for redirecting input and
output (>or<) and a following word are evaluated by the operating system and notpassed to the program. If an argument contains space or redirection characters, you must
place it in double quotes.Parameters of the Function 
main()So far we have only used the function main()without parameters. However, if youintend to process command line arguments, you must define parameters for main().Example:int main(int argc, char * argv[] ){   . . . // Function block   }argccontains the number of arguments passed via the command line. The programname is one of these, so argcwill have a value of at least 1.The parameter argvis an array of charpointers:argv[0]points to the program name (and path)argv[1]points to the first real argument, that is, the word after the pro-gram nameargv[2]points to the second argument.....argv[argc-1]points to the last argumentargv[argc]is the NULL pointerThe parameters are traditionally named argcandargvalthough any other name couldbe used.Various operating systems, for example WINDOWS 98/00/NT and UNIX, allow youto declare a third parameter for main(). This parameter is an array with pointers toenvironment strings. The exercises for this chapter contain a program that displays the
program environment.
exercises
368CHAPTER 17ARRAYS AND POINTERS
// strcmp() compares two C strings lexicographically.// Return value:       < 0, if str1 < str2
//                     = 0, if str1 == str2
//                     > 0, if str1 > str2 .
// ----------------------------------------------------int strcmp( const char str1[], const char str2[]){int i;
for( i=0; str1[i] == str2[i] && str1[i] != '\0'; ++i);return (str1[i] - str2[i]);}Original array:
After the first loop:After the second loop:smallest elementsecond smallest element10050303030401007050501007040
7040EXERCISESFor exercise 3
Index version of the standard function 
strcmp()Notes on exercise 4
The selection sort algorithm
MethodFirst find the smallest element in the array and exchange it with the first
element.This procedure is repeated while 
i > 0for the remainder of an array
containing array elements with an initial index of 
i.Example
EXERCISES369Exercise 1
Given an array 
vwith the following definition:
int v[] = { 10, 20, 30, 40 }, i, *pv;What screen output is caused by the following statements?
a.for( pv = v;  pv <= v + 3;  pv++ )cout << "      *pv = "  <<  *pv;b.for( pv = v, i = 1;  i <= 3;  i++ )cout << "    pv[i] = "  <<  pv[i];c.for( pv = v, i = 0;  pv+i <= &v[3];  pv++,i++)cout << "  *(pv + i) = "  <<  *(pv + i);d.for( pv = v + 3;  pv >= v;  --pv )cout << "     v["  <<  (pv - v)  <<  "] = "<< v[pv - v];Exercise 2
Write a program that uses the 
cinmethodget()to read a line character by
character and stores it in a 
chararray.The line is then output in reverse order.
Use a pointer,not an index,to address the array elements.
Exercise 3
The standard function 
strcmp()performs a lexicographical comparison of two
C strings.The opposite page contains an index version of 
strcmp().The return
value is the difference between two character codes.
Write a pointer version of the function 
strcmp().Call this function
str_cmp()to distinguish it from the standard function.
To test the function,use a loop to read two lines of text and output the
results of the comparison.The loop should terminate when both strings are

empty.
Exercise 4
Define and test the function selectionSort()that sorts an array of 
intvalues in ascending order.The principle of the selection sort algorithm is shown

opposite.
Arguments:Anintarray and its length
Return values:NoneDevelop both an index version and a pointer version.Test the functions with
random numbers between 
-10000and+10000.
370CHAPTER 17ARRAYS AND POINTERS
. . .COMSPEC=C:\COMMAND.COMPATH=C:\WINDOWS;C:\WINDOWS\COMMAND;C:\DOS;D:\TOOLS;
PROMPT=$p$gTEMP=C:\TEMP. . .Blood-pressureAge<120>= 160
120–12920–2930–3940–49251963427152624351211368418130–139140–149
Notes on exercise 5
Sample environment strings for DOS/Windows
Frequency table for exercise 7

EXERCISES371Exercise 5
a.Write a program that outputs its own name and all command line argu-
ments,each in a separate line.
b.Now extend the program to output its own environment.The environ-
ment is a memory area containing strings in the format
NAME=StringA third parameter for the function 
main()allows access to the environment.
This parameter is an array of pointers just like 
argv.The array elements are
charpointers to the environment strings,the last element being a NULL
pointer.
Exercise 6
A sample filter program called 
search1,which outputs lines and the relevant
line numbers for lines containing the search pattern 
"ei",was introduced in this
chapter.
Modify the program to produce a useful tool called 
search,to which you can
pass any search pattern via the command line.The program should issue an

error message and terminate if the command line does not contain a search

string.Use the standard function 
strstr().Sample call:search  Shanghai  < news.txtExercise 7
The following frequency was observed during an examination of the relationship

between age and blood pressure for 300 males.
Write a function that calculates the sums of the rows and columns in an 
intmatrix with three rows and five columns.Store the sums of the rows and

columns separately in a one-dimensional row or column array.
Arguments:The matrix,the row array,and the column array.
Return value:The sum of all the matrix elements.To test the function,output the matrix,as shown in the graphic opposite
along with the computed sums in your 
mainfunction.
solutions
372CHAPTER 17ARRAYS AND POINTERS
SOLUTIONSExercise 1
Screen Output:
a.*pv = 10      *pv = 20      *pv = 30      *pv = 40b.pv[i] = 20    pv[i] = 30    pv[i] = 40c.*(pv+i) = 10  *(pv+i) = 30d.v[3] = 40     v[2] = 30     v[1] = 20     v[0] = 10Exercise 2
// -------------------------------------------------------//reverse.cpp// Exercise on pointer arithmetic:// Reads a line and outputs the line in reverse order.// -------------------------------------------------------
#include <iostream>using namespace std;#define MAXLEN 80int main(){char line[MAXLEN], *p;cout << "Enter a line of text: " << endl;
// Input a line:for( p = line;p < line+MAXLEN  &&  cin.get(*p)  &&  *p != '\n';
++p );// Output the line in reverse order:while( --p >= line)cout << *p;cout << endl;return 0;}
SOLUTIONS373Exercise 3
// -------------------------------------------------------//str_cmp.cpp// Define and test the pointer version str_cmp()
// of the standard function strcmp().
// -------------------------------------------------------#include <iostream>using namespace std;
#define MAXLEN 100       // Maximum length of C strings// Prototype:int str_cmp( const char* str1, const char* str2);
int main()                            // Test str_cmp(){char text1[MAXLEN], text2[MAXLEN];
cout << "Testing the function str_cmp()" << endl;
while( true)
{cout << "Enter two lines of text!\n""End with two empty lines.\n" << endl;cout << "1. line: ";cin.sync();  cin.clear(); cin.get(text1,MAXLEN);
cout << "2. line: ";
cin.sync();  cin.clear(); cin.get(text2,MAXLEN);
if( text1[0] == '\0' && text2[0] == '\0')break;                    // Both lines empty.int cmp = str_cmp( text1, text2);if( cmp < 0)cout << "The 1st string is smaller!\n";else if( cmp == 0)cout << "Both strings are equal!\n";elsecout << "The 1st string is greater!\n";cout << endl;}
return 0;}// ------------------------------------------------------
// Function str_cmp()// Pointer version of the standard function strcmp().// ------------------------------------------------------
int str_cmp( const char* str1, const char* str2)
{for( ; *str1 == *str2 && *str1 != '\0'; ++str1, ++str2);return (*str1 - *str2);}
374CHAPTER 17ARRAYS AND POINTERS
Exercise 4
// -------------------------------------------------------//selSort.cpp// Implement the selection sort algorithm
// for int-arrays.
// -------------------------------------------------------#include <iostream>#include <iomanip>#include <cstdlib>           // For srand(), rand()#include <ctime>             // For time()
using namespace std;// Prototype:void selectionSort( int arr[], int len);const int len = 200;int intArr[len];            // int-arrayint main(){cout << "\n     ***  Selection Sort Algorithm  ***\n"<< endl;// To initialize an int-array with random numbers:srand( (unsigned int)time(NULL));  // Initialize the// random number generator.for( int n=0; n < len; ++n)intArr[n] = (rand() % 20000)-10000;// To sort the numbersselectionSort( intArr, len);// To output the numberscout << "The sorted numbers:" << endl;for( int i = 0; i < len; ++i)cout << setw(8) << intArr[i];cout << endl;return 0;}inline void swap( int& a, int& b){int temp = a;  a = b;  b = temp;}
SOLUTIONS375//  Index version:/*
void selectionSort( int arr[], int len){register int j, mini;            // Indicesfor( int i = 0;  i < len-1;  ++i){mini = i;                    // Search for minimumfor( j = i+1; j < len; ++j) // starting with index i.if( arr[mini] > arr[j])mini = j;swap( arr[i], arr[mini]);     // Swap.}}*/// Pointer version:void selectionSort( int *arr, int len){register int *p, *minp;   // Pointer to array elements,
int *last = arr + len-1;  // pointer to the last elementfor( ; arr < last;  ++arr){minp = arr;                     // Search for minimumfor( p = arr+1; p <= last; ++p) // starting with arrif( *minp > *p)minp = p;swap( *arr, *minp);             // Swap.}}
376CHAPTER 17ARRAYS AND POINTERS
Exercise 5
// -------------------------------------------------------//args.cpp// The program outputs the program name including the path,
// command line arguments and the environment.
// -------------------------------------------------------#include <iostream>using namespace std;int main( int argc, char *argv[], char *env[]){cout << "Program: " << argv[0] << endl;cout << "\nCommand line arguments:" << endl;int i;for( i = 1; i < argc; ++i)             // Argumentscout << argv[i] << endl;cout << "Type <Return> to go on";cin.get();cout << "\nEnvironment strings:" << endl;for( i = 0; env[i] != NULL; ++i)       // Environmentcout << env[i] << endl;return 0;}Exercise 6
// -------------------------------------------------------
//search.cpp// A filter that outputs all lines containing a certain
// pattern. The standard function strstr() is called.//// Call:    search  pattern [ < text.dat ]
//
// If no file name is passed the input is read from the// keyboard. In this case end input with <Ctrl> + <Z>.// ------------------------------------------------------
#include <iostream>#include <cstring>      // Standard functions for C stringsusing namespace std;
#define MAXL  200                // Maximum length of line
char line[500];                  // For a line of text.
SOLUTIONS377int main( int argc, char *argv[]){if( argc != 2){cerr << "Call:  search  pattern [ < text.dat ]"<< endl;return 1;}int lineNr = 0;// As long as a line exists:while( cin.getline( line, MAXL))
{++lineNr;if( strstr( line, argv[1]) != NULL)
{                         // If the pattern was found:cout.width(3);cout << lineNr << ": "       // Output the line<< line << endl;        // number and the line}}
return 0;}Exercise 7
// -------------------------------------------------------//matrix.cpp// To compute the sums of rows and columns in a matrix.// ------------------------------------------------------#include <iostream>#include <iomanip>using namespace std;// Define and initiate a two-dimensional array:
int matrix[3][5] = { { 25, 34, 26, 12,  8 },{ 19, 27, 24, 11,  4 },
{  6, 15, 35, 36, 18 } };int rowsum[3];               // For the sums of the rowsint colsum[5];               // For the sums of the columns// Prototype of function matrixsum():int matrixsum( int arr2D[][5], int vlen,int rsum[], int csum[]);
378CHAPTER 17ARRAYS AND POINTERS
int main(){cout << "Testing the function matrixsum().\n"<< endl;// Compute sums:int totalsum =matrixsum( matrix, 3, rowsum, colsum);// Output matrix and sums:cout << "The matrix with the sums "<< "of rows and columns:\n"
<< endl;int i,j;for( i = 0 ; i < 3 ; ++i)    // Output rows of the{                            // matrix with row sums.for( j = 0 ; j < 5 ; ++j)cout << setw(8) << matrix[i][j];cout << " | " << setw(8) << rowsum[i] << endl;}
cout << "  -------------------------------------------"<< endl;for( j = 0 ;  j < 5  ;  ++j )cout << setw(8) << colsum[j];cout << " | " << setw(8) << totalsum << endl;return 0;}// --------------------------------------------------------int matrixsum( int v[][5], int len,int rsum[], int csum[]){  int ro, co;                      // Row and column indexfor( ro = 0 ; ro < len ; ++ro)    // To compute row sums{rsum[ro] = 0;for( co = 0 ; co < 5 ; ++co)rsum[ro] += v[ro][co];}for(co = 0 ; co < 5 ; ++co)       // Compute column sums{csum[co] = 0;for( ro = 0 ; ro < len ; ++ro)csum[co] += v[ro][co];}
return (rsum[0] + rsum[1] + rsum[2]);  // Total sum =}                                       // sum of row sums.
379Fundamentals of File
Input and OutputThis chapter describes sequential file access using file streams.File
streams provide simple and portable file handling techniques.
chapter
18
380CHAPTER 18FUNDAMENTALS OF FILE INPUT AND OUTPUT
Main MemoryExternal Memory
Write
ReadFileFile Buffer
FILESFile operations

FILES381When a program is terminated, the program data stored in main memory is lost. To storedata permanently, you need to write that data to a file on an external storage medium.File Operations
Single characters or character strings can be written to text files just like they can be out-put on screen. However, it is common practice to store records in files. A record contains
data that forms a logical unit, such as the human resource information for a person. A
write operation stores a record in a file, that is, the existing record in the file is updated ora new record is added. When you reada record, this record is taken from the file andcopied to the data structure of a program.Objects can be put into permanent storage using similar techniques. However, thisnormally involves more than just storing an object’s data. You also need to ensure that
the object can be correctly reconstructed when it is read, and this in turn involves stor-
ing type information and references to other objects.External mass storage media, such as hard disks, are normally block-oriented—that is,data is transferred in blocks whose size is a multiple of 512 bytes. Efficient and easy file
management thus implies putting the data you need to store into temporary storage in
main memory, in a so-called file buffer.File Positions
From the viewpoint of a C++ program, a file is simply a long byte array. The structure ofthe file, using records for example, is entirely the programmer’s responsibility, allowing
for a maximum degree of flexibility.Every character in a file occupies a byte position. The first byte occupies position 0,the second byte position 1, and so on. The current file position is the position of the bytethat will be read or written next. Each byte that is transferred automatically increases the
current file position by 1.In the case of sequential access, the data is read or written byte by byte in a fixed order.The first read operation starts at the beginning of the file. If you need access to some
piece of information in a file, you must read the file content from start to finish. Write
operations can create a new file, overwrite an existing file, or append new data to an
existing file.Easy access to given data in a file implies being able to set the current file position asrequired. This technique is known as random file access and will be discussed in one of thefollowing chapters.
382CHAPTER 18FUNDAMENTALS OF FILE INPUT AND OUTPUT
iosistreamostreamiostreamofstreamifstreamfstreamFILE STREAMSStream classes for file access

FILE STREAMS383C++ provides various standard classes for file management. These so-called file streamclassesallow for easy file handling. As a programmer you will not need to concern your-self with file buffer management or system specifics.Since the file stream classes have been standardized, you can use them to developportable C++ programs. One program can thus process files on a Windows NT or UNIX
platform. You simply need to recompile the program for each platform you use.The File Stream Classes in the 
iostreamLibrary
The class hierarchy on the opposite page shows that the file stream classes contain thestream classes, with which you are already familiar, as base classes:theifstreamclass derives from the istreamclass and allows file readingtheofstreamclass derives from the ostreamstream class and supports writingto filesthefstreamclass derives from the iostreamstream class. As you wouldexpect, it supports both read and write operations for files.The file stream classes are declared in the fstreamheader file. An object thatbelongs to a file stream class is known as a file stream.FunctionalityThe file stream classes inherit the functionality of their base classes. Thus, the methods,operators, and manipulators you have already used for cinandcoutare also availablehere. Thus every file stream has:methods for non-formatted writing and reading of single characters and/or data
blocksthe operators <<or>>for formatted reading and writing from or to filesmethods and manipulators for formatting character sequencesmethods for state queries.File handling methods, particularly methods for opening and closing files, round off thepackage.
384CHAPTER 18FUNDAMENTALS OF FILE INPUT AND OUTPUT
// showfile.cpp// Reads a text file and outputs it in pages,// i.e. 20 lines per page.
// Call:  showfile  filename// ----------------------------------------------------#include <iostream>#include <fstream>using namespace std;int main( int argc, char *argv[]){if( argc != 2 )              // File declared?
{cerr << "Use: showfile filename" << endl;return 1;}ifstream file( argv[1]);// Create  a file stream// and open for reading.if( !file ) // Get status.{cerr << "An error occurred when opening the file "<< argv[1] << endl;return 2;}char line[80];int cnt = 0;while( file.getline( line, 80))// Copy the file{                                 // to standardcout << line << endl;           // output.if( ++cnt == 20)
{cnt = 0;cout << "\n\t ---- <return> to continue ---- "<< endl;cin.sync(); cin.get();}}if( !file.eof() )// End-of-file occurred?{cerr << "Error reading the file "<< argv[1] << endl;return 3;}return 0;}CREATING FILE STREAMS
Sample program

CREATING FILE STREAMS385Opening a FileYou need to open a file before you can manipulate it. To do so, you canstate the file name,which can also contain a pathdefine a so-called file access mode.If the path is not explicitly stated, the file must be in the current directory. The fileaccess mode specifically defines whether read and/or write access to the file is permitted.Any files still open when a program terminates are automatically closed.File Stream Definition
You can open a file when you create a file stream—you simply state the file name to doso. In this case default values are used for the file access mode.Example:ifstream myfile("test.fle");The file name test.fleis passed to the constructor of the ifstreamclass, whichopens the file for reading. Since the path was not stated, the file must be in the current
directory. When a file is opened, the current file position is the beginning of the file.If you create a file stream for write-only access, the file you state need not exist. Inthis case a new file is created.Example:ofstream yourfile("new.fle");This statement creates a new file called new.fleand opens the file for writing. But becareful! If the file already exists, it will be truncated to a length of zero bytes, or in other
words deleted.You can create a file stream which does not reference a specific file and use theopen()method to open a file later.Example:ofstream yourfile;yourfile.open("new.fle");This example has the same effect as the previous example. More specifically, open()uses the same default values for file access when opening a file as the default constructorfor the class.It rarely makes sense to use fixed file names. In the case of the sample program on theopposite page, you state the file name in the command line when you launch the pro-
gram. If no file name is supplied, the program issues an error message and terminates.
Using interactive user input is another possible way to define a file name.
386CHAPTER 18FUNDAMENTALS OF FILE INPUT AND OUTPUT
ios::inios::outios::appios::trunc
ios::ateios::binaryFlagEffects
Opens an existing file for input.Opens a file for output at the end-of-file.Perform input and output in binary mode.An existing file is truncated to zero length.Open and seek to end immediately after opening.Without this flag, the starting position after opening is
always at the beginning of the file.Opens a file for output. This flag implies
ios::trunc if it is not combined with one of theflagsios::in or ios::app or ios::ate.ifstreamofstreamfstreamios::inios::out | ios::truncios::in | ios::outClassFlags
1.These flags are defined in the baseclass 
ios,which is common to all stream classes,and
are of the 
ios::openmodetype.
2.By default a file is opened as a 
text file
in so-called text mode.When you read from or
write to a text file,control characters to indicate newlines or the end-of-file are inter-

preted separately and adapted to the current platform (so-called “cooked mode”).When

a file is opened in binary mode,the file contents are left unchanged (the so called “raw

mode”).NOTE
OPEN MODESFlags for the open mode of a fileDefault settings when opening a fileThe constructor and the method open()of all stream classes use the following defaultvalues:
OPEN MODES387To open a file in any but the default mode, you must supply both the file name and theopen mode. This is necessary, for example, to open an existing file for write access with-
out deleting the file.Open Mode FlagsIn addition to the file name, you can pass a second argument for the open mode to theconstructors and the open()method. The open mode is determined by using flags. Aflagrepresents a single bit in a computer word. If the flag is raised, the bit in question willcontain the value 1, with 0 representing all other cases.You can use the bit operator, |, to combine various flags. Either the flag ios::inorios::outmust be stated in all cases. If the flag ios::inis raised, the file must alreadyexist. If the flag ios::inis not used, the file is created, if it does not already exist.Example:fstream addresses("Address.fle",ios::out | ios::app);
This opens a file for writing at end-of-file. The file is created, if it does not already exist.
The file will automatically grow after every write operation.You can use the default mode for the fstreamclass, that is, ios::in|ios::out,to open an existing file for reading and writing. This so-called update mode is used for
updating the information in a file and is often seen in conjunction with random file
access.Error Handling
Errors can occur when opening a file. A user may not have the required access privileges,or the file you want to read may not exist. The state flag failbitof the iosbase classis raised in this case. The flag can either be queried directly using the fail()method,or indirectly by querying the status of a file stream in an ifcondition.Example:if( !myfile)          // or: if( myfile.fail())Thefailbit is also set if a read or write error occurs. If a read operation fails, the endof the current file may have been reached. To distinguish this normal behavior from a
read error, you can use the eof()method (eof = end-of-file) to query the eofbit:Example:if( myfile.eof())     // At end-of-file?Theeofbit is set if you try to carry on reading at the end of a file. The sample programon the previous page illustrates the potential issues.
388CHAPTER 18FUNDAMENTALS OF FILE INPUT AND OUTPUT
//fcopy1.cpp:  Copies files.// Call: fcopy1  source  [ destination ]// ----------------------------------------------------
#include <iostream>#include <fstream>using namespace std;inline void openerror( const char *file){cerr << "Error on opening the file " << file << endl;
exit(1);// Ends program closing}                         // all opened files.void copy( istream& is, ostream& os);    // Prototypeint main(int argc, char *argv[]){if( argc < 2 || argc > 3){  cerr << "Call: fcopy1 source [ destination ]"<< endl;return 1;                      // or: exit(1);}
ifstream infile(argv[1]);         // Open 1st fileif(!infile.is_open())openerror( argv[1]);if( argc == 2)               // Just one sourcefile.copy( infile, cout);else                         // Source and destination{ofstream outfile(argv[2]);     // Open 2nd fileif(!outfile.is_open())openerror( argv[2]);copy( infile, outfile);outfile.close();// Unnecessary.}
infile.close();// Unnecessary.return 0;}void copy( istream& is, ostream& os)  // Copy it to os.{char c;while( is.get(c) )os.put(c);                  // or:  os << c ;}CLOSING FILESSample program

CLOSING FILES389Motivation
After you have completed file manipulation, the file should always be closed for the fol-lowing reasons:data may be lost, if for some reason the program is not terminated correctlythere is a limit to the number of files that a program can open simultaneously.A program that terminates correctly will automatically close any open files before exit-ing. A file stream destructor will also close a file referenced by a stream. However, if the
file is no longer in use before this point, you should close the file explicitly.Methodsclose()andis_open()Each of the file stream classes contains a definition of a voidtype method calledclose(), which is used to close the file belonging to the stream.Example:myfile.close();However, the file stream continues to exist. It is therefore possible to use the streamto open and manipulate another file.If you are not sure whether a file stream is currently accessing a file, you can alwaysperform a test using the is_open()method . In the case of the myfilefile stream, thetest is as follows:Example:if( myfile.is_open() ){ /* . . . */ }            // File is openTheexit()FunctionOpen files are also closed when you call the global function exit(). The actual reasonfor using this function is to terminate a program in an orderly manner and return an error
code to the calling process.Prototype:
void exit( int status );The calling process, to which the statuserror code is passed for evaluation, willoften be the command interpreter—a Unix shell, for example. Successful program execu-
tion normally produces the error code 0. The statement return n;is thus equivalentto the statement exit(n);when used in the main()function.The program on the opposite page copies a file stated in the command line. If the userforgets to state a second (target) file, the source file is copied to standard output. In this
case, the source file will need to be a text file.
390CHAPTER 18FUNDAMENTALS OF FILE INPUT AND OUTPUT
// Pizza_W.cpp// Demonstrating output of records block by block.// ---------------------------------------------------
#include <iostream>#include <fstream>using namespace std;char header[] ="    * * *  P I Z Z A  P R O N T O  * * *\n\n";
// Record structure:struct Pizza { char name[32];  float price; };const int MAXCNT = 10;
Pizza pizzaMenu[MAXCNT] ={{ "Pepperoni", 9.90F },    { "White Pizza", 15.90F },
{ "Ham Pizza", 12.50F }, { "Calzone", 14.90F } };int cnt = 4;char pizzaFile[256] = "pizza.fle";int main()                       // To write records.{cout << header  << endl;// To write data into the file:int exitCode = 0;ofstream outFile( pizzaFile, ios::out|ios::binary );
if( !outFile){cerr << "Error opening the file!" << endl;exitCode = 1;}
else{for( int i = 0; i < cnt; ++i)if(!outFile.write( (char*)&pizzaMenu[i],sizeof(Pizza))){  cerr << "Error writing!" << endl;exitCode = 2;}}if( exitCode == 0)cout << "\nData has been added to file "<< pizzaFile << "\n" << endl;return  exitCode;}READING AND WRITING BLOCKS
Sample program

READING AND WRITING BLOCKS391The file stream classes can use all the publicoperations defined in their base classes.This means you can write formatted or unformatted data to a file or read that data from
the file block by block or character by character.Formatted and Unformatted Input and Output
The previous sample programs illustrated how to use the methods get(),getline(),andput()to read or write data from or to text files. Formatted input and output ofnumerical values, for example, requires the >> and << operators and appropriate manip-
ulators or formatting methods.Example:double price = 12.34;ofstream textFile("Test.txt");
textFile << "Price: " << price << "Dollar" << endl;The file Test.txtwill contain a line of text, such as "Price ... "that exactlymatches the screen output.Converting binary data to legible text is not practicable if you are dealing with largeamounts of data. It makes sense to write the data for a series of measurements to a binary
file in the order in which they occur in the program. To do so, you simply open the file
in binary mode and write the data to the file, or read it from the file, block by block.Transferring Data Blocks
Theostreammethodwrite()transfers given number of bytes from main memory to afile.Prototype:
ostream& write( const char *buf, int n);Sincewrite()returns a reference to the stream, you can check to ensure that the writeoperation was successful.Example:if( ! fileStream.write("An example ", 2) )cerr << "Error in writing!" << endl;A warning is issued if an error occurs while writing the characters "An". You can use theread()method to read data blocks from the file. The method transfers a data blockfrom a file to a program buffer.Prototype:
istream& read( char *buf, int n);The methods read()andwrite()are often used for files with fixed length records.The block that needs to be transferred can contain one or more records. The buffer in
main memory is either a structure variable or an array with elements belonging to the
structure type. You need to cast the address of this memory area to (char *)as shownin the example opposite.
392CHAPTER 18FUNDAMENTALS OF FILE INPUT AND OUTPUT
// Class Account with methods read() and write()// ---------------------------------------------------class Account
{private:string name;             // Account holderunsigned long nr;        // Account numberdouble balance;          // Balance of accountpublic:. . .   // Constructors, destructor,// access methods, ...ostream& Account::write(ostream& os) const;
istream& Account::read(istream& is)};// write() outputs an account into the given stream os.// Returns: The given stream.ostream& Account::write(ostream& os) const{os << name << '\0';         // To write a stringos.write((char*)&nr, sizeof(nr) );os.write((char*)&balance, sizeof(balance) );return os;}// read() is the opposite function of write().// read() inputs an account from the stream is
// and writes it into the members of the current objectistream& Account::read(istream& is){getline( is, name, '\0');   // Read a stringis.read( (char*)&nr, sizeof(nr) );is.read( (char*)&balance, sizeof(balance));return is;}OBJECT PERSISTENCEClass AccountImplementing methods read()andwrite()
OBJECT PERSISTENCE393Storing ObjectsObjects are created during program runtime and cleaned up before the program termi-nates. To avoid this volatility, you can make an object persistent, that is, you can storethe object in a file. However, you must ensure that the object can be reconstructed, as it
was, when read. This means dealing with the following issues:Objects can contain other objects. You will generally not know how to store a
member object.Objects can contain references to other objects. However, it does not make sense
to store pointer values in a file, as the memory addresses will change each time
you re-launch the program.For example, the class Accounton the opposite page contains the member objectname, which is a stringtype. As stringtype objects are used to handle variablelength strings, the object just contains a reference to the string. It therefore makes no
sense to save the memory content of size sizeof(name)occupied by the object namein a file. Instead, you should write the string itself to a file.One possible solution to this issue is to store the data to allow them to be passed to aconstructor for the class when read. Another solution involves providing methods to
allow the objects to write their own data members to files or read them from files. This
technique is normally preferable since the class can now handle data storage itself, allow-
ing it to write internal status data while simultaneously preventing external access to
that data.Storing Account Class Objects
The opposite page shows the Accountclass, with which you are already familiar. Fileinput and output methods have been added to the class. A file stream that references a
file opened in binary mode is passed as an argument to the methods read()andwrite(). The return value is the stream in both cases, so the status can be queriedwhen the function is called.Example:if( ! anAccount.write( outFile) )cerr << "Error in writing!" << endl;When you read an account, you can simultaneously create an empty object that theread()method can access.Example:if( ! anAccount.read( inFile) )cerr << "Error in reading!" << endl;The member object nameis saved as a C string, that is, as a string terminated by the nullcharacter,'\0'. The <<operator and the function getline()are available for thistask.
exercises
394CHAPTER 18FUNDAMENTALS OF FILE INPUT AND OUTPUT
fcopy file1 file2A file,
file1,is copied to 
file2.If 
file2already exists,it is overwritten.
fcopy file1A file,
file1,is copied to standard output,that is,to the screen if
standard output has not been redirected.
fcopyFor calls without arguments,the source and destination files are entered

in a user dialog.Ifisis a file stream that references a file opened for reading,the
following call
Example:char buf[1024];is.read(buf, 1024);transfers the next 1024 bytes from file to the buffer 
buf.Provided that no
error occurs,no less than 1024 bytes will be copied unless end-of-file is

reached.In this case the 
failandeofbits are set.The last block of bytes
to be read also has to be written to the destination file.The method
gcount()returns the number of bytes transferred by the last read
operation.Example:int nread = is.gcount();    // Number of bytes// in last read op.EXERCISESFor exercise 1
Possible calls to the program 
fcopy:More details on the istream class method 
read()
EXERCISES395Exercise 1
The sample program 
fcopy1,which copies a file to the screen or to a second
file,was introduced in this chapter.Write a program named 
fcopyto enhancefcopy1as follows:
If the program is launched without any arguments,it does not issue an

error message and terminate but requests user input for the names of the

source and target files.If an empty string is given as the name of the tar-

get file,that is,the Return key is pressed,the source file is displayed on

screen.
If the command line or the user dialog contains valid source and target

file names,a 
binary 
copy operation is performed.
Copy the data block by block with the 
read()andwrite()methods.The default block size is 1024 bytes.
Thecopy()function returns 
falseif an error occurs while copying and
truein all other cases.Also refer to the notes on the opposite page.
Exercise 2
a.Modify the sample program 
Pizza_w.cppin this chapter to allow the
user to add new pizza records to the four standard pizzas and store

these records on file.
b.Then write a program called 
Pizza_r.cpp,which displays the pizza
menu,that is,outputs the contents of the pizza file.
Exercise 3
Test the methods 
read()andwrite()in the Accountclass.To do so,write a
program called 
Account_rw.cppthatinitializes an array with account objects and stores the array in a file
reads the contents of the file to a second array and displays the accounts

in that array to allow you to check them.
Use binary mode for read or write access to the file.

396CHAPTER 18FUNDAMENTALS OF FILE INPUT AND OUTPUT
New data members:
stringfilename;// File namebooldirty;// true, if data is not// stored yet.New methods:
const string& getFilename() const;boolsetFilename( const string& fn);boolisDirty() const;boolload();     // Read data from the fileboolsave();     // Save data.boolsaveAs();   // Save data as ...* * * * *  Telephone List  * * * * *S = Show all entriesF = Find a telephone numberA = Append an entryD = Delete an entry-----------------------------------------O = Open a file
W = Save in the fileU = Save as ...-----------------------------------------
Q = Quit the programYour choice:For Exercise 4
New members of class 
TelListExtended menu of the application program

EXERCISES397Exercise 4
The program 
TelList,which was written as an exercise for Chapter 16,needs
to be modified to allow telephone lists to be saved in a file.
To allow this,first add the data members and methods detailed on the
opposite page to TelList.The string 
filenameis used to store the name of
the file in use.The dirty flag is raised to indicate that the phone list has been

changed but not saved.You will need to modify the existing methods 
append()anderase()to provide this functionality.
The strings in the phone list must be saved as C strings in a binary file,
allowing for entries that contain several lines.
Add the following items to the application program menu:
O = Open a fileRead a phone list previously stored in a file.
W = SaveSave the current phone list in a file.
U = Save as . . .Save the current phone list in a new file.
Choosing one of these menu items calls one of the following methods as
applicable:
load(),save()
orsaveAs().These methods return 
truefor a
successful action and falseotherwise.The user must be able to supply a file
name for the 
save()method,as the list may not have been read from a file
previously.
If the phone list has been modified but not saved,the user should be
prompted to save the current phone list before opening another file or

terminating the program.

solutions
398CHAPTER 18FUNDAMENTALS OF FILE INPUT AND OUTPUT
SOLUTIONSExercise 1
// ----------------------------------------------------//fcopy.cpp// Copy files
// Call: fcopy  [ source  [ destination ] ]
// ----------------------------------------------------
#include <iostream>
#include <fstream>
using namespace std;char usage[] = "Call: fcopy [source [destination]}";
inline void openerror( const char *file){cerr << "Error opening the file " << file << endl;
exit(1);}bool copy( istream& is, ostream& os),    // Prototype,ok = true;                          // ok flag.int main(int argc, char *argv[]){char source[256] = "", dest[256] = "";switch( argc ){case 1:                      // No file declared// ==> input file name.cout << "Copying source file to ""destination file!\n"
"Source file: ";cin.getline( source, 256);
if( strlen(source) == 0)
{ cerr << "No source file declared!" << endl;return 1;}
cin.sync();                  // No previous input
cout << "Destination file: ";
cin.getline( dest, 256);
break;case 2:                         // One file is declared.strcpy( source, argv[1]);
break;case 3:    // Source and destination files are declared.strcpy( source, argv[1]);
strcpy( dest, argv[2]);
break;
SOLUTIONS399default:             // Invalid call to the program.cerr << usage << endl;
return 2;                // or: exit(2);}if( strlen(dest) == 0)      // Only source file?{                           // yes ==> output to cout.ifstream infile(source);
if( !infile )openerror( source);ok = copy( infile, cout);
// The file is closed by the ifstream destructor.}
else                        // Copy source to destination
{                           // file in binary mode.ifstream infile( source, ios::in | ios::binary);
if( !infile )openerror( source);else{ofstream outfile( dest, ios::out | ios::binary);
if( !outfile)openerror( dest);ok = copy( infile, outfile);
if( ok)cerr << "File " << source << " to file "<< dest <<" copied!"<< endl;}}
if(!ok)
{  cerr << "Error while copying!" << endl;return 3;}
return 0;}bool copy( istream& is, ostream& os)  // To copy{                                     // is to os.const int BufSize = 1024;
char buf[BufSize];
do
{is.read( buf, BufSize);
if( is.gcount() > 0)os.write(buf, is.gcount());}
while( !is.eof() && !is.fail() && !os.fail() );
if( !is.eof() ) return false;
else            return true;}
400CHAPTER 18FUNDAMENTALS OF FILE INPUT AND OUTPUT
Exercise 2
// ----------------------------------------------------//Pizza.h// Header file for Pizza_W.cpp and Pizza_R.cpp.
// ----------------------------------------------------
#include <iostream>#include <iomanip>#include <fstream>
using namespace std;// Structure of a record:struct Pizza {  char  name[32];  float price;  };
#define MAXCNT     20           // Maximum number of pizzas#define FILENAME  "pizza.fle"inline void header(){cout << "      * * *  P I Z Z A  P R O N T O  * * *\n\n"<< endl;}// ----------------------------------------------------//Pizza_w.cpp// Demonstrating blockwise writing of records.// ----------------------------------------------------
#include "Pizza.h"Pizza pizzaMenu[MAXCNT] ={{ "Pepperoni", 9.90F },  { "White Pizza", 15.90F },
{ "Ham Pizza", 12.50F }, { "Calzone", 14.90F } };int  cnt = 4;char pizzaFile[256] = FILENAME;int main()                         // Write records.{int i;header();
cout << "\nOur standard offer:\n" << endl;
cout << fixed << setprecision(2);for( i = 0; i < cnt; ++i)cout << setw(20) << pizzaMenu[i].name<< setw(10) << pizzaMenu[i].price << endl;cout << "\n-----------------------------------------\n"<< endl;
SOLUTIONS401// Input more pizzas via keyboard:while( cnt < MAXCNT)
{cin.sync(); cin.clear();cout << "What pizza should be added "<< "to the menu?\n\n" << "Name:  ";cin.getline( pizzaMenu[cnt].name, 32);if( pizzaMenu[cnt].name[0] == '\0')break;cout << "Price: ";cin >> pizzaMenu[cnt].price;if( !cin)cerr << "Invalid input!" << endl;else++cnt;if( cnt < MAXCNT)cout << "\n... and the next pizza!\n"<< "Stop with <Return>.\n";}// Add data to the file:int exitCode = 0;
ofstream outFile( pizzaFile, ios::out | ios::binary);if( !outFile){cerr << "Error opening the file!" << endl;
exitCode = 1;}else
{for( int i = 0; i < cnt; ++i)if( !outFile.write( (char*)&pizzaMenu[i],sizeof(Pizza)) ){cerr << "Error writing to file!"<< endl;exitCode = 2;}}
if( exitCode == 0)cout << "\nData added to file " << pizzaFile<< ".\n" << endl;return exitCode;}
402CHAPTER 18FUNDAMENTALS OF FILE INPUT AND OUTPUT
// ----------------------------------------------------//Pizza_r.cpp// Demonstrating block by block reading of records.// ---------------------------------------------------#include "Pizza.h"
char pizzaFile[256] = FILENAME;
int main()              // Read and display records.{header();ifstream inFile( pizzaFile, ios::in | ios::binary);if( !inFile)
{cerr << "Pizza file does not exist!" << endl;
return 1;}Pizza onePizza;int cnt = 0;cout << "\n-------------------------------------------"<< "\nThe available pizzas:\n" << endl;cout << fixed << setprecision(2);while( true)if( !inFile.read( (char*)&onePizza, sizeof(Pizza)) )break;else{cout << setw(20) << onePizza.name<< setw(10) << onePizza.price << endl;++cnt;}cout << "\n------------------------------------------\n"<< endl;if( !inFile.eof()){cerr << "Error reading file!" << endl;return 2;}elsecerr << "These are " << cnt << " pizzas!\n" << endl;return 0;}
SOLUTIONS403Exercise 3
// -------------------------------------------------------//Account_rw.cpp// Writes an array with objects of class Account to
// a file and feed the array into another array.
// -------------------------------------------------------#include "Account.h"     // Definition of the class Account#include <iostream>#include <fstream>using namespace std;Account AccTab1[3] ={Account("Lucky, Luke", 707070, -1200.99),
Account("Mickey, Mouse", 123000, 2500.0),
Account("Snoopy, Dog\n"        // String can contain more"Cell #: 01771234567", 543001)  // than one line.};Account AccTab2[3];     // Calls to default constructor
int cnt = 3;char file[] = "account.fle";int main(){int i = 0;// --- Write accounts to file ---ofstream outFile( file, ios::out | ios::binary );if( ! outFile){cerr << "Error opening file " << file<< endl;return 1;}for( i = 0; i < cnt; ++i)if( !AccTab1[i].write(outFile) )
{cerr << "Error writing to file " << file<< endl;return 2;}outFile.close();
404CHAPTER 18FUNDAMENTALS OF FILE INPUT AND OUTPUT
// --- Reads accounts from file ---ifstream inFile( file, ios::out | ios::binary );if( ! inFile){cerr << "Error opening file " << file<< endl;return 3;}for( i = 0; i < cnt; ++i)if( !AccTab2[i].read(inFile) )
{cerr << "Error reading file " << file<< endl;return 4;}inFile.close();// --- Displays the accounts read ---cout << "The file " << file << " contains the "<< "following accounts:" << endl;for( i = 0; i < cnt; ++i)AccTab2[i].display();cout << endl;return 0;}Exercise 4
// -------------------------------------------------------
//telList.h// A class TelList to represent a list// containing names and telephone numbers.// The methods load(), save(), and saveAs() serve for
// loading and saving a telephone list.// --------- ---------------------------------------------#ifndef _TelList_#define _TelList_#include <string>using namespace std;#define PSEUDO -1          // Pseudo position#define MAX 100            // Maximum number of elements
SOLUTIONS405// Type of a list element:struct Element { string name, telNr; };class TelList{private:Element v[MAX];        // The array and the actualint count;             // number of elements.string filename;       // File namebool dirty;            // true if data has been changed// but not yet saved.public:TelList() : count(0), filename(""), dirty(false)
{}int getCount() { return count; }
Element *retrieve( int i ){return (i >= 0 && i < count)? &v[i] : NULL;}bool append( const Element& el )
{return append( el.name, el.telNr);}
bool append( const string& name, const string& telNr);bool erase( const string& name);int  search( const string& name) const;void print() const;int  print( const string& name) const;
int  getNewEntries();const string& getFilename() const { return filename; }bool setFilename( const string& fn){  if( fn.empty()return false;else { filename = fn;  dirty = true; return true; }}bool isDirty() const { return dirty; }bool load();bool save();
bool saveAs();};#endif  // _TelList_// -------------------------------------------------------//TelList.cpp// Implements the methods of class TelList.// -------------------------------------------------------#include "telList.h"      // Definition of class TelList
#include <iostream>
#include <iomanip>
#include <fstream>
using namespace std;
406CHAPTER 18FUNDAMENTALS OF FILE INPUT AND OUTPUT
bool TelList::append( const string& name,const string& telNr){if( count < MAX                 // Any space&& name.length() > 1        // minimum 2 characters
&& search(name) == PSEUDO)  // does not exist{v[count].name  = name;
v[count].telNr = telNr;
++count;
dirty = true;
return true;}
return false;}bool TelList::erase( const string& key ){int i = search(key);
if( i != PSEUDO )
{if( i != count-1)            // Copy the last elementv[i] = v[count-1];       // to position i.--count;dirty = true;
return true;}
return false;}
// --------------------------------------------------
// Methods search(), print(), getNewEntries()
// are unchanged (refer to solutions of chapter 16).
// --------------------------------------------------// Methods for loading and saving the telephone list.
bool TelList::load(){cout << "\n--- Load the telephone list "<< "from a file. ---" << "\nFile: ";string file;                      // Input file name.cin.sync(); cin.clear();          // No previous input
getline( cin, file);
if( file.empty())
{cerr << "No filename declared!" << endl;
return false;}
SOLUTIONS407// Open the file for reading:ifstream infile( file.c_str(), ios::in | ios::binary);
if( !infile ){cerr << "File " << file<< " could not be opened!" << endl;return false;}
int i = 0;while( i < MAX){getline( infile, v[i].name, '\0');
getline( infile, v[i].telNr, '\0');
if( !infile)break;else++i;}
if( i == MAX)cerr << "Max capacity " << MAX<< " has been reached!" << endl;else if( !infile.eof()){cerr << "Error reading file " << file << endl;
return false;}count = i;filename = file;
dirty = false;return true;}bool TelList::saveAs(){cout << "-- Save the telephone list in a file. --"<< "\nFile: ";string file;                    // Input file name.cin.sync(); cin.clear();        // No previous input
getline( cin, file);if( !setFilename(file)){cerr << "No file name declared!" << endl;return false;}
elsereturn save();}
408CHAPTER 18FUNDAMENTALS OF FILE INPUT AND OUTPUT
bool TelList::save()      // Save the telephone list.{if( filename.empty())return saveAs();if( !dirty)return true;ofstream outfile( filename.c_str(),ios::out | ios::binary);if( !outfile ){cerr << "File " << filename<< " could not be opened!" << endl;return false;}int i = 0;while( i < count)
{outfile << v[i].name  << '\0';
outfile << v[i].telNr << '\0';
if( !outfile)break;else++i;}if( i < count){cerr << "Error writing to file " << filename << endl;return false;}dirty = false;return true;}// -------------------------------------------------------//TelList_.cpp// Organize a telephone list with class TelList.// -------------------------------------------------------#include "telList.h"      // Definition of class TelList#include <iostream>#include <string>#include <cctype>
using namespace std;inline void cls(){cout << "\033[2J\n"; // If ANSI control characters are}                       // not available, output new-lines.
SOLUTIONS409inline void go_on(){cout << "\n\nGo on with return! ";cin.sync();  cin.clear();        // No previous inputwhile( cin.get() != '\n');}int menu();               // Enter a command
char askForSave();        // Prompt user to save.char header[] ="\n\n          * * * * *  Telephone List  * * * * *\n\n";
TelList myFriends;       // A telephone listint main(){int action = 0;        // Commandstring name;           // Read a namewhile( action != 'Q')
{action = menu();cls();  cout << header << endl;
switch( action)
{// ---------------------------------------------------//   case 'S':  case 'F':  case 'A':  case 'D':
//   unchanged (refer to the solutions of chapter 16).// ---------------------------------------------------case 'O':                      // To open a fileif(myFriends.isDirty() && askForSave() == 'y')myFriends.save();if( myFriends.load())cout << "Telephone list read from file "<< myFriends.getFilename() <<"!"<< endl;elsecerr << "Telephone list not read!"<< endl;go_on();
break;case 'U':                      // Save as ...if( myFriends.saveAs())cout << "Telephone list has been saved in file: "<< myFriends.getFilename() << " !" <<endl;elsecerr << "Telephone list not saved!" << endl;go_on();break;
410CHAPTER 18FUNDAMENTALS OF FILE INPUT AND OUTPUT
case 'W':                      // Saveif( myFriends.save())cout << "Telephone list has been saved in "<< "the file "
<< myFriends.getFilename() << endl;elsecerr << "Telephone list not saved!"<< endl;go_on();
break;case 'Q':                     // Quitif( myFriends.isDirty()  &&  askForSave() == 'Y')myFriends.save();cls();break;}} // End of while
return 0;}int menu(){static char menuStr[] =// . . ."\n             -------------------------------------"
"\n             O = Open a file""\n             W = Save ""\n             U = Save as ..."
"\n             -------------------------------------"
"\n             Q = Quit the program""\n\n Your choice:  ";// ---------------------------------------------------// everything else unchanged (cf. solutions in Chapter 16)
// ---------------------------------------------------return choice;}char askForSave(){char c;
cout <<  "Do you want to save the phone list(y/n)? ";
do{   cin.get(c);c = toupper(c);}while( c != 'Y'  &&  c != 'N');
return c;}
411Overloading Operators
Overloading operators allows you to apply existing operators to objects
of class type.For example,you can stipulate the effect of the + operator

for the objects of a particular class.
This chapter describes various uses of overloaded operators.
Arithmetic operators,comparisons,the subscript operator,and the shift

operators for input and output are overloaded to illustrate the

appropriate techniques.
The concept of friend functions,which is introduced in this context,is
particularly important for overloading operators.
chapter
19
412CHAPTER 19OVERLOADING OPERATORS
The assignment operator =, the address operator &,and the comma operator,have a predefinedmeaning for each built-in type. This meaning can be changed for classes by a definition of your own.NOTE
GENERALSOverloadable operators
RulesAn operator is always overloaded in conjunction with a class. The definition scope of anoperator is simply extended—the characteristics of the operator remain unchanged. The
following rules apply:You cannot create “new operators”—that is, you can only overload existing oper-
ators.You cannot redefine the operators for fundamental types.You cannot change the operands of an operator. A binary operator will always be
binary and a unary operator will always be unary.The precedence and the order of grouping operators of the same precedence
remains unchanged.+  -  *  /  %==  !=  < <=  >  >=&  |  ^  ~  <<  >>&&  ||  !=op=()  []&  *  ->  ,new  delete++  --Arithmetic operatorsRelational operatorsLogical operatorsAssignment operators(op is a binary arithmeticor a binary bitwise operator)Bitwise operatorsFunction call, subscript operatorOther operatorsOperatorsMeaning

GENERALS413Overloading
An operator is said to be overloaded if it is defined for multiple types. In other words,overloading an operator means making the operator significant for a new type.Most operators are already overloaded for fundamental types. In the case of theexpression:Example:a / bthe operand type determines the machine code created by the compiler for the division
operator. If both operands are integral types, an integral division is performed; in all
other cases floating-point division occurs. Thus, different actions are performed depend-
ing on the operand types involved.Operators for Classes
In addition to defining methods, C++ offers the interesting possibility of defining thefunctionality of a class by means of operators. Thus, you can overload the +operatorinstead of, or in addition to, using the add()method. For the objects xandyin thisclass:x + yis equivalent to x.add(y)Using the overloaded operators of a class expressions of this type can be as easily defined
as for fundamental types. Expressions using operators are often more intuitive, and thus
easier to understand than expressions containing function calls.Many operators belonging to the C++ standard library classes are already overloaded.This applies to the stringclass, with which you are already familiar.Example:string str1("Hello "), str2("Eve");str1 += str2;            // Operator +=
if( str2 < "Alexa") ...  // Operator <
cout << str1;            // Operator <<
str2[2] = 'i';           // Operators [] and =The tables on the opposite page show those operators that can be overloaded. Someoperators cannot be overloaded, such as the cast operators, the sizeofoperator, andthe following four operators:.  ::  .*member access and scope resolution operators?:conditional operatorThese operators either have a fixed significance in the classes for which they are defined,or overloading the operator makes no sense.
414CHAPTER 19OVERLOADING OPERATORS
// DayTime.h// The class DayTime containing operators < and ++ .
// ---------------------------------------------------
#ifndef _DAYTIME_
#define _DAYTIME_class DayTime{private:short hour, minute, second;
bool overflow;public:DayTime( int h = 0, int m = 0, int s = 0);
bool setTime(int hour, int minute, int second = 0);int getHour()   const { return hour;   }int getMinute() const { return minute; }
int getSecond() const { return second; }int asSeconds() const    // Daytime in seconds{ return (60*60*hour + 60*minute + second);  }bool operator<( const DayTime& t) const// compare{                                      // *this and treturn  asSeconds() < t.asSeconds();}DayTime& operator++()// Increment seconds{++second;                  // and handle overflow.return  *this;}void print() const;};#endif   // _DAYTIME_#include "DayTime.h". . .DayTime depart1( 11, 11, 11), depart2(12,0,0);. . .
if(depart1 < depart2)cout << "\nThe 1st plane takes off earlier!" << endl;. . .OPERATOR FUNCTIONS (1)
Operators 
<and++for class DayTimeCalling the Operator 
<
OPERATOR FUNCTIONS (1)415Naming Operator Functions
To overload an operator, you just define an appropriate operator function.The operatorfunction describes the actions to be performed by the operator. The name of an operator
function must begin with the operatorkeyword followed by the operator symbol.Example:operator+This is the name of the operator function for the + operator.An operator function can be defined as a global function or as a class method. Gener-ally, operator functions are defined as methods, especially in the case of unary operators.
However, it can make sense to define an operator function globally. This point will be
illustrated later.Operator Functions as Methods
If you define the operator function of a binaryoperator as a method, the left operand willalways be an object of the class in question. The operator function is called for this
object. The second, right operand is passed as an argument to the method. The method
thus has a singleparameter.Example:bool operator<( const DayTime& t) const;In this case the lesser than operator is overloaded to compare two DayTimeobjects. Itreplaces the method isLess(),which was formerly defined for this class.
The prefix operator ++has been overloaded in the example on the opposite page toillustrate overloading unary operators. The corresponding operator function in this class
has no parameters. The function is called if the object ain the expression ++ais anobject of class DayTime.Calling an Operator Function
The example opposite compares two times of day:Example:depart1 < depart2The compiler will attempt to locate an applicable operator function for this expressionand then call the function. The expression is thus equivalent todepart1.operator<( depart2)Although somewhat uncommon, you can call an operator function explicitly. The previ-
ous function call is therefore technically correct.Programs that use operators are easier to encode and read. However, you should beaware of the fact that an operator function should perform a similar operation to the cor-
responding operator for the fundamental type. Any other use can lead to confusion.
416CHAPTER 19OVERLOADING OPERATORS
// Euro1.h : The class Euro containing arithmetic operators.// --------------------------------------------------------#ifndef _EURO_H_#define _EURO_H_#include <sstream>             // The class stringstream#include <iomanip>using namespace std;class Euro
{private:long  data;                // Euros * 100 + Centspublic:Euro( int euro = 0, int cents = 0)
{data = 100L * (long)euro + cents;}
Euro( double x){x *= 100.0;                            // Rounding,data = (long)(x>=0.0 ? x+0.5 : x-0.5); //ex. 9.7 -> 10}
longgetWholePart()const { return data/100; }intgetCents()const { return (int)(data%100); }doubleasDouble()const { return (double)data/100.0; }stringasString()const;       // Euro as string.voidprint( ostream& os)const  // Output to stream os.{  os << asString() << " Euro" << endl;     }// ---- Operator functions ----Eurooperator-()const        // Negation (unary minus)){Euro temp;
temp.data = -data;return  temp;}Eurooperator+( const Euro& e2) const   // Addition.{Euro temp;temp.data = data + e2.data;return  temp;}Eurooperator-( const Euro& e2)const   // Subtraction.{  /*  Analog just as operator +  */  }
Euro&operator+=( const Euro& e2) // Add Euros.{data += e2.data;return  *this;}
Euro&operator-=( const Euro& e2);// Subtract euros.{  /*  Just as operator +=  */  }};
// Continued on the next double page.OPERATOR FUNCTIONS(2)
ClassEuro
OPERATOR FUNCTIONS(2)417Notes on the Sample Class EuroThe opposite page shows the Euroclass, which represents the new European currency.The member datastores a given amount of euros as an integer in the format:(integer part)*100 + Cents.Thusdata/100returns the number of euros and data%100the number of cents. Thistechnique allows for easy implementation of the arithmetic operations needed for theEuroclass.In addition to a constructor that is passed whole euros and cents as arguments, there isa constructor that can process a doublevalue of euros and a standard copy constructor.Example:Euro  e1(9,50), e2(20.07), e3(-e1);Negation,Addition,and Subtraction
The unary operator -does not change its operand. In the previous example, e3is thusassigned a value of -9,50euro, but e1remains unchanged. The operator function isthus a constmethod that creates and returns a temporary object.The binary operators +and-do not change their operands either. Thus, the operatorfunctions also create temporary objects and return them with the correct values.Example:Euro  sum = e1 + e2;The expression e1 + e2results in e1.operator+(e2). The return value is used toinitialize the new object, sum.The+=and-=Operators
Although the operators +and-were overloaded for the Euroclass, this does not auto-matically mean that the operators +=and-=are overloaded. Both are distinct operatorsthat require separate definitions. Of course, you should overload the operators to ensure
that the statementsExample:sum += e3;andsum = sum + e3;produce the same results.The binary operators +=and-=change the current object, that is, the left operand. Atemporary object is not required! The expression sum += e3represents the currentobject after modification. Thus, the operator function returns a reference to *this.
418CHAPTER 19OVERLOADING OPERATORS
// Continues file Euro1.h// --------------------------------------------------------inline string Euro::asString()const  // Euro as string{stringstream strStream;        // Stream for conversionlong temp = data;if( temp < 0) { strStream << '-';  temp = -temp; }strStream << temp/100 << ','<< setfill('0') << setw(2) << temp%100;return strStream.str();}#endif   // _EURO_H_// Euro1_t.cpp// Tests the operators of class Euro.// --------------------------------------------------------#include "Euro1.h"              // Definition of the class
#include <iostream>using namespace std;int main(){cout << "* * *  Testing the class Euro  * * *\n" << endl;Euro wholesale( 20,50), retail;retail = wholesale;                // Standard assignment
retail += 9.49; // += (Euro)9.49cout << "Wholesale price: ";   wholesale.print(cout);cout << "Retail price: ";   retail.print(cout);Euro discount( 2.10);          // double-constructorretail -= discount;cout << "\nRetail price including discount: ";retail.print(cout);
wholesale = 34.10;cout << "\nNew wholesale price: ";wholesale.print(cout);
Euro profit(retail - wholesale);    // Subtraction and// copy constructorcout << "\nThe profit: ";
profit.print(cout);                  // Negative!return 0;}USING OVERLOADED OPERATORS
FileEuro1.hcontinuedSample program

USING OVERLOADED OPERATORS419Calling Operator Functions
The following expressions are valid for the operators in the Euroclass.Example:Euro  wholesale(15,30), retail,profit(7,50), discount(1,75);retail = wholesale + profit;
// Call:  wholesale.operator+( profit)
retail -= discount;
// Call:  retail.operator-=( discount)
retail += Euro( 1.49);
// Call:  retail.operator+=( Euro(1.49))These expressions contain only Eurotype objects, for which operator functions havebeen defined. However, you can also add or subtract intordoubletypes. This is madepossible by the Euroconstructors, which create Euroobjects from intordoubletypes. This allows a function that expects a Eurovalue as argument to process intordoublevalues.As the program opposite shows, the statementExample:retail += 9.49;is valid. The compiler attempts to locate an operator function that is defined for both theEuroobject and the doubletype for +=.Since there is no operator function withthese characteristics, the compiler converts the doublevalue to Euroand calls theexisting operator function for euros.Symmetry of Operands
The available constructors also allow you to call the operator functions of +and – withintordoubletype arguments.Example:retail = wholesale + 10;       // okwholesale = retail - 7.99;     // okThe first statement is equivalent toretail = wholesale.operator+( Euro(10));But the following statement is invalid!Example:retail = 10 + wholesale;     // wrong!Since the operator function was defined as a method, the left operand must be a classobject. Thus, you cannot simply exchange the operands of the operator +. However, ifyou want to convert both operands, you will need global definitions for the operator
functions.
420CHAPTER 19OVERLOADING OPERATORS
=()[]->Assignment operatorFunction callSubscript operatorClass member accessOperatorsMeaning
The function call operator ()is used to represent operations for objects like function calls. Theoverloaded operator ->enables the use of objects in the same way as pointers.NOTE
// Euro.h// The class Euro represents a Euro with// global operator functions implemented for + and -.// ---------------------------------------------------#ifndef _EURO_H_#define _EURO_H_
// ....class Euro{//Without operator functions for + and -.// Otherwise unchanged, specifically with regard to
// the operator functions implemented for += and -=.};// ----------------------------------------------------//Global operator functions(inline)// Addition:
inlineEuro operator+( const Euro& e1, const Euro& e2){Euro temp(e1);temp += e2;return  temp;}// Subtraction:inlineEuro operator-( const Euro& e1, const Euro& e2){Euro temp(e1);   temp -= e2;
return  temp;}
#endif   // _EURO_H_GLOBAL OPERATOR FUNCTIONS
Operators overloadable by methods only
The operator functions of the following operators have to be methods:The new 
Euroclass
GLOBAL OPERATOR FUNCTIONS421Operator Functions:Global or Method?
You can define an operator function as a global function instead of a method. The fouroperators listed opposite are the only exceptions.+=   -=   *=   /=   %=These operators always require a so-called l-valueas their left operand, that is, theyrequire an object with an address in memory.Global operator functions are generally preferable if one of the following situationsapplies:the operator is binary and both operands are symmetrical, e.g. the arithmetic
operators+or*the operator is to be overloaded for another class without changing that class, e.g.
the<<operator for the ostreamclass.Defining Global Operator Functions
The operands for a global operator function are passed as arguments to that function.The operator function of a unary operator thus possesses a singleparameter, whereas theoperator function of a binary operator has two.TheEuroclass has been modified to provide a global definition of the operator func-tions for the operators +and-.Example:Euro operator+(const Euro& e1, const Euro& e2); Both operands are now peers. More specifically, conversion of intordoubletoEurois performed for both operands now. Given a Euroobjectnet,the following expres-sions are valid and equivalent:Example:net + 1.20and1.20 + netThey cause the following function calls:operator+( net, 1.20)andoperator+( 1.20, net)However, a global function cannot access the private members of the class. The func-tionoperator+()shown opposite therefore uses the +=operator, whose operatorfunction is defined as a method.A global operator function can be declared as a “friend” of the class to allow it accessto the private members of that class.
422CHAPTER 19OVERLOADING OPERATORS
// Euro.h// The class Euro with operator functions// declared as friend functions.
// ---------------------------------------------------#ifndef _EURO_H_#define _EURO_H_// ....class Euro{private:long  data;            // Euros * 100 + Centspublic:// Constructors and other methods as before.// Operators -(unary), +=, -=  as before.//DivisionEuro / double :Eurooperator/( double x)          // Division *this/x{                                  // =  *this * (1/x)return (*this * (1.0/x));}//Global friend functionsfriend Euro operator+( const Euro& e1, const Euro& e2);friend Euro operator-( const Euro& e1, const Euro& e2);friend Euro operator*( const Euro& e, double x){Euro temp( ((double)e.data/100.0) * x) ;return temp;}friend Euro operator*( double x, const Euro& e){return e * x;}};// Addition:inline Euro operator+( const Euro& e1, const Euro& e2)
{Euro temp;temp.data = e1.data + e2.data;return  temp;}// Subtraction:
inline Euro operator-( const Euro& e1, const Euro& e2){Euro temp;temp.data = e1.data - e2.data;return  temp;}#endif   // _EURO_H_FRIEND FUNCTIONSClassEurowith friend functions
FRIEND FUNCTIONS423The Friend Concept
If functions or individual classes are used in conjunction with another class, you maywant to grant them access to the privatemembers of that class. This is made possibleby a friend declaration, which eliminates data encapsulation in certain cases.Imagine you need to write a global function that accesses the elements of a numericalarray class. If you need to call the access methods of the class each time, and if these
methods perform range checking, the function runtime will increase considerably. How-
ever, special permission to access the private data members of the class can dramatically
improve the function’s response.Declaring Friend Functions
A class can grant any function a special permit for direct access to its private members.This is achieved by declaring the function as a friend. The friendkeyword must pre-cede the function prototype in the class definition.Example:class A{ // . . .friend void globFunc( A* objPtr);
friend int  B::elFunc( const A& objRef);};Here the global function globFunc()and the method elFunc()of class Baredeclared as friendfunctions of class A. This allows them direct access to the privatemembers of class A. Since these functions are not methods of class A, the thispointer isnot available to them. To resolve this issue, you will generally pass the object the func-
tion needs to process as an argument.It is important to note that the class itselfdetermines who its friends are. If this werenot so, data encapsulation could easily be undermined.Overloading Operators with Friend Functions
The operator functions for +and-in the Euroclass are now defined as friendfunc-tions, allowing them direct access to the private member data.In order to compute interest, it is necessary to multiply and divide euros by doublevalues. Since both the expression Euro*numandnum*Euroare possible, friendfunc-tions are implemented to perform multiplications. As the example shows, friendfunc-tions can also be defined inlinein a class.
424CHAPTER 19OVERLOADING OPERATORS
// Result.h// The class Result to represent a measurement
// and the time the measurement was taken.
// ---------------------------------------------------
#ifndef _RESULT_#define _RESULT_#include "DayTime.h"          // Class DayTimeclass Result{private:double val;DayTime time;public:// Constructor and access methodsfriend class ControlPoint; // All methods of};                          // ControlPoint are friends.#include Result.hclass ControlPoint{private:string name;              // Name of control pointResult measure[100];      // Table with results// . . .public:// Constructor and the other methods// . . .// Compute static values of measurement results
// (average, deviation from mean, ...).bool statistic();  // Can access the private// members of measure[i].};FRIEND CLASSESClassResultClassControlPoint
FRIEND CLASSES425Declaring Friend Classes
In addition to declaring individual friendfunctions, you can also make entire classes“friends” of another class. All the methods in this “friendly” class automatically becomefriendfunctions in the class containing the frienddeclaration.This technique is useful if a class is used in such close conjunction with another classthatallthe methods in that class need access to the private members of the other class.For example, the class ControlPointuses objects of the Resultclass. Calcula-tions with individual measurements are performed repeatedly. In this case, it makes sense
to declare the ControlPointclass as a friend of the Resultclass.Example:class Result{// . . .
friend class ControlPoint;};It is important to note that the ControlPointclass has no influence over the fact thatit is a friend of the Resultclass. The Resultclass itself decides who its friends are andwho has access to its private members.It does not matter whether a frienddeclaration occurs in the privateorpublicsection of a class. However, you can regard a frienddeclaration as an extension of thepublic interface. For this reason, it is preferable to place a frienddeclaration in thepublicarea of a class.Using Friend Functions and Classes
Usingfriendfunctions and friendclasses helps you to create efficient programs.More specifically, you can utilize global friendfunctions where methods are not suitedto the task in hand. Some common uses are global operator functions declared as friend
functions.However, extensive use of friendtechniques diffuses the concept of data encapsula-tion. Allowing external functions to manipulate internal data can lead to inconsistency,
especially if a class is modified or extended in a later version. For this reason, you should
take special care when using friendtechniques.
426CHAPTER 19OVERLOADING OPERATORS
// Array_t.cpp// A simple class to represent an array
// with range checking.
// --------------------------------------------------
#include <iostream>#include <cstdlib>                // For exit()using namespace std;#define MAX 100class FloatArr{private:float v[MAX];                // The arraypublic:float& operator[](int i);
static int MaxIndex(){ return MAX-1; }};float& FloatArr::operator[]( int i ){if( i < 0 || i >= MAX ){  cerr << "\nFloatArr: Outside of range!" << endl;exit(1);}return v[i];      // Reference to i-th element.}int main(){cout << "\n An array with range checking!\n"<< endl;FloatArr random;// Create array.int i;                // An index.// Fill with random euros:for( i=0; i <= FloatArr::MaxIndex(); ++i)random[i]=(rand() - RAND_MAX/2) / 100.0F;cout << "\nEnter indices between 0 and "<< FloatArr::MaxIndex() << "!"<< "\n (Quit by entering invalid input)"<< endl;while( cout << "\nIndex: " && cin >> i )cout << i << ". element:  " << random[i];return 0;}OVERLOADING SUBSCRIPT OPERATORS
A class representing arrays

OVERLOADING SUBSCRIPT OPERATORS427Subscript Operator
The subscript operator []is normally used to access a single array element. It is a binaryoperator and thus has two operands. Given an expression such as v[i], the array namevwill always be the left operand, whereas the index iwill be the right operand.The subscript operator for arrays implies background pointer arithmetic, for example,v[i]is equivalent to *(v+i). Thus, the following restrictions apply to non-overloadedindex operators:an operand must be a pointer—an array name, for examplethe other operand must be an integral expression.Usage in ClassesThese restrictions do not apply if the index operator is overloaded for a class. You shouldnote, however, that the operator function is always a class method with a parameter for
the right operand. The following therefore applies:the left operand must be a class objectthe right operand can be any valid typethe result type is not defined.This allows for considerable flexibility. However, your overloading should always reflectthe normal use of arrays. More specifically, the return value should be a reference to an
object.Since an index can be of any valid type, the possibilities are unlimited. For example,you could easily define associative arrays, that is, arrays whose elements are referenced bystrings.Notes on the Sample Program
Range checking is not performed when you access the elements of a normal array. Aninvalid index can thus lead to abnormal termination of an application program. How-
ever, you can address this issue by defining your own array classes, although this may
impact the speed of your programs.The opposite page shows a simple array class definition for floatvalues. The sub-script operator []has been overloaded to return a reference to the i-th array element.However, when the array is accessed, range checking is performed to ensure that the
index falls within given boundaries. If an invalid index is found, the program issues an
error message and terminates.The class FloatArrarray has a fixed length. As we will see, variable lengths are pos-sible using dynamic memory allocation.
428CHAPTER 19OVERLOADING OPERATORS
// Euro.h : Class Euro to represent an Euro// ---------------------------------------------------
#ifndef _EURO_H_
#define _EURO_H_
// ....class Euro{ // The class is left unchanged.// The print() method is now superfluous.};
// ----------------------------------------------------// Declaration of shift operators:ostream& operator<<(ostream& os, const Euro& e);
istream& operator>>(istream& is, Euro& e);#endif   // _EURO_H_// Euro_io.cpp// Overload the shift operators// for input/output of Euro type objects.
// ---------------------------------------------------#include "Euro.h"#include <iostream>
using namespace std;// Output to stream os.ostream& operator<<(ostream& os, const Euro& e){os << e.asString() << " Euro";   return os;}// Input from stream is.istream& operator>>(istream& is, Euro& e){cout << "Euro amount (Format ...x,xx): ";
int euro = 0, cents = 0;  char c = 0;if( !(is >> euro >> c >> cents))  // Input.return is;if( (c != ',' && c != '.')|| cents>=100)                // Error?is.setstate( ios::failbit);     // Yes => Setelse                              // fail bit.e = Euro( euro, cents);         // No => Acceptreturn is;                        // value.}OVERLOADING SHIFT-OPERATORS FOR I/O
Declaration of the operator functions
Definition of operator functions

OVERLOADING SHIFT-OPERATORS FOR I/O429When outputting a Euroclass object, price, on screen, the following output statementcauses a compiler error:Example:cout << price;coutcan only send objects to standard output if an output function has been defined forthetypein question—and this, of course, is not the case for user-defined classes.However, the compiler can process the previous statement if it can locate a suitableoperator function, operator<<(). To allow for the previous statement, you thereforeneed to define a corresponding function.Overloading the 
<<Operator
In the previous example, the left operand of <<is the object cout, which belongs to theostreamclass. Since the standard class ostreamshould not be modified, it is necessaryto define a global operator function with two parameters. The right operand is a Euroclass object. Thus the following prototype applies for the operator function:Prototype:
ostream& operator<<(ostream& os, const Euro& e);The return value of the operator function is a reference to ostream. This allows for nor-mal concatenation of operators.Example:cout << price << endl;Overloading the 
>>Operator
The>>operator is overloaded for input to allow for the following statements.Example:cout << "Enter the price in Euros: "cin >> price;The second statement causes the following call:operator>>( cin, price);Ascinis an object of the standard istreamclass, the first parameter of the operatorfunction is declared as a reference to istream. The second parameter is again a refer-ence to Euro.The header file Euro.hcontains only the declarations of <<and>>. To allow thesefunctions to access the private members of the Euroclass, you can add a frienddecla-ration within the class. However, this is not necessary for the current example.
exercises
430CHAPTER 19OVERLOADING OPERATORS
The expression obj++represents a copy of objbefore incrementing.The prefix and postfix decrement operators --are distinguished in the samemanner.NOTE
Optimized error handling for the Fractionclass will be discussed in Chapter28, “Exception Handling”NOTE
AdditionSubtractionMultiplicationDivisiona-
b+=c-
da*d + b*cb*da-b-=c-da*d - b*cb*da-b*=c-da * cb * da-b/=c-da * db * cExpressionOperator Function Call
++obj    (Prefix)obj++    (Postfix)obj.operator++()obj.operator++(0)EXERCISESPrefix and postfix increment
To distinguish the postfix increment operator from the prefix increment
operator,the postfix operator function has an additional parameter of type 
int.For exercise 2:Calculating with fractions

EXERCISES431Exercise 1
The<and++operators for the sample class 
DayTimewere overloaded at the
beginning of this chapter.Now modify the class as follows:
Overload the relational operators
<  >  <=  >=  == and!=and the shift operators>>and<<for input and output
using global operator functions.You can define these 
inlinein theheader file.
Then overload both the prefix and postfix versions of the 
++and--operators.The operator functions are methods of the class.The 
--oper-ator decrements the time by one second.The time is not decremented

after reaching 0:0:0.
Write a main function that executes all the overloaded operators and dis-

plays their results.
Exercise 2
You are to develop a class that represents fractions and performs typical

arithmetic operations with them.Use a header file called fraction.hto define the Fractionclass with anumerator and a denominator of type 
long.The constructor has two
parameters of type long:the first parameter (numerator) contains the
default value 0,and the second parameter (denominator) contains the

value 1.Declare operator functions as methods for 
-(unary),
++and--(prefix only),
+=,-=,*=,and 
/=.The operator functions of the binary
operators+,-,*,/and the input / output operators <<,>>are to be
declared as 
friendfunctions of the Fractionclass.Implement the constructor for the 
Fractionclass to obtain a positive
value for the denominator at all times.If the denominator assumes a value

of 0,issue an error message and terminate the program.Then write the

operator functions.The formulae for arithmetic operations are shown

opposite.
Then write a mainfunction that calls all the operators in the Fractionclass as a test application.Output both the operands and the results.

solutions
432CHAPTER 19OVERLOADING OPERATORS
SOLUTIONSExercise 1
// ----------------------------------------------------//DayTime.h// Class DayTime with all relational operators,
// the operators ++ and -- (prefix and postfix),
// such as the operators << and >> for input/output.// ----------------------------------------------------#ifndef _DAYTIME_#define _DAYTIME_#include <iostream>#include <iomanip>
using namespace std;class DayTime{private:short hour, minute, second;
bool overflow, underflow;void inc()             // private function for ++{++second;if( second >= 60)    // handle overflow.second = 0,  ++minute;if( minute >= 60)minute = 0,  ++hour;if( hour >= 24)hour = 0,  overflow = true;}
void dec()             // private function for --
{--second;
if( second < 0)      // handle underflow.second = 59,  --minute;if( minute < 0)minute = 59,  --hour;if( hour < 0)hour = 0,  underflow = true;}public:DayTime( int h = 0, int m = 0, int s = 0)
{overflow = underflow = false;
if( !setTime( h, m, s))hour = minute = second = 0;}
SOLUTIONS433bool setTime(int hour, int minute, int second = 0){if(    hour   >= 0  &&  hour < 24&& minute >= 0  &&  minute < 60&& second >= 0  &&  second < 60 ){this->hour   = (short)hour;
this->minute = (short)minute;
this->second = (short)second;
return true;}elsereturn false;}
int getHour()   const { return hour;   }int getMinute() const { return minute; };int getSecond() const { return second; };int asSeconds() const          // daytime in seconds{return (60*60*hour + 60*minute + second);}DayTime&operator++()          // ++Seconds{inc();return  *this;}
DayTimeoperator++(int)        // Seconds++{DayTime temp(*this);
inc();return temp;}DayTime&operator--
()          // --Seconds{dec();return  *this;}DayTimeoperator--
(int)        // Seconds--{DayTime temp(*this);dec();return temp;}};// ---  Relational operators  ---//  t1 < t2inline bool operator<( const DayTime& t1,const DayTime& t2){   return  t1.asSeconds() < t2.asSeconds(); }
434CHAPTER 19OVERLOADING OPERATORS
//  t1 <= t2inline bool operator<=( const DayTime& t1,const DayTime& t2){   return  t1.asSeconds() <= t2.asSeconds(); }//  t1 == t2inline bool operator==( const DayTime& t1,const DayTime& t2){   return  t1.asSeconds() == t2.asSeconds(); }//  t1 != t2inline bool operator!=( const DayTime& t1,const DayTime& t2){   return !(t1 == t2); }//  t1 > t2inline bool operator>( const DayTime& t1,const DayTime& t2){   return (t2 < t1); }//  t1 >= t2inline bool operator>=(const DayTime& t1,const DayTime& t2){   return !(t1 < t2); }//  ---  Input and Output  ---ostream&operator<<( ostream& os, const DayTime& t){os << setfill('0')<< setw(2) << t.getHour()    << ':'<< setw(2) << t.getMinute()  << ':'<< setw(2) << t.getSecond()  << " Time";os << setfill(' ');
return os;}istream&operator>>( istream& is, DayTime& t){cout << "Enter daytime in hh:mm:ss format: ";
int hr = 0, min = 0, sec = 0;char c1 = 0, c2 = 0;if( !(is >> hr >> c1 >> min >> c2 >> sec))return is;if( c1 != ':' || c2 != ':' || ! t.setTime(hr,min,sec))is.setstate( ios::failbit);   // Error!//  => Set fail bit.return is;}#endif   // _DAYTIME_
SOLUTIONS435// ----------------------------------------------------//DayTim_t.cpp// Testing the operators of class DayTime.// ----------------------------------------------------#include "DayTime.h"         // Definition of the class
#include <iostream>
using namespace std;int main(){DayTime cinema( 20,30);
cout << "\nThe movie starts at " << cinema << endl;DayTime now;cout << "What time is it now?" << endl;
if( !(cin >> now) )cerr << "Invalid input!" << endl;elsecout << "\nThe time is now" << now << endl;cout << "\nThe movie has ";if( cinema < now)cout << "already begun!\n" << endl;elsecout << "not yet begun!\n" << endl;cout << "Now it is     " << now++ << endl;cout << "After 2 seconds: " << ++now << endl;DayTime depart(16,0);cout << "Let's go at " << --depart << endl;if( depart >= now )cout << "You can ride with us!" << endl;elsecout << "We don't have room!" << endl;return 0;}
436CHAPTER 19OVERLOADING OPERATORS
Exercise 2
// ------------------------------------------------------//Fraction.h// A numerical class to represent fractions
// ------------------------------------------------------
#ifndef _FRACTION_#define _FRACTION_#include <iostream>#include <cstdlib>using namespace std;class Fraction{private:long numerator, denominator;public:Fraction(long n = 0, long d = 1);Fraction operator-() const{return Fraction(-numerator, denominator);}Fraction& operator+=(const Fraction& a)
{numerator = a.numerator * denominator+ numerator * a.denominator;denominator *= a.denominator;
return *this;}Fraction& operator-=(const Fraction& a){*this += (-a);
return *this;}Fraction& operator++(){numerator += denominator;return *this;}Fraction& operator--(){numerator -= denominator;
return *this;}
SOLUTIONS437friend Fraction operator+(const Fraction&, const Fraction&);friend Fraction operator-(const Fraction&, const Fraction&);
friend Fraction operator*(const Fraction&, const Fraction&);
friend Fraction operator/(const Fraction&, const Fraction&);
friend ostream& operator<< (ostream& os, const Fraction& a);
friend istream& operator>> (istream& is, Fraction& a);};
#endif// -------------------------------------------------------//Fraction.cpp// Defines methods and friend functions.
// -------------------------------------------------------
#include "Fraction.h"// Constructor:Fraction::Fraction(long n, long d)
{if(d == 0){ cerr << "\nError: Division by zero!\n";exit(1);}
if( n < 0 ) n = -n, d = -d;
numerator = n;    denominator  = d;}
Fractionoperator+(const Fraction& a, const Fraction& b){Fraction temp;
temp.denominator = a.denominator * b.denominator;
temp.numerator = a.numerator*b.denominator+ b.numerator * a.denominator;return temp;}Fractionoperator-(const Fraction& a, const Fraction& b ){Fraction temp = a;   temp += (-b);
return temp;}Fractionoperator*(const Fraction& a, const Fraction& b ){Fraction temp;
temp.numerator = a.numerator * b.numerator;
temp.denominator  = a.denominator  * b.denominator;
return temp;}
438CHAPTER 19OVERLOADING OPERATORS
Fractionoperator/(const Fraction& a, const Fraction& b ){if( b.numerator == 0){cerr << "\nError: Division by zero!\n";
exit(1);}// To multiply a by the inverse of b:
Fraction temp;temp.numerator = a.numerator * b.denominator;temp.denominator  = a.denominator  * b.numerator;if( temp.denominator < 0 )temp.numerator = -temp.numerator,
temp.denominator  = -temp.denominator;return temp;}ostream&operator<<(ostream& os, const Fraction& a){os << a.numerator << "/" << a.denominator;
return os;}istream&operator>>(istream& is, Fraction& a){cout << "Enter a fraction:\n""  Numerator:      ";   is >> a.numerator;cout << "  Denominator != 0:  ";   is >> a.denominator;if( !is) return is;
if( a.denominator == 0){cout << "\nError: The denominator is 0\n""  New denominator != 0: ";is >> a.denominator;if( a.denominator == 0){cerr << "\nError: Division by zero!\n"; exit(1);}}if( a.denominator < 0 )a.numerator = -a.numerator,a.denominator= -a.denominator;return is;}
SOLUTIONS439// -------------------------------------------------------//Fract_t.cpp// Testing the class Fraction.// Modules: Fract_t.cpp  Fraction.cpp// -------------------------------------------------------#include "Fraction.h"int main(){Fraction a(1,3), b(4);cout << "\nSome test results:\n\n";cout << " a = " << a << endl;cout << " b = " << b << endl;cout << " a + b = " << (a + b) << endl;cout << " a - b = " << (a - b) << endl;
cout << " a * b = " << (a * b) << endl;cout << " a / b = " << (a / b) << endl;cout << "  --a =  " <<  --a << endl;cout << "  ++a  = " <<  ++a << endl;a += Fraction(1,2);cout << " a+= 1/2;  a = " << a << endl;a -= Fraction(1,2);cout << " a-= 1/2;  a = " << a << endl;cout << "-b = " << -b << endl;cout << "\nAnd now an input\n";cin  >> a;cout << "\nYour input: " << a << endl;return 0;}
This page intentionally left blank 
441Type Conversion for
ClassesImplicit type conversion occurs in C++ when an expression cannot be
compiled directly but can be compiled after applying a conversion rule.

The programmer can stipulate how the compiler will perform implicit

type conversion for classes by defining conversion constructors and

functions.Finally,we discuss ambiguity occurring due to type conversion and
how to avoid it.
chapter
20
442CHAPTER 20TYPE CONVERSION FOR CLASSES
CurrentClassAnotherType
ConvertingConstructorConverting-Function// The class Euro defined in the last chapter// contains the following conversion constructors:Euro::Euro( int );// int -> EuroEuro::Euro( double );// double -> Euro// The following declarations are now possible:// Conversion constructorsEuro my(100),         // int-> Euro,your(321.41);    // double -> Euro.my = 987.12;// Implicit conversion://  double -> Euroyour += 20;// Implicit conversion://  int -> Euroyour = Euro(999.99);// Explicit conversion// (constructor style)my = (Euro)123.45; // Explicit conversion// (cast style)your = my;             // No conversionWhen the copy constructor performs a type conversion, a temporary object is first created and thisobject is used in the assignment. The temporary object is cleaned up later.NOTE
CONVERSION CONSTRUCTORS
Possible conversions
Converting constructors of class 
Euro
CONVERSION CONSTRUCTORS443Possible Type Conversions
Implicit and explicit type conversion is also performed for classes in C++. As a program-mer, you decide what kind of conversion is permissible. You can allow type conversion
between different classes or between classes and fundamental types.Any type conversion involving a class is defined eitherby a conversion constructor orby a conversion function.A conversion constructor performs type conversion by converting any given type to thetype of the current class. A conversion function performs conversion in the opposite
direction, that is, it converts an object of the current class to another type—a standard
type, for example.Conversion Constructors
A constructor with a singleparameter determines how to form an object of the new classfrom the argument passed to it. For this reason, a constructor with only one parameter is
referred to as a conversion constructor. The copy constructor is an exception to this rule: itcreates an object of the same class and does not perform type conversion.Each conversion constructor is placed by the compiler on a list of possible conver-sions. The standard stringclass contains a constructor that creates a stringobjectfrom a C string, for example.Example:string::string( const char* );This allows you to supply a C string as an argument wherever a stringobject isrequired.Calling a Conversion Constructor
Conversion constructors have already been used in several examples; for example, in theEuroclass. The compiler uses them to perform implicit and explicit type conversion.Examples:Euro salary(8765.30);salary += (Euro)897.1;     // explicit
salary += 897.1;           // implicitThe last statement initially causes a type mismatch. Addition is not defined for a euroand a doublevalue. The compiler therefore activates the conversion constructor to cre-ate a temporary Eurotype object from the doublevalue. This object is then added tothe value of the salaryobject.
444CHAPTER 20TYPE CONVERSION FOR CLASSES
// Euro.h : The class Euro represents a euro.// -----------------------------------------------------// . . .class Euro
{private:long  data;            // Euros * 100 + Centspublic:Euro( int euro = 0, int cents = 0);
Euro( double x);// For conversion from Euro to double:operator double() const { return (double)data/100.0; }// . . . other methods as before.};// Euro_t.cpp : Testing conversions of class Euro.// -----------------------------------------------------#include "Euro.h"           // Definition of the class#include <iostream>
using namespace std;int main(){cout << " * * *  Testing Conversions  * * * \n" << endl;Euro salary( 8888,80);
double x(0.0);salary += 1000;// implicit int -> Eurosalary += 0.10;// implicit double -> Eurox = salary;// implicit Euro -> doublex = (double)salary;// explicit Euro -> doublex = salary.operator double();// also possible!// Constructor style is also safe for built-in types:x = double(salary);
inti = salary;// Euro -> double -> int// Output:cout << " salary = " << salary << endl;  // 9888,90 Euro
cout << "      x = " << x << endl;       // 9888.9cout << "      i = " << i << endl;       // 9888return 0;}CONVERSION FUNCTIONSA converting function for the 
EuroclassTesting conversions

CONVERSION FUNCTIONS445If you need to convert an object of the current class to another type, you must define aconversion function to do so. This is an operator function that defines how conversion isperformed. Conversion functions are also automatically used by the compiler to perform
implicit and explicit type conversion.Defining Conversion Functions
A conversion function is always implemented as a method of the current class. Its nameis made up of the operatorkeyword and the target type to convert to.Example:operator int(void) const;The previous statement declares a conversion function where the target type is int. Youmay have noticed that the declaration of a conversion function does not contain a return
type. This is because the return type is implicitly defined by the target type in the name
of the conversion function. The target type can contain multiple keywords, such asunsigned shortorconst float*.Thus, conversion functions must be written to construct a target type object from thecurrent object,*this, and return the target object.TheEuroshown opposite contains a conversion function with a doubletarget type.In other words, the function converts a Eurotype object to a floating-point number.Example:double x = oneEuro;     // implicitConversion Function versus Conversion Constructor
The target type of a conversion function can also be a class. In this case, you must decidewhether it is preferable to use a conversion constructor in the target class.If you do not want to modify the target class—perhaps because it is a standard class—a conversion function will perform the task well.Standard Type Conversion
In addition to user-definable type conversions, the compiler also performs standard typeconversions. In the previous example, an intvariable is assigned to a euro object by thismethod.Example:int wholePart = oneEuro;This first converts a Euroobject to doubleand then to int, that is, the cents are trun-cated.
446CHAPTER 20TYPE CONVERSION FOR CLASSES
// Euro.h : The class Euro represents a euro.// -----------------------------------------------------// . . .class Euro
{private:long  data;            // Euros * 100 + Centspublic:explicitEuro( int euro = 0, int cents = 0);explicitEuro( double x);// Converting Euro to double:double asDouble() const { return (double)data/100.0;}
// No conversion function operator double(),// or as previously seen.};// Euro_E_t.cpp// Tests explicit conversion of class Euro.// ---------------------------------------------------#include "Euro_Ex.h"        // Class definition
#include <iostream>using namespace std;int main(){Euro salary( 8888.8);      // double constructordouble x(0.0);/* Now impossible:
salary += 1000;            // implicit int -> Eurosalary += 0.10;            // implicit double -> Eurosalary = 7777.77;x = salary;                // implicit Euro -> doublex = (double)salary;        // There is no method// operator double().// The following conversions are ok:salary = Euro( 7777.77);// explicit double -> Eurosalary += Euro(1000.10);x = salary.asDouble();// explicit by method// Euro -> doubleinti = salary.asDouble();// Euro -> double -> intreturn 0;}AMBIGUITIES OF TYPE CONVERSIONS
Explicit type conversion for class 
EuroTesting explicit conversions

AMBIGUITIES OF TYPE CONVERSIONS447Type Conversion Failure
Defining a conversion function or conversion constructor can prevent you from compil-ing a program that is otherwise unchanged.TheEuroclass contains a conversion constructor that converts a doublevalue toeuros. This means that the following statement is valid for two objects, wholesaleandretail,of the Eurotype.Example:retail = wholesale + 46.9;If you now additionally implement the conversion functionoperator double()that converts a euro to a doublevalue, the previous statement can no longer be com-piled. Since both conversion types double -> EuroandEuro -> doublearedefined, two possible conversions could be performed:prov2 + Euro(546.9)      // To add eurosanddouble(prov2) + 546.9;   // To add values// of type doubleHowever, the compiler can only perform implicit type conversion if the technique is notambiguous. If more than one choice is available, the compiler issues an error message.Avoiding Implicit Type Conversion
You can prevent ambiguities by stating any desired conversions explicitly. This also hasthe advantage of highlighting type conversions in your source code. Moreover, undesir-
able type conversion, which can occur when classes are extended at a later date, can be
avoided.In order to ensure that some kinds of type conversion are only performed explicitly,you can use the following techniques:you can use an explicitdeclaration for the conversion constructor. As theexample on the opposite page shows, only explicit calls to the constructor are
possible in this case.Example:wholesale + Euro(46.9)       // okimplicit type conversions by conversion functions can be prevented by not defin-
ing the function, of course. Instead you can use a method of an appropriate name,
for example asType(). Type conversion can only be performed by calling thisfunction explicitly.
exercise
448CHAPTER 20TYPE CONVERSION FOR CLASSES
// Fraction.cpp// . . .// To simplify fractions:void Fraction::simplify(){// Divide the numerator and denominator by// the greatest common divisor.if( numerator == 0){denominator = 1;
return;}// Calculating the greatest common divisor// using an algorithm by Euclid.long a = (numerator < 0) ? -numerator : numerator,b = denominator,help;while( b != 0){help = a % b;  a = b;  b = help;}// a is the greatest common divisor
numerator /= a;denominator  /= a;}EXERCISEMethodsimplify()of class Fraction
EXERCISE449Exercise
Enhance the numerical class 
Fraction,which you know from the last chapter,to
convert both 
doublevalues to fractions and fractions to double.In addition,
fractions should be rounded after arithmetic operations.
First declare the 
simplify()method for the 
Fractionclass and insert
the definition on the opposite page in your source code.The method

computes the largest common divisor of numerator and denominator.

The numerator and the denominator are then divided by this value.
Add an appropriate call to the 
simplify()function to all operator func-tions (except ++and--).Then add a conversion constructor with a 
doubletype parameter to theclass.Example:Fraction b(0.5);    // yields the fraction 1/2Doublevalues should be converted to fractions with an accuracy of three
decimal places.The following technique should suffice for numbers below

one million.Multiply the 
doublevalue by 
1000and add 
0.5for rounding.
Assign the result to the numerator.Set the value of the denominator to
1000.Then proceed to simplify the fraction.
You now have a conversion constructor for 
longanddoubletypes.To
allow for conversion of 
intvalues to fractions,you must write your own
conversion constructor for 
int!Now modify the class to allow conversion of a fraction to a 
doubletypenumber.Define the appropriate conversion function 
inline.Use the function main()to test various type conversions.More specifically,use
assignments and arithmetic functions to do so.Also compute the sum of a

fraction and a floating-point number.
Output the operands and the results on screen.

solution
450CHAPTER 20TYPE CONVERSION FOR CLASSES
SOLUTION// -------------------------------------------------------//Fraction.h// A numerical class to represent fractions.// The class converts Fraction <--> double// and simplifies fractions.
// -------------------------------------------------------#ifndef _FRACTION_#define _FRACTION_
#include <iostream.h>#include <stdlib.h>class Fraction
{private:  long numerator, denominator;public:Fraction(long z, long n);
Fraction(double x);              // double-constructor
// Default  long- and int-constructor:
Fraction(long z=0) : numerator(z), denominator(1) {}Fraction(int z)    : numerator(z), denominator(1) {}void simplify();
operator double()                // Fraction -> double
{return (double)numerator / (double)denominator;}
Fraction operator-() const{ return Fraction(-numerator, denominator);   }Fraction& operator+=(const Fraction& a)
{numerator = a.numerator * denominator+ numerator * a.denominator;denominator *= a.denominator;simplify();return *this;}
Fraction& operator-=(const Fraction& a){*this += (-a);      simplify();
return *this;}// The rest of the class including methods
//    operator++()   and   operator--()// and friend declarations are unchanged.};
#endif
SOLUTION451// --------------------------------------------------------//Fraction.cpp// Defines methods and friend functions// that are not inline.// --------------------------------------------------------#include <iostream.h>#include <stdlib.h>
#include "Fraction.h"// Constructors:Fraction::Fraction(long z, long n)
{// Unchanged! Same as in Chapter 19.}Fraction::Fraction( double x){x *= 1000.0;x += (x>=0.0) ? 0.5 : -0.5;    // Round the 4th digit.numerator = (long)x;
denominator = 1000;
simplify();}Fraction operator+(const Fraction& a, const Fraction& b ){Fraction temp;temp.denominator = a.denominator * b.denominator;temp.numerator = a.numerator*b.denominator+ b.numerator * a.denominator;temp.simplify();return temp;}// The functions//  operator-()    operator<<()     operator>>()
// are left unchanged.// The functions//  operator*()   and   operator/()
// are completed by a call to temp.simplify()// just like the function operator+().//// The code of method Fraction::simplify(), as// specified in the exercise, should be here.
452CHAPTER 20TYPE CONVERSION FOR CLASSES
// -------------------------------------------------------//Fract_t.cpp// Tests the class Fraction with type conversions.// -------------------------------------------------------#include <iostream.h>
#include "Fraction.h"
int main()
{Fraction a, b(-1,5), c(2.25);
double x = 0.5, y;
a = x;                    // double -> Fraction
cout << "\nSome test results:\n" << endl;
cout << " a = " << a << endl;
cout << " b = " << b << endl;
cout << " c = " << c << endl;
cout << "\nThe fractions as double values:\n" << endl;// Fraction -> double:cout << " a = " << (double)a << endl;
cout << " b = " << (double)b << endl;cout << " c = " << (double)c << endl;cout << "\nAnd calculate with:\n" << endl;cout << " a + b = " << (a + b) << endl;cout << " a - b = " << (a - b) << endl;
cout << " a * b = " << (a * b) << endl;
cout << " a / b = " << (a / b) << endl;cin  >> a;                // Enter a fraction.cout << "\nYour input:    " << a << endl;a.simplify();cout << "\nSimplified:        " << a << endl;
cout << "\nAs double value: " << (double)a << endl;cout << "\nEnter a floating point value: ";  cin >> x;
cout << "\nThis is in fraction form:            "<< (Fraction)x << endl;// To calculate the sum b + x :cout << " b = " << b << endl;cout << " x = " << x << endl;// a = b + x;                 // Error: ambiguous!a = b + Fraction(x);       // ok! To compute fractions.y = (double)b + x;         // ok! To compute doubles.
cout << " b + x  as fraction:   " << a << endl;cout << " b + x  as double:     " << y << endl;return 0;}
453Dynamic Memory
AllocationThis chapter describes how a program can allocate and release memory
dynamically in line with current memory requirements.
Dynamic memory allocation is an important factor in many C++
programs and the following chapters will contain several additional case

studies to help you review the subject.
chapter
21
454CHAPTER 21DYNAMIC MEMORY ALLOCATION
Heapptr_longptr_double12345671.9// Dynamic objects of type long and double// ------------------------------------------------------long *ptr_long;
ptr_long = new long; // No initialization// of the long object.*ptr_long = 1234567;          // Assign a valuedouble *ptr_double;double z = 1.9;
ptr_double = new double(z);// With initialization++(*ptr_double);              // Increment the value*ptr_double += *ptr_long;     // ok to add long valueptr_long = new double(2.7);   // Error: ptr_long not// pointing to double!THE OPERATOR 
newSample calls to newOn the heap
THE OPERATOR new455Dynamic Memory Allocation
When a program is compiled, the size of the data the program will need to handle isoften an unknown factor; in other words there is no way to estimate the memory require-
ments of the program. In cases like this you will need to allocate memory dynamically,
that is, while the program is running.Dynamically allocated memory can be released to continually optimize memory usagewith respect to current requirements. This in turn provides a high level of flexibility,
allowing a programmer to represent dynamic data structures, such as trees and linked
lists.Programs can access a large space of free memory known as the heap.Depending onthe operating system (and how the OS is configured), the heap can also occupy large
amounts of unused space on the hard disk by swappingmemory to disk.C++ uses the newanddeleteoperators to allocate and release memory, and thismeans that objects of any type can be created and destroyed. Let’s look at the scenario
for fundamental types first.Callingnewfor Fundamental Types
Thenewoperator is an operator that expects the type of object to be created as an argu-ment. In its simplest form, a call to newfollows this syntaxSyntax:ptr = new type;Whereptris a pointer to type. The newoperator creates an object of the specifiedtype and returns the address of that object. The address is normally assigned to a pointer
variable. If the pointer belongs to a wrong type, the compiler will issue an error message.Example:long double *pld = new long double;This statement allocates memory for a longdouble
type object, that is,sizeof(longdouble)
bytes.The previous call to newdoes not define an initial value for the new object, however,you can supply a value in parentheses to initializethe object.Example:pld = new long double(10000.99);Following this statement pldpoints to a memory address containing a long doubletype with a value of 10000.99. The statementcout << *pld << endl;will output this value.
456CHAPTER 21DYNAMIC MEMORY ALLOCATION
// DynStd.cpp// The operators new and delete for built-in types.// The program contains errors!// ==> Save all data before starting.// ---------------------------------------------------
#include <iostream>
using namespace std;int main(){cout << "\nTesting dynamic storage allocation! "<< endl;// To allocate storage:
double width = 23.78;double* ptrWidth  = &width;double* ptrLength  = new double(32.54);double* ptrArea = new double;// To work with ptrWidth, ptrLength, and ptrArea:*ptrArea = *ptrWidth * *ptrLength;delete ptrLength;      // Error:The object is still// in use!cout << "\nWidth     : " << *ptrWidth<< "\nLength    : " << *ptrLength
<< "\nArea      : " << *ptrArea << endl;// To free storage:delete ptrWidth;      // Error:The object has not// been dynamically reserveddelete ptrLength;// okdelete ptrArea;// okdelete ptrLength;      // Error:Pointer doesn't// address any object.ptrLength = new double(19.45);// ok// To give a name to a dynamic object:double& length = *ptrLength;       // Referencecout << "\nNew length       : " << length<< "\nCircumference    : " << 2 * width * length
<< endl;return 0;         // On terminating the program}                   // allocated storage will be freed.THE OPERATOR 
deleteSample program

THE OPERATOR delete457A program should make careful use of available memory and always release memory thatis no longer needed. Failure to do so can impact the performance of your computer sys-
tem. Memory that is released is available for further calls to new.CallingdeleteMemory that has been allocated by a call to newcan be released using the deleteoper-ator. A call to deletefollows this syntaxSyntax:delete ptr;The operand ptraddresses the memory space to be released. But make sure that thismemory space was dynamically allocated by a call to new!Example:long *pl = new long(2000000);. . . .       // to work with *pl.
delete pl;If you do not call delete, the dynamically allocated memory space is not released untilthe program terminates.You can pass a NULL pointer to deletewhen you call the operator. In this casenothing happens and deletejust returns, so you do not need to check for NULL point-ers when releasing memory.Adeleteexpression is always a voidtype, so you cannot check whether memoryhas been successfully released.As the sample program illustrates, misuse of deletecan be disastrous. More specifi-callydo not call deletetwice for the same objectdo not use deleteto release statically allocated memory.Error Handling for 
newIf there is not enough memory available, the so-called new handleris called. The newhandler is a function designed for central error handling. Thus, you do not need to design
your own error handling routines each time you call new.The new handler is activated by default and throws an exception. Exceptions can becaught by the program, allowing the error condition to be remedied (refer to Chapter 28,
Exception Handling). Any exception that is not caught will terminate the program,
however, you can install your own new handler.If you are working with an older compiler, please note that newreturns a NULLpointer if not enough memory is available.
458CHAPTER 21DYNAMIC MEMORY ALLOCATION
// DynObj.cpp// The operators new and delete for classes.
// ---------------------------------------------------
#include "account.h"
#include <iostream>using namespace std;Account *clone( const Account* pK);  // Create a copy// dynamically.int main(){cout << "Dynamically created objects.\n" << endl;// To allocate storage:Account *ptrA1, *ptrA2, *ptrA3;ptrA1 = new Account;// With default constructorptrA1->display();         // Show default values.ptrA1->setNr(302010);         // Set the otherptrA1->setName("Tang, Ming"); // values by accessptrA1->setStand(2345.87);     // methods.ptrA1->display();             // Show new values.// Use the constructor with three arguments:ptrA2 = new Account("Xiang, Zhang", 7531357, 999.99);
ptrA2->display();            // Display new account.ptrA3 = clone( ptrA1);       // Pointer to a dyna-// mically created copy.cout << "Copy of the first account: " << endl;ptrA3->display();            // Display the copy.delete ptrA1;// Release memorydelete ptrA2;delete ptrA3;return 0;}Account *clone( const Account* pK)   // Create a copy{                                    // dynamically.returnnew Account(*pK);}DYNAMIC STORAGE ALLOCATION FOR CLASSES
Sample program

DYNAMIC STORAGE ALLOCATION FOR CLASSES459The operators newanddeletewere designed to create and destroy instances of a classdynamically. In this case, in addition to allocating memory, a suitable constructor must
be called. Before releasing memory, the destructor must be called to perform cleaning up
tasks. However, the operators newanddeleteensure that this happens.Callingnewwith a Default Constructor
A call to newfor a class is not much different from a call for a fundamental type. Unlessexplicitly initialized, the default constructor is called for each new object, but you must
make sure that a default constructor exists!Example:Euro* pEuro = new Euro;This statement allocates memory for an object of the Euroclass. If enough memory isavailable, the default constructor for Eurois executed and the address of a new objectreturned.Explicit Initialization
To initialize an object explicitly, you can state its initial values in parentheses when youcallnew.Syntax:Type *ptr = new Type(initializing_list);The values in the initialization list are passed as arguments to the constructor. If the
compiler is unable to locate a suitable constructor, an error message occurs.Example:Euro *pE = new Euro( -123,77);This statement assigns the address of a new Euroclass object to the pointer pE. Theobject is initialized using the supplied values. The expression *pEthus represents theentire object.Example:*pE += 200;           // To add 200 euros.Thepublicmembers are referred to via the member access operator ->.Example:cout << pE->getCents() << endl;    // 33Releasing Memory
When an object that was created dynamically is destroyed, the deleteoperator makessure that the object is cleaned up. The destructor is first called, and only then is the
memory space released.As previously discussed in the section on fundamental types, when you call deleteyou must ensure that the pointer is addressing a dynamic object or that you are dealing
with a NULL pointer.
460CHAPTER 21DYNAMIC MEMORY ALLOCATION
// DynArr.cpp// Operators new[] and delete[] for dynamic arrays.// ----------------------------------------------------
#include <iostream>#include <iomanip>using namespace std;int main(){cout << "Using a dynamic array.\n" << endl;
int size = 0, cnt = 0, step = 10,i;float x, *pArr = NULL;cout << "Enter some numbers!\n""End with q or another character " << endl;while( cin >> x)
{if( cnt >= size)           // Array too small?{                          // => enlarge it.float *p = new float[size+step];// Copy the numbers:for( i = 0; i < size; ++i)p[i] = pArr[i];delete [] pArr;// Release old array:pArr = p;  size += step;}pArr[cnt++] = x;}// Work with the numbers:
if( cnt == 0)cout << "No invalid input!" << endl;else
{float sum = 0.0;cout << "Your input: " << endl;
for( i = 0; i < cnt; i++)       // To output and{                               // add.cout << setw(10) << pArr[i];sum += pArr[i];}
cout << "\nThe average: " << sum/cnt << endl;}delete [] pArr; // To free the storagereturn 0;}DYNAMIC STORAGE ALLOCATION FOR ARRAYS
Sample program

DYNAMIC STORAGE ALLOCATION FOR ARRAYS461Imagine you are compiling a program that will store an unknown quantity of elements inan array. Your best option is to let the program create the array dynamically. An array of
this type is known as a dynamic array.Thenew[ ]Operator
Thenew[ ]operator is available for creating dynamic arrays. When you call the opera-tor, you must supply the type and quantity of the array elements.Syntax:vekPtr = new Type[cnt];The pointer vekPtrwill then reference the first of a total of cntarray elements.vekPtrhas to be a pointer to Typefor this reason. Of course, Typecan also be a class.Example:Account *pk = new Account[256];This statement allocates memory for 256 Accounttype objects and uses the default con-structor to initialize them. Those objects arepk[0],  pk[1],  . . . , pk[255],or in pointer notation:*pk, *(pk + 1), ....., *(pk + 255).If the array elements are of a class type, the class must have a default constructor, since youcannot supply an initialization list when calling new[]. Starting values for the array ele-ments cannot be assigned until later.Thedelete[ ]Operator
It is always a good idea to release the memory space occupied by a dynamic array, if thearray is no longer needed. To do so, simply call the delete[]operator. The braces []tell the compiler to release the whole array, and not just a single array element.Example:delete[] pk;The operand for delete[]—the pointer pkin this case—mustreference the place inmemory that was allocated by a call to new[]! The destructor belonging to the currentclass is called for each array element. This shows the big difference to delete, whichwould merely call the destructor for *pk, i.e. for the first array element.The program on the opposite page stores numbers in a dynamic array. The size of thearray is adjusted as required. To do so, a newer bigger array is created, the data is copied
to the new array, and the memory occupied by the old array is released.
462CHAPTER 21DYNAMIC MEMORY ALLOCATION
firstlast
1st element2nd element3rd element
InfoInfoInfo
firstNew lastelementlast1st element2nd element3rd element
InfoInfo
InfoInfoAPPLICATION:LINKED LISTS
A simple linked list
Appending a list elementDeleting a list elementfirstRemovedelementNew firstelementNew secondelementInfoInfoInfo
Info
APPLICATION: LINKED LISTS463Dynamic Data Structures
Now, let’s implement a linked list as a sample application. A linked listis a dynamic datastructure that allows easy insertion and deletion of data. A data structure defines how datacan be organized in units, stored, and manipulated—as arrays, lists, or trees, for example.The type of data structure you choose has a far-reaching effect on the amount ofmemory you need, the speed of access to the data involved, and the complexity (or sim-
plicity) of the algorithms (data operations) you need.In contract to a staticdata structure, whose size is known before a program islaunched, a dynamicdata structure can change size while a program is running. Oneexample of this is an array whose size can be changed during runtime.Defining a Linked List
Another example is a linked list that is stored in main memory and has the followingcharacteristics:each list element contains a data store for the live data and a pointer to the next
element in the listeach list element—except the first and last elements—has exactly one predeces-
sor and one successor. The first element in the list has no predecessor and the last
element no successor.Someelementary operations are defined for linked lists, such as inserting and deleting listelements, or searching for and retrieving the information stored in a list element.Advantages
The storage used for the list elements need not be contiguous. The main advantage oflinked lists is:memory for the list elements is only allocated when neededyou only need to move a pointer when inserting or deleting list elements.When an array element is inserted or deleted, the other array elements have to be movedto make room or fill up the “gap” in the array. If there is no room left, you need to allo-
cate memory for a new array and copy the data to it before inserting a new element.
464CHAPTER 21DYNAMIC MEMORY ALLOCATION
// List.h// Defines the classes ListEl and List.// ---------------------------------------------------
#ifndef _LISTE_H_#define _LISTE_H_#include "Date.h"         // Class Date from Chapter 14#include <iostream>#include <iomanip>using namespace std;class ListEl// A list element.{private:Date  date;             // Datedouble amount;          // Amount of money
ListEl* next;           // Pointer to successorpublic:ListEl( Date   d = Date(1,1,1), double  b = 0.0,ListEl* p = NULL)
: date(d), amount(b), next(p) {}// Access methods:// getDate(), setDate(), getAmount(), setAmount()
ListEl* getNext() const { return next; }friend class List;};// ----------------------------------------------------// Defining the class Listclass List{private:ListEl* first, *last;public:List(){ first = last = NULL; }  // Constructor~List();// Destructor// Access to the first and last elements:
ListEl* front()const { return first; }ListEl* back()const { return last; }// Append a new element at the end of the list:void pushBack(const Date& d, double b);// Delete an element at the beginning of the list
void popFront();};#endif  // _LIST_H_REPRESENTING A LINKED LIST
Classes of header file List.h
REPRESENTING A LINKED LIST465Representing List Elements
You can use a recursive data structure to represent a linked list. A recursive data structureis a data structure containing a pointer to a data structure of the same type. Of course,
the data structure cannot contain itself—that would be impossible—but it does contain a
pointer to itself.Now let’s look at a linked list used to represent transactions in a bank account. Atransaction is characterized by a date, a sum of money, and the reason for the transac-
tion. Thus, the list element needed to represent a transaction will contain the transac-
tion data in its data store and a pointer to the next element in the list.The class shown on the opposite page, ListEl, was designed to represent list ele-ments. To keep things simple, the data store contains only the date and a sum of money.
Thepublicdeclaration includes a constructor and access methods for the live data.Later, we will be overloading the <<operator in order to output the list.It is common practice to let the pointer for the last element in the list point to NULL.This also provides a termination criterion—the nextpointer just needs to be queried forNULL.Representing a List
To identify a linked list, you just point a pointer at the first element in the list. You canthen use the pointer to the successor of each element to address any element in the list.
A pointer to the last element in the list is useful for appending new elements.The opposite page shows the class definition for the Listclass. The private sectioncomprises two pointers, which reference the first and last list elements respectively. The
constructorhas an easy job—it simply points both pointers to NULL, thus creating anempty list. The destructorhas a more complex task: it has to release the memory occupiedby the remaining list elements.ThepushBack()method is used to appenda new element to the end of the list. Todo so, memory is allocated dynamically and the new element becomes the successor of
what was previously the last element and the lastpointer is updated. In addition, themethod must deal with a special case, where the list is empty.ThepopFront()method deletes the first element in the list. This involves turningthe pointer to the first element around to the second element and releasing the memory
occupied by the first element. The special case with an empty list also applies.
exercises
466CHAPTER 21DYNAMIC MEMORY ALLOCATION
EXERCISESNotes on exercise 1
Effects of the splice()functionInsertPositionResult1st Array
2nd Array
735962
91426835
73914268355962

EXERCISES467Exercise 1
Write a global function called splice()that “splices” two 
intarrays together
by first allocating memory for a dynamic array with enough room for both 
intarrays,and then copying the elements from both arrays to the new array,as

follows:
first,the elements of the first array are inserted up to a given position,
then the second array is inserted,
then the remainder of the first array is appended.
Arguments:The two 
intarrays,their length,and the position at which
they are to be spliced.
Return value:A pointer to the new array
Exercise 2
Write a global function called merge()that merges two sorted 
intarrays by
first allocating memory for a dynamic array with enough room for both 
intarrays and then inserting the elements of both arrays into the new array in

sequence.
Arguments:The two 
intarrays and their length.
Return value:A pointer to the new array
To test the function,modify the program used to sort arrays in Exercise 4 of
Chapter 17.
Exercise 3
Complete and test the implementation of a linked list found in this chapter.
First define the access methods shown opposite.Then overload the 
<<operator for the class 
ListElto allow formatted output of the data in
the list elements.You can use the 
asString()in the date class to do so.
Then implement the destructor for the 
Listclass.The destructor will
release the memory used by all the remaining elements.Make sure that

you read the pointer to the successor of each element before destroying

it!Implement the methods pushBack()andpopFront()used for append-
ing and deleting list elements.Overload the operator 
<<in the Listclass to output all the data stored
in the list.Test the 
Listclass by inserting and deleting several list elements and
repeatedly outputting the list.

solutions
468CHAPTER 21DYNAMIC MEMORY ALLOCATION
SOLUTIONSExercise 1
// ----------------------------------------------------//Splice.cpp// Implements the splice algorithm.// ----------------------------------------------------
#include <iostream>#include <iomanip>#include <cstdlib>         // For srand() and rand()
#include <ctime>           // and for time().using namespace std;// Prototype:int *splice( int v1[], int len1,int v2[], int len2, int pos);int main(){cout << "\n  * * * Testing the splice function * * *\n"<< endl;int i, len1 = 10, len2 = 5;int *a1 = new int[len1],*a2 = new int[len2];// Initialize the random number generator
// with the current time:srand( (unsigned)time(NULL));for( i=0; i < len1; ++i)    // Initialize the arrays:a1[i] = rand();          // with positive andfor( i=0; i < len2; ++i)a2[i] = -rand();         // negative numbers.// To output the array:cout << "1. array: " << endl;
for( i = 0; i < len1; ++i)cout << setw(12) << a1[i];cout << endl;
cout << "2. array: " << endl;for( i = 0; i < len2; ++i)cout << setw(12) << a2[i];cout << endl;cout << "\n At what position do you want to insert ""\n the 2nd array  into 1st  array?"
"\n Possible positions: 0, 1, ..., " << len1<< " : ";int pos;  cin >> pos;
SOLUTIONS469int *a3, len3 = len1 + len2;a3   = splice( a1, len1, a2, len2, pos);if( a3 == NULL)cerr << "\n Invalid position!\n" << endl;else{cout << " The new spliced array: " << endl;
for( i = 0; i < len3; ++i)cout << setw(12) << a3[i];cout << endl;}
delete[] a1;   delete[] a2;   delete[] a3;
return 0;}// -------------------------------------------------------//Function splice() inserts the array v2 into v1//  starting at position pos.int *splice( int v1[], int len1,int v2[], int len2, int pos){if( pos < 0  ||  pos > len1)return NULL;int i = 0, i1 = 0, i2 = 0;int *v = new int[len1+len2];for( i = 0, i1 = 0; i1 < pos;  ++i, ++i1) // 1st partv[i] = v1[i1];for( i2 = 0; i2 < len2;  ++i, ++i2)       // 2nd partv[i] = v2[i2];for(  ; i1 < len1;  ++i, ++i1)            // 3rd partv[i] = v1[i1];return v;}
470CHAPTER 21DYNAMIC MEMORY ALLOCATION
Exercise 2
// ----------------------------------------------------//merge.cpp// Implements the merge algorithm.
// ----------------------------------------------------
#include <iostream>#include <iomanip>#include <cstdlib>
#include <ctime>using namespace std;// Prototypes:void selectionSort( int arr[], int len);int *merge( int v1[], int len1, int v2[], int len2);int main(){cout << "\n  * * *  The Merge Algorithm  * * *\n"<< endl;int i, len1 = 10, len2 = 20;int *a1 = new int[len1],*a2 = new int[len2];// Initialize the random number generator// with the current time:
srand( (unsigned)time(NULL));for( i=0; i < len1; ++i)   // Initialized arrays:a1[i] = rand();for( i=0; i < len2; ++i)a2[i] = rand();selectionSort( a1, len1);// To sort array a1.selectionSort( a2, len2);// To sort array a2.// Output the arrays:cout << "The sorted arrays:" << endl;cout << "1st array: " << endl;
for( i = 0; i < len1; ++i)cout << setw(12) << a1[i];cout << endl;
cout << "2nd array: " << endl;
for( i = 0; i < len2; ++i)cout << setw(12) << a2[i];cout << endl;
int *a3, len3;a3   = merge( a1, len1, a2, len2);len3 = len1 + len2;
SOLUTIONS471cout << "The new merged array: " << endl;for( i = 0; i < len3; ++i)cout << setw(12) << a3[i];cout << endl;delete[] a1;   delete[] a2;   delete[] a3;return 0;}
// ------------------------------------------------------
// Function selectionSort().
inline void swap( int& a, int& b)      // To swap.
{  int temp = a;  a = b;  b = temp;  }void selectionSort( int *arr, int len){register int *p, *minp;   // Pointer to array elements,int *last = arr + len-1;  // Pointer to the last elementfor( ; arr < last;  ++arr)
{minp = arr;                     // Search minimumfor( p = arr+1; p <= last; ++p) // starting atif( *minp > *p)              // position arr.minp = p;swap( *arr, *minp);             // To swap.}}// ------------------------------------------------------//merge(): Merges two sorted arrays to create//           a new sorted array.int *merge( int v1[], int len1, int v2[], int len2){int i = 0, i1 = 0, i2 = 0;
int *v = new int[len1+len2];    // New int array.for( i=0; i1 < len1 && i2 < len2; ++i){if( v1[i1] <= v2[i2])v[i] = v1[i1++];elsev[i] = v2[i2++];}if( i1 < len1)        // Copy the rest of v1 or v2.while( i1 < len1)v[i++] = v1[i1++];elsewhile( i2 < len2)v[i++] = v2[i2++];return v;}
472CHAPTER 21DYNAMIC MEMORY ALLOCATION
Exercise 3
// ----------------------------------------------------//date.h:   Defines the class Date.// ----------------------------------------------------
//date.cpp// Implements the methods of class Date,// which are not inline defined.// ----------------------------------------------------
//// These files are left unchanged// from Chapter 14 (solutions).
//// ----------------------------------------------------//List.h// Defines the classes ListEl and List
// to represent a linked list.// ----------------------------------------------------
#ifndef _LIST_H_#define _LIST_H_#include "Date.h"
#include <iostream>#include <iomanip>using namespace std;class ListEl{private:Date  date;           // Date
double amount;        // Amount of money
ListEl* next;         // Pointer to successorpublic:ListEl( Date   d = Date(1,1,1),double  b = 0.0,ListEl* p = NULL): date(d), amount(b), next(p) {}// Access methodsconst Date& getDate() const { return date; }void setDate()        // Sets the current date
{date.setDate();}
bool setDate( int day, int month, int year){return setDate( day, month, year);}
SOLUTIONS473double  getAmount() const { return amount; }void    setAmount(double a) { amount = a; }
ListEl* getNext()  const { return next; }friend class List;};// Output an elementostream& operator<<( ostream& os, const ListEl& le);// ------------------------------------------------------// Defines the List class
class List
{private:ListEl* first, *last;public:List(){ first = last = NULL; }  // Constructor~List();                        // Destructor// Access first and last elements:ListEl* front()const { return first; }ListEl* back() const { return last; }// Appends a new element at the end of the list:
void pushBack(const Date& d, double b);
// Deletes an element at the beginning of the list.
void popFront();};// Outputs the listostream& operator<<( ostream& os, const List& le);#endif  // _LIST_H_// ----------------------------------------------------//List.cpp// Implements the methods of class List,
// which are not previously defined inline.// ----------------------------------------------------#include "List.h"
// Destructor of the list:
List::~List(){ListEl *pEl = first,  *next = NULL;
for(  ; pEl != NULL;  pEl = next){next = pEl->next;
delete pEl;}}
474CHAPTER 21DYNAMIC MEMORY ALLOCATION
// Appends a new element at the end of the list:void List::pushBack(const Date& d, double b)
{ListEl *pEl = new ListEl( d, b);if( last == NULL)       // List empty?first = last = pEl;elselast->next = pEl,  last = pEl;}// Deletes an element from the beginning of the list.void List::popFront()
{if( first != NULL)       // Not empty?{ListEl *pEl = first;   // Save the first element.first = first->next;   // Move to the next element.delete pEl;            // Former first element
if( first == NULL)     // Empty now?last = NULL;}}// --- Global functions for output ---// Outputs an element:
ostream& operator<<( ostream& os, const ListEl& le){os << le.getDate().asString() << "  Amount: ";
os << fixed << setprecision(2) << setw(10)<< le.getAmount();return os;}// Outputs the list:ostream& operator<<( ostream& os, const List& List)
{ListEl *pEl = List.front();if( pEl == NULL)os << "The list is empty!" << endl;for(  ; pEl != NULL;  pEl = pEl->getNext() )os << *pEl << endl;return os;}
SOLUTIONS475// -------------------------------------------------------//List_t.cpp//  Tests the List class.
// -------------------------------------------------------#include "List.h"
int main(){cout << "\n * * *  Testing the class list  * * *\n"<< endl;List  aList;               // A list
cout << aList << endl;     // List is still empty.
cout << "\nEnter account changes (Date and Amount)""\n(Type invalid input to quit, e.g. q):\n";Date date;int month, day, year;   char c;double amount;while( true){cout << "Date format Month-Day-Year : ";
if( !(cin >> month >> c >> day >> c >> year)|| ! date.setDate( month, day, year) )break;                            // Invalid date.cout << "Account change: ";if( !(cin >> amount) ) break;aList.pushBack( date, amount);}cout << "\nContent of the list:\n";cout << aList << endl;cout << "\nRemoving the first element of the list:\n";
ListEl *ptrEl = ptrEl = aList.front();if( ptrEl != NULL)
{cout << "Deleting:  " << *ptrEl << endl;
aList.popFront();}cout << "\nContent of the list:\n";cout << aList << endl;return 0;}
This page intentionally left blank 
477Dynamic MembersThis chapter describes how to implement classes containing pointers to
dynamically allocated memory.These include
your own copy constructor definition and
overloading the assignment operator.
A class designed to represent arrays of any given length is used as a

sample application.chapter
22
478CHAPTER 22DYNAMIC MEMBERS
4.16.58.22.7
...ObjectfArrarrPtrmax:  10cnt:  4// A class representing dynamic arrays of floats.// ---------------------------------------------------class FloatArr{private:float* arrPtr; // Dynamic memberint max;          // Maximum quantity without// reallocating new storage.int cnt;          // Number of present elementspublic:// Public methods here};MEMBERS OF VARYING LENGTH
An object of class FloatArrin memory
Data members of class 
FloatArr
MEMBERS OF VARYING LENGTH479Dynamic MembersYou can exploit the potential of dynamic memory allocation to leverage existing classesand create data members of variable length. Depending on the amount of data an appli-
cation program really has to handle, memory is allocated as required while the applica-
tion is running. In order to do this the class needs a pointer to the dynamically allocated
memory that contains the actual data. Data members of this kind are also known as
dynamicmembers
of a class.When compiling a program that contains arrays, you will probably not know howmany elements the array will need to store. A class designed to represent arrays should
take this point into consideration and allow for dynamically defined variable length
arrays.Requirements
In the following section you will be developing a new version of the FloatArrclass tomeet these requirements and additionally allow you to manipulate arrays as easy as fun-
damental types. For example, a simple assignment should be possible for two objects v1andv2in the new class.Example:v2 = v1;The object v2itself—and not the programmer—will ensure that enough memory isavailable to accommodate the array v1.Just as in the case of fundamental types, it should also be possible to use an existingobject,v2, to initialize a new object, v3.Example:FloatArr v3(v2);Here the object v3ensures that enough memory is available to accommodate the arrayelements of v2.When an object of the FloatArris declared, the user should be able to define theinitial length of the array. The statementExample:FloatArr fArr(100);allocates memory for a maximum of 100 array elements.The definition of the FloatArrclass therefore comprises a member that addresses adynamically allocated array. In addition to this, two intvariables are required to storethe maximum and current number of array elements.
480CHAPTER 22DYNAMIC MEMBERS
// floatArr.h : Dynamic array of floats.// ---------------------------------------------------#ifndef _FLOATARR_
#define _FLOATARR_class FloatArr{private:float* arrPtr;    // Dynamic memberint max;          // Maximum quantity without// reallocation of new storage.int cnt;          // Number of array elementspublic:FloatArr( int n = 256 );// ConstructorFloatArr( int n, float val);~FloatArr();// Destructorint  length() const { return cnt; }float& operator[](int i);// Subscript operator.float  operator[](int i) const;bool append(float val);// Append value val.bool remove(int pos);// Delete position pos.};#endif   // _FLOATARR_#include "floatArr.h"#include <iostream>using namespace std;int main()
{FloatArr v(10);// Array v of 10 float valuesFloatArr w(20, 1.0F);// To initialize array w of// 20 float values with 1.0.v.append( 0.5F);
cout << " Current number of elements in v: "<<v.length()<< endl;                 //   1cout << " Current number of elements in w: "<<w.length()<< endl;                 //  20return 0;}CLASSES WITH A DYNAMIC MEMBER
First version of class 
FloatArrCreating objects with dynamic members

CLASSES WITH A DYNAMIC MEMBER481The next question you need to ask when designing a class to represent arrays is whatmethods are necessary and useful. You can enhance FloatArrclass step by step by opti-mizing existing methods or adding new methods.The first version of the FloatArrclass comprises a few basic methods, which areintroduced and discussed in the following section.Constructors
It should be possible to create an object of the FloatArrclass with a given length andstore a floatvalue in the object, if needed. A constructor that expects an intvalue asan argument is declared for this purpose.FloatArr(int n = 256);The number 256is the default argument for the length of the array. This provides for adefault constructor that creates an array with 256empty array elements.An additional constructorFloatArr( int n, int val );allows you to define an array where the given value is stored in each array element. In
this case you need to state the length of the array.Example:FloatArr arr( 100, 0.0F));This statement initializes the 100 elements in the array with a value of 0.0.Additional Methods
Thelength()method allows you to query the number of elements in the array.arr.length()returns a value of 100for the array arr.You can overload the subscript operator []to access individual array elements.Example:arr[i] = 15.0F;The index imust lie within the range 0tocnt-1.Theappend()method can be used to append a value to the array. The number ofelements is then incremented by one.When you call the remove()method it does exactly the opposite of append()—deleting the element at the stated position. This reduces the current count by one, pro-
vided a valid position was stated.
482CHAPTER 22DYNAMIC MEMBERS
ObjectfArrarrPtrmax:  10cnt:  10??????????
ObjectfArrarrPtrmax:  10cnt:  10CREATING AND DESTROYING OBJECTS
Effects of the declaration 
FloatArr fArr( 10, 1.0F ); First, memory is allocated for the data members:Then storage is allocated for 10 array elements and the variables maxandcntare set to10:Finally, a value of 1.0 is used to initialize the array elements:1.01.01.01.01.01.01.01.01.01.0
ObjectfArrarrPtrmax:  10cnt:  10
CREATING AND DESTROYING OBJECTS483The memory for the array elements is not contained in a FloatArrobject and must beallocated dynamically by the constructor. The object itself only occupies the memory
required for the data members arrPtr,max,and 
cnt. Thus, sizeof(FloatArr)is aconstant value that defaults to 12 bytes for 32 bit computers.The additional dynamic memory allocation may need to be adjusted to meet newrequirements, for example, if an assignment is made. Finally, the memory has to be
released explicitly when an object is destroyed.Constructing an Object
The first constructor in the FloatArrclass is defined as follows:FloatArr::FloatArr( int n ){max = n;   cnt = 0;
arrPtr = new float[max];}This allocates memory for narray elements. The current number of array elements is setto0.The second constructor fills the array with the supplied value and is therefore definedas follows:FloatArr::FloatArr(int n, float val){max = cnt = n;
arrPtr  = new float[max];
for( int i=0; i < cnt; ++i)arrPtr[i] = val;}The opposite page shows how memory is allocated for the object fArrand how thisobject is initialized.Destroying an Object
When an object is destroyed the dynamic memory the object occupies must be released.Classes with dynamic members will alwaysneed a destructor to perform this task.TheFloatArrclass contains a dynamic array, so memory can be released by a call tothedelete[]operator.FloatArr::~FloatArr(){delete[] arrPtr;}
484CHAPTER 22DYNAMIC MEMBERS
// FloatArr.cpp:// Implementing the methods of class FloatArr.
// -----------------------------------------------------
#include "floatArr.h"
#include <iostream>using namespace std;//Constructors and destructoras before.// Subscript operator for objects that are not const:
float& FloatArr::operator[]( int i ){if( i < 0 || i >= cnt )       // Range checking
{cerr << "\n class FloatArr: Out of range! ";exit(1);}return arrPtr[i];}float FloatArr::operator[]( int i ) const{// Else as before.}bool FloatArr::append( float val){if(cnt < max){arrPtr[cnt++] = val;  return true;}else                         // Enlarge the array!return false;}bool FloatArr::remove(int pos){if( pos >= 0 && pos < cnt)
{for( int i = pos; i < cnt-1; ++i)arrPtr[i] = arrPtr[i+1];--cnt;return true;}elsereturn false;}IMPLEMENTING METHODSNew version of class 
FloatArr
IMPLEMENTING METHODS485Read and Write Access Using the Subscript Operator
The subscript operator can be overloaded to allow easy manipulation of array elements.Example:FloatArr v(5, 0.0F);v[2] = 2.2F;
for( int i=0; i < v.length(); ++i)cout << v[i];The operator allows both read and write access to the array elements and cannot be usedfor constant objects for this reason. However, you will need to support read-only access
to constant objects.TheFloatArrclass contains two versions of the operator function operator[]()for this purpose. The first version returns a reference to the i-th array element and thussupports write access. The second, read-only version only supports read access to the
array elements and is automatically called by the compiler when accessing constant
objects.The implementation of these versions is identical. In both cases range checking isperformed for the index. If the index lies within the valid boundaries, an array element—
or simply a value in the case of the read-only version—is returned.Appending and Deleting in Arrays
TheFloatArrclass comprises the methods append()andremove()for appendingand deleting array elements.In the first version, the append()only works if there is at least one empty slot in thearray. In the exercises, append()is used to extend the array as required. This alsoapplies for a new method, insert(), which you will write as an exercise in this chapter.When the remove()method is used to delete an element, the elements followingthe deleted element move up one place, preserving the original order. The current count
is decremented by one. What was formerly the last element in the array is not deleted
but overwritten when a new element is inserted.Another technique would be to copy the last element to the position of the elementthat needs to be deleted, simply overwriting that element. Of course, this technique is
quicker and preferable for cases where the order of the elements is not significant.
486CHAPTER 22DYNAMIC MEMBERS
4.16.58.22.7
ObjectaarrPtrmax:  10cnt:  4ObjectbarrPtrmax:  10cnt:  4//floatArr.cpp: Implementing the methods.// ----------------------------------------------------FloatArr::FloatArr(const FloatArr& src){max = src.max;     cnt = src.cnt;arrPtr = new float[max];for( int i = 0; i < cnt; i++ )arrPtr[i] = src.arrPtr[i];}COPY CONSTRUCTOR
Effect of the standard copy constructor
FloatArr b(a);         // Creates a copy of a.A self-defined copy constructor for class 
FloatArr
COPY CONSTRUCTOR487Initializing with an ObjectThe next step is to ensure that an existing object can be used to initialize a new object.Given an array, a, the following statement should be valid:Example:FloatArr b(a);The array bshould now be the same length as the array aand the array elements in bshould contain the same values as in a.TheFloatArrclass needs a copy constructor to perform this task. The constructorhas a reference to a constant array as a parameter.Prototype:
FloatArr( const FloatArr& );Standard Copy Constructor
If a class does not contain a copy constructor, the compiler will automatically create aminimal version, known as the standard copy constructor. This constructor copies the datamembers of the object passed to it to corresponding data members of the new object.A standard copy constructor is normally sufficient for a class. However, simply copy-ing the data members would serve no useful purpose for objects containing dynamic
members. This would merely copy the pointers, meaning that the pointers of several dif-
ferent objects would reference the same place in memory. The diagram on the opposite
page illustrates this situation for two FloatArrclass objects.This scenario would obviously mean trouble. Imagine releasing memory allocated foran object dynamically. The pointer for the second object would reference a memory area
that no longer existed!Proprietary Version of the Copy Constructor
Clearly you will need to write a new copy constructor for classes with dynamic members,ensuring that the live data and not just the pointers are copied from the dynamically
allocated memory.The example on the opposite page shows the definition of the copy constructor fortheFloatArrclass. Calling new[]creates a new array and the array elements of theobject passed to the method are then copied to that array.
488CHAPTER 22DYNAMIC MEMBERS
// FloatArr.h : Dynamic arrays of floats.// ---------------------------------------------------class FloatArr{private:// . . . Data members as beforepublic:// . . . Methods as before and
FloatArr(const FloatArr& src); // Copy constructorFloatArr& operator=( const FloatArr&);// Assignment};// In file floatArr.cpp// The operator function implementing "=".
// ---------------------------------------------------
FloatArr& FloatArr::operator=( const FloatArr& src ){if( this != &src )             // No self assignments!{max = src.max;cnt = src.cnt;
delete[] arrPtr;             // Release memory,arrPtr = new float[max];     // reallocate andfor( int i=0; i < cnt; i++)  // copy elements.arrPtr[i] = src.arrPtr[i];}return *this;}#include "FloatArr.h"int main(){FloatArr v;            // Default constructor.
FloatArr w(20, 1.0F);  // Array w  - 20 float values// with initial value 1.0.const FloatArr kw(w); // Use copy constructor// to create an object.v = w; // Assignment.}ASSIGNMENTNew declarations in class 
FloatArrDefining the assignmentSample calls
ASSIGNMENT489Each class comprises four implicitly defined default methods, which you can replace withyour own definitions:the default constructor and the destructorthe copy constructor and the standard assignmentIn contrast to initialization by means of the copy constructor, which takes place when anobject is defined, an assignment always requires an existing object. Multiple assignments,
which modify an object, are possible.Default AssignmentGiven that v1andv2are two FloatArrclass objects, the following assignment isvalid:Example:v1 = v2;            // Possible, but ok?Default assignment is performed member by member. The data members of v2are copiedto the corresponding data members of v1just like the copy constructor would copythem. However, this technique is not suitable for classes with dynamic members. This
would simply point the pointers belonging to different objects at the same dynamic allo-
cated memory. In addition, memory previously addressed by a pointer of the target object
will be unreferenced after the assignment.Overloading the Assignment Operator
In other words, you need to overload the default assignment for classes containingdynamic members. Generally speaking, if you need to define a copy constructor, you will
also need to define an assignment.The operator function for the assignment must perform the following tasks:release the memory referenced by the dynamic membersallocate sufficient memory and copy the source object’s data to that memory.The operator function is implemented as a class method and returns a reference to thetarget object allowing multiple assignments. The prototype of the operator function for
theFloatArrclass is thus defined as follows:FloatArr& FloatArr::operator=( const FloatArr& src)When implementing the operator function you must avoid self assignment, which would
read memory areas that have already been released.
exercises
490CHAPTER 22DYNAMIC MEMBERS
// Copy constructor:List::List(const List&);// Assignment:List& List::operator=( const List&);// Methods to append a float or an// array of floats:void append( float val);
void append( const FloatArr& v);FloatArr& operator+=( float val);FloatArr& operator+=( const FloatArr& v);// Methods to insert a float or an// array of floats:
bool insert( float val, int pos);
bool insert( const FloatArr& v, int pos );// In any case, more memory space must be allocated// to the array if the current capacity is
// insufficient.EXERCISESNew methods of class 
ListNew methods of class 
FloatArr
EXERCISES491Thewidth()method in the ostreamclass returns the current field width, if you call the methodwithout any arguments.NOTE
Exercise 1
Complete the definition of the Listclass,which represents a linked list and test
the class.First,modify your test program to create a copy of a list.Call the default
assignment for the objects in the 
Listclass.Note how your program reacts.
A trial run of the program shows that the class is incomplete.Since the class
contains dynamic members,the following tasks must be performed:
Define a copy constructor for the 
Listclass.Overload the assignment operator.
Exercise 2
Add the methods shown opposite to the 
FloatArrclass.In contrast to the
existing methodbool append( float val);the new method must be able to allocate more memory as required.As this

could also be necessary for other methods,write a private auxiliary function for

this purposevoid expand( int newMax );The method must copy existing data to the newly allocated memory.
Overload the operator 
+=so it can be used instead of calling the functionappend().Theinsert()method inserts a 
floatvalue or a FloatArrobject atpositionpos.Any elements that follow 
posmust be pushed.
Also overload the shift operator 
<<to output an array using the field width
originally defined to output the array elements.
Now add calls to the new methods to your test program and output the results
after each call.
solutions
492CHAPTER 22DYNAMIC MEMBERS
SOLUTIONSExercise 1
// ----------------------------------------------------//List.h// Definition of classes ListEl and List// representing a linked list.// ---------------------------------------------------
#ifndef _LIST_H_#define _LIST_H_
#include "Date.h"#include <iostream>#include <iomanip>using namespace std;class ListEl{// Unchanged as in Chapter 21};// ------------------------------------------------------// Definition of class List
class List{private:ListEl* first, *last;public:// New methods:List(const List&); // Copy constructorList& operator=( const List&); // Assignment// Otherwise unchanged from Chapter 21};
#endif  // _LIST_H_// ----------------------------------------------------//List.cpp// Implements those methods of class List,// that are not defined inline.// ----------------------------------------------------
#include "List.h"// Copy constructor:List::List(const List& src)
{// Appends the elements of src to an empty list.first = last = NULL;
ListEl *pEl = src.first;
for(  ; pEl != NULL;  pEl = pEl->next )pushBack( pEl->date, pEl->amount);}
SOLUTIONS493// Assignment:List& List::operator=( const List& src)
{// Release memory for all elements:ListEl *pEl = first,*next = NULL;for(  ; pEl != NULL;  pEl = next){next = pEl->next;
delete pEl;}
first = last = NULL;// Appends the elements of src to an empty list.pEl = src.first;
for(  ; pEl != NULL;  pEl = pEl->next )pushBack( pEl->date, pEl->amount);return *this;}// All other methods unchanged.// -------------------------------------------------------//List_t.cpp//  Tests the class List with copy constructor and//  assignment.// -------------------------------------------------------
#include "List.h"int main(){cout << "\n * * *  Testing the class List  * * *\n"<< endl;List  list1;                 // A list
cout << list1 << endl;       // The list is still empty.Date date( 11,8,1999);       // Insert 3 elements.double amount( +1234.56);list1.pushBack( date, amount);date.setDate( 1, 1, 2002);amount = -1000.99;list1.pushBack( date, amount);date.setDate( 2, 29, 2000);amount = +5000.11;
list1.pushBack( date, amount);
494CHAPTER 22DYNAMIC MEMBERS
cout << "\nThree elements have been inserted!""\nContent of the list:" << endl;cout << list1 << endl;cout << "\nPress return to continue! "; cin.get();
List list2( list1);cout << "A copy of the 1st list has been created!\n""Contents of the copy:\n" << endl;cout << list2 << endl;cout << "\nRemove the first element from the list:\n";ListEl *ptrEl = ptrEl = list1.front();if( ptrEl != NULL)
{cout << "To be deleted:  " << *ptrEl << endl;list1.popFront();}cout << "\nContent of the list:\n";
cout << list1 << endl;list1 = list2;          // Reassign the copy.cout << "The copy has been assigned to the 1st list!\n""Contents after assignment:\n" << endl;cout << list1 << endl;return 0;}
SOLUTIONS495Exercise 2
// ------------------------------------------------------//floatArr.h: Dynamic arrays of floating-point numbers.// ------------------------------------------------------
#ifndef _FLOATARR_
#define _FLOATARR_#include <iostream>using namespace std;class FloatArr{private:float* arrPtr;    // Dynamic member
int max;          // Maximum quantity without// reallocating new storage.int cnt;          // Number of present array elementsvoid expand( int newMax);   // Helps enlarge the arraypublic:// Constructors , destructor,
// assignment, subscript operator, and method length()
// as before in this chapter.// Methods to append a floating-point number// or an array of floating-point numbers:
void append( float val);
void append( const FloatArr& v);
FloatArr& operator+=( float val){append( val);   return *this;}FloatArr& operator+=( const FloatArr& v){append(v);   return *this;}// Methods to insert a floating-point number// or an array of floating-point numbers:
bool insert( float val, int pos);
bool insert( const FloatArr& v, int pos );bool remove(int pos);     // Delete at position pos.// To output the array
friend ostream& operator<<( ostream& os,const FloatArr& v);};
#endif   // _FLOATARR_
496CHAPTER 22DYNAMIC MEMBERS
// -----------------------------------------------------//FloatArr.cpp// Implements the methods of FloatArr.// -----------------------------------------------------#include "floatArr.h"//  Constructors, destructor, assignment,//  and subscript operator unchanged.//  ---  The new functions  ---// Private auxiliary function to enlarge the array.void FloatArr::expand( int new){if( newMax == max)return;max = newMax;
if( newMax < cnt)cnt = newMax;float *temp = new float[newMax];
for( int i = 0; i < cnt; ++i)temp[i] = arrPtr[i];delete[] arrPtr;arrPtr = temp;}// Append floating-point number or an array of floats.void FloatArr::append( float val){if( cnt+1 > max)expand( cnt+1);arrPtr[cnt++] = val;}void FloatArr::append( const FloatArr& v){if( cnt + v.cnt > max)expand( cnt + v.cnt);int count = v.cnt;            // Necessary if v == *thisfor( int i=0; i < count; ++i)arrPtr[cnt++] = v.arrPtr[i];}
SOLUTIONS497// Insert a float or an array of floatsbool FloatArr::insert( float val, int pos)
{return insert( FloatArr(1,val), pos);}bool FloatArr::insert( const FloatArr& v, int pos ){if( pos < 0 || pos >= cnt)return false;              // Invalid positionif( max < cnt + v.cnt)expand(cnt + v.cnt);int i;for( i = cnt-1; i >= pos; --i)    // Shift uparrPtr[i+v.cnt] = arrPtr[i];   // starting at posfor( i = 0; i < v.cnt; ++i)       // Fill gap.arrPtr[i+pos] = v.arrPtr[i];cnt = cnt + v.cnt;return true;}// To deletebool FloatArr::remove(int pos)
{if( pos >= 0 && pos < cnt){for( int i = pos; i < cnt-1; ++i)arrPtr[i] = arrPtr[i+1];--cnt;return true;}elsereturn false;}// Output the arrayostream& operator<<( ostream& os, const FloatArr& v)
{int w = os.width();            // Save field width.for( float *p = v.arrPtr; p < v.arrPtr + v.cnt; ++p)
{os.width(w);    os << *p;}
return os;}
498CHAPTER 22DYNAMIC MEMBERS
// -----------------------------------------------------//FloatV_t.cpp// Tests the class FloatArr.
// -----------------------------------------------------
#include "FloatArr.h"
#include <iostream>
#include <iomanip>
using namespace std;int main(){FloatArr v(10);        // Array v for 10 float values
FloatArr w(15, 1.0F);  // Initialize the array w of// 15 float values with 1.0.cout << " Current total of elements in v: "<< v.length() << endl;cout << " Current total of elements in w: "<< w.length() << endl;float x = -5.0F;             // Append values.for( ; x < 6 ; x += 1.7F)v.append(x);v += v;                      // Also possible!
cout << "\nThe array elements after appending:"<< endl;cout << setw(5) << v << endl;const FloatArr cv(v);        // Copy constructor// creates const object.cout << "\nThe copy of v has been created.\n";
cout << "\nThe array elements of the copy:\n"<< setw(5) << v << endl;w.remove(3);           // Erase the element at// position 3.w.append(10.0F);       // Add a new element.
w.append(20.0F);       // And once more!v = w;cout << "\nAssignment done.\n";
cout << "\nThe elements after assigning: \n"<< setw(5) << v << endl;v.insert( cv, 0);
cout << "\nThe elements after inserting "" the copy at position 0: \n"<< setw(5) << v << endl;return 0;}
499InheritanceThis chapter describes how derived classes can be constructed from
existing classes by inheritance.Besides defining derived classes,we will

also discusshow members are redefined
how objects are constructed and destroyed,and
how access control to base classes can be realized.
chapter
23
500CHAPTER 23INHERITANCE
CONCEPT OF INHERITANCE
Is relation
CarPropertiesand capacitiesof classCarPropertiesand capacitiesof classCarPropertiesand capacitiesof classCarAdditionalproperties andcapacities of classPassCarAdditionalproperties andcapacities of classTruckPassCarTruck

CONCEPT OF INHERITANCE501Base Classes and Derived Classes
Inheritance allows new classes to be constructed on the basis of existing classes. The newderived class“inherits” the data and methods of the so-called base class. But you can addmore characteristics and functionality to the new class.A fleet management program used by a car hire company needs to handle all kinds ofvehicles—automobiles, motorcycles, trucks, and so on. All of these vehicles have an
identification number that indicates the vehicle, the manufacturer, and the vehicle sta-
tus, such as “hired,” “repair shop,” and so on. Additionally, operations such as “modify
status” are required for the class.To differentiate between vehicle types, various classes are derived from the base classCar, such as PassCar, which is used to represent passenger-carrying vehicles. This classhas additional attributes, such as the number of seats, type, sunroof (yes/no), and various
additional operations.Is Relationship
An object of the PassCartypeisa special object of the Carclass. A passenger vehicleis a special kind of car. In cases like this we can say that the derived class establishes an isrelationship to the base class.We distinguish between this close relationship and a so-called hasrelationship. Asalready mentioned, a hasrelationship occurs between two classes when an member ofone class has another class type. An Accountobject has a stringobject to representthe name of the account holder, for example.Data Abstraction and Reusability
Inheritance has a number of important benefits for software developers:data abstraction: General characteristics and abilities can be handled by generic(base) classes and specializations can be organized in hierarchical relationships by
means of derived classes. This makes it easier to manage complex situations and
relationships.re-usability: Classes that you have defined and tested can be reused and adapted toperform new tasks. The base class implementation need not be known for this
purpose: only the public interfaces are required.
502CHAPTER 23INHERITANCE
BBase class BCDB is a directbase classB is an indirectbase classclass C : public B{private:// Declaration of additional private
// data members and member functionspublic:// Declaration of additional public// data members and member functions};DERIVED CLASSESDefining a derived class
Direct and indirect derivation

DERIVED CLASSES503When you define a derived class, the base class, the additional data members and meth-ods, and the access control to the base class are defined.The opposite page shows a schematic definition of a derived class, C. The Cclassinherits the Bclass, which is defined in the publicsection following the colon. Theprivateandpublicsections contain additional members of the Cclass.Access to Public Members in the Base Class
Access privileges to the base class Bare designated by the publickeyword that pre-cedes the B. In other words, all the publicmembers in base class Bare publicly available in the derived classC.This kind of inheritance ports the public interface of the base class to the derivedclass where it is extended by additional declarations. Thus, objects of the derived class
can call the publicmethods of the base class. A publicbase class, therefore, imple-ments the isrelationship; this is quite common.There are some less common cases where access to the members of the base classneeds to be restricted or prohibited. Only the methods of class Ccan still access thepublicmembers of B, but not the users of that class. You can use privateorpro-tectedderivation to achieve this (these techniques will be discussed later).Access to Private Members of the Base Class
Theprivatemembers of the base class are protected in all cases. That is, the methods of the derived class cannot access the privatemembers of the baseclass.Imagine the consequences if this were not so: you would be able to hack access to thebase class by simply defining a derived class, thus undermining any protection offered by
data encapsulation.Direct and Indirect Base Classes
The derived class Ccan itself be a base class for a further class, D. This allows for classhierarchies. Class Bthen becomes an indirect base class for class D.In the graphic on the opposite page, the arrow means directly derived from. That is,classDis a direct derivation of class Cand an indirect derivation of B.
504CHAPTER 23INHERITANCE
// car.h:   Definition of baseclass Car and//          of the derived class PassCar
// --------------------------------------------------
#include <iostream>
#include <string>using namespace std;class Car // Base class{private:long   nr;string producer;public:// Constructor:Car( long n = 0L, const string& prod = "");// Access methods:long  getNr(void) const { return nr; }void  setNr( long n ) { nr = n; }const string& getProd() const{ return producer; }void  setProd(const string& p){ producer = p; }void display( void ) const;    // Display a car};class PassCar : public Car// Derived class{private:string passCarType;bool   sunRoof;public:// Constructor:PassCar( const string& tp, bool sd,int n = 0 , const string& h = "");// Access methods:const string& getType() const{ return passCarType; }
void  setType( const string s) { passCarType = s; }bool  getSunRoof() const   { return sunRoof; }void  setSunRoof( bool b ) { sunRoof = b; }
void  display() const;};MEMBERS OF DERIVED CLASSESBase class Carand derived class 
PassCar
MEMBERS OF DERIVED CLASSES505Let’s look at the example on the opposite page to illustrate how derived classes aredefined. The Carclass and a derived class PassCarare defined in the example.Data Members and Methods
The base class Carcontains two data members, nrandproducer, which are used torepresent an identification number and the name of the manufacturer. The derived classPassCarinherits these data members. Thus, an object of the PassCarclass also con-tains the data members nrandproducer. The object includes a so-called basesub-
objectof type Car.ThePassCarclass additionally contains the data members passCarTypeandsunRoofto represent a passenger vehicle with or without a sunroof. So a PassCartypeobject has a total of four data members. For the sake of simplicity, we have omitted fur-
ther data members, such as the number of seats, etc.The base class Carcontains a constructor, access methods, and the methoddisplay(), which is used for screen output. The methods are also inherited by thederived class PassCar.In the PassCarclass a constructor, additional access methods, and a second outputfunction also called display()are declared. The derived class thus inherits a methodcalleddisplay()and declares a method with the same name. The display()method is said to have been redefined.Every member function and every data member in a derived class can be redefined.The member assumes a new meaning for the derived class. The member inherited from
the base class is also available in the derived class and will retain its original meaning.
We will be looking at this point in more detail later.Public Interface
Since the Carclass is a publicbase class of the PassCarclass, all the publicmem-bers of the base class are available in the derived class. For example, you can call thegetNr()method for an object named cabrioin the PassCarclass.Example:cout << "Car number: "<< cabrio.getNr();The public interface of the derived class thus comprisesthepublicmembers of the base class andthepublicmembers additionally defined in the derived class.
506CHAPTER 23INHERITANCE
class Carclass PassCar : public Carvoid PassCar::display( void) constprivate:private:public:public:<< getNr();<< getProd();cout << "Type: "<< passCarType;cout << "Type: "<< passCarTypif( sunRoof)cout << "yes";
elsecout << " no";
cout << endl;cout << "\nCar number: "string passCarType;long nr;string producer;long getNr(void);bool   sunRoof;cout << "\nProducer: "}{{{}}. . .. . .. . .okoknot okMEMBER ACCESSAccessing members of base class Car
MEMBER ACCESS507Access to Additional Members
The methods of derived classes can access any member additionally defined in thederived class.Example:const string& getType() const{  return passCarType;  }ThegetType()method directly accesses the private data member passCarTypeinthePassCarclass in this example.Access to Private Members of the Base Class
However, a private member of the base class is not directly accessible for the methods ofthe derived class. The output function display()in the derived class PassCar, forexample, cannot contain the following statement:Example:cout << "Producer: " << producer;Asproduceris a private data member of the base class Car, the compiler would issuean error message at this point.Methods belonging to derived classes only have indirect access to the private datamembers of the base class. They use access methods in the publicdeclaration of thebase class for this purpose. The opposite page shows a version of the display()methodthat calls the getmethods in its base class Car.When you call an access method, you do not need to state the method’s base class.The base class is identified by the thispointer, which is passed implicitly as an argu-ment. The call to getProd()on the opposite page is thus equivalent to:Example:this->getProd();Name LookupThe following rules apply when searching for the name of a method:the compiler looks for the name of the method called in the derived class firstif the name cannot be found, the compiler walks one step up the tree and looksfor a publicmethod with that name.The above example thus calls the getProd()in the base class Car, as the method isnot defined in the PassCarclass.
508CHAPTER 23INHERITANCE
// Within file Car.cpp// This version of method PassCar::display() calls
// the method display() of the base class.
// ---------------------------------------------------void PassCar::display( void) const{Car::display();           // Method in base classcout << "Type:       " << passCarType;cout << "\nSunroof:  ";if(sunRoof)cout << "yes "<< endl;elsecout << "no " << endl;}REDEFINING MEMBERSNew version of method 
display()
REDEFINING MEMBERS509RedefinitionThere are two options for the names of data members or methods in derived classes:1.The name does not occur in the base class 
no redefinition.2.The name already exists in the base class 
redefinition.In the second case, the member of the same name continues to exist unchanged in thebase class. In other words, redefining members in a derived class has no effect on the base
class.However, the name lookup rules for the compiler lead to the following scenario: if a member is redefined in a derived class, it will mask the corresponding mem-
ber in the base class.This situation is similar to the one seen for local and global variables. A local variablewill mask a previously defined global variable with the same name.Redefinition and Overloading
Normally,methodsare redefined in derived classes. This adopts the methods to the newfeatures of the class. When a method is redefined, the signature and the return type of
the method can be changed. However, a redefinition does not overload functions since
the derived class has a different scope.Redefining a method will always mask a method with the same name in the base class.Of course, you can overload methods within the same class, and this means you can
repeatedly redefine a base class method for a derived class.Access to the Members in the Base ClassIf you redefine a method in a derived class, this does not alter the fact that the base classmethod still exists. If the method was declared in the publicsection of the base class,you can call it to redefine a method. The range ::operator is used to access the baseclass method.The new version of the display()method opposite illustrates this point. Thedisplay()method defined in the base class is used to output the data members of thebase class. To do so, you must use the range operator with the name of the base class.
Otherwise the display()method in the derived class will call itself and head off intoan indefinite recursion.
510CHAPTER 23INHERITANCE
// First version of the constructor of PassCar// --------------------------------------------------PassCar::PassCar(const string& tp, bool sr, int n,const string& hs){setNr(n);            // Initial values for datasetProd(hs);         // members of the base class.passCarType  = tp;   // Initial values for data mem-sunRoof = sr;        // bers of the derived class}// Second version of the constructors of PassCar// ----------------------------------------------------PassCar::PassCar(const string& tp, bool sr, int n,const string& hs) : Car( n, hs){passCarType  = tp;   // Initial values for data mem-sunRoof = sr;        // bers of the derived class}// Third version of the constructor of PassCar// ----------------------------------------------------PassCar::PassCar(const string& tp, bool sr, int n,const string& hs): Car( n, hs), passCarType( tp ), sunRoof( sr ){// There remains nothing to do}CONSTRUCTING AND DESTROYING DERIVED CLASSES
First version of the constructor of 
PassCarSecond version with base class initializer
Third version with base class and member initializer

CONSTRUCTING AND DESTROYING DERIVED CLASSES511Constructor Calls
The constructor of a derived class is required to create an object of the derived class type.As the derived class contains all the members of the base class, the base sub-object must
also be created and initialized. The base class constructor is called to perform this task.
Unless otherwise defined, this will be the default constructor.The order in which the constructors are called is important. The base class construc-tor is called first, then the derived class constructor. The object is thus constructed from
its core outwards.The first version of the constructor for PassCar, as shown opposite, sets initial val-ues by calling the access methods of the base class. An implicit call to the default con-
structor of the base class occurs prior to this, and the base sub-object is initialized with
default values. This process has the same drawbacks as the technique of creating objects
with member objects. A default constructor must be available in the base class and ini-
tialization with incorrect values before assigning live values impacts the response of the
program.Base Initializer
If the base class contains a constructor with parameters, it makes sense to call this con-structor. This immediately initializes the data members with correct values. A base initial-izerfor the constructor of the derived class can be defined for this purpose.The second version of the constructor for PassCarcontains a base initializer.Example:Car( n, hs )The syntax of the base initializer for base sub-objects is similar to that of the member ini-
tializer for member sub-objects. This means that you can state both the base and the
member initializer in a list separated by commas. The third version of the PassCarcon-structor illustrates this point.Destroying Objects
When an object is destroyed, the destructor of the derived class is first called, followed bythe destructor of the base class. The reverse order of the constructor calls applies.You need to define a destructor for a derived class if actions performed by the con-structor need to be reversed. The base class destructor need not be called explicitly as it
is executed implicitly.
512CHAPTER 23INHERITANCE
// car_t.cpp:  Testing the base class Car and//             the derived class PassCar.// -----------------------------------------------------#include "car.h"int main(){const PassCar beetle("Beetle", false, 3421, "VW");beetle.display();cout << "\nAnd the passenger car number again: "<<beetle.getNr()<< endl;PassCar cabrio("Carrera", true);cabrio.setNr(1000);cabrio.setProd("Porsche");
cabrio.display();cout << "\nOnly data of the base class: ";cabrio.Car::display();return 0;}OBJECTS OF DERIVED CLASSESSample program
Screen output
---------------------------------------------Car number:   3421
Producer:     VW
Type:         Beetle
Sunroof:      noAnd the passenger car number again: 3421
---------------------------------------------Car number:   1000
Producer:     Porsche
Type:         CarreraSunroof:      yesOnly data of the base class:---------------------------------------------
Car number:   1000
Producer:     Porsche
OBJECTS OF DERIVED CLASSES513Declaring ObjectsThe program opposite illustrates how objects of derived classes can be used. Two objects,beetleandcabrio, of the derived class PassCartype are declared. As the PassCarclass does not contain a default constructor, both objects must be initialized. However, itis sufficient to state a PassCartype with or without a sunroof as default values exist forall other data members.The object beetleis declared as constjust to show that the getmethods and thedisplay()method can also be called for constant objects since they were declared asread-only methods.However, the following call is invalid:Example:beetle.setNr( 7564 );          // ErrorThis means you have to correctly define all the initial values for the object when you
declare it.Calling Redefined MethodsWhen you call a redefined method, the object type determines what version of themethod will be executed. In the PassCarclass the method display()has been rede-fined. The statementExample:cabrio.display();also outputs the additional data members passCarTypeandsunRoof. However, inthe case of the vanobject in the Carclass, callingExample:van.display();will execute the method in the base class.Calling Methods in the Base ClassYou may be wondering if a base class method can be called for an object of a derivedclass, if the method has been redefined in the derived class. This is possible using the
scope resolution operator,::.If you want to display the basic data of the cabrioobject, you can use a direct call tothe base class method display()to do so.Example:cabrio.Car::display();The name of the method is preceded by the name of the base class and the scope resolu-
tion operator in this case.
514CHAPTER 23INHERITANCE
// safe.h : The classes Safe and Castle// ---------------------------------------------------#include <iostream>
using namespace std;class Safe{private:int topSecret;protected:int secret;void setTopSecret( int n) { topSecret = n;}
int  getTopSecret() const { return topSecret;}void setSecret( int n){ secret = n;}int  getSecret() const { return secret;}public:int noSecret;Safe(){ topSecret = 100; secret = 10; noSecret = 0; }};class Castle : public Safe{public:Castle(){// topSecret = 10;      // Error, because privatesetTopSecret(10);       // ok, because protectedsecret = 1;             // ok, because protectednoSecret = 0;           // ok, because public}
void test(){// top.Secret = 200;      // Error, because privatesetTopSecret(200);     // ok, because protectedsecret = 20;           // ok, because protectednoSecret = 2;          // ok, because public}};PROTECTED MEMBERS
Sample classes
PROTECTED MEMBERS515Access to Sheltered Members
The private members of a base class are equally inaccessible for the methods and friendfunctions of a derived class.When you create a class hierarchy you may want require the methods and friendfunctions of a derived class to communicate directly with the members of the base class.
This would be particularly necessary if the base class contained members for use as build-
ing blocks for derived classes but not for general purpose use.For example, a class used to represent a window on screen could contain the dimen-sions and other characteristics of a general windows. The characteristics need protecting;
however, methods in derived classes will still need direct access.Protected Members
To allow methods and friendfunctions access to the sheltered members of a base class,let’s introduce an additional level of access control between privateandpublic.This is achieved by means of protected declarations.A member declared protectedis sheltered from external access just like a pri-vatemember. That means, a protectedmember is inaccessible for base class objectsand any classes derived from the base class. However, in contrast to a privatemember,methods and friendfunctions of derived classes can access the member.The classes defined opposite, SafeandCastle, show that protectedmembers ofthe base class can be accessed directly in a derived class. In contrast to this, protectedmembers are inaccessible to users of these classes.Example:Castle   treasure;treasure.topSecret = 1;   // Error: private
treasure.secret = 2;      // Error: protected
treasure.setTopSecret(5); // Error: protected
treasure.noSecret = 10;   // okProtecteddeclarations should be used with caution. If you change the declaration of aprotectedmember, every class derived from this class must be examined to ascertainwhether additional modifications are necessary.
exercises
516CHAPTER 23INHERITANCE
Additional data members:
Type
Number of axlesintLoad capacity
doubleAdditional methods:
void  setAxles( int a );int   getAxles() const;void  setCapacity( double cp );void  getCapacity() const;void display() const;EXERCISESFor exercise 1
ClassTruckbeing derived from class 
Car
EXERCISES517Exercise 1
The classes CarandPassCarare to modify to allow objects to be created and
destroyed.In addition,the class 
Truckis to be added to the class hierarchy.
Change the classes CarandPassCarto make the constructor issue the
following message:
"Creating an object of type ... ."Define a destructor for the 
CarandPassCarclasses.The destructor
should issue the following message:
"Destroying an object of type ...."Then define the class Truck,which is derived from 
Car,using the data
members shown opposite,a constructor,a destructor,and the additional

methods shown opposite.
Implement the constructor for the 
Truckclass—the constructor shouldagain issue a suitable message.Use the base initializer to initialize the data

members of Car.Define a destructor for 
Truck—the destructor should again issue a suit-able message for trucks.
To test your class,create and display a 
Trucktype object in your 
mainfunction.If required by the user,enable your program to create and dis-

play objects of the types 
PassCarandCar.Observe how the various objects and member objects are created and
destroyed.
Exercise 2
Derive two classes,
DepAccandSavAcc,from the 
Accountclass,which was
defined in Chapter 14,in the section titled “Const Objects and Methods.”

Additionally define an overdraft limit and an interest rate for the 
DepAccclass.TheSavAcccontains the members of the base class and an interest rate.
For both classes,define constructors to provide default values for all

parameters,add access methods,and add a 
display()method for
screen output.
Test the new classes by initializing objects of the 
DepAccandSavAcctypes in the object declarations and outputting them.Then modify both a

savings and a deposit account interactively and display the new values.

518CHAPTER 23INHERITANCE
ProductPrepackedFoodFreshFood
Properties:BarcodeNameMethods:setCode()getCode()  ...
scanner()printer()Properties:Price per pieceMethods:getPrice()setPrice()  ...
scanner()printer()Properties:Weight
Price per poundMethods:setWght()getWght()  ...scanner()printer()Exercise 3

EXERCISES519Exercise 3
A supermarket chain has asked you to develop an automatic checkout system.
All products are identifiable by means of a barcode and the product name.

Groceries are either sold in packages or by weight.Packed goods have fixed

prices.The price of groceries sold by weight is calculated by multiplying the

weight by the current price per kilo.
Develop the classes needed to represent the products first and organize
them hierarchically.The 
Productclass,which contains generic information on all
products (barcode,name,etc.),can be used as a base class.
TheProductclass contains two data members of type 
longused for
storing barcodes and the product name.Define a constructor with

parameters for both data members.Add default values for the para-

meters to provide a default constructor for the class.In addition to the

access methods setCode()andgetCode(),also define the methods
scanner()andprinter().For test purposes,these methods will simply
output product data on screen or read the data of a product from the

keyboard.
The next step involves developing special cases of the 
Productclass.Define two classes derived from 
Product,PrepackedFood
andFresh-Food.In addition to the product data,the 
PrepackedFoodclass shouldcontain the unit price and the FreshFoodclass should contain a weight
and a price per kilo as data members.In both classes define a constructor with parameters providing
default-values for all data members.Use both the base and member ini-

tializer.
Define the access methods needed for the new data members.Also
redefine the methods 
scanner()andprinter()to take the new data
members into consideration.Test the various classes in a 
mainfunction that creates two objects each
of the types Product,PrepackedFoodandFreshFood.One object of
each type is fully initialized in the object definition.Use the default con-

structor to create the other object.Test the 
getandsetmethods andthescanner()method and display the products on screen.

solutions
520CHAPTER 23INHERITANCE
SOLUTIONSExercise 1
// ----------------------------------------------------//Car.h:  Defines the base class Car and//          the derived classes PassCar and Truck// --------------------------------------------------------#ifndef _CAR_H_
#define _CAR_H_#include <iostream>#include <string>using namespace std;class Car{// See previous definition in this chapter};class PassCar : public Car{// See previous definition in this chapter};class Truck : public Car{private:int    axles;
double tons;public:Truck( int a, double t, int n, const string& hs);
~Truck();void   setAxles(int l){ axles = l;}int    getAxles() const   { return axles; }void   setCapacity( double t) { tons = t;}double getCapacity() const    { return tons; }void display() const;};#endif
SOLUTIONS521// ------------------------------------------------------//car.cpp// Implements the methods of Car, PassCar, and Truck// ------------------------------------------------------#include "car.h"
// ------------------------------------------------------
// The methods of base class Car:
Car::Car( long n, const string& prod)
{cout << "Creating an object of type Car." << endl;nr = n;   producer = prod;}
Car::~Car()
{cout << "Destroying an object of type Car" << endl;}void Car::display() const{cout << "\n---------------------------- "<< "\nCar number:   " << nr<< "\nProducer:     " << producer
<< endl;}// -------------------------------------------------------// The methods of the derived class PassCar:PassCar::PassCar(const string& tp, bool sd, int n,const string& hs): Car( n, hs), PassCarTyp( tp ), sunRoof( sd ){cout << "I create an object of type PassCar." << endl;}PassCar::~PassCar(){cout << "\nDestroying an object of type PassCar"<< endl;}void PassCar::display( void) const{Car::display();            // Base class method
cout << "Type:          " << passCarType<< "\nSunroof:       ";if(sunRoof)cout << "yes "<< endl;elsecout << "no " << endl;}
522CHAPTER 23INHERITANCE
// ----------------------------------------------------// The methods of the derived class Truck:
Truck::Truck( int a, double t, int n, const string& hs): Car( n, hs), axles(a), tons(t){cout << "Creating an object of type Truck." << endl;}Truck::~Truck()
{cout << "\nDestroying an object of type Truck\n";}
void Truck::display() const{Car::display();
cout <<   "Axles:       " << axles<< "\nCapacity:    " << tons << " long tons\n";}// -----------------------------------------------------//Car_t.cpp: Tests the base class Car and//             the derived classes PassCar and Truck.
// -----------------------------------------------------#include "car.h"int main()
{Truck toy(5, 7.5, 1111, "Volvo");toy.display();char c;
cout << "\nDo you want to create an object of type "<< " PassCar? (y/n) ";  cin >> c;if( c == 'y' || c == 'Y')
{const PassCar beetle("Beetle", false, 3421, "VW");beetle.display();}cout << "\nDo you want to create an object "<< " of type car? (y/n) ";   cin >> c;if( c == 'y' || c == 'Y'){const Car oldy(3421, "Rolls Royce");
oldy.display();}return 0;}
SOLUTIONS523Exercise 2
// -----------------------------------------------------// account.h:// Defines the classes Account, DepAcc, and SavAcc.
// -----------------------------------------------------
#ifndef _ACCOUNT_H#define _ACCOUNT_H#include <iostream>
#include <iomanip>#include <string>using namespace std;
class Account{private:string name;   unsigned long nr;    double balance;public:Account(const string& s="X", unsigned long n= 1111111L, double st = 0.0): name(s), nr(n), balance(st){ }const string& getName() const  { return name; }
void  setName(const string& n) { name = n;}
unsigned long getNr() const { return nr; }
void setNr(unsigned long n) { nr = n; }
double getBalance() const   { return balance; }void   setBalance(double st){ balance = st; }void display()
{  cout << fixed << setprecision(2)<< "----------------------------------------\n"<< "Account holder:        " << name  << endl
<< "Account number:        " << nr    << endl
<< "Balance of the account:" << balance <<endl;}};class DepAcc : public Account{private:double limit;                // Overdraft limitdouble interest;             // Interestpublic:DepAcc(const string& s = "X",unsigned long n = 1111111L, double st = 0.0,double li = 0.0, double ra = 0.0): Account(s, n, st), limit(li), interest(ra){ }
524CHAPTER 23INHERITANCE
// Access methods:double getLimit() const { return limit; }
void   setLimit(double lt){ limit = lt; }double getInterest() const { return interest; }void   setInterest(double sl){ interest = sl; }void display(){Account::display();cout << fixed << setprecision(2)<< "Overdraft limit: " << limit << endl
<< "Interest rate:   " << interest  << endl
<< "----------------------------------\n"<< endl << endl;}};class SavAcc: public Account{private:double interest;               // compound interestpublic:SavAcc(const string& s = "X",unsigned long n = 1111111L, double st = 0.0,
double in = 0.0): Account(s, n, st), interest(in){ }// Access methods.double getInterest() const   { return interest; }void   setInterest(double in){ interest = in; }void display(){Account::display();
cout << fixed << setprecision(2)<< "Interest rate:    " << interest << endl<< "----------------------------------\n"
<< endl << endl;}};#endif
SOLUTIONS525// -------------------------------------------------------//account_t.cpp// Tests the classes DepAcc and SavAcc// derived from class Account// -------------------------------------------------------
#include "account.h"int main(){string s;double db;SavAcc mickey("Mickey Mouse", 1234567,2.40, 3.5);mickey.display();cout << "New name:          "; getline(cin, s);cout << "New interest rate: "; cin >> db;mickey.setName(s);mickey.setInterest(db);mickey.display();DepAcc dag("Donald Duck", 7654321,-1245.56, 10000, 12.9);dag.display();cout << "New limit:         "; cin >> db;dag.setLimit(db);
dag.display();return 0;}
526CHAPTER 23INHERITANCE
Exercise 3
// ----------------------------------------------------//product.h: Defines the classes//             Product, PrepackedFood, and FreshFood
// ----------------------------------------------------
#ifndef _PRODUCT_H#define _PRODUCT_H#include <iostream>
#include <iomanip>#include <string>using namespace std;class Product{private:long   bar;
string name;public:Product(long b = 0L, const string& s = ""): bar(b), name(s)
{  }void setCode(long b) { bar = b; }long getCode() const { return bar; }
void  setName(const string& s){ name = s; }const string& getName() const { return name; }void scanner()
{cout << "\nBarcode:    "; cin >> bar;
cout <<   "Name:        "; cin >> name;
cin.sync(); cin.clear();}void printer() const{cout << "\n-------------------------------"<< "\nBarcode:    " << bar<< "\nName:       " << name
<< endl;}};class PrepackedFood : public Product{private:double pce_price;
SOLUTIONS527public:PrepackedFood(double p = 0.0,long b = 0L,const string& s = ""): Product(b, s), pce_price(p){}
void   setPrice(double p){ pce_price = p;}
double getPrice()const   { return pce_price; }
void scanner()
{   Product::scanner();cout << "Price per piece:    "; cin >> pce_price;}
void printer() const{  Product::printer();cout << fixed << setprecision(2)<< "Price per piece:    " << pce_price << endl;}};class FreshFood : public Product{private:double wght;double lbs_price;public:FreshFood(double g = 0.0, double p = 0.0,long b = 0L, const string& s = ""): Product(b, s), wght(g), lbs_price(p) {}
void   setWght(double g) { wght = g;}double getWght()const    { return wght; }void   setPrice(double p) { lbs_price = p;}
double getPrice()const    { return lbs_price; }void scanner()
{   Product::scanner();cout << "Weight(lbs):  "; cin >> wght;
cout << "Price/lbs:    "; cin >> lbs_price;cin.sync(); cin.clear();}
void printer() const{Product::printer();
cout << fixed << setprecision(2)<< "Price per Lbs:   " << lbs_price<< "\nWeight:        " << wght
<< "\nTotal:         " << lbs_price * wght<< endl;}};
#endif
528CHAPTER 23INHERITANCE
// ------------------------------------------------------//product_t.cpp// Tests classes Product, PrepackedFood, and FreshFood.// ------------------------------------------------------#include "product.h"int main(){Product p1(12345L, "Flour"), p2;p1.printer();             // Output the first productp2.setName("Sugar");      // Set the data membersp2.setCode(543221);p2.printer();            // Output the second product// Prepacked products:PrepackedFood pf1(0.49, 23456, "Salt"), pf2;pf1.printer();           // Output the first// prepacked productcout << "\n Input data of a prepacked product: ";pf2.scanner();           // Input and output
pf2.printer();           // data of 2nd productFreshFood pu1(1.5, 1.69, 98765, "Grapes"), pu2;pu1.printer();           // Output first item// fresh foodcout <<"\n Input data for a prepacked product: ";
pu2.scanner();           // Input and outputpu2.printer();           // data of 2nd product.cout << "\n-------------------------------"<< "\n-------------------------------"<< "\nAgain in detail: \n"<< fixed << setprecision(2)
<< "\nBarcode:       " << pu2.getCode()<< "\nName:          " << pu2.getName()<< "\nPrice per Lbs: " << pu2.getPrice()
<< "\nWeight:        " << pu2.getWght()<< "\nEnd price:     " << pu2.getPrice()* pu2.getWght()<< endl;return 0;}
529Type Conversion in Class
HierarchiesThis chapter describes implicit type conversion within class hierarchies,
which occurs in the context of assignments and function calls.
In addition,explicit type casting in class hierarchies is discussed,in
particular,upcasting and downcasting.
chapter
24
530CHAPTER 24TYPE CONVERSION IN CLASS HIERARCHIES
CONVERTING TO BASE CLASSES
Example for implicit conversion
#include "car.h"bool compare( Car&, Car&);
int main(){
   PassCar beetle("New Beetle", false, 3421, "VW"),
           miata( "Miata", true, 2512, "Mazda");   bool res = compare( beetle, miata);   // ...
}
                             // ok!
                             // Implicit conversion
                             // to base class.
                             // Car& a = beetle;
                             // Car& b = miata;bool compare( Car& a, Car& b){   // Here a is the base part of beetle,   // b is the base part of miata.   // If this is inconvenient, an explicit   // type cast to type PassCar has to be performed.}
CONVERTING TO BASE CLASSES531Implicit Conversion
If a class is derived from another class by publicinheritance, the derived class assumesthe characteristics and features of the base class. Objects of the derived class type then
becomespecialobjects of the base class, just like an automobile is a special type of vehi-cle.You can utilize the isrelationship when handling objects. It is possible to assign anobject of a derived class to an object of the base class. This causes an implicit type conver-sionto a base class type.The base class thus becomes a generic term for multiple special cases. Given that theclassesPassCarandTruckwere derived from the Carclass, objects of the PassCarorTrucktype can always be managed like objects of Cartype.AssignmentsImplicit type conversion in class hierarchies occurs in assignments tobase class objectspointers or references to the base class.Function CallsAdditionally, a similar kind of implicit type conversion takes place for the arguments offunction calls.Given the function compare()with the following prototypeExample:bool compare( Car& , Car& );and two objects of the derived PassCarclass type, beetleandmiata, the followingstatement is validExample:compare( beetle, miata);The compiler performs implicit type conversion for the arguments beetleandmiata,converting them to the parameter type, that is, to a reference to the base class Car.Type conversion for arguments used in function calls is similar to the type conversionthat occurs in assignments, as shown in the following section.
532CHAPTER 24TYPE CONVERSION IN CLASS HIERARCHIES
autobmw
nr: 4325producer:"Bayer...."nr: 4325sunRoof: trueproducer:"Bayer...."passCarType:"520i"TYPE CONVERSIONS IN ASSIGNMENTS
Effect of an assignmentCar   auto;PassCar bmw("520i", true, 4325,"Bayerische Motorenwerke");auto = bmw;
TYPE CONVERSIONS IN ASSIGNMENTS533Assignment to a Base Class ObjectAn object belonging to a derived class type can be assigned to an object of a base class.Example:Car   auto;PassCar bmw("520i", true, 4325,"Bayerische Motorenwerke");auto = bmw;The object bmw, which belongs to the derived class PassCar, contains all the datamembers of the base class, Car, i.e. the vehicle id number and the manufacturer. Duringan assignment the object bmwis copied to the data members of the object autostep bystep.This makes the above statement equivalent to:auto.nr       = bmw.nr;auto.producer = bmw.producer;The data members additionally defined in the derived class are not copied!The following statement outputs the copied data members:Example:auto.display();The fact that you can assign an object belonging to a derived class to a base class object
assumes that more will always fill less. The object on the right of the assignment operator
will always contain a member object of the type on the left of the operator.Assignments to Derived Class Objects
This is not the case when you attempt to assign a base class object to an object of aderived class. The assignmentExample:bmw = auto;    // Error!is therefore invalid, since the values for the additional data members passCarTypeandsunRoofare unknown.An assignment in reverse order is only possible if you have defined an assignment ofthis type or a copy constructor with a parameter of the type “reference to base class.”
Both would be able to supply default values for the additional data members of the
derived classes.
534CHAPTER 24TYPE CONVERSION IN CLASS HIERARCHIES
carPtrcabrio
nrproducer1001"Triumph"carType"Spitfire"
sunRooftrue
CONVERTING REFERENCES AND POINTERS
Effect of a pointer assignmentPassCar cabrio("Spitfire", true, 1001, "Triumph");Car* carPtr = &cabrio;
carPtr = &cabrio;
CONVERTING REFERENCES AND POINTERS535Converting to Base Class Pointers
Theisrelationship between a derived class and a base class is also apparent when refer-ences and pointers are used. A pointer of the type “pointer to base class,” or base classpointerfor short, can reference an object of a derived class type.Example:Car* carPtr = &cabrio;In this case cabriois an object of the class PassCar.The following rule applies for access to the referenced object:a base class pointer can only access the public interface of the base class.The additional members defined in the derived class are therefore inaccessible. To makethis more clear:Example:carPtr -> display();calls the display()method in the base class Car. Although carPtrpoints to anobject of the PassCarclass in this case, it is impossible to call any methods additionallydefined in the derived class.Example:carPtr->setSunRoof(false);    // ErrorThe object *carPtrbelongs to the Carclass and only represents the generic part ofcabrio. Thus, the following assignment is also invalidExample:PassCar auto;auto = *carPtr;      // Error!althoughcarPtris pointing at an object of the PassCartype in this case!Conversions in References to Base Classes
A similar situation arises when you are working with references. A reference of the type“reference to base class” can point to an object of a derived class. The reference will
address only the generic part of the object in this case.Example:Car& carRef = cabrio;          // okcarRef.display();              // Output base members
carRef.setSunRoof(true);       // Error
PassCar auto;
auto = carRef;                 // ErrorAlthough the reference carRefpoints to an object of the PassCartype, it is impossi-ble to assign the PassCartype object autoto this object.
536CHAPTER 24TYPE CONVERSION IN CLASS HIERARCHIES
CarPassCarcarPtrstatic_cast<PassCar*>(carPtr)Pointer toBase classDerivedclassDowncastCarPassCarstatic_cast<Car*>(PassCarPtr)PassCarPtrPointer toBase classDerivedclassUpcastEXPLICIT TYPE CONVERSIONS
Downcast
Upcast
EXPLICIT TYPE CONVERSIONS537Upcasts and Downcasts
Type conversions that walk up a class hierarchy, or upcasts, are always possible and safe.Upcasting is performed implicitly for this reason.Type conversions that involve walking down the tree, or downcasts, can only be per-formed explicitly by means of a cast construction. The cast operator (type), which wasavailable in C, or the static_cast< >operator are available for this task, and areequivalent in this case.Explicit Cast Constructions
Given that cabriois again an object of the derived class PassCar, the following state-mentsExample:Car* carPtr = &cabrio;( (PassCar*) carPtr )->display();first point the base class pointer carPtrto the cabrioobject.carPtris then cast as apointer to the derived class. This allows you to access the display()method of thederived class PassCarvia the pointer. Parentheses are necessary in this case as themember access operator ->has a higher precedence than the cast operator (type).The operator static_cast< >conforms to the followingSyntax:static_cast<type>(expression)and converts the expression to the target type type. The previous example is thus equiv-alent toExample:static_cast<PassCar*>(carPtr)->display();No parentheses are required here as the operators static_cast<>and->are of equalprecedence. They are read from left to right.After downcasting a pointer or a reference, the entire public interface of the derivedclass is accessible.Downcast Safety Issues
Type conversions from top to bottom need to be performed with great care. Downcastingis only safe when the object referenced by the base class pointer really is a derived class
type. This also applies to references to base classes.To allow safe downcasting C++ introduces the concept of dynamic casting.This tech-nique is available for polymorphic classes and will be introduced in the next chapter.
exercise
538CHAPTER 24TYPE CONVERSION IN CLASS HIERARCHIES
ProductPrepackedFoodFreshFood
EXERCISEClass hierarchy of products in a supermarket

EXERCISE539Exercise
The class hierarchy representing a supermarket chain’s checkout system
comprises the base class Productand the derived classes 
PrepackedFoodandFreshFood.Your job is to test various cast techniques for this class (see also
Exercise 3 in Chapter 23).
Define a global function isLowerCode()that determines which one oftwo products has the lower barcode and returns a reference to the prod-

uct with the lower barcode.
Define an array with three pointers to the base class 
Product.Dynami-
cally create one object each of the types 
Product,PrepackedFood,and
FreshFood.The three objects are to be referenced by the array pointers.
Additionally define a pointer to the derived class 
FreshFood.Initialize the
pointer with the address of a dynamically allocated object of the same

class.Now call the method 
printer()for all four objects.Which version of
printer()is executed?
Perform downcasting to execute the correct version of 
printer()inevery case.Display the pointer values before and after downcasting.
Use the pointer of the derived class 
FreshFoodto call the base class ver-
sion of printer().Perform an appropriate upcast.
Test the function 
isLowerCode()by multiple calls to the function with
various arguments.Output the product with the lower barcode value in

each case.

solution
540CHAPTER 24TYPE CONVERSION IN CLASS HIERARCHIES
SOLUTION// ----------------------------------------------------//product.h: Defines the classes//             Product, PrepackedFood, and FreshFood// ----------------------------------------------------//
// Unchanged! See the previous chapter's solutions.// ------------------------------------------------------//produc_t.cpp// Tests up and down casts for the classes
// Product, PrepackedFood, and FreshFood.// ------------------------------------------------------#include "product.h"const Product& isLowerCode(const Product& p1,const Product& p2);int main(){Product* pv[3];FreshFood* pu;pv[0] = new Product(12345L, "Flour");pv[1] = new PrepackedFood(0.49, 23456, "Salt");pv[2] = new FreshFood(1.5, 1.69, 98765, "Grapes");pu =  new FreshFood(2.5, 2.69, 56789, "Peaches");cout << "\nA fresh product: ";pu->printer();cout << "\nThe generic data of the other products:";int i;
for(i=0; i < 3; ++i)pv[i]->printer();cin.get();cout << "\nAnd now the downcast: " << endl;static_cast<PrepackedFood*>(pv[1])->printer();
static_cast<FreshFood*>(pv[2])->printer();
cin.get();cout << "\nAnd an upcast: " << endl;static_cast<Product*>(pu)->printer();
SOLUTION541cout << "\nNow compare the barcodes!" << endl;cout << "\nIs barcode for flour or salt smaller?";isLowerCode(*pv[0], *pv[1]).printer();cout << "\nIs barcode for salt or grapes smaller?";isLowerCode(*pv[1], *pv[2]).printer();return 0;}const Product& isLowerCode(const Product& p1,const Product& p2){if(p1.getCode() < p2.getCode())return p1;elsereturn p2;}
This page intentionally left blank 
543Polymorphism
This chapter describes how to develop and manage polymorphic classes.
In addition to defining virtual functions,dynamic downcasting in

polymorphic class hierarchies is introduced.
chapter
25
544CHAPTER 25POLYMORPHISM
Classes with virtual methods:Base class pointer and objects:Calling virtual methods:base class with virtual method display().derived from Base with its own redefinitionsof method display().When a virtual method is called, the corresponding version of the method isexecuted for the object currently referenced.Base:Derived1 and Derived2:Base*basePtr;// Base class pointer
Derived1 angular;// Objects
// Calling// Derived1::display()// Calling// Derived2::display()Derived2 round;basePtr = &angular;basePtr->display();basePtr = &round;basePtr->display();CONCEPT OF POLYMORPHISM
Example
CONCEPT OF POLYMORPHISM545IssuesIf the special features of derived class objects are insignificant, you can simply concernyourself with the base members. This is the case when dynamic allocated objects are
inserted into a data structure or deleted from that structure.It makes sense to use pointers or references to the base class in this case—no matterwhat type of concrete object you are dealing with. However, you can only access the
common base members of these objects.However, you should be able to activate the special features of a derived class whenthe object is accessed by a pointer or reference to the base class andthe concrete object type will not be known until the program is executed.Given a base class pointer, carPtr, the statementExample:carPtr->display();should output allthe data members of the object currently being referenced.Traditional Approach
Traditional programming languages solved this issue by adding a type field both to thebase class and to the derived classes. The type field stored the type of the current class. A
function that manages objects via the base class pointer could query the concrete type in
a switch statement and call the appropriate method.This solution has a disadvantage; adding derived classes at a later stage also meantadding a caselabel and recompiling.Object-Oriented Approach
The approach adopted by object-oriented languages is polymorphism(Greek for multi-form). In C++, virtual methods are used to implement polymorphic classes. Calling a vir-tual method makes the compiler execute a version of the method suitablefor the objectin question, when the object is accessed by a pointer or a reference to the base class!
546CHAPTER 25POLYMORPHISM
// virtual.cpp : Tests the virtual method display()//               of the classes Car and PassCar.
// ----------------------------------------------------#include "car.h"// The Car class with virtual method display():// class Car// {
//   ...
//virtual void display() const;// };int main(){Car* pCar[3];// Three pointers to the base class.int i = 0;          // Index
pCar[0] = new Car( 5634L, "Mercedes");
pCar[1] = new PassCar("Miata",true,3421,"Mazda");
pCar[2] = new Truck( 5, 7.5, 1234, "Ford");while( true){cout << "\nTo output an object of type ""Car, PassCar or Truck!""\n 1 = Car,  2 = PassCar,  3 = Truck"
"\nYour input (break with 0): ";cin >> i;--i;
if( i < 0  || i > 2)break;pCar[i]->display();}
return 0;}VIRTUAL METHODS
Calling the virtual method 
display()
VIRTUAL METHODS547Declaring Virtual Methods
Thevirtualkeyword is used to declare a virtual method in a base class.Example:virtual void display() const;The definition of a virtual method is no different from the definition of any other mem-ber function.A virtual method does not need to be redefined in the derived class. The derived classthen inherits the virtual method from the base class.RedefinitionHowever, it is common practice for the derived class to define its own version of the vir-tual method, which is thus modified to suit the special features of the derived class.Creating a proprietary version of a virtual method means redefining that method. Theredefinition in the derived class must have1.the same signature and
2.the same return type
as the virtual method in the base class.The new version of a virtual method is automatically virtual itself. This means youcan omit the virtualkeyword in the declaration.When you redefine a virtual function, be aware of the following:if the return type is a pointer or reference to the base class, the new version of the
virtual method can also return a pointer or reference to a derived class (Note:
Not all compilers support this option.)constructors cannot have a virtual declarationa base class method does not become virtual just because it is declared as virtual
in a derived class.If you use a different signature or return type of a virtual base class method to define amethod in a derived class, this simply creates a new method with the same name. The
method will not necessarily be virtual!However, the virtual method in the base class will be masked by the method in thederived class. In other words, only the non-virtual version of the method is available for
a derived class object.
548CHAPTER 25POLYMORPHISM
// v_destr.cpp// Base class with a virtual destructor.
// -----------------------------------------------------
#include <iostream>
#include <cstring>             // For strcpy()using namespace std;class Base{public:Base()
{  cout << "Constructor of class Base\n"; }
virtual ~Base(){  cout << "Destructor of class Base\n"; }};
class Data
{private:char *name;public:Data( const char *n){ cout << "Constructor of class Data\n";name = new char[strlen(n)+1];strcpy(name, n);}
~Data()
{ cout << "Destructor of class Data for "<< "object: " << name << endl;delete [] name;}};class Derived : public Base{private:Data data;public:Derived( const char *n) : data(n)
{  cout << "Constructor of class Derived\n";  }
~Derived()                // implicit virtual
{  cout << "Destructor of class Derived\n"; }};int main(){Base *bPtr = new Derived("DEMO");
cout << "\nCall to the virtual Destructor!\n";
delete bPtr;
return 0;}DESTROYING DYNAMICALLY ALLOCATED OBJECTS
Sample program

DESTROYING DYNAMICALLY ALLOCATED OBJECTS549Dynamically created objects in a class hierarchy are normally handled by a base classpointer. When such an object reaches the end of its lifetime, the memory occupied by
the object must be released by a deletestatement.Example:Car *carPtr;carPtr = new PassCar("500",false,21,"Geo");
. . .
delete carPtr;Destructor Calls
When memory is released, the destructor for an object is automatically called. If multipleconstructors were called to create the object, the corresponding destructors are called in
reverse order. What does this mean for objects in derived classes? The destructor of the
derived class is called first and then the destructor of the base class executed.If you use a base class pointer to manage an object, the appropriate virtual methods ofthe derived class are called. However, non-virtual methods will always execute the base
class version.In the previous example, only the base class destructor for Carwas executed. As thePassCardestructor is not called, neither is the destructor called for the data memberpassCarType, which is additionally defined in the derived class. The data memberpassCarTypeis a string, however, and occupies dynamically allocated memory—this memory will not be released.If multiple objects are created dynamically in the derived class, a dangerous situationoccurs. More and more unreferenced memory blocks will clutter up the main memory
without you being able to reallocate them—this can seriously impact your program’s
response and even lead to external memory being swapped in.Virtual Destructors
This issue can be solved simply by declaring virtual destructors. The opposite page showshow you would define a virtual destructor for the Carclass. Just like any other virtualmethod, the appropriate version of the destructor will be executed. The destructors from
any direct or indirect base class then follow.A class used as a base class for other classes should always have a virtual destructordefined. Even if the base class does not need a destructor itself, it should at least contain
a dummy destructor, that is, a destructor with an empty function body.
550CHAPTER 25POLYMORPHISM
VMT pointer
Object of type CarAddress of Car::display()Address of Car::~Car()VMT of 
Carnrproducer12345AudiVMT pointer
Address ofObject of type PassCarVMT of Pass
Carnrproducer54321GeopassCarTypePassCar::display()Address ofPassCar::~PassCar()500sunRooftrueVMT pointer
Object of type PassCarnrproducer98765VWpassCarTypeGTIsunRooffalseVIRTUAL METHOD TABLE
VMT for the classes CarandPassCar
VIRTUAL METHOD TABLE551Static Binding
When a non-virtual method is called, the address of the function is known at time ofcompilation. The address is inserted directly into the machine code. This is also referred
to as staticorearly binding.If a virtual method is called via an object’s name, the appropriate version of thismethod is also known at time of compilation. So this is also a case of early binding.Dynamic BindingHowever, if a virtual method is called by a pointer or reference, the function that will beexecuted when the program is run is unknown at time of compilation. The statementExample:carPtr->display();could execute different versions of the display()method, depending on the objectcurrently referenced by the pointer.The compiler is therefore forced to create machine code that does not form anassociation with a particular function until the program is run. This is referred to as lateordynamic binding.VMTDynamic binding is supported internally by virtual method tables (or VMT for short). AVMT is created for each class with at least one virtual method—that is, an array with the
addresses of the virtual methods in the current class.Each object in a polymorphic class contains a VMT pointer, that is, a hidden pointerto the VMT of the corresponding class. Dynamic binding causes the virtual function call
to be executed in two steps:1.The pointer to the VMT in the referenced object is read.
2.The address of the virtual method is read in the VMT.
In comparison with static binding, dynamic binding does have the disadvantage thatVMTs occupy memory. Moreover, program response can be impacted by indirect
addressing of virtual methods.However, this is a small price to pay for the benefits. Dynamic binding allows you toenhance compiled source code without having access to the source code. This is particu-
larly important when you consider commercial class libraries, from which a user can
derive his or her own classes and virtual function versions.
552CHAPTER 25POLYMORPHISM
// cast_t.cpp// Dynamic casts in class hierarchies.
// ----------------------------------------------------
#include "car.h"bool inspect( PassCar* ),       // Inspection ofinspect(Truck* );          // car types.bool separate(Car* );           // Separates cars// for inspection.int main()
{Car* carPtr = new PassCar("520i", true, 3265, "BMW");
Truck* truckPtr = new Truck(8, 7.5, 5437, "Volvo");// ... to test some casts and ...separate(carPtr);
separate(truckPtr);
return 0;}
bool separate( Car* carPtr)
{PassCar* PassCarPtr = dynamic_cast<PassCar*>(carPtr);if( PassCarPtr != NULL)return inspect( PassCarPtr);Truck* truckPtr = dynamic_cast<Truck*>(carPtr);if( truckPtr != NULL)return inspect( truckPtr);return false;}
bool inspect(PassCar* PassCarPtr)
{   cout << "\nI inspect a passenger car!" << endl;cout << "\nHere it is:";PassCarPtr->display();
return true;}
bool inspect(Truck* truckPtr)
{   cout << "\nI inspect a truck!" << endl;cout << "\nHere it is:";
truckPtr->display();
return true;}The compiler’s option “Run Time Type Information (RTTI)” must be activated, for example, underProject/Settings. The GNU compiler activates these options automatically.NOTE
DYNAMIC CASTS
Using dynamic casts
DYNAMIC CASTS553Safety Issues in Downcasting
Downcasts in class hierarchies are unsafe if you use a C cast or the static cast operator. Ifthe referenced object does not correspond to the type of the derived class, fatal runtime
errors can occur.Given that carPtris a pointer to the base class Car, which is currently pointing to aPassCartype, the statementExample:Truck *truckPtr = static_cast<Truck*>(carPtr);
will not cause a compiler error. But the following statement, truckPtr->setAxles(10);could cause the program to crash.Thedynamic_cast<>Operator
You can use the cast operator dynamic_cast<>to perform safe downcasting in poly-morphic classes. At runtime the operator checks whether the required conversion is
valid or not.Syntax:dynamic_cast<type>(expression)If so, the expression expressionis converted to the target type type. The target typemust be a pointer or reference to a polymorphic class or a voidpointer. If it is a pointertype,expressionmust also be a pointer type. If the target type is a reference,expressionmust identify an object in memory.ExamplesGiven a pointer carPtrto the base class Car, the statementExample:Truck* truckPtr = dynamic_cast<Truck*>(carPtr);performs a downcast to the derived Truckclass, provided the pointer carPtrreallyidentifies a Trucktype object. If this is not so, the dynamic_cast<Truck>operatorwill return a NULL pointer.Given that cabriois a PassCartype object, the following statementsExample:Car& r_car = cabrio;PassCar& r_passCar=dynamic_cast<PassCar&>(r_car);perform a dynamic cast to the “reference to PassCar” type. In any other case, that is, ifthe reference r_cardoes not identify a PassCartype object, an exception of thebad_casttype is thrown.The dynamic cast can also be used for upcasting. The classes involved do not need tobe polymorphic in this case. However, type checking is not performed at runtime. An
erroneous upcast is recognized and reported by the compiler.
exercises
554CHAPTER 25POLYMORPHISM
* * * Car Rental Management * * *P = Add a passenger carT = Add a truck
D = Display all carsQ = QuitYour choice:bool insert(const  string& tp, bool sr,            long n, const string& prod);Add a new passenger car:bool insert(int a, double t, long n,
            const string& prod);Add a new truck:EXERCISESMenu optionsDifferent versions of method 
insert()
EXERCISES555Exercise 1
Modify the vehicle management program to allow an automobile rental company
to manage its fleet of automobiles.First,define a class called 
CityCarthatcontains an array of pointers to the 100 objects in the 
Carclass.This also allows
you to store pointers to objects of the derived class types 
PassCarandTruck.The objects themselves will be created dynamically at runtime.
Define a class CityCarwith an array of pointers to the 
Carclass and anintvariable for the current number of elements in the array.
The constructor will set the current number of array elements to 0.
The destructor must release memory allocated dynamically for the
remaining objects.Make sure that you use a virtual destructor definition

in the base class Carto allow correct releasing of memory for trucks and
passenger vehicles.
Implement two versions of the 
insert()method using the prototype
shown opposite.Each version will allocate memory to an object of the

appropriate type—that is of the 
PassCarorTruckclass—and use thearguments passed to it for initialization.The method should return 
falseif it is impossible to enter another automobile (that is,if the array is full),

andtruein all other cases.Thedisplay()method outputs the data of all vehicles on screen.To
perform this task it calls the existing 
display()method for each object.
Create a new function called 
menu()and store this function in a new
source file.The function will display the menu shown opposite,read,and

return the user’s choice.
Additionally,write two functions,
getPassCar()andgetTruck(),which
read the data for a car or a truck from the keyboard and write the data

into the appropriate arguments.
Create an object of the 
CityCartype in your 
mainfunction.Insert one
car and one truck.These will be the first vehicles of the company’s fleet.
If a user chooses “Add car” or “Add truck,” your program must read the
data supplied and call the appropriate version of 
insert().
556CHAPTER 25POLYMORPHISM
Please type next article?0 = No more articles1 = Fresh food
2 = Prepacked article?Another customer (y/n)?If yes  to recordDialog with the receptionist
In function record()Loop of main()
EXERCISES557Exercise 2
An automatic checkout system for a supermarket chain needs to be completed.
Declare the virtual methods 
scanner()andprinter()in the base classProduct.Also define a virtual destructor.
Write the record()function,which registers and lists products pur-
chased in the store in a program loop.
The function creates an array of 100 pointers to the base class,
Product.The checkout assistant is prompted to state whether a prepacked or

fresh food item is to be scanned next.Memory for each product scanned

is allocated dynamically and referenced by the next pointer in the array.

After scanning all the available items,a sequential list is displayed.The

prices of all the items are added and the total is output at the end.
Now create an application program to simulate a supermarket checkout.

The checkout assistant is prompted in a loop to state whether to define a

new customer.If so,the 
record()function is called;if not,the program
terminates.
solutions
558CHAPTER 25POLYMORPHISM
SOLUTIONSExercise 1
// ----------------------------------------------------//car.h:  Defines the base class Car and//          the derived classes PassCar and Truck// --------------------------------------------------------#ifndef _CAR_H_
#define _CAR_H_#include <iostream>#include <string>using namespace std;class Car{private:long   nr;
string producer;public:Car( long n = 0L, const string& prod = "");
virtual ~Car() {}// Virtual destructor.// Access methods:long  getNr(void) const { return nr; }void  setNr( long n ) { nr = n; }const string& getProd() const { return producer; }void  setProd(const string& p){ producer = p; }virtual void display() const; // Display a car};// The derived classes PassCar and Truck are unchanged// (see Chapter 23).#endif// ------------------------------------------------------//car.cpp// Implements the methods of Car, PassCar, and Truck
// ------------------------------------------------------// Unchanged (see Chapter 23).//
SOLUTIONS559// ------------------------------------------------------//city.h: Defines the CityCar class// ------------------------------------------------------#ifndef _CITY_H_#define _CITY_H_#include "car.h"
class CityCar{private:Car* vp[100];
int cnt;public:CityCar(){ cnt = 0;}~CityCar();bool insert(const string& tp, bool sr,long n, const string& prod);bool insert(int a, double t,long n, const string& prod);void display() const;};
#endif  // _CITY_H// ------------------------------------------------------//city.cpp: Methods of class CityCar// ------------------------------------------------------
#include "city.h"CityCar::~CityCar(){for(int i=0; i < cnt; ++i)delete vp[i];}// Insert a passenger car:bool CityCar::insert(const string& tp, bool sr,long n, const string& prod){if( cnt < 100)
{vp[cnt++] = new PassCar( tp, sr, n, prod);
return true;}elsereturn false;}
560CHAPTER 25POLYMORPHISM
// Insert a truck:bool CityCar::insert( int a, double t,long n, const string& prod){if( cnt < 100)
{vp[cnt++] = new Truck( a, t, n, prod);return true;}
elsereturn false;}void CityCar::display() const{cin.sync(); cin.clear();    // No previous inputfor(int i=0; i < cnt; ++i){vp[i]->display();if((i+1)%4 == 0)  cin.get();}}// --------------------------------------------------//city_t.cpp: Test the CityCar class// --------------------------------------------------#include "city.h"char menu(void);
void getPassCar(string&, bool&, long&, string&);void getTruck(int&, double&, long&, string&);int main(){CityCar carExpress;string tp, prod;  bool   sr;
int    a;    long   n;  double t;// Two cars are already present:carExpress.insert(6, 9.5, 54321, "Ford");
carExpress.insert("A-class", true, 54320, "Mercedes");char choice;do
{   choice = menu();switch( choice ){case 'Q':case 'q': cout << "Bye Bye!"  << endl;break;
SOLUTIONS561case 'P':case 'p': getPassCar(tp, sr, n, prod);carExpress.insert(tp, sr, n, prod  );break;case 'T':
case 't': getTruck(a, t, n, prod);carExpress.insert(a, t, n, prod);break;case 'D':
case 'd': carExpress.display();cin.get();
break;default:  cout << "\a";     // Beepbreak;}}while( choice != 'Q'  && choice != 'q');return 0;}char menu()                         // Input a command.{cout << "\n  * * *  Car Rental Management * * *\n\n"char c;cout <<   "\n           P = Add a passenger car "<<   "\n           T = Add a truck "
<<   "\n           D = Display all cars "<<   "\n           Q = Quit the program "<< "\n\nYour choice: ";cin >> c;return c;}void getPassCar(string& tp, bool& sr, long& n,string& prod){char c;
cin.sync(); cin.clear();cout << "\nEnter data for passenger car:" << endl;cout << "Car type:          "; getline(cin, tp);
cout << "Sun roof (y/n):    "; cin >> c;if(c == 'y' || c == 'Y')sr = true;elsesr = false;cout << "Car number:      "; cin >> n;cin.sync();
cout << "Producer:       "; getline(cin, prod);cin.sync(); cin.clear();}
562CHAPTER 25POLYMORPHISM
void getTruck(int& a, double& t, long& n, string& prod){cout << "\nInput data for truck:" << endl;cout << "Number of axles:     "; cin >> a;cout << "Weight in tons:      ";  cin >> t;
cout << "Car number:          ";    cin >> n;
cin.sync();
cout << "Producer:            "; getline(cin, prod);
cin.sync();}Exercise 2
// ----------------------------------------------------
//product.h: Defining the classes//             Product, PrepackedFood, and FreshFood// ----------------------------------------------------// . . .class Product{private:long   bar;string name;public:Product(long b = 0L, const string& s = ""): bar(b), name(s)
{  }//  Access methods as previously used.virtualvoid scanner();       // Virtual now!virtualvoid printer() const;};// The classes PrepackedFood and FreshFood are unchanged!// Refer to the solutions in Chapter 23.
SOLUTIONS563// ------------------------------------------------------//counter.cpp: Simulates a checkout desk// ------------------------------------------------------#include "product.h"void record();int main(){cout << "\nHere is a checkout desk!" << endl;char c;
while(true)
{cin.sync();cout << "\nAnother customer (y/n)?   ";
cin  >> c;if(c == 'y' || c == 'Y')record();elsebreak;}
return 0;}// ------------------------------------------------------// record() : Records the articles bought by a customer
//            and the total price.
void record(){Product* v[100];
int x, i, cnt = 0;double sum = 0.0;for (i = 0; i < 100; i++){cin.sync();
cout << "\nWhat is the next article?" << endl;
cout << "  0 = No more article\n"<< "  1 = Fresh Food\n"<< "  2 = Prepacked article\n"
<< "? " ;cin  >> x;if( x <= 0 || x >= 3)break;
564CHAPTER 25POLYMORPHISM
switch(x){case 2:v[i] = new PrepackedFood;v[i]->scanner();
sum += ((PrepackedFood*)v[i])->getPrice();
break;case 1:v[i] = new FreshFood;v[i]->scanner();
sum += ((FreshFood*)v[i])->getPrice()* ((FreshFood*)v[i])->getWght();break;}}cnt = i;for( i=0; i < cnt; i++)           // Outputv[i]->printer();cout << "\n-----------------------------"<< fixed << setprecision(2)<< "\nTotal price:   " << sum << endl;}
565Abstract ClassesThis chapter describes how abstract classes can be created by defining
pure virtual methods and how you can use abstract classes as a

polymorphic interface for derived classes.To illustrate this we will be

implementing an inhomogeneous list,that is,a linked list whose elements

can be of various class types.
chapter
26
566CHAPTER 26ABSTRACT CLASSES
// Coworker.h:  Defining the abstract class Coworker.// ----------------------------------------------------#ifndef _COWORKER_H
#define _COWORKER_H#include <string>#include <iostream>using namespace std;class Coworker{private:string name;// more informationpublic:Coworker( const string& s = ""){ name = s; }
virtual ~Coworker() {}     // Destructorconst string&  getName() const{ return name; }void  setName( const string& n){ name = n; }virtual void display() const;virtual double income() const = 0;virtual Coworker& operator=(const Coworker&);};#endifThe virtual operator function for the assignment will be described in the section on ”VirtualAssignments.”NOTE
PURE VIRTUAL METHODS
The base class Coworker
PURE VIRTUAL METHODS567Motivation
Virtual methods are declared in the base class to ensure that they are available in anyderived classes via the common class interface. It may happen that they rarely perform
any useful tasks in the base class. For example, a destructor in a base class does not need
to perform any explicit cleaning-up operations.In this case, of course, you can define a virtual dummy method whose address isentered in the VMT of the base class. However, this creates op-code for a function that
should never be called. It makes more sense not to define a function like this. And this is
where C++ steps in and gives you the opportunity of declaring pure virtual methods.Declaration
When a pure virtual method is declared, the method is identified by adding the expres-sion= 0.Example:virtual void demo()=0;  // pure virtualThis informs the compiler that there is no definition of the demo()method in the class.A NULL pointer is then entered in the virtual method table for the pure virtual method.The Base Class CoworkerThe opposite page shows a definition of the Coworkerclass, which was designed to rep-resent human resources data for a company. The class is used as a base class for various
employees, blue-collar, white-collar, and freelancers.To keep things simple the Coworkerclass has only a name as a data member. How-ever, it could also contain the address of an employee, or the division where the
employee works.TheCoworkerclass does not comprise data members to represent an employee’ssalary. It makes more sense to store data like this in derived classes where the hourly
wage and number of hours worked by a blue-collar worker and the monthly salary for a
white-collar worker are also defined. The income()method is therefore not defined forthe base class and can be declared as a pure virtual method.
568CHAPTER 26ABSTRACT CLASSES
// coworker.h:   Extending the headerfile.// --------------------------------------------------
class Laborer : public Coworker
{private:double wages;             // Pay per hourint    hr;public:Laborer(const string& s="", double w=0.0, int h=0): Coworker(s), wages(w), hr(h){ }double getWages() const { return wages; }void   setWages( double w ){ wages = w; }int    getHr() const { return hr; }void   setHr(int h ) { hr = h; }void   display() const;double income() const;Laborer& operator=(const Coworker&);Laborer& operator=(const Laborer&);};The operator functions for the assignments are discussed in the section ”Virtual Assignments.”NOTE
ABSTRACT AND CONCRETE CLASSES
The derived class 
Laborer
ABSTRACT AND CONCRETE CLASSES569Concrete or Abstract?
If a class comprises pure virtual methods, you cannot create objects of this class type.Example:Coworker worker("Black , Michael");The compiler will issue an error message here, as the Coworkerclass contains thepure virtual method income(). This avoids calling a method for workerthat stillneeds to be defined.A class that does not allow youto create any objects is referred to as an 
abstract class.In contrast, a class that allows you to create objects is referred to as a concrete class.Deriving Abstract Classes
When a class is derived from an abstract class, it inherits all the methods the base classcontains, particularly the pure virtual methods. If all of these pure virtual methods are
implemented in the derived class, you can then create an object of the derivedclass type. 
This means you need to implement the income()method in the Laborerclassshown opposite. Since the hourly wage and the number of hours worked are both defined
for blue-collar workers, it is possible to implement that method.Example:double Laborer::income(){return ( wages * hr );}A class derived from a concrete class can again contain pure virtual methods, due toadditional definitions in the derived class. In other words, an abstract class can be
derived from a concrete class.An abstract class does not necessarily need to contain pure virtual functions. If theclass contains a protectedconstructor, objects of the class type cannot be created.The constructor can only be called then by methods in derived classes. A constructor of
this type normally acts as base initializer, when an object of a derived class type is cre-
ated.A class with pure virtual methods is an abstract class.NOTE
A class derived from a class containing pure virtual methods is a concrete class, if it contains a definitionfor each pure virtual function.NOTE

570CHAPTER 26ABSTRACT CLASSES
// coworker.h:   Extending the headerfile.// --------------------------------------------------
class Employee : public Coworker
{private:double salary;       // Pay per monthpublic:Employee( const string& s="", double sa = 0.0): Coworker(s), salary(g){ }double getSalary() const { return salary; }void   setSalary( double sa){ salary = sa; }void   display() const;
double income()const { return salary; }Employee& operator=( const Coworker& );Employee& operator=( const Employee& );};// coworker_t.cpp : Using the Coworker classes.// -------------------------------------------------#include "coworker.h"int main(){Coworker* felPtr[2];felPtr[0] = new Laborer("Young, Neil",45., 40);felPtr[1] = new Employee("Smith, Eve", 3850.0);for( int i = 0; i < 2; ++i){felPtr[i]->display();cout << "\nThe income of " << felPtr[i]->getName()<< " :  " << felPtr[i]->income()<< endl;}delete felPtr[0];  delete felPtr[1];return 0;}POINTERS AND REFERENCES TO ABSTRACT CLASSES
The derived class 
EmployeeSample program

POINTERS AND REFERENCES TO ABSTRACT CLASSES571Although you cannot define objects for abstract classes, you can declare pointers and ref-erences to abstract classes.Example:Coworker *felPtr, &coRef;The pointer felPtris a base class pointer that can address objects belonging to derivedconcrete classes. The reference coRefcan also address objects of this type.References to Abstract Base Classes
References to base classes are often used as parameters in functions. The copy construc-tor in the Coworkerclass is just one of them.Example:Coworker( const Coworker& );The copy constructor expects an object belonging to a derived class, since the base class
is abstract.The assignment in the Coworkerclass has a reference as a parameter and returns areference to the abstract class.Pointers to Abstract Base Classes
Pointers to base classes are generally used to address dynamically allocated objects. If thebase class is abstract, you can only allocate memory for objects belonging to derived, con-
crete classes.Example:Coworker* felPtr;felPtr = new Laborer("Young, Neil",45.,40);
cout << felPtr->income();Since the income()method is virtual, a corresponding function found in the derivedclassLaboreris executed.Polymorphic Interface
Defining pure virtual methods also determines interfaces for general operations, althoughthe interfaces still need to implemented in the derived classes. If a derived class contains
its own definition of a virtual method, this version will also be executed if an object is
referenced by a base class pointer or reference. Abstract classes are therefore also referred
to as polymorphic interfacesto derived classes.The opposite page shows the definition of the Employeeclass, which was alsoderived from the abstract class Coworker. The operator functions for the assignmentsare discussed and implemented in the following section.
572CHAPTER 26ABSTRACT CLASSES
// Virtual Assignment in the base classCoworker& operator=(const Coworker & m){if( this != &m )         // No self assignmentname = m.name;return *this;}Redefining the virtual operator function operator=(), which returns a reference to the derived class,is not yet supported by all compilers. In this case the return type must be a reference to the base class
Coworker.NOTE
// Redefinition: virtualEmployee& operator=(const Coworker& m){if( this != &m )         // No self assignment
{Coworker::operator=( m );
salary = 0.0;}return *this;}// Standard Assignment: not virtualEmployee& operator=(const Employee& a){if( this != &a )
{Coworker::operator=( a );salary = a.salary;}return *this;}VIRTUAL ASSIGNMENT
Assignment for class CoworkerAssignments for class Employee
VIRTUAL ASSIGNMENT573Virtual Operator Functions
Operator functions implemented as methods can also be virtual. In this case, you canensure that the right version of an operator function will be executed when using a
pointer or reference to a base class to address a derived class object.One example of this is the operator function for an assignment. If the function decla-ration is not virtual, and if the function is called via a base class pointer, only the base
data of the object is overwritten. Any additional data members of the derived class
remain unchanged.Using Virtual Assignments
The assignment was declared virtual in the Coworkerbase class. The derived classesLaborerandEmployeeboth contain their own versions. Thus, in the followingExample:void cpy(Coworker& a,const Coworker& b){ a = b; }the assignment of the Employeeclass is executed, if an object of this class type is thefirst argument passed to it. If the object is a Laborertype, the assignment of theLaborerclass is performed.In the case of the cpy()function, you can therefore assign two objects of any class,including classes derived at a later stage, without having to modify the function itself!
However, you definitely need to define a version of the assignment for each derived class.Redefining the Standard Assignment
When you define a new version for a virtual method in a derived class, this implies usingthe signature of the original method. Since the standard assignment of a derived class has
a signature of its own, it is notvirtual. The standard assignment for the Laborerclasshas the following prototype:Example:Laborer& operator=(const Laborer&);The type const Laborer&is different from the const Coworker&type of theparameter in the virtual operator function of the base class. The standard assignment
thus masks the virtual assignment in the base class. This gives rise to two issues:the virtual operator function for the assignment must be defined for every derived
classto ensure that the standard assignment is also available, the standard assignment
must also be redefined in every derived class.
574CHAPTER 26ABSTRACT CLASSES
// cell.h: Defining the classes Cell, BaseEl, and DerivedEl// --------------------------------------------------------#ifndef _CELL_#define _CELL_
#include <string>#include <iostream>using namespace std;class Cell{private:Cell* next;protected:Cell(Cell* suc = NULL ){ next = suc; }public:virtual ~Cell(){ }// Access methods to be declared here.virtual void display() const = 0;};class BaseEl : public Cell
{private:string name;public:BaseEl( Cell* suc = NULL, const string& s = ""):  Cell(suc), name(s){}
// Access methods would be declared here.void display() const;};class DerivedEl : public BaseEl{private:string rem;public:DerivedEl(Cell* suc = NULL,const string& s="",const string& b=""): BaseEl(suc, s), rem(b) { }// Access methods would be declared here.void display() const;};#endifAPPLICATION:INHOMOGENEOUS LISTS
The abstract base class Celland derived classes

APPLICATION: INHOMOGENEOUS LISTS5751st  list elementInfoInfo
Pointer
2nd  list element3rd  list element
Info
PointerPointer
Terminology
Let’s look into implementing an application that uses an inhomogeneous list. An inho-mogeneous list is a linear list whose elements can be of different types. If the data you
need to store consists of objects in a class hierarchy, one list element could contain an
object belonging to the base class, whereas another could contain an object of a derived
class.Due to implicit type conversions in class hierarchies, you can use the base class point-ers to manage the list elements, that is, you can manage the elements in a linked list.
The following graphic illustrates this scenario:Representing List Elements
To separate the management of list elements from the information contained in the list,we have defined an abstract class called Cellas a base class for all list elements. Theclass contains a pointer of type Cell*as the data member used to link list elements.SinceCelltype objects are not be created, the constructor in the Cellclass has aprotecteddeclaration.TheCellclass does not contain any data that might need to be output. However,each class derived from Cellcontains data that need to be displayed. For this reason,Cellcontains a declaration of the pure virtual method display(), which can be mod-ified for multiple derivations.The classes BaseElandDerivedEl, which are derived from Cell, represent listelements used for storing information. To keep things simple, the BaseElclass containsonly a name, and the DerivedElclass additionally contains a comment. The publicdeclaration section contains a constructor and access method declarations. In addition, a
suitable version of the display()method is defined. Both classes are thus concreteclasses.
576CHAPTER 26ABSTRACT CLASSES
InfoInfo
PointerNewelement:InfoPointerPointer
Info// List.h:  Defining the class InhomList// ---------------------------------------------#ifndef _LIST_H#define _LIST_H
#include "cell.h"class InhomList{private:Cell* first;protected:Cell* getPrev(const string& s);void  insertAfter(const string& s,Cell* prev);void  insertAfter(const string& s,const string& b,Cell* prev);public:// Constructor, Destructor etc....void  insert(const string& n);
void  insert(const string& n, const string& b);void displayAll() const;};
#endifvoid InhomList::insertAfter(const string& s, Cell* prev){if( prev == NULL )   // Insert at the beginning,first = new BaseEl( first, s);else                 // middle, or end.{Cell* p = new BaseEl(prev->getNext(), s);prev->setNext(p);}}IMPLEMENTING AN INHOMOGENEOUS LIST
Defining class InhomListInserting a list element in the middle
Definition of insertAfter()version

IMPLEMENTING AN INHOMOGENEOUS LIST577TheInhomListClassThe inhomogeneous list must allow sorted insertion of list elements. It is no longer suffi-cient to append elements to the end of the list; instead, the list must allow insertion at
any given point. A pointer to the first element in the list is all you need for this task. You
can then use the pointer to the next list element to access any given list element.The definition of the InhomListclass is shown opposite. A pointer to Cellhasbeen declared as a data member. The constructor has very little to do. It simply sets the
base class pointer to NULL, thus creating an empty list.The list will be sorted by name. When inserting a new element into the list, the inser-tion point—that is the position of the element that will precede the new element—must
first be located. In our example, we first locate the immediate lexicographical predeces-
sor. The getPrev()method, shown opposite, performs the search and returns eitherthe position of the predecessor or NULL if there is no predecessor. In this case, the new
list element is inserted as the first element in the list.Inserting a New List Element
After finding the insertion position you can call the insertAfter()method that allo-cates memory for a new list element and inserts the element into the list. There are two
cases that need to be looked at:1.If the new element has to be inserted at the start of the list, what was originally
the first element now becomes the second. The new element becomes the first
element. The firstpointer thus needs updating.2.If the new element is inserted at any other position in the list, the 
firstpointeris not affected. Instead, you have to modify two pointers. The pointer in the pre-
ceding list element must be pointed at the new element and the pointer in the
new element must be pointed at what was formerly the successor of the preceding
element. This situation also applies in cases where the successor was a NULL
pointer, in other words, when the new element is appended to the list.Since the list contains objects of the BaseElandDerivedEltypes, theinsertAfter()method has been overloaded with two versions. They differ only indifferent calls to the newoperator.Theinsert()method was overloaded for the same reason. Both versions first callthegetPrev()method and the corresponding version of the insertAfter()method.
exercise
578CHAPTER 26ABSTRACT CLASSES
class InhomList{private:Cell* first;protected:Cell* getPrev(const string& s);
Cell* getPos(const string& s);void  insertAfter(const string& s, Cell* prev);void  insertAfter(const string& s,const string& b,Cell* prev);void  erasePos(Cell* pos);public:InhomList(){ first = NULL; }
InhomList(const InhomList& src);
~InhomList();InhomList& operator=( const InhomList& src);
void  insert(const string& n);void  insert(const string& n, const string& b);void  erase(const string& n);void displayAll() const;};EXERCISEThe complete class InhomList
EXERCISE579Exercise
Modify and complete the definition of the class InhomList,which represents an
inhomogeneous list.Write the destructor for the 
InhomListclass.The destructor releases
the memory occupied by the remaining list elements.
Implement the getPrev()method and both versions of the 
insert()andinsertAfter()methods.The algorithm needed for inserting list ele-
ments was described in the section “Implementing an Inhomogeneous

List.”
Implement the displayAll()method,which walks through the list
sequentially,outputting each element.
Test insertion and output of list elements.Check whether the comments

on the objects are output,if present.
Define the getPos()method,which locates the position of an element
to be deleted.If the element is in the list,its address is returned.Other-

wise a NULL pointer is returned.
Write the erasePos()method,which deletes a list element at a given
position.Pay attention to whether the element to be deleted is the first

or any other element in the list.Since the destructor for 
Cellwasdeclared virtual,only one version of the 
deletePos()method is neces-sary.
Define the erase()method,which deletes a list element with a given
name from the list.
Test deletion of list elements.Continually display the remaining elements

in the list to be certain.
Now implement the copy constructor and assignment.Use the 
insert()to construct the list,calling the applicable version of the method.You can

call the typeid()operator to ascertain the type of the list element
currently to be inserted.The operator is declared in the header file
typeinfo.Example:if( typeid(*ptr) == typeid(DerivedEl)) ...The expression is true if 
ptrreferences a 
DerivedEltype object.Then test the copy constructor and the assignment

solution
580CHAPTER 26ABSTRACT CLASSES
SOLUTION// ------------------------------------------------------//cell.h// Defines the classes Cell, BaseEl, and DerivedEl.// ------------------------------------------------------#ifndef _CELL_
#define _CELL_#include <string>#include <iostream>
using namespace std;class Cell{private:Cell* next;protected:Cell(Cell* suc = NULL ){ next = suc; }public:virtual ~Cell(){ }Cell* getNext() const { return next; }
void  setNext(Cell* suc) { next = suc; }virtual void display() const = 0;};class BaseEl : public Cell{private:string name;public:BaseEl( Cell* suc = NULL, const string& s = ""):  Cell(suc), name(s){}// Access methods:void    setName(const string& s){ name = s; }const string& getName() const { return name; }void display() const{cout << "\n--------------------------------"<< "\nName:       " << name << endl;}};
SOLUTION581class DerivedEl : public BaseEl{private:string rem;public:DerivedEl(Cell* suc = NULL,const string& s="", const string& b=""): BaseEl(suc, s), rem(b){ }// Access methods:void    setRem(const string& b){ rem = b; }
const string& getRem() const { return rem; }
void display() const{BaseEl::display();
cout << "Remark:     " << rem << endl;}};
#endif// ------------------------------------------------------//List.h: Defines the class InhomList// ------------------------------------------------------#ifndef _LIST_H_
#define _LIST_H_
#include "cell.h"class InhomList{private:Cell* first;protected:Cell* getPrev(const string& s);Cell* getPos( const string& s);
void  insertAfter(const string& s, Cell* prev);void  insertAfter(const string& s,const string& b,Cell* prev);void  erasePos(Cell* pos);public:InhomList(){ first = NULL; }InhomList(const InhomList& src);~InhomList();
InhomList& operator=( const InhomList& src);void  insert(const string& n);void  insert(const string& n, const string& b);
void  erase(const string& s);void displayAll() const;};
#endif
582CHAPTER 26ABSTRACT CLASSES
// ------------------------------------------------------//List.cpp: The methods of class InhomList// ------------------------------------------------------#include "List.h"#include <typeinfo>// Copy constructor:InhomList::InhomList(const InhomList& src)
{// Append the elements from src to the empty list.first = NULL;
Cell *pEl = src.first;
for(  ; pEl != NULL;  pEl = pEl->getNext() )if(typeid(*pEl) == typeid(DerivedEl))insert(dynamic_cast<DerivedEl*>(pEl)->getName(),dynamic_cast<DerivedEl*>(pEl)->getRem());elseinsert(dynamic_cast<BaseEl*>(pEl)->getName());}// Assignment:InhomList& InhomList::operator=(const InhomList& src){// To free storage for all elements:
Cell *pEl = first,*next = NULL;while( pEl != NULL ){next = pEl->getNext();delete pEl;pEl = next;}first = NULL;                // Empty list// Copy the elements from src to the empty list.pEl = src.first;for(  ; pEl != NULL;  pEl = pEl->getNext() )if(typeid(*pEl) == typeid(DerivedEl))insert(dynamic_cast<DerivedEl*>(pEl)->getName(),dynamic_cast<DerivedEl*>(pEl)->getRem());elseinsert(dynamic_cast<BaseEl*>(pEl)->getName());return *this;}
SOLUTION583// Destructor:InhomList::~InhomList()
{Cell *pEl = first,*next = NULL;while( pEl != NULL )
{next = pEl->getNext();
delete pEl;
pEl = next;}}Cell* InhomList::getPrev(const string& n){Cell *pEl  = first,*prev = NULL;while( pEl != NULL  )
{if( n > dynamic_cast<BaseEl*>(pEl)->getName() )
{prev = pEl;   pEl  = pEl->getNext();}elsereturn prev;}
return prev;}Cell* InhomList::getPos( const string& n){Cell *pEl  = first;
while( pEl != NULL  &&(n != dynamic_cast<BaseEl*>(pEl)->getName()))pEl  = pEl->getNext();if( pEl != NULL  &&n == dynamic_cast<BaseEl*>(pEl)->getName())return pEl;elsereturn NULL;}void InhomList::insertAfter(const string& s, Cell* prev){if( prev == NULL )    // Insert at the beginning:first = new BaseEl( first, s);else                  // In the middle or at the end:
{  Cell* p = new BaseEl(prev->getNext(), s);prev->setNext(p);}}
584CHAPTER 26ABSTRACT CLASSES
void InhomList::insertAfter( const string& s,const string& b, Cell* prev){if( prev == NULL )      // Insert at the beginning:first = new DerivedEl( first, s, b);else                    // In the middle or at the end:{Cell* p = new DerivedEl(prev->getNext(), s, b);
prev->setNext(p);}}void InhomList::insert(const string& n){Cell* pEl = getPrev(n);
insertAfter(n, pEl);}void  InhomList::insert(const string& n, const string& b){Cell* pEl = getPrev(n);insertAfter(n, b, pEl);}void  InhomList::erasePos(Cell* pos){Cell* temp;if( pos != NULL)if( pos == first )      // Delete the first element
{temp = first;first = first->getNext();
delete temp;}else          // Delete from the middle or at the end
{                       // Get the predecessortemp = getPrev( dynamic_cast<BaseEl*>(pos)->getName());if(temp != NULL)      // and bend pointer.temp->setNext(pos->getNext());delete pos;}}void  InhomList::erase(const string& n){erasePos( getPos(n));}
SOLUTION585void InhomList::displayAll() const{Cell* pEl = first;
while(pEl != NULL)
{pEl->display();
pEl = pEl->getNext();}}// ------------------------------------------------------//List_t.cpp: Tests the sorted inhomogeneous list// ------------------------------------------------------#include "List.h"
int main(){InhomList liste1;cout << "\nTo test inserting. " << endl;liste1.insert("Bully, Max");liste1.insert("Cheers, Rita", "always merry");
liste1.insert("Quick, John", "topfit");
liste1.insert("Banderas, Antonio");liste1.displayAll(); cin.get();
cout << "\nTo test deleting. " << endl;
liste1.erase("Banderas, Antonio");liste1.erase("Quick, John");
liste1.erase("Cheers, Rita");liste1.displayAll(); cin.get();
cout << "\n----------------------------------"<< "\nGenerate a copy and insert an element. "
<< endl;InhomList liste2(liste1),     // Copy constructorliste3;             // and an empty list.liste2.insert("Chipper, Peter", "in good temper");liste3 = liste2;              // Assignment
cout << "\nAfter the assignment:  " << endl;
liste3.displayAll();return 0;}
This page intentionally left blank 
587Multiple InheritanceThis chapter describes how new classes are created by multiple
inheritance and explains their uses.Besides introducing you to creating

and destroying objects in multiply-derived classes,virtual base classes are

depicted to avoid ambiguity in multiple inheritance.
chapter
27
588CHAPTER 27MULTIPLE INHERITANCE
class MotorHome : public Car, public Home{private:// Additional private members hereprotected:// Additional protected members herepublic:// Additional public members here};CarHomeMotorHomeMULTIPLY-DERIVED CLASSES
The multiply-derived class 
MotorHomeDefinition scheme for class MotorHome
MULTIPLY-DERIVED CLASSES589A class can contain not just one but several different base classes. In this case the class isderived from multiple base classes in a process known as multiple inheritance.The Multiply-Derived Class 
MotorHomeThis class Caris used to represent vehicles and the class Homecontains characteristicvalues for an apartment, such as floor space, number and type of rooms, and typical oper-
ations, such as building, selling, or renting.Using these two classes you can then derive the MotorHomeclass. The opposite pageshows the inheritance and definition schemes for the new class. An object of theMotorHomeclass contains both the members of Carand the members of Home. Morespecifically, the object contains two base sub-objects of type CarandHome.Accessibility of Base ClassesSince the MotorHomeclass has two publicbase classes, it assumes the publicinter-faces of both classes. A MotorHometype object not only allows access to the additionalpublicmembers but to all the publicmembers of the base classes CarandHome.When defining a multiply-derived class, the accessibility, private,protected, orpublic, must be defined separately for each base class. The MotorHomeclass couldhave the publicbase class Carand the protectedbase class Home.Example:class MotorHome:public Car,protected Home{  . . . };If the keyword is omitted, the base class will default to private.Example:class MotorHome : public Car, Home
{ . . . };This statement defines the publicbase class Carand the privatebase class Home.This makes all the publicmembers in Homeprivate
members of the derived class.In multiple inheritance each publicbase class establishes an is relationship.This issimilar to simple inheritance. If the MotorHomeclass inherits two publicbase classes,a motor-homeisa special kind of motor vehicle and a special kind of home.
590CHAPTER 27MULTIPLE INHERITANCE
CarCarPassCarVanSUVclass SUV : public PassCar, public Van{// Here are additional methods and data members};MULTIPLE INDIRECT BASE CLASSES
The multiple indirect base class 
CarDefinition scheme of class SUV
MULTIPLE INDIRECT BASE CLASSES591Multiple Identical Base ClassesWhen multiply-derived classes are defined, a direct base class cannot be inherited morethan once. The following statementExample:class B : public A, public A   // Error{ . . . };causes the compiler to issue an error message.A class can be derived from several classes that have a common base class, however.This class is then referred to as a multiple indirect base class.The inheritance graph on the opposite page shows the multiply-derived class SUV,which was derived from the classes PassCarandVan. Both base classes were them-selves derived from the Carclass. This makes Cara multiple indirect base class of theSUVclass.AmbiguityAn object of the SUVclass thus contains the members of Cartwice. Access to membersof the Carclass results in ambiguity.Example:SUV mySUV(. . .);cout << mySUV.getProd();   // ErrorBoth the base classes PassCarandVancontain a method called getProd(), whichthey both inherited from the Carclass. In this case the compiler cannot decide whichmethod is meant.Ambiguity in the context of multiple inheritance is also possible when severalbaseclasses contain members with identical names. If both the Homeclass and the Carclasscontain a method called getNr(), the getNr()method cannot be correctly identifiedin the following statement.Example:MotorHome motorHome( . . .);motorHome.getNr();To resolve ambiguity of this kind, you can use the scope resolution operator to determinewhich base class is meant.Example:cout << motorHome.Home::getNr();cout << mySUV.PassCar::getProd();ThegetNr()method in the Homeclass is called first, followed by the getProd()method inherited by PassCarfrom the Carclass.
592CHAPTER 27MULTIPLE INHERITANCE
CarPassCarVanSUVclass PassCar : public virtual Car{// Here are additional members// of class PassCar};class Van : public virtual Car{// Here are additional members// of class Van};VIRTUAL BASE CLASSES
The virtual base class 
CarDefinition scheme
VIRTUAL BASE CLASSES593IssuesYou will not normally want a class created by multiple inheritance to contain multipleinstances of an indirect base class. Why should a station wagon contain two versions of
the manufacturer’s name or the chassis number for example? So you might be asking
yourself whether you can define multiply-derived classes that will contain only one
instance of an indirect base class.C++ uses virtual base classes to do this. An object in a multiply-derived class containsonly one instance of the members in a virtual base class. The inheritance graph on the
opposite page uses the SUVclass to illustrate this situation.Declaration
A direct base class is declared virtual when a derived class is defined. You can use thevirtualkeyword, which directly precedes the name of the base class.In the definition scheme shown opposite, the Carclass becomes the virtual base classofPassCarandVan. However, the fact that the base class Caris virtual has no signifi-cance at this point.A virtual base class takes effect in cases of multiple inheritance. The following defi-nitionExample:class SUV: public PassCar, public Van{ . . . };ensures that the SUVclass only contains one instance of the virtual base class Car. Anobjectmyof the SUVclass gets sufficient memory for only one Carclass sub-object.More specifically, the statementExample:cout<<"Producer: " << mySUV.getProd();does not cause ambiguity.The following items are important with respect to virtual base classes:a virtual base class stays virtual even if further derivations are built. Each class
derived from PassCaralso has the Carclass as a virtual base class.you cannot change the declaration of an indirect base class to virtual.You must therefore decide what classes are to be declared virtual when you design theclass hierarchy. Later modifications will require modifications to the source code of any
derived classes.
594CHAPTER 27MULTIPLE INHERITANCE
Base1Base2Base3
MultiDerivedclass multiDerived : public Base1, public Base2,public Base3{// Here are additional data members and methods};CONSTRUCTOR CALLS
Building an inheritance graphClass DefinitionInheritance graph
CONSTRUCTOR CALLS595Initialization
When an object is created in a simply-derived class, the sub-objects of the base classesare created first on all levels of the class hierarchy. The sub-object whose class is nearer
to the top of the inheritance graph is created first.The order of the constructor calls is “top down” and follows the inheritance graph.The activation order used for the constructors in simple inheritance has been generalized
for multiple inheritance.Inheritance GraphAgain, the inheritance graph, also called sub-object lattice, has an important job to do.When a derived class is defined, the following rules apply:In cases of multiple inheritance, base classes are entered into the inheritance
graph from left to right in the order in which they were stated when the class was
defined. The graph opposite illustrates this point.If the class hierarchy does not contain any virtual base classes, the following applies tothe activation order of the constructors.The base class constructors are executed first, top-down and from left to right on
each level.Finally, the constructor belonging to the current class, which is at the bottom of
the inheritance graph, is executed.If we look at the example on the opposite page, this means that the sub-objects of thebase classes Base1,Base2, and Base3are created in this order. Then the constructorofMultiDerivedis executed.Base Initializers
The constructor for the class at the bottom end of the inheritance graph uses base initial-izers to pass the values to the direct and indirect base classes. If the base initializer defini-
tion is missing in a constructor definition, the default constructor of the base class is
automatically executed.Initial values are thus passed to the base class constructors “bottom up.”
596CHAPTER 27MULTIPLE INHERITANCE
class SUV : public PassCar, public Van{private:// . . .public:SUV( ... ) : Car( ... )
{// Initialize additional data members}void display() const{PassCar::display();
Van::display();// Output additional data members}};INITIALIZING VIRTUAL BASE CLASSES
ClassSUV
INITIALIZING VIRTUAL BASE CLASSES597Constructor Calls in Virtual Base Classes
When an object is created for a multiply-derived class, the constructors of the baseclasses are called first. However, if there is one virtual base class in the class hierarchy,
the virtual base class constructor is executed beforea constructor of a non-virtual baseclass is called. The constructors of the virtual base classes are called first, followed by the constructors of non-virtualbase classes in the order defined in the inheritance graph.NOTE
The constructor of a virtual base class is called with the arguments stated for the base initializer of the
lastclass to be derived, i.e. class at the bottom end of the inheritance graph.NOTE
The constructor of the virtual base class nearest the top of the inheritance graph isexecuted first. This does not necessarily mean the top level of the class hierarchy, since a
virtual base class can be derived from a non-virtual base class.In our example with the multiply-derived class SUV(Sport Utility Vehicle) the con-structor for the virtual base class Caris called first, followed by the direct base classesPassCarandVan, and last but not least, the constructor of the SUVclass.Base Initializers
You may be wondering what arguments are used to call the constructor of a virtual baseclass. A base initializer of the directly-derived class or any other derivation could be
responsible. The following applies: The example opposite shows SUVcontaining a constructor with onebase initializer.Its arguments are passed to the constructor of the virtual base class Car.For the purpose of initialization, it does not matter whether a class derived directlyfromCarcontains a base initializer or not. Base initializers for virtual indirect baseclasses defined in the constructor of a direct base class are ignored. If the base classesPassCarandVanalso contained base initializers for the virtual base class Car, thesewould be ignored too.If the constructor for the last derived class does not contain a base initializer, thedefault constructor is executed for each virtual base class. Whatever happens, a default
constructor must then exist in every virtual base class! Thus, base initializers that happen
to exist in base classes are also ignored.
exercises
598CHAPTER 27MULTIPLE INHERITANCE
Data member:
Type
catCATEGORY
Methods:MotorHome(CATEGORY, long, const string&, int, double );void     setCategory(CATEGORY )CATEGORY getCategory() const ;void display() const;CarHomeMotorHomeEXERCISESThe multiply-derived class 
MotorHomeAdditional members of class 
MotorHome
EXERCISES599Exercise 1
The multiply-derived class 
MotorHomeneeds to be fully implemented and tested.
Define an enumeration type 
CATEGORYthat represents the categories
“Luxury,” “First Class,” “Middle Class,” and “Economy”.
Develop a class called 
Homewith two data members used to store the
number of rooms and the size in square meters.Supply default values for

your constructor definition to create a default constructor.In addition to

access methods,also define the method 
display(),which outputs the
data members of an apartment.
Define a class derived from the 
CarandHomeclasses called MotorHome,which is used to represent motorhomes.Inheritance of 
publicbaseclasses is used.The 
MotorHomeclass contains a new data member used to
store one value of the 
CATEGORYtype.In addition to defining a construc-
tor with default values,also define appropriate access methods and a
display()method for output.
Place your definitions of the 
HomeandMotorHomeclasses in a separateheader file,which includes the existing header file 
car.h.Write a mainfunction that first fully initializes a 
MotorHometype objectand then outputs the object.Then create a second instance of the 
MotorHometype without initial val-ues and display the object on screen.Call all the set methods in the
MotorHomeclass and its base classes to set your own values for the
objects.Then output the object once more.

600CHAPTER 27MULTIPLE INHERITANCE
Class hierarchy for the multiply-derived class 
SUVCarData members:car numberproducerSUVData members:number of seatsPassCarData members:car typesun roof (y/n)VanData members:capacity  (lbs)
EXERCISES601Exercise 2
Now fully define the 
SUVclass for testing virtual base classes.
Change the definition of the PassCarclass in the car.hheader file tomake 
Cara virtual base class of the 
PassCarclass.Then define the Vanclass using the Carclass as a virtual base class.The
new class should contain an additional data member used to represent

the payload of the van in kilograms.A maximum of 750 kg applies to vans.

The constructor should use default values to initialize the data members
with defaults,thus providing a default constructor for the class.A maxi-

mum value of 750 applies for the payload.In addition to the access

methoddisplay(),you still need to define methods for screen output.
Create the class 
SUV,which is derived from 
PassCarandVan,to repre-
sent a station wagon.Store the number of seats available in the station

wagon as a data member.
The constructor in the SUVclass should use the base initializer to set allthe values of a station wagon using default values for every data member.
Additionally,define access methods and a 
display()to define output.Use a mainfunction to test the SUVclass;the function should create sta-
tion wagons with and without default values and display them on screen.

solutions
602CHAPTER 27MULTIPLE INHERITANCE
SOLUTIONSExercise 1
// ------------------------------------------------------//car.h:  Definition of base class Car and//          derived classes PassCar and Truck// ------------------------------------------------------//car.cpp// Implementing methods of Car, PassCar, and Truck// ------------------------------------------------------
//// These files have been left unchanged// from Chapters 23 and 25.//// ------------------------------------------------------//motorHome.h: Definition of the class Home and the//               multiply-derived class MotorHome
// ------------------------------------------------------#ifndef _MOTORHOME_H_#define _MOTORHOME_H_
#include "car.h"#include <iomanip>#include <iostream>
using namespace std;enum CATEGORY {LUXURY, FIRSTCLASS, SECONDCLASS, ECONOMY};class Home{private:int room;double ft2;public:Home(int r = 0, double m2 = 0.0){ room = r; ft2 = m2;}void setRoom(int n){ room = n;}
int  getRoom() const { return room; }void   setSquareFeet(double m2){ ft2 = m2;}double getSquareFeet() const { return ft2; }
void display() const{cout << "Number of rooms:   " << room<< "\nSquare feet: "
<< fixed << setprecision(2) << ft2 << endl;}};
SOLUTIONS603class MotorHome : public Car, public Home{private:CATEGORY cat;public:MotorHome(long n=0L, const string& prod="", int ro=0,double m2=0.0, CATEGORY k=ECONOMY): Car(n, prod), Home(ro, m2), cat(k)
{}void      setCategory(CATEGORY c){cat = c;}CATEGORY  getCategory() const { return cat;}void display() const{cout << "\nMotorHome:   ";
Car::display();Home::display();cout << "Category:    ";
switch(cat)
{case LUXURY:        cout << "    Luxury";break;case FIRSTCLASS:    cout << "   First class";break;case SECONDCLASS:   cout << "   Second class";break;case ECONOMY:       cout << "   Economy";break;}
cout << endl;}};
#endif// ------------------------------------------------------//motorHome_t.cpp// Testing the multiply-derived class MotorHome
// ------------------------------------------------------
#include "motorHome.h"int main(){MotorHome rv(12345L, "Texaco", 2, 40.5, LUXURY);
rv.display();MotorHome holiday;holiday.display();          // Default values
cin.get();
604CHAPTER 27MULTIPLE INHERITANCE
holiday.setNr(54321);holiday.setProd("VW");
holiday.setRoom(1);holiday.setSquareFeet(11.5);holiday.setCategory(SECONDCLASS);
holiday.display();
return 0;}Exercise 2
// ------------------------------------------------------
//car.h:  Definition of base class Car and//          the derived classes PassCar and Truck// ------------------------------------------------------//car.cpp// Implementing the methods of Car, PassCar, and Truck// ------------------------------------------------------//
// These files are carried over from Chapter 23 and 25,// with the following changes://
// Class Car is a virtual base class now
class PassCar : public virtual Car{// ...};class Truck : public virtual Car{// ...};// ------------------------------------------------------//suv.h: Defines the class Van and//         the multiply-derived class SUV// ------------------------------------------------------#ifndef _SUV_H
#define _SUV_H#include "car.h"class Van : public virtual Car{private:double capacity;
SOLUTIONS605public:Van(long n=0L, const string& prod="",double l=0.0): Car(n,prod){if(l > 750)  l = 750;capacity = l;}void setCapacity(double l){if(l > 750)capacity= 750;elsecapacity = l;}double getCapacity() const { return capacity; }void display() const{cout << "Capacity:         "<< capacity  << " kg" << endl;}};class SUV : public PassCar, public Van{private:int cnt;          // Number of seatspublic:SUV(const string& tp="without type", bool sb=false,long n=0L, const string& prod=" none ",double l=0.0, int z = 1): PassCar(tp,sb), Car(n,prod),Van(n,prod,l), cnt(z){ }void display() const{PassCar::display();Van::display();cout << "Number of seats:  " << cnt << endl;}};#endif
606CHAPTER 27MULTIPLE INHERITANCE
// ------------------------------------------------------//suv_t.cpp:  Tests the class SUV// ------------------------------------------------------#include "suv.h"
int main(){SUV mobil("Bravada", true, 120345, "Oldsmobile",350,6);mobil.display();SUV trucky;trucky.display();trucky.setNr(543221);trucky.setProd("Renault");trucky.setCapacity(1000.);trucky.display();return 0;}
607Exception HandlingThis chapter describes how a C++ program uses error-handling
techniques to resolve error conditions.In addition to throwing and

catching exceptions,we also examine how exception specifications are

declared and exception classes are defined,additionally looking into the

use of standard exception classes.chapter
28
608CHAPTER 28EXCEPTION HANDLING
TRADITIONAL ERROR HANDLING
Error checking after leaving a function
First callingfunctionSecond callingfunctionThird callingfunctionCalled function. . .{. . .if(func()>0)
// every-// thing// is ok
 elseexit(-1);. . .}. . .{ . . .if(func()<=0)
// All errors
// are// handled. . .}. . .{
 . .  x= func(); if(x == 0)
 //1. error else if  (x == -1)
 //2. error...}int func( void){ . . . 
 if(dilemma)
  return 0; . . . if(catastrophe)
 return -1; . . .}
TRADITIONAL ERROR HANDLING609Error Conditions
Errors that occur at program runtime can seriously interrupt the normal flow of a pro-gram. Some common causes of errors aredivision by 0, or values that are too large or small for a typeno memory available for dynamic allocationerrors on file access, for example, file not foundattempt to access an invalid address in main memoryinvalid user inputAnomalies like these lead to incorrect results and may cause a computer to crash. Both ofthese cases can have fatal effects on your application.One of the programmer’s most important tasks is to predict and handle errors. Youcan judge a program’s quality by the way it uses error-handling techniques to counteract
any potential error, although this is by no means easy to achieve.Traditional Error Handling
Traditional structured programming languages use normal syntax to handle errors:errors in function calls are indicated by special return valuesglobal error variables or flags are set when errors occur, and then checked againlater.If a function uses its return value to indicate errors, the return value must be examinedwhenever the function is called, even if no error has occurred.Example:if( func()> 0 )// Return value positive => o.k.else// Treat errorsError variables and flags must also be checked after everycorresponding action.In other words, you need to continually check for errors while a program is executing.If you do happen to forget to check for errors, the consequences may be fatal.
610CHAPTER 28EXCEPTION HANDLING
// calc_err.cpp: Defining the function calc(),//               which throws exceptions.// ----------------------------------------------------class Error{// Infos about the error cause};double calc( int a, int b ){if ( b < 0 )throw (string)"Denominator is negative!";if( b == 0 ){Error errorObj;throw errorObj;}return ((double)a/b);}EXCEPTION HANDLINGUsing the throwstatement

EXCEPTION HANDLING611Exception Handling ConceptC++ introduces a new approach to error handling. Exception handlingis based on keepingthe normal functionality of the program separate from error handling. The basic idea is
that errors occurring in one particular part of the program are reported to another part of
the program, known as the calling environment. The calling environment performs centralerror handling.An application program no longer needs to continually check for errors, because inthe case of an error, control is automatically transferred to the calling environment.
When reporting an error, specific information on the error cause can be added. This
information is evaluated by the error-handling routines in the calling environment.ThethrowStatement
An exception that occurs is recorded to the calling environment by means of a throwstatement; this is why we also say that an exception has been thrown.Syntax:throw fault;The expression faultis an exception objectthat is thrownto the calling environment. It
can belong to any type except void.Example:throw "Fire!";In this example, the exception object is a string that is thrown to the calling environ-
ment.Exception ClassesNormally, you define your own exception classes to categorize exceptions. In this caseyou use the throwstatement to throw an object belonging to a specific exception class.An exception class need not contain data members or methods. However, the type,which is used by the calling environment to identify the error, is important. Generally,
the exception class will contain members that provide more specific information on the
cause of the error.In the sample program on the opposite page, the calc()function throws exceptionsin two cases, where the numerator is negative or has a value of 0. In the first case, theexception thrown is a string. In the second case, the exception is an Errorexceptionclass object. Instead of creating a local exception object errorObj, a temporary objectcan be created:Example:throw Error();         // It is shorter
612CHAPTER 28EXCEPTION HANDLING
try{// Exceptions thrown by this block will be// caught by the exception handlers,
// which are defined next.}catch( Type1 exc1)
{// Type1 exceptions are handled here.}[catch( Type2 exc2){// Type2 exceptions are handled here.}. . .             //etc.][catch( ... ){// All other exceptions are handled here.}]The brackets [...]in a syntax description indicate that the enclosed section is optional.NOTE
EXCEPTION HANDLERSSyntax of tryandcatchblocks

EXCEPTION HANDLERS613How Exception Handling Works
The part of a program that performs central error handling in the calling environment isreferred to as an exception handler. An exception handler catches the exception objectthrown to it and performs error handling. The exception object type determines which
handler will catch it and consequently be executed.This means that you need to specify two things when implementing exception han-dling:the part of the program that can throw exceptionsthe exception handlers that will process the various exception types.C++ provides language elements for this task, the keywords tryandcatch. Each key-word precedes a code block and thus they are often referred to as tryandcatchblocks.Syntactically speaking, each tryandcatchblock is a statement, however.tryandcatchBlocksAtry blockcontains the program code in which errors can occur and exceptions can bethrown. Normally, a tryblock will consist of a group of functions that can produce simi-lar errors.Eachcatch blockdefines an exception handler, where the exception declaration, which isenclosed in parentheses, defines the type of exceptions the handler can catch. Thecatchblocks immediately follow the tryblock. A minimum of one catchblock isrequired.The exception handlers defined by the catchblocks catch the exceptions thrownwithin the tryblock. If there is no handler defined for a particular exception type, theprogram will not simply enter an undefined state but will be orderly terminated by a call
to the standard function terminate().It is common practice to define specific handlers for certain types of errors and onegeneric handler for all other errors. This functionality is provided by a special syntax in
thecatchstatement with an exception declaration consisting of just three dots.Syntax:catch( ... ){  // General handler for// all other exceptions}Since the application program decides what reaction is applicable for certain error condi-tions, the tryandcatchblocks are formulated in the application.
614CHAPTER 28EXCEPTION HANDLING
// calc_err.cpp:  Tests the function calc(),//                which throws exceptions.// ----------------------------------------------------
#include <iostream>#include <string>using namespace std;double calc( int a, int b );int main(){int x, y;
double res;bool flag = false;do
{try                                 // try block{cout << "Enter two positive integers: ";cin >> x >> y;
res = calc( x, y);cout << x << "/" << y << " = " << res << endl;flag = true;        // Then to leave the loop.}catch( string& s)              // 1st catch block{cerr << s << endl;}catch( Error& )                // 2nd catch block{cerr << "Division by 0! " << endl;}catch(...)                    // 3rd catch block{cerr << "Unexpected exception! \n";exit(1);}}while( !flag);// continued ...return 0;}As the Errorclass contains no data members, the corresponding catchblock declares only the typeof exception, and no parameters. This avoids a compiler warning since the parameter is not used.NOTE
THROWING AND CATCHING EXCEPTIONS
Demonstration program

THROWING AND CATCHING EXCEPTIONS615Backing Out of an Error Condition
When the throwstatement is executed, an exception object is thrown. That is, a tem-porary object of the same type and content as the throwexpression is created.Example:throw "Cyclone!";This creates a string as an exception object and copies the string "Cyclone!"to it.Thus, if the throwexpression is a class type, the copy constructor is executed.The exception object is then thrown and the program control leaves the tryblock.Any changes to the stack that took place after entering the tryblock are unwound.This specifically involves destroying any local, non-static objects. Unwinding the stackallow you to back out of the normal program flow in an orderly manner.Searching for Handlers
After leaving the tryblock, the program control is transferred to an matching handlerin the catchblocks that follow. This search operation is always performed sequentiallybeginning with the first catchblock and the exception declaration of the handlerdetermines whether the handler should be executed.A handler is called when the type in the exception declaration isidentical to the exception type thrown ora base class of the exception type ora base class pointer and the exception is a pointer to a derived class.This is why the general exception handler catch( ... )always has to be defined last.Since the first suitable handler will be executed, and any exception thrown will be
caught by the general handler, a handler defined after the general handler would never
be called.Continuing the Program
After executing a handler, the program continues with the first statement following thecatchblocks, unless the handler throws another exception or terminates the program.After completing exception handling, the exception object that was thrown is destroyed.The first two catchblocks handle both exceptions that the calc()function canthrow. In both cases a message is displayed and the program carries on prompting for
input and computing values. If an unexpected exception occurs, a message is again dis-
played, but in this case the program then terminates.
616CHAPTER 28EXCEPTION HANDLING
try{// Type1 exceptions are thrown here.try
{// Type1 and Type2 exceptions are thrown here.}catch( Type2 e2){// Type2 exceptions are pre-handled herethrow;               // and thrown again.}// Other Type1 exceptions// can be thrown.}
catch( Type1 e1){// Type1 exceptions are handled here.}catch(...)
{// All remaining exceptions are handled here,// particularly Type2 exceptions.}This scenario assumes that the error classes Type1andType2are not derived one from another. IfclassType2is derived from class Type1, any Type2exceptions thrown will be caught by the handlerfor the base class Type1.NOTE
NESTING EXCEPTION HANDLINGNestedtryandcatchblocks

NESTING EXCEPTION HANDLING617NestedtryandcatchBlocksA program will normally contain multiple tryblocks with appropriate exception han-dlers. This allows for various error handling in different parts of the program.However, a tryblock can contain additional tryblocks. This allows you to use thehandlers in a nested tryblock for special purpose error handling, leaving the handlers inthe surrounding tryblock to deal with remaining errors. Handlers in a nested tryblockcan also pre-handle specific errors and then pass control to the tryblock wrapper forfinal handling.Re-throwing Exceptions
In the last of these cases an exception thrown by the nested tryblock has to be passedto the tryblock wrapper. This is achieved using a throwstatement that does notexpect an exception object.Example:throw;          // in a catch blockThis re-throws the pre-handled exception, which can then be processed by the handler
in the surrounding tryblock. The statement is only valid within a nested catchblockfor this reason.Exception Specifications
The exceptions that a function can throw are features of that function. The applicationprogrammer must have knowledge of both the function prototype and the exceptions the
function can throw to ensure that he or she will be capable of programming correct func-
tion calls and taking appropriate action in case of errors.The exceptions a function can throw can be stated in a so-called exception specifica-tion list when you declare a function.Example:int func(int) throw(BadIndex, OutOfRange);The list BadIndex,OutOfRangestates the exceptions that the function func()canthrow. If the list is empty, that is, if the list contains only the throw()statement, noexceptions are thrown. If the throwstatement is also missing, there is no specific infor-mation about possible exceptions and any exception can be thrown.
618CHAPTER 28EXCEPTION HANDLING
// calc_new.cpp: New version of function calc(),//               which throws exceptions of type
//               MathError.
// ----------------------------------------------------
#include <string>#include <iostream>using namespace std;class MathError{private:string message;public:MathError( const string& s) : message(s) {}const string& getMessage() const {return message;}};double calc( int a, int b ) throw(MathError);int main(){int x, y;  bool flag = false;
do{try                                 // try block
{cout << "Enter two positive integers: ";cin >> x >> y;
cout << x <<"/"<< y <<" = "<< calc( x, y) << '\n';flag = true;        // To leave the loop.}catch( MathError& err)              // catch block{cerr << err.getMessage() << endl;}}while( !flag);
// continued ...return 0;}double calc( int a, int b ) throw (MathError){  if ( b < 0 )throw MathError("Denominator is negative!");if( b == 0 )throw MathError("Division by 0!");return ((double)a/b);}DEFINING YOUR OWN ERROR CLASSES
Exception handling for numeric operations

DEFINING YOUR OWN ERROR CLASSES619Exception Class MembersWhen an exception is thrown, the exception object type determines which exceptionhandler will be executed. For this reason, an exception class does not need to have any
members.However, an exception class can contain data members and methods—just like anyother class. This makes sense, as locally defined non-static objects are destroyed when an
exception has been thrown and the stack is unwound. Thus, the exception handler can
no longer access the previously existing objects.You can use the data members of error classes to rescue data threatened by an errorcondition. For example, you can store data important for exception handling in an
exception object.The Exception Class MathErrorThe exception class MathErroris defined opposite. The calc()function throws anexception when a number input by a user is negative or 0. When an exception is thrown,Example:throw MathError("Division by 0!");the error message is stored in the exception object. The exception handler can then use
thegetMessage()method to evaluate the message.Exception Hierarchies
New exception classes can be derived from existing exception classes. A base class willnormally represent a general error type and specific errors will be represented by derived
classes.Thus, the exception class MathErrorcould be defined to represent general errors inmathematical computations, but it would make sense to define derived exception classes
for special cases, such as “Division by 0” or “Arithmetic overflow.” You could call these
classesDivisionByZeroandOverflowError, for example.Be aware of the following rules for exception handlers in this context:given that T is a derived exception class, special errors of this type are handled by
the exception handlerif T is a base class, the handler will also catch the exception objects thrown by
derived classes, thus providing similar handling for generic and specific errors.
620CHAPTER 28EXCEPTION HANDLING
invalid_argumentout_of_range
length_errordomain_errorInvalid argumentArgument value not in its expected range
Length exceeds maximum  capacity
Domain error reported by the implementationrange_errorunderflow_error
overflow_errorRange error in internal computationArithmetic underflow error
Arithmetic overflow error// Subscript operator of class FloatArr throws// exceptions with type of standard class out_of_range:// ---------------------------------------------------#include <stdexcept>
#include <iostream>using namespace std;double& FloatArr::operator[](int i) throw(out_of_range){  if( i < 0 || i >= anz )throw out_of_range("Invalid index!");else return arrPtr[i];}// --------------  Test Program  ------------------
int main(){try
{// Uses arrays of type FloatArr}catch(out_of_range& err){cerr << err.what()  << endl;}// The program continues here.}STANDARD EXCEPTION CLASSES
Exception classes derived from 
logic_errorException classes derived from 
runtime_errorUsing standard exception classes

STANDARD EXCEPTION CLASSES621Hierarchy of Standard Exception Classes
The C++ standard library contains various exception classes, which are used in the stringand container libraries, for example. However, the standard exception classes can be
used just like exception classes of your own. Their definitions are to be found in the
header file stdexcept.The standard exception classes are organized in a hierarchy, the common base classbeing the exceptionclass. In addition to a default constructor, a copy constructor, andan assignment, this class contains a virtual publicmethod,what(), which returns amessage on the error cause as a C string.Representing Logic Errors and Runtime Errors
The following exception classes are derived from the exceptionclass:logic_errorused to represent logic errors, caused by anomalies in the program’slogic. These errors can be avoided.runtime_errorused to represent runtime errors, such as under- or overflows occur-
ring in internal computations. These errors are unpredictable.The opposite page contains on overview of the exception classes derived from thelogic_errorandruntime_errorclasses. For example, the method at()in thestringclass throws an out_of_rangetype exception when an invalid string positionis passed to it. If a string cannot be displayed because of its exceptional length, an excep-
tion of the invalid_argumenttype is thrown.An exception of the overflow_errororunderflow_errortype is thrown if thevalue to be displayed is too large or too small for the type in use. The range_errorclass shows range errors, which can occur during internal computations.A constructor with a string as a parameter is defined in every class derived fromexception. This means you can initialize exceptions of these types with error messages.Thewhat()method returns this error message as a C string.
exercises
622CHAPTER 28EXCEPTION HANDLING
Error in reading:Invalid index: ... 
Error in writing:

Invalid index: ... 
EXERCISESExercise 1: Error messages of the exception handlerThe first exception handler’s message:
The second exception handler’s message:

EXERCISES623Exercise 1
TheFloatArrclass needs exception handling for cases where an invalid index is
stated when accessing an array member.
Define the exception class BadIndexfor this purpose and store the class
in the header file “
floatArr.h”.The exception class must contain a data
member to store the invalid index.The constructor expects an index 

that it will copy to the data member.The 
constaccess method getBadIndex()returns the data member.
Both subscript operators should be able to throw 
BadIndextype excep-tions.Add an exception specification to the declaration of the subscript

operators.The methods that expect the position as an argument,such as 
insert()andremove(),should also throw exceptions.Add appropriate exception
specifications to the definitions and change the return types from 
booltovoid.Change the definitions of the methods and operator functions to allow a
BadIndextype exception to be thrown when the index passed to the
function is outside the valid range.
Write a mainfunction where a constant vector is created and initialized
with fixed values.Exception handling is required for the following scenar-

ios.The array elements are displayed and an index is read until an invalid

index value is input.The 
catchhandler should output the information
shown opposite for each invalid index.
Then create a non-constant array.Add further exception handling to be
performed.Elements are appended or inserted within a 
tryblock.Include an invalid element access attempt,which causes the 
catchhan-dler to output the information shown opposite.Then finally output the

array elements outside the 
tryandcatchblocks.
624CHAPTER 28EXCEPTION HANDLING
Exercises
For Exercise 2: Error messages of the exception handlersMessages of the exception handlers
for an exception object of type DivisionByZero:
Error in initializing:The denominator is 0!Error in division:
No division by zero!Error: Denominator is 0!
New denominator != 0: ...
EXERCISES625Exercise 2
Implement exception handling for the 
Fractionclass,which is used to
represent fractions (see Exercise 2,Chapter 19).Dividing by 0 throws an

exception that affects the constructor for the 
Fractionclass and the operatorfunctions/and>>.Define the exception class DivError,which has no data members,within
theFractionclass.The exception class is of the following type
Fraction::DivErrorAdd an appropriate exception specification to the declarations of the

constructor and the operator functions /and>>.Change the definition of the constructor in the Fractionclass.If the
value of the denominator is 0,a 
DivisionByZerotype exception shouldbe thrown.
Similarly modify the operator functions.
Now write a 
mainfunction to test the various exceptions.You will need
to arrange three different 
tryandcatchblocks sequentially.
The first try/catchblock tests the constructor.Create several fractions,
including some with a numerator value of 0 and one with 0 as its

denominator.The exception handler should issue the error message

shown opposite.
The second try/catchblock tests divisions.Use a statement to attempt
to divide by 0.The corresponding exception handler should send the

second error message shown opposite to your standard output.
The third 
try/catchblock reads numerators and denominators of
fractions in dialog.If the value of the denominator is 0,the denominator is

read again.If the value is still 0,the third error message as shown

opposite is output and the program terminates.

solutions
626CHAPTER 28EXCEPTION HANDLING
SOLUTIONSExercise 1
// ------------------------------------------------------//floatArr.h: Represents dynamic float arrays.// Methods throw exceptions for an invalid index.
// ------------------------------------------------------
#ifndef _FLOATARR_
#define _FLOATARR_#include <iostream>using namespace std;class BadIndex{private:int index;public:BadIndex(int i){index = i;}
int getBadIndex() const {return index;}};class FloatArr{private:float* arrPtr;    // Dynamic member
int max;          // Maximum number without// reallocating more memory.int cnt;          // Current number of elements.void expand( int newSize);      // Function to help// enlarge the array.public:FloatArr( int n = 256 );        // Constructors
FloatArr( int n, float val);
FloatArr(const FloatArr& src);
~FloatArr();                    // Destructor
FloatArr& operator=( const FloatArr&);  // Assignmentint  length() const { return cnt; }// Subscript operators:float& operator[](int i) throw(BadIndex);
float operator[](int i) const  throw(BadIndex);// Methods to append a float value// or an array of floats:
void append( float val);
void append( const FloatArr& v);
SOLUTIONS627FloatArr& operator+=( float val){append( val);   return *this;}FloatArr& operator+=( const FloatArr& v)
{append(v);   return *this;}// Methods to insert a float value// or an array of float values:void insert( float val, int pos) throw(BadIndex);
void insert(const FloatArr& v,int pos) throw(BadIndex);
void remove(int pos) throw(BadIndex); // Remove// at pos.// Output the arrayfriend ostream& operator<<( ostream& os,const FloatArr& v){int w = os.width();        // Save field width.for( float *p = v.arrPtr; p < v.arrPtr + v.cnt; ++p)
{os.width(w);  os << *p;}
return os;}};#endif   // _FLOATARR_// -----------------------------------------------------//floatArr.cpp// Implementing the methods of FloatArr.// -----------------------------------------------------
#include "floatArr.h"// ---  Constructors  ---FloatArr::FloatArr( int n ){max = n;   cnt = 0;        // Sets max and cnt.arrPtr = new float[max];   // Allocates memory}FloatArr::FloatArr(int n, float val){max = cnt = n;
arrPtr  = new float[max];for( int i=0; i < cnt; ++i)arrPtr[i] = val;}
628CHAPTER 28EXCEPTION HANDLING
FloatArr::FloatArr(const FloatArr& src){max = src.max;cnt = src.cnt;arrPtr = new float[max];for( int i = 0; i < cnt; i++ )arrPtr[i] = src.arrPtr[i];}// --- Destructor ---FloatArr::~FloatArr()
{delete[] arrPtr;}// Private functions to help enlarge the array.void FloatArr::expand( int newSize)
{if( newSize == max)return;max = newSize;
if( newSize < cnt)cnt = newSize;float *temp = new float[newSize];
for( int i = 0; i < cnt; ++i)temp[i] = arrPtr[i];delete[] arrPtr;arrPtr = temp;}FloatArr& FloatArr::operator=( const FloatArr& src ){if( this != &src )              // No self assignment!
{max = src.max;cnt = src.cnt;delete[] arrPtr;             // Release memory,arrPtr = new float[max];     // reallocate,
for( int i=0; i < cnt; i++)  // copy elements.arrPtr[i] = src.arrPtr[i];}
return *this;}
SOLUTIONS629float& FloatArr::operator[]( int i ) throw(BadIndex){if( i < 0 || i >= cnt )  throw BadIndex(i);return arrPtr[i];}
float FloatArr::operator[]( int i ) const throw(BadIndex)
{if( i < 0 || i >= cnt )  throw BadIndex(i);
return arrPtr[i];}// Append a float value or an array of floats.void FloatArr::append( float val){if( cnt+1 > max)expand( cnt+1);arrPtr[cnt++] = val;}
void FloatArr::append( const FloatArr& v){if( cnt + v.cnt > max)expand( cnt + v.cnt);int count = v.cnt;            // Necessary if// v == *this.for( int i=0; i < count; ++i)arrPtr[cnt++] = v.arrPtr[i];}// Inserts a float value or an array of floats.void FloatArr::insert(float val, int pos) throw(BadIndex){insert( FloatArr(1, val), pos);}void FloatArr::insert( const FloatArr& v, int pos )throw( BadIndex ){if( pos < 0 || pos > cnt)   // Append is also possible.throw BadIndex(pos);if( max < cnt + v.cnt)expand(cnt + v.cnt);int i;
for( i = cnt-1; i >= pos; --i)    // Shift up fromarrPtr[i+v.cnt] = arrPtr[i];   // position pos.for( i = 0; i < v.cnt; ++i)       // Fill the gap.arrPtr[i+pos] = v.arrPtr[i];cnt = cnt + v.cnt;}
630CHAPTER 28EXCEPTION HANDLING
// To deletevoid FloatArr::remove(int pos) throw(BadIndex)
{if( pos >= 0 && pos < cnt){for( int i = pos; i < cnt-1; ++i)arrPtr[i] = arrPtr[i+1];--cnt;}
elsethrow BadIndex(pos);}// -------------------------------------------------------//arr_h.cpp// Tests exception handling for float arrays.// -------------------------------------------------------#include <iostream>
#include <iomanip>using namespace std;#include "floatArr.h"int main(){const FloatArr v(10, 9.9f);bool ok = false;while( !ok){try{cout << "Here is the constant array v: \n";cout << setw(8) << v <<endl;int i;cout << "Index? "; cin >> i;cout << "\nThe value read: " <<  v[i] << endl;
ok = true;}catch(BadIndex& err)
{cerr << "Error in reading.\n"<< "\nInvalid index: "<< err.getBadIndex() << endl;}}
SOLUTIONS631FloatArr w(20);             // Array wtry
{w.insert(1.1F, 0);      // To write.w.insert(2.2F, 1);//      w.insert(3.3F, 3);      // Error!//      w[10] = 5.0;            // Error!//      w.remove(7);            // Error!}
catch(BadIndex& err)
{cerr << "\nError in writing! "<< "\nInvalid index: "<< err.getBadIndex() << endl;}cout << "\nHere is the array: \n";cout << setw(5) << w << endl;
return 0;}Exercise 2
// ------------------------------------------------------//fraction.h// A numeric class to represent fractions,
// exception handling is included.
// ------------------------------------------------------
#ifndef _FRACTION_#define _FRACTION_#include <iostream>
#include <cstdlib>using namespace std;class Fraction{private:long numerator, denominator;public:class DivisionByZero
{// No data members};
Fraction(long z = 0, long n = 1) throw(DivisionByZero);
Fraction operator-() const{return Fraction(-numerator, denominator);}
632CHAPTER 28EXCEPTION HANDLING
Fraction& operator+=(const Fraction& a){numerator = a.numerator * denominator+ numerator * a.denominator;denominator *= a.denominator;
return *this;}Fraction& operator-=(const Fraction& a){*this += (-a);
return *this;}Fraction& operator++(){numerator += denominator;return *this;}Fraction& operator--(){numerator -= denominator;
return *this;}friend Fraction operator+(const Fraction&,const Fraction&);friend Fraction operator-(const Fraction&,const Fraction&);friend Fraction operator*(const Fraction&,const Fraction&);friend Fraction operator/(const Fraction&,const Fraction&)throw(Fraction::DivisionByZero);friend ostream& operator<<(ostream&, const Fraction&);friend istream& operator>>(istream& is, Fraction& a)throw(Fraction::DivisionByZero);};#endif
SOLUTIONS633// -------------------------------------------------------//fraction.cpp// Defines methods and friend functions.
// -------------------------------------------------------
#include <iostream>
#include <cstdlib>
using namespace std;
#include "fraction.h"
// Constructor:
Fraction::Fraction(long z, long n)throw(Fraction::DivisionByZero){if(n == 0)  throw DivisionByZero();
if( n < 0)  z = -z, n = -n;
numerator = z;   denominator  = n;}Fraction operator+(const Fraction& a, const Fraction& b){Fraction temp;
temp.denominator = a.denominator * b.denominator;
temp.numerator = a.numerator*b.denominator+ b.numerator * a.denominator;return temp;}Fraction operator-(const Fraction& a, const Fraction& b ){Fraction temp = a;   temp += (-b);
return temp;}Fraction operator*(const Fraction& a, const Fraction& b ){Fraction temp;
temp.numerator = a.numerator * b.numerator;
temp.denominator  = a.denominator  * b.denominator;
return temp;}Fraction operator/(const Fraction& a, const Fraction& b )throw(Fraction::DivisionByZero){if( b.numerator == 0)  throw Fraction::DivisionByZero();
// Multiply a with the inverse of b:
Fraction temp;
temp.numerator = a.numerator * b.denominator;
temp.denominator  = a.denominator  * b.numerator;if( temp.denominator < 0 )temp.numerator = -temp.numerator,
temp.denominator  = -temp.denominator;return temp;}
634CHAPTER 28EXCEPTION HANDLING
ostream& operator<<(ostream& os, const Fraction& a){os << a.numerator << "/" << a.denominator;return os;}istream& operator>>(istream& is, Fraction& a)throw(Fraction::DivisionByZero){cout << "Enter a fraction:\n""  Numerator:      ";   is >> a.numerator;cout << "  Denominator != 0:  ";   is >> a.denominator;if( !is) return is;
if( a.denominator == 0){cout << "\nError: The denominator is 0\n"<< "New Denominator != 0: "; is >> a.denominator;}if( a.denominator == 0)throw Fraction::DivisionByZero();if( a.denominator < 0 )a.numerator = -a.numerator,a.denominator  = -a.denominator;return is;}// -------------------------------------------------------//fract_t.cpp: Testing the class Fraction.// Modules: fract_t.cpp  fraction.cpp
// -------------------------------------------------------#include <iostream.h>#include "fraction.h"int main(){try        // Tests the exception of the constructor:
{Fraction c(5,0);}
catch(Fraction::DivisionByZero& ){cout << "\nError on initializing: "<< "\nThe denominator is 0\n";}
SOLUTIONS635Fraction a(1,3), b(3);try{cout << "\nSome test output:\n\n";cout << " a = " << a << endl;cout << " b = " << b << endl;cout << " a + b = " << (a + b) << endl;cout << " a - b = " << (a - b) << endl;
cout << " a * b = " << (a * b) << endl;
b = 0;cout << " a / b = " << (a / b) << endl;   // Error!}
catch(Fraction::DivisionByZero& ){cout << "\nError on dividing: "<< "\nNo division by zero! 0\n";}cout << "  --a =  " <<  --a << endl;cout << "  ++a  = " <<  ++a << endl;a += Fraction(1,2);cout << " a+= 1/2;  a = " << a << endl;a -= Fraction(1,2);cout << " a-= 1/2;  a = " << a << endl;cout << "-b = " << -b << endl;cout << "\nAnd now your input: \n";try{cin  >> a;}catch(Fraction::DivisionByZero&)
{cerr << "\nError: The denominator is 0\n";exit(1);}cout << "\nYour input: " << a  << endl;return 0;}
This page intentionally left blank 
637More about Files
This chapter describes
random access to files based on file streams
options for querying file state
exception handling for files.
We will also illustrate how to make objects in polymorphic classes

persistent,that is,how to save them in files.The applications introduced in

this chapter include simple index files and hash tables.
chapter
29
638CHAPTER 29MORE ABOUT FILES
Open modeEffectsMust  the file
exist?To open the file for input and
output.Opens the file for input andoutput. If the file already exists,
it will be truncated.Opens the file for input andoutput. If the file does not exist,
it will be created.
Before each writing access, a
seek to end is performed.yesnonoios::in| ios::outios::in| ios::out
| ios::truncios::in| ios::out| ios::app1.If the flag 
ios::binaryis additionally set,the file will be opened in binary mode.
2.If the flag 
ios::ate(“at end”) is additionally set,the current seek position is set to
end-of-file immediately after opening.
NOTE
OPENING A FILE FOR RANDOM ACCESS
Combined open modes for read and write access

OPENING A FILE FOR RANDOM ACCESS639Random File Access
So far we have only looked at sequential file access. If you need access to specific infor-mation in such a file, you have to walk through the file from top to tail, and new records
are always appended at the end of the file.Random file access gives you the option of reading and writing information directly at apre-defined position. To be able to do this, you need to change the current file position
explicitly, that is, you need to point the get/putpointer to the next byte to be manipu-lated. After pointing the pointer, you can revert to using the read and write operations
that you are already familiar with.Open ModesOne prerequisite of random file access is that the position of the records in the file can beprecisely identified. This implies opening the file in binary mode to avoid having to
transfer additional escape characters to the file.Example:ios::openmode mode = ios::in | ios::out |ios::app | ios::binary;fstream fstr("account.fle", mode);This statement opens the file "Account.fle"in binary mode for reading and append-ing at end-of-file. The file will be created if it did not previously exist. Random read accessto the file is possible, but for write operations new records will be appended at the end of
the file.To enable random read and write access to a file, the file can be opened as follows:Example:ios::openmode mode = ios::in | ios::out |ios::binary;fstream fstr("account.fle", mode);However, this technique can only be used for existing files. If the file does not exist, youcan use the ios::truncflag to create it.The section “File State” discusses your error handling options if a file, such as"account.fle"cannot be found.
640CHAPTER 29MORE ABOUT FILES
Access pointPositioning  flagFile
Beginning of the fileios::begCurrent positionios::curEnd of fileios::end••••••
•POSITIONING FOR RANDOM ACCESS
The three access points in a file

POSITIONING FOR RANDOM ACCESS641Discovering and Changing the Current Position
The file stream classes comprise methods to discover and change the current position ina file. The tellp()andtellg()methods return the current position of the putorgetpointers as a longvalue.Example:long rpos = myfile.tellg();This statement queries the current position of the read pointer in the myfilestream.The current position is always returned as a byte offset relative to the beginning of the
file.The current file position can be modified using the seekp()orseekg()method.The position is stated as a byte offset, relative to either the beginning or end of the file,
or relative to the current position in the file.Positioning Flags
Threeios::seekdirtype positioning flags are defined in the iosclass for this pur-pose; these are ios::beg,ios::cur, and ios::end.Imagine you want to write the object accto the file "account.fle"at offset pos.You can use the following statements to do so:Example:ofstream fstr("account.fle", ios::out |ios::binary);fstr.seekp(pos, ios::begin);
acc.write( fstr );This calls the write()method in the Accountclass, which allows an object to writeits own data members to a file (see Chapter 18).If you do not specify a positioning flag, the position will be assumed to be relative tothe beginning of the file. The statement used to position the write pointer in the last
example can therefore be formulated as follows:Example:fstr.seekp(pos );The byte offset can also be negative for calls to the methods seekp()andseekg().However, you cannot position the read/write pointer before the beginning of the file.In contrast, it is possible to place the pointer at a position after the end of the file andthen perform a write operation, which will create a gap with unknown content in the
file. This only makes sense if all the empty slots in the file are of an equal length, as they
can be overwritten later. This option is often used when programming hash tables.
642CHAPTER 29MORE ABOUT FILES
// index.h:  Defines the class IndexEntry// ----------------------------------------------------
#ifndef _INDEX_H
#define _INDEX_H
#include <fstream>#include <iostream>using namespace std;class IndexEntry{private:long key;                 // Key
long recNr;               // Offsetpublic:IndexEntry(long k=0L, long n=0L) { key=k; recNr=n;}
// Access methods ... and:int recordSize() const{ return sizeof(key) + sizeof(recNr); }fstream& write( fstream& ind) const;
fstream& read(  fstream& ind);fstream& write_at(fstream& ind, long pos) const;fstream& read_at( fstream& ind, long pos);};
#endif// index.cpp:  Implements the methods// ---------------------------------------------------#include "index.h"// . . .
fstream& IndexEntry::write_at( fstream& ind, long pos)const{ind.seekp(pos);ind.write((char*)&key, sizeof(key) );
ind.write((char*)&recNr, sizeof(recNr) );return ind;}fstream& IndexEntry::read_at(fstream& ind, long pos){ind.seekg(pos);ind.read((char*)&key, sizeof(key) );ind.read((char*)&recNr, sizeof(recNr));
return ind;}POSITIONING FOR RANDOM ACCESS (CONTINUED)
Representing an index entry
Theread_at()andwrite_at()methods
POSITIONING FOR RANDOM ACCESS (CONTINUED)643Using Positioning Methods
The following statements are commonly used for random positioningseekg( 0L);andseekp( 0L, ios::end );They set the current position to the beginning or end of a file. You should be aware thatthe first argument is 0Lto indicate that longtype is required.If you need to determine the length of a file, you can point the getpointer to the endof the file and then query the position of the pointer:Example:fstr.seekg(0L, ios::end);unsigned long count = fstr.tellg();Thecountvariable will then contain the number of bytes occupied by the file.These positioning methods are useful for files opened in binary mode. However, itdoes not make much sense to use them for text files or particularly for devices. In text
mode, conversions of LF <=> CR/LF prevent the methods from working correctly.Determining Positions in a File
The position of records in a files is easy to compute if all the records in the file are thesame length. Given that sizeis the length of a record0L,  size,  2*size, ...are the positions of the first, second, third records, and so on.If you are working with variable length records, you cannot exactly compute theirpositions. To enable random access you therefore need to store the positions of the
records in a separate structure, a so-called index.The index stores pairs of keys and record positions, so-called index entriesin a file. Akey, a social security number, or customer id, for example, must uniquely identify a
record. If the index is sorted, the position that correlates to the required key can be
quickly found using the binary search algorithm.TheIndexEntryClassTheIndexEntryclass, used to represent an index entry, is shown opposite. The classcomprises methods for reading and writing an index entry at the current file position or
at any given position. The appropriate file stream is passed as an argument to the
method.
644CHAPTER 29MORE ABOUT FILES
// index.h: (continued)// Adds the definition of an index
// --------------------------------------------------
#include <string>class IndexFile{private:fstream index;
string  name;              // Filename of indexpublic:IndexFile(const string& s);~IndexFile() { index.close(); }void insert( long key, long pos);long search( long key);void retrieve(IndexEntry& entry, long pos );};// index.cpp: (continued)// Adds methods of class IndexFile// ---------------------------------------------------IndexFile::IndexFile(const string& file)
{ios::openmode mode =  ios::in | ios::out| ios::binary;index.open(file.c_str(), mode);if(!index)            // If the file does not exist{index.clear();
mode |= ios::trunc;index.open(file.c_str(), mode);if(!index)return;}elsename = file;}//. . .FILE STATE
Representing an index
Constructor of class 
IndexFile
FILE STATE645State Flags
A file stream can assume various states, for example, when it reaches the end of a file andcannot continue reading. A file operation can also fail if a file cannot be opened, or if a
block is not transferred correctly.Theiosclass uses state flags to define the various states a file can assume. Each stateflag corresponds to a single bit in a status-word, which is represented by the iostatetype in the iosclass. The following state flags exist:ios::eofbitend of file reachedios::failbitlast read or write operation failedios::badbitan irrecoverable error occurredios::goodbitthe stream is ok, e.g. no other state flag is set.The “flag” ios::goodbitis an exception to the rule since it is not represented by asingle bit, but by the value 0 if no other flag has been set. In other words a status-word
has the value ios::goodbitif everything is fine!Discovering and Changing the State
There are multiple methods for discovering and modifying the status of a stream. Amethod exists for each state flag; these are eof(),fail(),bad(), and good(). Theyreturntruewhen the corresponding flag has been raised. This means you can discoverthe end of a file with the following statement:Example:if( fstr.eof() ) ...The status-word of a stream can be read using the rdstate()method. Individual flagscan then be queried by a simple comparison:Example:if( myfile.rdstate() == ios::badbit ). . .Theclear()method is available for clearing the status-word. If you call clear()without any arguments, all the state flags are cleared. An argument of the iostatetypepassed to clear()automatically becomes the new status-word for the stream.TheIndexFileClassTheIndexFileclass, which uses a file to represent an index, is defined opposite. Theconstructor for this class uses the clear()method to reset the failbit after an invalidattempt to open a non-existent file. A new file can then be created.TheIndexFileclass comprises methods for inserting, seeking, and retrieving indexentries, which we will be implementing later in this chapter.
646CHAPTER 29MORE ABOUT FILES
// exceptio.h : Exception classes for file access// -------------------------------------------------
#ifndef _EXCEPTIO_H
#define _EXCEPTIO_H#include <string>#include <iostream>using namespace std;class FileError{private:string filename;public:FileError( const string& file) : filename(file){ }
string getName() const{ return filename; }};class OpenError : public FileError{public:OpenError( const string& file):FileError(file){ }};class ReadError : public FileError{public:ReadError( const string& file):FileError(file){ }};class WriteError : public FileError{public:WriteError(const string& file):FileError(file){ }};
#endifEXCEPTION HANDLING FOR FILESDefining your own exception classes

EXCEPTION HANDLING FOR FILES647Implementing Your Own Exception Handling
You can exploit the error tracking options that state flags give you to implement yourown exception handling for files. For example, a method that reads records from a file
can throw an exception when the state flag ios::eofis raised, that is, when the end ofthe file is reached.The opposite page shows typical exception classes organized in a hierarchy that can beused to represent error conditions on opening, reading from, and writing to a file. In each
case the file name is saved for evaluation by the exception handler.Standard Exception Handling for Streams
C++ also provides standard exception handling for streams. You can use the excep-tions()method to specify the flags in the status-word of a stream that will causeexceptions to be thrown.Theexceptions()method is defined in the iosstream base class. The methodexpects one or multiple state flags separated by the |sign. An exception is then thrownfor the flags specified.Example:ifstream ifstrm("account.fle");fstrm.exceptions(ios::failbit | ios::badbit);On accessing the fstrmstream an exception is thrown if either one of the flagsios::failbitorios::badbitis raised. The operation that caused the error is thenterminated and the state flags are cleared by a call to clear(rdstate());.The exception thrown here is of a standard exception class, failure. This type isdefined as a publicelement in the iosbase class and comprises the virtual methodwhat()that returns a C string containing the cause of the error. The exception handlerwill normally send the string to standard error output.You can call exceptions()without any arguments to discover the state flags in astatus-word of a stream that can cause an exception to be thrown. If a bit is set in the
return value of the exceptions()method, an appropriate exception will be thrownwhenever this error occurs.Example:iostate except = fstrm.exceptions();if( except & ios::eofbit) ...This statement uses a bitwise AND operator to ascertain whether an exception is thrownwhen end-of-file is reached.
648CHAPTER 29MORE ABOUT FILES
// account.h :  Defines the classes//              Account, DepAcc, and SavAcc
//              with virtual read and write methods.
// --------------------------------------------------
// . . .enum TypeId { ACCOUNT, DEP_ACC, SAV_ACC };class Account{private:// Data members: as previously defined.

public: // Constructor, access methods ... 
virtual TypeId getTypeId() const { return ACCOUNT;}virtual ostream& write(ostream& fs) const;
virtual istream& read(istream& fs);};
class DepAcc : public Account{     // Data members, constructor, . . .TypeId getTypeId() const { return DEP_ACC; }ostream& write(ostream& fs) const;istream& read(istream& fs);};
class SavAcc: public Account{// Data members, constructor, . . .
TypeId getTypeId() const { return SAV_ACC; }
ostream& write(ostream& fs) const;istream& read(istream& fs);};// account.cpp:  Implements the methods.// ----------------------------------------------------#include "account.h"ostream& DepAcc::write(ostream& os) const
{if(!Account::write(os))return os;os.write((char*)&limit, sizeof(limit) );os.write((char*)&deb, sizeof(deb) );
return os;}istream& DepAcc::read(istream& is)
{if(!Account::read(is))return is;is.read((char*)&limit, sizeof(limit) );is.read((char*)&deb, sizeof(deb));
return is;}
// . . .PERSISTENCE OF POLYMORPHIC OBJECTS
The methods read()andwrite()of class DepAcc
PERSISTENCE OF POLYMORPHIC OBJECTS649Storing Polymorphic Objects
Imagine you want to make the objects of a polymorphic class hierarchy persistent, that is,store them in a file. You need to ensure that an object can be reconstructed precisely
when it is read. This gives rise to the fact that objects in polymorphic class hierarchies
contain virtual methods. So it is not simply a case of making the data members of an
object into records and writing them to afile.
1.You must write both the type and the data members of the object to a file. 
2.If the objects contain dynamic members, you must save the referenced objects themselves along with
information on the object type.NOTE
To allow the class to assume control over object storage, you need methods that allowthe object to write its own data members to a file. The methods can have a virtual defini-
tion within the class hierarchy. Thus, if pointers are used to reference objects, the appro-
priate read/write operation for each object will be called.Storing Objects of the AccountHierarchy
The opposite page shows the Accountclass, with which you should already be familiar.Virtual file I/O methods have now been added. The implementation of the read()andwrite()methods was discussed earlier in Chapter 18, “Fundamentals of File Input andOutput,” and is unchanged.The derived classes DepAccandSavAccalso contain definitions of the read()andwrite()methods that read only their “own” objects and write them to files. The imple-mentation first calls the appropriate base class method. If no errors occur, it is simply a
question of transferring the additional data members of the derived class to or from a file.At present, no type information will be written to file or read from file. This task willbe performed by a special class whose features are used for file management. The follow-
ing section contains more details on this topic.
650CHAPTER 29MORE ABOUT FILES
// account.h : (continued)// Add definition of AccFile class// --------------------------------------------------// . . .
#include "exceptio.h"class AccFile{private:fstream f;             // Stream
string  name;          // Filenamepublic:AccFile(const string& s)  throw(OpenError);
~AccFile(){ f.close(); }long     append( Account& acc) throw(WriteError);Account* retrieve( long pos )  throw(ReadError);};// account.cpp: (continued)// Implements methods of class AccFile.// ---------------------------------------------------long AccFile::append( Account& acc) throw( WriteError)
{f.seekp(0L, ios::end);   // Seek to end,long pos = f.tellp();    // save the position.if( !f )throw WriteError(name);TypeId id = acc.getTypeId();  // To write the TypeIdf.write( (char*)&id, sizeof(id));if(!f)throw WriteError(name);elseacc.write(f);             // To write an object// to the file.if(!f)throw WriteError(name);elsereturn pos;}// . . .PERSISTENCE OF POLYMORPHIC OBJECTS (CONTINUED)
Theappend()method
PERSISTENCE OF POLYMORPHIC OBJECTS (CONTINUED)651A ScenarioImagine you want to save the data for various account types, including current and sav-ings accounts to a file. Since the objects you need to save belong to different types, you
must save both the data members and the type of object. This is the only way to ensure
that an object will be correctly reconstructed when read.The methods in the class you are going to define should throw exceptions if errorsoccur. The exception type thrown by a method is stated in the exception specification.TheAccFileClassTheAccFileclass, which is used for random access to a file with account data, isdefined opposited. The data members are an fstreamtype file stream and a string usedfor storing the file name.The constructor saves the file name and opens a given file for reading and appendingat end-of-file. If the file cannot be opened, the constructor throws an OpenErrorclassexception.Theappend()method writes an account passed to it as an argument at end-of-fileand returns the position where the account was written into the file.In order to get the current type of the argument, the virtual method getTypeid()iscalled. Depending on this type the append()method will write the appropriate typefield to the file and then call the virtual method write(), allowing the current objectto write itself to the file. If a write error occurs, the method will throw a WriteErrortype exception.Theretrieve()method first reads the type identifier and then determines the typeof object it needs to allocate memory for. The data from the file is then transferred to the
dynamically allocated object by a call to the virtual method read(). Here too, anexception will be thrown if a stream access error occurs.
652CHAPTER 29MORE ABOUT FILES
// index.cpp: (continued)// Implements the methods of class IndexFile.// ----------------------------------------------------
// . . .void IndexFile::insert(long k, long n)throw(ReadError, WriteError){IndexEntry entry;int size = entry.recordSize();    // Length of an// index entry.index.clear();index.seekg(0, ios::end);
long nr = index.tellg();     // Get file length// 0, if file is empty.if(!index) throw ReadError(name);nr -= size;                    // Last entry.bool found = false;while( nr >= 0 && !found )     // Search for position{                              // to insertif( !entry.read_at(index, nr))throw ReadError(name);if( k < entry.getKey())          // To shift.{entry.write_at(index, nr + size);
nr -= size;}else{found = true;}}entry.setKey(k); entry.setPos(n);  // insertentry.write_at(index, nr + size);if(!index)throw WriteError(name);}APPLICATION:INDEX FILES
Theinsert()method of class IndexFile
APPLICATION: INDEX FILES653IndexPrimary file
12345 |It makes sense to organize data sequentially in files if you need to walk through all therecords regularly. This is particularly true for files used to store salary data or phone bills.However, most applications need to provide quick access to specific data. For exam-ple, a user would definitely prefer to be able to locate an account quickly by reference to
an account number, rather than searching through a file from top to bottom. Index files
can mean a real performance boost in cases like this.Index Files
Anindex file comprises a so-called primary filecontaining the live data, and an index. Theindexconsists of pairs of keys and record positions for the primary file. A key stored in theindex will identify a record in the primary file. This situation can be more easily
explained by the following graphic:The index is sorted by reference to the keys for speed of access, allowing you to perform abinary search to locate the position of a record.Inserting into the Index
We can use the IndexFileclass definition to represent an index. The insert()method, which correctly inserts a new record into the sorted index, is defined opposite.The read pointer is first set to end-of-file for insertions. If the current position is 0,that is, the file is empty, the entry is inserted at offset 0. In all other cases, any entrieswhose keys are greater than the new key are shifted down to make room for the new
entry.
654CHAPTER 29MORE ABOUT FILES
// index.h:   Defines the class IndexFile// ---------------------------------------------------
class IndexFileSystem : public AccFile, public IndexFile
{private:string name;public:IndexFileSystem(const string s): AccFile(s + ".prim"), IndexFile(s + ".ind")
{ name = s;  }void   insert  ( Account& acc );Account* retrieve( long key );};// index.cpp:   Implementing the methods.// ---------------------------------------------------void IndexFileSystem::insert(Account& acc){                            // No multiple entries:if(search(acc.getNr()) == -1){long pos = append(acc); // Insert in primary fileif(pos != -1)                            // Insert inIndexFile::insert(acc.getNr(), pos);   // index file.}}Account* IndexFileSystem::retrieve(long key ){  long pos = search(key);    // Get the record address:if( pos == -1 )            // Account number found?return NULL;else{  IndexEntry entry;      // Read the index entry:IndexFile::retrieve(entry, pos);// Read from primary file:return( AccFile::retrieve( entry.getPos() ));}}IMPLEMENTING AN INDEX FILE
Representing the index file
Methodsinsert()andretrieve()of class IndexFileSystem
IMPLEMENTING AN INDEX FILE655Index File for Account Management
Since an index file consists of a primary file and an index, it makes sense to derive theclass used to represent an index file from the classes of the primary file and the index file.
Let’s now look at a sample index file, used for managing bank accounts.TheIndexFileSystemclass, which is derived from the two previously definedclassesAccFileandIndexFile, is defined on the opposite page. The only data mem-ber is a string for the file name. The constructor expects a file name as an argument and
composes names for the primary file and the index by adding a suitable suffix. Base ini-
tializers are then used to open the corresponding files.It is not necessary to define a destructor, since files are automatically closed when thebase class destructors are called.Inserting and Retrieving Records
Theinsert()method was defined to insert new records. It first calls the search()method to check whether the account number already exists in the index. If not, a newrecord is appended to the end of the primary file using the append()method. Then thekey and the address of the record are inserted into the index.TheIndexFileSystemclass also contains the retrieve()method, which is usedto retrieve records from the primary file. The key, key, which is passed to the method, isused by the search()method to look up the address of the required record in theindex. Then the record is retrieved from the primary file by the AccFileclassretrieve()method.Only the retrieve()methods for the IndexFileandAccFileclasses and thesearch()method, which performs a binary search in the index, are needed to com-plete the index file implementation. It’s your job to implement these three methods as
your next exercise!Using a sorted file to implement an index has the disadvantage that records need tobe shifted to make room to insert new records. As shifting is time-consuming, an index is
normally represented by a tree, which needs less reorganization.
exercises
656CHAPTER 29MORE ABOUT FILES
class IndexFile{private:fstream index;
string  name;              // Filename of the indexpublic:IndexFile(const string s)throw(OpenError);~IndexFile( ){ index.close(); }
void insert( long key, long pos)throw(ReadError, WriteError);long search( long key) throw(ReadError);
void retrieve(IndexEntry& entry, long pos )throw( ReadError);};enum TypeId { ACCOUNT, DEPOSIT, SAVINGS };class AccFile{private:fstream f;string  name;          // Filename of primary filepublic:AccFile(const string s) throw(OpenError);~AccFile(){ f.close(); }
long   append( Account& acc)  throw(WriteError);Account* retrieve( long pos ) throw(ReadError);};EXERCISESExercise 1
ClassIndexFileClassAccFile
EXERCISES657Exercise 1
Complete and test the implementation of the IndexFileSystemclass.The
methods should throw exceptions of an appropriate 
FileErrortype if an error
occurs.a.Complete the constructor of the 
IndexFileclass in order to throw an
exception of the type OpenErrorif the file can not be opened.b.Write the 
retrieve()method for the 
IndexFileclass.The method
retrieves a record at a given position in the index.
c.Define the 
search()method,which looks up an index entry for an
account number passed to it as an argument.Base the method on the

binary search algorithm.
Return value:
The position of the record found,or -1 if the account
number is not found in the index.
d.Then define the 
retrieve()method for the 
AccFileclass,which first
evaluates the type field at a given position in the account file,then

dynamically allocates memory for an object of the appropriate type,and

finally reads the data for an account from the file.
e.Write a 
main()function that uses a tryblock to create an 
Index-FileSystemtype object and to insert several accounts of various types
into the index file.The subsequent user dialog reads a key and displays

the corresponding record on screen.Write an exception handler to han-

dle the various errors that could occur.The name of the file and the

cause of the error must be output in any case of error.

658CHAPTER 29MORE ABOUT FILES
Hash fileHash functionKey4713123434Hash FilesHash Files profit from random file access in localizing file records directly.Each
file record must have the same length and it must be identified by a unique key,

the so-called hash key
.The idea behind hashing is to provide a function,the 
hash function,which is
applied to the hash key of a record and yields the address of the file record.If

the file records are numerated and if the hash key equals the record number,a

simple hash function can be the identical function.However,hash keys,such as

account or insurance numbers,consist of a fixed number of digits that do not

start with 0.
The following example shows a frequently used hash function
Example:Hash(key) = key % b;This hash function transforms the hash value 
keyinto a record number between
0andb-1.The number 
0is the first record number and 
b-1is the last record
number in the 
address space
of the hash file.For a sufficiently large prime
number 
b,the function 
Hash()yields a good distribution of file records in the
address space.
However,the hash function maps the hash key values 
key,key + b,key + 2*b,etc.to the same record number.In this case 
collisionsmay occur,for example,
when a new record being inserted hashes to an address that already contains a

different record.
To solve this conflict,the new record must be inserted at some other
position.The process of finding another position at which to insert the new

record is called 
collision resolution
.Linear solutionis a common collision resolution technique:Starting at the
occupied position,subsequent positions are checked sequentially until an

available position is found.The new file record is then inserted at this position.

EXERCISES659Exercise 2
A hash file is required for speed of access to customer data.The concept of hash
files is explained on the opposite page.To keep things simple,each record in the

hash file contains only a customer id and a name.The customer id is the key

used by the hash function opposite to compute the address of the record.Use

linear solution as collision resolution technique.
Note:Linear solution provides for adequate access times if the address space is
sufficiently large and not too full.It is also important to distribute the record

numbers yielded by the hash function evenly throughout the available address

space.The hash function opposite will guarantee a good distribution if 
bis asufficiently large prime number.
Develop the 
HashEntryclass used to represent customer data.You need
to store the customer id as an 
unsigned longvalue and the name ofthe customer as a chararray with a length of 30.Supply default values for
the constructor declaration and additionally declare the 
read_at()andwrite_at()methods that read customer information at a given position
in a stream or write information at that position.Both methods expect

the position and the stream as arguments.
Define the HashFileclass to represent a hash file.The 
privatemem-bers of the class comprise an fstreamtype file stream,a string used to
store the file name,an 
intvariable used to store the number 
b,and the
hash function shown opposite as a method.The 
publicmembers com-prise a constructor that expects a file name and a number 
bas argu-ments.It opens the corresponding file for read and write access.The

destructor closes the file.
Additionally declare the methods 
insert()andretrieve()to insert or
retrieve single records.Both methods use a call to the hash function to

compute the appropriate record number in the hash file.If a collision

occurs,the methods perform a sequential search to locate the next free

slot in the address space (mod of address space size),or the desired cus-

tomer data.Test the 
HashFileby writing a 
mainfunction that creates hash file with a
small address space (e.g.b = 7).Add various customer information

records to the hash file and then retrieve this data.Deliberately provoke

collisions using the customer ids 5,12,and 19,for example.

solutions
660CHAPTER 29MORE ABOUT FILES
SOLUTIONSExercise 1
// ------------------------------------------------------//exceptio.h: Error classes for file processing// ------------------------------------------------------// Unchanged (cf. earlier in this chapter).// ------------------------------------------------------// account.h :
// Defines the classes//       Account, DepAcc, and SavAcc// with virtual read and write methods as well as
// the class AccFile to represent account files.// ------------------------------------------------------#ifndef _ACCOUNT_H
#define _ACCOUNT_H#include <fstream>#include <iostream>
#include <iomanip>#include <string>using namespace std;#include "exceptio.h"enum TypeId{ ACCOUNT, DEP_ACC, SAV_ACC };class Account{private:                       // Data elements:string name;unsigned long nr;
double balance;public:                        // Constructor:Account( const string c_name  = "X",unsigned long c_nr   = 1111111L,double c_balance     = 0.0): name(c_name), nr(c_nr), balance(c_balance)
{ }virtual ~Account() {}        // Virtual destructor
SOLUTIONS661// Access methods here:long getNr() const { return nr; }
void setNr(unsigned long n){ nr = n; }// . . .// The other methods:virtual TypeId getTypeId() const { return ACCOUNT; }virtual ostream& write(ostream& fs) const;virtual istream& read(istream& fs);virtual void display() const{cout << fixed << setprecision(2)<< "----------------------------------\n"
<< "Account holder:       " << name    << endl<< "Account number:       " << nr      << endl<< "Balance of account:   " << balance << endl
<< "----------------------------------\n"
<< endl;}};class DepAcc : public Account{private:double limit;           // Overdrawn limitdouble interest;        // Interest ratepublic:DepAcc( const string s  = "X",unsigned long n = 1111111L,
double bal = 0.0,double li  = 0.0,double ir  = 0.0): Account(s, n, bal), limit(li), interest(ir){ }// Access methods:// . . .// The other methods are implicit virtual:TypeId getTypeId() const { return DEP_ACC; }ostream& write(ostream& fs) const;istream& read(istream& fs);
662CHAPTER 29MORE ABOUT FILES
void display() const{Account::display();cout << "Overdrawn limit:      " << limit << endl<< "Competitive interest: " << interest
<< "\n----------------------------------\n"
<< endl;}};class SavAcc: public Account{private:double interest;            // Compound interestpublic:// Methods as in class DepAcc.};// --------------------------------------------------// The definition of class AccFileclass AccFile{private:fstream f;string  name;          // Filenamepublic:AccFile(const string& s) throw(OpenError);~AccFile(){ f.close(); }long append( Account& acc)   throw(WriteError);Account* retrieve( long pos) throw(ReadError);void display() throw( ReadError);};#endif
SOLUTIONS663// ----------------------------------------------------//account.cpp// Implement methods of the classes// Account, DepAcc, SavAcc, and AccFile.// ----------------------------------------------------
#include "account.h"
#include <typeinfo>ostream& Account::write(ostream& os) const{os << name << '\0';
os.write((char*)&nr, sizeof(nr) );
os.write((char*)&balance, sizeof(balance) );return os;}istream& Account::read(istream& is){getline( is, name, '\0');is.read((char*)&nr, sizeof(nr) );is.read((char*) &balance, sizeof(balance));
return is;}ostream& DepAcc::write(ostream& os) const{if(!Account::write(os))return os;os.write((char*)&limit, sizeof(limit) );os.write((char*)&interest, sizeof(interest) );return os;}istream& DepAcc::read(istream& is){if(!Account::read(is))return is;is.read((char*)&limit, sizeof(limit) );
is.read((char*)&interest, sizeof(interest));return is;}// ostream& SavAcc::write(ostream& os) const// istream& SavAcc::read(istream& is)// as in class DepAcc.
664CHAPTER 29MORE ABOUT FILES
// ---- Methods of class AccFile ----AccFile::AccFile(const string& s) throw( OpenError)
{ios::openmode mode = ios::in | ios::out | ios::app| ios::binary;f.open( s.c_str(), mode);if(!f)throw OpenError(s);elsename = s;}void AccFile::display() throw(ReadError){Account acc, *pAcc = NULL;
DepAcc depAcc;SavAcc savAcc;TypeId id;if( !f.seekg(0L))throw ReadError(name);cout << "\nThe account file: " << endl;while( f.read((char*)&id, sizeof(TypeId)) ){switch(id){case ACCOUNT:  pAcc = &acc;break;case DEP_ACC:  pAcc = &depAcc;break;case SAV_ACC:  pAcc = &savAcc;break;default: cerr << "Invalid flag in account file"<< endl;exit(1);}if(!pAcc->read(f))break;pAcc->display();cin.get();             // Go on with return}
SOLUTIONS665if( !f.eof())throw ReadError(name);f.clear();}long AccFile::append( Account& acc) throw( WriteError){f.seekp(0L, ios::end);   // Seek to end,
long pos = f.tellp();    // save the position.if( !f )throw WriteError(name);TypeId id = acc.getTypeId();f.write( (char*)&id, sizeof(id));  // Write the TypeIdif(!f)throw WriteError(name);elseacc.write(f);        // Add an object to the file.if(!f)throw WriteError(name);elsereturn pos;}Account* AccFile::retrieve( long pos) throw(ReadError){f.clear();f.seekg(pos);                  // Set the get pointerif( !f )throw ReadError(name);TypeId id;f.read( (char*)&id, sizeof(id) );     // Get TypeIdif(!f)throw ReadError(name);Account* buf;switch( id )
{case ACCOUNT:  buf = new Account;break;case SAV_ACC:  buf = new SavAcc;break;
666CHAPTER 29MORE ABOUT FILES
case DEP_ACC:  buf = new DepAcc;break;}if( !(buf->read(f)))                  // Get datathrow ReadError(name);return buf;}// -------------------------------------------------------//index.h:Contains definitions of classes//          IndexEntry representing an  index entry,
//          Index      representing the index and
//          IndexFile  representing an  index file.
// -------------------------------------------------------#ifndef _INDEX_H#define _INDEX_H#include <fstream>#include <iostream>
#include <string>
#include "account.h"
using namespace std;class IndexEntry{private:long key;                 // Keylong recPos;              // Offsetpublic:IndexEntry(long k=0L, long n=0L){ key=k; recPos=n; }void setKey(long k) { key = k; }long getKey() const { return key; }void setPos(long p) { recPos = p; }long getPos() const { return recPos; }int recordSize() const{ return sizeof(key) + sizeof(recPos); }fstream& write( fstream& ind) const;fstream& read(  fstream& ind);fstream& write_at(fstream& ind, long pos) const;fstream& read_at( fstream& ind, long pos);
SOLUTIONS667void display() const{   cout << "Account Nr: " << key<< "  Position: " << recPos << endl;}};class IndexFile{private:fstream index;string  name;              // Filename of indexpublic:IndexFile( const string& s)  throw (OpenError);~IndexFile() { index.close(); }void insert( long key, long pos)throw(ReadError, WriteError);long search( long key) throw(ReadError);
void retrieve(IndexEntry& entry, long pos )throw(ReadError);void display() throw(ReadError);};class IndexFileSystem : public AccFile, public IndexFile{private:string name;               // Filename without suffixpublic:IndexFileSystem(const string& s): AccFile(s + ".prim"), IndexFile(s + ".ind"){ name = s;  }bool     insert( Account& acc);Account* retrieve( long key);};#endif
668CHAPTER 29MORE ABOUT FILES
// ------------------------------------------------------//index.cpp: Methods of the classes//             IndexEntry, Index, and IndexFile
// ------------------------------------------------------
#include "index.h"fstream& IndexEntry::write_at(fstream& ind, long pos) const{ind.seekp(pos);
ind.write((char*)&key, sizeof(key) );
ind.write((char*)&recPos, sizeof(recPos) );
return ind;}fstream& IndexEntry::read_at(fstream& ind, long pos){ind.seekg(pos);
ind.read((char*)&key, sizeof(key) );
ind.read((char*)&recPos, sizeof(recPos));
return ind;}fstream& IndexEntry::write(fstream& ind) const{ind.write((char*)&key, sizeof(key) );ind.write((char*)&recPos, sizeof(recPos) );
return ind;}fstream& IndexEntry::read(fstream& ind){ind.read((char*)&key, sizeof(key) );
ind.read((char*)&recPos, sizeof(recPos));
return ind;}// ---------------------------------------------------// Methods of class IndexFileIndexFile::IndexFile(const string& file) throw (OpenError)
{ios::openmode mode =  ios::in | ios::out | ios::binary;// Open file if it already exists:index.open( file.c_str(), mode);
if(!index)           // If the file doesn't exist
{   index.clear();mode |= ios::trunc;
index.open( file.c_str(), mode);
if(!index)throw OpenError(name);}
name = file;}
SOLUTIONS669void IndexFile::display() throw(ReadError){IndexEntry entry;index.seekg(0L);if(!index)throw ReadError("IndexFile: Setting the get pointer");cout << endl << "The Index: " << endl;while( true)
{if( !entry.read(index))break;entry.display();}
if( !index.eof())throw ReadError(name);index.clear();}long IndexFile::search(long k) throw(ReadError){IndexEntry entry;long key;
long  mid, begin = 0, end;   // Number of file records.
int size = entry.recordSize();   // Length of an index// entry.index.clear();
index.seekg(0L, ios::end);
end = index.tellg() / size;if(!index)throw ReadError(name);if( end == 0)return -1;end -= 1;                // Position of the last entrywhile( begin < end ){mid = (begin + end +1)/2 ;entry.read_at(index, mid*size);if(!index)throw ReadError(name);key = entry.getKey();if( k < key)end = mid - 1;elsebegin = mid;}
670CHAPTER 29MORE ABOUT FILES
entry.read_at(index, begin * size);if(!index)throw ReadError(name);if( k == entry.getKey() )      // Key found?return begin * size;else return -1;}void IndexFile::insert(long k, long n)throw(ReadError, WriteError){IndexEntry entry;int size = entry.recordSize();  // Length of an index// entry.index.clear();index.seekg(0, ios::end);long nr = index.tellg();        // Get file length// 0, if file is empty.if(!index) throw ReadError(name);nr -= size;                        // Last entry.bool found = false;
while( nr >= 0 && !found )         // Search position
{                                  // to insertif(!entry.read_at(index, nr))throw ReadError(name);if( k < entry.getKey())          // To shift.{entry.write_at(index, nr + size);
nr -= size;}else{found = true;}}entry.setKey(k); entry.setPos(n);  // Insertentry.write_at(index, nr + size);if(!index)throw WriteError(name);}
SOLUTIONS671void IndexFile::retrieve( IndexEntry& entry, long pos)throw(ReadError){index.clear();
if(!entry.read_at(index, pos))throw ReadError(name);}// ---------------------------------------------------//  Implementing the methods of class IndexFileSystem.bool IndexFileSystem::insert( Account& acc)throw(ReadError, WriteError){if(search(acc.getNr()) == -1)  // No multiple entries.{long pos = append(acc);      // Add to primary file.
IndexFile::insert(acc.getNr(), pos); // Add to Indexreturn true;}
elsereturn false;}Account* IndexFileSystem::retrieve(long key ){// Get the record address from the index:long pos = search(key);     // Byte offset of// index entry.if( pos == -1 )        // Account number doesn't exist.return NULL;else                   // Account number does exist:
{IndexEntry entry;        // To read the index eintryIndexFile::retrieve( entry, pos);// Get from primary file:return( AccFile::retrieve( entry.getPos() ));}}// ------------------------------------------------------//index_t.cpp: Testing the index file// ------------------------------------------------------
#include <iostream>
#include <string>using namespace std;#include "index.h"
#include "account.h"
672CHAPTER 29MORE ABOUT FILES
int main(){try{IndexFileSystem database("AccountTest");Account acc1( "Vivi", 490UL, 12340.57);database.insert( acc1 );SavAcc acc2( "Ulla", 590UL, 4321.19, 2.5);database.insert( acc2 );DepAcc acc3( "Jeany", 390UL, 12340.20, 10000.0, 12.9);database.insert( acc3 );database.IndexFile::display();cin.get();database.AccFile::display();
unsigned long key;cout << "Key? ";  cin >> key;
if(database.search(key) != -1)cout << "Key " << key << " found" << endl;elsecout << "Key " << key << " not found" << endl;Account* pAcc = database.retrieve(key);if( pAcc  != NULL )
{pAcc->display();delete pAcc;
pAcc = NULL;}else cout << "Retrieving failed" << endl;}
catch(OpenError& err){cerr << "Error on opening the file:" << err.getName()<< endl;exit(1);}
catch(WriteError& err){cerr << "Error on writing into the file: "<< err.getName() << endl;exit(1);}
SOLUTIONS673catch(ReadError& err){cerr << "Error on reading from the file: "<< err.getName() << endl;exit(1);}catch(...){cerr << " Unhandled Exception" << endl;
exit(1);}return 0;}Exercise 2
// -------------------------------------------------------
//exceptio.h: Error classes for file processing// -------------------------------------------------------// As seen previously in this chapter.// -------------------------------------------------------//hashFile.h// Defines the classes
//HashEntryrepresenting a record in a hash file and//HashFilerepresenting a hash file.// -------------------------------------------------------#ifndef _HASH_H_#define _HASH_H_#include <fstream>#include <iostream>#include <iomanip>
#include <string>#include <string.h>using namespace std;#include "exceptio.h"class HashEntry{private:unsigned long nr;
char name[30];
674CHAPTER 29MORE ABOUT FILES
public:HashEntry(unsigned long n = 0L, const string& s = "")
{nr = n;strncpy(name, s.c_str(), 29); name[30]='\0';}long   getNr() const { return nr; }void   setNr(unsigned long n){ nr = n; }string getName() const { return name; }void   setName(const string& s)
{  strncpy(name, s.c_str(), 29); name[30]='\0'; }int getSize() const{ return(sizeof(long) + sizeof(name)); }fstream& write(fstream& fs);fstream& read(fstream& fs);fstream& write_at(fstream& fs, unsigned long pos);fstream& read_at(fstream& fs, unsigned long pos);virtual void display(){cout << fixed << setprecision(2)<< "----------------------------------\n"<< "Client number:        " << nr    << endl<< "Client:               " << name  << endl
<< "----------------------------------\n"
<< endl;cin.get();}};class HashFile{private:fstream f;string  name;          // Filename
unsigned long b;       // Size of address spaceprotected:unsigned long hash_func(unsigned long key)
{ return key%b; }public:HashFile(const string s, unsigned long n )throw(OpenError);
SOLUTIONS675void insert( HashEntry& rec)throw( ReadError, WriteError );HashEntry& retrieve( unsigned long key )throw( ReadError );void display();};#endif// -------------------------------------------------------//hashFile.cpp: Methods of classes HashEntry and HashFile// -------------------------------------------------------
#include "hashFile.h"fstream& HashEntry::write(fstream& f){f.write((char*)&nr, sizeof(nr) );
f.write( name, sizeof(name) );return f;}fstream& HashEntry::read(fstream& f){f.read((char*)&nr, sizeof(nr) );
f.read( name, sizeof(name));return f;}fstream& HashEntry::write_at(fstream& f, unsigned long pos){f.seekp(pos);f.write((char*)&nr, sizeof(nr) );f.write( name, sizeof(name) );
return f;}fstream& HashEntry::read_at(fstream& f, unsigned long pos){f.seekg(pos);f.read((char*)&nr, sizeof(nr) );
f.read( name, sizeof(name));return f;}
676CHAPTER 29MORE ABOUT FILES
HashFile::HashFile(const string file, unsigned long n)throw(OpenError){ios::openmode mode =  ios::in | ios::out | ios::binary;f.open(file.c_str(), mode);    // Open file if it// already exists.if(!f)                         // If file doesn't exist:{f.clear();
mode |= ios::trunc;
f.open(file.c_str(), mode);
if(!f)throw OpenError(name);}
name = file;
b = n;HashEntry rec(0L, "");f.seekp(0L);
for( unsigned long i=0; i < b; i++) // Initialize{                                   // the address spacerec.write(f);
if(!f)throw WriteError(name);}}void HashFile::insert( HashEntry& rec)throw( ReadError, WriteError){HashEntry temp;int  size = temp.getSize();
// Hash-Wert:unsigned long pos = hash_func(rec.getNr());temp.read_at(f, pos*size);         // Read a slot.if(!f)throw ReadError(name);else
{if(temp.getNr() == 0L)          // Slot free?rec.write_at(f, pos*size);  // Yes => Add// to the file.else                            // No => Search for{                               // a free slot.bool found = false;unsigned long p = (pos*size + size)%(b*size);
SOLUTIONS677while( !found && p!= pos*size  ){temp.read_at(f, p);if(!f)throw ReadError(name);elseif(temp.getNr() == 0L)  // Free slotfound = true;       // found.else// Proceed to the next slot:p = (p + size)%(b*size);}if( p == pos*size )       // Address space full.throw WriteError(name);if ( found == true )     // Add to file.rec.write_at(f,p);}if(!f)throw WriteError(name);}}HashEntry& HashFile::retrieve( unsigned long key )throw(ReadError){static HashEntry temp;int size = temp.getSize();unsigned long pos = hash_func(key);   // Hash value.temp.read_at(f, pos*size);            // Read a slot.if(!f) throw ReadError(name);
if(temp.getNr() == key)                // Found?return temp;                        // Yes  => finishelse                                   // No   => search
{unsigned long p = (pos*size + size)%(b*size);while( p!= pos *size )
{temp.read_at(f, p);if(!f)throw ReadError(name);
678CHAPTER 29MORE ABOUT FILES
elseif(temp.getNr() == key)      // Record found.return temp;elsep = (p + size)%(b*size);  // Proceed to the}                                  // next slot.temp.setNr(0L); temp.setName("");  // Key doesn't// exist.return temp;}}void HashFile::display(){HashEntry temp;f.seekg(0L);for(unsigned int i = 0; i < b; i++){temp.read(f);if(!f)throw ReadError(name);temp.display();}
f.clear();}// -------------------------------------------------------//hash_t.cpp: Tests hash files// -------------------------------------------------------#include <iostream>#include <string>#include "hashFile.h"
using namespace std;int main(){try{HashFile hash("Client.fle", 7);       // Address space// of length 7cout << "\nInsert: " << endl;HashEntry kde( 3L, "Vivi");hash.insert( kde );
SOLUTIONS679kde.setNr(10L); kde.setName("Peter");hash.insert( kde );kde.setNr(17L); kde.setName("Alexa");hash.insert( kde );kde.setNr(21L); kde.setName("Peter");hash.insert( kde );kde.setNr(15L); kde.setName("Jeany");hash.insert( kde );
cout << "\nInsertion complete: " << endl;hash.display();unsigned long key;cout << "Key? ";  cin >> key;HashEntry temp = hash.retrieve(key);if(temp.getNr() != 0L)temp.display();elsecout << "Key " << key<< " not found" << endl;}catch(OpenError& err)
{cerr << "Error in opening the file:"<< err.getName() << endl;exit(1);}catch(WriteError& err){cerr << "Error writing to file: "<< err.getName() << endl;exit(1);}
catch(ReadError& err){cerr << "Error reading from file: "<< err.getName() << endl;exit(1);}return 0;}
This page intentionally left blank 
681More about Pointers
This chapter describes advanced uses of pointers.These include pointers
to pointers,functions with a variable number of arguments,and pointers

to functions.An application that defines a class used to represent dynamic
matrices is introduced.
chapter
30
682CHAPTER 30MORE ABOUT POINTERS
// accSort.cpp: Sorts an array of pointers to accounts//              according to the account numbers
// ---------------------------------------------------#include "account.h"
void ptrSwap(Account**, Account** );
void accSort( Account** kptr, int n){Account **temp, **minp, **lastp;
lastp = kptr + n - 1;    // Pointer to the last// pointer in the array.for(  ; kptr < lastp; ++kptr ){minp = kptr;for( temp = kptr + 1; temp <= lastp; ++temp ){if( (*temp)->getNr() < (*minp)->getNr() )minp = temp;}
ptrSwap( kptr, minp );}}void ptrSwap( Account **p1, Account **p2 ){Account *help;
help = *p1; *p1 = *p2; *p2 = help;}POINTER TO POINTERS
The function accSort()
POINTER TO POINTERS683Motivation
Pointer variables are objects that have an address in memory, and this means you can usepointers to address them. It is thus possible to create pointers to pointers. This is necessaryifan array of pointers is to be dynamically allocated, ora function expects an array of pointers as an argument.In both cases you need to declare a pointer variable that can access the first element inthe array. Since each element in the array is a pointer, this pointer variable must be a
pointer to a pointer.Generating Pointer Arrays Dynamically
Now let’s look into creating a dynamic array of pointers to Accountclass objects.Example:Account** ptr = new Account*[400];The pointer ptris now pointing at the first pointer in the array with a total of 400Account*type pointers. The array elements can be addressed as follows:*ptrandptr[0](pointer to index 0)*(ptr + i)andptr[i](pointer to index i)Access to objects managed by the array is achieved as follows:**ptrand*ptr[0](object addressed by pointer at index 0)**(ptr+i)and*ptr[i](object addressed by pointer at index i)Pointer Arrays as Arguments
When you define a function that expects an array of pointers as an argument, you mustdefine parameters to match.Example:void accSort( Account **kptr, int len);You can use the kptrparameter to manipulate a pointer array whose length is stored inthe second parameter, len. After callingExample:accSort( ptr, 100);kptrpoints to the first pointer ptr[0]in the pointer array ptr. Instead of Account **kptryou can also use the equivalent form Account *kptr[].The opposite page shows an implementation of the function accSort(). The func-tion uses the selection sort algorithm (which you have already worked with) for sorting.
In this case it is important not to sort the accounts itself, but to sort the pointers instead.
This saves time-consuming copying.
684CHAPTER 30MORE ABOUT POINTERS
Fixed argumentsFirst varyingargumentVarying arguments
Last varyingargumentva_start(argp,max)char *bufferint max•••#include <stdarg.h>int func( char *buffer, int max, ... ){va_list argptr;     // Declares argument pointer.
long arg3;. . .va_start( argptr, max);         // Initialization.
arg3 = va_arg( argptr, long );  // Read arguments.// To use argument arg3.. . . .va_end(argptr);     // Set argument pointer to NULL.}VARIABLE NUMBER OF ARGUMENTS
Fixed and varying arguments on the stack
Scheme of a function with varying arguments

VARIABLE NUMBER OF ARGUMENTS685C++ allows you to define functions that allow a variable number of arguments. Oneexample of a function of this type is the standard C function printf(), which requiresat least one argument, a format string. The printf()function uses the conversionspecifiers in the format string to compute the number and type of arguments that follow.Obligatory and Optional Arguments
Functions with a variable number of arguments always expect a fixed number of obliga-toryarguments and a variable number of optionalarguments. At least one obligatory argu-ment is required.As you would expect, you need to define an appropriate parameter for each obligatoryargument when you define a function of this type. The optional arguments are repre-
sented by three dots ...in the parameter list. The function shown opposite, func(),expects two or more arguments. The prototype is, thus, as followsPrototype:
int func( char *buffer, int max, ...);To allow functions with a variable number of arguments to be defined, C++ pushes the
last argument onto the stack first. After calling the sample function func(), the stacklooks like the diagram opposite.The optional arguments are accessed via a pointer, the so-called argument pointer,which is designated by argptrhere. The header files cstdargorstdarg.hcontainmacros, which conform to ANSI standard, to manage the pointer and assure that the
source code will be portable.Access to Arguments
The following steps are required to read the optional arguments:1.The 
va_listtype argument pointer argptrmust be declared in addition toother local variables. The type va_listis defined in the header file stdarg.has a typeless or charpointer.2.The macro 
va_start()is then called to point the argument pointer argptrto the first optional argument. va_start()expects two arguments: the name ofthe argument pointer and the name of the last obligatory parameter.Example:va_start( argptr, max );
686CHAPTER 30MORE ABOUT POINTERS
// input.cpp: The function input() reads characters//            from the keyboard and appends '\0'.//            The input can be corrected with backspace.
// Arguments: 1. Pointer to the input buffer.//            2. Maximum number of characters to be read/             3. Optional arguments: Characters that//               terminate the input.//               This list has to end with CR = '\r'!// Returns:   Character that breaks the input.
// ---------------------------------------------------#include <stdarg.h>#include <conio.h>     // For getch() and putch()int input(char *buffer, int max,... ){int c, breakc;  // Current character, character to// break with.int nc = 0;     // Number of characters read.va_list argp;   // Pointer to the following arguments.while(true){*buffer = '\0';
if( ( c = getch()) == 0)  // Read a character.c = getch() + 256;    // For special keys:// Extended code + 256.va_start(argp, max);      // Initialize argp.do                 // Compare with break characters:if( c == (breakc = va_arg(argp,int)) )return(breakc);while( breakc != '\r');
va_end( argp);if( c == '\b' &&  nc > 0)    // Backspace?{--nc,  --buffer;putch(c);  putch(' '); putch(c);}
else if( c >= 32  &&  c <= 255  &&  nc < max ){               // Place character into the buffer++nc,  *buffer++ = c;  putch(c);  // and output.else if( nc == max)    // Is end of buffer reached?putch('\a');        // Beep.}}VARIABLE NUMBER OF ARGUMENTS (CONTINUED)
The function input()
VARIABLE NUMBER OF ARGUMENTS (CONTINUED)6873.When the macro 
va_arg()is called, the optional argument pointed to byargptris read from the stack. The arguments of va_arg()are the name of theargument pointer and the type of the optional argument:Example:arg3 = va_arg( argptr, long);Each call to the macro va_arg()sets the argument pointer to the next optionalargument. The result of va_arg()has the type stated in the call. It must beidentical to the type of the corresponding optional argument.There is no special terminating condition for the last optional argument. A spe-cific value (such as NULL,1orCR) can be used, or the current number of argu-ments can be defined by an obligatory argument.4.After evaluating the arguments the argument pointer is set to 
NULLby theva_end()macro:Example:va_end( argptr);Optional arguments can also be read more than once. The procedure described above isrepeated beginning at Step 2, that is, with the macro va_start().Notes on the Example OppositeThe sample function input()on the opposite page uses the getch()function to readcharacter input from the keyboard and store it in the buffer addressed by the first argu-
ment. The second argument defines the maximum number of characters to be read. All
other arguments are characters that can terminate keyboard input. The last argument
mustbe a return character ('\r')!Example:#define ESC   27           // ESC key#define F1   (256 + 59)    // F1 key
input( name, 20, ' ', ESC, F1, '\r');This call to input()reads up to 20 characters and stores them in the array name. Inputcan be terminated by pressing the space, ESC,F1, or return keys. The return value is thecorresponding character code. Non-printable characters are ignored unless stated as
optional arguments.Special keys, such as the function keys, return a value of 0for the first call togetch()and the extended codefor the second call. For function keys this code is withinthe range 59Ð68. To distinguish extended codes from normal ASCII codes (0Ð255),the value 256is added to the extended code. A table of extended codes is available inthe Appendix.
688CHAPTER 30MORE ABOUT POINTERS
// funcptr.cpp:  Demonstrates the use of an array//               of pointers to functions.
// --------------------------------------------------#include  <iostream>#include  <cstdlib>    // Prototype of atoi()
#include  <cctype>     // Macros  toupper(), tolower()using namespace std;void  error_message(char *), message(char *),message_up(char *), message_low(char *);void (*functab[])(char *) = { error_message, message,message_up, message_low };char call[]="Input: 1,2, or 3";int main(){int n = 0;
cout << "Which of the three functions "<< "do you want call (1,2, or 3)?\n";cin >> n;if( n<1 || n>3)(*functab[0])( call );else(*functab[n])("Hello, world\n");return 0;}void error_message( char *s)  {  cerr << s << endl; }void message( char *s)       {  cout << s << endl; }
void message_up( char *s){   int c;for( ; *s != '\0';++s) c = toupper(*s),cout.put(c);}void message_low( char *s){   int c;for( ; *s != '\0';++s) c = tolower(*s), cout.put(c);}POINTERS TO FUNCTIONS
A jump table

POINTERS TO FUNCTIONS689Using Pointers to Functions
In C++ the name of a function is a constant pointer to that function. It addresses themachine code for the function. This is a situation that we have already seen for arrays—
the array name is also a constant pointer to the first array element.There are many uses for pointers to functions. You can save them in an array to form ajump table.Individual functions are then accessible via an index.A pointer to a function can also be passed as an argument to another function. Thismakes sense if the function you are calling needs to work with different functions
depending on the current situation.The standard function qsort()is an example of this. qsort()uses the quick sortalgorithmto sort an array. Depending on the type of the array elements and the sort crite-ria, the qsort()function will expect as argument another comparison function.Declaring Pointers to Functions
A pointer to a function is declared as follows:Syntax:type (* funcptr)( parameter_list );This defines the variable funcptr, which can store the address of a function. The func-tion has the type typeand the parameter list stated. The first pair of parentheses is alsoimportant for the declaration. The statement type *funcptr(parameter_list);would declare a function funcptrthat returned a pointer.Now let’s point funcptrto the function compare()and call compare()via thepointer.Example:bool compare(double, double); // Prototypebool (*funcptr)(double, double);
funcptr = compare;
(*funcptr)(9.1, 7.2);Calling(*funcptr)()is now equivalent to calling compare(). The declaration ofcompare()is necessary to let the compiler know that compareis the name of a func-tion.In the program shown opposite, functabis an array with four pointers to functionsof the voidtype, each of which expects a C string as an argument. functabis initial-ized by the functions stated in its definition and thus functab[0]points toerror_message(),functab[1]tomessage(), etc. When the program is exe-cuted, the function with the specified index is called.
690CHAPTER 30MORE ABOUT POINTERS
COMPLEX DECLARATIONS
1st Example:3.0. 
strptr is a1. pointer to

2. an array with 50 elements of type

3. 
char.1.0.2.
char (* strptr) [50]2nd Example:5.6.5.3.1.0.2.4.
0. 
func is a1. function with return value  of type

2. pointer to

3. an array with elements of type

4. pointer to

5. 
long.0. 
funcptr is a1. pointer to

2. a function with return value of type

3. pointer to

4. an array with elements of type

5. pointer to

6. 
char.4.2.0.1.
long  *  (* func () )[]
3rd Example:char  *  (* (* funcptr ) () ) []
3.
COMPLEX DECLARATIONS 691OperatorSignificance
Array with elements of typeFunction with return value of type
Pointer to
Reference to[]()*
&Operators and Complex Declarations
In the declaration and definition of a function or a variable the same operators that youfind in expressions are used in addition to the base type and the name. These operators
are:Acomplex declaration always uses more than one of these operators.Example:char *strptr[50];This declares strptras an array of pointers to char. In a declaration, a combination ofthe three operators is permissible, however, the following exceptions apply:the elements of an array cannot be functionsa function cannot return a function or an array (but it can return a pointer to a
function or an array).Operators have the same precedence in declarations as in expressions. You can useparentheses to redefine the order of precedence.RulesWhen a complex declaration is evaluated, the following rules are applied:0.Always start with the identifier being declared.
Then repeat the following steps until all the operators have been resolved:1.If the parentheses/brackets 
()or[]are on the right,they are interpreted.2.If there is nothing or just a right bracket on the right 
), the asterisk on the leftisinterpreted, if it exists.At last the base type is interpreted.This proceeding is demonstrated by the example opposite. The above rules apply toboth the function and each of its arguments.
692CHAPTER 30MORE ABOUT POINTERS
1st Example:typedef DayTime FREETIME;FREETIME timeArr[100];2nd Example:typedef struct { double re, im; } COMPLEX;
COMPLEX z1, z2, *zp;3rd Example:
typedef enum { Mo, Tu, We, Th, Fr } WORKDAY;
WORKDAY day;4th Example:typedef enum { Diamonds, Hearts,Spades, Clubs } COLOR;typedef enum { seven, eight, nine, ten ,jack, queen, king, ace } VALUE;typedef struct
{COLOR f;
VALUE w;} CARD;typedef CARD[10] HAND;HAND player1, player2, player3;DEFINING TYPENAMES
DEFINING TYPENAMES 693ThetypedefKeyword
C++ allows you to give types a new name using the keyword typedef.Example:typedef unsigned char BYTE;This defines the type name BYTE, which can then be used as an abbreviation of theunsigned chartype. The statementExample:BYTE array[100];will then define an array arraywith 100 elements of the unsigned chartype. Typenames are normally uppercase, although this is not mandatory.Examples:typedef int* INTPTR;typedef enum{ RED, AMBER, GREEN } Lights;Here,INTPTRidentifies the type “pointer to int” and Lightsis an enumerated type.The new type name always assumes the position of a variable name in a typedefdefinition. Omitting the typedefprefix will define a variable name but not a new typename.Type definitions do not allocate memory and do not create a new type. They simplyintroduce a new name for an existing type.Example:typedef char* (*PTR_TO_FUNC)();The type name PTR_TO_FUNCis an abbreviation for the type “pointer to a function thatreturns a pointer to char.” The declarationExample:PTR_TO_FUNC search;is then equivalent tochar* (*search)();Advantages
The major advantage of using typedefis that it improves the readability of your pro-grams, especially when complex types are named.One additional advantage is that you can isolate platform dependent types. When aprogram is ported to another platform, you only need to change the platform dependent
type once in the typedefdefinition.
694CHAPTER 30MORE ABOUT POINTERS
// matrix.h:  Representing dynamic matrices.// ---------------------------------------------------
#include <stdexcept>#include <iostream>using namespace std;class Row{double *ro;   int size;public:Row( int s) { size = s; ro = new double[s]; }~Row(){ delete[]ro; }double& operator[](int i) throw(out_of_range){if(i < 0 || i > size)throw out_of_range("Column index: Out of Range\n");elsereturn ro[i];}};class Matrix{Row **mat;            // Pointer to array of rowsint lines, cols;      // Number of rows and columnspublic:Matrix(int ro , int co ){ lines = ro; cols = co;mat = new Row*[lines];
for(int i=0; i < lines; i++)mat[i] = new Row(cols);}~Matrix(){   for(int i=0; i < lines; i++)delete mat[i];delete[] mat;}int  getLines() const { return lines; }int  getCols() const { return cols; }Row& operator[](int i) throw(out_of_range){ if(i < 0 || i > cols)throw out_of_range("Row index: Out of Range\n");elsereturn *mat[i];}};APPLICATION:DYNAMIC MATRICES
Class Matrix

APPLICATION: DYNAMIC MATRICES695Now let’s develop an application that uses a class to represent dynamic matrices. Matri-ces are used for computing vectors needed to move, rotate, or zoom images in graphics
programming, for example.TheMatrixClassMemory is to be allocated dynamically to a matrix mat runtime. Additionally, it shouldbe possible to use the index operator to access the elements of the matrix.Example:m[i][j]  // Element in row i, column jThe class will therefore need a dynamic member to reference the matrix. As you already
know, a matrix is a single-dimensional array whose elements are single-dimensional
arrays themselves.The class Row, which can be used to represent single-dimensional arrays of doublevalues, is defined opposite. The index operator is overloaded for the Rowclass to allowan exception of the out_of_rangetype to be thrown for invalid indices.TheMatrixclass contains a dynamic member, mat, which can address an array ofpointers to Rowobjects.matis thus a pointer to a pointer.Constructor,Destructor,and Subscript Operator
The constructor in the Matrixclass creates an array of linespointers to objects of theRowtype. A loop is then used to allocate memory to the rows dynamically.In contrast, the destructor releases the memory occupied by the line arrays first, beforereleasing the space occupied by the pointer array mat.The subscript operator in the Matrixclass returns the line array ifor a given indexi. When the following expression is evaluatedExample:m[2][3]the first call is to the subscript operator of the Matrixclass, which returns a line array toindex 2. Then the subscript operator of the Rowclass is called for the line array. Itreturns a reference to the doublevalue at index 3.You will be enhancing the Matrixclass in the exercises to this chapter by overload-ing the copy constructor and the assignment, for example.
exercises
696CHAPTER 30MORE ABOUT POINTERS
#include <iostream>using namespace std;char* color[] = {"WHITE", "PINK", "BLUE", "GREEN" };int main()
{cout << *color[1] << "  "<< *color << "  "
<< *(color[3] + 3) << "  "
<<  color[2] + 1 << "  "
<< *( *(color + 1) + 3)<< endl;return 0;}Since the comparison function comparewill be called as a C function, it shouldbe declared and defined asextern "C" int compare(....);Refer to the Appendix “Binding C Functions.”NOTE
EXERCISESListing for exercise 1
For exercise 3
The standard function 
qsort()#include <cstdlib>void qsort( void* array, size_t n, size_t size,int (*compare)(const void*, const void*));The function qsort(),”quick sort,” sorts an array of 
nelements whose firstelement is pointed to by 
array.The size of each element is specified by 
size.The comparison function pointed to by 
compareis used to sort the content
of the array in ascending order
.qsort()
calls the function with two arguments
that point to the elements being compared.
You will normally need to define the comparison function yourself.The
function must return an integer less than,equal to,or greater than zero if the

first argument is less than,equal to,or greater than the second.

EXERCISES697You can use the SelectionSort()function defined in Exercise 4 of Chapter 17 as an algorithm forsorting the intvalues in this exercise.Use the standard function qsort(), whose prototype is defined opposite, as quick sort algorithmfor this exercise.NOTE
Exercise 1
What does the program opposite output on screen?
Exercise 2
Write a function min()that computes and returns the minimum of two positive
numbers.The function expects a 
variable
number of 
unsigned intvalues asarguments.The last argument must be the number 
0.Exercise 3
Write a C++ program that compares the speed of the quick sort and selection

sort algorithms
Sort two identical sequences of random numbers of the type 
intto test thesort algorithms.Read the maximum number of random numbers from the

keyboard and allocate the needed memory dynamically.Display the time in

seconds required for the sort operation on screen after each sort operation.
Exercise 4
Write additional methods to complete the 
Matrixclass.Add a 
constversion of the subscript operator to the 
RowandMatrixclasses.Use an 
inlineimplementation.Define a constructor for the 
Matrixclass.The constructor dynamically
allocates a matrix with a given number of rows and columns,and initial-

izes the matrix elements with a given value.Also write a copy construc-

tor.
Overload the assignment operator 
=and the compound assignment oper-ator+=.Additionis defined for two 
nnmatrices,AandB,which have equal num-
bers of rows and columns.The sum 
Cis a nnmatrix whose elementsare computed by adding elements as follows
C[i,j] = A[i,j] + B[i,j]for
i, j = 0, ..., n-1Test the 
Matrixwith a suitable mainfunction that calls all the methods.Display the results of the calculations on screen.

solutions
698CHAPTER 30MORE ABOUT POINTERS
SOLUTIONSExercise 1
Screen output:
P  WHITE  E  LUE  KExercise 2
// -------------------------------------------------------//minivar.cpp// Defines and tests the function min(), which
// computes and returns the minimum of positive integers.
// The function expects a variable number of arguments
// with unsigned int types.
// The last argument must be 0!
// -------------------------------------------------------
#include <stdarg.h>unsigned int min( unsigned int first, ... ){unsigned int minarg, arg;va_list argptr;  // Pointer to optional argumentsif( first == 0)return 0;va_start( argptr, first);minarg = first;
while( (arg = va_arg(argptr, unsigned int) ) != 0)if( arg < minarg)minarg = arg;va_end (argptr);
return minarg;}// ----- A small function main() for testing---------------#include <iostream>using namespace std;
int main(){cout << "\nThe minimum of : 34 47 19 22 58 "<< "is:  " << min(34, 47, 19, 22, 58, 0)<< endl;return 0;}
SOLUTIONS699Exercise 3
// -- ----------------------------------------------------//sort_t.cpp// Compares the performances of sorting algorithms
//            quick sort  and  selection sort
// For this purpose, two identical arrays are dynamically
// generated and initialized with random numbers.
// The times needed for sorting are displayed.
// -------------------------------------------------------
#include <iostream>
#include <iomanip>
#include <cstdlib>
#include <ctime>
using namespace std;void isort(int *v, int lenv);
// For qsort():extern "C" int intcmp(const void*, const void*);main(){unsigned int  i, size;
int  *numbers1, *numbers2;
long time1, time2;cout << "\n   The performance of the sorting algorithms"<< "\n        quick sort  and  selection sort"
<< "\n    is being compared.\n\n"
<< "\nHow many numbers are to be sorted?   ";cin >> size;numbers1 = new int[size];
numbers2 = new int[size];
cout << "\nThere are "<< size << " random numbers to be generated.\n";srand((unsigned)time(NULL)); // Initialize the// random number generator.for(i = 0 ; i < size ; ++i)numbers1[i] = numbers2[i] = rand(); // Random numberscout << "\nSorting starts! Please wait.\n";time(&time1);                     // Length of time// for quick sort.qsort(numbers1, size, sizeof(int), intcmp);
time(&time2);cout  << "\nTime taken by the quick sort algorithm: "<<   time2 - time1 << " seconds.\n";
700CHAPTER 30MORE ABOUT POINTERS
cout << "\nI am sorting again. Please wait!\n";time(&time1);                      // Length of timeisort(numbers2, size);             // for selection sorttime(&time2);cout << "\nTime taken by the insertion sort algorithm: "<< time2 - time1 << " seconds.\n"
<< "\nOutput sorted numbers? (y/n)\n\n";char c;  cin >> c;if( c == 'Y' || c == 'y')for( i = 0 ; i < size ; ++i)cout << setw(12) <<  numbers1[i];cout << endl;return 0;}extern "C" int intcmp( const void *a, const void *b){return (*(int*)a - *(int*)b);}// -------------------------------------------------------// isort()  sorts an array of int values//          using the selection sort algorithm.void isort( int *a, int len)   // Sort the array a of{                              // length len in ascendingregister int *b, *minp;     // order
int *last, help;last = a + len - 1;      // Points to the last elementfor( ; a <= last; ++a)   // Search for the smallest{                        // element starting at a.minp = a;             // minp points to the "current"// smallest array element.for( b = a+1; b <= last; ++b)    // Search for theif( *b < *minp )              // minimum.minp = b;help = *a, *a = *minp, *minp = help;    // Swap.}}
SOLUTIONS701Exercise 4
// -- ----------------------------------------------------//matrix.h:  Represents dynamic matrices// -------------------------------------------------------
#ifndef _MATRIX_H_
#define _MATRIX_H_#include <stdexcept>#include <iostream>using namespace std;class Row{double *ro;
int size;public:Row( int s) { size = s; z = new double[s]; }~Row(){ delete[]ro; }double& operator[](int i){if(i < 0 || i > size)throw out_of_range("Row index: Out of Range\n");return ro[i];}
const double& operator[](int i)  const{if(i < 0 || i > size)throw out_of_range("Row index: Out of Range\n");return ro[i];}};class Matrix{private:Row **mat;            // Pointer to array of rows
int lines, cols;      // Number of rows and columnspublic:Matrix(int ro , int co)
{lines = ro; cols = co;mat = new Row*[lines];
for(int i=0; i < lines; i++)mat[i] = new Row(cols);}
Matrix:: Matrix( int z, int s, double val);
702CHAPTER 30MORE ABOUT POINTERS
Matrix( const Matrix& );~Matrix()
{  for(int i=0; i < lines; i++)delete mat[i];delete[] mat;}int  getLines() const { return lines; }int  getCols()  const { return cols; }Row& operator[](int i){if(i < 0 || i > cols)throw out_of_range("Row index: Out of Range\n");return *mat[i];}const Row& operator[](int i) const{if(i < 0 || i > cols)throw out_of_range("Row index: Out of Range\n");return *mat[i];}// Assignments:Matrix& operator=( const Matrix& );
Matrix& operator+=( const Matrix& );};#endif// ------------------------------------------------------//matrix.cpp: Defines methods of class Matrix// ------------------------------------------------------
#include "matrix.h"Matrix:: Matrix( int ro, int co, double val){lines = ro; cols = co;mat = new Row*[lines];          // Array of pointers to// arrays of rowsint i, j;for(i=0; i < lines; i++)        // Arrays of rows:{mat[i] = new Row(cols);      // Allocate memoryfor(j = 0; j < cols; ++j)(*this)[i][j] = val;     // and copy values.}}
SOLUTIONS703Matrix:: Matrix( const Matrix& m){lines = m.lines; cols = m.cols;  // Rows and columnsmat = new Row*[lines];           // Array of pointers// to arrays of rowsint i, j;
for(i=0; i < lines; i++)         // Arrays of rows:{mat[i] = new Row(cols);      // To allocate// storagefor( j = 0; j < cols; ++j)(*this)[i][j] = m[i][j]; // and copy values.}}Matrix& Matrix::operator=(const Matrix& m){int i, j;                // Free "old" storage:for(i=0; i < lines; i++)delete mat[i];delete[] mat;lines = m.lines; cols = m.cols;  // Rows, columns
mat = new Row*[lines];           // Array of pointers// to arrays of rowsfor(i=0; i < lines; ++i)         // Array of rows:
{mat[i] = new Row(cols);       // Allocate spacefor( j = 0; j < cols; ++j)(*this)[i][j] = m[i][j];   // and copy values.}return *this;}Matrix& Matrix::operator+=( const Matrix& m){int i, j;
if( cols == m.cols && lines == m.lines)for( i=0; i < lines; ++i)for( j=0; j < cols; ++j)(*this)[i][j] += m[i][j];return *this;}
704CHAPTER 30MORE ABOUT POINTERS
// ------------------------------------------------------//matrix_t.cpp: Tests dynamic matrices// ------------------------------------------------------#include "matrix.h"void display( Matrix& m);        // Output a matrix.
int main()
{Matrix m(4,5);
try{int i,j;
for( i=0; i < m.getLines(); i++)for( j=0; j < m.getCols(); j++)m[i][j] = (double)i + j/ 100.0;cout << "Matrix created" << endl;display(m);Matrix  cop(m);cout << "Copy generated." << endl;display(cop);cop += m;cout << "Compute the sum:" << endl;
display(cop);Matrix m1(4, 5, 0.0);cout << "Initializing a matrix with 0:" << endl;
display(m1);m = m1;cout << "Matrix assigned:" << endl;
display(m);}catch(out_of_range& err){  cerr << err.what() << endl;    exit(1);  }
return 0;}void display( Matrix& m){for(int i=0; i < m.getLines(); i++)
{for(int j=0; j < m.getCols(); j++)cout << m[i][j] << "  ";cout << endl;}cin.get();}
705Manipulating BitsThis chapter describes bitwise operators and how to use bit masks.The
applications included demonstrate calculations with parity bits,

conversion of lowercase and capital letters,and converting binary

numbers.Finally,the definition of bit-fields is introduced.
chapter
31
706CHAPTER 31MANIPULATING BITS
Bitwise ANDBitwise inclusive OR
ResultResult
0 & 00 & 11 & 01 & 10 | 00 | 11 | 01 | 100
0101
110 ˆ 00 ˆ 11 ˆ 0
1 ˆ 1~0~1011
010a = 5;b = 12;
c = a & b;
c = a | b;
c = a ˆ b;
c = ~a;unsigned int a, b, c;0 0 . . . . . . . 0 0 1 0 10 0 . . . . . . . 0 1 1 0 00 0 . . . . . . . 0 1 1 0 10 0 . . . . . . . 0 1 0 0 11 1 . . . . . . . 1 1 0 1 00 0 . . . . . . . 0 0 1 0 0Bit patternBITWISE OPERATORS
“True or False”table for bitwise operators
Examples
BITWISE OPERATORS707Bit Coding Data
In cases where conservative use of memory is imperative, data often need to be bit coded,a technique to represent information as individual bits. Some examples of bit coded data
can be found in file access rights or the status-word of a stream.To access bit coded data, you need to be able to read or modify individual bits. C++has six bitwise operators to perform these tasks:Logical bitwise operators&AND|inclusive OR^exclusive OR
NOTBitwise shift operators<<Left shift >>Right shiftOperands for bitwise operators must have integral types. Operands belonging to floatordoubletypes are invalid.The boolean tables on the opposite page show the effect of the logicalbitwise opera-tors for individual bits. If a bit is set, that is, if it has a value of 1, it will be interpreted as
true. If the bit is not set, and thus has a value of 0, it will be interpreted as false. Exam-
ples for each bitwise operator follow.The result type of a bitwise operation will be the integral type defined by the operandtype. If, for example, both operands are inttypes, the result will also be of an inttype.Arithmetic Type Conversions and Precedence
If the operands of a bitwise operator are of different types, normal arithmetic type con-version will occur. If one operand type is an intand the other a long, the intvaluewill be converted to longbefore the operation is performed.The logical bitwise operators &or|should not be confused with the logical &&and||operators. The latter do not affect individual bits but interpret the whole value oftheir operands as boolean, returning a boolean value. The expression 1 && 2returnsthe value true, whereas 1 & 2has the value 0.Theprecedenceof the bitwise NOT operator is high, since is a unary operator. Asyou can see from the table of precedence in the appendix, both the binary operators &, ^,and|have low precedence. However, their precedence is higher than that of the logicaloperators&&and||.
708CHAPTER 31MANIPULATING BITS
a = 12;b = a << 3;
b = a >> 2;unsigned int a, b;0 0 . . . . 0 0 0 0 1 1 0 00 0 . . . . 0 1 1 0 0 0 0 00 0 . . . . 0 0 0 0 0 0 1 1Bit pattern// getbin_t.cpp: Defines the function getbin(), which//               reads a binary number (ex. 0101... )
//               from the standard input, and returns
//               a value of type unsigned int.
// --------------------------------------------------
#include <iostream>
using namespace std;unsigned int getbin(){char c;
unsigned int val = 0;while ( (c = cin.get()) == ' ' || c == '\t' );            // Ignore leading blanks and tabswhile( c == '0' || c == '1' )    // Read and convert{                                // the binary numberval = (val << 1) | (c - '0');
c = cin.get();}return val;}BITWISE SHIFT OPERATORS
Right and left shiftUsing shift operators

BITWISE SHIFT OPERATORS709Left and Right ShiftThe shift operators <<and>>shift the bit pattern of their left operand a certain numberof bit positions. The number of positions is defined by the right operand. The examples
opposite illustrate this point.In the case of a left shift,0bits are padded. The bits dropped on the left are lost.Example:short x = 0xFF00;x = x << 4;              // Result: 0xF000In the case of a right shift, 0bits are padded from the left if the left operand is anunsignedtype or has a positive value. In all other cases, the compiler determineswhether to pad an expression with 0bits (logical shift) or with the sign bit (arithmeticshift), although an arithmetic shift normally occurs.Example:short x = 0xFF00;x = x >> 4;              // Result: 0xFFF0To ensure portable source code, you should use right shifts for positive values only.Integral Promotion
Integral promotion is performed for the operands of a shift operator, that is charisextended to int. The result type in a shift operation is then the same as the type of theleft operand after integral promotion.The result of a shift operation is unpredictable if the value of the right operand is neg-ative or larger than the length of the left operand expressed in bits.Example:char x = 0xFF;x = x >> 9;          // undefined resultApplications
Shift operators allow you to perform efficient multiplication and division with 2n. Shift-ing a number n places left (or right) is equivalent to a multiplication (or division) by 2n.Examples:unsigned res,number = 5;res = number << 3;        // 5 * 23= 40res = number >> 1;        // 5 / 21= 2
710CHAPTER 31MANIPULATING BITS
Bit pattern
Bit positionhigher bitslower bits
nn-143210
10101
01••••
Current bit patterns:  0 1 0 0 0 0 0 1    'A' = 0x41| 0 0 1 0 0 0 0 0   MASK = 0x20  0 1 1 0 0 0 0 1    'a' = 0x61BIT MASKSBit positionsExample#define MASK 0x20char c = 'A';c = c | MASK;
BIT MASKS711Deleting BitsThebitwiseAND operator
is normally used to delete specific bits. A so-called maskis usedto determine which bits to delete.Example:c = c & 0x7F;In the mask 0x7Fthe seven least significant bits are set to 1, and all significant bits areset to 0. This means that all the bits in c, with the exception of the least significant bits,are deleted. These bits are left unchanged.The variable ccan be of any integral type. If the variable occupies more than onebyte, the significant bits in the mask, 0x7F, are padded with 0bits when integral promo-tion is performed.Setting and Inverting Bits
You can use the bitwiseOR operator
|to set specific bits. The example on the oppositepage shows how to change the case of a letter. In ASCII code, the only difference
between a lowercase and an uppercase letter is the fifth bit.Finally, you can use the bitwise exclusive OR operator^to invert specific bits. Each 0-bit is set to 1and each 1-bit is deleted if the corresponding bit in the mask has avalue of 1.Example:c = c ^ 0xAA;The bit pattern for 0xAAis10101010. Every second bit in the least significant eightbits of cis therefore inverted.It is worthy of note that you can perform double inversion using the same mask torestore the original bit pattern, that is, (x ^ MASK) ^ MASKrestores the value x.The following overview demonstrates the effect of a statement for an integral expres-sionxand any given mask, MASK:x & MASKdeletes all bits that have a value of 0 in MASKx | MASKsets all bits that have a value of 1 in MASKx ^ MASKinverts all bits that have a value of 0 in MASK.The other bits are left unchanged.
712CHAPTER 31MANIPULATING BITS
// parity_t.cpp: Defines the function parity(), which//               computes the parity of an unsigned//               value.
// Returns:      0, if the number of 1-bits is even,//               1  in all other cases.// ---------------------------------------------------inline unsigned int bit0( unsigned int x ){return (x & 1);}int parity( unsigned int n){unsigned int par = 0;for( ; n != 0; n >>=1 )par ^= bit0(n);return (par);}USING BIT MASKSComputing the parity of an integer

USING BIT MASKS713Creating Your Own Masks
You can use the bitwise operators to create your own bit masks.Example:x = x & 3;In the bit pattern of 3, only the bits at positions 0and1are set. The mask 3thereforecontains a whole bunch of 1-bits and only the two least significant bits are 0. The aboveexpression would thus delete the two least significant bits in x.The mask 3is independent of the word length of the computer and is thus preferableto the mask 0xFFFC.The next example shows masks that address exactly one bit in a word. They are cre-ated by left shifting 1.Examples:x = x | (1 << 6);x = x & (1 << 6);The first expression sets the sixth bit in x. The same bit is then deleted, as only the sixthbit in the mask (1 << 6)has a value of 0.Of course, you can also use masks such as (1 << n)wherenis a variable containingthe bit position.Example:int setBit(int x, unsigned int n){if( n < sizeof(int) )return( x & (1 << n);}Bitwise Operators in Compound Assignments
The binary bitwise operators &,|,^,<<, and >>can be used in compound assignments.Examples:x >>= 1;x ^= 1;Both statements are equivalent tox = x >> 1;
x = x ^ 1The function parity()shown opposite includes compound assignments with bitwiseoperators. Parity bit computation is used to perform error recognition in data communi-
cations.
714CHAPTER 31MANIPULATING BITS
ByteGeneral FlowControlHeader ErrorControlVirtual Path
IdentifierVirtual Channel
IdentifierVirtual Channel
IdentifierVirtual Channel
IdentifierPayloadType
CLPVirtual Path
IdentifierGeneral Flow ControlVirtual Path/Channel Identifier

Payload Type
Controls the data streamAddress of the virtual  path/channel
Distinguish between payload and control
data
Mark cells with high priority
Check sum for headerCLP 
(Cell Loss Priority)Header Error Control12
3
45struct ATM_Cell{unsigned GFC : 4;     // General Flow Controlunsigned VPI : 8;     // Virtual Path Identifier
unsigned VCI : 16;    // Virtual Channel Identifierunsigned PT  : 3;     // Payload Typeunsigned CLP : 1      // Cell Loss Priority
unsigned HEC : 8;     // Header Error Controlchar payload[48];     // Payload};BIT-FIELDS
Header of ATM cells
Representing an ATM cell

BIT-FIELDS715C++ lets you divide a computer word into bit-fieldsand give the bit-fields a name. Bit-fields offer major advantages; their uncluttered structure makes them preferable and less
error prone than using masks and bitwise operators to manipulate individual bits.Defining Bit-FieldsBit-fields are defined as data members of a class. Each bit-field is of unsigned inttypewith an optional nameandwidth. The width is defined as the number of bits the bit-fieldoccupies in a computer word and is separated from the bit-field name by a colon.Example:struct { unsigned bit0_4 : 5;unsigned        : 10;
unsigned bit15  : 1; } word;The member word.bit0_4designates the 5least significant bits in a computer wordand can store values in the range 0to31. The second data member does not have aname and is used to create a gap of 10bits. The member word.bit15contains thevalue at bit position 15.You cannot reference nameless bit-fields. They are used to align the subsequent bit-fields at specific bit positions.The width of a bit-field cannot be greater than that of the computer word. The width0has a special significance; the subsequent bit-field is positioned on the next wordboundary, that is, it begins with the next computer word. If a bit-field will not fit in a
computer word, the following bit-field is also positioned on the next word boundary.There are several special cases you need to consider when dealing with bit-fields:you cannot use the address operator for bit-fields. You cannot create arrays of bit-
fields. Neither restriction applies to a class containing bit-field members, how-
ever.the order bit-fields are positioned in depends on the machine being used. Some
computer architectures position bit-fields in reverse order. This is true of DEC
Alpha workstations, for example.The Sample Program Opposite
The opposite page shows a class designed to represent ATM cells. Cells are used for datatransportation in ATM (AsynchronousTransferMode) networks. Each cell comprises a 5byte header with addresses and a checksum for error checking and 48byte data sectionorpayload. The header shown here is used to connect a computer to the network in theUser Network Interface.
exercises
716CHAPTER 31MANIPULATING BITS
******  BITWISE OPERATORS  ******Please enter two integers.
1st Number  -->  572nd Number  --> -3The bit pattern of 57 = x :   0000 0000 0011 1001The bit pattern of -3 = y :   1111 1111 1111 1101The bit pattern of x & y :    0000 0000 0011 1001The bit pattern of x | y :    1111 1111 1111 1101
The bit pattern of x ^ y :    1111 1111 1100 0100How many bit positions is x to be shifted?Count --> 4The bit pattern of x << 4 : 0000 0011 1001 0000The bit pattern of x >> 4 : 0000 0000 0000 0011Repeat (y/n)?EXERCISESSample screen output for exercise 1

EXERCISES717Exercise 1
a.Write the function 
putBits()that outputs the bit pattern of a number
as an unsigned inttype.Only the 16 least significant bits are to be
output no matter what the size of the computer word.The number is

passed as an argument to the function,which has no return value.
b.Write a tutorial to demonstrate the effect of bitwise operators.First
read two decimal integers from the keyboard and store them in the vari-

ablesxandy.Then use the function 
putBits()to output the bit pat-terns of x,x&y,x | y,x ^ y,and 
x.To demonstrate the shift operators,shift the value of 
xa given number of
bit positions right and left.Read the number of bit positions from key-

board input.Use the value 1 in case of invalid input.
The opposite page shows sample output from the program.
Exercise 2
Your task is to encrypt data to prevent spying during data communications.The
sender uses a filter to encrypt the data in question,and the receiver uses the

same filter to decrypt the transmission.
a.Define the function 
swapBits()that swaps two bits in an 
intvalue.The
intvalue and the positions of the bits to be swapped are passed as argu-
ments to the function.The return value is the new 
intvalue.If one of
the positions passed to the function is invalid,the 
intvalue should bereturned unchanged.
b.Write a filter that swaps the bits at bit positions 5 and 6,0 and 4,and 1
and 3 in all characters except control characters (defined as ASCII Code

>= 32).Test the filter by writing the encrypted output to a file and then using the same
filter to output the new file.The output must comprise the original unencrypted

data.
solutions
718CHAPTER 31MANIPULATING BITS
SOLUTIONSExercise 1
// ------------------------------------------------------//bits_t.cpp// Demonstrates bitwise operators.
// ------------------------------------------------------
#include <iostream>
#include <iomanip>
using namespace std;void putbits( unsigned int n);  // Prototype of putbits()
int main()                   // Learning bitwise operations{int  x, y, count;
char yn;do{cout << "\n\n   ******  BITWISE OPERATIONS  ******\n";cout << "\nPlease enter two integers.\n\n"<<  "1st number --> ";cin >> x;cout << "2nd number --> ";cin >> y;cout << "\nThe bit pattern of "<< setw(6) << x << " = x  :    ";putbits(x);cout << "\nThe bit pattern of "<< setw(6) << y << " = y  :    ";putbits(y);cout << "\nThe bit pattern of     x & y  :    ";putbits(x&y);cout << "\nThe bit pattern of     x | y  :    ";putbits(x|y);cout << "\nThe bit pattern of     x ^ y  :    ";putbits(x^y);cout << "\n\nHow many bit positions"" is x to be shifted?"<< "\nNumber --> ";cin >> count;
SOLUTIONS719if( count < 0  ||  count > 15){cout << "Invalid input!"<< " Shifting by one bit position.\n";count = 1;}
cout << "\nThe bit pattern of     x << "<< setw(2) << count << " :    ";putbits( x << count);cout << "\nThe bit pattern of x >> "<< setw(2) << count << " :    ";putbits( x >> count);cout << "\nRepeat (y/n)? ";cin >> yn;
while( (yn | 0x20) != 'y'  &&  yn != 'n');}while( yn == 'y');return 0;}// ------------------------------------------------------// Output the bit pattern of n (only the 16 lower bits).void putbits( unsigned int n ){int i;for( i = 15; i >= 0 ; --i){cout << (char)( ((n>>i) & 1) + '0');   // i-th bit
if( i % 4 == 0  &&  i > 0)     // and after 4 bitscout << ' ';                // one blank.}}Exercise 2
// -------------------------------------------------------
//hide_t.cpp:Filter to encrypt data.//               Swap bits in bit positions 5 and 6,
//               0 and 4,  1 and 3 for all characters
//               except control characters.
//               Modules:  hide_t.cpp,  swapbits.cpp
//
//  Call:       hide_t [ < sourcefile ] [ > destfile ]
// -------------------------------------------------------
720CHAPTER 31MANIPULATING BITS
#include <iostream>using namespace std;int swapbits( int ch, int bitnr1, int bitnr2); // Prototypeint main()                                  // Encrypt data{int c;
while( (c = cin.get()) != EOF){if( c >= 32)                    // Control character?
{c = swapbits(c, 5, 6);       // Swap bitsc = swapbits(c, 0, 4);c = swapbits(c, 1, 3);}cout << c;}
return 0;}// -------------------------------------------------------//swapbits.cpp: The function swapbits() swaps two bits//               within an integer.
// Arguments:    The integer and two bit positions.
// Returns:      The new value.
// -------------------------------------------------------int swapbits( int x, int bitnr1, int bitnr2){                              // To swap two bits in x.int newx, mask1, mask2;
int msb = 8 * sizeof(int) - 1;  // Highest bit positionif( bitnr1 < 0 || bitnr1 > msb ||bitnr2 < 0 || bitnr2 > msb)return x;       // Return, if bit position is invalidmask1 = (1 << bitnr1);    // Shift 1 to position bitnr1mask2 = (1 << bitnr2);    // Shift 1 to position bitnr2newx = x & ~(mask1 | mask2);        // Delete both bitsif( x & mask1 )  newx |= mask2;     // Swap bits.if( x & mask2 )  newx |= mask1;return( newx);}
721Templates
Templates allow you to construct both functions and classes based on
types that have not yet been stated.Thus,templates are a powerful tool

for automating program code generation.
This chapter describes how to define and use function and class
templates.In addition,special options,such as default arguments,

specialization,and explicit instantiation are discussed.
chapter
32
722CHAPTER 32TEMPLATES
FUNCTION AND CLASS TEMPLATES
Template and instantiation
Template
Instantiation for
Type  
longType  
intType  
char

FUNCTION AND CLASS TEMPLATES723Motivation
As a programmer you will often be faced with implementing multiple versions of similarfunctions and classes, which are needed for various types.A class used to represent an array of intvalues is very similar to a class representingan array of doublevalues, for example. The implementation varies only in the type ofelements that you need to represent. Operations performed with elements, such as search
and sort algorithms, must be defined separately for each type.C++ allows you to define templates—parameterized families of related functions orclasses:afunction templatedefines a group of statements for a function using a parameterinstead of a concrete typeaclass templatespecifies a class definition using a parameter instead of a concretetype.A class template can provide a generic definition that can be used to represent varioustypes of arrays, for example. During instantiation, that is, when a concrete type is defined,an individual class is created based on the template definition.Advantages of Templates
Templates are powerful programming tools.A template need only be coded once. Individual functions or classes are automat-ically generated when needed.A template offers a uniform solution for similar problems allowing type-inde-
pendent code to be tested early in the development phase.Errors caused by multiple encoding are avoided.Templates in the Standard Library
The C++ standard library contains numerous class template definitions, such as thestream classes for input and output, string, and container classes. The classes string,istream,ostream,iostream, and so on are instantiations for the chartype.The standard library also includes an algorithm library, which comprises many searchand sort algorithms. The various algorithms are implemented as global function tem-
plates and can be used for any set of objects.
724CHAPTER 32TEMPLATES
// stack.h : The class template Stack with//           methods push() and pop().
//-----------------------------------------------------template<class T>class Stack{private:T* basePtr;      // Pointer to array
int tip;         // Stack tip
int max;         // Maximum number of elementspublic:Stack(int n){ basePtr = new T[n]; max = n; tip = 0;}Stack( const Stack<T>&);
~Stack(){ delete[] basePtr; }Stack<T>& operator=( const Stack<T>& );
bool empty(){ return (tip == 0); }bool push( const T& x);bool pop(T& x);};template<class T>bool Stack<T>::push( const T& x)
{if(tip < max - 1)        // If there is enough space{basePtr[tip++] = x;  return true;}
else return false;}template<class T>bool Stack<T>::pop( T& x){if(tip > 0)             // If the stack is not empty{x = basePtr{--tip];   return true;}else return false;}DEFINING TEMPLATES
Class template 
Stack
DEFINING TEMPLATES725Defining Function Templates
The definition of a template is always prefixed bytemplate<class T>where the parameter Tis a type name used in the definition that follows. Although youmust state the classkeyword,Tcan be any given type, such as an intordouble.Example:template <class T>void exchange(T& x, T&y)
{T help(x); x = y; y = help;}This defines the function template exchange(). The parameter Trepresents the typeof variables, which are to interchange. The name Tis common but not mandatory.Defining Class Templates
Example:template <class U>class Demo
{U elem;    . . .  // etc.};This defines the class template Demo<U>. Both UandDemo<U>are treated like normaltypes in the class definition. You simply need to state the name of the template, Demo,within the class scope.The methods of a class template are also parameterized via the future type. Eachmethod in a class template is thus a function template. If the definition is external to the
class template, function template syntax is used. The method name is prefixed by the
class template type and the scope resolution operator.The example on the opposite page illustrates this point by defining a stacktemplate.A stack is managed according to the last-in-first-out principle, lifo-principlefor short; thelast element to be “pushed” onto the stack is the first to be removed, or “popped,” from
the stack.The methods of a class template are normally defined in the same header file. Thisensures that the definition will be visible to the compiler, since it requires the definition
to generate machine code for concrete template arguments.
726CHAPTER 32TEMPLATES
// stack_t.cpp: Testing a stack// ----------------------------------------------------#include <iostream>
#include <iomanip>using namespace std;#include "stack.h"
typedef Stack<unsigned> USTACK; // Stack for elements// of type unsigned.void fill(  USTACK& stk );void clear( USTACK& stk );int main(){USTACK ustk(256);     // Create and fillfill( ustk);          // the original stack.USTACK ostk(ustk);    // Copy.cout << "The copy: " << endl;
clear( ostk);         // Output and clear the copy.cout << "The original: " << endl;clear( ustk );        // Output, clear the original.return 0;}void fill( USTACK& stk ){unsigned x;cout << "Enter positive integers (quit with 0):\n";while( cin >> x  && x != 0 )if( !stk.push(x) ){cerr << "Stack is full!"; break;}}void clear( USTACK& stk ){if(stk.empty())cerr << "Stack is empty!" << endl;else{unsigned x;
while( stk.pop(x))cout << setw(8) << x << "  ";cout << endl;}}TEMPLATE INSTANTIATION
Sample program

TEMPLATE INSTANTIATION727Defining a template creates neither a concrete function nor a class. The machine codefor functions or methods is not generated until instantiation.Instantiating Template Functions
Atemplate functionis instantiated when it is first called. The compiler determines theparameter type of Tby the function arguments.Example:short a = 1, b = 7;exchange( a, b );The template is first used to generate the exchange()function machine code for theshorttype. The template functions can be called after this step.This allows you to generate an exchange()template function for any type. Giventhatxandyare two doublevariables, the following statementExample:exchange( x, y );creates a second template function for the doubletype.Instantiation of Template Classes
The instantiation of a template classis performed implicitlywhen the class is used for thefirst time, for example, when an object of the template class is defined.Example:Stack<int> istack(256);// implicit
This statement first creates the template class Stack<int>, generating the machinecode of all methods for the inttype. After this step has been completed, an istackobject of the Stack<int>type can be constructed.If a further template class, such as Stack<float>is created, the machine code gen-erated for the methods in this template class will be different from the machine code of
theStack<int>methods.In other words, developing templates will not reduce the amount of machine coderequired for a program. However, it does spare the programmer’s extra work required to
develop multiple versions of functions and classes.Templates are double checked for errorsby the compiler—once when the templatedefinition is compiled and again during instantiation. The first check recognizes errors
that are independent of the template parameters. Errors in parameterization cannot be
detected until instantiation if, for example, an operator for the template argument type
has not been defined.
728CHAPTER 32TEMPLATES
// stackn.h: Class Template Stack<T, n>// ---------------------------------------template <class T, int n>class Stack
{private:T   arr[n];      // Arrayint tip;         // Tip of stack
int max;         // Maximum number of elementspublic:Stack(){ max = n; tip = 0; };bool empty(){ return (tip == 0); }bool push( const T& x);
bool pop(T& x);};template<class T, int n>bool Stack<T, n>::push( const T& x){if(tip < max - 1)
{arr[tip++] = x; return true;}
else return false;}template<class T, int n>bool Stack<T, n>::pop(T& x )
{if(tip > 0){x = arr{--tip];  return  true;}
else return false;}TEMPLATE PARAMETERS
TheStacktemplate with two template parameters

TEMPLATE PARAMETERS729Multiple Template Parameters
You can also define templates with multiple parameters like the following class template, Example:template <class U, class V>class Demo
{   // . . .     };which has two parameters UandV. A class Demo<U,V>is defined for each pair of U,Vtypes.A template parameter need not always be a type name. Normal function parametersare also permissible, particularly pointers and references.Example:template<class T, int n>class Stack{ . . . };This defines the class template Stack<T, n>that is parameterized with the type Tandan integer n.The example on the opposite page uses the parameter nto specify the size of an arrayused to represent a stack. The major advantage is that the number of array elements is
already known when an object of the template class is instantiated. Objects can then be
created without allocating dynamic storage.This simplifies the definition of the stack template. The copy constructor, the assign-ment operator, and the destructor no longer need to be defined!RestrictionsTwo restrictions apply to template parameters other than type parameters:they cannot be modifiedthey cannot be floating-point types.The following expression would thus be invalid in the definition opposite:Example:++n; // Error: changing template parameterEven though doubletype template parameters are not permissible,Example:template<class T, double d>  // Error!class Demo { . . . };pointers and references to floating-point types are:Example:template<class T, double& ref>
class Demo { . . . };
730CHAPTER 32TEMPLATES
// mini_t.cpp: Passing arguments to//             function templates
// ----------------------------------------------
#include <iostream>
using namespace std;template <class T>T min( T x, T y)
{return( (x < y) ? x : y);}int main(){short x = 10, y = 2;cout << "x = " << x << "  y = " << y << endl;cout << "The smaller value is: "<< min(x, y) << endl;      // Call is ok.double z1 = 2.2;float  z2 = 1.1F;cout << "\nThe smaller value is: "<< min(z1, z2) << endl;    //Not ok!double z3 = 1.1;cout << "\nz1 = " << z1<< "  z3 = " << z3 << endl;cout << "The smaller value is: "<< min(z1, z3) << endl;    //Call is ok.return 0;}TEMPLATE ARGUMENTS
Sample program

TEMPLATE ARGUMENTS731Passing Arguments
A template is instantiated when a template argument is passed to it. The argument typesmust exactly match to the types of the template parameters.Not even implicit type conversions, such as floattodouble, are performed. In thecase of the template function min()this means that both arguments must be of thesame type. The following callExample:float x = 1.1; double y = 7.7;min ( x , y );would lead to an error message, since the template function cannot be defined by thePrototype:
void min( float , double );RestrictionsThere are several restrictions for template arguments other than type names:if the template parameter is a reference, only a global or static object can bepassed as a template argumentif the template parameter is a pointer, only the address of an object or a function
with global scope can be statedif the template parameter is neither a reference nor a pointer, only constant
expressions can be used as template arguments.Example:int cnt = 256;            // Error:typedef Stack<short, cnt> ShortStack;Since only an intconstant is permitted as a template argument, this statement provokesan error.Strings, such as "Oktoberfest,"are also invalid as template arguments, as theirscope is static and not global.Example:template<class T,char* s> class Demo{...};Only globally defined strings can be used for instantiation, for examplechar str[] = "Oktoberfest";  // globalDemo<double, str> income;    // ok
732CHAPTER 32TEMPLATES
template <class T>T min( T x, T y)
{return( (x < y) ? x : y)}#include <cstring>const char* min( const char* s1, const char* s2 ){return( (strcmp(s1, s2) < 0 ) ? s1: s2 );}#include <cstring>template<>const char* min( const char* s1, const char* s2 ){return( (strcmp(s1, s2) < 0 ) ? s1: s2 );}SPECIALIZATION
Function template 
min()Specializing the function template for C strings
ANSI specialization
The ANSI standard does not differ between template functions and “normal” functions.The definition of a function template and a function with the same name, which can be
generated by the function template, causes the compiler to output an error message (ex.
“duplicate definition ...”).That is why the ANSI standard provides its own syntax for defining specializations:
SPECIALIZATION733Motivation
A template function can only be instantiated if all the statements contained in the func-tion can be executed. If you call the template function exchange()with two objects ofthe same class, the copy constructor and the assignment must be defined for this class.More specifically, all operators used in a template function must be defined for thecurrent argument type. Thus, the function template min(), which determines the lesserof two arguments, can only be instantiated if the operator < is defined for the argument
type.Besides non-executable instructions there are other reasons to prevent a functiontemplate being instantiated for a particular type:the generic approach defined by the template does not return any useful results
for a given typethere are more efficient approaches for some types.The statementExample:minStr = min(, "VIVIAN", "vivian" );only returns the lower of the two addresses at which the C strings are stored.Defining Specialization
In cases like this, it makes sense to specialize the template function definition. To do so,you use a function with a separate definition to overload the template function. This
technique is demonstrated on the opposite page using the function template min(),where a specialization has been defined for the char*type, both for older and moremodern compilers that support the current ANSI standard.If a template function is replaced by a specialization, the appropriate version must beexecuted when a call to the function is made. The order the compiler looks up a function
guarantees that if both a function template and a specialization are defined for a specific
type, the specialization will be called.This also applies to the methods of a class template, which are function templates, ofcourse. More specifically, a template class can only be created if all the methods in the
appropriate function template can be instantiated without error.
734CHAPTER 32TEMPLATES
// quadMat.h:  Defines the template QuadMatrix//             to represent quadratic matrices
// -----------------------------------------------------
#include <iostream>
#include <stdexcept>
using namespace std;template <class T, int cnt = 10>class QuadMatrix
{private:T mat[cnt][cnt];public:int dim() const{ return cnt; }T*  operator[](int line) throw(out_of_range){if( line < 0 || line >= cnt)throw out_of_range("Matrix: Index out of range");elsereturn mat[line];}const T*  operator[](int line) constthrow(out_of_range){if( line < 0 || line >= cnt)throw out_of_range("Matrix: Index out of range");elsereturn mat[line];}
friend QuadMatrix& operator+(const QuadMatrix&,const QuadMatrix&);// etc.};DEFAULT ARGUMENTS OF TEMPLATES
A class template representing quadratic matrices

DEFAULT ARGUMENTS OF TEMPLATES735Setting DefaultsYou can define default arguments for template parameters, just as for function parame-ters. If an argument required to instantiate a template is missing, the default value is then
used.You can specify default values in the template definition or when you declare a tem-plate in a module.The Class Template 
QuadMatrix<T, n> The class template defined opposite, QuadMatrix<T, n>, represents quadratic matri-ces. The subscript operator is overloaded to allow you to access a matrix elementm[i][j]in a given matrix m. If the line index iis outside of the valid range, a standardout_of_rangetype exception is thrown.The default values are chosen to create a matrix mforintvalues with 10 rows and 10columns following this definition:Example:typedef QuadMatrix < > IntMat;IntMat m;You cannot omit the angled brackets since the QuadMatrixtype does not exist.QuadMatrixis merely the name of a template.The following definitionExample:typedef QuadMatrix<double> DoubleMat;DoubleMat dm;defines a matrix dmofdoublevalues with 10 rows and 10 columns.RulesThe same rules apply to the default arguments of templates as to the default arguments offunctions:if you declare a default argument for at least one parameter, you must define
default values for all the remaining parametersif a template argument for which a default argument was declared is omitted dur-
ing instantiation, all the remaining template arguments must be omitted.
736CHAPTER 32TEMPLATES
// expIns_t.cpp:  Tests explicit instantiation// -----------------------------------------------------
#include <iostream>
#include <iomanip>
using namespace std;#include "quadMat.h"// Explicit Instantiation:template class QuadMatrix<long double, 5>;int main(){QuadMatrix<long double, 5> m;try{for(int k=0; k < m.dim(); k++)
{for( int l = 0; l < m.dim(); l++){m[k][l] = k*l;
cout << setw(2) << m[k][l] << " ";}
cout << endl;}}
catch(out_of_range& err )
{cerr << err.what() << endl;}return 0;}EXPLICIT INSTANTIATION
Sample program for the class template 
QuadMatrix
EXPLICIT INSTANTIATION737In addition to implicit instantiation of templates, which occurs when a template func-tion is called, for example, explicit instantiation is also possible. This is important when
you design libraries that contain template functions and classes for application programs.SyntaxExplicit instantiation can be achieved by the followingSyntax:template declaration;wheredeclarationcontains the name of the template and the template arguments.Explicit instantiation for the class template Stackwould be performed as follows:Example:template class Stack<long double, 50>;This declaration creates the template class Stack<long double, 50>with a maxi-mum of 50 long doubletype elements.Function templates can also be instantiated explicitly.Example:template short min( short x, short y);This creates a template function for the shorttype from the function template min().ANSI Instantiation
The ANSI standard provides an additional technique for the explicit instantiation offunction templates. Template arguments are stated in the angled brackets that follow the
function name, when the function is first called.Example:min<long>(x, y);In this case, a template function min()for the longtype is generated. This advancedsyntax for function templates is not supported by all C++ compilers, however.Explicit instantiation of function templates extends their possible usage:function templates can be parameterized by types that cannot be derived from the
function arguments—more specifically, function templates can be defined with-
out function parametersfunction templates can be defined with function parameters that are not template
parameters themselves.
exercises
738CHAPTER 32TEMPLATES
The left, sorted part originally consists of only one element, the first arrayelement.NOTE
EXERCISESInterpolation search
The elements of a numerical array are assumed to be unique and sorted in
ascending order.
The given value is compared with the array element at the position where the
value is “expected” to be.For example,if the value searched for is two-thirds of

the way from the lowest to the highest subarray element,the probe would be

made two-thirds from the lowest to the highest index of the subarray.If the

required value is lesser than that of the array element found at the expected

position,the search is continued in the left part of the subarray,just like a binary

search.Otherwise the search continues in the right part of the subarray.
The “expected” position 
expin an array 
vcan be calculated as follows:If 
keyis the required value,
beginis the lowest,and 
endis the highest index of thecorresponding subarray,the following applies:
double temp = (double)(key-vp[begin]);temp /= (vp[end]-vp[begin]);
temp  = temp * (end - begin) + 0.5;
exp   = begin + (int)temp;Insertion sort algorithm
The following technique is used to divide the array into a left,sorted part and a
right,unsorted part:
Each subsequent element in the unsorted part of the array is selected and
taken out from the array.As long as a greater array element can be found

starting from the end of the left subarray,the element is shifted up by one

position.If a smaller array element is found,the selected element is inserted at

the vacant position.3030305050507070407020202070 > 40?yes
to take outGraphic:
EXERCISES739Exercise 1
Define a function template interpolSearch()that looks up a given ele-
ment in a sorted,numeric array.The array elements are of the same type

as the template parameter T.The function template has three parameters—the value searched for of
typeT,a pointer to the first array element,and the number of array ele-
ments.The function template returns the index of the first element in the array
that corresponds to the searched for value,or –1 if the value cannot be

found in the array.
Implement the function template.Use the technique described opposite
as your algorithm for the interpolation search.Store the function tem-

plate definition in the header file search.h.Define a function template,
insertionSort(),which sorts a numeric
array in ascending order.The array elements are of the type of the tem-

plate parameter T.The function template has two parameters—a pointer to the first array
element,and the number of array elements.There is no return value.
Define a function template display()to display a numeric array on
screen.
The function template has two parameters—a pointer to the first array
element and the number of array elements.There is no return value.
Use the function templates interpolSearch(),insertionSort()
,and
display()to define template functions for 
doubleandshorttypes.To
do so,define an array of 
doublevalues and an array with 
shortvalues.Write a mainfunction that creates and calls each template function
insertionSort()for the 
intanddoubletypes.Then display the
sorted arrays.
Add a call to each template function 
search()in your 
mainfunction.Callsearch()passing values that exist and do not exist in the array.

740CHAPTER 32TEMPLATES
class FloatArr// Without conversion functions{private:float* arrPtr;    // Dynamic member
int max;          // Maximum number, without having// to reallocate storage.int cnt;          // Current number of elementsvoid expand( int new Size);     // Function to help// enlarge the array.public:FloatArr( int n = 256 );
FloatArr( int n, float val);FloatArr(const FloatArr& src);~FloatArr();FloatArr& operator=( const FloatArr& );int  length() const { return cnt; }float& operator[](int i) throw(BadIndex);float operator[](int i) const  throw(BadIndex);void append( float val);void append( const FloatArr& v);FloatArr& operator+=( float val){append( val);   return *this;}FloatArr& operator+=( const FloatArr& v){append(v);   return *this;}void insert( float val, int pos) throw(BadIndex);void insert( const FloatArr& v, int pos )throw(BadIndex);void remove(int pos) throw(BadIndex);friend ostream& operator<<( ostream& os,const FloatArr& v);};Exercises
The class FloatArr(as defined in Chap.28,Ex.1)

EXERCISES741Exercise 2
Define a class template Array<T, n>to represent an array with a maximum of
nelements of type T.Attempting to address an array element with an invalid
index should lead to an exception of the BadIndex(defined previously) error
class being thrown.If there is no space left to insert an element in the array,an
exception of the OutOfRangetype should be thrown.
First define the error class 
OutOfRangewithout any data members.Use
the error class 
BadIndex,which was defined in Exercise 1 of Chapter 28.
Change the existing FloatArrclass into a class template,
Array<T, n>.Use255as the default value for the parameter 
nof the class template.
This allocates memory for the array statically.Now define a default con-
structor and a constructor that initializes a given number of array ele-

ments with a given value.You do not need to define a copy constructor,a

destructor,or an assignment operator.
As access methods define the size()and the length()methods,the
size()method returns the maximum number of array elements,that 
is,n;the 
length()method returns the current number of elements in
the array.
Also define methods for inserting and deleting elements like those
defined for the 
FloatArrclass.The methods have a 
voidreturn type and
can throw exceptions of type 
BadIndexand/orOutOfRange.Additionally overload the index and shift operators 
<<.The subscript
operator throws 
BadIndextype exceptions.Test the class template 
Array<T,n>for 
doubleandinttypes first.Define arrays of the appropriate types,then insert and delete elements in

the arrays.Output all the elements of the array.
Modify the test program by adding an array for objects of a class type.

Use the DayTimeclass from Exercise 1,Chapter 19 for this purpose.
Test the array template by defining an array with 5 
DayTimeclass objectsand inserting a few objects.Then display all the objects on screen.

solutions
742CHAPTER 32TEMPLATES
SOLUTIONSExercise 1
// ------------------------------------------------------//interpol.cpp: Template function interpolSearch()// ------------------------------------------------------
#include <iostream>
using namespace std;template <class T>longinterpolSearch(const T& key, T* vp, int len){int  expect, begin = 0, end = len - 1;
double temp;if( end < 0                      // Array is empty or|| key > vp[end]             // or key is out of|| key < vp[begin] )         // rangereturn -1;while( begin <= end )
{if(key > vp[end] || key < vp[begin] ) // Key is notreturn -1;                         // in range.temp  = (double)(key - vp[begin])/ (vp[end]-vp[begin]);temp  = temp * (end - begin) +0.5;
expect = begin + (int)temp;
if( vp[expect] == key )            // Key found?return expect;if( vp[expect] > key)end = expect - 1;else begin = expect+1;}
return -1;}template <class T>voidinsertionSort( T* vp, int len){T temp;
for( int i=0; i < len; i++)
{temp = vp[i];     // Take element out.
int j;            // Shift greater elements up:
for( j = i-1; j >= 0 && vp[j] > temp; j--)vp[j+1] = vp[j];vp[j+1] = temp;            // Insert.}}
SOLUTIONS743template <class T>voiddisplay(T* vp, int len){cout << "\n\nThe array: " << endl;
for(int i = 0; i < len; i++)
{cout << vp[i] << "  ";
if( (i+1)%10 == 0)cout << endl;}
cout << endl; cin.get();}// Two arrays for testing:short  sv[5] = { 7, 9, 2, 4, 1};
double dv[5] = { 5.7, 3.5, 2.1, 9.4, 4.3 };int main(){cout << "\nInstantiation for type short: " << endl;
display(sv, 5);insertionSort(sv, 5);cout << "\nAfter sorting: ";
display(sv, 5);short key;cout << "\nArray element? ";  cin >> key; cin.sync();
int pos = interpolSearch(key, sv, 5);
if( pos != -1)cout << "\nfound!" << endl, cin.get();elsecout << "\nnot found!" << endl, cin.get();// -------------------------------------------------
cout << "\nInstantiation for type double: " << endl;display(dv, 5);insertionSort(dv, 5);cout << "\nAfter sorting: ";
display(dv, 5);double dkey;cout << "\nArray element? "; cin >> dkey; cin.sync();
pos = interpolSearch(dkey, dv, 5);
if( pos != -1)cout << "\nfound!" << endl, cin.get();elsecout << "\nnot found!" << endl, cin.get();return 0;}
744CHAPTER 32TEMPLATES
Exercise 2
// ------------------------------------------------------//array.h// Use of class templates to represent arrays.
// ------------------------------------------------------
#ifndef _ARRAY_H_#define _ARRAY_H_#include <iostream>#include <iomanip>using namespace std;class BadIndex{private:int index;public:BadIndex(int i):index(i){}
int getBadIndex() const { return index; }};class OutOfRange {  /* Without data members*/ };template <class T, int n = 256>class Array
{private:T   arr[n];          // The array
int cnt;             // Current number of elementspublic:Array( ){ cnt = 0;}Array(int n, const T& val );int  length() const { return cnt; }int  size()   const { return n; }T& operator[](int i) throw(BadIndex){if( i < 0 || i >= cnt ) throw BadIndex(i);return arr[i];}const T&  operator[](int i) const throw(BadIndex){if( i < 0 || i >= cnt ) throw BadIndex(i);
return arr[i];}
SOLUTIONS745Array& operator+=( float val) throw(OutOfRange){append( val);   return *this;}Array& operator+=(const Array& v)  throw(OutOfRange){append(v);   return *this;}void append( T val) throw(OutOfRange);void append( const Array& v) throw(OutOfRange);void insert( T val, int pos)throw(BadIndex, OutOfRange);void insert( const Array& v, int pos )throw(BadIndex, OutOfRange);void remove(int pos) throw(BadIndex);};template <class T, int n >Array<T,n>::Array(int m, const T& val ){cnt = m;
for(int i=0; i < cnt; i++ )arr[i] = val;}template <class T, int n >void Array<T,n>::append( T val) throw(OutOfRange){if( cnt < n)arr[cnt++] = val;elsethrow OutOfRange();}template <class T, int n >void Array<T,n>::append( const Array<T,n>& v) throw(OutOfRange){if( cnt + v.cnt > n)            // Not enough space.throw OutOfRange();int count = v.cnt;              // Necessary if// v == *thisfor( int i=0; i < count; ++i)arr[cnt++] = v.arr[i];}
746CHAPTER 32TEMPLATES
template <class T, int n >void Array<T,n>::insert( T val, int pos)throw(BadIndex, OutOfRange){   insert( Array<T,n>(1,val), pos);}template <class T, int n >void Array<T,n>::insert( const Array<T,n>& v, int pos )throw(BadIndex, OutOfRange){if( pos < 0 || pos >= cnt)throw BadIndex();              // Invalid position.if( n < cnt + v.cnt)throw OutOfRange();int i;for( i = cnt-1; i >= pos; --i)    // Shift uparr[i+v.cnt] = arr[i];         // starting at pos.for( i = 0; i < v.cnt; ++i)       // Fill the gap.arr[i+pos] = v.arr[i];cnt = cnt + v.cnt;}template <class T, int n >void Array<T,n>::remove(int pos) throw(BadIndex){if( pos >= 0 && pos < cnt){for( int i = pos; i < cnt-1; ++i)arr[i] = arr[i+1];--cnt;}else  throw BadIndex(pos);}template <class T, int n >ostream& operator<<(ostream& os, const Array<T,n>& v)
{int w = os.width();       // Save the field widthfor( int i = 0; i < v.cnt; ++i){os.width(w);    os << v.arr[i];}os << endl;return os;}
#endif
SOLUTIONS747// ----------------------------------------------------//DayTime.h// Class DayTime with relational operators,
// the operators ++ and -- (prefix and postfix),
// and the operators << and >> for I/O.
// ----------------------------------------------------// The same as in Chapter 19.// ------------------------------------------------------//Array_t.cpp// Testing class templates Array<T,n>.
// ------------------------------------------------------#include "array.h"#include "DayTime.h"
#include <cstdlib>
#include <iostream>#include <iomanip>using namespace std;typedef Array<int, 100>   IntArr;typedef Array<double>     DoubleArr;typedef Array<DayTime, 5> DayTimeArr;
int main(){try
{const DoubleArr vd(10, 9.9);
DoubleArr kd;cout << "\nThis is the constant array of doubles: \n";cout << setw(8) << vd;kd = vd;cout <<  "\nAn array of doubles after the assignment: "<< endl;cout << setw(8) << kd;kd.remove(3);          // Delete the element at// position 3.kd.append(10.0);       // Add a new element.
kd.append(20.0);       // And repeat!cout <<  "\nThis is the modified array: "<< endl;cout << setw(8) << kd;
748CHAPTER 32TEMPLATES
IntArr vi;int i;for(i=0; i < 10; i++)vi.append(rand()/100);cout << "\nThis is the array of int values: \n";cout << setw(12) << vi;vi += vi;cout << "\nAnd append: \n";
cout << setw(12) << vi;IntArr ki(vi);cout << "\nThis is the copy of the array: \n";
cout << setw(12) << ki;DayTimeArr vt;    // Array of DayTime objects.DayTime temp;for(i=0; i < 3; i++){if( !(cin >> temp))break;vt.append(temp);}cout << "\nThe array with objects of type DayTime:\n";for(i=0; i < 3; i++)cout << setw(20) << vt[i] << endl;}catch(BadIndex& err)
{cerr << "\nIndex " << err.getBadIndex()<< " invalid";exit(1);}catch(OutOfRange& ){cerr << "\nArray is full!";exit(2);}return 0;}
749ContainersThis chapter describes standard class templates used to represent
containers for more efficient management of object collections.These

includesequences,such as lists and double ended queues
container adapters,such as stacks,queues,and priority queues
associative containers,such as sets and maps,and
bitsets.Besides discussing how to manage containers,we will also be looking at

sample applications,such as bitmaps for raster images,and routing

techniques.chapter
33
750CHAPTER 33CONTAINERS
CONTAINER TYPES
Sequences and associative containers
ArraysStacksQueues
etc.Sets...MapsBitsets
SequencesAssociative
ContainersContainers
CONTAINER TYPES751What is a Container?
Containers are used to store objects of the same type and provide operations with whichthese objects can be managed. These operations include object insertion, deletion, and
retrieval. Memory is allocated for containers dynamically at runtime. Containers thus
provide a safe and easy way to manage collections of objects.The C++ standard library provides various class templates for container managementin the Containers Library. These classes can be categorized as follows:sequential containers,orsequences, where the objects are arranged sequentiallyand access to an object can either be direct or sequentialassociative containers, where the objects are generally organized and managed ina tree structure and can be referenced using keys.SequencesSequential containers are distinguished by the operations defined for them, which areeither generic or restricted. Restricted operations, such as appending at the end of a con-
tainer, have constant runtimes. That is, the runtime is proportional to a fixed period of
time and does not depend on the number of objects in the container.The following are sequential containers:arrays,which provide the same operations as C arrays but increase and decreasein size dynamically, in contrast to C arraysqueues, which are managed on the FIFO (First In First Out) principle. The firstelement to be inserted is also removed firststacks, which are managed on the LIFO (Last In First Out) principle. The lastelement to be inserted is removed first.Associative Containers and Bitsets
Associative containers comprisesets, which allow quick access to objects via sortablekeys, and maps, which maintain efficient object/key pairs.There are also so-called bitsets, which represent bit sequences of a given length andprovide bitwise operators, with which bits can be manipulated.
752CHAPTER 33CONTAINERS
SEQUENCESOperations for sequences
Class TemplateTime needed to insert or
remove  an objectvector<class T, class Allocator           = allocator<T> >At the end: constant.At the beginning or in the
middle: linear.
In all positions: constant.At the beginning or end:constant.
In the middle: linearlist<class T, class Allocator           = allocator<T> >deque<class T, class Allocator           = allocator<T> >Container adaptersClass TemplateInsertionDeletion
stack<class T, class Container        = dequeue<T> >at the endat the end
queue<class T, class Container        = dequeue<T> >at the endat the 
beginningat the beginningpriority_queue<class T,class Container = vector<T>,Compare=less<T> >prioritybasedSequences and header filesContainerHeader File
vector<T, Allocator>list<T, Allocator>
deque<T, Allocator>
stack<T, Container>
queue<T, Container>
priority_queue<T,<vector><list>
<deque>
<stack>
<queue>
<queue>Container, Compare >
SEQUENCES753Representing Sequences
The Containers Library defines so-called container classesrepresenting containers. Theseare class templates parameterized by the type Tof the objects to be managed.Three basic class templates are defined for sequences.The container class vector<T, Allocator>supports standard array opera-tions, such as direct access to individual objects via the subscript operator [],and quick appending and deletion at the end of the container. However, the run-
time for insertion and deletion at the beginning or in the middle of the container
is linear, that is, proportional to the number of objects stored in the container.The container class list<T, Allocator>provides functionality that is typi-cal for double linked lists. This includes quick insertion and deletion at any given
position. General list operations, such as sorting and merging, are also defined.The container class deque<T, Allocator>(double ended queue, pronounced“deck”) provides direct access via a subscript operator, just like a normal array,
but offers optimized insertion and deletion at the beginning and end of the con-
tainer. The same operations in the middle of a container have a linear runtime.The second template parameter is used for any storage allocation to be performed. Thestorage management is represented by a so-called allocator class, which is parameterizedby an object of type T. It enables dynamic memory allocation for objects of type T. Thedefault value of the template parameter is the standard allocator classallocator<T>that uses the newanddeleteoperators to allocate and release memory.Adapter ClassesThe basic sequence classes are used to construct so-called adapter classes. An adapter classexpects a sequence as a template argument and stores the sequence in a protecteddata member.The opposite page shows various adapter classes. The priority_queuetemplaterepresents priority queues. The relationship between the keys used to manage the priori-
ties is defined in the comparator class,Compare. The default value of the templateparameter is the predefined comparator class, less<T>, which uses the lesser than oper-ator<for type T.
754CHAPTER 33CONTAINERS
// Outputs a list containing integers.// ---------------------------------------------------#include <list>
#include <iostream>using namespace std;typedef list<int> INTLIST; // int listint display(const INTLIST& c){int z = 0;                             // Counterlist<int>::const_iterator pos;// Iteratorfor( pos = c.begin(); pos != c.end(); pos++, z++)cout << *pos << endl;cout << endl;return z;}// iterat_t.cpp: Outputs an array of accounts.// ---------------------------------------------------#include <vector>#include <iostream>
using namespace std;#include "account.h"typedef vector<Account> AccVec;// Account vectorvoid display(const AccVec& v){AccVec::const_iterator pos;// Iteratorfor( pos = v.begin(); pos < v.end(); pos++)pos->display();cout << endl;}ITERATORS
Iterating lists
Iterating vectors

ITERATORS755Positioning and Iterating in Containers
Each object in a container occupies the specific position where it was stored. To allowyou to work with the objects in a container, the positions of the objects in the container
must be accessible. There must therefore be at least one mechanism that allows:read and/or write access to the object at any given position andmoving from the position of one object to the position of the next object in the
container.This situation should be familiar from your experience of working with pointers. Giventhatiis the index of an element in an array v,(v+i)is its address, *(v+i)the arrayelement itself, and (v + (++i))the address of the next array element.Iterators were introduced in C++ to provide a uniform model for positioning and iter-ation in containers. An iterator can thus be regarded as an abstraction of a pointer.Iterator Types
Two types of iterators are important in this context:bidirectional iterators, which can be shifted up by the increment operator ++and down with the decrement operator --, and use the operators *and->toprovide write or read access to objectsrandom access iterators, which are bidirectional iterators that can additionallyperform random positioning. The subscript operator []was overloaded for thispurpose, and the operations defined for pointer arithmetic, such as addition/sub-
traction of integers or comparison of iterators, are defined.The container classes vector<T>anddeque<T>have random access iterators and thecontainer class list<T>has bidirectional iterators.Iterator Classes
The types iteratorandconst_iteratorare defined in all the above classes to rep-resent iterators. An iterator belonging to one of these classes can reference constant or
non-constant objects.The methods begin()andend()are also defined. The begin()method accessesthe first position and end()accesses the position afterthe last container object.Containers that belong to adapter classes offer only restricted access to the beginningor end. You cannot use iterators to walk through them.
756CHAPTER 33CONTAINERS
// sortVec.h: The Class Template SortVec representing//            a sorted vector.//---------------------------------------------------
#include <vector>      // For class template vector<T>#include <functional>  // For comparator class less<T>using namespace std;template <class T, class Compare = less<T> >class SortVec : public vector<T>
{public:SortVec()  { }
SortVec(int n, const T& x = T());void insert(const T& obj);     // in sorted orderint  search(const T& obj);
void merge(const SortVec<T>& v);};// sortv_t.cpp :   Tests the template SortVec.//---------------------------------------------------#include "sortVec.h"typedef SortVec<int> IntSortVec;int main(){IntSortVec v, w;             // Default constructorv.insert(2);v.insert(7); v.insert(1);int n = v.search(7);w.insert(3); w.insert(9);v.merge(w);return 0;}// The array v then contains the elements: 1 2 3 7 9DECLARING SEQUENCESThe derived container class 
sortVec<T, Compare> Using the container class sortVec
DECLARING SEQUENCES757Constructors of vector,list,and deque
The container classes vector,list, and dequedefine three constructors and a copyconstructor with which sequences can be created. Their functionality is similar for the
various classes and is discussed in the following section using the vectorclass as anexample.The statementExample:vector<Account> v;declares an empty container vfor objects of the Accounttype. You can then insertindividual objects into the container.However, you can also declare a container and fill it with a predefined number ofobject copies.Example:Fraction x(1, 1);vector<Fraction> cont(100, x);This defines the container contwith 100 Fractiontype objects, and fills it with theobjectx. If the second argument is not supplied, each of the 100 objects is initialized bythe default constructor.Finally, you can initialize a container with a part of another container. To do so, youmust state a range of iterators.Example:vector<double> v(first,last);The arguments firstandlastare iterators in an existing container. The new con-tainer,v,is initialized using objects in the range [first,last): this includes all theobjects between the positions first(includingfirst) and last(excludinglast).Constructors for Adapter Classes
Only a default constructor and the copy constructor are defined for adapter classes.Given that waitis a predefined queue of the container class queue<double>, the fol-lowing statementExample:queue<double> w(wait);creates a new queue, w,and uses the object waitto initialize it.The opposite page shows the derived container class sortVec, which is used to rep-resent sorted, dynamic arrays. The class is parameterized by the type Tof array elements.The second template parameter is a comparator class, which represents a comparison cri-
terion for sorting.
758CHAPTER 33CONTAINERS
MethodEffect
void push_back(const T&x);Addsx at the end of thesequence.Addsx before the firstelement of the sequence.Insertsx after positionposand returns the position ofthe newly inserted element.Insertsn copies of x afterpositionpos and returns thenumber of inserted elements.Inserts all elements fromrange[first,last) afterpositionpos into thesequence.void push_front(const T&x);iterator  insert(iterator   pos,           const T&  x = T() );size_type  insert(iterator  pos,       size_type n, const T& x)void insert(iterator pos,InputIterator firstInputIterator last)// Method insert() adds a new object at the end// of the vector and reorganizes in ascending order.//---------------------------------------------------template <class T, class Compare >
void SortVec<T, Compare>::insert(const T& obj){SortVec::iterator  pos, temp;push_back(obj);               // Add at the end.pos = end();  pos--;          // Last positionwhile (pos-- > begin())       // Sort:{if( obj < *pos)             // Swap:{ temp = pos; *(++temp) = *pos;  *pos = obj; }
else   break;}}INSERTING IN SEQUENCES
Inserting methods
Methodinsert()of the derived container class 
SortVec
INSERTING IN SEQUENCES759Insertion Methods
The following methods are defined in the container classes vector,deque,andlistpush_back()insert at endinsert()insert after a given position.Additionally, the following method is available in the listanddequeclassespush_front()insert at beginning.This method is not defined in the vectorclass.Theinsert()method is overloaded in various versions, allowing you to insert a sin-gle object, multiple copies of an object, or object copies from another container. Given
two containers vandwthe followingExample:w.insert(--w.begin(), v.begin(), v.end());inserts the objects from container vin front of all the other objects in w. A container canof course be assigned to another container of the same type. The assignment operator is
overloaded for containers to allow this operation.Runtime Behavior
Thepush_back()andpush_front()methods are preferable on account of theirconstant runtime. Insertion of oneobject with the insert()method also has a con-stant runtime in the listclass. However, this is linear in the vectoranddequeclasses, that is, the time increases proportionally to the number of objects in the con-
tainer.This dissimilar runtime behavior for methods can be ascribed to the implementationof various container classes. Normally, containers of the listtype are represented bydouble linked lists in which each element possesses a pointer to the preceding and fol-
lowing element. This allows for extremely quick inserting at a given position.The container classes vectoranddequeare represented as arrays. Inserting in themiddle means shifting the objects in the container to make place for the new object.
Therefore the runtime will increase proportionally with the number of objects the con-
tainer holds.Insertion in Adapter Classes
There is only one insertion method for adapter classes: push(). In stacks and queues,push()appends an object with a constant runtime. Insertion of objects into priorityqueues depends on the priority of the object and the runtime is linear.
760CHAPTER 33CONTAINERS
// sortvec.h// Method search() seeks an object objin the vector// using the binary search algorithms:
// The object objis first compared to the element in// the middle of the vector. If objis smaller than the// "middle" element, it must belong to the left half or
// else to the right half of the vector. We repeat this
// process comparing objwith the "middle" element in// the section where it is known to be, repeatedly// halving the size of the interval until the interval// consists of a single point, which is where obj// belongs.
// This algorithm has logarithmic time and thus
// is very fast.
// ----------------------------------------------------
template <class T, class Compare >
int SortVec<T, Compare>::search(const T& obj)
{int first = 0, last = end() - begin() - 1, mid;while( first < last ){mid = (first + last + 1)/ 2;// Search the left half,if( obj < (*this)[mid] )last = mid - 1;else first = mid;        // the right half.}if ( obj == (*this)[first] )  // Found?return first;           // Yes.else  return size();          // Not found.}ACCESSING OBJECTSMethodsearch()of container class sortVec
ACCESSING OBJECTS761Thefront()andback()MethodsAccess to individual objects in the container classes vector,deque, and listcan beperformed by the following methodsfront()for access to the first element andback()for access to the last element.Both methods return a reference to the object in question.Example:double z = v.front();v.front() = 1.9;This saves the first object in container vin the variable zand then overwrites the objectby1.9.Access via IndicesThe subscript operator []is overloaded in the vectoranddequeclasses to permit theuse of indices for access to the objects in a container. An index is a positive integer of
the type size_type.Example:v[20] = 11.2;       // the 21st objectGiven that posis an iterator that references the first object in a container v, the expres-sionv[20]is equivalent to pos[20].When you use the subscript operator, you must ensure that the index does not exceedthe valid range. You can use the access method at()to throw an exception if an indexis out of range.Example:v.at(20) = 11.2;Theat()method throws an exception of the standard error class out_of_rangeif anerror occurs.The subscript operator and the at()method are not defined in the listclass.Before you can manipulate the tenth object in the container, for example, you need to
walk through the container sequentially up to that position.Access to Objects in Adapter Classes
The method top()is defined for access to the element with the highest priority, or theelement at the top of the stack, in the adapter classes priority_queueandstack.Thequeueclass comprises the front()method, which is used to access the firstelement.
762CHAPTER 33CONTAINERS
// sortvec.h:  Method merge() merges the argument vector//             with the vector *this.// ---------------------------------------------------template <class T, class Compare >void SortVec<T,Compare>::merge(const SortVec<T,Compare>& v){SortVec temp;                    // Temporary vector
SortVec::iterator pos = begin(); // Iteratorint n1 = 0, n2 = 0;// Copy the smaller object into vector temp:while(n1 < size() &&  n2 < v.size())if( pos[n1] <= v[n2] )temp.push_back(pos[n1++]);elsetemp.push_back(v[n2++]);// Append the rest:while( n1 < size())temp.push_back(pos[n1++]);while( n2 < v.size())temp.push_back(v[n2++]);*this = temp;}LENGTH AND CAPACITY
Methodmerge()of container class SortVec
LENGTH AND CAPACITY763The identifying features of a container areitslength, that is, the number of objects held in the container, andthecapacity, that is, the maximum number of objects the container can store.The length of a container changes after every insertion or deletion—the capacity doesnot.Length of a ContainerThe length of a container is discovered by a call to the size()method. The methodreturns an integer of the size_typetype.Example:Fraction x(1, 1);vector<Fraction> v(100, x);
vector<Fraction>::size_type sz = v.size();The variable szcontains the value 100in this case.The length of an empty container is always 0. You can also use the empty()methodto discover whether a container is empty. The method returns truein this case.Example:while( !cont.empty() ) ...The methods size()andempty()are defined for all container classes. You can usetheresize()method to change the length of a container.Example:cont.resize( n, x);The length is increased to nprovidedn > size()is true, or decreased for n <size(). If n == size(), nothing happens.If the length is increased, n Ð size()copies of the object xare appended to thecontainer. The second argument, x, can be omitted. In this case, the default constructorfor a type Tobject is called as often as necessary.CapacityThe capacity of a container can be checked using the max_size()method.Example:size_type k = cont.max_size();The return value depends on the amount of memory available and the object size.Only the size()andempty()methods are defined for adapter classes. You cannotdiscover the capacity of an object, nor can you call resize()to change its length.
764CHAPTER 33CONTAINERS
// prior_t.cpp : Testing a priority queue// -------------------------------------------------#include <queue>
#include <string>#include <iostream>using namespace std;class Parcel{private:unsigned int prio;                 // Prioritystring info;public:Parcel(unsigned int p, const string& s):prio(p), info(s) {}// Access methods, ... overloaded operators:friend bool operator<(const Parcel& x,const Parcel& y){ return (x.prio < y.prio); }friend ostream& operator<<(ostream& os,const Parcel& x){ os << x.prio << "  "<<  x.info << endl; return os; }};int main(){priority_queue<Parcel>  pq;pq.push(Parcel(7,"Bob"));// Insertpq.push(Parcel(1,"Peter"));pq.push(Parcel(4,"Susan"));while( !pq.empty() ){cout << pq.top() << endl; // Output
pq.pop();// and delete}return 0;}// Output:    7  Bob//            4  Susan
//            1  PeterDELETING IN SEQUENCESA priority queue
DELETING IN SEQUENCES765Deletion MethodsThe following methods are available for deleting objects in the container classes vec-tor,deque, and list:pop_back()deletes the last object in the containererase()deletes the object at a given position, or deletes all the objects ina given rangeclear()deletes all the objects in a container.The following method is additionally defined in the dequeandlistclasses:pop_front()deletes the first object in the container.The method does not have a return value, just like the pop_back()method.Thepop_back()andpop_front()methods are preferable on account of theirconstant runtimes. Using the erase()method to delete an object at the beginning orin the middle of a container also provides a constant runtime in the container classlist. However, the runtime is linear in the vectoranddequeclasses, since objectsmust be shifted within the container to fill the gap left by the deletion.Deleting Ranges of ObjectsWhen you use the erase()method to delete the objects in a given range, the positionof the first element to be deleted and the position afterthe last object to be deleted arerequired as arguments.Example:cont.erase(cont.begin() + 10, cont.end());This deletes all the remaining objects in the container, starting at position 11. Theerase()method returns the new position of the object immediately after the range ofobjects deleted.Deletion in Adapter Classes
There is only one method of deletion for adapter classes, namely pop(). Given thatwaitis a queue of the queuetype, the following statementExample:wait.pop();deletes the element at the beginning of the queue. In the case of a stack, pop()deletesthe element at the top of the stack, and for priority queues, the object with the highest
priority. The runtime is constant in all cases.
766CHAPTER 33CONTAINERS
// list_t.cpp:  Tests list operations// ----------------------------------------------------
#include <list>
#include <cstdlib>
#include <iostream>using namespace std;typedef list<int>  INTLIST;int display( const INTLIST& c);int main(){INTLIST ls, sls;
int i;
for( i = 1; i <= 3; i++)ls.push_back( rand()%10 );          // ex. 1 7 4ls.push_back(ls.front());             // 1 7 4 1
ls.reverse();                         // 1 4 7 1
ls.sort();                            // 1 1 4 7for( i = 1; i <= 3; i++)sls.push_back( rand()%10 );         // ex. 0 9 4// Insert first object of sls before the last in ls:INTLIST::iterator pos = ls.end();ls.splice(--pos, sls, sls.begin());  // 1 1 4 0 7display(sls);                        // 9 4
ls.sort();                           // 0 1 1 4 7sls.sort();                          // 4 9
ls.merge(sls);                       // 0 1 1 4  4 7 9ls.unique();                         // 0 1 4 7 9return 0;}LIST OPERATIONS
Sample program

LIST OPERATIONS767The container class listcomprises methods for list operations that are not defined inother container classes. These aresorting and inverting listsmerging two sorted listssplicing lists.Sorting,Inverting,and Splicing Lists
A container of the listtype, or list containerfor short, can be sorted by a call tosort(). This assumes that the operator <is defined in class T. A call to sort()sortsthe container in ascending order.You can use the reverse()method to invert a list container, that is, to reverse theorder of the objects in the container. What was originally the first element in the con-
tainer becomes the last, and the second element becomes the second to last, and so on.Themerge()method is used to merge two list containers. Given that ls1andls2are two sorted list containers, the following callExample:ls1.merge(ls2);creates the sorted list ls1, whose objects comprise the original objects of ls1andls2.Thels2container is empty following this operation.Splice Operations
Splice operationsinsert the objects from one list container at a given position in anotherlist container and remove them from the original container. You can transfer either a
whole container or just part of a container.Example:ls1.splice(pos, ls2);This inserts the whole of container ls2in front ofpositionposinls1.ls2is emptiedby this statement. The following statementExample:ls1.splice(pos1, ls2, pos2);Inserts the element at position pos2inls2beforethe element at position pos1inls1and deletes it from ls2. If you want to transfer part of a container, the third and fourtharguments must contain the starting and end position.You cannot use a splice operation to insert at a position before begin()or afterend().
768CHAPTER 33CONTAINERS
Container ClassRepresenting
set< class T,class Compare = less<T>,class Allocator = allocator<T> >collections of objects withunique keysmultiset< class T,class Compare = less<T>,class Allocator = allocator<T> >collections of objects withequivalent keys, i.e.
possibly multiple copies of
the  same key valuemap< class Key, class T,class Compare = less<T>,class Allocator = allocator<T> >collections of objects/keypairs where the keys  are
uniquemultimap< class Key, class T,class Compare = less<T>,class Allocator = allocator<T> >collections of objects/keypairs with possibly
equivalent keysContainer ClassHeader File
set< T, Compare, Allocator >multiset<T, Compare, Allocator  >
map< Key, T, Compare, Allocator >
multimap< Key, T, Compare, Allocator ><set><set>
<map>
<map>ASSOCIATIVE CONTAINERS
Container classesAssociative containers and header files

ASSOCIATIVE CONTAINERS769Sequences store objects in linear order. Searching for a given object will thus require alinear runtime. If you have only a few objects to deal with, this will not cause any signifi-
cant delay. However, it is a major disadvantage in large collections of objects.Representing Sets and Maps
Associative containers with different classes that represent sets and maps allow you opti-mize runtimes. They manage objects in so-called heaps, that is in trees with a minimumheight. Operations are performed by sortable keys. One of the characteristics of a heap is
that the object with the smallest key is always stored at the top of the heap.Insertion, deletion, and search operations in sets and maps can be performed with log-arithmic runtimes. That is, the response is proportional to log(n), where nis the num-ber of objects in a container. Since a logarithmic function grows very slowly, response
will be phenomenally quick.Unique and Ambiguous Keys
In a set, each object contains a key. This is why we refer to embedded keys. The relation-ship between the objects is defined by reference to this key. Besides sets, which have
unique keys, you can also define multisets, where multiple objects can have the same key.Maps are used to manage key/object pairs. In other words, the key is not embedded inthe object but stored separately from it. The type of the key is Key,andTis the objecttype. The relationship between the objects is again defined by the keys.Besides maps, which contain only unique keys, you can also define multimaps, whereseveral objects can exist for a single key.Associative Container Classes
The opposite page shows various classes used to represent sets, multisets, maps, and mul-timaps. The template parameter Compareis a comparator class and Allocatoris anallocator class. Both parameters have default values, which we already saw in the context
of sequences.The methods begin()andend()are defined for access to the positions in all asso-ciative container classes. They return the position of the first element or the position
after the last element.
770CHAPTER 33CONTAINERS
// set_t.cpp:  Tests sets and multisets// ----------------------------------------------------#include <set>
#include <cstdlib>#include <ctime>#include <iostream>using namespace std;typedef set<int> IntSet;// Define type andtypedef IntSet::iterator SetIter; // iterator typetypedef multiset<int> IntMultiSet; // Multiset andtypedef IntMultiSet::iterator MultiSetIter; // iteratorint main(){IntSet  lotto;             // Create a set.SetIter pos;               // Bidirectional iteratorsrand((unsigned) time(NULL));while( lotto.size() < 6)   // Insertlotto.insert( rand()%50 );cout << "These are your lotto numbers: " << endl;for( pos = lotto.begin(); pos != lotto.end(); pos++)cout << *pos << "  ";cout << endl << endl;IntMultiSet  ms;           // Create a multiset.MultiSetIter mpos;         // Bidirectional iteratorfor( int i=0; i < 10; i++) // Insertms.insert( rand()%10 );cout << "And now 10 random numbers "<< " between  0 and 10: " << endl;for( mpos = ms.begin(); mpos != ms.end(); mpos++)cout << *mpos << "  ";cout << endl;return 0;}SETS AND MULTISETS
Sample sets and multisets
SETS AND MULTISETS771Sets and multisets are used for efficient management of object collections with sortablekeys, that is, insertion, deletion, and search operations can be performed with logarith-
mic runtimes. Keys are always parts of objects, thus, keys are data members whose rela-
tionships to one another must be defined in the corresponding class. A lesser than
relationship is normally defined for this purpose, that is, the operator <will be over-loaded for the class.Declaring Sets and MultisetsThe container classes setandmultisethave two constructors each for creating con-tainers. You can use the default constructor to create sets and multisets with a length of0. The second constructor inserts objects from a range of iterators into the new set ormultiset.Example:typedef set<Account> AccountSet;AccountSet mySet(first, last);Here,[first, last)is a range of iterators in an existing container whose objects areofAccounttype.The copy constructor is also defined, and this allows you to use an existing containerof the same type to initialize a new container.Inserting and Deleting
Theinsert()method is available for insertions. This allows for insertion of individualobjects or multiple objects from a given range of iterators.Example:mySet.insert(Account(1234,"May, Tom",100));In contrast to multisets, a new object is only inserted in a set if it does not already exist
in the container.You can use the erase()method to delete objects. To do so, you can either specifythe object itself or its position in the container.Example:mySet.erase(mySet.begin());This deletes the first element in the AccountSetset.You can delete all objects in a container with the following statement:Example:mySet.erase( mySet.begin(), mySet.end() );For erasing a whole container you can also use the clear()method. Calling empty()will tell you whether the container is empty. The size()method returns the number ofobjects in the container.
772CHAPTER 33CONTAINERS
// mulmap_t.cpp:  Testing multimaps// -------------------------------------------
#include <map>
#include <string>
#include <iostream>
using namespace std;typedef multimap<int, string> MULTI_MAP;typedef MULTI_MAP::iterator ITERATOR;int main(){MULTI_MAP  m;// Create a multimap.ITERATOR pos;// Iterator.// To insert:m.insert(pair<int, string>(7, "Bob") );
m.insert(pair<int, string>(3, "Sarah"));
m.insert(pair<int, string>(1, "Diana"));
m.insert(pair<int, string>(1, "Lisa"));cout << "This is the multimap: " << endl;for(pos = m.begin(); pos!= m.end(); pos++)cout << pos->first << "  "<< pos->second << endl;cout << endl;pos = m.find(3);       // Search for the pair// with the given key 3if( pos != m.end())    // and output the pair
cout << pos->first << "  " << pos->second << endl;int key = 1;           // Determine the quantity of// pairs with key value 1:cout << "There are " << m.count(key)<< " pairs with key " << key << endl;return 0;}MAPS AND MULTIMAPS
Using multimaps
MAPS AND MULTIMAPS773Representing Pairs of Keys/Objects
Maps and multimaps store pairs of sorted keys and objects. The key is used again to iden-tify the object but is stored separately from the object. The comparison criterion is
applied to the keys.The C++ Standard Library contains the class template pair<const Key,T>withtwopublicdata members firstandsecond, a default constructor, and a copy con-structor to represent key/object pairs. The first template parameter, Key, is the key typeand the second is the object type T. The data member firstis used to store the keys,andsecondstores the associated object.Given that posis the position of an object in a map or multimap, you can referencethe key with pos->first, and the associated object itself with pos->second.Using Maps and MultimapsThe container classes mapandmultimapcontain constructors with the same function-ality as the setandmultisetclasses. Thus, you can create a container with a lengthof0, or use the objects in an existing container to initialize a new container. The copyconstructor is also defined.The methods insert()for insertion, and erase()andclear()for deletion havethe same interfaces as in the container classes setandmultiset. The methodssize(), which you can use to discover the length of the container, and empty(),which ascertains whether the container is empty, are also defined.Thefind()method is used to look up key/object pairs and expects a key as an argu-ment in the mapandmultimapclasses. Its return value is the associated position in thecontainer. In the case of multimaps where several objects can have the same key, it
returns the first position with that key. If the search fails, the value end()is returned asa pseudo position.You can use the count()method to discover the number of key/object pairs with agiven key in the container. The method expects a key as an argument. The method
returns0or1for maps, depending on whether a pair exists or not. In the case of multi-maps, the return value can be greater than 1, of course.
774CHAPTER 33CONTAINERS
//  bitmap.h : Defines the template Bitmap<N>//             representing raster images.
// -------------------------------------------------
#ifndef _BITMAP_
#define _BITMAP_#include <bitset>#include <stdexcept>using namespace std;template <int N>class Bitmap : public bitset<N>
{private:int lines, cols; // Number of rows and columns
int ax, ay;      // Current cursor positionint ai;          // Current index in the bitsetpublic:Bitmap(int l, int c);void move(int x, int y);
void draw(int x, int y);};template <int N>Bitmap<N>::Bitmap(int l, int c){if (l*c <= N){reset();                  // Set all bits to 0lines = l; cols = c;      // Rows and columnsax = 0; ay = 0; ai = 0;   // Current position}else throw invalid_argument("Invalid argument \n");}template <int N>void Bitmap<N>::move(int x, int y)
{if( x >= 0 && x < lines && y >= 0 && y < cols){   ax = x; ay = y;   ai = x * cols + y;  }
else throw invalid_argument("Invalid argument\n");}// to be continuedBITSETSRepresenting raster images with bitmaps

BITSETS775Declaring BitsetsA bitset stores a bit sequence of a given length. This allows storage of mass bit codeddata, such as raster images, with minimum memory used.The container class bitset<N>provides the functionality needed to manage bitsets.The template parameter Nis the length of bitset, that is the maximum number of bitsstored.You can use the default constructor to create a bitset with no initial values. However,you can also use a given bit-pattern to initialize a bitset. The bit-pattern is either defined
as an unsigned longvalue or as a string.Example:string s = "10101010";bitset<1024> b(s);The string scan contain only the '0'or'1'characters. The last character in the stringwill be the first bit value (that is 0 or 1) at bit position 0, the second to last character in
the string is the bit value at position 1, and so on. The remaining bits are padded with 0up to a length of N. This also applies when an unsigned longvalue is used for initial-ization purposes.Notes on the Sample Program Opposite
The container class Bitmap<N>, which is defined opposite, can be used to representsimple monochrome raster images. A pixel (picture element) is represented by a bit in abitset. If the bit is set, a pixel on screen will be illuminated (white) and otherwise turned
off (black).The number of pixels that can be represented horizontally and vertically is defined bythe resolution. 480 by 800 is a typical screen resolution and 3300 by 2300 is a typical res-
olution for laser printers (at 300 dpi) for an 81⁄211 page size. The value of Nis theproduct of the number of pixels in horizontal and vertical direction.The container class Bitmap<N>is derived from bitset<N>bypublicinheri-tance. Thus, the class comprises a bitset and all the publicbitset management methodsit inherits. Additional data members are used to store the number of rows and columns of
pixels, the current cursor position, and the current bitset index. The move()methodmoves the cursor to the position with the given coordinates. The draw()method drawsa straight line from the current cursor position to the point with the given coordinates.
776CHAPTER 33CONTAINERS
// bitmap.h: In addition the Bresenham algorithm.// ---------------------------------------------------
template <int N>
void Bitmap<N>::draw(int x, int y)
{if( x >= 0 && x < lines && y >= 0 && y < cols){int savex = x, savey = y;if(ax > x) // Draw in ascending x-direction
{          // => possibly swap (ax,ay) and (x,y)int temp = ax; ax = x; x = temp;temp = ay; ay = y; y = temp;}int dx = x - ax, dy = y - ay;int xinc = 1, yinc;      // Incrementif( dy < 0)              // Gradient < 0 ?{ yinc = -1; dy = -dy;}  // Decrement yelse yinc = 1;           // or else increment.int count = dx + dy;   // Number of pixels to be setint d = (dx - dy)/2;   // Measurement of deviation// off the line.while( count-- > 0){ai = ax * cols + ay;   // Index in the bitsetset(ai);               // Set the bitif( d < 0)             // Next pixel in{ ay += yinc;  d += dx; }    // y-directionelse                         // or else in{ ax += xinc;  d  -= dy; }   // x-direction}ax = savex; ay = savey; // Current cursor positionai = ax * cols + ay;    // Current index in bitset}else throw invalid_argument("Invalid argument\n");}
#endifBITSETS (CONTINUED)Bresenham algorithm

BITSETS (CONTINUED)777Manipulating Bits
The container class Bitset<N>provides the get()andset()methods for readingand writing individual bits. These methods expect a bit position as an argument. You can
additionally pass a value of 0or1to the setmethod, which writes this value at the bitposition stated. The default value here is 1.If you call the set()method without any arguments, allthe bits in the bitset are setto 1. In contrast, the reset()method deletes all the bits. Bits can be inverted by a callto the flip()method. Each 0-bit in the bitset is set then to 1and each 1-bit is set to0.Bits at specific coordinates can be referenced by the subscript operator. The index is abit position, that is a number between 0andN-1.As you would expect, bitwise operators can also be used for bit manipulation. The bitoperators&,|, and ^are globally overloaded for bitsets. The operator functions for theNOT operator ~, the shift operators <<and>>, and the operators for compound assign-ments,&=,|=,^=, are implemented as methods of the container class.The Bresenham Algorithm
The opposite page shows the draw()method that draws a line from the current cursorposition pixel by pixel to the given coordinates. The Bresenham algorithm used here
applies incremental techniques. Starting at the current cursor position, it sets the neigh-
boring pixel in the x- or y-direction. To do this, you only need to increment or decre-
ment the x- or y-coordinate by 1. This avoids time consuming floating-point arithmetic,
which would be required to solve a linear equation.To allow drawing to take place along a positive x-axis, the starting and target pointsof the straight line can be swapped. The difference between the y-coordinates of the
starting and target points dy = y - aythen determines whether to increment ordecrement by 1 along the y-direction.Drawing neighboring pixels creates a “staircase” effect, which deviates from thestraight line. The variable d = (dx - dy)/2represents this deviation. If the value ofdis negative, the line is seen to be growing along y-direction and the next pixel is drawnalong the y-direction. Then the deviation is corrected by adding dx. As soon as dbecomes positive, the next pixel is drawn along the x-direction and the deviation is cor-
rected with dy.
exercise
778CHAPTER 33CONTAINERS
9 queues have been created.The queues will now be filledusing the hot potato algorithm.Some elements of randomly selectedqueues are removed.Output the queues:
1.queue: 28  88  70  60   62.queue: 64   6  54   1
3.queue:  2  88  64  30  66  29  11  74  49  41
4.queue: 17  25
5.queue: 96  97  47  27  71  34  87  586.queue: 77  82  547.queue: 35  65  23  40   5  83  92
8.queue: 32  23  54
9.queue: 28  55  54  73  28  82  21  99RouterExits
1. Queue2. Queue3. Queue4. QueueEntranceEXERCISEHot potato algorithm
Test output

EXERCISE779Exercise
In data communications between two remote computers messages are transmitted viamultiple subnets. En route to the target computers, so-called routersstore these messagesin queues before transmitting them towards the target via the next available line. The
routers assume responsibility for route discovery, generally referring to complex address
tables.There are various routing techniques, including a simple algorithm that can do with-out address tables, the so-called Hot Potato Algorithm. The router simply tries to disposeof incoming messages as quickly as possible by sending each incoming message to the
outgoing line with the shortest queue.Define a container class VecQueue<T>, which is parameterized with a messagetypeTto represent this scenario. The class comprises an array of queues of typevector<queue<T>>
and a data member used to store the current number ofqueues in the array.The constructor creates the number of empty queues passed to it as an argumentfor the array. Additionally, you will need to declare the methodssize(),empty(), push() andpop().Overload the size()method in two versions: If no argument has been passedto the method, it returns the current number of messages in all queues. If an argu-
mentiof type inthas been passed, the method returns the current number ofmessages in the i-th queue. Additionally, overload the empty()andempty(int i)methods, which return true, if all queues or the i-th queue areempty.Thepush()method uses the hot potato algorithm to append a message passedto it at the end of the shortest queue. Thepop()andpop(int i)methods are used to simulate the assignment ofmessages to lines, that is retrieval and removal of messages from queues, in this
exercise. The method pop()retrieves the message at the top of a randomlyselected queue and deletes it, returning the message. The method pop(int i)retrieves the message at the top of the i-th queue and deletes it, returning the
message.To test your class, declare a container of the type VecQueue<int>in yourmainfunction. A message is represented by a number. Use a loop to insert ran-dom numbers between 0 and 99 into the container and relay some of them to the
outside lines. Then display the remaining messages on screen, as shown opposite,
by calling the pop(int i)method.
solution
780CHAPTER 33CONTAINERS
Solution// ------------------------------------------------------//vecQueue.h// Defining the Class Template VecQueue<T>
// to represent a vector of queues.
// ------------------------------------------------------
#ifndef _VECQUEUE_H#define _VECQUEUE_H#include <vector>#include <queue>#include <cstdlib>             // For srand(), rand()#include <ctime>               // For time()
using namespace std;template <class T>class VecQueue{private:vector< queue<T> > v;
size_t sz;                 // Number of queuespublic:VecQueue(size_t n);size_t size() const;       // Current number of all// elements.size_t size(int i) const   // Number of elements in
{ return v[i].size(); }    // the i-th queue.bool empty() const      { return size() == 0; }bool empty(int i) const { return size(i) == 0; }void push(const T& a);   // Hot potato algorithmconst T& pop();          // Removes the element at the// beginning of a randomly 
// choosen queue.const T& pop(int i);     // Removes the element at the};                           // beginning of the i-th queuetemplate <class T> VecQueue<T>::VecQueue( size_t n)      // Constructor
{if(n > 0)v.resize(n);sz = n;srand(time(NULL));}
SOLUTION781template <class T>       // Current number of all elements size_t VecQueue<T>::size() const{size_t count = 0;
for( int i=0; i < sz; ++i)count += v[i].size();return count;}template <class T>       // To insert the argument into thevoid VecQueue<T>::push(const T& a)        // shortest queue
{int small = 0;                  // To determine the 
for(int i = 0; i < sz; i++)     // shortest queue.if( v[i].size() < v[small].size())small = i;v[small].push(a);               // and insert there.}template <class T>             // To retrieve and deleteconst T& VecQueue<T>::pop()    // an element in a randomly {                              // choosen queue.static T temp;
int i, i0;i = i0 = rand() % sz;do
{if(!v[i].empty())       // If i-th queue is not empty:{                       // To retrieve and delete thetemp = v[i].front();  // element at the beginning.
v[i].pop();break;}
i = (i+1) % sz;    // Or else: Move to the next queue.}
while( i != i0);return temp;}template <class T>               // To retrieve and delete const T& VecQueue<T>::pop(int i) // an element in the 
{                                // i-th queue.static T temp;if( i >= 0 && i < sz)         // If the index is okay:{                             // To retrieve the elementtemp = v[i].front();      // at the beginning andv[i].pop();               // to delete.}
return temp;}
#endif   // _VECQUEUE_H
782CHAPTER 33CONTAINERS
Solutions (continued)
// ----------------------------------------------------- //hotpot_t.cpp: Simulates the hot potato algorithm //                using a vector of queues.
// ----------------------------------------------------- #include <cstdlib>       // For srand(), rand()#include <ctime>         // For time()#include <iostream>#include <iomanip>
using namespace std;#include ÒvecQueue.hÓ
int main(){const int nQueues = 9;
VecQueue<int> vq(9);          // Vector of 9 queuescout << nQueues << Ò queues have been created.Ó<< endl;srand(time(NULL));cout << Ò\nThe queues will now be filled Ò<< Òusing the hot potato algorithm.Ó
<< endl;int i;for(i = 0; i < 100; i++)      // To insert 100 elementsvq.push(rand()%100);cout << Ò\nSome elements of randomly selected ÒÒqueues are removed.Ó << endl;for(i=0; i < 50; i++)         // To remove 50 elementsvq.pop();cout << Ò\nTo output the queues:Ó << endl;// To retrieve, removefor( i = 0; i < nQueues; ++i)    // and display all
{                                // remaining elements.cout << Ò\nÓ << i+1 << Ò.Queue: Ò;while( vq.size(i) > 0 ){cout << setw(4) << vq.pop(i);}
cout << endl;}return 0;}
783This appendix containsbinary number representation
preprocessor directives
pre-defined standard macros
binding C functionsoperator precedence table
ASCII Code table
screen control characters
appendix
784APPENDIXBINARY NUMBERS
The numbers used by a program can be divided into two groups depending on their type:integersof the char,signed char,unsigned char,short,unsignedshort,int,unsigned int,long,unsignedlong
types andfloating-pointnumbers of the float,double, and longdouble
types.Both integral and floating-point numbers are represented internally as binary numbers,that is, as sequences of 0 and 1 values. However, the formats for representing integral and
floating-point numbers differ. Thus, the bit-pattern of an integer will be interpreted dif-
ferently from that of a floating-point number by the computer.Representing Signed and Unsigned Integers 
The binary format of integers is basically the same for the char,short,int
andlongtypes and differs only in the number of bytes available for each type andwhether the number is interpreted as signed or unsigned. The bit-pattern of a positive integer can be represented as a base 2 power series. The signbit0additionally indicates that the number is positive in the case of signedtypes.The number 4can be represented by the following power series:0*20+ 0*21+ 1*22+ 0*23+ 0*24...The binary representation of the number 4assigned chartype value (8 bits) is thusas follows:Two’s complementis used to represent a negative number, for example -4:11111011
First,one's complement of 4 iscomputed, that is,

all the bits are inverted:
Then the number 
1 is added:Producing the bit pattern of 
–4:00000001
11111100
2625..2221200000000
1Sign bit
You can also use two’s complement to compute the absolute value of a negative num-ber. Two’s complement for -4yields a value of 4.Sign bits are not required for unsignedtypes. The bit can then be used to representfurther positive numbers, doubling the range of positive numbers that can be repre-
sented.The following table contains the binary formats of signed and unsigned integral 8 bitvalues:If the bit-pattern of a negative number is interpreted as an unsignednumber, the valueof the number changes. The bit-pattern1111 1100of the number 4 will thus yieldthe following unsignedvalue:0*20+ 0*21+ 1*22+ 1*23+ 1*24+ 1*25+ 1*26+ 1*27that is, the decimal number 252.Representing Floating-point Numbers
To represent a given floating-point number, x, the number is first broken down into asign,v, a mantissa, m, and a power, exp,with a base of 2:x = v * m * 2exp0000 00000000 0001
0000 0010
0000 00110111 11010111 1110
0111 11111111 11001111 11011111 11101111 11111000 00001000 0001BinarySigned decimalUnsigned decimal
....0123125126127–128–127–4–3–2–1....128129252253254255..01
23125126
127..BINARY NUMBERS785
Memory for the values v,m,and
expis normally assigned in IEEE (Institute of Elec-tronics and Electronical Engineers) format. The type float(32 bit) will thus be organ-ized as follows:In this “normalized” form, floating-point numbers are unambiguous. The mantissa, m, hasa value that is greater than or equal to 1 and less than 2, the only exception being x ==0, where the mantissa is 0.Example:-4.5 =  -1 * 1.125 * 22The first digit of the mantissa is always 1 and need not be stored. The power is storedalong with its bias. A bias of 127applies for floattypes; thus a power eof a floating-point number is represented internally as e + 127.The memory reserved for the mantissa defines the accuracy,and the memory reservedfor the power defines the range of values for the floating-point number. If platform-dependent ranges, such as the length of the mantissa or the smallest orlargest value that can be represented, are significant in your programs, you can discover
these ranges in the cfloatorclimitsheader files. You can use an instantiation of the numeric_limitsclass template for the type inquestion to query platform-dependent ranges by method calls.Bit position(v = signbit)313023220
vexpm
786APPENDIX
PREPROCESSOR DIRECTIVES
The #define Directive
The#definedirective is used to define symbolic constants and macros.Syntax:#define name[(parameterlist)] [SubstituteText]The preprocessor replaces nameorname(parameterlist)withSubstituteTextthroughout the whole program. If SubstituteTextis not stated, the preprocessor willdelete the symbolic constant or macro throughout the program code (see also Chapter 7,
“Symbolic Constants and Macros”.)Example:#define BUFSIZ   512 // Symbolic constant
#define  CLS     cout << "\033[2J"  // Macro 

#define  MAX(a,b)((a)>(b) ? (a):(b))// Macro
The # Operator
A macro parameter in a substitute text can be preceded by the # operator (or stringizingtoken). When the macro is called, the argument is set in quotes, that is, a string constantis formed using the characters of the current argument.Example:#define TITLE(s)  "****  " #s "  *****"The callcout << TITLE(Catalog);causes the preprocessor to expand the following string"****  " "Catalog" "  ****"which is then concatenated to "****  Catalog  ****".The characters "and\are represented by \"and\\within an argument.Example:#define path(logid,subdir) "\\user\\" #logid "\\bin\\" #cmdWith 
path(Smith, games)the string "\user\Smith\bin\games " is produced.The ## Operator
When a macro is defined, character sequences can be concatenated in the substitutetext. The past token operator, ##, is used to this effect. When the macro is called, the parameter preceding or following the ## token isreplaced by the appropriate argument. Then the token and any leading or trailing white-
space character is removed.PREPROCESSOR DIRECTIVES787
Example:#define debug(n) cout << "x" #n "=" << x ## nCallingdebug(1);will generate the statementcout << "x1=" << x1;The arguments of a macro are not parsed for symbolic constants or macros. However, ifthe result of a concatenation is a symbolic constant or a macro, text replacement is again
performed.The #undef Directive
To change the definition of a symbolic constant or a macro at program runtime, you
must first remove the original definition. To do so, the #undefdirective is used.Syntax:#undef nameDo not supply the parameter list for parameterized macros.
You can then use the #definedirective to redefine the macro.Example:#define   BUFSIZE  512.
.
#undef    BUFSIZE
#define   BUFSIZE  1024The #include Directive
The#includedirective copies a file to a program. The #includedirective is replacedby the content of the file.Syntax:#include <filename>#include "filename"If the file name is surrounded by <and>, the file will only be looked up in the directo-ries defined by the environment variable (usually INCLUDE).If the file name is stated in quotes the file will also be looked up in the current direc-tory first.The namefilenamecan include a path. In this case the file is only looked up inthe directory stated.You can also supply the file name as a symbolic constant. The substitute text must bein quotes or square brackets in this case.788APPENDIX
Example:#include <iostream>#include "project.h"
#if VERSION == 1#define MYPROJ_H "version1.h"#else#define MYPROJ_H "version2.h"#endif
#include MYPROJ_HThe #if,#elif,#else,and #endif Directives
You can use the #if,#elif, and #endifdirectives to compile certain parts of a sourcefile and ignore others. The directives are known as conditional compilation directivesforthis reason.Syntax:#if expression1[text1][#elif  expression2text2].
.[#elif  expression(n)text(n)][#elsetext(n+1)]#endifEach#ifdirective must be terminated by an #endifdirective. Multiple #elifdirec-tives can occur in between. The #elsedirective can occur once only.The preprocessor evaluatesexpression1,expression2,...in sequence. Ifan expression that yields “true” is found, that is its value is not 0, the corresponding codefor this expression is processed.If none of these expressions is true, the #elsedirective is executed. If this directive isomitted, no corresponding code is processed.expression1,expression1,...must be constant expressions of integral typesand cannot contain the cast operator. Some compilers do not allow the use of thesizeofoperator.The corresponding text is a source text, that is, it comprises preprocessor directives,C++ statements, or whole C++ programs.When a corresponding text is processed, the preprocessor may first execute directivesbefore passing the expanded source code to the compiler for compilation. Code that the
preprocessor has not processed is removed from the source.PREPROCESSOR DIRECTIVES789
The defined Operator
You can use thedefinedoperator to check whether a symbolic constant or macro hasbeen defined.Syntax:defined(name)The operator returns a value other than0if  valid definition for 
nameexists, and thevalue0in all other cases.A definition created using the #definedirective remains valid until it is removed byan#undefdirective. If the substitute text following namein the #definedirective ismissing, the definition is still valid.Thedefinedoperator is normally used in #ifor#elifdirectives, for exampleExample:#if defined VERSION...Using the definedoperator allows you to use its return value in a preprocessor expres-sion.The #ifdef and #ifndef Directives
You can also perform the same check using the #ifdefand#ifndefdirectives.Syntax:#ifdef   name#ifndef  nameThe #ifdefdirective returns a value other than0ifnameis defined and otherwise 0.In contrast, the #ifndefdirective ensures that a value has not yet been defined, thatis, thatnameis undefined, returning 0ifnamehas been defined, and a non-zero valuein any other case.Example:#if defined(STATE) && defined(COND). . . The #line Directive
The compiler uses line numbers and the name of a source file to display errors discoveredon compilation. You can use the #linedirective to change the line numbers and thefile name.Syntax:#line new_number ["filename"]At this position a new line count begins by new_number. If filenameis stated, it willbecome the new file name that the compiler refers to when issuing error messages.The new file name must be in quotes and new_numbermust be an integral constant.Example:#line 170 "genprog1.cpp"The line number and the file name can also be stated as symbolic constants.790APPENDIX
Example:#if VERSION == 1#define NEWNUMBER 20#else#define NEWNUMBER 25#line NEWNUMBERThe#linedirective is often used by program generators compiling code to produce aC++ program. In the case of error messages, the message can refer to the appropriate line
and file name in the original code.The current line number and file name can be accessed using the standard macros__LINE__and__FILE__.Example:cout << "Current line number: " << __LINE__ << endl
<< "File name: " << __FILE__ << endl;The #error Directive
The#errordirective can be used to show preprocessor errors.Syntax:#error errortext;The message errortextis issued and compilation is terminated.Example:#if defined   VERSION #if VERSION < 3
#error VERSION too old.\n
##error Version 3 or better needed.#endif
#include "version.h"If the symbolic constant VERSIONis defined and the value is less than 3, the followingerror message is output:VERSION too old.Version 3 or better needed.The #pragma Directive
The #pragmadirective is compiler dependentand allows you to define your own pre-processor commands for a specific compiler.Syntax:#pragma commandAny other compiler that supports the #pragmadirective but does not support the com-mand following #pragmasimply ignores the command.Example:#pragma pack(1)This directive causes a Microsoft compiler to align the components of a class bytewise,
avoiding gaps. Other options are pack(2)andpack(4).PREPROCESSOR DIRECTIVES791
PRE-DEFINED STANDARD MACROS
The ANSI standard provides for six pre-defined standard macros. Their names begin andend with two underscores:__LINE__Returns the number of the line containing the __LINE__macro. Thefirst line in a source code is line 1. The numbering can be modified
using the #linedirective.__FILE__Returns the name of the source file that contains the __FILE__macro. The name can be modified using the#linedirective.__DATE__Returns the date in the mmm dd yyyyformat, where mmmis anabbreviation for the month, ddis the day of the month, and yyyyisthe year, resulting in Jul 17 2001, for example.__DATE__refers to the point in time when the preprocessor startedprocessing the source. Thus, the macro returns the same result at any
position in the source code.__TIME__Returns the time as a string in the format hh:mm:ss, where hhrefersto hours, mmto minutes, and ssto seconds, e.g., 15:23:47.__TIME__refers to the point in time when the preprocessor startedprocessing the source. Thus, the macro returns the same result at any
position in the source code.__STDC__Is only defined if the source code contains ANSI keywords only.__cplusplusIs defined if the source code is compiled using a C++ compiler.792APPENDIX
BINDING C FUNCTIONSCalling C Functions in C++ Programs
C functions from C libraries can be called in a C++ program. However, function calls areinterpreted differently by the C++ compiler than you would expect from a C compiler.
You must therefore supply additional binding information that is accessible via anextern"C" 
declaration.Example:extern "C" void oldfunc(int size);This informs the C++ compiler that a C compiler was used to compile the oldfunc()function.If you need to declare multiple C functions, you can declare their prototypes afterextern"C"
within curved brackets. If you have already declared the functions in aheader file, you can include the header file in an extern"C"
block.Example:extern "C"{#include "graphic.h"}It is common practise to declare extern"C"
code in C header files. You can theninclude the C header both in C and in C++ programs.Example:#if defined _cplusplusextern "C"
{
#endif// Prototypes for C functions here#if defined __cplusplus
}
#endifThe symbolic constant __cplusplusis evaluated to discover whether the currentcompiler is a C or C++ compiler. If __cplusplusis defined, that is, a C++ compiler isactive, the extern"C"
block is inserted. Defining C Functions in C++ Programs
It is also possible to define your own C functions for a C++ program. You need to do this
if you call a function that expects a C function as an argument, such as the standardqsort()andbsearch()functions.The definition for a C function in a C++ program must be encased in an extern"C"block. This instructs the compiler to compile the function as a C function.BINDING C FUNCTIONS793
Example:#include <string>#include <iostream>
#include <cstdlib>
using namespace std;static char* city[] = { "Paris", "London", "Barcelona", "Hollywood"}static char* key = "New York";extern "C"int scmp(const void*, const void*);int main(){                          // Sort cities:qsort( city, 4, sizeof(char*), scmp); // Find city:if( bsearch( &key, city, 4,sizeof(char*),scmp) == NULL)cout << "City" << (string) key << "not found.\n";}extern "C"{int scmp(const void *s1, const void *s2)
{return strcmp( *(const char**)s1, *(const char**)s2 );}}The C function scmp()is passed to the standard functions bsearch()for binarysearching and qsort()for sorting using the quick sort algorithm. 794APPENDIX
OPERATORS OVERVIEW
OperatorMeaning
Arithmetical Operators:
Relational Operators:
Logical Operators:
Assignment Operators:
Bit-wise operators:
addition, subtraction
multiplication

division, modulus division
unary plus, minus operator

increment, decrement operator
+*/+++-%---“equal”, “unequal”“less”, “less or equal”

“greater”, “greater or equal”
==<>!=<=>=AND, OR
NOT
&&!||AND, NOT
OR, exclusive-OR

left shift, right shift
&|<<~^>>simple assignmentcompound assignment(op is a binary arithmetical or binary
bit-wise operator)
=op=OPERATORS OVERVIEW795
OPERATORS OVERVIEW (CONTINUED)
OperatorMeaning
Access Operators:Cast Operators:Operators for Storage Allocation
Other Operators:scope resolution operatorsubscript operator
indirection operator
class member access operators
pointer to member operators::[]
*..*->->*C cast operatordynamic cast operator
static cast operator
const cast operator
reinterpret cast operatorconditional expression and commaoperatoraddress-of operator
call to function namecreate a temporary object of typetypesizeof operator (size of type)
typeid operator (type informations)To allocate storage dynamically for
an object, an array resp.To free dynamically allocated storage
for an object, an array resp.(type)dynamic_cast<>
static_cast<>const_cast<>reinterpret_cast<>newdeletenew []   delete []?:&name()type()sizeof()typeid(),796APPENDIX
OPERATOR PRECEDENCE TABLE
OperatorPrecedenceGrouping
1.2.3.4.5.6.7.8.9.10.11.
12.13.
14.15.16.17.from left to rightfrom left to rightfrom left to rightfrom left to rightfrom left to rightfrom left to rightfrom left to rightfrom left to rightfrom left to rightfrom left to rightfrom left to rightfrom left to rightfrom left to rightfrom left to rightfrom right to leftfrom right to leftfrom right to left::!.**>><==^|||!=<=>>=
<</%->*~.->[]
++("postfix")+ ("unary")+ ("binary") - ("binary")& ("bit-wise AND")
&&?:=%=+=-=*=/=
&=,^=|=<<=>>=
-  (  "unary")++ ("prefix")-  (  "prefix")& ("address")*  (  "indirection")––("postfix")
name()typeid()type()
dynamic_cast<>static_cast<>const_cast<>
reinterpret_cast<>new  new[]  delete  delete[](type)    sizeof()OPERATOR PRECEDENCE TABLE797
ASCII CODE TABLE
decimaloctalhexcharacterdecimaloctalhexcharacter
01
2
3
4
5
6
7
8
9101112
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
313233
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
632021
22
23
24
25
26
27
28
292A
2B2C
2D2E2F30
31
32
33
34
35
36
37
38
393A
3B3C
3D3E3F(BLANK)!"#
$%&'(
)*+,-.
/0
1
2
3
4
5
6
7
8
9:;<
=
>?040041
042
043
044
045
046
047
050
051
052
053
054
055
056
057
060
061
062
063
064
065
066
067
070
071
072
073
074
075
076
077 000001
002
003
004
005
006
007
010011
012
013
014
015
016
017
020
021
022
023
024
025
026
027
030
031
032
033
034
035
036
037 0001
02
03
04
05
06
07
08
09A
BC
DEF101112
13
14
15
16
17
18
191A
1B1C
1D1E1F(NUL)(SOH)(STX)
(ETX)(EOT)(ENQ)(ACK)(BEL)(BS)(HT)(LF)(VT)(FF)(CR)(SO)(SI)(DLE)(DC1)
(DC2)
(DC3)
(DC4)
(DC5)(SYN)(ETB)(CAN)(EM)(SUB)
(ESC)(FS)(GS)(RS)
(US)798APPENDIX
ASCII CODE TABLE (CONTINUED)
decimaloctalhexcharacterdecimaloctalhexcharacter
6465
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
959697
98
99100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
1276061
62
63
64
65
66
67
68
696A
6B6C
6D6E6F70
71
72
73
74
75
76
77
78
797A
7B7C
7D7E7F`a
bcd
efg
hi
jklmn
o
p
qrstuvwx
y
z{|}~(DEL)140141
142
143
144
145
146
147
150
151
152
153
154
155
156
157
160
161
162
163
164
165
166
167
170
171
172
173
174
175
176
177 100101
102
103
104
105
106
107
110
111
112
113
114
115
116
117
120
121
122
123
124
125
126
127
130
131
132
133
134
135
136
137 4041
42
43
44
45
46
47
48
494A
4B4C
4D4E4F50
51
52
53
54
55
56
57
58
595A
5B5C
5D5E5F@A
BC
DEFGHIJKLMNOPQRSTUVWX
YZ[
\
]^_ASCII CODE TABLE799
SCREEN CONTROL SEQUENCESThe following escape sequences reflect the ANSI standard for screen control. Replacethe#sign by the appropriate decimal number in all cases.ESC[#ACursor # lines upESC[#BCursor # lines downESC[#CCursor # characters rightESC[#DCursor # characters leftESC[z,sHor ESC[z;sfPut cursor in linezand column sESC[sSave cursor position ESC[uLoad saved cursor position ESC[#K# = 0: Delete from cursor position to line end# = 1:Delete from start of line to cursor position
# = 2: Delete whole lineESC[2JClear screenESC[#(;#...)opm# = 0: all attributes normal# = 1: switch double intensity on
# = 4: Underline on (monochrome screens)
# = 5: Blink on
# = 7: Inverse on
# = 3x: Foreground color# = 4x: Background colorx = 0: blackx = 4: blue

x = 1: redx = 5: magenta

x = 2: greenx = 6: cyan

x = 3: yellowx = 7:white
ESC[c1;c2pChange key assignments: The key with decimal code c1willthen return code c2.To enable these escape sequences, you must first load an appropriate screen devicedriver. To do so for Windows 9x, place the following line in your CONFIG.SYS fileDEVICE = C:\Windows\Command\Ansi.sys
Win NT and Win 2000 do not supply the ANSI screen control characters. Correspond-ing functions based on system calls are offered for download.800APPENDIX
LITERATURE
International Standard ISO/IEC 14882, Programming Languages—C++; published byAmerican National Standards Institute, New York NY, 1998.International Standard ISO/IEC 9899:1999(E), Programming Languages—C; published byISO Copyright Office, Case postale 56, CH-1211, Geneva 20, 1999.Stroustrup, Bjarne, The C++ Programming Language,Addison Wesley, 2000.Josuttis, Nicolai, The C++ Standard Library,Addison Wesley, 1999.LITERATURE801
This page intentionally left blank 
803Note: Italicized page locators indicate figures.index
Symbols&, 223, 231, 691&&, 91+, 50, 82, 85, 157++, 85, 355-, 82--, 85, 355, 420, 755*, 82, 233, 255, 355, 691, 755/, 82%, 82->, 255, 755=, 87+=, 50, 87-=, 87, 355*=, 87, 157/=, 87%=, 87==, 88, 159!=, 88, 159<, 88, 159<=, 88, 159>, 88, 159>=, 88, 159<<, 9, 88, 229, 429>>, 44, 229, 429::, 209?:, 109[], 691, 755//, 91/, 707+-, 355Ô\nÕ, 51, 187(), 691AAbstract classes, 565-585concrete classes versus, 569deriving, 569
and inhomogeneous lists, 574,575-577pointers and references to, 570pure virtual methods for, 566virtual assignment in, 572, 573
Abstraction, 245Access methods, 274, 275AccFileclass,656append()method of, 650, 651Accountclass, 267, 392, 393access methods for, 274with constructors, 266defining,648methods of, 248read-only methods in, 276sample class, 272Account management index file, 655accPtrarraypointers in, 364accSort()function,682, 683Accuracy, 21, 786
Adapter classes, 753access to objects in, 761
constructors for, 757
deletion in, 765
insertion in, 759Addition, 82, 353, 417
Addresses, array, 351
Address operator, 231, 412
Address space, hash file, 658
Algorithm librarywithin C++ standard library, 723Alignmentand fill characters, 67
setting, 67Ambiguity, 591
Ambiguous keys, 769
American National Standards Institute (ANSI), 3Ampersand character, 223, 231, 691
Analysis, 245ANDoperator, 91Angled bracketsand header files, 47
template arguments stated in, 737Appendingin arrays, 485
at end-of-file, 639
list elements, 465, 467append()method, 333, 481, 485, 655for class AccFile,650Applicationsdynamic matrices, 694, 695index files, 652, 653inhomogeneous lists, 574-575area()functiondefining and calling, 176, 177Argument pointer, 685
Arguments, 43access to, 685
arrays as, 356command line, 366, 367functions without, 45
macros called with, 123
objects as, 235
objects passed as, 282passing,178pointer arrays as, 683
pointers as, 235
template,730, 731variable number of, 684, 685, 686argvarrayin memory, 366Arithmetic operators, 20, 412binary,8283precedence of, 84unary,84, 85Arithmetic shifts, 709
Arithmetic type conversionsand precedence, 707Arithmetic types, 20, 21in assignments, 145arrarrayin memory, 322Array elements, 323addressing, 353
arrays as, 331
index for, 323
pointers interrelated with, 352Arraysappending/deleting in, 485
as arguments, 356as array elements, 331classFloatArr, 427class representing, 426, 427defining,322, 323dynamic, 461804INDEX
dynamic storage allocation for, 460, 461encapsulating, 333
initializing,324, 325length of, 357
member,332multidimensional,330, 331name and address of, 351
parameters declared as, 357
of pointers, 364pointers moved in, 355
and pointer variables, 351
sample program, 350,352as sequential containers, 751
subscript operator for, 427Arrow operator, 255Articleclass, 287, 311copy constructor of, 310ASCII code (American Standard Code for Informa-tion Interchange), 17, 800Assignment operator, 87, 253, 412overloading, 489Assignments, 279, 488, 489implicit type conversions in, 145, 531
type conversions in, 145, 532, 533virtual,572, 573. See alsoCompound assignmentsAssociative arrays, 427
Associative container classes, 769
Associative containers, 750, 751, 768, 769and bitsets, 751ATM (Asynchronous Transfer Mode) cellsheader of, 714, 715representing,714at()method, 165, 761autokeyword, 205Automatic lifetime, 199
auto objects, 205autospecifier,204Bback()methodand container classes vector, deque, and list, 761Backslashes, 29bad_cast, 553badbit, 645Base classes, 383, 501accessibility of, 589access to members in, 503, 509calling methods in, 513
conversions in references to, 535
converting to, 530, 531multiple indirect, 590, 591virtual,592, 593with virtual destructors, 548, 549Base class object assignment, 533
Base class pointer conversion, 535BaseE1class, 575defining,574Base initializers, 511, 595, 597, 655
Base subobject, 505begin()method, 755, 769Bell Laboratories, 3
Bias, 786
Bidirectional iterators, 755
Binary arithmetic operators, 82, 83Binary bitwise operators, 713
Binary complement, 143
Binary modefile opened in, 638Binary operator, 415, 417and operands, 82Binary search algorithm, 643
Binary trees, 187
Binding, 551
Bit coded data, 707
Bit-fields,714defining, 715Bitmapcontainer class, 774, 775Bitmapsraster images represented with, 774, 775Bit masks, 710, 711creating, 713
using,712Bit patternsretaining, 143Bitsdeleting, 711manipulating, 777Bitsets,774, 775, 776, 777associative containers and, 751
declaring, 775BitwiseANDoperator, 711Bitwise exclusive ORoperator, 711INDEX805
Bitwise operators, 412,706, 707, 751for bit manipulation, 777
in compound assignments, 713
for creating bit masks, 713BitwiseORoperator, 711Bitwise shift operators, 707, 708, 709Blocks, building, 97
Block scopeobject defined with, 199Boolean constants, 23
Boolean operator precedence, 91
Boolean values, 17output of, 68, 69, 71types for, 16booltype, 17, 23, 91Bracesand functions without arguments, 45
and variables, 33Bracketsand parameters for macros, 123
in syntax descriptions, 612Branches, 125breakstatement, 113sample program containing, 112Bresenham algorithm, 776, 777Bubble sort algorithm, 334Built-in types, 17CCprogramming language, 3, 49, 51
standard library header files, 48C++characteristics of, 2, 3conventions in, 31
developing/translating programs in, 6, 7historical perspective on, 3
keywords in, 30programming language, 3
sample program, 8,18standard library, 7, 9, 48, 173, 723, 751, 753, 773calc()function,618, 619Calling environment, 611
Capacities, 5, 763capital()functiondefining, 182Carclass,504accessing members of, 506virtual method table for, 550Case conversionand macros, 129Case labels, 111
Casting, 147Castleclass,514, 515Cast operator, 147catchblock, 615nested,616, 617syntax of, 612, 613Catching exceptions, 614cctypeheader file, 129Cell base classand derived classes, 574cerrstream, 58, 59cfloatheader file, 21Character by character string comparison, 159
Character codes, 17, 69
Character constants, 23, 25examples for, 24Character manipulationstandard macros for, 128Characters, 17output of, 68, 69reading and writing, 75
testing, 129
types for, 16Character set, 17chararrays, 327CHAR_MAX, 19CHAR_MIN, 19charpointers, 351array of, 367
sample function, 364chartype, 17, 19, 25, 112charvectors, 327cin, 429cinstream, 47, 49, 58, 61Class arraysdeclaring, 329
sample program, 328Class(es), 5, 245abstract, 565-585
adapter, 753806INDEX
associative container, 769base, 501
container, 753
defining,246, 247derived, 501
dynamic members of, 479, 480dynamic storage allocation for, 458example of, 246exception, 611
friend,424, 425and friend functions, 423
and global functions, 51
I/O stream, 59
iterator, 755
multiply-derived,588, 589naming, 247
operators for, 413. See alsoAbstract classes;Adapter classes; Base classes; Derived classes;
Type conversion for classesclasskeyword, 247, 257Class member access operator, 253
Class-specific constants, 309
Class template, 723defining, 725
for sequences, 753clear()method, 70, 645for deleting objects in container classes, 765
for erasing containers, 771
and maps/multimaps, 773Client class, 303climitsheader file, 19clogstream, 58, 59close()method, 389Closing files, 388, 389CLS macro, 123cmathheader file, 41Collision resolution, 658
Collisions, 658
Colonsafter labels, 113Command line arguments, 367sample program, 366Comma operator, 412syntax for, 101Commasfor separating member initializers, 301CommentsC++ program with, 10examples of, 11Comparative operators, 88, 159, 355
Comparator class, 753compare()function, 689Comparisonsresults of, 89, 159, 355Compiler, 7
Complex declarations, 690operators and, 691
rules for evaluating, 691complexheader file, 48Compound assignments, 145bitwise operators in, 713
demonstration of, 86operators, 87Compound conditions, 91
Concatenation operators, 50, 157
Concrete classesabstract classes versus, 569Conditional expressions, 109compilation, 790
structogram for, 108Conditional inclusion, 126, 127Conditional operator precedence, 109conio.hheader file, 132Constants, 23, 25class-specific, 309const_iteratortype, 755constkeyword, 34, 36, 64, 223constmember object declaration, 303Constobjects/methodsaccessing,276, 277pointers to, 361Constructor calls, 594, 595and initialization, 595
sample program, 268in virtual base classes, 597Constructors, 251, 465Accountclass with, 266for adapter classes, 757
calling, 269, 299
conversion,442, 443copy, 279
declaring, 267INDEX807
Constructors(continued)default, 269, 279
defining,266, 267initializing, 269
with inline definitions, 273
task of, 267
of vector, list, and deque, 757. See alsoDestructorsContainer adapters, 752Container classes, 753, 768deleting objects in, 765Containers, 749-782description of, 751
length and capacity of, 763
positioning and iterating in, 755
types of, 750, 751Containers Library, 751, 753
Contiguous memory space, 323continuestatement, 113Control, 28
Controlling expression, 97ControlPointclass,424, 425Conversion constructors, 442, 443Conversion functions, 443conversion constructor versus, 445defining, 445“Cooked mode,” 386
Copy constructor, 279effect of standard, 486forFloatArrclass,486, 487proprietary version of, 487cos()function, 40Counterinitializing, 99count()methodand maps/multimaps, 773count variable, 643cout, 9, 30, 32coutstream, 47, 49, 58, 61Coworker class, 566, 567assignment for, 572, 573CPU registers, 205cstdlibheader file, 45C stringsinitializing,326specializing function template for, 732and string class, 327ctime()function, 167ctype.hheader file, 48Current file position, 381currentTime()global function, 284, 285DDataabstraction, 3, 245, 501
bit coding, 707
class-specific, 305
encapsulation, 3, 245, 273
structures, 463Data blockstransferring, 391Data handlingwith traditional procedural programming, 5Data members, 51, 245and methods, 505
static,304, 305Dateclass methods, 288Daytimeclass operators, 414DayTimesample class, 280Debuggers, 7
DEC Alpha workstationsand bit-fields, 715Decimal constant, 23
Decimalsfloating-point numbers represented as, 25Declarations, 41within header files, 47Declaring sequences, 756, 757decmanipulator, 63, 73Decrement operator, 85and bidirectional iterators, 755Default arguments, 182, 183defining,182, 183rules for and setting of, 735
of templates, 734, 735defaultconstructors, 269, 279, 299, 461Default destructors, 271defaultlabel, 111Default settings, for flags, 61
#definedirective, 121, 127enumconstants contrasted with, 309working with, 124, 125deleteoperator, 455, 456, 457, 459808INDEX
delete[]operator, 461, 483Deletingin arrays, 485
list elements, 465, 467
objects in container classes, 765
in sequences, 764, 765depAccclassread()andwrite()methods of, 648, 649dequecontainer class, 755, 765constructors of, 757Derived classes, 501, 505constructing/destroying,510, 511defining,502members of, 504standard assignment of, 573Derived class object assignment, 533DerivedE1class, 575defining,574Derived type, 323
Destructors, 251, 465, 483, 655calling, 271, 549
declaring, 271
default, 271
defined, 271
with inline definitions, 273
in Matrix class, 695
sample program, 270.See alsoConstructorsDirect base class, 503
Direct derivation, 502displayError() function, 365display()function, 227display()method, 247, 253, 509calling,546, 547new version of, 508Division, 82
Dot operators, 253
Double ended queue, 753
Double quotesand header files, 47
string constant within, 25doubletype, 21, 25do-whileloop, 97syntax for, 103do-whilestatementstructogram for, 102Downcasting,536, 537safety issues in, 537, 553draw()methodandBitmapcontainer class, 775and Bresenham algorithm, 777Dynamically allocated objectsdestroying,548, 549Dynamic arrays, 461
Dynamic binding, 551
Dynamic casting, 537dynamic_castoperator, 553Dynamic castsusing,552Dynamic data structures, 463
Dynamic matrices, 694, 695Dynamic members, 477-498classes with, 480description of, 479
objects created with, 480of varying length, 478Dynamic memory allocation, 453-475for containers, 751Dynamic storage allocationfor arrays, 460, 461for classes, 458EEarly binding, 551Elementary operations, 463
Element functionsfor output in fields, 66elsebranch, 105, 107Else-ifchainsstructogram for, 106switchstatement contrasted with, 111Embedded keys, 769Employeeclass,570assignment for, 572, 573Empty lists, 465, 577empty()method, 771and container classes, 763Empty statements, 99
Empty strings, 25
Encapsulation, 3, 245, 257of arrays, 333
and static data members, 307INDEX809
end()method, 755and associative container classes, 769endlmanipulator, 9, 61Enumerationdefinition, 309
sample program, 308enumkeyword, 309eofbit, 387Equals signand initialization, 33erase()method, 161, 771for deleting objects in container classes, 765errno.hheader file, 48Error classesdefining,618, 619Error conditionbacking out of, 615Error handling, 387and exception hierarchies, 619
for new handler, 457
traditional,608, 609Errorsavoiding, 723
common causes of, 609
input, 73
messages, 7, 43
parity bit computation and recognition of, 713
runtime, 267
templates checked for, 727Escape sequences, 26, 28, 29, 123decimal values and effects, 28Euroclass,416, 417, 418converting constructors of, 442converting function for, 444explicit type conversion for, 446expressions valid for operators in, 419
with friend functions, 422new,420testing conversions of, 444Exception classes, 611defining,646standard,620, 621Exception class members, 619
Exception declaration, 613
Exception handlers, 612, 613searching for, 615Exception handling, 3, 607-635concept behind, 611
description of, 613
for files, 646implementing own, 647
nesting, 616-617Exception hierarchies, 619
Exceptions, 165catching,614re-throwing, 617
throwing, 611, 614, 651exceptions()method, 647Exception specification list, 617exchange()template function, 727Executable file, 7
Exit code, 9exit()function, 389exp()function, 40Explicit cast constructions, 537
Explicit initialization, 329of objects, 459Explicit inline methods, 273
Explicit instantiationof templates, 736, 737syntax for, 737Explicit type conversion, 147, 443, 536, 537for Euro class, 446testing,446explicitkeyword, 447Exponential notation, 25, 65
Expressions, 83evaluating, 97
with reference type, 228, 229in switch statement, 111Extended codes, 687
External functions, 207
External static object, 203externstorage class, 200, 201, 207extern “c”, 795Ffailbitstate flag, of iosbase class, 387fail()method, 387falsekeyword, 23Fibonacci numbers, 325
Fibonacci quotients, 325810INDEX
Fieldsinput, 71
output,66Field widthdefining, 63
specifying, 67File accessmode, 385
stream classes for, 382File managementand file buffer, 381File operations, 380, 381Files, 381buffers, 381
closing,388, 389default settings for opening, 386
determining positions in, 643
error handling when opening, 387
exception handling for, 646extensions, 7
names, 385
opening/closing, 383, 385, 387, 638open mode of, 386positioning for random access, 640, 641, 642, 643.See alsoHeader files; RecordsFile scopeobject defined with, 199File state, 644, 645File stream classes, 382, 383functionality of, 383
iniostreamlibrary, 383File streams, 383definition, 385
sample program/creating, 384Fill-charactersspecifying for field, 67fill()method, 67Filter programsusing, 131Filters, 131find()method, 163and maps/multimaps, 773fixedmanipulator, 65Fixed point output, 65
Flags,60for open mode of file, 386open mode, 387positioning, 641
state, 645, 647FloatArrclass,740constructors in, 483
copy constructor for, 486, 487data members of, 478new declarations in, 488new methods of, 490, 491prototype of operator function for, 489
versions of, 479, 480, 481, 484, 485Floating-point constants, 25examples for, 24Floating-point division, 413
Floating-point numbers, 17, 21, 25formatted output of, 64inputting, 73Floating-point types, 20, 21conversion of, to integral type, 145
conversion of, to larger floating-point type, 143
conversion of, to smaller type, 145Floating-point valuestypes for, 16floattype, 21, 25, 331forloopssyntax for, 99Formatting, 61options, 63
standard settings, 65Formatting flags, 61
Formatting operator, 63, 67forstatement, 97sample program, 100structogram for, 98Fractionclass, 431simplify()method of, 448Fractionscalculating with, 430Friend classes, 424, 425declaring, 425
using, 425Friend declaration, 423
Friend functions, 422, 423declaring, 423
overloading operators with, 423
using, 425INDEX811
friendkeyword, 423front()method, 761and container classes vector, deque, and list, 761fstreamclass, 383, 387Function blocks, 175
Function call operator, 420Function callsdefined, 43
implicit type conversions in, 147, 531
sample program, 42Function prototype, 11, 41example of, 40Functions, 171-195C++ program with, 10calling and called, 178conversion of, 443
declaring, 40-41, 175, 177
default arguments defined for, 182, 183defining,174error checking after leaving, 608external, 207
general form of, 174, 175hash, 658
inline,180, 181libraries, 173
and macros, 125
operator,414, 415, 416overloading,184, 185and passing by value, 179
pointers to, 688, 689pointer versions of, 358, 359recursive,186, 187return value of, 176sample, 205
scheme of, with varying arguments, 684signatures, 185
significance of, in C++, 172static, 207
virtual operator, 573
without arguments, 45
without return value, 45Function templates, 723ANSI instantiation of, 737
defining, 725
explicit instantiation of, 737
passing arguments to, 730, 731Fundamental types, 16, 17, 18,20example with, 303
operators for, 82-90Gget()function, 75getch()function, 132, 687getline()function, 51, 155getline()method, 75, 391get()method, 75, 391getPassword()function, 203, 207get pointer, 643getput()function, 187get/put pointer, 639getTypeid()method, 651Global arrays, 325
Global functions, 9, 51from C++ standard library, 173
methodsversus, 283programming, 175Global objects, 199defining, 201
using, 201Global operator functions, 420, 421defining, 421Global variables, 33, 34gotostatement, 113Graphical user interfaces, 7, 173H“Has-A” relationship, 299
Hash files, 658-659
Hash function, 658
Hashing, 325
Hash key, 658
Hash tables, 641
has relationship, 501
Header files, 7, 9, 41, 249and associative containers, 768and macros, 125multiple inclusions of, 126searching for, 47
and sequences, 752standard,48standard class definitions in, 47
using,46, 47812INDEX
Heap,454, 455, 769Hexadecimal constant, 23
Hexadecimalsdisplaying, 63
outputting, 63hexmanipulator, 63, 73Hot potato algorithm, 778, 779IIdentical types, 323Identifiers, 31declaring, 41
read-only, 223IEEE.SeeInstitute of Electrical and Electronic Engi-neers#ifdefdirective, 127if-elsestatementstructogram for, 104syntax for, 105#ifndefdirective, 127ifstatementsvariables defined in, 105ifstreamclass, 383Implicit conversion, 531example for, 530Implicit inline methods, 273
Implicit instantiation, 737of template class, 727Implicit type conversions, 140, 141, 441, 443in assignments, 144
avoiding, 447
to base class type, 531
in function calls, 147#includedirective, 47Include files, 7
include folder, 47income()method, 567, 569inconstant, 309Increment operator, 85and bidirectional iterators, 755Indefinite recursion, 509
Indentation, 11
Index entries, 643representing,642IndexEntryclass,642, 643Indexes, 165, 323, 643, 653, 655access via, 761for array elements, 323
and bit manipulation, 777
invalid, 165
representing,644Index file, 653implementing,654, 655IndexFileclass,656constructor of, 644defined,644, 645insert()method of, 652, 653IndexFileSystemclassinsert()andretrieve()methods of, 654,655Index versionsof functions, 358, 359Indirect base class, 503
Indirect derivation, 502Indirection operator, 232, 233, 355Infinite loops, 101
Inheritance, 3, 59, 499-528data abstraction and reusability, 501
derived classes, 502is relation, 500, 501member access, 506-507
protected members, 514, 515redefining members, 508, 509. See alsoMultipleinheritanceInheritance graphbuilding,594, 595InhomListclasscomplete,578defining,576, 577Inhomogeneous listsapplication with, 574implementing,576terminology for, 575init()call, 253Initialization, 33and constructor calls, 595
of constructors, 269
explicit, 329
of member objects, 301
of objects, 251, 279, 455
references, 223
for virtual base classes, 596, 597INDEX813
Initialization list, 325, 329and arrays of pointers, 365init()method, 247, 267Inline functions, 125, 180, 181definition of, 181
global, 273
and macros, 181, 183inline keyword, 181
Inline methods, 272, 273Inputerrors, 73
fields, 71
formatted,70formatted, for numbers, 72redirecting standard, 130, 131stream classes for, 58streams, 9input()function,686, 687insertAfter()method, 577Insertion methodsin sequences, 758in vector, deque, and list container classes, 759Insertion sort algorithm, 738insert()method, 161, 485, 771of class IndexFile,652, 653of class IndexFileSystem,654, 655and maps/multimaps, 773
ofSortVecderived container class, 758Instances, class, 51, 251
Instantiationand template definition, 723
of template functions, 733
of templates, 726, 727Institute of Electrical and Electronic Engineers, 20
Integer promotions, 140, 141Integers, 17computing parity of, 712formatted output of, 62inputting, 73
types for, 16Integer types, 21
Integral constants, 23examples for, 22Integral numbersdisplaying, 63Integral promotion, 709Integral types, 18, 19conversion of, to floating-point type, 143
conversion of, to smaller type, 145
and operands for bitwise operators, 707Integrated software development environment, 7internalmanipulator, 67Internal static object, 203
International Organization for Standardization, 3
Interpolation search, 738INT_MAX, 19INT_MIN, 19inttype, 19, 23Invalid indexes, 427invalid_argumentclass, 620I/O (input/output)formatted/unformatted,74, 75, 391overloading shift operators for, 428redirecting,130, 131iomanipheader file, 48, 65, 66iosbaseclassflags defined in, 386ios::boolalphaflag, 69iosclass, 59ios::seekdirtype positioning flags, 641iostreamclass, 59iostreamheader file, 9iostreamlibrary, 59file stream classes in, 383isLess()method,282islower(c)macro, 129ISO.SeeInternational Organization for Standardiza-tionis_open()method, 389is relationship, 500, 535, 589istreamclass, 47, 59, 61Iterating lists, 754Iterator classes, 755
Iterators,754types of, 755JJump table, 688, 689Kkbhit()function, 132814INDEX
Keysand adapter classes, 753
and associative containers, 751
hash, 658
representing pairs of, 773
and sets and multisets, 771
unique and ambiguous, 769Keyword, 29LLabelsandgotostatement, 113Laborerclass, 568standard assignment for, 573Layoutand program flow, 107
of source files, 11Left shift operators, 708, 709leftmanipulator, 66Legibility, 11
Length, of container, 763length_error(*)class, 620length()method, 51, 481Less-than symbols, 9
Librariesfunctions in, 173Lifetimeobject, 199
static, 203LIFO (last-in-first-out) principle, 179, 725, 751Lightsclass, 309limitsheader file, 48Linear solution, 658
Line feed, 187line()function, 11Linked lists, 462, 463advantages with, 463
defining, 463
representing,464Linker, 7Listclassclass definition for, 464, 465new methods of, 490, 491listcontainer class, 767constructors of, 757
methods for deleting objects in, 765List elementsappending/deleting,462, 465, 467inserting in middle of inhomogeneous list, 576inserting new, 577
representing, 465, 575List operations sample program, 766Listsrepresenting, 465
sorting, inverting, and splicing, 767Literals, 23
Local objects, 179, 199
Local variables, 33, 34
LOCATE macro, 123
Logarithmic runtimes, 769
Logical bitwise operators, 707
Logical expressionsexamples for, 90Logical operators, 90, 141, 412Logical shifts, 709logic_errorexception classes derived from, 620, 621longdouble
type, 21, 25longtype, 19Loop body, 97
Loops, 97
l-value, 233, 421MMacro definitionvisibility for, 125Macroscalling with arguments, 123
and case conversion, 129
for character manipulation/classification, 128defining, 121
in different source files, 124within header files, 47
and inline functions, 181, 183
redefining, 127
sample program, 120for screen control, 123, 125Macros with parameters sample program, 122main()function, 9, 11, 173, 175parameters of, 367
structure of, 8MAKE utility, for module management, 173INDEX815
Manipulators, 61calling,60floating-point numbers formatting, 64
and integers formatting, 62for output in fields, 66Mapsand associative containers, 751
representing, 769
using, 773Masks, bit, 710, 711Mathematical rulesand expressions, 83Mathematical standard functions, 40MathErrorexception class, 619math.hheader file, 190Matrix, 331
Matrix class, 695constructor, destructor, and subscript operator for,695Member arrays, 332Member functions, 9, 51, 245
Member initializers, 300, 301Member objects, 298, 299constant,302, 303initializing, 301Members, 247redefining,508, 509Member sub-object, 299
Memoryallocating, 249
objects in, 251
releasing, 459
union and usage of, 259Memory addressfor object of class, 255merge()methodfor merging list containers, 767
ofSortVeccontainer class, 762message()function, 227Methods, 51, 245calling, 51
of class template, 725
const and non-const versions of, 277, 279
and data members, 505
defining,248, 249global functions versus, 283name lookup for, 507operator functions as, 415
operators overloadable by, 420positioning, 643
pure virtual, 566, 567standard,278, 279min()function template, 732MIN macro, 127
Modifierssigned and unsigned, 19Modular programming, 7, 249
Modules, 7, 173, 199MotorHomemultiply-derived class, 588, 589, 598move()methodand BitmapN container class, 775Multidimensional arraysdefining, 331
as parameters, 359
sample program, 330Multimaps, 769using,772, 773Multiple assignments, 87
Multiple indirect base classes, 590, 591Multiple inheritance, 587-606constructor calls, 594initializing virtual base classes, 596multiple identical base classes, 591
multiple indirect base classes, 590multiply-derived classes, 588, 589virtual base classes, 592Multiple template parameters, 729
Multiply-derived classes, 588, 589multisetcontainer class, 771Multisets, 769declaring, 771
sample,770NNames and namingarrays, 351
bit-fields, 715
constructors, 267
declaring, 41
file, 385
macros, 121
operator functions, 415816INDEX
source file, 7valid, 31
of variables, 31namespacekeyword, 209Namespacesdefining,208, 209n-dimensional array, 331
Negation, 417
Negative numbersconverting,142outputting as decimals, 63Nested if-else statements, 105
Nested namespaces, 209
Nesting exception handling, 616, 617Nesting loops, 103
new handler, 457
New-line characters, 11, 51newoperator,454calling for fundamental types, 455
calling with default constructor, 459new[]operator, 461noboolalphamanipulator, 69Nongraphic characters, 28noshowpoint(*), 64noshowpos(*)manipulator, 60NOToperator, 91nouppercase manipulator, 63
NULL, 365, 465, 577
Null character, 25, 26, 327
NULL pointer, 333, 363, 457
Numbersformatted input of, 72Number symbol (#), 9, 11
Numerical constants, 23
Numeric operationsexception handling for, 618, 619numeric_limits, 786OObject-oriented programming, 3, 4, 5, 245Object persistence, 392, 393Objects, 5, 33accessing, 281, 760, 761as arguments, 235
assigning, 253
cleaning up, 271creating/destroying, 51, 482, 483, 511creating with dynamic members, 480declaring, 513
defining,250, 251of derived classes, 512explicit initialization of, 459
initializing, 251, 455
lifetime of, 199
local, 179
member,298in memory, 251
passing as arguments, 282passing by reference, 283
passing by value, 283
pointers to, 254, 255references returned to, 285
representing pairs of, 773
returning,284, 285static, 203
storage classes of, 198storing, 393
of union WordByte in memory, 258using,252.See alsoClasses; ReferencesObligatory arguments, 685
Octal constant, 23
Octal numbersoutputting, 63octmanipulator, 63, 73OFF constant, 309ofstreamclass, 383ON constant, 309
OOP.SeeObject-oriented programmingopen()method, 386, 387Open mode flags, 387
Open modes, of file, 386Operandsand order of evaluation, 91
symmetry of, 419Operationsfile,380, 381for sequences, 752Operator functions, 414, 415, 416calling, 415, 419declaration of, 428defining global, 421
definition of, 428INDEX817
Operator functions(continued)global or method, 421
as methods, 415
naming, 415
negation, addition, and subtraction, 417operatorkeyword, 415, 445Operatorsbitwise,706, 707for classes, 413
and complex declarations, 691
dot, 253
indirection,232overloadable,412overloading, 413
with pointer variables, 355
reference type, 229
in template functions, 733
unary, 233Operators for fundamental typesbinary arithmetic operators, 82-83
increment/decrement operators, 85
logical operators, 90relational operators, 88, 89sign operators, 85
unary arithmetic operators, 84Optional arguments, 685, 687
OR operator, 91ostreamclass, 47, 59, 61outconstant, 309out_of_range(*), 620Outputredirecting standard, 130, 131stream classes for, 58streams, 9overflow_error(*)class, 620Overloaded operatorsrules for, 412
using,418, 419Overloadingassignment operator, 489
functions,184, 185operators, 413, 423
and redefinition, 509
shift operators for I/O, 428, 429subscript operators, 426, 427, 485PParameters, 175declaring, 357
multidimensional arrays as, 359
pointers as, 234read-only pointers as, 361Parenthesesin syntax description, 33Parity bit computation, 713parity()function, 713PassCarversions of, 510, 511PassCarclassvirtual method table for, 550PassCarderived class, 504Passing argumentsto function templates, 730, 731Passing by reference, 179, 225, 283
Passing by value, 179, 225, 283
Persistenceobject,392, 393of polymorphic objects, 648,650Pixels (picture element), 775
Pointer arithmetic, 354, 355Pointer arraysgenerating dynamically, 683Pointer assignmenteffect of, 534Pointers, 233, 285, 729, 755to abstract classes, 570, 571as arguments, 235
array elements interrelated with, 352arrays of, 364comparing, 355
to const objects, 361
defining,230defining arrays of, 365
to functions, 688, 689moving in array, 355
NULL, 333
to objects, 254, 255as parameters, 234parameters declared as, 357
read-only,360returning,362, 363818INDEX
sample program, 350,352subtracting, 355
typeless, 351
use of, instead of indices, 359Pointers to pointers, 682, 683Pointer types, 231
Pointer variables, 231, 235, 683addressing with, 353
and arrays, 351Polymorphic interfaces, 571
Polymorphic objectspersistence of, 648,650storing, 649Polymorphism, 3, 543-564concept of, 544, 545destroying dynamically allocated objects, 548, 549dynamic casts, 552, 553virtual methods, 546, 547virtual method table, 550, 551pop_back()methodfor deleting objects in container classes, 765popFront()method, 465, 467pop()method, 765Positioning flags, 641
Positioning methods, 643
Positive numbersconverting to, 142Postfix increment, 430Postfix notation, 85effects of, 84Precedenceof arithmetic operators, 84and arithmetic type conversions, 707
of Boolean operators, 91
for cast operator (type), 147
for comma operator, 101
for indirection operator, 233
operator, 85
for operators with pointer variables, 355
of relational operators, 88, 89precision()method, 65Prefixes, 31
Prefix increment, 430
Prefix notation, 85effects of, 84Preprocessor, 9Preprocessor directives, 11
Primary file, within index file, 653, 655printf()function, 685Priority queues, 753testing,764priority_queuetemplate, 753Private data membersaccessing, 275Private members, 245, 247, 249, 503, 507
Procedures, 5
Program scopeobject defined with, 199Projects, 249
Properties, 5
protected constructors, 569
Protected declarations, 515
Protected members, 515
Prototype, 175, 177publicbase classesis relationship established by, 589Public interface, of class, 247
Public members, 245, 247access to, in base class, 503Public methods, 51
Pure virtual methods, 566, 567pushBack()method, 465, 467push_back()method, 759push_front()method, 759push()method, 759put()method, 75, 391Qqsort()function, 689, 696, 697QuadMatrixtemplate,734, 735Quadratic matricesclass template representing, 734, 735Queuesas sequential containers, 751Quick sort algorithm, 187, 689
Quotientof Fibonacci number, 325Rrand(), 45INDEX819
Random access iterators, 755Random file access, 381, 639positioning for, 640, 641, 642, 643Random number generatorinitializing, 44, 45Random positioning statements, 643
Random read and write access, 639
Range checking, 427
Range operator, 305base class method accessed by, 509range_errorclass, 620Raster imagesrepresenting with bitmaps, 774, 775rdstate()method, 645Readabilityand complex expressions, 109
and empty statements, 99
and loop body, 97
and macros, 121
andtypedef, 693Read accessopen mode for, 638read_at()method,642Readingblocks of records, 390characters, 75
records, 381read()methodof classes DepAccandSavAcc,648, 649implementing,392, 393Read-only methods, 277
Read-only pointers, 360for non-constant objects, 361Read-only references, 223, 225
Records, 257inserting and retrieving, 655
position of, in files, 643
reading, 381
reading/writing blocks, 390Recursive data structures, 465
Recursive functions, 186, 187Redefined methodscalling, 513Redefinition, 509References, 3, 729to abstract classes, 570, 571conversions in, to base classes, 535
defining,222as parameters, 224and pointers, 231
read-only, 223, 225
returning, 285
as return value, 226, 227sample program, 222Reference type functioncalling, 227registerkeyword, 205RegistersCPU, 205Register variables, 205sample function with, 204Relational operators, 50, 412precedence of, 88, 89remove()method, 481, 485replace()method, 163reset()methodand manipulating bits, 777Resistant mistakesprogram with, 76resize()methodand container classes, 763Resultclass, 303, 424, 425constructors for, 298, 299new version of, 302with static members, 304with static methods, 306retrieve()method, 651ofIndexFileSystemclass,654, 655Return address, 181returnstatement, 9, 177Return values, 41, 285
Reusability, 5, 501reverse()function, 357reverse()method, 767rfind()method, 163Right shift operators, 708, 709Round brackets, 33
Routers, 779820INDEX
Rowclassdefining,694, 695RTTI.SeeRun Time Type InformationRuntime behaviorof container classes, 759runtime_error, 621Run time errors, 621avoiding, 43, 267
exception classes derived from, 620, 621Run Time Type Information, 552
R-values, 233SSafeclass,514, 515SavAccclassdefining,648, 649scientificmanipulator, 65Scope, 199
Scope resolution operator, 209, 211, 249
Screen controlmacros, 123, 125

Scrolling string output, 334search()method, 655seekg()method, 641seekp()method, 641SelectionSort()function, 697Semicolon, 9, 103
Sequencesand header files, 752operations for, 752representing, 753Sequential containers (or sequences), 750, 751Sequential file access, 381setcontainer class, 771setfill()manipulator, 66setfill()method, 67setf()method,60, 61, 69set()method, 777setprecision()manipulator, 65Setsassociative containers within, 751
declaring, 771
representing, 769
sample,770setTime()method,282setw()manipulator, 66Shape type, 309
Sheltered membersaccess to, 515Shift operators, 708shorttype, 19showposmanipulatorcalling,60Side effectsavoiding, 87
of macros, 125Sieve of Eratosthenes, 334signal.hheader file, 48Signaturesconstructor, 267, 269
function, 185signed chartype, 19, 142Signed integersconverting,142signedkeyword, 19Signed typeconversion of, to larger integral type, 143Sign extension, 143
Sign operators, 85
Simple assignments, 87
Single charactersmeaning of, 26Single quotescharacter constants within, 25size()methodand length of container, 763
and maps/multimaps, 773
and number of objects in container, 771sizeofoperator, 21sort()methodlist container sorted by call to, 767SortVeccontainer classmerge()method of, 762search()method of, 760using,756Source code, 7
Source files, 7, 249layout of, 11
name, 7INDEX821
Spaces, 11Special characters, 28
Special objects, of base class, 531splice()function,466, 467Splice operations, 767sqrt()function, 40, 53srand()function, 45sstreamclass, 48Stackclass template, 724explicit instantiation for, 737
with two template parameters, 728Stack contentafter calling function, 178Stacks, 179fixed/varying arguments on, 684and recursive functions, 187
as sequential containers, 751
testing,726Standard copy constructor, 487
Standard exception classeshierarchy of, 621
using,620Standard exception handlingfor streams, 647Standard input, 59
Standard methods, 279sample program, 278Standard output, 59
Standard settings, 65
Star character, 233
State flags, 645, 647
Statements, 9
Static arrays, 325
Static binding, 551
Static data members, 304, 305accessing,306declaring, 305
definition and initialization, 305
and encapsulation, 307Static data structures, 463
Static functions, 207statickeyword, 305static_cast, 537Static lifetime, 199, 203
Static member functions, 307
Static objects, 203staticstorage class, 202, 203, 207stdstandard namespace, 9, 209Storage classes, 199of functions, 206Storage class specifiers, 198strcat()functionand return pointers, 363strcmp()function, 327index version of, 368strcpy()function, 327pointer versions of, 358
and return pointers, 363Stream access errors, 651
Stream classshift operators, 229streambufclass, 48Streams, 9discovering/changing status of, 645
standard, 59
standard exception handling for, 647String assignments, 155, 157stringclass, 153, 251, 413C strings and, 327
defining, 155
objects of, 51
sample assignments of, 228sample program, 50,154String constants, 23, 25
String literalinternal representation of, 24Stringscharacters accessed in, 164comparing,158concatenating,156, 157escape sequences used in, 29
initializing,154, 155inserting and erasing in, 160, 161numbers converted to, 288output of, 68, 69searching and replacing in, 162, 163stringstreamclass, 288strlen()function, 327, 359Stroustrup, Bjarne, 3strstr()function sample program, 362, 363structkeyword, 257structs sample program, 256822INDEX
Style, 11Sub-object lattice, 595
Subroutines, 5, 181
Subscript, 323
Subscript operators, 165, 427and access via indices, 761
bits referenced by, 777
in Matrix class, 695
overloading,426, 427read and write access using, 485Substringserasing,160replacing,162Subtraction, 355, 417swap()implementing as method, 282swap()function, 235Swapping, 455switchstatement, 111else-ifchains contrasted with, 111structogram for, 110Symbolic constants, 121sync()method, 70Syntax, 249brackets in descriptions, 612
for defining variables, 33
errors, 7TTabs, 11tan()function, 40tellg()method, 641TelListclass,332, 333methods implemented for, 336, 337tellp()method, 641Template argumentsrestrictions on, 731Template function definition, 733
Template functionsmotivation for, 733Template parametersmultiple, 729
restrictions on, 729Templates, 3, 721-748advantages of, 723arguments,730, 731in C++ standard library, 723default arguments of, 734, 735defining,724, 725defining with multiple parameters, 729
function and class, 723
instantiating,726, 727, 736, 737parameters,728, 729specialization, 732-733terminate()function, 613Testing characters, 129
Textmode, 386
and nesting loops, 103Text editor, 7thispointersample class DayTime,280using, 281Throwing exceptions, 614throwstatement, 611using,610timediff()function, 207time()function, 167time_ttype, 261tmstruct, 260Tokens, 11
Toneand nesting loops, 103top()method, 761toupper()macro, 129Traditional procedural programming, 4, 5Translation unit, 199truekeyword, 23truncopen mode, 386Truth tablefor logical operators, 90tryblock, 615nested,616, 617syntax of, 612, 613Two-dimensional arraysinitialization list of, 331
parameter declaration for, 359Type casting, 351
Type conversion for classes, 441-452ambiguities of type conversions, 446-447
conversion constructors, 442-443
conversion functions, 444-445INDEX823
Type conversions, 43, 146ambiguities of, 446, 447in assignments, 145, 532, 533explicit, 147, 536, 537failure, 447
implicit,140, 144, 147, 531standard, 445
usual arithmetic, 141, 142typedefkeyword, 693Type hierarchy, 140Typeless pointers, 351
Typenamesdefining,692Types, 611platform dependent, 693
pointer, 231UUnary arithmetic operators, 84, 85Unary operators, 83, 233underflow_errorclass, 620#undefdirective, 127Underscoresand internal names, 31Unicode, 17
Union,258, 259defined, 259Unique keys, 769usetf()method,60, 61unsigned chartype, 19unsignedkeyword, 19unsigned short, 19
Unsigned types, 143
Unsigned value, 45
Unwinding the stack, 615
Upcasting,536, 537, 553User Network Interface, 715usingdeclaration, 211usingdirective, 211usingkeyword, 9, 49, 210Usual arithmetic type conversions, 141, 145performing,142Vva_arg()macroarguments of, 687valarrayclass, 48Variablesdefining, 33
defining in if statements, 105
names of, 31
pointer, 683
sample program, 32Variable type, 77
Vector, 323vectorcontainer class, 755constructors of, 757
methods for deleting objects in, 765Vectorsiterating,754Virtual assignmentsusing, 573Virtual base classes, 592, 593constructor calls in, 597
initializing,596, 597Virtual destructorsdeclaring, 549virtualkeyword, 593Virtual methods, 546, 547calling,544, 545declaring, 547
pure,566, 567redefining, 547Virtual method tables, 550, 551Virtual operator functions, 573VMT.SeeVirtual method tablesvoidtype, 21for functions, 44, 45void*type pointer, 351volatilekeyword, 34, 36WWarnings, 7wchar_ttype, 17, 19what()method, 621824INDEX
what()virtual method, 647whilestatementstructogram for, 96structogram for break within, 112syntax for, 97Whitespace characters, 11
Widthbit-fields, 715width()method, 67, 491Wordbyte uniondefining/using,258Write accessopen mode for, 638write_at()method,642WriteErrortype exception, 651write()method, 391, 392, 393of classes DepAccandSavAcc,648, 649Write operation, 381
Writingblocks of records, 390characters, 75XXORoperator, 707ZZero extension, 143INDEX825
