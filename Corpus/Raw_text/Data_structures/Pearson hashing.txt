***Pearson hashing***
Pearson hashing  is a hash function designed for fast execution on processors with 8-bit registers. Given an input consisting of any number of bytes, it produces as output a single byte that is strongly dependent on every byte of the input. Its implementation requires only a few instructions, plus a 256-byte lookup table containing a permutation of the values 0 through 255.
 This hash function is a CBC-MAC that uses an 8-bit substitution cipher implemented via the substitution table. An 8-bit cipher has negligible cryptographic security, so the Pearson hash function is not cryptographically strong, but it is useful for implementing hash tables or as a data integrity check code, for which purposes it offers these benefits:
 
 It is extremely simple. 
 It executes quickly on resource-limited processors. 
 There is no simple class of inputs for which collisions (identical outputs) are especially likely. 
 Given a small, privileged set of inputs (e.g., reserved words for a compiler), the permutation table can be adjusted so that those inputs yield distinct hash values, producing what is called a perfect hash function. 
 Two input strings differing by exactly one character never collide. E.g., applying the algorithm on the strings ABC and AEC will never produce the same value. One of its drawbacks when compared with other hashing algorithms designed for 8-bit processors is the suggested 256 byte lookup table, which can be prohibitively large for a small microcontroller with a program memory size on the order of hundreds of bytes. A workaround to this is to use a simple permutation function instead of a table stored in program memory. However, using a too simple function, such as  T[i] = 255-i , partly defeats the usability as a hash function as anagrams will result in the same hash value; using a too complex function, on the other hand, will affect speed negatively. Using a function rather than a table also allows extending the block size. Such functions naturally have to be bijective, like their table variants.
 The algorithm can be described by the following pseudocode, which computes the hash of message  C  using the permutation table  T :
 
 h := 0
 for each  c  in  C  loop 
  h := T[ h  xor  c ]
 end loop 
 return  h
 
 The hash variable ( h ) may be initialized differently, e.g. to the length of the data ( C ) modulo 256; this particular choice is used in the Python implementation example below.
 

 **Python implementation to generate a (pseudo) 8-bit output**

 The 'table' parameter requires a pseudo-randomly shuffled list of range [0..255]. This may easily be generated by using python's builtin  range  function and using  random.shuffle  to permutate it:
 

 **C implementation to generate 64-bit (16 hex chars) hash**

 The scheme used above is a very straightforward implementation of the algorithm, with a simple extension to generate a hash longer than 8 bits.  That extension comprises the outer loop (i.e. all statement lines that include the variable  j ) and the array  hh .
 For a given string or chunk of data, Pearson's original algorithm produces only an 8-bit byte or integer, 0-255. However, the algorithm makes it extremely easy to generate a hash of whatever length is desired. As Pearson noted, a change to any bit in the string causes his algorithm to create a completely different hash (0-255). In the code above, following every completion of the inner loop, the first byte of the string is effectively incremented by one (without modifying the string itself).
 Every time that simple change to the first byte of the data is made, a different Pearson hash,  h , is generated. The C function builds a 16 hex character hash by concatenating a series of 8-bit Pearson hashes (collected in  hh ). Instead of producing a value from 0 to 255, this function generates a value from 0 to 18,446,744,073,709,551,615 (= 2 64  - 1).
 This shows that Pearson's algorithm can be made to generate hashes of any desired length by concatenating a sequence of 8-bit hash values, each of which is computed simply by slightly modifying the string each time the hash function is computed. Thus the same core logic can be made to generate 32-bit or 128-bit hashes.
 

 