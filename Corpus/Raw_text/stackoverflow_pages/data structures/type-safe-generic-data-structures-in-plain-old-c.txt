*** type-safe-generic-data-structures-in-plain-old-c ***

 I have done far more C++ programming than "plain old C" programming.  One thing I sorely miss when programming in plain C is type-safe generic data structures, which are provided in C++ via templates. 
 For sake of concreteness, consider a generic singly linked list.  In C++, it is a simple matter to define your own template class, and then instantiate it for the types you need. 
 In C, I can think of a few ways of implementing a generic singly linked list: 
 
 Write the linked list type(s) and supporting procedures once, using void pointers to go around the type system. 
 Write preprocessor macros taking the necessary type names, etc, to generate a type-specific version of the data structure and supporting procedures. 
 Use a more sophisticated, stand-alone tool to generate the code for the types you need. 
 
 I don't like option 1, as it is subverts the type system, and would likely have worse performance than a specialized type-specific implementation.  Using a uniform representation of the data structure for all types, and casting to/from void pointers, so far as I can see, necessitates an indirection that would be avoided by an implementation specialized for the element type. 
 Option 2 doesn't require any extra tools, but it feels somewhat clunky, and could give bad compiler errors when used improperly. 
 Option 3 could give better compiler error messages than option 2, as the specialized data structure code would reside in expanded form that could be opened in an editor and inspected by the programmer (as opposed to code generated by preprocessor macros).  However, this option is the most heavyweight, a sort of "poor-man's templates".  I have used this approach before, using a simple sed script to specialize a "templated" version of some C code. 
 I would like to program my future "low-level" projects in C rather than C++, but have been frightened by the thought of rewriting common data structures for each specific type. 
 What experience do people have with this issue?  Are there good libraries of generic data structures and algorithms in C that do not go with Option 1 (i.e. casting to and from void pointers, which sacrifices type safety and adds a level of indirection)? 
 
 Option 1 is the approach taken by most C implementations of generic containers that I see.  The Windows driver kit and the Linux kernel use a macro to allow links for the containers to be embedded anywhere in a structure, with the macro used to obtain the structure pointer from a pointer to the link field: 
 
  macro in Linux   
  macro in Windows   
 
 Option 2 is the tack taken by BSD's tree.h and queue.h container implementation: 
 
 http://openbsd.su/src/sys/sys/queue.h 
 http://openbsd.su/src/sys/sys/tree.h 
 
 I don't think I'd consider either of these approaches type safe. Useful, but not type safe. 
 
 C has a different kind of beauty to it than C++, and type safety and being able to always see what everything is when tracing through code without involving casts in your debugger is typically not one of them. 
 C's beauty comes a lot from its lack of type safety, of working around the type system and at the raw level of bits and bytes. Because of that, there's certain things it can do more easily without fighting against the language like, say, variable-length structs, using the stack even for arrays whose sizes are determined at runtime, etc. It also tends to be a lot simpler to preserve ABI when you're working at this lower level. 
 So there's a different kind of aesthetic involved here as well as different challenges, and I'd recommend a shift in mindset when you work in C. To really appreciate it, I'd suggest doing things many people take for granted these days, like implementing your own memory allocator or device driver. When you're working at such a low level, you can't help but look at everything as memory layouts of bits and bytes as opposed to 'objects' with behaviors attached. Furthermore, there can come a point in such low-level bit/byte manipulation code where C becomes easier to comprehend than C++ code littered with  , e.g. 
 As for your linked list example, I would suggest a non-intrusive version of a linked node (one that does not require storing list pointers into the element type,  , itself, allowing the linked list logic and representation to be decoupled from   itself), like so: 
 
 Now we can create a list node like so: 
 
 To retrieve the element from the list as T*: 
 
 Since it's C, there's no type checking whatsoever when casting pointers in this way, and that will probably also give you an uneasy feeling if you're coming from a C++ background. 
 The tricky part here is to make sure that this member,  , is properly aligned for whatever type you want to store. When you can solve that problem as portably as you need it to be, you'll have a powerful solution for creating efficient memory layouts and allocators. Often this will have you just using max alignment for everything which might seem wasteful, but typically isn't if you are using appropriate data structures and allocators which aren't paying this overhead for numerous small elements on an individual basis. 
 Now this solution still involves the type casting. There's little you can do about that short of having a separate version of code of this list node and the corresponding logic to work with it for every type, T, that you want to support (short of dynamic polymorphism). However, it does not involve an additional level of indirection as you might have thought was needed, and still allocates the entire list node and element in a single allocation. 
 And I would recommend this simple way to achieve genericity in C in many cases. Simply replace   with a buffer that has a length matching   and aligned properly. If you have a reasonably portable and safe way you can generalize to ensure proper alignment, you'll have a very powerful way of working with memory in a way that often improves cache hits, reduces the frequency of heap allocations/deallocations, the amount of indirection required, build times, etc. 
 If you need more automation like having   automatically initialize  , I would recommend creating a general type table struct that you can pass around which contains information like how big T is, a function pointer pointing to a function to create a default instance of T, another to copy T, clone T, destroy T, a comparator, etc. In C++, you can generate this table automatically using templates and built-in language concepts like copy constructors and destructors. C requires a bit more manual effort, but you can still reduce it the boilerplate a bit with macros. 
 Another trick that can be useful if you go with a more macro-oriented code generation route is to cash in a prefix or suffix-based naming convention of identifiers. For example, CLONE(Type, ptr) could be defined to return  , so   could invoke  . This is kind of a cheat to get something akin to function overloading in C, and is useful when generating code in bulk (when CLONE is used to implement another macro) or even a bit of copying and pasting of boilerplate-type code to at least improve the uniformity of the boilerplate. 
 
 Option 1, either using   or some   based variant is what most C programs use, and it may give you BETTER performance than the C++/macro style of having multiple implementations for different types, as it has less code duplication, and thus less icache pressure and fewer icache misses. 
 
 GLib is has a bunch of generic data structures in it,  http://www.gtk.org/ 
 CCAN has a bunch of useful snippets and such  http://ccan.ozlabs.org/ 
 
 Your option 1 is what most old time c programmers would go for, possibly salted with a little of 2 to cut down on the repetitive typing, and just  maybe  employing a few function pointers for a flavor of polymorphism. 
 
 There's a common variation to option 1 which is more efficient as it uses unions to store the values in the list nodes, ie there's no additional indirection. This has the downside that the list only accepts values of certain types and potentially wastes some memory if the types are of different sizes. 
 However, it's possible to get rid of the   by using flexible array member instead if you're willing to break strict aliasing. C99 example code: 
 
 
 An old question, I know, but in case it is still of interest: I was experimenting with option 2) (pre-processor macros) today, and came up with the example I will paste below.  Slightly clunky indeed, but not terrible.  The code is not fully type safe, but contains sanity checks to provide a reasonable level of safety.  And dealing with the compiler error messages while writing it was mild compared to what I have seen when C++ templates came into play.  You are probably best starting reading this at the example use code in the "main" function. 
 
 
 I use void pointers (void*) to represent generic data structures defined with structs and typedefs. Below I share my implementation of a lib which I'm working on. 
 With this kind of implementation, you can think of each new type, defined with typedef, like a pseudo-class. Here, this pseudo-class is the set of the source code (some_type_implementation.c) and its header file (some_type_implementation.h).  
 In the source code, you have to define the struct that will present the new type. Note the struct in the "node.c" source file. There I made a void pointer to the "info" atribute. This pointer may carry any type of pointer (I think), but the price you have to pay is a type identifier inside the struct (int type), and all the switchs to make the propper handle of each type defined. So, in the node.h" header file, I defined the type "Node" (just to avoid have to type struct node every time), and also I had to define the constants "EMPTY_NODE", "COMPLEX_NODE", and "MATRIX_NODE". 
 You can perform the compilation, by hand, with "gcc *.c -lm". 
 **main.c Source File**

 
 **node.c Source File**

 
 **node.h Header File**

 
 **matrix.c Source File**

 
 **matrix.h Header File**

 
 **complex.c Source File**

 
 **complex.h Header File**

 
 I hope I hadn't missed nothing. 
 
 I am using option 2 for a couple of high performance collections, and it is extremely time-consuming working through the amount of macro logic needed to do anything truly compile-time generic and worth using. I am doing this purely for raw performance (games). An  X-macros  approach is used. 
 A painful issue that constantly comes up with Option 2 is, "Assuming some finite number of options, such as 8/16/32/64 bit keys, do I make said value a constant and define several functions each with a different element of this set of values that constant can take on, or do I just make it a member variable?" The former means a less performant instruction cache since you have a lot of repeated functions with just one or two numbers different, while the latter means you have to reference allocated variables which in the worst case means a data cache miss. Since Option 1 is purely dynamic, you will make such values member variables without even thinking about it. This truly is micro-optimisation, though. 
 Also bear in mind the trade-off between returning pointers vs. values: the latter is most performant when the size of the data item is less than or equal to pointer size; whereas if the data item is larger, it is most likely better to return pointers than to force a copy of a large object by returning value. 
 I would strongly suggest going for Option 1 in any scenario where you are not 100% certain that collection performance will be your bottleneck. Even with my use of Option 2, my collections library supplies a "quick setup" which is like Option 1, i.e. use of   values in my list and map. This is sufficient for 90+% of circumstances. 
 