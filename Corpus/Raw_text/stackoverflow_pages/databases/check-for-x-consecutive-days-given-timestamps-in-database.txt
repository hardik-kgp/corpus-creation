*** check-for-x-consecutive-days-given-timestamps-in-database ***

 Could anybody give me an idea or hint how you could check for X consecutive days in a database table (MySQL) where logins (user id, timestamp) are stored? 
 Stackoverflow does it (e.g. badges like Enthusiast - if you log in for 30 consecutive days or so...). What functions would you have to use or what is the idea of how to do it? 
 Something like  ? 
 
 You can accomplish this using a shifted self-outer-join in conjunction with a variable. See this solution: 
 
 This will return either a   or a   based on if a user has logged in for 30 consecutive days or more at  **ANYTIME**
 in the past.  
 The brunt of this query is really in the first subselect. Let's take a closer look so we can better understand how this works: 
 With the following example data set: 
 
 This query: 
 
 Will produce: 
 
 As you can see, what we are doing is  shifting  the joined table by +1 day. For each day that is not consecutive with the prior day, a   value is generated by the LEFT JOIN.  
 Now that we  know  where the non-consecutive days are, we can use a variable to differentiate each  set  of consecutive days by detecting whether or not the shifted table's rows are  . If they are  , the days are not consecutive, so just increment the variable. If they are  , then don't increment the variable: 
 
 After we've differentiated each set of consecutive days with the incrementing variable, it's then just a simple matter of grouping by each "set" (as defined in the   column) and using   to filter out any set that has less than the specified consecutive days (30 in your example): 
 
 Then finally, we wrap  **THAT**
 query and simply count the number of sets that had 30 or more consecutive days. If there was one or more of these sets, then return  , otherwise return  . 
 
 **See a **
**SQLFiddle step-by-step demo**

 
 You can add X to timestamp date and chech if distinct( dates ) in this date range is == X: 
 At least once every day of those 30 days: 
 
 (You don't speack about performance requirements ... ;)   ) 
 *** Edited ***
 The query for only last X days: east once every day of those 30 days 
 
 
 That's a hard problem to solve with SQL alone.   
 The core of the problem is that you need to compare dynamic results sets to each other in one query.  For example, you need to get all the logins/session IDs for one DATE, then JOIN or UNION them with a list to a grouping of logins from the DATE() (which you could use DATE_ADD to determine).  You could do this for N number of consecutive dates.  If you have any rows left, then those sessions have been logged in over that period. 
 Assume the following table: 
 sessionid int, created date 
 This query returns all the sessionids that have have rows for the last two days: 
 
 As you can see, the SQL will get gnarly for 30 days.  Have a script generate it. :-D 
 This further assumes that every day, the login table is updated with the session. 
 I don't know if this actually solves your problem, but I hope I have helped frame the problem. 
 Good luck. 
 
 Wouldn't it be more simple to have an extra column consecutive_days in login_dates table with default value 1. This would indicate the length of consecutive dates ending on that day. 
 You create an insert after trigger on login_dates where you check if there is an entry for the previous day. 
 If there is none, then the field would have the default value 1 meaning that a new sequence is started on that date. 
 If here is an entry for previous day then you change the days_logged_in value from the default 1 to be 1 greater then that of previous day. 
 Ex: 
 
 