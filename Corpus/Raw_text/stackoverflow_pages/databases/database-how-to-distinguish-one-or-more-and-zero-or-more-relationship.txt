*** database-how-to-distinguish-one-or-more-and-zero-or-more-relationship ***

 Design tools allow distinguish between  "one TO  **zero-or-more**
"  and  "one TO  **one-or-more**
"  relationships. I could imagine how to implement  "one TO zero-or-more"  relation: 
 
 **CHILD_TABLE**

 (pk) chid_id  
(fk) parent_id  (required) 
 
 **PARENT_TABLE**

 (pk) parent_id  
 
 How to implement  "one TO one-or-more"  relationship? How to say that parent requires at least one child? Or is " **one-or-more**
" usually implemented as " **zero-or-more**
" ? 
 
 Implementing a 1 to 1-or-more relationship is done through the business logic, or at least using a transaction.  You cannot insert into both tables simultaneously; you insert into one table at a time.  Therefore, you need to insert the parent before you can insert the child and there is no built-in way for the database to enforce the required logic.   
 If you wrap the two INSERT statements inside a transaction, then you guarantee if the child insert fails, the parent insert will be rolled back.  However, it is up to the business logic to make sure a parent is not inserted without a child. 
 
 It is obvious that enforcing constraints such as the one you specify, will require the clients to sometimes issue (and the DBMS engines to accept) something that could be labeled "simultaneous updates", that is, more than one distinct table being updated prior to any constraint checking. 
 The SQL  language  (I mean, the standard) offers support for that through CREATE ASSERTION.  Alas, no currently existing engine supports this statement. 
 The only way this can be achieved with currently existing SQL engines, is to defer the constraint checking until after all updates are done (if your engine supports this, of course).  Enforcing such constraints in application code or business logic ultimately amounts to not having the constraint at all in the first place, if your database is "shared" and can also be updated by other programs. 
 Systems do exist that offer support for enforcing your kind of constraint, but they are not SQL sytems. 
 aioobe's solution is quite original, but keep in mind that you can only do so by duplicating all columns of the "many" (/child) side to the "one" (/parent) side (because otherwise you still have the same problem between two tables, except that the "or-more" part has gone away, but that's not where the problem is).  And if you do this, you will then be faced with great difficulties when :  
 
 writing queries against the "many" side (you will have to see to it that that one other row that resides on the "one" side will always get UNIONed with the many side), 
 enforcing keys on the "many" side (you will have to see to it that no key on the many side will have the same value as that one other row that resides on the "one" side, 
 enforcing referential integrity when the referred table is itself your "one-or-more" side (you should see to it that it is also valid for references to exist to that one other row that resides on the "one" side). 
 
 So aioobe's solution, allthough original, is likely to create more new problems than it solves. 
 
 In SQL Server foreign key relationships are always "one" to "zero or more". A "one" to "one or more" relationship would make inserting initial data very hard as well. (you would have to disable the foreign key before you can insert a record in the parent table) 
 
 The best way I know of is to do all inserts through a stored proc which has a transaction and rollsback the parent insert if the child fails.   
 Another way I have seen (but which is really somewhat of a hack) is to make all fields in the child except the autogenerated Id and the FK nullable and then insert the record with just the id from a trigger on the parent table. Then an update is done to the child table to add the details for the other fields. This is acceptable if they should be nullable or if you might not have any data at the time of data entry for the child table, but can create data itegrity issues if the fields shouldn't be null.  
 
 You could implement it as "one-to-one" plus "one-to-zero or more" 
 
 The SQL language has very limited support for referential integrity and integrity constraints in general. Standard SQL (and most if not all popular SQL DBMSs) does not support one to one-or-more constraints. SQL FOREIGN KEY constraints are always optional on the referencing side of the relationship. Data modelling tools and languages usually support such constraints (ORM, ERD) but DBMSs rarely allow you to implement them. 
 