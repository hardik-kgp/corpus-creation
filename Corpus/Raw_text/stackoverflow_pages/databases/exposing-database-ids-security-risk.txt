*** exposing-database-ids-security-risk ***

 I've heard that exposing database IDs (in URLs, for example) is a security risk, but I'm having trouble understanding why. 
 Any opinions or links on why it's a risk, or why it isn't? 
 EDIT: of course the access is scoped, e.g. if you can't see resource   you'll get an error page. Otherwise the URL itself should be secret. 
 EDIT: if the URL is secret, it will probably contain a generated token that has a limited lifetime, e.g. valid for 1 hour and can only be used once. 
 EDIT (months later): my current preferred practice for this is to use UUIDS for IDs and expose them. If I'm using sequential numbers (usually for performance on some DBs) as IDs I like generating a UUID token for each entry as an alternate key, and expose that. 
 
 Given the proper conditions, exposing identifiers is not a security risk. And, in practice, it would be extremely burdensome to design a web application without exposing identifiers. 
 Here are some good rules to follow: 
 
 Use role-based security to control access to an operation. How this is done depends on the platform and framework you've chosen, but many support a declarative security model that will automatically redirect browsers to an authentication step when an action requires some authority. 
 Use programmatic security to control access to an object. This is harder to do at a framework level. More often, it is something you have to write into your code and is therefore more error prone. This check goes beyond role-based checking by ensuring not only that the user has authority for the operation, but also has necessary rights on the specific object being modified. In a role-based system, it's easy to check that only managers can give raises, but beyond that, you need to make sure that the employee belongs to the particular manager's department. 
 For most database records, conditions 1 and 2 are sufficient. But adding unpredictable IDs can be thought of as a little extra insurance, or "security in depth," if you buy into that notion. One place where unpredictable identifiers is a necessity, however, is in session IDs or other authentication tokens, where the ID itself authenticates a request. These should be generated by a cryptographic RNG. 
 
 
 It depends on what the IDs stand for. 
 Consider a site that for competitive reason don't want to make public how many members they have but by using sequential IDs reveals it anyway in the URL:  http://some.domain.name/user?id=3933 
 On the other hand, if they used the login name of the user instead:  http://some.domain.name/user?id=some  they haven't disclosed anything the user didn't already know. 
 
 While not a  **data security**
 risk this is absolutely a  **business intelligence security**
 risk as it exposes both data size and velocity.  I've seen businesses get harmed by this and have written about this anti-pattern in depth.  Unless you're just building an experiment and not a business I'd highly suggest keeping your private ids out of public eye.  https://medium.com/lightrail/prevent-business-intelligence-leaks-by-using-uuids-instead-of-database-ids-on-urls-and-in-apis-17f15669fd2e 
 
 The general thought goes along these lines: "Disclose as little information about the inner workings of your app to anyone." 
 Exposing the database ID counts as disclosing some information. 
 Reasons for this is that hackers can use any information about your apps inner workings to attack you, or a user can change the URL to get into a database he/she isn't suppose to see? 
 
 We use GUIDs for database ids. Leaking them is a lot less dangerous. 
 
 If you are using integer IDs in your db, you may make it easy for users to see data they shouldn't by changing qs variables.  
 E.g.  a user could easily change the id parameter in this qs and see/modify data they shouldn't  http://someurl?id=1 
 
 When you send database id's to your client you are  forced  to check security in both cases. If you keep the id's in your web session you can choose if you want/need to do it, meaning potentially less processing. 
 You are constantly trying to delegate things to your access control ;)  This  may  be the case in your application but I have never seen such a consistent back-end system in my entire career. Most of them have security models that were designed for non-web usage and some have had additional roles added posthumously, and some of these have been bolted on outside of the core security model (because the role was added in a different operational context, say before the web).  
 So we use synthetic session local id's because it hides as much as we can get away with. 
 There is also the issue of non-integer key fields, which may be the case for enumerated values and similar. You can try to sanitize that data, but chances are you'll end up like  little bobby drop tables .  
 