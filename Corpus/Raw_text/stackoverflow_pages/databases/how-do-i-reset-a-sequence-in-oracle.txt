*** how-do-i-reset-a-sequence-in-oracle ***

 In  PostgreSQL , I can do something like this: 
 
 Is there an Oracle equivalent? 
 
 Here is a good procedure for resetting any sequence to 0 from Oracle guru  Tom Kyte .  Great discussion on the pros and cons in the links below too. 
 
 From this page:  Dynamic SQL to reset sequence value 
Another good discussion is also here:  How to reset sequences? 
 
 A true restart is not possible  AFAIK . (Please correct me if I'm wrong!). 
 However, if you want to set it to 0, you can just delete and recreate it. 
 If you want to set it to a specific value, you can set the INCREMENT to a negative value and get the next value. 
 That is, if your sequence is at 500, you can set it to 100 via 
 
 
 This is my approach: 
 
 drop the sequence 
 recreate it 
 
 Example: 
 
 
 My approach is a teensy extension to  Dougman's example . 
 Extensions are... 
 Pass in the seed value as a parameter.  Why?  I like to call the thing resetting the sequence back to  the max ID used in some table .  I end up calling this proc from another script which executes multiple calls for a whole bunch of sequences, resetting nextval back down to some level which is high enough to not cause primary key violations where I'm using the sequence's value for a unique identifier. 
 It also honors the previous  minvalue .  It may in fact  push the next value ever higher  if the desired  **p_val**
 or  existing minvalue  are higher than the current or calculated next value. 
 Best of all, it can be called to reset to a specified value, and just wait until you see the wrapper "fix all my sequences" procedure at the end. 
 
 That procedure is useful all by itself, but now let's add another one which calls it and specifies everything programmatically with a sequence naming convention and looking for the maximum value used in an existing table/field... 
 
 Now we're cooking with gas!   
 The procedure above will check for a field's max value in a table, builds a sequence name from the table/field pair and invokes  "Reset_Sequence"  with that sensed max value. 
 The final piece in this puzzle and the icing on the cake comes next... 
 
 In my actual database there are around one hundred other sequences being reset through this mechanism, so there are 97 more calls to  Reset_Sequence_to_Data  in that procedure above. 
 Love it?  Hate it?  Indifferent? 
 
 
 This feature was officially added in 18c but is unofficially available in 12.1. 
 It is arguably safe to use this undocumented feature in 12.1.  Even though the syntax is  not  included in the  official documentation , it is generated by the Oracle package  DBMS_METADATA_DIFF .  I've used it several times on production systems.  However, I created an Oracle Service request and they verified that it's not a documentation bug, the feature is truly unsupported. 
 In 18c, the feature does not appear in the SQL Language Syntax, but is included in the  Database Administrator's Guide . 
 
 The following script set the sequence to a desired value: 
 Given a freshly created sequence named PCS_PROJ_KEY_SEQ and table PCS_PROJ: 
 
 
 This  stored procedure  restarts my sequence: 
 
 / 
 
 There is another way to reset a sequence in Oracle: set the   and   properties. When the   of the sequence hits the  , if the   property is set then it will begin again from the   of the sequence. 
 The advantage of this method compared to setting a negative   is the sequence can continue to be used while the reset process runs, reducing the chance you need to take some form of outage to do the reset. 
 The value for   has to be greater than the current  , so the procedure below includes an optional parameter allowing a buffer in case the sequence is accessed again between selecting the   in the procedure and setting the   property. 
 
 The procedure as stands still allows the possibility that another session will fetch the value 0, which may or may not be an issue for you. If it is, you could always: 
 
 Set   in the first alter 
 Exclude the second   fetch  
 Move the statement to set the   property into another procedure, to be run at a later date (assuming you want to do this). 
 
 
 Jezus, all this programming for just an index restart...
Perhaps I'm an idiot, but for pre-oracle 12 (which has a restart feature), what is wrong with a simpel: 
 
 ? 
 
 1) Suppose you create a SEQUENCE like shown below: 
 
 2) Now you fetch values from SEQUENCE. Lets say I have fetched four times as shown below. 
 
 3) After executing above four commands the value of the SEQUENCE will be 4. Now suppose I have reset the value of the SEQUENCE to 1 again. The follow the following steps. Follow all the steps in the same order as shown below: 
 
 
 
 
 
 
 
 Altering the sequence's INCREMENT value, incrementing it, and then altering it back is pretty painless, plus you have the added benefit of not having to re-establish all of the grants as you would had you dropped/recreated the sequence. 
 
 I create a block to reset all my sequences: 
 
 
 Here's a more robust procedure for altering the next value returned by a sequence, plus a whole lot more. 
 
 First off it protects against SQL injection attacks since none of the strings passed in are used to directly create any of the dynamic SQL statements, 
 Second it prevents the next sequence value from being set outside the bounds of the min or max sequence values.  The   will be !=   and between   and  . 
 Third it takes the current (or proposed)   setting as well as all the other sequence settings into account when cleaning up. 
 Fourth all parameters except the first are optional and unless specified take on the current sequence setting as defaults.  If no optional parameters are specified no action is taken. 
 Finally if you try altering a sequence that doesn't exist (or is not owned by the current user) it will raise an   error. 
 
 Here's the code: 
 
 
 In my project, once it happened that someone manually entered the records without using sequence, hence I have to reset sequence value manually, for which I wrote below sql code snippet: 
 
 Please note, the above code will work if the sequence is lagging.  
 
 You can use the CYCLE option, shown below: 
 
 In this case, when the sequence reaches MAXVALUE (100), it will recycle to the MINVALUE (0). 
 In the case of a decremented sequence, the sequence would recycle to the MAXVALUE. 
 
 Here's how to make all auto-increment sequences match actual data: 
 
 Create a procedure to enforce next value as was already described in this thread: 
 
 Create another procedure to reconcile all sequences with actual content: 
 
 
 NOTES: 
 
 Procedure extracts names from trigger code and does not depend on naming conventions 
 To check generated code before execution, switch comments on last two lines 
 
 
 I make an alternative that the user donâ€™t need to know the values, the system get and use variables to update. 
 
 
 Stored procedure that worked for me 
 
 How to use the stored procedure: 
 
 