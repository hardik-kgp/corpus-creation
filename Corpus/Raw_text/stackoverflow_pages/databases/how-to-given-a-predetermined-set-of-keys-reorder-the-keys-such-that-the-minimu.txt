*** how-to-given-a-predetermined-set-of-keys-reorder-the-keys-such-that-the-minimu ***

 So I have a problem which i'm pretty sure is solvable, but after many, many hours of thinking and discussion, only partial progress has been made.  
 The issue is as follows. I'm building a BTree of, potentially, a few million keys. When searching the BTree, it is paged on demand from disk into memory, and each page in operation is relatively expensive. This effectively means that we want to need to traverse as few nodes as possible (although after a node has been traversed to, the cost of traversing through that node, up to that node is 0). As a result, we don't want to waste space by having lots of nodes nearing minimum capacity. In theory, this should be preventable (within reason) as the structure of the tree is dependent on the order that the keys were inserted in. 
 So, the question is how to reorder the keys such that after the BTree is built the fewest number of nodes are used. Here's an example: 
 
 I did stumble on this question  In what order should you insert a set of known keys into a B-Tree to get minimal height?  which unfortunately asks a slightly different question. The answers, also don't seem to solve my problem. It is also worth adding that we want the mathematical guarantees that come from not building the tree manually, and only using the insert option. We don't want to build a tree manually, make a mistake, and then find it is unsearchable! 
 I've also stumbled upon 2 research papers which are so close to solving my question but aren't quite there! 
 Time-and Space-Optimality in B-Trees  and  Optimal 2,3-Trees  (where I took the above image from in fact) discuss and quantify the differences between space optimal and space pessimal BTrees, but don't go as far as to describe how to design an insert order as far as I can see. 
 Any help on this would be greatly, greatly appreciated. 
 Thanks 
 Research papers can be found at: 
 http://www.uqac.ca/rebaine/8INF805/Automne2007/Sujets2007Automne/p174-rosenberg.pdf 
 http://scholarship.claremont.edu/cgi/viewcontent.cgi?article=1143&context=hmc_fac_pub 
 EDIT:: I ended up filling a btree skeleton constructed as described in the above papers with the FILLORDER algorithm. As previously mentioned, I was hoping to avoid this, however I ended up implementing it before the 2 excellent answers were posted! 
 
 The algorithm below should work for B-Trees with minimum number of keys in node = d and maximum = 2*d I suppose it can be generalized for 2*d + 1 max keys if way of selecting median is known. 
 Algorithm below is designed to minimize the number of nodes not just height of the tree. 
 Method is based on idea of putting keys into any non-full leaf or if all leaves are full to put key under lowest non full node. 
 More precisely, tree generated by proposed algorithm meets following requirements:
It has minimum possible height;
It has no more then two nonfull nodes on each level. (It's always two most right nodes.) 
 Since we know that number of nodes on any level excepts root is strictly equal to sum of node number and total keys number on level above we can prove that there is no valid rearrangement of nodes between levels which decrease total number of nodes. For example increasing number of keys inserted above any certain level will lead to increase of nodes on that level and consequently increasing of total number of nodes. While any attempt to decrease number of keys above the certain level will lead to decrease of nodes count on that level and fail to fit all keys on that level without increasing tree height.
It also obvious that arrangement of keys on any certain level is one of optimal ones.
Using reasoning above also more formal proof through math induction may be constructed. 
 The idea is to hold list of counters (size of list no bigger than height of the tree) to track how much keys added on each level. Once I have d keys added to some level it means node filled in half created in that level and if there is enough keys to fill another half of this node we should skip this keys and add root for higher level. Through this way, root will be placed exactly between first half of previous subtree and first half of next subtree, it will cause split, when root will take it's place and two halfs of subtrees will become separated. Place for skipped keys will be safe while we go through bigger keys and can be filled later. 
 Here is nearly working (pseudo)code, array needs to be sorted: 
 
 Example: 
 Here is how numbers and corresponding counters keys should be arranged for d = 2 while first pass through array. I marked keys which pushed into the B-Tree during first pass (before loop with recursion) with 'o' and skipped with 'x'. 
 
 Since we don't iterate through skipped keys we have O(n) time complexity without adding to B-Tree itself and for sorted array; 
 In this form it may be unclear how it works when there is not enough keys to fill second half of node after skipped block but we can also avoid skipping of all skip[order] keys if total length of array lesser than ~ i + 2 * skip[order] and skip for skip[order - 1] keys instead, such string after changing  counters but before changing variable i might be added: 
 
 it will be correct cause if total count of keys on current level is lesser or equal than 3*d they still are split correctly if add them in original order. Such will lead to slightly different rearrangement of keys between two last nodes on some levels, but will not break any described requirements, and may be it will make behavior more easy to understand. 
 May be it's reasonable to find some animation and watch how it works, here is the sequence which should be generated on 0..29 range: 0 1 4 5 6 9 10 11 24 25 26 29 / end of first pass / 2 3 7 8 14 15 16 19 20 21 12 13 17 18 22 23 27 28
 
 
 The algorithm below attempts to prepare the order the keys so that you don't need to have power or even knowledge about the insertion procedure. The only assumption is that overfilled tree nodes are either split at the middle or at the position of the last inserted element, otherwise the B-tree can be treated as a black box. 
 The trick is to trigger node splits in a controlled way. First you fill a node exactly, the left half with keys that belong together and the right half with another range of keys that belong together. Finally you insert a key that falls in between those two ranges but which belongs with neither; the two subranges are split into separate nodes and the last inserted key ends up in the parent node. After splitting off in this fashion you can fill the remainder of both child nodes to make the tree as compact as possible. This also works for parent nodes with more than two child nodes, just repeat the trick with one of the children until the desired number of child nodes is created. Below, I use what is conceptually the rightmost childnode as the "splitting ground" (steps 5 and 6.1). 
 Apply the splitting trick recursively, and all elements should end up in their ideal place (which depends on the number of elements). I believe the algorithm below guarantees that the height of the tree is always minimal and that all nodes except for the root are as full as possible. However, as you can probably imagine it is hard to be completely sure without actually implementing and testing it thoroughly. I have tried this on paper and I do feel confident that this algorithm, or something extremely similar, should do the job. 
 Implied tree  T  with maximum branching factor  M . 
 Top procedure with  keys  of length  N : 
 
 Sort the  keys . 
 Set  minimal-tree-height  to ceil(log( N +1)/log( M )). 
 Call  insert-chunk  with  chunk  =  keys  and  H  =  minimal-tree-height . 
 
 Procedure  insert-chunk  with  chunk  of length  L , subtree height  H : 
 
 If  H  is equal to 1:
 
 Insert all keys from the  chunk  into  T 
 Return immediately. 
 
 Set the ideal subchunk size  S  to pow( M ,  H  - 1). 
 Set the number of subtrees  T  to ceil(( L  + 1) /  S ). 
 Set the actual subchunk size  S'  to ceil(( L  + 1) /  T ). 
 Recursively call  insert-chunk  with  chunk'  = the last floor(( S  - 1) / 2) keys of  chunk  and  H'  =  H  - 1. 
 For each of the ceil( L  /  S' ) subchunks (of size  S' ) except for the last with index  I :
 
 Recursively call  insert-chunk  with  chunk'  = the first ceil(( S  - 1) / 2) keys of subchunk  I  and  H'  =  H  - 1. 
 Insert the last key of subchunk  I  into  T  (this insertion purposefully triggers a split). 
 Recursively call  insert-chunk  with  chunk'  = the remaining keys of subchunk  I  (if any) and  H'  =  H  - 1. 
 
 Recursively call  insert-chunk  with  chunk'  = the remaining keys of the last subchunk and  H'  =  H  - 1. 
 
 Note that the recursive procedure is called twice for each subtree; that is fine, because the first call always creates a perfectly filled half subtree. 
 
 Here is a way which would lead to minimum height in any BST (including b tree) :- 
 
 
 sort array 
 Say you can have m key in b tree 
 Divide array recursively in m+1 equal parts using m keys in parent. 
 construct the child tree of n/(m+1) sorted keys using recursion. 
 
 
 example  : - 
 
 
 So is this about optimising the creation procedure, or optimising the tree? 
 You can clearly create a maximally efficient B-Tree by first creating a full Balanced Binary Tree, and then contracting nodes. 
 At any level in a binary tree, the gap in numbers between two nodes contains all the numbers between those two values by the definition of a binary tree, and this is more or less the definition of a B-Tree. You simply start contracting the binary tree divisions into B-Tree nodes. Since the binary tree is balanced by construction, the gaps between nodes on the same level always contain the same number of nodes (assuming the tree is filled). Thus the BTree so constructed is guaranteed balanced. 
 In practice this is probably quite a slow way to create a BTree, but it certainly meets your criteria for constructing the optimal B-Tree, and the literature on creating balanced binary trees is comprehensive. 
 ===================================== 
 In your case, where you might take an off the shelf "better" over a constructed optimal version, have you considered simply changing the number of children nodes can have? Your diagram looks like a classic 2-3 tree, but its perfectly possible to have a 3-4 tree, or a 3-5 tree, which means that every node will have at least three children. 
 
 Your question is about btree optimization. It is unlikely that you do this just for fun. So I can only assume that you would like to optimize data accesses - maybe as part of database programming or something like this. You wrote: "When searching the BTree, it is paged on demand from disk into memory", which means that you either have not enough memory to do any sort of caching or you have a policy to utilize as less memory as possible. In either way this may be the root cause for why any answer to your question will not be satisfying. Let me explain why. 
 When it comes to data access optimization, memory is your friend. It does not matter if you do read or write optimization you need memory. Any sort of write optimization always works on the assumption that it can read information in a quick way (from memory) - sorting needs data. If you do not have enough memory for read optimization you will not have that for write optimization too. 
 As soon as you are willing to accept at least some memory utilization you can rethink your statement "When searching the BTree, it is paged on demand from disk into memory", which makes up room for balancing between read and write optimization. A to maximum optimized BTREE is maximized write optimization. In most data access scenarios I know you get a write at any 10-100 reads. That means that a maximized write optimization is likely to give a  poor performance in terms of data access optimization. That is why databases accept restructuring cycles, key space waste, unbalanced btrees and things like that... 
 