*** how-to-make-a-uuid-in-dynamodb ***

 In my db scheme, I need a autoincrement primary key. How I can realize this feature?  
 PS For access to DynamoDB, I use  dynode , module for Node.js.  
 
 Disclaimer: I am the maintainer of the Dynamodb-mapper project 
 Intuitive workflow of an auto-increment key: 
 
 get the last counter position 
 add 1 
 use the new number as the index of the object 
 save the new counter value 
 save the object 
 
 This is just to explain the underlying idea. Never do it this way because it's not atomic. Under certain workload, you may allocate the same ID to 2+ different objects because it's not atomic. This would result in a data loss. 
 The solution is to use the  **atomic ADD**
 operation along with  **ALL_NEW**
 of  UpdateItem : 
 
 atomically generate an ID 
 use the new number as the index of the object 
 save the object 
 
 In the worst case scenario, the application crashes before the object is saved but never risk to allocate the same ID twice. 
 There is one remaining problem: where to store the last ID value ? We chose: 
 
 Of course, to work reliably, all applications inserting data MUST be aware of this system otherwise you might (again) overwrite data. 
 the last step is to automate the process. For example:  
 
 For implementation details (Python, sorry), see  https://bitbucket.org/Ludia/dynamodb-mapper/src/8173d0e8b55d/dynamodb_mapper/model.py#cl-67 
 To tell you the truth, my company does not use it in production because, most of the time it is better to find another key like, for the user, an ID, for a transaction, a datetime, ... 
 I wrote some examples in  dynamodb-mapper's documentation  and it can easily be extrapolate to Node.JS 
 If you have any question, feel free to ask. 
 
 If you're okay with gaps in your incrementing id, and you're okay with it only roughly corresponding to the order in which the rows were added, you can roll your own: Create a separate table called NextIdTable, with one primary key (numeric), call it Counter. 
 Each time you want to generate a new id, you would do the following: 
 
 Do a GetItem on NextIdTable to read the current value of Counter --> curValue 
 Do a PutItem on NextIdTable to set the value of Counter to curValue + 1.  Make this a conditional PutItem so that it will fail if the value of Counter has changed.   
 If that conditional PutItem failed, it means someone else was doing this at the same time as you were.  Start over.   
 If it succeeded, then curValue is your new unique ID. 
 
 Of course, if your process crashes before actually applying that ID anywhere, you'll "leak" it and have a gap in your sequence of IDs.  And if you're doing this concurrently with some other process, one of you will get value 39 and one of you will get value 40, and there are no guarantees about which order they will actually be applied in your data table; the guy who got 40 might write it before the guy who got 39.  But it does give you a rough ordering. 
 Parameters for a conditional PutItem in node.js are detailed here.   http://docs.aws.amazon.com/AWSJavaScriptSDK/latest/frames.html#!AWS/DynamoDB.html .  If you had previously read a value of 38 from Counter, your conditional PutItem request might look like this. 
 
 
 Another approach is to use a   generator for primary keys, as these are  highly  unlikely to clash.  
 IMO you are more likely to experience errors consolidating primary key counters across highly available   tables than from clashes in generated  s. 
 For example, in Node: 
 
 
 Taken from SO  answer . 
 
 I don't believe it is possible to to a SQL style auto-increment because the tables are partitioned across multiple machines. I generate my own UUID in PHP which does the job, I'm sure you could come up with something similar  like this  in javascript.   
 
 For those coding in Java,  DynamoDBMapper  can now generate unique UUIDs on your behalf. 
 
 DynamoDBAutoGeneratedKey 
 Marks a partition key or sort key property as being auto-generated.
  DynamoDBMapper will generate a random UUID when saving these
  attributes. Only String properties can be marked as auto-generated
  keys. 
 
 Use the  DynamoDBAutoGeneratedKey  annotation like this 
 
 As you can see in the example above, you can apply both the DynamoDBAutoGeneratedKey and DynamoDBHashKey annotation to the same attribute to generate a unique hash key. 
 
 Addition to @yadutaf's answer 
 AWS supports  Atomic Counters . 
 Create a separate table ( ) with a row holding the latest order_number: 
 
 This will allow to increment order_number by   and get the incremented result in a callback from AWS DynamoDB: 
 
 ðŸ›ˆ Be aware that in some  rare  cases their might be problems with the connection between your caller point and AWS API. It will result in the dynamodb row being incremented, while you will get a connection error. Thus, there might appear some unused incremented values. 
 You can use incremented   in your table, e.g. to insert   into   table. 
 
 I've had the same problem and created a small web service just for this purpose. See this blog post, that explains how I'm using  stateful.co  with DynamoDB in order to simulate auto-increment functionality:  http://www.yegor256.com/2014/05/18/cloud-autoincrement-counters.html 
 Basically, you register an atomic counter at  stateful.co  and increment it every time you need a new value, through RESTful API. The service is free. 
 
 Create the new   and put this code: 
 
 Then you can apply this function to the primary key id. It will generate the UUID. 
 
 Auto Increment is not good from performance perspective as it will overload specific shards while keeping others idle, It doesn't make even distribution if you're storing data to Dynamodb. 
  looks like its actually V.4 UUID (Random), code snippet below to try it:  
 
 In case you want to generate this yourself, you can use  https://www.npmjs.com/package/uuid  or  Ulide  to generate different versions of UUID based on  RFC-4122   
 
 V1 (timestamp based) 
 V3 (Namespace)  
 V4  (Random)  
 
 For Go developers, you can use these packages from  Google's UUID ,   Pborman , or  Satori . Pborman is better in performance, check these  articles and benchmarks  for more details.  
 More Info on Universal Unique Identifier Specification could be found  here .  
 