*** how-to-select-bottom-most-rows ***

 I can do SELECT TOP (200) ... but why not BOTTOM (200)? 
 Well not to get into philosophy what I mean is, how can I do the equivalent of TOP (200) but in reverse (from the bottom, like you'd expect BOTTOM to do...)? 
 
 
 
 It is unnecessary. You can use an   and just change the sort to   to get the same effect. 
 
 Sorry, but I don't think I see any correct answers in my opinion.  
 The   x function shows the records in undefined order. From that definition follows that a   function can not be defined. 
 Independent of any index or sort order. When you do an   you get the rows with the highest y value first. If this is an autogenerated ID, it should show the records last added to the table, as suggested in the other answers. However: 
 
 This only works if there is an autogenerated id column 
 It has a significant performance impact if you compare that with the   function 
 
 The correct answer should be that there is not, and cannot be, an equivalent to   for getting the bottom rows. 
 
 Select Bottom 1000 from Employee 
 
 
 The currently accepted answer by "Justin Ethier" is not a correct answer as pointed out by "Protector one". 
 As far as I can see, as of now, no other answer or comment provides the equivalent of BOTTOM(x) the question author asked for. 
 First, let's consider a scenario where this functionality would be needed: 
 
 This returns a table of one column and five records: 
 
 apple 
 orange 
 banana 
 apple 
 lime 
 
 As you can see: we don't have an ID column; we can't order by the returned column; and we can't select the bottom two records using standard SQL like we can do for the top two records. 
 Here is my attempt to provide a solution: 
 
 And here is a more complete solution: 
 
 I am by no means claiming that this is a good idea to use in all circumstances, but it provides the desired results. 
 
 It would seem that any of the answers which implement an ORDER BY clause in the solution is missing the point, or does not actually understand what TOP returns to you. 
 TOP returns an unordered query result set which limits the record set to the first N records returned. (From an Oracle perspective, it is akin to adding a where ROWNUM < (N+1). 
 Any solution which uses an order,  may  return rows which also are returned by the TOP clause (since that data set was unordered in the first place), depending on what criteria was used in the order by 
 The usefulness of TOP is that once the dataset reaches a certain size N, it stops fetching rows. You can get a feel for what the data looks like without having to fetch all of it. 
 To implement BOTTOM accurately, it would need to fetch the entire dataset unordered and then restrict the dataset to the final N records. That will not be particularly effective if you are dealing with huge tables. Nor will it necessarily give you what you  think  you are asking for. The end of the data set may not necessarily be "the last rows inserted" (and probably won't be for most DML intensive applications). 
 Similarly, the solutions which implement an ORDER BY are, unfortunately, potentially disastrous when dealing with large data sets. If I have, say, 10 Billion records and want the last 10, it is quite foolish to order 10 Billion records and select the last 10. 
 The problem here, is that BOTTOM does not have the meaning that we  think of  when comparing it to TOP. 
 When records are inserted, deleted, inserted, deleted over and over and over again, some gaps will appear in the storage and later, rows will be slotted in, if possible. But what we often see, when we select TOP,  appears  to be sorted data, because it may have been inserted early on in the table's existence. If the table does not experience many deletions, it may  appear  to be ordered. (e.g. creation dates may be as far back in time as the table creation itself). But the reality is, if this is a delete-heavy table, the TOP N rows may not look like that at all. 
 So -- the bottom line here(pun intended) is that someone who is asking for the BOTTOM N records doesn't actually know what they're asking for. Or, at least, what they're asking for and what BOTTOM actually means are not the same thing. 
 So -- the solution may meet the actual business need of the requestor...but does not meet the criteria for being the BOTTOM. 
 
 All you need to do is reverse your  . Add or remove   to it. 
 
 The problem with ordering the other way is that it often does not make good use of indices. It is also not very extendable if you ever need to select a number of rows that are not at the start or the end. An alternative way is as follows. 
 
 
 "Tom H" answer above is correct and it works for me in getting Bottom 5 rows. 
 
 Thanks. 
 
 try this.  
 
 
 I've come up with a solution to this that doesn't require you to know the number of row returned.  
 For example, if you want to get all the locations logged in a table, except the latest 1 (or 2, or 5, or 34) 
 
 
 Querying a simple subquery sorted descending, followed by sorting on the same column ascending does the trick. 
 
 
 
 Where ID is the primary key of the TABLE1. 
 
 First, create an index in a subquery according to the table's original order using:  
 
 Then order the table descending by the   column you've created in the main query:  
 
 And finally use   with your wanted quantity of rows: 
 
 