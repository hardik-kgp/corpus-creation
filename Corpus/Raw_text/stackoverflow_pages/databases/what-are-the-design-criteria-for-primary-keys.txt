*** what-are-the-design-criteria-for-primary-keys ***

 Choosing good primary keys, candidate keys and the foreign keys that use them is a vitally important database design task -- as much art as science. The design task has very specific design criteria. 
 What are the criteria? 
 
 The criteria for consideration of a primary key are: 
 
 **Uniqueness**
  
 **Irreducibility**
 (no subset of the key uniquely identifies a row in the table) 
 **Simplicity**
 (so that relational representation & manipulation can be simpler) 
 **Stability**
 (should not be altered frequently)  
 **Familiarity**
 (meaningful to the user) 
 
 
 **What is a Primary Key?**

 The primary key is something that uniquely identifies a row/record of data.  It can also be multiple columns, which is called a composite.  
 **Ability to Change**

 Because the primary key is often used for foreign references, it should be as stable as possible.  All data in the database is mutable, providing someone is connecting with an account that has appropriate privileges.  This is why databases provide the ability to define CASCADE ON DELETE and CASCADE ON UPDATE--to sync referential dependencies without having to disable constraints. 
 **Natural or Artifical/Surrogate?**

 Ideally, you want a natural key. A natural key is existing data that uniquely identifies the entity you are modeling. For example, the abbreviations of US states is a good natural key because the abbreviation is consistent and everyone knows them: 
 
 Don't try too hard to find a natural key.  They seldom exist.  It's unlikely that a US State name would change, but it is plausible. 
 Realistically, primary keys will typically be artificial (often generated by database functionality). These are typically numbers or GUIDs, and they're considered artificial because on their own - there's nothing to relate their value to the information they uniquely identify. A sales receipt is always numbered, because there's nothing natural about it and it's also for auditing - gaps in the receipt numbers raise suspicions.  To demonstrate how arbitrary numbering is, here's the US state table but using an integer for the primary key column, US_STATE_CODE: 
 
 There's no requirement to start the value at one; some shops use this as a security measure to thwart SQL injection.  The value is sequential based on the alphabetic ordering of the State name, but that can't be guaranteed.  But unlike the natural key, if the state name changed - only one column would have to be updated. 
 **Single Column vs Composite**

 Ideally one column will be the primary key, but make the decision based on the data at hand--do not combine columns just for the sake of having a single column.  If you do shoehorn data together, use a character to separate the data easily (though operations to do this won't be able to take advantage of an index if present). 
 **Performance**

 From a performance perspective, integers are best because they offer a decent range of values and the number of bytes used is small when you compare to VARCHAR of five or more characters. 
 
 Database design starts with a conceptual data model (such as an entity relationship diagram) and finishes up with a database schema or schemas.  Entities are mapped to tables; in this process one entity may be split into several table, several entities may be merged into a single table and new tables may arise (for instance, intersection tables to implement many-to-many relationships). 
 In an ERD entities have primary keys.  These are natural keys, that is they are attributes of the entity.  For a PERSON entity it might be SocialSecurityNumber.  For an ORDER entity if might be OrderRef  For an INVOICE entity it might be InvoiceNo.  In the first case that is a real-life identifier; in the second case it is a smart key in an ugly format (2010/DEF/000023 ); in the third case it is a monotonically incrementing number because that is what the current paper-based system uses. 
 Natural keys can be fanciful.  I once worked on a database design where the analyst had specified the CUSTOMER entity with a key of (FullName, Address, Sex, DateOfBirth, DistinguishingCharacteristics) on the basis that two individuals of the same name, birth date and gender could live at the same address. 
 The characteristics of an entity's primary key are: 
 
 unique 
 familiar 
 stable (presumed) 
 minimal (one or more attributes but as few as necessary)  
 
 When it comes to primary keys for database tables, natural keys are not always suitable.    
 There are many reasons not to use SSN as a physical primary key.  Protection of a citizen's personal data is actually the most important but it is also the case that an individual's number can change.  Primary keys should be unvarying.   
 Smart keys are dumb.  They are actually compound keys compressed into a single column.  They are better represented as separate columns, not least because it is a frequent requirement to search on single elements of the key.  Also, the format of such keys can change. 
 In general compound keys are a pain as primary keys because we have to cascade multiple columns as foreign keys.  This is exacerbated when the child's primary key is defined as a serial number within the parent's primary key. There are systems out there which dependent tables inheriting a nine-column foreign key from a parent when they have a scant two data columns of their own.  Sometimes this sort of inheritance can be useful but mostly it is a just a hassle. 
 The characteristics of an entity's primary key are: 
 
 unique 
 appropriate (meaningless) 
 guaranteed stability 
 minimal, usually a single column (except for intersection tables)  
 
 So unless the candidate key is a meaningless identifier (such as InvoiceNo) a table should have a synthetic key (AKA surrogate key).  This can be a monotonically incrementing number or a GUID according to your needs.  Regarding intersection tables, if they have no other attributes or dependent tables there is no value in replacing a compound primary key (AKA composite key) with a synthetic one. 
 The crucial thing is: we still  enforce the candidate keys .  This means applying UNIQUE constraints on those columns - SSN , OrderRef - in the parent table.  This is because a synthetic key uniquely identifies a row in a table, it does not uniquely identify the data.  
 
 **Regarding familiarity**

 Familiarity is a curly one.  It is an important consideration when it comes to we are identifying primary keys in a conceptual data model but it is less useful when it comes to database design.    
 In a commnet @bbadour provides two contrasting examples: 
 
 and poses the question: 
 "What does 3296013 achieve that was not already achieved by 840082470, which happens to be the primary key for my academic records at any or every post-secondary school in Canada."  
 Well, 840082470 is like a invoice number.  Of itself it is a meaningless string of digits.  If the system we are designing belongs to the domain of Canadian higher education then it is certainly acceptable as a candidate key. However, because it is a key apparently owned by an external central system (forgive me for not understanding the Canadian academic system), it is open to some of the objections to SSN as a primary key.  We are reliant on that external system to ensure uniqueness, guarantee stability and verify identification. 
 As for  745  versus  PE,CA , that is clearly wrong.  The Canadian postal abbreviation for "Prince Edward Island" and the ISO digraph for "Canada" identify two distinct pieces of information and derive from different sources,  so they should be represented as two separate columns.  But let us focus on whether  745  or  PE  makes the better primary key. 
 First thing, the database doesn't care which data type we use for the code to represent "Prince Edward Island".  It just wants guaranteed uniqueness. 
 Second thing, the user-facing part of the system is likely to display the full expansion "Prince Edward Island", in which case the application is going to need to execute a look-up anyway.  This is because users of a system which also holds addresses from the country of Peru or the state of California will appreciate the clarity of the expanded names[1].  Certainly if we go beyond the few hard cases (such as state abbreviations) the application should always expand codes when displaying them to users.  
 Thus the only advantage of using  PE  rather than  745  is that it makes ad hoc querying easier.    
 Third thing, if the code expansion changes we might want to distinguish records which use the newer version.  This is a lot easier if   and   than if we use PE as the primary key.   
 Fourth thing, there are programming considerations.  For instance, if the application developers have to provide drop-down lists using Java Enumerations they need numeric codes.   
 In short, familiarity of natural keys is not as useful as the practicality of surrogate keys.      
 [1]  Canadians will know that CA stands for Canada.  But does MO stand for Morocco, Monaco, Moldova, Montenegro, Mongolia or Montserrat?  Actually none of them: it's Macau. 
 
 A Primary Key is a key that uniquely identifies an entity. When you are choosing a primary key, the best choice is almost always a surrogate key that has absolutely nothing to do with the entity at all other than uniquely identifying it. 
 And that's it. There are supposedly rare edge cases where a primary key might be a natural key, but I've never seen a valid one.  
 Most of us use a 32-bit auto-increment integer as a primary key. Another excellent choice (in certain circumstances) is a UUID.  
 
 A candidate key is a set of attributes that are irreducibly unique (irreducible meaning that no attribute can be removed from the key without losing the uniqueness property). 
 Other criteria when choosing what candidate keys to implement are: simplicity, stability, familiarity. 
 These three criteria are important considerations but not necessarily essential attributes of a key. For instance it may be desirable and quite reasonable to enforce a key that can change often. e.g.: a user login name is required to be unique but the user may change it at will as long as it remains unique. 
 A primary key is a candidate key. 
 
 Hey.  it's open again.  Here goes. 
 (1) Choose good candidate keys. 
 It does not pertain to the database designer to choose candidate keys.
The database designer has the responsibility to see to it that all the
uniqueness requirements he is informed of by the user, will be enforced.
So it is the user who "chooses" what the candidate keys are. 
 There are two scenario's I can think of that relax this unequivocal
position a bit. 
 One is if the user says that some attribute of type 'video' or 'audio' (or
some such) is to be unique.  It may be infeasible to actually enforce
that, and it is the designer's responsibility to point that out to the
user (as it is also his responsibility to point out that 'uniqueness' of
audio and video content is a very debatable subject, and that any
uniqueness on such attribute values, even if enforcible by the system,
still has a good chance of not being the same uniqueness that the user
wants). 
 Second is how the picture gets muddied by the possibility of distinct
logical designs all addressing the same problem.  If D1 and D2 are both
valid designs addressing the same problem, then it might be the case that
a certain given uniqueness rule imposed by the user, is enforcible using
keys in D1, but not in D2.  From this perspective, "choosing candidate
keys" can be interpreted as "choosing a particular design such that a
given uniqueness rule is enforcible using keys".  But that wasn't really
the question that you asked. 
 (2) Choose good primary keys. 
 A while ago, Darwen launched the question "What are good reasons to single
out one particular candidate from among the others as being 'primary' ?".
Nothing much came out, except then perhaps : "to suggest that this
particular key is the preferred one to use whenever making references to
this relvar".  I suspect they didn't find that convincing enough to change
their earlier decision that "no key is more unique than any other". 
 But, supposing that nonetheless there exists some valid reason to single
out one particular key as "primary", I suppose the following
considerations apply : 
 
 the likeliness, or appropriateness, of using this primary key also as,
e.g., the clustering key in the physical design. 
 and as a consequence of that, the probability of having to change a
value of some existing primary key.  Key values that are highly stable
will be preferable over key values that are more volatile. 
 the percentage of the business that naturally uses some such key in
their daily operations. 
 if the required space for physically encoding key values is
significantly different, which one has the smallest encoding size. 
 
 
 Your answer to Erwin:
"I agree that choosing a primary key merely designates one candidate key as preferred for foreign key references. However, even if we eliminated the name "primary key" entirely, designers must still choose which candidate key to propagate into another relation for reference purposes. If users identify a heavily referenced relation with an unstable, composite key, do you intend to imply that the designer has no business choosing an additional simple, stable key? Or using the simple, stable key for referencing the relation? Your candidate key section seems to imply that. – bbadour 8 hours ago " 
 Your original question was about 'primary keys'. Now you change your focus to keys and foreign keys. A key is an integrity constraint, so the only criteria are that a minimal set of attributes has to be unique in a relation (uniqueness and irreducibility). If we change our focus to foreign keys then simplicity, stability and familiarity are the criteria to choose from all the candidate keys in de referenced relation. There could be more candidate keys that fulfill that criteria to more or less the same extend. If we look at familiarity, one candidate key could be very familiar to a group of users and not to another group for which another candidate key is more familiar. Think about different views or subschemas of a database. This second group of users should choose a different candidate key for reference purposes (as foreign key). If you insist in 'primary keys' of which we only have one per relation then I have to ask what makes a key more primary than others. 
I think the term primary key should not be used. At least at the logical level. Also the term 'foreign keys' is not well chosen (foreign keys are not keys, but references). 
 So, I think the remarks of Erwin about ‘primary’ keys were very much to the point. Or at least this was my interpretation of what he means. 
 Do you agree with this?
If so, would you change your original question to "What are the design criteria for keys and what are the criteria to choose a foreign key from the available candidate keys?"?
If not, why? 
 Regards,
Carlos 
 
 A primary key is a candidate key chosen for special treatment, so first we must look at the properties of candidate keys. A set of one or more columns is a candidate key if it has the following two properties: 
 Uniqueness: A candidate key must uniquely identify each row in a table. No table may contain two rows with the same value for the candidate key. 
 Irreducability: Removing any column from a candidate key must violate the uniqness property. In other words, no subset of columns in a candidate key is itself a candidate key. 
 If no candidate key exists, and sometimes even if one does, a surrogate key is often created using an auto-incrementing integer column, or made up using some other technique. This surrogate key is now also a candidate key.  
 It is often useful to choose among the available candidate keys and to designate one of them as the primary key. The first criteria often applied is simplicity indicating the candidate key with the fewest columns. However there are other potential criteria, like familiarity, familiar values being more useful than non-familiar values, and stability, stable keys being less troublesome than keys that are apt to change. These criteria however, are strictlty outside the scope the relational model, often conflict with each other, and are often made to deal with implementation limitations. 
 I would say that the first two concepts "uniqueness" and "irreducability" are less design criteria than fundamental properties of primary keys, while the latter concepts of "simplicity", "familiarity" and "stability" are more properly labeled design criteria, as they involve tradeoffs and subjectivity. 
 Why choose a primary key?  Simplicity and familiarity are not only criteria for choosing among available candididate keys, but are why we should choose a primary key at all. If there are are multiple candidate keys in a table, it simplifys things if all foreign keys pointing to that table refer to the same candidate key. Furthermore, the very act of choosing a particular candidate key will help make it familiar.    
 
 
 What are the criteria? 
 
 A   is something that will define the entity, only the entity and nothing but the entity. 
 
 You can take it from the outside world. Say, a star catalog number to identify a star (good example), or an   to identify a person (bad example). 
 In this case, you rely on the outside world. 
 
 Do all people have  ? (They don't). 
 Are  's unique? (They aren't). 
 Can an   be assigned to another person? (It can). 
 
 You can generate it inside your model, using   or   or whatever. 
 In this case, you rely on yourself and your database skills. 
 
 Do all people in your model have an  ? (Yes, they do, otherwise they wouldn't be in the table with  ). 
 Are these   unique? (Yes, they are, the   constraint takes care of it). 
 Can they be assigned to other persons? (No, they cannot, they are either non-repeatable by design or auto incrementing). 
 
 Or another set of answers: 
 
 Do all people in your model have an  ? (No, they don't, the people table was accidentally dropped, though some other information retained). 
 Are these   unique? (No, we failed to merge two versions of the database properly). 
 Can they be assigned to other persons? (Yes, we reset the   by mistake). 
 
 
 The most important thing is that a surrogate key is a feast that is always with you. You can always create a surrogate key: nothing on Earth can stop you from declaring an   field. But by far not all things have some kind of identifier everybody agrees upon. 
 However, a good natural key cannot be overemphasized. 
  database is most probably backed up more reliably than yours, and the list of   state codes you always can restore right from the memory. 
 
 Only one really, choose a surrogate for each table (identity/auto_number) or something similar that the users will never even see so you can do whatever is necessary with them whenever you need to now and in the future. 
 
 (Not quite sure how to interpret this question. Sounds like a quiz or something where you are looking for one single "right" answer from a textbook. I'm going to interpret the question as a more practical one, hence my advice below.) 
 At least in the MS SQL world, discussion about a proper Primary Key is inevitably wrapped up in discussion about the proper  clustered index  for a table. The two don't  have  to be the same, but they are by default, and for many tables, making the two the same is often a good idea. 
 For the purpose of our discussion here, its important to distinguish between the two: 
 A  **PRIMARY KEY**
 is a field or combination of fields that uniquely identify a row. 
A  **CLUSTERED INDEX**
 is a field or combination of fields that represents the physical ordering of a table. (Again, I am speaking about MS SQL Server, not sure how other RDBS might handle this) 
 Key to the remainder of my discussion is knowing that since SQL 7.0, the  clustered index key  is used as a row identifier for all  non-clustered indexes . This means that many of the same criteria for choosing a good clustering key are the same as for choosing a good primary key. 
 Let's first look at the criteria for a good clustered index (From  Kimberly Tripp's excellent article ). A clustered index should be: 
 
 **Unique**
 - otherwise useless as a row identifier for other indexes 
 **Narrow**
 - this key is used in other indexes, so should be as narrow as possible 
 **Static**
 - If key values change, then references become invalid and will need updating 
 **Ever-increasing**
 - To reduce physical table fragmentation as new rows are added 
 
 It is readily apparent the first 3 are also good criteria for a primary key. #4 is a bonus that will reduce table fragmentation as tables grow. 
 A GUID as a primary key, as popular as that is, actually fails 2 of these criteria (Narrow and Ever-Increasing). As such, it is not recommended as a PK/Clustered index in most circumstances (see Kim's  related article here ) 
 
 I'm going to say something here that is not expected. 
 All the stuff they teach in database about normalization and keys is all wrong when it comes to choosing primary keys. 
 The primary key is special when it comes to range queries, and for that reason if you have a dominant range query that is your primary key, no exceptions. 
 If your dominant range query is not on a candidate key you end up with a primary key that is not enforced for uniqueness! This is sometimes called a clustered index, which is a misnomer because there is no index. 
 Now the normalization and candidate keys are all important, and you will want to enforce unique constraints on at least some of them. But do not assign the primary key because it is the natural key. In fact, this is slower than defining an index and a unique constraint. Define the primary key based on range queries only. 
 Remember, there is no constraint to actually have primary keys. A table with no primary keys is called a heap table and has either no intrinsic ordering or insertion order intrinsic ordering. 
 EDIT: definition of range query: 
       A range query is a query that is an ORDER BY query or contains either a greater than or less than operator.  What we are interested in are the columns for which these queries run on. The fundamental idea is a range query fetches several (tens to hundreds to perhaps thousands but not all) rows from the table based on bounding conditions at one or both ends. 
       There is another kind of range queries, and that is where you have a foreign key to another table and an operation is select all matching on that foreign key. This is in fact also a range query although not obviously so. 
 