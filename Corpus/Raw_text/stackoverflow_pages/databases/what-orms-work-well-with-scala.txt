*** what-orms-work-well-with-scala ***

 
 
 
 
 
 
 
 
                            As it currently stands, this question is not a good fit for our Q&A format. We expect answers to be supported by facts, references,   or expertise, but this question will likely solicit debate, arguments, polling, or extended discussion. If you feel that this question   can be improved and possibly reopened,  visit the help center  for guidance.
                            
                         
 
 
 Closed  7 years ago . 
 
 
 I'm about to write a Scala command-line application that relies on a MySQL database. I've been looking around for ORMs, and am having trouble finding one that will work well. 
 The  Lift ORM  looks nice, but I'm not sure it can be decoupled from the entire Lift web framework. ActiveObjects also looks OK, but the author says that it may not work well with Scala. 
 I'm not coming to Scala from Java, so I don't know all the options. Has anyone used an ORM with Scala, and if so, what did you use and how well did it work? 
 
 There are several reasons why JPA-oriented frameworks (Hibernate, for instance) do not fit into idiomatic Scala applications elegantly: 
 
 there are no nested annotations as states the  Scala 2.8 Preview  -- that means you cannot use annotations as mapping metadata for complex applications (even the simplest ones often use   ->  ); 
 inconsistencies between Scala and Java collections make developers convert collections; there are also cases when it is impossible to map Scala collections to associations without implementing complex interfaces of the underlying framework (Hibernate's  , for example); 
 some very common features, such as domain model validation, require JavaBeans conventions on persistent classes -- these stuff is not quite "Scala way" of doing things; 
 of course, the interop problems (like Raw Types or proxies) introduce a whole new level of issues that cannot be walked around easily. 
 
 There are more reasons, I'm sure. That's why we have started the  Circumflex ORM project . This pure-Scala ORM tries it's best to eliminate the nightmares of classic Java ORMs. Specifically, you define your entities in pretty much way you would do this with classic DDL statements: 
 
 As you can see, these declarations are a bit more verbose, than classic JPA POJOs. But in fact there are several concepts that are assembled together: 
 
 the precise DDL for generating schema (you can easily add indexes, foreign keys and other stuff in the same DSL-like fashion); 
 all queries can be assembled inside that "table object" instead of being scattered around in DAO; the queries themselves are  very  flexible, you can store query objects, predicates, projections, subqueries and relation aliases in variables so you can reuse them, and even make batch update operations from existing queries (insert-select for example); 
 transparent navigation between associations (one-to-one, many-to-one, one-to-many and many-to-many-through-intermediate-relation) can be achieved either by lazy or by eager fetching strategies; in both cases the associations are established on top of the foreign keys of underlying relations; 
 validation is the part of framework; 
 there is also a Maven2 plugin that allows generating schema and importing initial data from handy XML formatted files. 
 
 The only things Circumflex ORM lacks are: 
 
 multi-column primary keys (although it is possible to create multi-column foreign keys backed by multi-column unique constraints, but it is only for data integrity); 
 full-fledged documentation (although we are actively working on it); 
 success stories of ten-billion-dollar production systems that have Circumflex ORM as it's core technology. 
 
 P.S. I hope this post will not be considered an advertisement. It isn't so, really -- I was trying to be as objective as possible.  
 
 I experimented with  EclipseLink JPA  and basic operations worked fine for me.  JPA is a Java standard and there are other implementations that may also work ( OpenJPA , etc). Here is an example of what a JPA class in Scala looks like: 
 
 
 I am happy to announce the 1st release of a new ORM library for Scala. MapperDao maps domain classes to database tables. It currently supports mysql, postgresql (oracle driver to be available soon), one-to-one, many-to-one, one-to-many, many-to-many relationships, autogenerated keys, transactions and optionally integrates nicely with spring framework. It allows freedom on the design of the domain classes which are not affected by persistence details, encourages immutability and is type safe. The library is not based on reflection but rather on good Scala design principles and contains a DSL to query data, which closely resembles select queries. It doesn't require implementation of equals() or hashCode() methods which can be problematic for persisted entities. Mapping is done using type safe Scala code. 
 Details and usage instructions can be found at the mapperdao's site: 
 http://code.google.com/p/mapperdao/ 
 The library is available for download on the above site and also as a maven dependency (documentation contains details on how to use it via maven) 
 Examples can be found at: 
 https://code.google.com/p/mapperdao-examples/ 
 Very brief introduction of the library via code sample: 
 
 Querying is very familiar: 
 
 I encourage everybody to use the library and give feedback. The documentation is currently quite extensive, with setup and usage instructions. Please feel free to comment and get in touch with me at kostas dot kougios at googlemail dot com. 
 Thanks, 
 Kostantinos Kougios 
 
 Here's basically the same example with @Column annotation: 
 
 
 Slick  is a perfect match for a functional world. Traditional ORM's are not a perfect fit for Scala. Slick composes well and uses a DSL that mimics Scala collection classes and for comprehensions. 
 
 Of course, any Java database access framework will work in Scala as well, with the usual issues that you may encounter, such as collections conversion, etc. jOOQ for instance, has been observed to work well in Scala. An example of jOOQ code in Scala is given in the manual: 
 
 Taken from
 http://www.jooq.org/doc/2.6/manual/getting-started/jooq-and-scala/ 
 