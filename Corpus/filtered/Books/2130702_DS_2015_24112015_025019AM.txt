linear data structure prof pradyumansinh jadeja   data structure  program gcd recursion write algorithm factorial recursion algorithm factorial integer algorithm computes factorial stack store activation record assoc iated recursive activation record current current return address ret_adde temp_rec record variables param address pointer element stack initially return address set main calling address param set initial include stdio int find_gcd int int void main int n1 gcd gcd find_gcd n1 int find_gcd int int int gcdval gcdval find_gcd  gcdval gcdval find_gcd return gcdval linear data structure prof pradyumansinh jadeja   data structure  difference recursion iteration iteration recursion iteration problem converted train steps finished time recursion piling steps quashing solution iteration step leads stepping stones river recursion step replicates smaller scale combined eventually solve problem iterative problem solved recursively recursive problem solved iteration stack stack  save return address push temp_rec  base criterion  factorial  step  param  address step  step   calculate factorial factorial  restore previous return address temp_rec pop param address ret_addr address linear data structure prof pradyumansinh jadeja   data structure  write algorithm nvert infix expression postfix expression symbol input precedence function stack precedence function rank function  variables algorithm revpol input string infix infix expression symbol precedence table vector stack nextchar invoked returns character argument algorithm converts infix reverse polish places result string polish integer variable denotes stack algorithm push pop stack manipulation integer variable rank accumulates rank expression finally string variable temp temporary storage purpose linear data structure prof pradyumansinh jadeja   data structure   initialize stack   initialize output string rank count polish rank   input symbol nextchar infix  ranslate infix expression  remove symbols greater precedence stack  exit repeat temp pop polish polish temp rank rank tem rank  exit  matching parentheses push pop  symbol nextchar infix  expression valid  rank  write linear data structure prof pradyumansinh jadeja   data structure  trace conversion infix postfix form tabular form input ymbol content stack reverse polish rank   postfix expression linear data structure prof pradyumansinh jadeja   data structure  input ymbol content stack reverse polish rank postfix expression linear data structure prof pradyumansinh jadeja   data structure  convert string prefix step  reverse infix expression step step  convert string postfix input ymbol content stack reverse polish rank   step  reverse postfix expression linear data structure prof pradyumansinh jadeja   data structure  translate string polish notation trace content stack step  reverse infix expression step step  convert string postfix input symbol content stack reverse polish rank step  reverse postfix expression linear data structure prof pradyumansinh jadeja   data structure  write algorithm evaluation postfix expression evaluation expression showing status stack tabular formalgorithm evaluae_postfix input string postfix representing postfix expression algorithm evaluate postfix expression result variable vector stack push pop function manipulation stack operand2 operand1 temporary variable temp temporary variable nextchar function invoked returns character perform_operation function perf orms required operation operand1 operand2  initialize stack    evaluate prefix expression repeat character temp nextchar postfix temp digit hen push temp lse operand  pop operand1 pop perform_operation operand1 operand2 temp push pop  return answer stack return pop linear data structure prof pradyumansinh jadeja   data structure  evaluate evaluatestack read push operands    read operator pop values stack opn2  opn1  push answer  read operator pop values stack opn2  opn1  push answer read push operands    read operator pop values stack opn2  opn1  push answer   read operator pop values stack opn2  opn1  push answer  read operator pop values stack opn2  opn1  push answer  poped  answer    stack read push operands    read operator pop values stack opn2  opn1  push answer  read operator pop values stack opn2  opn1  push answer read push operands    read operator pop values stack opn2  opn1  push answer   read operator pop values stack opn2  opn1  push answer  read operator pop values stack opn2  opn1  push answer  poped  answer linear data structure prof pradyumansinh jadeja   data structure  arithmetic expression written postfix notation translate infix notation evaluate expression infix notation explain difference stack queue stack queue linear list insertion deletion element called stack linear list insertion deletion called queue insertion deletion element performed stack elements removed opposite order insertion insertion deletion element performed opposite queue elements removed order insertion stack called ast irst lifo list queue called fifo list accessible elements stack insertion element performed deletion performed rear stack arranging plates ordinary queue provisional store insertion operation referred push deletion operation referred pop insertion operation referred enqueue deletion operation referred dqueue function calling languages stack task schedul ing operating    stack read push operands    read operator pop values stack opn2  opn1  push answer  read operator pop values stack opn2  opn1  push answer read push operands    read operator pop values stack opn2  opn1  push answer   read operator pop values stack opn2  opn1  push answer  read operator pop values stack opn2  opn1  push answer  poped  answer linear data structure prof pradyumansinh jadeja   data structure  explain followi queue circular queue iii dqueue priority queue queue linear list permits deletion performed list insertion called queue list processed fifo fcfs served pattern queue deletion performed rear queue element inserted process add element nto queue called enqueue process removal element queue called dequeue familiar traditional queue checkout supermarket cash register person checkedout circular queue suitable method representing simple queue prevents excessive memory circular fashion  called circular queue standard queue data structure buffering problem occurs dequeue operation solve problem joining rear ends queue eue circular queue circular queue linear data structure fifo principle circular queue node connected node circle circular linked list fallow principle elements rear elements deleted queue rear pointers points array ins ertion rear deletion linear data structure prof pradyumansinh jadeja   data structure  iii queue queue double ended queue linear list insertion deletion performed structure variations dqueue input restricted dqueue inser tion output restricted dqueue deletion structure represented fig priority queue queue insert remove items position based property priority task processed referred priority queue fig represent priority queue jobs waiting computer priorities    attached jobs real time online batch job initiated priority inserted list jobs ith priorities jobs removed queue insertion rear deletion deletion insertion linear data structure prof pradyumansinh jadeja   data structure task identification priority fig priority queue viewed single queue insertion allowed position  priority  priority  priority  fig priority queue viewed viewed set queue linear data structure prof pradyumansinh jadeja   data structure  write algorithms basic primitive operations queue procedure qinsert_rear pointers rear elements queue queue consisting elements procedure inserts rear queue function qdelete_front pointers rear elements queue queue consisting elements function deleted element queue  unde rflow  return   denotes queue  decrement element  queue   increment pointer  return element return  return  overflow return  incremen rear pointer   insert element  pointer properly set   return linear data structure prof pradyumansinh jadeja   data structure  write algorithms basic primitive operations circular queue procedure cqinsert pointers rear elements circular queue circular queue consisting elements procedure inserts rear circular queue function cqdelete pointers rear elements circular queue circular queue consisting elements function deleted element circular queue temporary pointer variable  reset rear pointer    overflow return  insert element  pointer properly set   return linear data structure prof pradyumansinh jadeja   data structure  write algorithms basic primitive operations dqueue procedure dqinsert_front pointers rear elements queue queue consisting elements element procedure inserts queue procedure dqdelete_rear pointers rear elements queue queue correspond function deletes returns element queue temporary variable  overflow  return  return  decrement pointer   insert element return  underflow  return   delete element  queue  return  increment pointer   return linear data structure prof pradyumansinh jadeja   data structure   underflow  return   delete element  queue   decrement pointer  return element return linear data structure prof pradyumansinh jadeja   data structure  procedure queue_display rare pointers rear elements queue queue consist elements procedure display queue contents queue queue circular queue  memory cells  rear  queue _ _ _ queue peration place queue letters deleted queue queue letter deleted positions initial position queue  rear  queue  rear  letters deleted  rear  queue  rear  queue  rear  letter deleted  rear   check return  display content reaer write  return statement return linked list prof pradyumansinh jadeja   data structure   linear data structure linked storage representation applications sequential allocation method unacceptable characteristics unpredictable storage requirement extensive manipulation stored data linked allocation method storage result efficient computer storage computer time linked list sequential collection data items concept linked list simple data item linked list pointer memory allocation data item linked list data items linked list consecutive memory locati ons memory accessing data items easier data item address data item  linked list types linked list write short note singly circular doubly linked list advantages disadvantages singly circular doubly linked list linked list collection objects stored list form linked list sequence items objects item linked linked list primitive type data structure element dynamically allocated elements point define linear relationship elements linked list called nodes node things data pointer nex node linked list require memory compared array stores pointer node linked lists simplest common data structures implement data structures stacks queuesnull linked list linked list prof pradyumansinh jadeja   data structure  operations linked list insert insert position insert position insert ordered list delete traverse list print list copy linked list types linked list singly linked list basic type li nked list node data pointer node limitation singly linked list traverse direction forward direction circular linked list circular linked list singly linked list node points node list null pointers singly linked li traverse direction forward direction biggest advantage time saving node node directly points node good application circular linked list timesharing problem solved operating null singly linked list node info link data pointer node structure represent node struct node int info struct node link linked list prof pradyumansinh jadeja   data structure  doubly linked list node doubly linked list data pointers point previous lptr rptr node main advantage doubly linked list traverse direction forward reverse advantage doubly linked list delete node trouble pointers previous nodes node singly linked list removed pointer predecessor drawback doubly linked list requires memory compared singly linked list extra pointer point previous node image denote left nodes list left link node link node null indicating list direction  discuss advantages disadvantages linked list array advantages array  access element array directly random access easy  create data structures queues stacks null doubly linked list prev prev null node data pointer node structure represent node struct node int info struct node lptr struct node rptr rptr lptr info circular linked list pointer previous node linked list prof pradyumansinh jadeja   data structure   light memory usage compared structures disadvantages array  size fixed  dynamically esized languages  hard add remove elements  size elements  rigid structure rigid inflexible changeable advantages linked list  linked lists dynamic data structures grow shrink durin execution program  efficient memory utilization memory pre allocated memory allocated required deallocated free longer needed  insertion deletions easier efficient linked list provide flexibility inserting data item position deletion data item position  eleme nts linked list flexible primary data type user defined data types disadvantages linked list  random access allowed access elements sequentially starting node binary search linked lists  easily sorted  traverse   list average access element  complex create array  extra memory space pointer required element list  advantages disadvantages stack queue implemented linked list array advantages disadvantages stack queue implemented linked list array insertion deletion operation insertion deletion operations push pop operation stack insert delete operation queue case array elements list required insert element firs element  elements list moved room element case linked list accomplished interchanging pointers insertion deletions efficient performed lin ked list array linked list prof pradyumansinh jadeja   data structure  searching node node linked list required follow links node onwards desired node case array directly access node join split join linked list assigning pointer linked list node linked list assign null address node split linked list parts joining splitting arrays ore difficult compared linked list memory pointers linked list consume additional memory compared array size array fixed sized number elements limited stack queue size linked list dynamic changed easily flexible number elementsinsert location    array linked list insert location  change pointers insertion deletion operations array linked list linked list prof pradyumansinh jadeja   data structure   write algorithms singly linked list  insert position  insert position  insert order linked list  delete element  copy linked list ew assumptions assume typical element node consists fields field called info pointer field denoted link typical element denoted node node info link data pointer node structure represent node struct node int info struct node link linked list prof pradyumansinh jadeja   data structure  function insert element pointer element linked linear list typical node info link fields avail pointer element availab ility tack temporary pointer variable function inserts node position linked list function returns address node  underflow avail null return  address free node avail  remove free node availability stack avail link avail  initialize fields node link list info link  return address node eturn insert invoked returns pointer variable insert linked list prof pradyumansinh jadeja   data structure  function insend insert element pointer element linked linear list typical node info link fields avail pointer elemen availability tack temporary pointer variable function inserts node position linked list function returns address node  underflow avail null return  address free node avail  remove free node availability stack avail link avail  initialize field node info link null  list null return  initialize search node save  search list save link save  set link field node link save  return node pointer return insert invoked returns pointer variable insert linked list prof pradyumansinh jadeja   data structure  insert node ordered linked list applications desirable maintain ordered linear list ordering increasing decreasing order info field ordering efficient processing general algorithm inserting node ordered linear list  remove node availability stack  set field node  linked list return address node  node preced nodes list inserts node list returns address  repeat step  node list content node  node linked li  insert node list return address node linked list prof pradyumansinh jadeja   data structure  function insord element pointer element linked linear list typical node info link fields avail poi nter element availability tack save temporary pointer variable function inserts node linked list preserves ordering terms increasing order info field function returns address node  underflow avail null return  address free node avail  remove free node availability stack avail link avail  list null link null eturn  node precede node list link eturn  initialize temporary pointer save  search predecessor node save link save  set link field node predecessor link link save link save  return node pointer eturn insert invoked returns pointer variable insert linked list prof pradyumansinh jadeja   data structure  repeatedly involving function insord easily obtains ordered liner list sequence statements algorithm delete node linked list algorithm deletes node linked linear list  linked list write flow return  repeat step  list reached node  node list record predecessor node  list reached write node return  delete node list  return node availability area   trace construction ordered linked linear list function insord null insord  insord  insord  insord  insord  linked list prof pradyumansinh jadeja   data structure  procedure delete address node delete pointer element linked linear list typical node info link fields save pred temporary pointer variables function copy pointer node linked list function copy list list nodes pointer fields denoted field ptr address node newly created list save pred points variables general algorithm copy linked list  list return null  list null return  initialize search save  repeat step  update predecessor marker pred save  node save link save  list return  delete node link link pred link  free deleted node free linked list prof pradyumansinh jadeja   data structure   availability stack write availability stack underflow return copy node  report step  list reached  node list record predecessor node  availability stack write availability stack underflow return copy node add rear list  set link node list null return  list null return null  copy node node avail avail link avail field info  initialize traversal save  node list  update predecessor save pointer pred save link save  copy nod avail null eturn  avail avail link avail field info save ptr pred  set link node return ptr null eturn linked list prof pradyumansinh jadeja   data structure   write algorithms circular link list  insert position  insert position  insert ordered linked list  delete element procedure circular_link_insert_first pointer element circular linked linear list typical node info link fields temporary pointer variable procedure inserts position circular linked inear list  create node node  initialize fields node link list info null link link link return linked list prof pradyumansinh jadeja   data structure  procedure cir_link_insert_end pointer element circular linked linear list typical node info link fields temporary pointer variable procedure inserts position circular linked linear list  create node node  initialize fields node link list null link link link return linked list prof pradyumansinh jadeja   data structure  procedure cir_link_insert_order pointer element circular linked linear list respectivel typical node info link fields temporary pointer variable procedure inserts linked list preserves ordering terms increasing order info field  create node node  copy content node info  linked list null link return  node precedes nodes list lin link eturn  initialize temporary pointer save  search predecessor node save link save  set link field node predecessor link link save link save save  finish return linked list prof pradyumansinh jadeja   data structure  procedure cir_link_ elete pointer element circular linked linear list typical node info link fields save pred tempor ary pointer variable procedure deletes node address pointer variable  list null linked list eturn  initialize search save  repeat step   update predecessor marker pred save  node save link save  linked list return  delete link link link pred link pred  free deleted node free linked list prof pradyumansinh jadeja   data structure   write algorithm perform operations circular singly linked list header node  add node  add node  insert node node address  delete node element function cir_link_head_insert_ pointer element circular linked linear list typical node info link fields temporary pointer variable address head node procedure inserts position circular linked linear list function cir_link_head_insert_last pointer element circular linked linear list typical node info link fields temporary points variable head address head node procedure inserts position circular linked linear list  create emp ty node node  initialize fields node link list info link head link  create node node  initialize fields node link list info link link head link head linked list prof pradyumansinh jadeja   data structure  function cir_link_head_insert_after_node pointer element circular linked linear list spectively typical node info link fields temporary pointer variable head address head node procedure insert node node address  create node node  initialize field node link list info link link link linked list prof pradyumansinh jadeja   data structure  procedure cir_link_head_delete pointer element circular linked linear list typical node info link fields save pred temporary pointer variable head address head node procedure deletes node  list null underflow return  initialize search save   update predecessor pred save  node save link save  list info wr return  delete node info link head link link pred link save save pred  free deleted node free linked list prof pradyumansinh jadeja   data structure   write algorithms doubly link list  insert  insert ordered linked list  delete element prdcedure doubins doubly link list left nodes addressed pointer variables required insert node address pointer variable left links nodes denoted lp rptr field node denoted variable info element list node insertion performed left specific node address pointer variable informa tion entered node contained  create node node  copy field info  insert list null lptr rptr null null eturn  left insertion lptr null rptr lptr eturn  insert middle lptr lptr rptr lptr rptr lptr eturn linked list prof pradyumansinh jadeja   data structure  procedure doubins_ord doubly link list left nodes addressed pointer variables required insert node address pointer variable left links nodes denoted lptr rptr field node denoted variable info element list node insertion performed ascending order info inf ormation entered node contained  create node node  copy field info  insert list null lptr rptr null null return  node precedes nodes list rptr lptr null lptr eturn  initialize temporary pointer save  search predecessor node repeat rp save rptr save  set link field node predecessor rptr rptr save lptr rptr save rptr save lptr save save rptr save linked list prof pradyumansinh jadeja   data structure  procedure doubdel doubly linked list addresses left nodes pointer variables required delete node address contained variable node left links names lptr rptr  underflow null return  delete node single node list null left node rptr lptr null lptr rptr null rptr lptr rptr lptr rptr lptr  free deleted node free linked list prof pradyumansinh jadeja   data structure   write implementation procedure basic primitive operations stack linear array linked list implement push pop linear array define maxsize  int stack maxsize int  void push int val maxsize printf stack overflow stack val int pop int  stack return printf stack underflow stack pop return  linked list prof pradyumansinh jadeja   data structure   write implementation procedure basic primitive operations queue linear arra linked list implement push pop linked list include stdio include malloc struct node int info struct node link void push int val struct node struct node malloc sizeof struct node info val link return int pop int val null val info link return val printf stack underflow return  linked list prof pradyumansinh jadeja   data structure  implement enqueue insert dequeue delete linear array include stdio define maxs ize   int queue maxsize  rear  void enqueue int val rear maxsize printf queue overflow return rear queue rear val  int dequeue int data  printf queue underflow return  data queue rear rear  return data linked list prof pradyumansinh jadeja   data structure  implement enqueue insert dequeue delete linked list include stdio include malloc struct node int info struct node link rear void enqueue int val struct node struct node malloc sizeof struct node info val link null rear null null rear link rear int dequeue struct node int val null rear null printf flow exit  val info link free return val linked list prof pradyumansinh jadeja   data structure   write algorithm implement ascending priority queue singular linear linked list insert function queue remains ordered list implement remove function remove struct node tmp null printf queue underflow tmp printf deleted item tmp info link free tmp remove struct node int priority int info struct node link null linked list prof pradyumansinh jadeja   data structure  insert struct node tmp int added_item item_priority tmp struct node malloc sizeof struct node printf input item queue scanf added_item printf enter priority scanf item_priority tmp info added_item tmp priority item_priority queue item priority item null item_priority priority tmp link fro tmp link null link priority item_priority link tmp link link link tmp insert linked list prof pradyumansinh jadeja   data structure  display struct node ptr ptr null printf queue printf queue printf priority item ptr null printf d d ptr priority ptr info ptr ptr link display nonlinear data structure graph tree prof pradyumansinh jadeja   data structure   discuss  graph graph consist set called set nodes points vertices graph set set edges mapping set edges set pairs elements convenient write graph notice definition graph implies edge graph associate pair nodes  adjacent nodes nodes connected edge graph called adjacent node  directed undirected edge graph edge directed called directed edge edge specific direction called undirected edge  directed graph digraph graph edge directed called directed graph digraph  undirected graph graph whic edge undirected called directed graph  mixed graph edges directed undirected graph graph called mixed graph  loop sling edge graph joins node called loop sling  parallel edges directed undirected graphs airs nodes joined edge edges called lel edges  multigraph graph parallel edges called multigraph  weighted graph graph weights assigned edge called weighted graph nonlinear data structure graph tree prof pradyumansinh jadeja   data structure   isolated node graph node adjacent node called isolated node  null graph graph isolated nodes called null graph set edges null graph  path graph simple digraph terminal node edge sequence initial node edge appearing sequence defined path graph  length path number edges appearing sequence path called length path  degree vertex edges rminal node indegree node edges initial node outdegree node sum indegree outdegree node called total degree degree vertex  simple path edge simple path diagra edges distinct called simple path edge simple  elementary path node simple path nodes traverses distinct called elementary path  cycle circuit path originates ends node called cycle circuit  directed tree directed tree acyclic digraph node called root degree  nodes degree  directed tree node isolated node directed tree  terminal node leaf node directed tree node degree  called terminal node node  level node level node length path root nonlinear data structure graph tree prof pradyumansinh jadeja   data structure   ordered tree directed tree ordering nodes level prescribed tree called ordered tree  forest delete root edges connecting nodes level  set disjoint tree set disjoint tree forest  ary tree directed degree node equal tree called ary tree  complete ary tree degree node equal  number nodes level  tree lled comple ary tree  positional ary tree ary trees children node assumed distinct positions positions account tree called positional ary tree  height tree height tree length path root deepest node tree  binary tree directed tree degree node equal  tree called binary tree  strictly binary tree strict ly binary tree proper binary tree  tree binary tree tree node leaves children  complete binary tree degree node equal   number odes level   tree called complete binary tree  sibling siblings nodes share parent node  binary search tree binary search tree binary tree node possessed key satisfy conditions nonlinear data structure graph tree prof pradyumansinh jadeja   data structure   key left tree root precedes key root  key root precedes key tree  left tree trees root search trees  height balanced binary tree avl tree tree called avl height balance binary tree node possesses properties  node called left heavy longest path left tree longer longest path tree  node called heavy longest path tree longer path left tree  node called balanced longest path left tree equal  explain preorder inorder postorder traversal techniques binary tree suitable common operations performed tree structure traversal procedure node tree processed systematic manner ways traversing binary tree  preorder traversal  inorder traversal  postorder traversal fig   preorder traversal inorder traversal postorder traversal converse preorder traversal converse inorder traversal converse postorder traversal nonlinear data structure graph tree prof pradyumansinh jadeja   data structure  preorder preorder traversal binary tree defined follow process root node traverse left subtree preorder traverse subtree preorder subtree node left descendant traversal performed null subtree considered fully traversed encountered preorder traversal tree fig   inorder inorder traversal binary tree follo wing steps traverse left subtree inorder process root node traverse subtree inorder inorder traversal tree fig   postorder postorder traversal traverse left subtree postorder traverse subtree postorder process root node postorder traversal tree fig   interchange left preceding definitions tra versal orders called converse preorder converse inorder converse postorder  write algorithm preorder inorder postorder traversal techniques binary tree procedure rpreorder binary tree root node address pointer variable node structure procedure traverses tree preorder recursive manner nonlinear data structure graph tree prof pradyumansinh jadeja   data structure  procedure rinorder binary tree root node address pointer variable node structure procedure traverses tree inorder recursive manner  check tree null return  process left subtree rinorder lptr  process root node write data  process subtree rinorder rptr  finished return  check tree null return lse write data  process left subtree rpreorder lptr  process subtree rpreorder rptr  fini return lptr data rptr nonlinear data structure graph tree prof pradyumansinh jadeja   data structure  procedure rpostorder binary tree root node address pointer variable node structure procedure traverses tree postorder recursive manner  traversa order tree inorder preorder ostorder inorder preorder post order check tree null return  process left subtree rpostorder lptr  process subtree rptr rpostorder rptr  process root node write data  finished return nonlinear data structure graph tree prof pradyumansinh jadeja   data structure   construct tree inorder ostorder traversals inorder postorder nonlinear data structure graph tree prof pradyumansinh jadeja   data structure  postorder inorder nonlinear data structure graph tree prof pradyumansinh jadeja   data structure   constr uct tree inorder reorder traversals pre order inorder nonlinear data structure graph tree prof pradyumansinh jadeja   data structure   create binary search tree data    construct binary search tree data inorder preorder postorder traversal  preorder    inorder    postorder nonlinear data structure graph tree prof pradyumansinh jadeja   data structure   write short note threaded binary tree wasted null links binary tree storage representation replaced threads binary tree threaded traversal order threads inorder traversals tree pointers higher nodes traversal order left link node null link replaced address predecessor link node null replaced address successor left link node denote structural link thread distinguish method  represent thread address method  separ ate boolean flag ght pointers node structure lptr lthread data rthread rptr alternate node threaded binary tree lthread true denotes leaf thread link lthread false denotes leaf structural link rthread true denotes threaded link rthread false denotes structural link head node simply node serves predecessor successor tree nodes tree attached left branch head node head advantages inorder traversal faster unthreaded version tack required effectively determines predecessor successor inorder traversal unthreaded tree task difficult stack required provide upward pointing tree reading generate successor predecessor node head ck threading disadvantages threaded trees unable share common subtrees nonlinear data structure graph tree prof pradyumansinh jadeja   data structure  addressing permitted programming language additional fields required insertion deletion threaded binary tree time consuming thread structural link maintained fully hreaded binary tree binary tree head binary tree inorder traversal nonlinear data structure graph tree prof pradyumansinh jadeja   data structure   draw threaded binary tree tree hreaded binary tree binary tree head nonlinear data structure graph tree prof pradyumansinh jadeja   data structure   meaning height balanced tree rebalancing height balanced tree tree called avl height balance binary tree node possesses properties  node called eft heavy longest path left tree longer longest path tree  node called heavy longest path tree longer path left tree  node called balanced longest path left tree equal tree unbalanced inserting node based position insertion rotate unbalanced node rotation process tree balanced  insertion left tree nodes left child single rotation  insertion left rotation  insertion left left rotation  insertion ngle left rotation  insertion left tree nodes left child single rotation node unbalanced insertion node left tree nodes left child perform single rotation unbalanced node righ rotation tree leaf child parent attach parent parent tree leaf tree child rotation critical node nonlinear data structure graph tree prof pradyumansinh jadeja   data structure   insertion left rotation node unbalanced insertion node perform left rotation unbalanced node leaf rotation leaf child follo rotation parent  insertion left left rotation node unbalanced insertion node left perform left rotation unba lanced node single rotation child foll owed left rotation parent left rotation rotation    critical node steps rotation nonlinear data structure graph tree prof pradyumansinh jadeja   data structure   insertion single left rotation node unbalanced insertion node tree nodes child perform single left rotation nbalanced node left rotation tree child parent attach parent left parent tree tree left child unbalanced node leaf rotation unbalanced node t4 unbalanced node t4 rotation t4 left rotation nonlinear data structure graph tree prof pradyumansinh jadeja   data structure   construct avl search tree inserting elements order occurrence assignment define height binary tree define height balanced tree advantages construct height balanced binary tree avl tree data   construct avl arch tree inserting elements order occurrence  insert  insert insert  rotate insert  inser  righ rotate insert  rotate nonlinear data structure graph tree prof pradyumansinh jadeja   data structure   advantages multiway search tree disc access construct tree der  data insert    insert    insertinser  insert overflow   insert  insert  insertinsert  overflow  insert  insertinsert overflow nonlinear data structure graph tree prof pradyumansinh jadeja   data structure  assignment construct mutiway search tree data order  insert   overflow   insert insert overflow    nonlinear data structure graph tree prof pradyumansinh jadeja   data structuretree   tree type data structure properties data appears leaves data elements ordered left minimum maximum path tree length interior nodes   subtrees  graph represented adjacency matrix path matrix path matrix adjacency atrix graph graph consist set called set nodes points vertices graph set set edges mapping set edges set pairs elements convenient write graph notice definition graph implies edge graph associate pair nodes ociated pair nodes edge connect acency matrix simple diagraph   nodes assumed ordered  matrix elements called adjacency matrix graph element adjacency matrix   graph adjacency matrix depends ordering elements ordering elements adjacenc matrices nonlinear data structure graph tree prof pradyumansinh jadeja   data structure  extend idea matri representation multigraph weighted graphs case multigraph weighted graph write ji denotes multiplicity weight edge path matrix entry  ith row jth column existence edge path length  denote elements    equal number paths length  element row column  number paths length   basic traversing techniques graph write algorithm graph problems involve traversal graph traversal grap visit node commonly graphs traversal techniques  depth search dfs  breadth search bfs    path matrices    digraph adjacency matrix nonlinear data structure graph tree prof pradyumansinh jadeja   data structure  depth search dfs preorder traversal tree traversal start vertex vi vi visited vertices adjacent vi traversed recursively dfs graph cycles avoid visiting node visit vertex marks visited visited selected traversal graph dfs  visit  dfs  dfs  dfs  dfs  dfs traversal graph nonlinear data structure graph tree prof pradyumansinh jadeja   data structure  procedure vertecx procedure traverse graph dfs manner starting vertex explored stack visited array tells vertex visited adjacent node vertex push pop functions insert remove stack  initialize visited visited    push vertex stack push  repeat stack repeat step  stack pop visited  visited  adjacent visited  push nonlinear data structure graph tree prof pradyumansinh jadeja   data structure  breadth search bfs methods starts vertex   marked visited vertices adjacent  visited vertices adjacent  marked visited unvisited vertices adjacentvisited method continuous ertices visited algorithm bfs maintain list vertices visited explored adjacent vertices vertices visited explored adjacent vertices stored queue initially queue starting vertex iteration vertex removed queue adjacent vertices visited queue algorithm terminates queue graph bfs traversal graph nonlinear data structure graph tree prof pradyumansinh jadeja   data structure   spanning tree spanning tree graph undirected tree consisting edges connect nodes original graph spanning tree properties pair nodes exists path insertion edge spanning tree forms unique cycle spanning graph depends criteria generate dfs search edges traversed algorithm forms edges tree referred depth spanning tree bfs search spanning tree formed edges traversed search producing breadth search spanning tree procedure bfs vertex procedure traverse graph bfs manner starting vertex explored queue visited array tells vertex visited adjacent node vertex  initialize  marks visited  visited   add vertex insertqueue  repeat repeat removefromqueue vertices adjacent visited  visited  insertqueue nonlinear data structure graph tree prof pradyumansinh jadeja   data structure   graph fig depth breadth traversals graph starting v0 v1 v2 v3 v4 v5 v6 v7 v0 v1 v2 v3 v4 v5 v6 v7 v0 v1 v2 v3 v4 v5 v6 v7 dfs spanning tree bfs spanning tree nonlinear data structure graph tree prof pradyumansinh jadeja   data structure  dfs bfs nonlinear data structure graph tree prof pradyumansinh jadeja   data structure   define spanning tree minimum spanning tree minimum spanning tree graph fig  set nodes explored initially step  minimum weight edge adjacent edges  step  minimum weight edge adjacent edges   step  minimum weight edge adjacent edges   step  minimum weight edge adjacent edges  nodes graph set minimum spanning tree cost nonlinear data structure graph tree prof pradyumansinh jadeja   data structure   step  min edge step  min edge edges graph visited minimum spanning tree cost  step  min edge    step  min edge step  min edge forms cycle step  min edge forms cycle step  min edge forms cycle step  min edge forms cycle step  min edge forms cycle nonlinear data structure graph tree prof pradyumansinh jadeja   data structure   applications directed undirected graphs adjacency matrix graph fig applications graph electronic circuits printed circuit board integrated circuit transportation networks highway networks modeling road network vertexes towns edge costs distances water supply netw orks modeling water supply network cost relate current function capacity length water flows  direction higher lower pressure connections downhill network inherently acyclic directed graph ight network minimizing cost time air travel direct flights exist starting airports computer networks local area network internet dynamically modeling status set routes traffic directed internet web directed graph map links website analyze ease navigation parts site databases entity relationship diagram   adjacency matrix graph nonlinear data structure graph tree prof pradyumansinh jadeja   data structure    vertex f5 graph fig step  traverse adjacent nodestep  traverse adjacent node  step  traverse adjacent node  step  traverse adjacent node   step  traverse adjacent node shortest path node step  length path  hashing prof pradyumansinh jadeja   data structure  hashing sequential search requires average comparisons locate element comparisons desirable large database elements binary search requires fewer comparisons average log additional requirement data sorted sorting algorithm sorting elements require  log comparisons technique storing data called hashing requirement keeping data sorted binary search case timing complexity constant order   worst case hashing algorithm starts behaving linear search ase timing behavior searching hashing  worst case timing behavior arching hashing hashing record key lue key directly referred calculating address key address location element record computing arithmetic function key address table hash table data structure forms hashing  open hashing external hashing open external hashing records stored unlimited space hard disk places limitation size tables address hash table  mapping record hash table record hashing prof pradyumansinh jadeja   data structure   close hashing internal hashi closed internal hashing fixed space storage limits size hash table  open hashing ata tructure basic idea records elements partitioned classes numbered    hashing function maps record key integer  bucket bucket table head linked list records mapped bucket  close hashing data structure closed hash table elements bucket ement bucket place element bucket holds element collision occurred case collision element rehashed alternate location  bucket table closed hashing collision handling issue bucket table header list elements   open hashing data organization hashing prof pradyumansinh jadeja   data structure  hashing functions characteristics good hash function good hash function avoids collisions good hash function spread keys evenly array good hash function easy compute hashing functions  division method  midsquare methods  folding method  digit analysis  length dependent method  algebraic coding  multiplicative hashing  division method method modular ithmetic divide key integer divisor table size location element write mod  location table file key table size number slots file suppose    mod key  th location  midsquare methods case square key number digits required form address middle position squared suppose key  square  address digits select address  digits starting middle   folding method machines small number primitive data types arithmetic instructions frequently key fit easily data types discard portion key fit arithmetic data typ hashing prof pradyumansinh jadeja   data structure  solution combine parts key parts key affect final result operation termed folding key key partitioned number parts sam length required address add parts ignoring final carry required address ways fold shifting actual values parts key suppose key  required address digits break keyadd ignore   location fold boundary reversed values outer parts key suppose key  required address digits break keyadd ignore   location  digit analysis hashing function distribution dependent statistical analysis digits key select digits fixed position occur frequently reverse shifts digits address key  statistical analysis revealed position digits occur frequently choose digits positions key  reversing  address  length dependent method type hashing function length key portion key produce address directly indirect method length key portion key intermediate  algebraic coding bit key represented polynomial divisor polynomial constructed based address range required modular division key polynomial divisor polynomial address polynomial polynomial bit key    divisor polynomial required address polynomial mod  multiplicative hashing method based obtaining address key based multiplication hashing prof pradyumansinh jadeja   data structure  negative key constant   compute kc mod  fractional kc multiply fractional floor address  collision resolution strategies synonym resolution collision resolution main problem hashing element inserted mapped location element inserted collision resolved strategies collision resolution commonly  separate chaining open hashing  open addressing closed hashing  separate aining strategy separate list elements mapped maintained separate chaining based collision avoidance memory space tight separate chaining avoided additional memory space links wasted storing address linked elements ha shing function ensure distribution elements buckets timing behavior operations hash table deteriorate hashing prof pradyumansinh jadeja   data structure  integers inserted hash table  locations chaining resolve collisions construct hash table simplest hash function    element mapped location hash table mapping function key  hash table location mapped element  list elements separate chaining hash table hashing prof pradyumansinh jadeja   data structure   open addressing separate chaining requires additional memory space pointers open addressing hashing alternate method handling collision open addressing collision occurs alternate cells cell linear probing quadratic probing double hashing linear probing linear probing collision cells searched sequentially wraparound cell fig result inserting keys hash function key key  linear probing strategy table    linear probing easy implement suffers primary clustering hash table  hashing prof pradyumansinh jadeja   data structure  keys mapped location clustering linear probing distribute keys evenly hash table keys stored neighborhood location mapped lead clustering keys point collision quadratic probing reducing primary clustering quadratic probing resolve collision suppose key mapped location cell occupied quadratic prob ing location    examined cell key inserted table reduces prima clustering ensure cells table examined cell key inserted cell table double hashing method equires hashing func tions f1 key key roblem clustering easily handled double hashing function  key primary hash function case address  key occupied key function key evaluated function key compute increment address hash function  key case collision search location successively addresses  key key  key f2 key  key f2 key file prof pradyumansinh jadeja   data structure  file file collection records record consists fields sequence fields field fixed length sample file records roll year marks amit    kalpesh    jitendra    ravi    records fields roll year marks ecords uniquely identified field roll roll key field database collection files commonly file organizations  sequential files  relative files  direct files  indexed sequential files  files primitive operations file  creation  reading  insertion  deletion  updation  searching sequential files common type file type file fixed format record records length position field record length field fixed records physically ordered fields called ordering field file prof pradyumansinh jadeja   data structure  block  roll year marks amit    kalpesh    jitendra    ravi    block  nilesh    blocks ordered sequential file students records roll ordering field advantages sequential file unordered files reading records order ordering key extremely efficient finding record order ordering key require additional block access record block searching operation ordering key faster binary search utilized binary search require log  block accesses total number blocks file disadvantages sequential file sequential file advantage search operation carried ordering field inserting record expensive operation insertion record requires finding place insertion records ahead moved create space record inserted cou ld expensive large files deleting record expensive operation deletion requires movement records modification field ordering key time consuming modifying ordering field record change position requires deletion record insertion modified record hashing direct file organization common technique fast accessing records secondary storage records file divided buckets bucket disk block cluste contiguous blocks hashing function maps key bucket number buckets numberedhash function maps key integers   key number bucket record key file prof pradyumansinh jadeja   data structure  blocks making bucket contiguous blocks chained linked list ranslation bucket number disk block address bucket directory address block chained blocks linked list hashing efficient retrieving record hashed key average number block accesses retrieving record operation times faster number buckets unordered file insert record key record block chain bucket record fit existing block record stored block block chain bucket designed hashed structure requires block accesses operations indexing indexing speed retrieval records  bucket  bucket  bucket  bucket directory hashing buckets chained blocks file prof pradyumansinh jadeja   data structure  separate sequential file record file consi sts fields key field pointer main file specific record key searched key binary search search file address record record main file easily retrieved file ordered ordering key roll record file points record main file sorted advantages indexing sequential file sequential file searched effec tively ordering key search record basis attribute ordering key field sequential file representation inadequate multiple indexes maintained type field searchin indexing flexibility file requires storage space main file binary search sequential file require accessing blocks explained sequential file  records fixed length record size  bytes stored disk block size bytes number blocks required store file number block accesses arching record log    suppose construct key field  bytes long block pointer  bytes long record file form  bytes entry total number ind entries  number blocks required store file number block accesses searching record log amit kalpesh jitendra ravi nilesh  roll year marks main file search key pointer file file prof pradyumansinh jadeja   data structure  indexing records main file require movement records case sequential file updation file requires fewer block accesses compare sequential file types indexes  primary indexes  clustering indexes  secondary indexes primary indexes indexed sequential file indexed sequential file characterized sequential organization ordered primary key primary key indexed sequential file ordered indexed records organized sequence based key field primary key file support random access record file consists elds key field key field main file number records file equal number blocks main file data file equal number records main file data file create prima ordered file fig rollno field primary key entry file rollno block pointer entries  address block   address block   address block  total number entries number disk locks ordered data file binary search file requires block accesses file prof pradyumansinh jadeja   data structure  clustering indexes records file ordered key field create type clustering key field distinct record clustering ordered file fields block pointer roll file data file primary ordering key field roll number file prof pradyumansinh jadeja   data structure  secondary indexes simple file hashed sequential indexed sequential files suitable operations based ordering key hashed key file organizations suitable operation involving search field ordering hashed key searching required keys secondary indexes fields maintained secondary ordered file fields ordering field data fil block pointer secondary indexes file binary search file entries file ordered secondary key field records data files ordered secondary key field secondary requires storage space longer search time primary secondary file entry record primary file entry block data file single primary file number secondary indexes math  science block pointer field file field clustering data file clustering roll  physics file prof pradyumansinh jadeja   data structurefield    file data file block pointer indexing field roll secondary ordering key field sorting searching prof pradyumansinh jadeja   data structure  bubble sort bubble sort referred sinking sort simple sorting algorithm works repeatedly stepping list sorted comparing pair adjacent items swapping wrong order pass list repeated swaps needed ind icates list sorted algorithm smaller elements bubble list comparisons operate elements comparison sort algorithm simple slow practical compared insertion sort algorithm program include stdio void main int array  temp printf enter number elements scanf printf enter integers  scanf arrayarray array  decreasing order   rray array  decreasing order temp rray rray  rray  temp sorting searching prof pradyumansinh jadeja   data structure  tem array array array  array  tem printf sorted list ascending order  printf array getch array  element pass  comparisons pass  compareinterchange compareinterchange compareinterchange compar  interchange pass largest element array  bubbled position array   sorting searching prof pradyumansinh jadeja   data structure  pass  comparisons pass  compareinterchange compareinterchange compareinterchange pass  comparisons pass  compareinterchange compareinterchange   largest element  largest elementlargest element sorting searching prof pradyumansinh jadeja   data structure  pass  comparisons pass  compar interchange   sorted array sorting searching prof pradyumansinh jadeja   data structure  selection sort ide algorithm simple array imaginary divided parts sorted unsorted sorted unsorted array tep algorithm finds minimal element unsorted adds sorted unsorted algorithm stops algorithm program include stdio void main int array  min temp printf enter number elements scanf printf enter integers  scanf array   min  array min array min selection_sort   min  min min temp min min temp sorting searching prof pradyumansinh jadeja   data structure  min temp array array array min array min temp printf sorted list ascending order  printf array getch sorting searching prof pradyumansinh jadeja   data structure  unsorted array    unsorted array sorted array exchange   exchange unsorted array sorted array exchange   unsorted array sorted array exchange unsorted array sorted array exchange   unsorted array sorted array exchange   unsorted array sorted array exchange   sorted array array step  step  step  step  step  step  step  step  step  sorting searching prof pradyumansinh jadeja   data structure  quick sort uicksort fastest sorting algorithm practical choice sorting average expected running time log pick element called pivot array reorder array elements values pivot pivot elements values greater pivot equal values partitioning pivot final position called partition operation recursively apply steps array elements smaller values separately array elements greater values quicksort merge sort divide conque recursive algorithm basic divide conquer rocess sorting array summarized easy steps divide partition arrays   element  equal turn equal element  compute partitioning procedure conquer sort arrays   recursive calls quicksort combine arrays sorted place work needed combing entire array sorted algorithm procedure pivot var permutes elements array returns initial  repeat  repeat  swap repeat  repeat  swap procedure quicksort sorts array decreasing order small insert pivot quicksort  quicksort sorting searching prof pradyumansinh jadeja   data structure  program include stdio void quicksort int  int int int partition int  int int void main int  size printf enter size array scanf size printf enter elements size  size scanf quicksort  size  printf sorted elements  size printf getch void quicksort int  int int int mid mid partition int int int quicksort mid  quicksort mid  int partition int  int int int temp sorting searching prof pradyumansinh jadeja   data structuretemp temp temp  temp return  sorting searching prof pradyumansinh jadeja   data structure   exchange exchange exchange   apply method left array finally sorted array left array array sort array quick sort sorting searching prof pradyumansinh jadeja   data structure  merge sort merge sort algorithm based classical divide conquer paradigm operates divide partition element sequence sorted subsequences  elements conqu sort subsequences recursively merge sort combine merge sorted subsequences size  produce sorted sequence consisting elements note recursion bottoms sequence sorted length sequence length  sorted order furth recursive key operation merge sort algorithm merging sorted sequences combine step perform merging auxiliary procedure merge array indices numbering elements array proce dure assumes arrays  sorted order merges form single sorted array replaces current array finally sorted array  solution algorithm merge n1   n1   n1  infinite  infinitesorting searching prof pradyumansinh jadeja   data structure  program include stdio void mergesort int  int int int merge int  int int int void main int  size printf enter size array scanf size printf enter elements size  size scanf merge sort  size  printf sorted elements  size printf getch void merge sort int  int int int merge sort  merge sort merger sort  merge sorting searching prof pradyumansinh jadeja   data structure   mergesort merge sort  merge int merge int  int int int int n1   n1   n1   n1  null  null   sorting searching prof pradyumansinh jadeja   data structure sort array usin merge sort sorting searching prof pradyumansinh jadeja   data structure  linear sequential search computer science linear search sequential search method finding list consists checking elements time seq uence desired linear search simplest search algorithm special case brute force search worst case cost proportional number lements list algorithm program include stdio void main int array  key printf enter number elements array scanf printf enter integer  printf array scanf array printf enter number search scanf key input array integer key output key  algorith linear_search  equals key return return  sorting searching prof pradyumansinh jadeja   data structure   array key required element printf location key  break printf array search etch search  array comparing element search seache element array   element sorting searching prof pradyumansinh jadeja   data structure  binary search array sorted efficient algorithm called binary search binary search time divide array equal half compare middle element search lement middle element equal search element element return middle element search element array middle element greater search element left array algorithm program include stdio void main int middle key array  printf enter number elements scanf printf enter integers sorted order  scanf array printf enter scanf key input sorted array integer key output key  alg orith binary _search left left middle halfway left middle matches key return middl key middle middle  left middle  return  sorting searching prof pradyumansinh jadeja   data structure    middle  array middle key printf location key middle  break array middle key middle  middle  middle  printf list key getch    step  middle element   search left   step  middle element   earc step  middle element   element  