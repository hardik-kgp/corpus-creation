xvcontentsa list set hash set tree set summary exercises chapter maps understanding maps testing map implementations list map hash map tree map summary exercises chapter ternary search trees understanding ternary search trees searching word inserting word prefix searching pattern matching putting ternary search trees practice crossword helper summary exercise chapter trees understanding trees putting trees practice summary exercises chapter string searching generic string searcher interface generic test suite brute force algorithm boyer moore algorithm creating tests implementing algorithm _596748 ftoc qxd   xvicontentsa string match iterator comparing performance measuring performance compare summary chapter string matching understanding soundex understanding levenshtein word distance summary chapter computational geometry quick geometry refresher coordinates points lines triangles finding intersection lines slope crossing axis finding intersection point finding closest pair points summary exercises chapter pragmatic optimization optimization fits understanding profiling filesortinghelper program profiling hprof profiling jmp understanding optimization putting optimization practice summary appendix reading appendix resources _596748 ftoc qxd   xvi xviicontentsappendix bibliography appendix answers exercises index541 _596748 ftoc qxd   xvii _596748 ftoc qxd   xviii introductionwelcome algorithms step step introduction computing algorithms real developers algorithms data structures day working lives good standing algorithms knowledge apply essential producing software works correctly performs efficiently book aims explain algorithms data structures commonly encountered day day software development remaining times practical concise point verbiage distract core concepts examples read bookthe ideal reader book develops applications starting understand algorithms data structures include programmers developers soft ware engineering students systems students computer science students book assumes understanding computer programming general hoped code read book cover cover follow alongñ albeit conceptual level reason team leaders architects business analysts benefit prerequisite knowledgeas code examples written programming language working knowledge familiarity standard librariesñand langpackage inparticular understanding arrays loops create compile classes prerequisites mentioned requirement knowledge data structures algorithms contained learn detailed explanations implementations exercises designed build understanding point knowledge real examples rarely academic nature careful consideration chapter code cases real applications _596748 flast qxd   xix xxintroductionwe hard adhere commonly accepted software development practices include design patterns cormen coding conventions quality checks fullyautomated unit tests hope addition understanding algorithms problem solving deeper appreciation build robust extensible functional software familiar language notice overlap classes book utilpackage book concernedwith specific implementations libraries hope insight designers language felt include specific implementations ofcertain algorithms data structures including work book designed teach basics computer programming general programming explain standard libraries intent code examples classes lang cases thejava packages packages limits book build classes hand enable experience satisfaction thatcomes discovering algorithms emphasis unit testing chapter book study guide unit testing hoped exposing directly unit test code gain understanding basic unit testing techniques bookfor book intended read guides reader basics algorithms data structures performance characteristics specific algorithms sorting searching book divided main sections chapters explain basics algorithms iteration recursion introducing reader fundamental data structures lists stacks queues chapters  deal sorting algorithms prerequisite topics keys ordering chapters  cover efficient techniques storing searching hashing trees sets maps chapters  include specialized advanced topics general discussion common performance pitfalls optimization techniques chapter introduces concepts build previous chapters ground subsequent open book chapter bit thumbing chapters attain sufficient understanding subject matter event recommend carefully work sample implementations code exercises chapter order gain solid understanding concepts principles covered finally check appendixes suggestions read ing resources bibliography _596748 flast qxd   xxiintroductionprinciples approachoften difficult understanding code coming grips unwritten assump tions principles guided decision making process reason felt explain approach insight rationale fundamental development practices guided uswhen writing book things hope simplicity leads code donõt optimize prematurely interfaces promote flexibility design production code covered automated unit functional tests assertions developerõs friend simple heard òoh itõs complex wouldnõt understand ó òour code difficult test ó dealing complexity essence software engineering youõve managed build job hard explain difficult test works coincidence youõve deliberately implemented solution fact works dependent probability pure determinism complex break problem smaller manageable chunks start solv ing smaller problems start refactoring abstracting based common code common solu tions large systems complex arrangements simple things keeping simple stupid kiss motto examples book simple simpler book intended practical guide algorithms code examples provided close produce real applica tion cases methods longer book intended teachñnot exercise writing smallest number lines code donõt pre optimize tempting code fast start interesting thing optimization performance bottlenecks expect nature suspected preempting hot spots costly exercise design code leave performance improvement separate task requiring separate skills explained chapter book trade performance clarity err clarity understand design intent code shave milliseconds running time _596748 flast qxd   xxi xxiiintroductionagood design easier profile optimize spaghetti òcleveró code fact experience simple designs result code performs optimization required interfacesmany data structures algorithms extant outward functionality underlying implementation real applications choose implementations based processing memory constraints cases constraints advance interfaces enable define contract regard underlying implementation flexibility design facilitating pluggability implementation imperative code interfaces substituting implementations book implementations translating functionality defined operations interface cases operations fall groups core optional core operations provide base functionality required interface implementations derived principles independent optional operations conversely implemented core operations generally considered provided convenience developer easily implement needed basis application code commonly practice core api finish discussion topic implementing employ testing modern development practices demand software rigorously united functionally tested ensure ongoing integrity code keeping approach defining interface defining concrete implementation translate functional requirements test cases ensuring assumption covered confirmed tests written junit facto standard testing framework exercise functional aspect implementation tests written based defined interfaces concrete implementation enables tests implementation ensuring consistent quality addition demonstrates performance characteristics choosing differ ent implementations application testing purists argue tests long liking test things method tend agree things simple pos sible order facilitate understanding occasionally liberty bining scenarios test method _596748 flast qxd   xxii xxiiiintroductionthe point write tests written implementation code approach test driven development tdd forces concentrate tract published behavior classes implementation enables treat test cases requirements cases code experience design classes simpler demonstrated examples fact code tests interfaces tdd breeze assertive rigor testing complacent believing code fully tested itis bug free problem tests donõt prove software itõs supposed tests prove software works scenarios assumptions match reality greatest comprehensive test suite itõs testing wrong things matters keeping fail fast motto urge program defensively check null pointers assert objects correct state start method experience kind programming catches manner strange bugs earlier waiting nullpointerexception anytime assumption state object nature parameter validate assumption code assertion anytime òthis happen donõt worry ó code level assertion imagine monetary field database òknowó òneveró neg ative turn assertions someday negative willcreep days months years notice effects parts calculations  cents notice time problem discovered determining adverse effects devise enabled code level assertion software failed predictable instant problem arose diag nostic track problem data corrupted repair assertions production code enable software fail predictable ways ways ultimately identify nature problem easily incur negligible overhead donõt presume moment assertions software perform badly chances good assertions code combined donõt compare time inside remote procedure database query recommend leave assertions turned production code running couldnõt simpler quick head start download fully working project source code tests automated command build wrox website refer òsource codeó _596748 flast qxd   xxiii xxivintroductionif prefer approach youõre luck minimized number dependencies started acopy development kit jdk version  includes compile code junit library consisting single jar file classpath compile unit tests atext editor integrated development environment ide working code jdk junit freely downloaded internet appendix òresourcesó requirement weõd start ide war thatõs doubt favorite stick event donõt edit code friends fellow students lecturers work colleagues weõre pretty wonõt shy opinion code compile operating wrote developed book combination apple macintosh windows based machines code ticularly cpu intensive hardware usual software develop ment fine conventions text track whatõs happening weõve number ventions book outhands practice exercise work text book consists coded steps steps numbered short series small steps lead final larger accomplishment works step block code accomplishes explained works topic book algorithms suited hands numbered exer cises suited hands examples youõll works sections altered idea engage applying youõre learning tips hints tricks asides current discussion offset italics boxes hold forgotten directlyrelevant surrounding text _596748 flast qxd   xxiv xxvintroductionas styles text italicizeimportant introduce keyboard strokes ctrl filenames urls code text persistence properties code ways code examples highlight code gray background gray highlighting code presentcontext source codeas work examples book choose type code manually source code files accompany book source code book avail download wrox site simply locate bookõs title thesearch box title lists click download code link bookõs source code book books titles easiest search isbn book isbn   changing   industry wide digit isbn numbering phased january download code decompress favorite compression tool alternately main wrox code download wrox dynamic books download aspxtosee code book wrox books errata effort ensure errors text code fect mistakes occur error book spelling mistake faulty piece code grateful feedback sending errata save reader hours frustration time helping provide higher quality errata book wrox comand locate title search box title lists book details click book errata link canview errata submitted book posted wrox editors acomplete book list including links bookõs errata wrox misc booklist shtml donõt spot òyouró error book errata wrox contact techsupport shtmland complete form send error weõll check post message bookõs errata problem subsequent editions book _596748 flast qxd   xxv xxviintroductionp2p wrox comfor author peer discussion join p2pforums p2p wrox forums web based sys tem post messages relating wrox books technologies interact readers technology users forums offer subscription feature mail topics choosing posts wrox authors editors industry experts fellow readers forums p2p wrox comyou number forums read book develop applications join forums follow steps p2p wrox comand click register link read terms click agree complete required join optional provide click submit receive mail describing verify account plete joining process read messages forums joining p2p order post messages youmust join join post messages respond messages users post read mes sages time web messages forum mailed click subscribe forum icon forum forum listing wrox p2p read p2pfaqs answers ques tions forum software works common questions specific p2pand wrox books read faqs click faq link p2ppage _596748 flast qxd   xxvi getting started journey algorithms preparation background informa tion youõll things learning algorithms data structures rest book youõre keen reading chapter rest book includes concepts prerequisites understanding explanations code analyses algorithms chapter discusses algorithm isthe role algorithms software everyday life meant complexity algorithmseveral broad classes algorithm complexity enable distinguish solutions problem òbig oó notationwhat unit testing importanthow write unit tests junitdefining algorithmsperhaps algorithms computing good care turns algorithms arenõt limited computing algorithms day life simple terms algorithmis set defined steps required accomplish task youõve baked cake recipe kind youõve algorithm algorithms involve state transitioning series intermediate states everyday life _596748 ch01 qxd    simple integer multiplication memorized multiplication tables grade school actual process multiplication thought series additions expression  shorthand    matter integers aand multiplying atimes involves adding btoitself atimes expressed sequence steps initialize integer ais weõre ccontains result proceed step  add bto decrement step notice recipe baking cake multiplication addition algorithm loops step algorithms involve kind looping repeatedly apply calculation computation iterationand recursion ñthe main types loopingñare covered chapter algorithms pseudo code kind upprogramming language easy understand nonprogrammers code function multiply thattakes integersñ aand bñand returns busing addition pseudo code representing multiplying integers addition function multiply integer integer integer while greater c endreturn cendof multiplication simple algorithm applications encounter involve algorithms complex problem complex algo rithms inherently difficult understand bugs fact large computer science involves proving algorithms work correctly coming algorithms isnõt easy addition algorithm solve problem solutions simple complex efficient simplest solution isnõt obvious rigorous scientific analysis good starting point stuck analysis paralysis bit ofgood fashioned creativity needed approaches investigate hunches determine current attempts solution work cases reason seminal works called computer scienceand software engineeringis called artofcomputer programming authored donald knuth algorithms book determin isticñthe result algorithm determined based inputs problem difficult finding precise solution costly terms time resources case heuristicmay practical approach perfect solution chapter _596748 ch01 qxd    heuristic characteristics problem produce approximate solution heuristics sift data removing ignoring values irrelevant computationally expensive parts algorithm operate smaller set data arather lighthearted heuristic involves crossing street countries north america europe vehicles drive hand road youõve lived united states life youõre doubt left crossing street travel australia looked left road clear moved street shock australia united kingdom japan countries vehicles drive left hand road simple cars traveling irrespective country youõre direction parked cars lined pointing left chances good left crossing road conversely parked cars lined pointing left left crossing street simple heuristic works mostof time cases heuristic falls parked cars road cars parked facing directions happen lot london cars drive street case bangalore major drawback heuristic determine perform timeñas demonstrated leads level uncertainty algorithm acceptable depending application problem solve undoubtedly algorithm kind simpler precise understandable algorithm easier determine works correctly perform understanding complexity relation algorithmshaving groundbreaking algorithm determine efficiency code efficient youõll prove work hoped efficient cpu time memory usage disk measure efficiency algorithm common mistakes analyzing efficiency algorithm confuse formance cpu memory disk usage complexity algorithm scales algorithm takes milliseconds process  records isnõt good indica tion efficiency true ultimately resource consumption aspects cpu time heavily efficiency performance underlying hardware code compiler generate machine code addition code itõs ascertain algorithm behaves size problem increases number records process doubled processing time returning original algorithm takes milliseconds process  records takes milliseconds òbetter ó algorithm takes milliseconds process  records times algorithm takes milliseconds reconsider choice getting started _596748 ch01 qxd    generally speaking complexity measure resource required perform function possibleñand usefulñto measure complexity terms disk memory usage focus complexity cpu time redefine complexity measure number computations operations required perform function interestingly itõs measure precise number operations greater number operations performed varies size problem previous problem size increase order magnitude affect number operations required perform simple function number remain double increase linearly size problem increase exponentially refer algorithm complexity measuring complexity algo rithm hope predict perform complexity performance vice versa book algorithms data structures presented analysis complexity wonõt require mathematics understand cases simple theoretical analysis complexity backed easy follow empirical form test cases playing changing inputs order good feel efficiency algorithms covered cases average complex ity givenñthe expected average case performance code cases worst case case time measureñbest worst averageñis depend algorithm extent function type data algorithm operate cases remember complexity doesnõt provide pre cise measure expected performance places bounds limits achievable formance understanding big notation mentioned earlier precise number operations complexity algorithm defined terms order magnitudeof number operations required perform function denoted capital ofor order ofñhence big oñfollowed expression repre senting growth relative size problem denoted letter list common orders discussed pronounced òorder ó denoting function runs constant time pronounced òorder nó denoting function runs linear time pronounced òorder squaredó denoting function runs quadratic time logn pronounced òorder log nó denoting function runs logarithmic time nlogn pronounced òorder log nó denoting function runs time propor tional size problem logarithmic time pronounced òorder factorialó denoting function runs factorial time orders listed sufficient describing complexity algorithms presented book chapter _596748 ch01 qxd    figure  measures complexity compare horizontal axis represents size problemñfor number records process search algo rithm vertical axis represents computational effort required algorithms class indicative running time cpu cycles consumed indication computational resources increase size problem solved increases figure  comparison orders complexity referring list noticed orders constants algorithmõs expected runtime performance proportional  casesthe complexity defined strange firstñsurely nis than100 nñbut mentioned earlier aim determine exact number operations provide comparing algorithms relative efficiency algo rithm runs time generally outperform algorithm runs dealing large values constants difference ration size difference     insignificant actu ally times bigger point compare actual performance algorithms espe cially takes minutes hours thing remember itõs easier halve time algorithm tochange algorithm thatõs inherently log log getting started _596748 ch01 qxd    constant time forgiven assuming complexity implies algorithm takesone operation perform function algo rithm takes constant time performance isnõt size problem sounds good true youõd granted simple functions time simplest constant timeperformance addressing main memory computer extension array lookup locating element array generally takes time size complex problems finding algorithm runs constant time difficult chapter òlists ó chapter òhashing ó introduce data structures algorithms time complexity thing note constant time complexity doesnõt guarantee algo rithm fast time algorithm takes month actual running time completely unacceptable linear time algorithm runs number operations required perform function directly propor tional number items processed figure  continues upward slope remains waiting supermarket average takes time customer checkout takes minutes process customerõs items  minutes process customers  minutes process customers point matter customers waiting time process remains pro cessing time directly proportional number customers interestingly doubled tripled number registers operation time processing time officially remember big notation disregards constants algorithms time acceptable theyõre considered effi cient weõve mentioned finding constant time algorithms difficult manage algorithm runs linear time efficient bit analysisñand occasional stroke geniusñas chapter òstring searching ó demonstrates quadratic time imagine group people meeting time keeping protocol person group greet shake hands person people group total    handshakes figure  chapter _596748 ch01 qxd    figure  member group greets member happen people group    handshakes people work   handshakes people idea time size group grows extra son shake hands person number handshakes required group size turns big onotation disregards constantsñin case ñweõre left table  nbecomes larger subtracting nfrom n2will safely ignore subtraction leaving complexity table  subtracting as increasesnn2n2ð ndifference           getting started _596748 ch01 qxd    algorithms quadratic time computer programmerõs worst nightmare algo rithm complexity pretty guaranteed useless solving smallest problems chapters  sorting provide interesting examples logarithmic time log log figure  logn itõs good running time logarithmic algorithm increases logñin cases log base ñof problem size size input data set increases factor mil lion time increase factor log   easy calculate log base integer work number binary digits required store number log base  takes binary digits represent number binary representation achieving logarithmic running times requires algorithm discard large por tions input data set result algorithms exhibit behavior involve searching kind chapter òbinary searching ó chapter òbinary search trees ó cover algorithms logn figure  nlogn goodas chapters  cover algorithms nlogn factorial time thought algorithms perform ñcompare lines figure  orders worse donõt cover book itõs fairly unusual encounter functions kind behavior examples donõt involve code case youõve forgotten factorial isñor knew placeñhereõs quick refresher factorial integer product integers pronounced òsix factorialó           table  comparison and integers  table  comparison and small integers nn2n   chapter _596748 ch01 qxd    nn2n      values nup including factorial quadratic afterwhich point factorial takes leaves wake consequence youõd hope code isnõt unit testing continuing journey realm algorithms digress discuss topic thatõs dear hearts unit testing years unit testing popularamong developers place high quality systems build devel opers comfortable creating software creating accompanying suite automated tests prove software theyõve created intend guessed hold point view thatõs algorithm weõll works providing unit tests recommend adopt habit development efforts greatly increase odds leaving work time sections provide quick overview unit testing general introduce junit frame work unit testing programs junit book youõll familiar order sense examples provided feel free skip book youõre hardcore test infected developer good unit testing aunit testis simply program tests program terms itõs class purpose test class thatõs things itõs easy learn hard mas ter unit testing art science books testing wonõt depth check appendix afor good books topic basic operation unit test set objects support test sample data stuff called fixtures test exercising objects ensuring expected happen happen called making assertions finally clean longer needed called tearing getting started _596748 ch01 qxd    common convention naming unit tests book create test class class test test class called widget create class called widgettestto unit test examples book notice common convention organizing source files involves placing unit tests parallel source tree package structure main source files widget lives package called wrox algorithms source files organized figure  figure  unit test source files live parallel package structure package statement file thefiles live directories file model production code sepa rate test code easy packaging distribution main code easy ensure production code doesnõt rely test code build process differ ent classpath arrangements compiling directories people fact enable tests access package scoped methods thatõs finish describing unit testing aware common types testing weõll provide basic definitions context avoid unnec essary confusion book unit testing check references additional infor mation types testing terms encounter include black box testing imagine test dvd player access voiding warranty buttons plugs canõt test individual components dvd player donõt access externally visible controls provided black box software terms akin user interface fully deployed application components access functional testing interchangeably black box testing white box testing refers testing inside overarching component organi zation greater lesser extent test individual components user interface srcð mainð comð wroxð algorithmsð widgetðð testð comð wroxð algorithmsð widgettest10chapter _596748 ch01 qxd    integration testing testing individual component alarge distributed types tests aimed ensuring systems continue meet agreed contracts behavior evolve independently unit testing fine grained testing techniques involves single class beingtested independently classes unit tests quick independent unit testing understand youõre reading unit testing book algorithms compiler enables programs program wrote working hadnõt compiled compiler kind test programñit ensures program expressed correct language syntax thatõs feedback program thatõs unit tests interested programs typed correctly unit tests provide essential barrier bugs kinds benefit unit tests provide reliable documentation behavior class test youõve unit tests action youõll itõs easier work aclass test code code howit thatõs matter junit primerthe place visit junit website junit org software download junit ide pointers extensionsand enhancements junit created address youõve downloaded software add junit jarto classpath andyouõre ready create unit test create unit test simply create class extends junit framework testcasebase class code basic structure unit test written junit package wrox algorithms queues import wrox algorithms lists linkedlist import wrox algorithms lists list import junit framework testcase public class randomlistqueuetest extends testcase private static final string value_a private static final string value_b private static final string value_c private queue _queue getting started _596748 ch01 qxd    donõt concerned unit test testing unit test youõllunderstand discussion queues book main point unit test regular class base class supplied junit framework code declare class extend base class declare static members instance member hold queue youõre test thing override setup method add code needed objects ready testing case simply calling overridden setup method superclass instantiating queue object testing note spelling setup method thatõs capital òuó middle javaõs weak nesses methods overridden coincidence explicit intention mistype method wonõt work expect protected void setup throws exception super setup _queue randomlistqueue provided junit framework guarantee time test method youõll shortly setup method called test runs test method companion teardown method opportunity clean code protected void teardown throws exception super teardown _queue null wondering bother setting instance member field null whilenot strictly large suites unit tests neglecting step unit tests sume lot memory itõs good habit acquire method actual unit test code designed test behavior queue isempty item allowed designer object interesting case demonstrates technique prove classes fail expected ways improper hereõs code public void testaccessanemptyqueue assertequals _queue size asserttrue _queue isempty _queue dequeue fail catch emptyqueueexception expected chapter _596748 ch01 qxd    note points code methodõs test required junit framework enable differentiate test method supporting method method assertequals method prove size queue syntax method assertequals expected actual overloaded versions method basic types familiarwith method book common assertion unit tests making expect rea son turns expect junit framework willabort execution test report failure helps unit test concise readable common assertion asserttrue ensure boolean values expected state test case making queue reports correctly state catchblock surrounds method queue object designed throw exception queue construct youõll normal exception handling carefully case itõs sidered goodif exception thrown badif thrown reason code catchblock tryblock calls junit framework fail method calling method youõre test fail method aborts testand reports failure method throws expected exception execution fall method test pass exception thrown test fail sounds confusing read unit test method class public void testclear _queue enqueue value_a _queue enqueue value_b _queue enqueue value_c assertequals _queue size assertfalse _queue isempty _queue clear assertequals _queue size asserttrue _queue isempty method starts testso junit reflection test adds items queue asserts size isempty methods work expected clearsthe queue ensures methods behave expected thing youõll writing unit test note unit test main method canõt directly junit test runnersthat provide dif ferent interfacesñfrom simple text based console interface rich graphical interface development environments eclipse intellij idea direct support running junit tests getting started _596748 ch01 qxd    command preceding test command junit jaron classpath junit textui testrunner wrox algorithms queues randomlistqueuetestrunning graphical version easy junit swingui testrunner wrox algorithms queues randomlistqueuetestjunit tools ant maven build soft ware including running good unit test suite build software development life lot easier software lot robust check junit website details test driven development algorithms data structures book include unit tests ensure code works expected fact unit tests written code existed tested seema strange youõre exposed unit testing aware increas ingly popular technique practiced developers care quality code write test driven development term test driven developmentwas coined kent beck creator extreme programming kent written books subject extreme programming general test driven development basic idea development efforts rhythm switching writ ing test code writing production code cleaning code designed refactoring rhythm creates constant feeling forward progress build software building solid suite unit tests protect bugs caused code track reading book decide unit testing include code check books specialize topic check appendix afor recommendations summary chapter learned algorithms everyday life algorithms central computer systems meant algorithm complexity algorithms compared terms complexity big notation broadly classify algorithms based complexity unit testing write unit tests junit chapter _596748 ch01 qxd    iteration recursion iteration recursion fundamental concepts impossible computing sorting names calculating credit card transaction totals printing order items require record data point processed achieve desired result iteration simply repetition processing steps repetitions required determined factors calculate total stock portfolio iterate stock holdings keeping running total holding processed case number repetitions determined holdings hap pen recursion technique solving problems recursion natural expressing algorithm iteration youõve pro gramming recursion isñyou didnõt knew arecursive algorithm involves method function calling breaking prob lem smaller smaller parts larger finer grained difficult concept grasp algorithms tend fall naturally category easily expressed iteratively recursively fair recursive algorithms fewer farther iterative practical applications chapter assume familiar construct loops method calls concentrate iteration recursion solve problems chapter describes iteration perform calculationshow iteration process arrays abstract problem iteration simple arrays complex data structures recursion technique solving problems _596748 ch02 qxd    performing calculations iteration perform calculations simplest examples raise onenumber base power exponent baseexp involves repeatedly multiplying base times defined exponent  and106     youõll implement class powercalculator single method calculate thattakes parametersñan integer base exponentñand returns base raised power exponent itõs negative exponent purposes assume exponents greater equal outtesting calculations general case pretty straightforward special rules considered docu mented codified tests ensure final implementation works expected creating test class extend testcase package wrox algorithms iteration import junit framework testcase public class powercalculatortest extends testcase rule involves raising base power cases result public void testanythingraisedtothepowerofzeroisone powercalculator calculator powercalculator instance assertequals calculator calculate  assertequals calculator calculate  assertequals calculator calculate  assertequals calculator calculate  rule involves raising base power case result base public void testanythingraisedtothepowerofoneisitself powercalculator calculator powercalculator instance assertequals calculator calculate  assertequals calculator calculate  assertequals calculator calculate  assertequals calculator calculate  chapter _596748 ch02 qxd    finally arrive general case public void testaritrary powercalculator calculator powercalculator instance assertequals calculator calculate  assertequals calculator calculate  assertequals calculator calculate  assertequals calculator calculate  assertequals calculator calculate  works rule number calculations values ensures calcula tion returns in cases notice raised power rule perform number calculations varying base values time exponent time outcome calculation tested number combinations base exponent outimplementing calculator coded tests implement actual calculator package wrox algorithms iteration public final class powercalculator public static final powercalculator instance powercalculator private powercalculator public int calculate int base int exponent assert exponent exponent int result int exponent result base return result works calculate method checks ensure exponent valid remember donõt negative values initializes result iteration form forloop exponent loop terminate performing multiplication result iteration recursion _596748 ch02 qxd    ñanything raised power exponent loop wouldmake single pass multiplying initial result base returning callerña number raised power number values exponent larger loop continue multiplying result base times aprivate constructor order prevent instances class constructed class single instance accessed constant instance anexample singleton design pattern gamma processing arrays performing calculations iteration process arrays imagine wanted apply discount group orders code snippet iterates array orders applying discount order orders int orders length orders applydiscount percentage initialize variable position element inti continue incre menting reaching element orders length applying percentage notice iteration compares variable length array process array reverse print list names reverse order code snippet iterates backward array customers print ing customer customers int customers length  println customers getname time initialize variable position element inti customers length continue decrementing reaching printing customerõs time loop iterators overcome array based problems array based iteration dealing simple data structures diffi cult construct generalized algorithms process element array start finish suppose process item include exclude specific values based selection criteria process items reverse order ear lier tied arrays difficult write applications operate databases files copying data array processing chapter _596748 ch02 qxd    simple array based iteration ties algorithms arrays requires logic determining elements stay order process advance worse perform iteration place code duplicating logic isnõt extensible approach whatõs needed separate logic selecting data code processes iterator enumerator solves problems providing generic interface looping set data underlying data structure storage mechanismñsuch array database onñis hidden simple iteration generally requires write specific code handle data sourced kind ordering preprocessing required iterator enables write simpler generic algorithms iterator operationsan iterator number operations traversing accessing data operations listed table  notice methods traversing backward forward remember iterator concept implementation defines iterator interface standard collections framework iterator define noticeably deliberately standard version conforms closely iterator discussed design patterns gamma table  iterator operations operationdescription previouspositions previous item throws unsupportedoperationexcep tionif implemented isdonedetermines iterator refers item returns trueif endhas reached returns falseto items processed currentobtains current item throws iteratoroutofboundsex ceptionif current item methods throw unsupportedoperationexception data structures traversing data directions sense reason accept traversal methodsñ previous ñto throw unsupportedoperationexceptionto missing unimplemented behavior leave behavior calling current beencalled undefined iterator implementations position item mayrequire event relying behavior considered pro gramming coincidenceand avoided iterators follow idioms òiterator idiomsó chapter iteration recursion _596748 ch02 qxd    iterator interfacefrom operations create interface package wrox algorithms iteration public interface iterator public void public void public boolean isdone public void public void previous public object current throws iteratoroutofboundsexception demonstrated literally translated operations interface method peroperation define exception thrown attempt access current item items process package wrox algorithms iteration public class iteratoroutofboundsexception extends runtimeexception accessing iterator bounds considered programming error coded reason itõs good idea iteratoroutofboundsexceptionextendruntimeexception making called unchecked exception ensures client code handle exception fact adhere idioms discussed iteratoroutofboundsexception iterable interfacein addition iterator interface youõll create interface generic iterator data structure supports package wrox algorithms iteration public interface iterable public iterator iterator iterableinterface defines single methodñ iterator ñthat obtains iterator data contained underlying data structure chapter iterableinterface enables code iterate contents data structure treat implement irrespective underlying implementation chapter _596748 ch02 qxd    iterator idiomsas simple array based iteration basic ways templates iterators whileloop forloop case procedure iterator obtainedñ explicit construction argument methodñposition items remaining process moving previous whileloop enables perform literal translation preceding text code iterator iterator iterator iterator isdone object object iterator current iterator iterator passed parameter method thiscase method iterator positioned starting point forloop familiar closely resembles iterate array iterator iterator iterator iterator isdone iterator object object iterator current notice array iteration initialization terminationcondition check isdone increment achieved calling idiom encouraged frequency real code whichever choose choose remember methods unreliable depend implementation iterator standard iterators addition iterators provided data structures book iterators create standard implementations provide commonly function ality combined iterators standard iterators enable write sophisti cated algorithms data processing iteration recursion _596748 ch02 qxd    array iterator obvious iterator implementation wraps array encapsulating array iterator start writing applications operate arrays extend easily data structures future outtesting array iterator test array iterator usual structure junit test case package wrox algorithms iteration import junit framework testcase public class arrayiteratortest extends testcase advantages iterators donõt traverse array start traverse expose portion ofan array test write ensure construct array iterator pass ing accessible boundsñin case starting position element count enables create iterator array constructor public void testiterationrespectsbounds object array object arrayiterator iterator arrayiterator array  iterator assertfalse iterator isdone assertsame array iterator current iterator assertfalse iterator isdone assertsame array iterator current iterator assertfalse iterator isdone assertsame array iterator current iterator asserttrue iterator isdone iterator current fail catch iteratoroutofboundsexception expected chapter _596748 ch02 qxd    thing test iterating backward arrayñthat starting element working element public void testbackwardsiteration object array object arrayiterator iterator arrayiterator array iterator assertfalse iterator isdone assertsame array iterator current iterator previous assertfalse iterator isdone assertsame array iterator current iterator previous assertfalse iterator isdone assertsame array iterator current iterator previous asserttrue iterator isdone iterator current fail catch iteratoroutofboundsexception expected works test constructing iterator passing array elements notice passed starting position element element count based expect iterator return values test position iterator item ensure expectedñin case nextfor remaining elements theunderlying array elements expect iterator test ensures calling current items throws iteratoroutofboundsexception test previous test construct iterator passing array time iterator traverse elements array portion position item work backward calling previous youreach item iterator signals check ensure current throws exception expected thatõs test scenarios order ensure correct behavior array iterator itõs time array iterator practice iteration recursion _596748 ch02 qxd    outimplementing array iterator tests place implementing array iterator iterator implement iteratorinterface addition holding reference underlying array assume iterator operates entire length array start finish store current position provide access portion array iterator hold boundsñthe upper lower positionsñof array relevant client iterator package wrox algorithms iteration public class arrayiterator implements iterator private final object _array private final int _start private final int _end private int _current public arrayiterator object array int start int length assert array null array null assert start start assert start array length start array length assert length length _array array _first start _last start length assert _last array length start length array length iterating portions array times iterate entire array convenience itõs good idea provide constructor takes array argument calculates starting positions public arrayiterator object array assert array null array null _array array _first _last array length array calculated upper lower bounds implementing couldnõt easier public void _current _first chapter _596748 ch02 qxd    public void _current _last traversing forward backward directly accessing arrays public void _current public void previous _current method isdone determine elements process case work determining current position falls bounds calculated constructor public boolean isdone return _current _first _current _last currentposition firstor elements iterator finished finally implement current retrieve current element array public object current throws iteratoroutofboundsexception isdone throw iteratoroutofboundsexception return _array _current works code block preceding reference underlying array variables hold current element positions  bit checking ensure values arguments sense invalid caller pass array length and starting position moving position elements itõs simply matter setting current position appropriately forward increment current position backward decrement notice ensure return calling isdone assumingthere return current position directly accessing array iteration recursion _596748 ch02 qxd    reverse iterator reverse iteration order changing code processes val ues imagine array names sorted ascending order ato displayed user user chose view names sorted descending order zto sort array implement code traversed array backward reverse iterator behavior achieved sorting dupli cated code application calls reverse iterator calls lying iterator application calls underlying iteratorõs previous method isinvoked behavior iterator reversed changing client code displays sorting array processing inten sive book write sorting algorithms outtesting reverse iterator tests reverse iterator straightforward main scenarios test forward itera tion backward vice versa cases test data iterate direction youõve tested implemented array iterator test reverse iterator package wrox algorithms iteration import junit framework testcase public class reverseiteratortest extends testcase private static final object array object test class defines array test cases test reverse iterator returns elements array order public void testforwardsiterationbecomesbackwards reverseiterator iterator reverseiterator arrayiterator array iterator assertfalse iterator isdone assertsame array iterator current iterator assertfalse iterator isdone assertsame array iterator current iterator assertfalse iterator isdone assertsame array iterator current iterator asserttrue iterator isdone chapter _596748 ch02 qxd    iterator current fail catch iteratoroutofboundsexception expected notice iterating forward array start finish values returned reverse order wasnõt apparent hoped powerful struct imagine array youõre iterating list data sorted order reverse sort order sorting public void testbackwardsiterationbecomesforwards reverseiterator iterator reverseiterator arrayiterator array iterator assertfalse iterator isdone assertsame array iterator current iterator previous assertfalse iterator isdone assertsame array iterator current iterator previous assertfalse iterator isdone assertsame array iterator current iterator previous asserttrue iterator isdone iterator current fail catch iteratoroutofboundsexception expected works test case ensures calling reverse iterator lastand previouselements array test iterating backward array returns items underlying iterator start finish test structurally previous test time youõre calling andprevious checking values returned start finish youõre ready reverse iterator practice iteration recursion _596748 ch02 qxd    outimplementing reverse iterator implementing reverse iterator easy invert behavior calls traversal methods previous simplicity weõve chosen entire class piece break individual methods package wrox algorithms iteration public class reverseiterator implements iterator private final iterator _iterator public reverseiterator iterator iterator assert iterator null iterator null _iterator iterator public boolean isdone return _iterator isdone public object current throws iteratoroutofboundsexception return _iterator current public void _iterator public void _iterator public void _iterator previous public void previous _iterator works implementing iteratorinterface class holds iterator reverse behavior calls isdone current delegated directly remaining methods previous redirect opposite numberñ previous respectivelyñthereby reversing direction iteration filtering iterator interesting advantages iterators capability wrap decorate decorator pattern gamma iterator filter return values chapter _596748 ch02 qxd    simple returning sophisticated processing database query remove unwanted values imagine scenario addition database query selection criteria client perform filtering filter iterator works wrapping iterator returning values satisfy condi tion predicate time underlying iterator called returned passed predicate determine discarded continuous evaluation values predicate enables data filtered predicate classyou creating interface represents predicate package wrox algorithms iteration public interface predicate public boolean evaluate object object interface simple method evaluate called andreturning boolean meets selection criteria evaluate returns true included returned filter iterator conversely predicate returns false treated existed simple predicate interface enables build sophisticated filters implement predicates enabling construction arbi trarily complex predicate outtesting predicate class write number tests ensure filter iterator performs correctly ensure filter returns underlying iterator predicate accepts perform tests combinations forward backward iterationñone predicate accepts values predicate rejects values package wrox algorithms iteration import junit framework testcase public class filteriteratortest extends testcase private static final object array predicate called item returned underlying iterator create predicate testing purposes private static final class dummypredicate implements predicate private final iterator _iterator private final boolean _result public dummypredicate boolean result iterator iterator iteration recursion _596748 ch02 qxd    _iterator iterator _result result _iterator public boolean evaluate object object assertsame _iterator current object _iterator return _result test ensure filter returns values predicate acceptsñ evaluate returns trueñwhile iterating forward public void testforwardsiterationincludesitemswhenpredicatereturnstrue iterator expectediterator arrayiterator array iterator underlyingiterator arrayiterator array iterator iterator filteriterator underlyingiterator dummypredicate true expectediterator iterator assertfalse iterator isdone assertsame array iterator current iterator assertfalse iterator isdone assertsame array iterator current iterator assertfalse iterator isdone assertsame array iterator current iterator asserttrue iterator isdone iterator current fail catch iteratoroutofboundsexception expected asserttrue expectediterator isdone asserttrue underlyingiterator isdone test simpler time predicate rejects valuesñthat evaluate returns false chapter _596748 ch02 qxd    public void testforwardsiterationexcludesitemswhenpredicatereturnsfalse iterator expectediterator arrayiterator array iterator underlyingiterator arrayiterator array iterator iterator filteriterator underlyingiterator dummypredicate false expectediterator iterator asserttrue iterator isdone iterator current fail catch iteratoroutofboundsexception expected asserttrue expectediterator isdone asserttrue underlyingiterator isdone remaining tests identical order iteration reversed public void testbackwardssiterationincludesitemswhenpredicatereturnstrue iterator expectediterator reverseiterator arrayiterator array iterator underlyingiterator arrayiterator array iterator iterator filteriterator underlyingiterator dummypredicate true expectediterator iterator assertfalse iterator isdone assertsame array iterator current iterator previous assertfalse iterator isdone assertsame array iterator current iterator previous assertfalse iterator isdone assertsame array iterator current iterator previous asserttrue iterator isdone iterator current fail catch iteratoroutofboundsexception expected asserttrue expectediterator isdone asserttrue underlyingiterator isdone iteration recursion _596748 ch02 qxd    public void testbackwardsiterationexcludesitemswhenpredicatereturnsfalse iterator expectediterator reverseiterator arrayiterator array iterator underlyingiterator arrayiterator array iterator iterator filteriterator underlyingiterator dummypredicate false expectediterator iterator asserttrue iterator isdone iterator current fail catch iteratoroutofboundsexception expected asserttrue expectediterator isdone asserttrue underlyingiterator isdone works test cases test class simple test data order test filter iterator adequately confirm expected iteration predicate called correctly dummypredicateinner class created testing purposes code block holds iterator return values order expect predicate called time evaluate called check correct passed addi tion checking values evaluate returns predetermined resultñset test casesñso check predicate accepts values rejects values create actual tests started creating iterators items expect predicate called provide items filter place construct filter iterator passing underlying iterator dummy predicate configured accept values passed evaluation position filter iterator item check fact item expected remainder test simply calls repeatedly iterator complete checking notice assertions test code block preceding ensure underlying iterator expected iterator exhausted test previous test construct predicate prede termined return false positioning filter iterator item expect finished straightawayñthe predicate rejecting values expect iterators exhausted expect underlying iterator values inspected test notice reverseiterator dummy iterator thinks itõs iterating ward reality itõs iterating backward chapter _596748 ch02 qxd    outimplementing predicate class tests place straight implementation youõve defined interface predicates create filter iterator class package wrox algorithms iteration public class filteriterator implements iterator private final iterator _iterator private final predicate _predicate public filteriterator iterator iterator predicate predicate assert iterator null iterator null assert predicate null predicate null _iterator iterator _predicate predicate public boolean isdone return _iterator isdone public object current throws iteratoroutofboundsexception return _iterator current case delegated underlying iterator searching forward current position satisfies filter public void _iterator filterforwards public void _iterator filterforwards private void filterforwards _iterator isdone _predicate evaluate _iterator current _iterator finally add previous surprisingly andnext public void _iterator iteration recursion _596748 ch02 qxd    filterbackwards public void previous _iterator previous filterbackwards private void filterbackwards _iterator isdone _predicate evaluate _iterator current _iterator previous filteriteratorcan traverse data structure supporting iterators create predicate specific filtering require works filter iterator class implements iteratorinterface holds iterator bewrapped predicate filtering constructor checks argument nullbefore assigning instance variables methods isdone current delegate respective methods underlying iter ator works underlying iterator state object allowed predicate current object real work iterator performed traversal methods called anytime previous invoked predicate include exclude values maintaining semantics iterator public void _iterator filterforwards public void _iterator filterforwards private void filterforwards _iterator isdone _predicate evaluate _iterator current _iterator chapter _596748 ch02 qxd    filterforwardsis called assumed underlying iterator posi tioned element start searching method loops calling eitherthere elements matching element notice cases methods underlying iterator directly prevents unnecessary looping abnormal program termination extreme cases public void _iterator filterbackwards public void previous _iterator previous filterbackwards private void filterbackwards _iterator isdone _predicate evaluate _iterator current _iterator previous previous respective methods wrapped class invoking filterbackwardsto element satisfies predicate recursion òto understand recursion understand recursion ó ñanonymous imagine file computer file root directory subdirectories files turn subdirectories files directory structure referred directory tree ña tree root branches directories leaves files figure  file represented tree notice inverted tree root leaves interesting things òtreesó computing sense branch smaller tree figure  tree time highlighting branches notice structure bigger tree iteration recursion _596748 ch02 qxd    figure  directory structure represented tree characteristic things granularities magnifications applied solving problems anytime problem broken smaller components larger divide conquer precisely recursion sense recursion ultimate pattern method calls dev tmpvarfd0tty036chapter _596748 ch02 qxd    figure  branches tree trees recursive directory tree printer letõs continue file analogy write program print contents entire direc tory tree examples demonstrate recursion involve finding prime num bers fibonacci numbers solving mazesñhardly things encounter daily basis simply printing names letõs format output file subdirectory indented parentñlike text version windows explorer mac finder structure file systems construct recursive algorithm traverse directory structure breaking problem solution works level calls deeper level directory tree tmpvarfd0dev tty037iteration recursion _596748 ch02 qxd    naturally start class program mand main method package wrox algorithms iteration import file public final class recursivedirectorytreeprinter private static final string spaces public static void main string args assert args null args null args length err println usage recursivedirectorytreeprinter dir exit print file args program requires single directory file passed command performing rudimentary checking main constructs filefrom argu ment passes print method notice argument method string print toindent output case itõs level directory tree printing donõt indenting constant spaces defined spaces usedlater increase indentation print method accepts single fileand string indenting output public static void print file file string indent assert file null file null assert indent null indent null print indent println file getname file isdirectory print file listfiles indent spaces code straightforward indentation printed file file represents directory fileobjects individual files directories print method process list files contained indentation chapter _596748 ch02 qxd    nest level tree increase inden tationñthat print shifted couple spaces achieve current indentation appending constant spaces indentation string case increase spaces spaces causing printed output shifted time method listfiles returns array donõt version print accepts letõs create public static void print file files string indent assert files null files null int files length print files indent method iterates array calling original print method file recursive recall print methodñthe takes single fileñcalls print method takes array turn calls method forever fact eventually print method runs filesñthat reaches arrayñand returns code sample output running program directory tree taining code book algorithmsbuildclassescomwroxalgorithmsiterationarrayiterator classarrayiteratortest classiterator classiteratoroutofboundsexception classrecursivedirectorytreeprinter classreverseiterator classreverseiteratortest classsingletoniterator classsingletoniteratortest classsrcbuild xmlconfbuild propertiescheckstyle header txtcheckstyle main xmlcheckstyle test xmlcheckstyle xslsimian xsllib39iteration recursion _596748 ch02 qxd    antlr  jarcheckstyle  jarcheckstyle optional  jarcommons beanutils jarcommons collections  jargetopt jarjakarta oro jarjakarta regexp jarjamaica tools jarjunit  jarsimian  jarmaincomwroxalgorithmsiterationarrayiterator javaiterator javaiteratoroutofboundsexception javarecursivedirectorytreeprinter javareverseiterator javasingletoniterator javaas output nicely formatted indentation time contents directory printed hoped demonstrated practical recursion solve kinds problems problem solved recursively solved iteratively times difficult cumbersome requiring data structures covered stacks chapter anatomy recursive algorithm matter problem recursive algorithm broken parts base case general case letõs reexamine previous identify elements base casein encounter single file dealing problem smallest level granularity perform action algorithm designed case print base case base case problem easily solve requiring recursion halting case prevents recursion continuing forever astackoverflowexceptionwhile executing recursive algorithm indication ing insufficient termination condition causing program nested calls eventually runs memory problem solve large computing resources chapter _596748 ch02 qxd    general casethe general case time recursive exam ple recursive occurs encounter file represents directory printed process files contained directory print method print method calls print method file directory methods recursively mutual recursion summary iteration recursion fundamental implementing algorithm fact rest book relies heavily concepts fully understand continuing chapter demonstrated iteration lends solving problems recursion natural iteration simple straightforward approach solving common problems performing calculations processing arrays simple array based iteration doesnõt scale real applications overcome introduced concept iterator discussed types iterators recursion divide conquerapproach method repeated nested calls choice processing nested data structures problems solved iteration recursion exercisesyou sample answers exercises exercises chapters appendix òexercise answers ó create iterator returns thelement integer greater create predicate performs boolean predicates implement powercalculatorusing recursion iteration replace arrays iterators recursive directory tree printer create iterator holds single create iterator iteration recursion _596748 ch02 qxd    _596748 ch02 qxd    listsnow familiar iteration basics algorithms time complex data structure lists fundamental data structure data structures built algorithms operate itõs hard examples lists real shopping lists lists train timetables order forms òlist lists ó arrays lists generally applica tions write fact lists great substitute arraysñit possi ble desirable replace arrays lists memory sensitive time critical applications chapter starts introducing basic operations list heads straight tests covering list implementations array lists linked lists imple mentations conform common interface characteristics differ ences affect applications chapter familiar lists lists likehow lists lists implemented understanding lists alist ordered collection elements supporting random access element arrayñyou query list contained arbitrary element lists preserve insertion order assuming intervening modifications list return position arrays lists attempt preserve uniqueness values meaning list duplicate values listcontaining values òswimmingó òcyclingó òdancingó add òswimmingó list grown include copies òswimmingó _596748 ch03 qxd    major difference arrays lists array fixed size lists sizeñgrowing shrinkingñas minimum list supports core operations table  table  core operations list operationdescription insertinserts list position  size listwill increase throws indexoutofboundsexceptionif specifiedposition range size deletedeletes position  list returns contained size list decrease throws indexoutofboundsexceptionif position therange size getobtains position  list throws indexoutofboundsexceptionif position range size sizeobtains number elements list operations absolutely accessing list opera tions listed copying pasting code repeatedly discovered sophisticated ways access lists specific method changing existing element array althoughyou achieve thing deleting element inserting place prevent unnecessary duplication logic repeatedly simple interface choose encapsulate common behavior inside list implementing conve nience operations table  table  convenience operations list operationdescription setsets position  list returns valueoriginally position throws indexoutofboundsexceptionifthe position range size addadds list size list increase deletedeletes occurrence list size list decrease returns trueif falseif doesnõt exist containsdetermines contained list indexofobtains position  occurrence list returns if equality determined bycalling valueõs equalsmethod chapter _596748 ch03 qxd    operationdescription isemptydetermines list returns trueif list size returns false iteratorobtains iteratorover elements list cleardeletes elements list size list reset operations implemented core operations choosing implement list create richer interface greatly simplifying job developer list set operation easily implemented combination delete andinsert add insert isempty size stress core operations richness encapsulation common functionality behavior data structure list powerful outcreating list interface operations general sense itõs time create actual interface implement chapter package wrox algorithms lists import wrox algorithms iteration iterable public interface list extends iterable public void insert int object throws indexoutofboundsexception public void add object public object delete int throws indexoutofboundsexception public boolean delete object public void clear public object set int object throws indexoutofboundsexception public object int throws indexoutofboundsexception public int indexof object public boolean object public int size public boolean isempty works literally operations converted meth ods interface parameters return types exceptions trivial interface numerous methods implement actual implementa tion extra functionality simple provide youõll notice listinterface extends iterableinterface introduced chapter interface single iterator method list write code iterate contents list lists06_596748 ch03 qxd    interface mind snippets code creates array values iterates printing turn string anarray anarray apple anarray banana anarray cherry int anarray length println anarray piece code creates list values iterates printing list alist alist add apple alist add banana alist add cherry iterator alist iterator isdone println alist current isnõt lot difference twoñyou argue ways version list readable add iterator helps convey intent code testing lists havenõt implemented single concrete list code scenarios lists encounter ensure correct behavior vari ous list implementations create tests implementation satisfy tests implement code requirements tables   definition list contract working tests gain good understanding expected behavior list easier time write ownimplementation outcreating generic test class list implementations ordinarily create individual test suite itõs create single test suite implementations create abstract class actual test cases hooks subclassing started define abstract base class extended concrete test classes specific implementation list chapter _596748 ch03 qxd    package wrox algorithms lists import wrox algorithms iteration iterator import wrox algorithms iteration iteratoroutofboundsexception import junit framework testcase public abstract class abstractlisttestcase extends testcase protected static final object value_a protected static final object value_b protected static final object value_c protected abstract list createlist common test data youõve defined abstract method returns instance list test methods list test anytime create test suite type list extend abstractlisttestcaseand implement createlist methodto return instance specific list class tests actual implementation letõs testing behavior list outtesting methods inserting adding values insertion fundamental function listñwithout lists remain code public void testinsertintoemptylist list list createlist assertequals list size asserttrue list isempty list insert value_a assertequals list size assertfalse list isempty assertsame value_a list test insert betweentwo values expect elements insertion point shift position room public void testinsertbetweenelements list list createlist list insert value_a list insert value_b list insert value_c lists06_596748 ch03 qxd    assertequals list size assertsame value_a list assertsame value_c list assertsame value_b list insert element list public void testinsertbeforefirstelement list list createlist list insert value_a list insert value_b assertequals list size assertsame value_b list assertsame value_a list test inserting afterthe element fundamentally add list type insertion public void testinsertafterlastelement list list createlist list insert value_a list insert value_b assertequals list size assertsame value_a list assertsame value_b list youõll test list correctly handles attempt insert position falls bounds cases expect indexoutofboundsexceptionto thrown indicating application programming error public void testinsertoutofbounds list list createlist list insert value_a fail catch indexoutofboundsexception expected list insert value_b fail catch indexoutofboundsexception expected chapter _596748 ch03 qxd    finally test add method simple add list theinsert method natural requires coding express intention specific method public void testadd list list createlist list add value_a list add value_c list add value_b assertequals list size assertsame value_a list assertsame value_c list assertsame value_b list works method testinsertintoanemptylist checks insert list size list increase retrieve expected position method testinsertbetweenelements tests attempt insert valuebetween test starts list valuesñ aand bin positions and figure  figure  list prior insertion inserts valueñ cñbetween position aand list figure  figure  list insertion elements bhas shifted position room i ndex acindex bindex i ndex ab49lists06_596748 ch03 qxd    method testinsertbeforefirstelement ensures inserting position shifts existing values place test insertion pointñposition ñeach time insert called confirms values correct order ashould start position place room method testinsertafterlastelement ensures add list insert ing position greater valid position list contained ele ment inserting position place list contained elements inserting position place add list inserting position defined size list method testinsertoutofbounds checks list correctly identifies common pro gramming errors negative insertion point insertion point greater size list insertion point size list adds test codestarts list meaning positionñposition ñis place inserted attempt negative greater result indexoutofboundsexception finally method testadd tests behavior convenience method add values list checked ensure correct order relative simplicity testadd versus testinsertafterlastelement specificmethod adding list code readable requires code requires thinking calling add intuitive calling insert passing size insertion point outtesting methods retrieving storing values place values list thing youõll access tested behavior size isempty matter test ing insert add youõll start testing set public void testset list list createlist list insert value_a assertsame value_a list assertsame value_a list set value_b assertsame value_b list thing havenõt tested boundary conditions attempt access list start element insert attempts access listbeyond boundaries result indexoutofboundsexception public void testgetoutofbounds list list createlist list fail chapter _596748 ch03 qxd    catch indexoutofboundsexception expected list fail catch indexoutofboundsexception expected list add value_a list fail catch indexoutofboundsexception expected test boundary conditions calling set public void testsetoutofbounds list list createlist list set value_a fail catch indexoutofboundsexception expected list set value_b fail catch indexoutofboundsexception expected list insert value_c list set value_c fail catch indexoutofboundsexception expected lists06_596748 ch03 qxd    works method set works setting element array populating list testset replaces ensures returned original method testgetoutofbounds starts list attempts access neg ative position position large doubly adds list creating element position access list cases expect indexoutofboundsexceptionto thrown method testsetoutofbounds basically testgetoutofbounds ofattempting retrieve attempt update calling set outtesting methods deleting values type deletion youõll test involves deleting element list expect deletion list public void testdeleteonlyelement list list createlist list add value_a assertequals list size assertsame value_a list assertsame value_a list delete assertequals list size delete element list element values shift left place public void testdeletefirstelement list list createlist list add value_a list add value_b list add value_c assertequals list size assertsame value_a list assertsame value_b list assertsame value_c list assertsame value_a list delete assertequals list size assertsame value_b list assertsame value_c list chapter _596748 ch03 qxd    delete element list element public void testdeletelastelement list list createlist list add value_a list add value_b list add value_c assertequals list size assertsame value_a list assertsame value_b list assertsame value_c list assertsame value_c list delete assertequals list size assertsame value_a list assertsame value_b list test behavior deleting values shift left place public void testdeletemiddleelement list list createlist list add value_a list add value_c list add value_b assertequals list size assertsame value_a list assertsame value_c list assertsame value_b list assertsame value_c list delete assertequals list size assertsame value_a list assertsame value_b list ensure attempts delete list bounds throw indexoutofboundsexception public void testdeleteoutofbounds list list createlist list delete fail catch indexoutofboundsexception lists06_596748 ch03 qxd    expected list delete fail catch indexoutofboundsexception expected youõve tested delete position deleting deleting straightforward deleting indexñas list ensure event duplicates deleting removes occurrence time called public void testdeletebyvalue list list createlist list add value_a list add value_b list add value_a assertequals list size assertsame value_a list assertsame value_b list assertsame value_a list asserttrue list delete value_a assertequals list size assertsame value_b list assertsame value_a list asserttrue list delete value_a assertequals list size assertsame value_b list assertfalse list delete value_c assertequals list size assertsame value_b list asserttrue list delete value_b assertequals list size works tests exercise basic functionality deleting specific element deletion inverse insertion expect element deleted size list decrease elements deleted element shift left contract òdeleteby indexó states return deleted tested chapter _596748 ch03 qxd    method testdeleteoutofbounds ñas bounds checking testsñattempts access list invalid position negative position position big time expect indexoutofboundsexceptionto thrown application pro gramming error method testdeletebyvalue ensures delete list knowing exact location test inserts values list duplicates removes duplicate values ensures contained list ensure occurrence removed attempts delete doesnõt exist list finally deletes remain ing leaving list time checked returned deleteiscorrect deleting exists return true deleting unknown shouldreturn false outtesting iteration difficult parts list implementation iteration recall listinter face extends iterableinterface chapter requiring implementations provide iterator contents test general scenarios iteration list iteration forward start iteration backward start testing behavior iterating list public void testemptyiteration list list createlist iterator iterator list iterator asserttrue iterator isdone iterator current fail catch iteratoroutofboundsexception expected test forward iteration list public void testforwarditeration list list createlist list add value_a list add value_b list add value_c iterator iterator list iterator iterator lists06_596748 ch03 qxd    assertfalse iterator isdone assertsame value_a iterator current iterator assertfalse iterator isdone assertsame value_b iterator current iterator assertfalse iterator isdone assertsame value_c iterator current iterator asserttrue iterator isdone iterator current fail catch iteratoroutofboundsexception expected finally test reverse iteration element list public void testreverseiteration list list createlist list add value_a list add value_b list add value_c iterator iterator list iterator iterator assertfalse iterator isdone assertsame value_c iterator current iterator previous assertfalse iterator isdone assertsame value_b iterator current iterator previous assertfalse iterator isdone assertsame value_a iterator current iterator previous asserttrue iterator isdone iterator current fail catch iteratoroutofboundsexception expected chapter _596748 ch03 qxd    works iterating list expect isdone return true indicating elements method testforwarditeration creates list values obtains iterator calls start element list successive calls andcurrent checking values returned expected order method isdone shouldonly return trueafter elements visited testing reverse iteration steps testing forward iteration start element work backward calling previous cases iterator completedñ isdone returns trueñan attempt access iterator calling current throw iteratoroutofboundsexception outtesting methods finding values lists enable searching values indexof methods indexof method returns position  if inthe event list duplicate values indexof occurrence public void testindexof list list createlist list add value_a list add value_b list add value_a assertequals list indexof value_a assertequals list indexof value_b assertequals list indexof value_c method returns trueif returns false public void testcontains list list createlist list add value_a list add value_b list add value_a asserttrue list value_a asserttrue list value_b assertfalse list value_c lists06_596748 ch03 qxd    works tests populate list values duplicate method testindexof checks correct position returned existing valuesñ aand bñand is returned existing valueñ case duplicate posi tion occurrence returned method testcontains checks returns truefor existing values falsefornonexisting outtesting list cleared test reset list calling clear list shouldbe size reset public void testclear list list createlist list add value_a list add value_b list add value_c assertfalse list isempty assertequals list size list clear asserttrue list isempty assertequals list size works method testclear populates list values calls clear list checked ensure longer values implementing listsby understanding list functionality codified expected behavior tests easily determine implementations working expected dive earned production coding ways implement list common presented array based implementation called linked list suggests array list array hold values alinked list conversely chain elements item reference link optionally previous element simplest case array list sophisticated linked list characteristics depending requirements chapter _596748 ch03 qxd    application reason specific pros cons explana tion code case assumptions type data stored list lists null values allowing null values simplifies code removing boundary conditions tend dealing null values restriction shouldnõt concern business applications lists rarely null values array list suggests array list array underlying mechanism storing elements fact directly arrays implementing access elements trivial array list fastest implementation indexed sequential access downside array time insert element shift ele ments higher positions place physically copying deleting existing element shift objects higher positions place left gap leftby deleted element additionally arrays fixed size anytime increase size list reallocate array copy contents performance inser tion deletion array list good starting point moving simple arrays richer data structures lists outcreating test class define test cases ensure implementation correct start creating class named arraylisttestthat extends abstractlisttestcaseclass created earlier package wrox algorithms lists public class arraylisttest extends abstractlisttestcase protected list createlist return arraylist public void testresizebeyondinitialcapacity list list arraylist list add value_a list add value_a list add value_a assertequals list size assertsame value_a list assertsame value_a list assertsame value_a list public void testdeletefromlastelementinarray lists06_596748 ch03 qxd    list list arraylist list add object list delete works hard work created abstractlisttestcaseclass earlier extending class inherited tests needed implement createlist method order return instance arraylistclass tests addition standard tests couple extras needed array lists work internally method testresizebeyondinitialcapacity needed size arraylist increases underlying array resized accommodate extra elements contents correctly copied test starts constructing array list initial capacity values underlying array grow consequence elements copied original array larger test ensures size contents copied implies test method testdeletefromlastelementinarray checks whathappens delete element list code bit boundary condition lead arrayindexoutofboundsexceptionsif handled correctly outcreating arraylist class created test cases safely proceed creating array list implementa tion start creating arraylistclass package wrox algorithms lists import wrox algorithms iteration arrayiterator import wrox algorithms iteration iterator public class arraylist implements list private static final int default_initial_capacity private final int _initialcapacity private object _array private int _size public arraylist default_initial_capacity public arraylist int initialcapacity assert initialcapacity initialcapacity _initialcapacity initialcapacity chapter _596748 ch03 qxd    clear public void clear _array object _initialcapacity _size works class simple fields implement listinterface created field hold array elements separate field hold size list aware size list size array array òspareó capacity length array doesnõt match number ele ments stored list constructors convenienceñit calls default values constructor takes argument size initial array validated saved calling clear initialize element array reset size list technically require resizing array time inserted force caller pass outmethods inserting adding values method implement inserts values list position public void insert int object throws indexoutofboundsexception assert null null _size throw indexoutofboundsexception ensurecapacity _size arraycopy _array _array _size _array _size private void ensurecapacity int capacity assert capacity capacity _array length capacity object copy object capacity capacity arraycopy _array copy _size _array copy lists06_596748 ch03 qxd    insert adding list naturally public void add object insert _size works insert method starts validating input instance check nullvalues explicitly allowed recall test cases insert isrequired throw indexoutofboundsexceptionif attempt insert ele ment element list arrays fixed size lists ensure underlying array capacity hold array lengthfive wanted add sixth element array doesnõt space wonõtmagically resize ensurecapacity ensures room array accommodate ensurecapacity returns space safely shift existing elements position makeroom finally store element remembering increase size list method ensurecapacity handles dynamic resizing underlying array anytime detects underlying array small array allocated contents copied array discarded freeing garbage collection number strategies determining big allocate array size array increased additional percent required kind safety net ensures list doesnõt spend time allocating arrays copying val ues add method simply delegates insert passing size list insertion point ensuring outmethods storing retrieving values position create methods set storing retrieving values implementation based arrays access contained values trivial public object int throws indexoutofboundsexception checkoutofbounds return _array public object set int object throws indexoutofboundsexception assert null null checkoutofbounds object oldvalue _array _array return oldvalue chapter _596748 ch03 qxd    private void checkoutofbounds int isoutofbounds throw indexoutofboundsexception private boolean isoutofbounds int return _size works checking requested position valid method returns contained element set method replaces additionally set takes copy originally stored position overwriting original returned caller array list performs extremely indexed access fact indexed access list generally considered array lists close deliv ering promise identical worst average case performance outmethods finding values discussion set lists ideal storing values positions perfect types sorting chapters  searching chapter determine position specific unsortedlist willhave crude straightforward method linear searching indexof method enables position specific list position returned is returned doesnõt exist public int indexof object assert null null int _size equals _array return return provided mechanism searching list indexof proceed implement public boolean object return indexof lists06_596748 ch03 qxd    works indexof method performs linear search list achieves goal starting position list working element reached method calls indexof perform search behalf returns trueonly isfound indexof simple implement linear searching doesnõt scale large lists imagine list taining values cat dog mouse zebra imagine search turn cat dog count number comparisons needed cat list comparison dogwill mousethree zebrafour calculate average number comparisons required     cansee list nitems average number comparisons required worst case time efficient method searching chapter òbinary searching ó introduces efficient method searching list òbrute forceó approach searching outmethods deleting values listinterface methods deleting values enables delete position public object delete int throws indexoutofboundsexception checkoutofbounds object _array int copyfromindex copyfromindex _size arraycopy _array copyfromindex _array _size copyfromindex _array _size null return support deletion knowing precise location advantage fact mechanism determining position indexof public boolean delete object int indexof delete return true return false chapter _596748 ch03 qxd    works checking validity input delete method copies values ofthe deletion point left position size list decremented element array cleared clear element array havenõt moved values leftby position youõve copied didnõt clear element taining inadvertently hold copies deleted values preventing garbage collected commonly referred memory leak notice bounds checking ensure donõt arrayindexoutofboundsexceptionwhendeleting element array fact commenting entire block code ifstatement rerunning tests notice careful copy stored deleted position returned caller worth noting capacity underlying array shrinks list grows large shrinks lot òwastedó storage problem implementing inverse ensurecapacity time delete ele ment list check size percentage threshold size drops percent list capacity reallocate smaller array copy tents freeing unused storage sake clarity chosen code jdk implementation arraylistbehaves worry cases mind delete works calling indexof determine position occurrence calling delete method performance delete method ñdiscounting time copy valuesñwhereas delete isintrinsically tied performance indexof average deletion time outcompleting interface youõre implementing entire listinterface methods cover public iterator iterator return arrayiterator _array _size public int size return _size public boolean isempty return size lists06_596748 ch03 qxd    works iterator method simpleñyou code form arrayiteratorclass chapter implementing size method simpler insert delete methods main tain size list simply return stored _sizefield finally isempty returns trueonly size list size trivial implementation isempty ñlike convenience methods listinterfaceñmakes application code readable reducing ònoise ó linked list array hold elements linked list individual elements linksbetween figure  element linked list reference link previous elements acting links chain figure  elements doubly linked list references directions precisely referred doubly linked list element links opposed asingly linked list element link double linking tra verse elements direction insertion deletion simpler array list recall discussion array lists cases deleting inserting portion underlying array copied linked list time insert delete element update references previous ele ments cost actual insertion deletion negligible extreme cases lists extremely large numbers elements traversal time formance issue adoubly linked list maintains references elements listñoften referred head tail enables access equal performance outcreating test class remember tests validating implementation meets requirements set tables   chapter time create class named linkedlisttestthat extends abstractlisttestcase aindex nextbindex cprevious nextprevious chapter _596748 ch03 qxd    package wrox algorithms lists public class linkedlisttest extends abstractlisttestcase protected list createlist return linkedlist works arraylisttestclass earlier extend abstractlisttestcasein order advantage predefined test cases time createlist method returns instance linkedlist notice time havenõt created additional test cases tests defined abstractlisttestcasewill sufficient outcreating linkedlist class creating linkedlistclass fields constructors package wrox algorithms lists import wrox algorithms iteration iterator import wrox algorithms iteration iteratoroutofboundsexception public class linkedlist implements list private final element _headandtail element null private int _size public linkedlist clear works list thing implement listinterface youtrack size list instance variable _size theoretically derive size time itõs required counting element wouldnõt scale obvious single unmodifiable element _headandtailinstead refer ences discussed start field sentinel asentinelñoften referred null object patternor simply null objectñis technique simplifying algorithm adding special element ends data structure avoid writing special code handles bound ary conditions sentinel code littered statements checked updated nullreferences head tail previous fields sen tinel point elements list elements refer sentinel element chain sentinels difficult concept grasp donõt worry strange fact formulatean algorithm sentinels intuitive process accustomed algorithms elegant succinctñtry writing doubly linked list lists06_596748 ch03 qxd    lastly constructor calls clear youõll create clear method donõt worry nowñsuffice resets internal state class outcreating element class array list linked list inherent place store values representing element create aptly named elementinner class private static final class element private object _value private element _previous private element _next public element object setvalue public void setvalue object _value public object getvalue return _value public element getprevious return _previous public void setprevious element previous assert previous null previous null _previous previous public element getnext return _next public void setnext element assert null null _next public void attachbefore element assert null null element previous getprevious setnext setprevious previous setprevious previous setnext public void detach chapter _596748 ch03 qxd    _previous setnext _next _next setprevious _previous works class elementis straightforward addition holding element holds references previous elements simple methods setting fields point code insert element list logic encapsu lated inside method attachbefore suggests method element insert storing refer ences previous elements updating refer delete elements created method detach elementto remove chain setting previous elements point notice point needed check nullvalues update references head tail sentinel sentinel itselfaninstance element bea previous element update outmethods inserting adding values inserting linked list conceptually simpler array list resizing involved bit logic involved finding correct insertion point public void insert int object throws indexoutofboundsexception assert null null _size throw indexoutofboundsexception element element element element attachbefore getelement _size private element getelement int element element _headandtail getnext int element element getnext return element lists06_596748 ch03 qxd    add simply delegate insert passing size list point insertion public void add object insert _size works insert starts validating input create element speci fied insertion point attach chain finally incrementing size list reflect change getelement method workhorse linked list implementation called number methods traverses list search element position brute force approach insert delete average worst case ning time improve actual performance getelement joke òq long linked list distance middle ó recall linked list implementa tion holds reference ends list head position searching falls half list start element work forward conversely desired position falls half list start searching element work backward traverse half list reach destination magnitude search times effectively cut actual aver age running times half left exercise chapter outmethods storing retrieving values setting retrieving values linked list identical array list indexing array getelement method youintroduced insert public object int throws indexoutofboundsexception checkoutofbounds return getelement getvalue public object set int object throws indexoutofboundsexception assert null null checkoutofbounds element element getelement object oldvalue element getvalue element setvalue return oldvalue private void checkoutofbounds int isoutofbounds throw indexoutofboundsexception chapter _596748 ch03 qxd    private boolean isoutofbounds int return _size works cases checking validity position desired element set set tied implementation getelement running times constrained indexed based retrieval values linked list slower average array list outmethods finding values conceptually searching linked list searching array list choice start continue searching simply elements public int indexof object assert null null int element _headandtail getnext _headandtail getnext equals getvalue return return method identical arraylist public boolean object return indexof works difference linked list array list implementations indexof navigate element array list itõs easy simply increment access array directly linked lists hand links element position returned sentinel lists06_596748 ch03 qxd    reached fallen list loop terminates is returned indi cate doesnõt exist method calls indexof returns true outmethods deleting values deletion linked list trivial implemented code inside elementinner class earlier public object delete int throws indexoutofboundsexception checkoutofbounds element element getelement element detach _size return element getvalue hereõs method deleting public boolean delete object assert null null element _headandtail getnext _headandtail getnext equals getvalue detach _size return true return false works checking position valid delete method obtains ele ment calling getelement detaches decrements size list returning code delete method indexof difference tracking returning position finding matching element delete return donõt forget decrement size list calling detach outcreating iterator iteration linked list involved array list searching deleting simply matter linksñin directionñuntil reach create class valueiterator encapsulate iteration logic chapter _596748 ch03 qxd    private final class valueiterator implements iterator private element _current _headandtail public void _current _headandtail getnext public void _current _headandtail getprevious public boolean isdone return _current _headandtail public void _current _current getnext public void previous _current _current getprevious public object current throws iteratoroutofboundsexception isdone throw iteratoroutofboundsexception return _current getvalue defined class return instance iterator method public iterator iterator return valueiterator works valueiteratorclass virtually identical arrayiteratorclass chapter case searching deleting getnext getprevious methods tra verse forward backward elements reach sentinel outcompleting interface arrived methods interface size isempty clear public int size return _size public boolean isempty return size lists06_596748 ch03 qxd    public void clear _headandtail setprevious _headandtail _headandtail setnext _headandtail _size works surprisingly size isempty methods carbon copies array list counterparts method clear simple array list implementation order maintain correct behavior sentinel set previous values point ensures insert element list previous val ues point sentinel sentinelõs previous values point element summary chapter demonstrated lists replacement arrays real applications learned lists preserve insertion order inherent concept uniqueness youõve covered lot code order examine common list implementa tions relative performance characteristics array lists linked lists search iteration times nature array lists based access pared linked lists hand linked lists donõt overhead copying resizing array lists generally insertion deletion times ends lists situations times behavior needed chapters discuss variations lists queuesand stacks solve specific computing problems exercises1 write constructor arraylistthat accepts standard array initially populate list write equals method work listimplementation write tostring method work listimplementation prints tents single values surrounded square brackets separated commas ò ó ò ó list create iteratorthat work listimplementation performance implications update linkedlistto traverse backward inserting deleting desired halfway list rewrite indexof work list create listimplementation throws unsupportedoperationexceptionif attempt modify chapter _596748 ch03 qxd    queuesqueues essential algorithms manage allocation scheduling work events messages processed enabling processesñ machinesñto communicate chapter learn queues differ lists characteristics implementation fifo queuehow create thread safe queue create bounded queueñone maximum size limit combine queue types build multi threaded simulation center queues useunderstanding queues customers bank waiting served teller supermarkets waiting checkout doubt youõve stuck waiting speak customer service representative center computing terms queue list data items stored retrieved definable order main distinguishing feature queue list items list accessibleñby position listñthe item retrieve queue head item head dependson specific queue implementation order retrieval order insertion fifo possibilities common examples include queue chapter priority queue chapter retrieval based relative priority item create random queuethat effectively òshufflesó contents _596748 ch04 qxd    book term òqueue ó referring fifo queue queues terms producers consumers producer stores data queue consumeris retrieves data queue figure  interac tions producers consumers queues figure  producers consumers interact queue queues ether boundedor unbounded bounded queues limits number itemsthat held time memory constrainedñfor device router memory message queue unbounded queues conversely free grow size limits hardware queue operationsthis chapter describes queues book retrieval order irrespective behavior queues share common interface table  lists queue operations description table  queue operations operationdescription enqueuestores queue size queue increase dequeueretrieves head queue size queue decrease throws emptyqueueexceptionif items queue cleardeletes elements queue size queue reset sizeobtains number elements queue isemptydetermines queue size producerqueueproducerproducerconsumerconsumerconsumer76chapter _596748 ch04 qxd    queue interface simpler list enqueue responsible storing values dequeue retrieving remaining methods behavior names defined lists notice accessing data items queue iterator chapter reinforcing idea thing item head queue interfaceany operations defined translated directly interface easily create pluggable implementations package wrox algorithms queues public interface queue public void enqueue object public object dequeue throws emptyqueueexception public void clear public int size public boolean isempty operation translated directly method interface thing define emptyqueueexceptionthrown dequeue package wrox algorithms queues public class emptyqueueexception extends runtimeexception chosen emptyqueueexceptiona runtime extension forced wrap catchblocks calls dequeue primary reason retrieval attempts queue programming error isempty check calling dequeue queue describes implementation fifo queue youõll learn characteristics fifo queue youõll develop tests finally implement straightforward unbounded fifo queue based lists calling dequeue fifo queue returns element queue longest enqueue values cat dog apple banana callingdequeue return order cat dog apple banana ways implement fifo queue types queues matter simplest solutions presented list underlying storage mech anism ways natural fit aqueue thought simplified list includes constraints adding removing items queues07_596748 ch04 qxd    enqueue list figure  figure  calling enqueue adds list conversely dequeue removed list figure  figure  calling dequeue removes start list easily chosen add start remove work instance chosen add remove start fit mental model queue discussed design itõs time write code usual youõll write tests actual queue implementation outtesting fifo queue youõre examine implement fifo queue keeping approach book youõll develop suite tests fifo queue pass tests defined abstract class hooks enable extendthem order test specific implementations package wrox algorithms queues import junit framework testcase public abstract class abstractfifoqueuetestcase extends testcase private static final string value_a private static final string value_b private static final string value_c private queue _queue protected void setup throws exception dogapple catbananacatdogapple banana78chapter _596748 ch04 qxd    super setup _queue createfifoqueue protected abstract queue createfifoqueue test bit bounds checking list returns size isempty returns true attempting dequeue emptyqueueexception public void testaccessanemptyqueue assertequals _queue size asserttrue _queue isempty _queue dequeue fail catch emptyqueueexception expected test longer pretty straightforward checks success fully enqueue dequeue values public void testenqueuedequeue _queue enqueue value_b _queue enqueue value_a _queue enqueue value_c assertequals _queue size assertfalse _queue isempty assertsame value_b _queue dequeue assertequals _queue size assertfalse _queue isempty assertsame value_a _queue dequeue assertequals _queue size assertfalse _queue isempty assertsame value_c _queue dequeue assertequals _queue size asserttrue _queue isempty _queue dequeue fail catch emptyqueueexception queues07_596748 ch04 qxd    expected final test ensure clear queue emptied expected public void testclear _queue enqueue value_a _queue enqueue value_b _queue enqueue value_c assertfalse _queue isempty _queue clear assertequals _queue size asserttrue _queue isempty _queue dequeue fail catch emptyqueueexception expected developed abstract test class create concrete test class actual fifo queue implementation havenõt defined implementation class wonõt stopus defining test case package wrox algorithms queues public class listfifoqueuetest extends abstractfifoqueuetestcase protected queue createfifoqueue return listfifoqueue works test class abstractfifoqueuetestcase defines constants theactual tests defines local variable _queue holding instance fifo queue running tests setup methodñcalled prior running individual testñensures local variable achieves calling createfifoqueue abstract methodyou implement return instance specific fifo queue class test tests ensure time enqueued dequeued actions reflected accurately size queue importantly retrieve values returned order stored definition fifo queue final test simply stores number values queue calls clear ensures queue chapter _596748 ch04 qxd    creation concrete class queue class named listfifoqueue factthat fifo queue list store data notice easy extend abstractfifoqueuetestcaseand implement createfifoqueuemethod return instance concrete queue class implementing fifo queuewith tests place safely start coding implementation class listfifoqueue package wrox algorithms queues import wrox algorithms lists linkedlist import wrox algorithms lists list public class listfifoqueue implements queue private final list _list public listfifoqueue list list assert list null list null _list list public listfifoqueue linkedlist implementing queueinterface holds underlying list defines constructors constructor takes argument list storing data naturally checked null secondña default constructorñcalls passing instance linked list alinked list perfectly suited queue capable efficiently adding removing elements compare array list recall incurs overhead continually moving elements removed construct list based fifo queue add things queue enqueue public void enqueue object _list add pretty simple discussed earlier enqueue add underlying list implement dequeue enables retrieve items queue public object dequeue throws emptyqueueexception isempty throw emptyqueueexception queues07_596748 ch04 qxd    return _list delete wasnõt complicated remember dequeue simply removes returns element underlying list extra action quick check ensure ele ment remove isnõt list throw emptyqueueexceptionas defined queueinterface argue listinterface throws indexoutofboundsexception simply catch exception throw emptyqueueexceptioninstead checking foran list mentioned indexoutofboundsexceptionwas tobe thrown propagate indication programming error thing caller wrong methods queueinterface easier implement coinciden tally method listinterface public void clear _list clear public int size return _list size public boolean isempty return _list isempty cases delegate underlying list blocking queuesqueues multi threaded environments form interprocess communication listfifoqueueis totally unsafe situations multiple consumers accessing concurrently blocking queueis provide thread safe imple mentation ensuring access data correctly synchronized main enhancement blocking queue offers regular queue bounded chapter dealt unbounded queuesñthose continue grow limit blocking queue enables set upper limit size queue attempt store item queue reached limit queue guessed block thread space availableñeither removing item calling clear inthis guarantee queue exceed predefined bounds major feature behavior dequeue recall implementation listfifoqueuepresented earlier emptyqueueexceptionis thrown attempt retrieve item queue ablocking queue block current chapter _596748 ch04 qxd    thread item enqueuedñperfect implementing work queues multiple concurrent consumers wait tasks perform encapsulating queueinterface free consumers queue intrica cies subtleties thread synchronization options creating blocking queue extendan existing queue implementation listfifoqueue wrap behavior queue option lock specific queue implementation youshould optionñwrap queueñas flexibility easily turn anyqueue implementation priority queues presented chapter blocking queue synchronization concerned common technique ensuring code plays nicely multi threaded environment alock object technical terms mutual exclu sion semaphore mutex synchronization point methods class amutex error prone ways ensuring thread access underlying queue time outusing blockingqueue point òand start tests ó exercise deviate norm skip writing tests altogether tests write tests explanation testing multi threaded applications scope book chose omit text youõre trust tests downloading entire source code book learn writing multi threaded code starting doug leaõs concurrent programming design principles patterns discussion blockingqueuecode starts class declaration package wrox algorithms queues public class blockingqueue implements queue private final object _mutex object private final queue _queue private final int _maxsize public blockingqueue queue queue int maxsize assert queue null queue null assert maxsize size _queue queue _maxsize maxsize public blockingqueue queue queue queues07_596748 ch04 qxd    queue integer max_value blockingqueueimplements queueinterface holds instance variables variables pretty straightforward queue holds reference underlying queue data stored _maxsize holds maximum allowable size queue variable _mutex lock object earlier constructors takes queue data storage maximum allowable size constructor enables create bounded queue constructor accepts queue calls constructor passing largest integer maximum queue size limit large effectively created unbounded queue itõs time implementing desired behavior starting enqueue itmay spooky itõs complicated public void enqueue object synchronized _mutex size _maxsize waitfornotification _queue enqueue _mutex notifyall private void waitfornotification _mutex wait catch interruptedexception ignore works thing enqueuedoes methods matter ensure threads access queue time achieved synchronizedto lockon objectñin case mutex thread lock current thread blocked thread releases lock threads access queue current thread falls synchronized block enables manipulate underlying queue worrying stepping actions thread thread unexpectedly manipulating underlying queue sole access queue thing ensure bounds respected queue maximum allowable size thread opportunity free space achieved waitfornotification method this84chapter _596748 ch04 qxd    method calls mutexõs wait method effectively putting thread sleep putting thread sleep temporarily lock queue thread woken sleep thread notifyall method mutex time enqueue willregain control eventually space stored underlying queue notifyall mutex threads asleep woken outimplementing dequeue implementing dequeue retrieves stores queue public object dequeue throws emptyqueueexception synchronized _mutex isempty waitfornotification object _queue dequeue _mutex notifyall return enqueue dequeue obtains exclusive lock ensure thread accessing queue waits item calling dequeue theunderlying queue works enqueue youõre notifyall dequeue retrieves items notify threads blocked calling enqueue queue reaches maximum allowable size outimplementing clear method clear method simpler public void clear synchronized _mutex _queue clear _mutex notifyall works obtaining lock usual manner underlying queue cleared dequeue threads notified case blocked waiting store items queue reached size limit queues07_596748 ch04 qxd    outimplementing size isempty methods finally code methods size isempty public int size synchronized _mutex return _queue size public boolean isempty synchronized _mutex return _queue isempty works methods simply wrap underlying queueõs equivalent method inside thread safe synchronization code case modification underlying queue notifyall center simulatornow itõs time queues youõve learned practicalñif simplisticñcontext youõve learned queues allocating prioritizing work youõre scenarios center build simulator blocking queue main idea pretty simple develop calls randomly center queued ready answered customer service agent figure  idea main concepts involved figure  high level design center simulation callgeneratorcustomerserviceagentcall call blocking queuecall centercall customerserviceagentcustomerserviceagent86chapter _596748 ch04 qxd    acall generator creates calls center center stores blocking queue wait answered customer service agent agent pletes returns queue attempts retrieve calls pro cessed queue returns queue block appears customer service agent worry calls answered logic handled blocking queue notice queue customer service agents live center notice multiple customer service agents working timeñjust real concurrent execution customer service agent thread thankfully blocking queue implementation designed multi threading mind queue point thread contention context thereõs worry synchronizing parts application simulator developed stand application print log messages consoleas runs happening program enables simulations dif ferent scenarios based values variables variables mand number customer service agentsnumber callsmaximum durationmaximum intervalthe number customer service agents enables number threads consuming calls queue agents threads faster calls processed flip depending rate generated calls threads agents wait ing calls arrive queue number calls determines calls total generate purely safety precaution prevent application running forever prefer set large number maximum duration defines upper limit long answered enables simulate calls longer shorter amounts time maximum interval defines upper limit long wait generating design straightforwardñweõve simple possibleñand involves classes addition blockingqueuedeveloped earlier class fully idea weõre achieve itõs time develop application reasons explained forgo usual tests jump straight code remember tests downloadable source code felt explana tion text confuse issue youõll start creating class concepts depicted figure  finish simple simulator application command queues07_596748 ch04 qxd    monitor behavior simulation runs class prints sole application youõll flood messages showing happening inside simulator weõve included output idea diagnostic outcreating class represents telephone calls queued center subse quently answered customer service agent discussed package wrox algorithms queues public class private final int _id private final int _duration private final long _starttime public int int duration assert duration calltime _id _duration duration _starttime currenttimemillis public string tostring return _id works assigned unique duration enables track progress duration determines time spent òansweringó lastly record time started determine long waiting queue method class answer method customer service agent youguessed answer public void answer println answered waited currenttimemillis _starttime milliseconds thread sleep _duration catch interruptedexception ignore chapter _596748 ch04 qxd    start printing fact answered total time spent waiting queue method sleep duration constructed responsible simulating time complete customer wonõt hang theyõre ready outcreating customerservice agent class class customerserviceagentñthe consumer figure  class responsible pulling calls queue answering package wrox algorithms queues public class customerserviceagent implements runnable hung onpublic static final go_home  private final int _id private final queue _calls public customerserviceagent int queue calls assert calls null calls null _id _calls calls public string tostring return agent _id agent assigned unique helps identify agent agent holds reference queue retrieve calls notice customerserviceagentimplements runnableinterface enables instance tobe separate thread enabling multiple agents concurrently runnablespecifiesone method implemented youõll code pulls calls queue answers public void println clocked true println waiting _calls dequeue println answering go_home break answer queues07_596748 ch04 qxd    println works time customer service agent prints message started working sits loop pulling calls queue answering time retrieved mes sage printed answered completed agent queue noticed check determine exists calling dequeue forgiven thinking wonõt long encounter emptyqueueexception blocking queue recall blocking queue thread safe waitsñas opposed throwing exceptionñwhen queue odd thing method piece code go_home break check agent continue looping forever waiting calls arrive imagine happen center closes day stops accepting calls discussed blocking queue wait leaving poor customer service agent sitting night noth ing fairly common problem dealing work queues fortunately common solution idea create special understood òstop process ing ó defined constant go_home start class definition anytime appears queue customer service agent itõs time finish day outcreating callcenter class calls customer service agents finally create center class responsible managingñstarting stoppingñthe agents placing calls queue agents process package wrox algorithms queues import wrox algorithms iteration iterator import wrox algorithms lists arraylist import wrox algorithms lists list public class callcenter private final queue _calls blockingqueue listfifoqueue private final list _threads private final int _numberofagents public callcenter int numberofagents chapter _596748 ch04 qxd    _threads arraylist numberofagents _numberofagents numberofagents process calls open centerñjust real aptly named method open public void open assert _threads isempty open println center opening int _numberofagents thread thread thread customerserviceagent _calls thread start _threads add thread println center open center open accepting calls public void accept assert _threads isempty open _calls enqueue println queued eventually close center send customer service agents public void close assert _threads isempty closed println center closing int _numberofagents accept customerserviceagent go_home iterator _threads iterator isdone waitfortermination thread current queues07_596748 ch04 qxd    _threads clear println center closed private void waitfortermination thread thread thread join catch interruptedexception ignore works thing callcenterdoes create queueñmore instance blockingqueue enables happily multiple customer service agents thread accessing queue note starting multiple threads reason maintain list running threads lastly store number agents starting open method responsible starting agents construction customerserviceagentis constructed idñhere youõve iteration variableñand queue created started thread list placing queue waits answered ònext operator ó isnõt wonõt answer calls straightaway send agents thing place special queueñone customer service agents finish day agent running place special go_homecall queue simply telling agents calls waiting queue youõre friendly sort center donõt hang customers placing go_homecall wait finish turn ing lights locking doors method waitfortermination thread join effectively sleep thread finishes execution youõre classes outcreating callgenerator class acall generator suggests responsible actual generation phone calls package wrox algorithms queues public class callgenerator private final callcenter _callcenter private final int _numberofcalls chapter _596748 ch04 qxd    private final int _maxcallduration private final int _maxcallinterval public callgenerator callcenter callcenter int numberofcalls int maxcallduration int maxcallinterval assert callcenter null callcenter null assert numberofcalls numberofcalls assert maxcallduration maxcallduration assert maxcallinterval maxcallinterval _callcenter callcenter _numberofcalls numberofcalls _maxcallduration maxcallduration _maxcallinterval maxcallinterval constructor public method imagine performs generation public void generatecalls int _numberofcalls sleep _callcenter accept int math random _maxcallduration private void sleep thread sleep int math random _maxcallinterval catch interruptedexception ignore works method generatecalls sits loop generates calls configured gen erated random duration center processing method waits random interval callsñagain construction time outcreating callcentersimulator class class center simulator small application mand ties center generator real simulation performed classes discussed callcentersimulatorclass concerned reading parsing command arguments package wrox algorithms queues public final class callcentersimulator queues07_596748 ch04 qxd    private static final int number_of_args private static final int number_of_agents_arg private static final int number_of_calls_arg private static final int max_call_duration_arg private static final int max_call_interval_arg private callcentersimulator public static void main string args assert args null args null args length number_of_args println usage callgenerator numberofagents numberofcalls maxcallduration maxcallinterval exit callcenter callcenter callcenter integer parseint args number_of_agents_arg callgenerator generator callgenerator callcenter integer parseint args number_of_calls_arg integer parseint args max_call_duration_arg integer parseint args max_call_interval_arg callcenter open callgenerator generatecalls finally callcenter close works main method entry point application called interpreter pass ing array command arguments checked ensure required parameters provided number agents usethe number calls generatethe maximum durationthe maximum time wait generated callsif parameters missing application prints message terminates parameters application constructs center generator center opened calls generated finally center closed ensure customer service agents stopped correctly chapter _596748 ch04 qxd    running application compiling running simulator letõs summarize application youõve created callgeneratorcreates calls random duration calls accepted callcenterthatplaces blockingqueue customerserviceagents answer calls untilthey told go_home tied command application callcentersimulator center simulator customer service agents answering calls maximum duration set  milliseconds maximum time wait generatingcalls milliseconds output large chunk removed sake space center openingagent clocked onagent waitingagent clocked onagent waitingagent clocked onagent waitingcall center openagent answering call answered waited millisecondscall queuedagent answering call answered waited millisecondscall queuedagent answering call answered waited millisecondscall queuedcall queuedcall queuedcall queuedcall queuedcall queuedagent waitingagent answering call answered waited millisecondscall queuedcall queuedcall queuedcall queuedagent waitingagent answering call answered waited milliseconds answered waited millisecondsagent waitingagent answering call answered waited millisecondsagent waitingagent answering call answered waited millisecondsagent waitingagent answering queues07_596748 ch04 qxd    answered waited millisecondsagent waitingagent answering call answered waited millisecondsagent waitingagent answering agent homeagent waitingagent answering agent homeagent waitingagent answering agent homecall center closedthis calls answered program action observe center opening agents signing calls generated waiting queue answered agent notice wait time starts time answered itõs seconds  milliseconds playing input variables number agents time calls code simple hoped idea queues gathering statistics average wait time agent extending code types generators center simulate types calls peak load times summary chapter learned key points queues operation queues lists simpler interface defined order retrieval queues optionally bounded limits number items queue time alinked list ideal data structure build fifo queue implement thread safe wrapper works queue implementation implement bounded queueñone maximum size limit exercises1 implement thread safe queue performs waiting queue work multi threaded environment blocking implement queue retrieves values random order dealing cards deck random selection process chapter _596748 ch04 qxd    stacksnow familiar lists queues itõs time describing stacks familiar real examples stacks plates stackedñyou place shelf add plate remove newspapers local convenience store stacked books desk youõve meaning read stacks implement simple mru cache parsing programming languages òeverything stacksó chapter familiarize topics stacks stacks likehow stackshow stacks implemented start introducing basic operations stack cover tests required validate correctness stack implementation finally youõll common form stack based list stacksastack list access restricted figure  graphical representation stack figure  stack pictured vertically ctop ba08_596748 ch05 qxd    youõll notice lists queues thought running left stacks pictured verticallyñhence term òtopó refer directly accessible element stack astack inserts pushes deletes pops astack lifo queue guarantees element removed stack time table  describes operations provided stack table  operations stack operationdescription pushadds stack size stack increase popdeletes returns stack size stack decrease throws emptystackexceptionwhen ele ments stack sizeobtains number elements stack peekreturns delete stack throws emptystackexceptionwhen elements stack isemptydetermines stack returns trueif stack size returns false cleardeletes elements stack size stack reset pushinga stack adds figure  dis pushedonto stack figure  figure  pushing adds stack poppinga stack removes figure  popped stack figure  figure  popping removes ctop babatop ctop bacbadtop chapter _596748 ch05 qxd    operationsñ peek isempty clear ñare technically provided conve nience implemented operation definitions convert combination interfaces tests package wrox algorithms stacks import wrox algorithms queues queue public interface stack extends queue public void push object public object pop throws emptystackexception public object peek throws emptystackexception public void clear public int size public boolean isempty interface simple small number operations methods pop peek declare throw emptystackexceptionanytime attempt madeto access stack elements define exception class package wrox algorithms stacks public class emptystackexception extends runtimeexception lastly note stackinterface extends queueinterface thatõs dis cussed stack lifo queue youõd plug compatible enqueue dequeue acting synonyms push pop tests proceed create test cases ensure correct operation stack define separate test cases push pop peek clear methods size isempty methods explicit tests tested mentioned stack implementation chapter create variations reason create generic test class extended concrete test classes specific implementation notice emptyqueueexceptionfrom chapter defined extending runtimeexception indicative programming errorñan error application logic legitimate reason occur normal applicationexecution donõt force developer needlessly catch stacks08_596748 ch05 qxd    outcreating generic test class package wrox algorithms stacks import junit framework testcase public abstract class abstractstacktestcase extends testcase protected static final string value_a protected static final string value_b protected static final string value_c protected abstract stack createstack works stack interface simple reflected small number test cases complacent presume simplicity testing required outusing push pop methods peek test accessing stack push pop methods impossible test public void testpushandpop stack stack createstack stack push value_b stack push value_a stack push value_c assertequals stack size assertfalse stack isempty assertsame value_c stack pop assertequals stack size assertfalse stack isempty assertsame value_a stack pop assertequals stack size assertfalse stack isempty assertsame value_b stack pop assertequals stack size asserttrue stack isempty ensure attempt pop list excep tion thrown chapter _596748 ch05 qxd    public void testcantpopfromanemptystack stack stack createstack assertequals stack size asserttrue stack isempty stack pop fail catch emptystackexception expected works test pushes values conto stack pops time ensur ing removed correct order finally ensuring stack attempt pop pop successful youfail test incorrect behaviorñyou shouldnõt pop stack emptystackexceptionis thrown stack working expected outtesting peek method addition pushing popping values stack peek method òsneakpreviewó topmost element public void testpeek stack stack createstack stack push value_c stack push value_a assertequals stack size assertsame value_a stack peek assertequals stack size test peek push valuesñ cand añand ensure peek return pushedñin case añbut removed stack consequence public void testcantpeekintoanemptystack stack stack createstack assertequals stack size asserttrue stack isempty stack peek fail stacks08_596748 ch05 qxd    catch emptystackexception expected confirm clear performs expected removes elements stack public void testclear stack stack createstack stack push value_a stack push value_b stack push value_c assertfalse stack isempty assertequals stack size stack clear asserttrue stack isempty assertequals stack size stack pop fail catch emptystackexception expected works initially filling stack values stack cleared size checked attempt pop fail popping stack throw emptystackexception implementationalthough implement stack principles chapter queues advantage fact list pro vides implement stack youõll trivial implement stack based methods provided list case implement stack list specific construct purpose enforce clean separation concept list stack separation concerns critically designing software chosen list implement stack decide beachieved options enhance existing list implementation extend existing list implementation create class altogether chapter _596748 ch05 qxd    solutions pros cons enhancing extending existing implementation trivialñyou simply class implement stackin addition listinterface andadd methods satisfy requirements stack approach major drawback doubt countless unknown list implementa tions repeat process type list wished elegant solution option discussed write class liststack usescomposition class hold wrap instance list number advan tages implemented wisely stack capable operating type list choose code point book clear deem tests weneed concrete test class package wrox algorithms stacks public class liststacktest extends abstractstacktestcase protected stack createstack return liststack outimplementing liststack class define liststackclass things implement stackinterface defined earlier package wrox algorithms stacks import wrox algorithms lists arraylist import wrox algorithms lists list public class liststack implements stack private final list _list linkedlist pushing stack easy adding list public void push object _list add public void enqueue object push works thing class hold list underlying data structure alinked list efficient adding removing items endsñsomething stack stacks08_596748 ch05 qxd    easily substitute array list worry main thing understand extend list implementation youõve compositionto òwrapó list prevents list methods òleakingó users liststackclass methods list interface definedfor stack push adds underlying list enqueue simply delegates topush notice havenõt checked nullvalue delegate responsibility underlying list implementation outpopping stack popping stack easy remove element underlying list public object pop throws emptystackexception isempty throw emptystackexception return _list delete list size public object dequeue throws emptyqueueexception return pop catch emptystackexception throw emptyqueueexception performance push pop implemented relies performance underlying listõs add delete methods peek method access stack removing public object peek throws emptystackexception object result pop push result return result complete class delegate remaining methods underlying list expected behavior identical public void clear _list clear public int size return _list size chapter _596748 ch05 qxd    public boolean isempty return _list isempty works time cautious defensive check listõs delete methodmight throw indexoutofboundsexceptionñnot caller expected explicitly check size stack throw emptystackexceptionas thestackinterface removing returning element underlying list notice dequeue delegate behavior pop vert emptystackexceptioninto emptyqueueexception peek method pop retrieve item record push returning caller effectively returned stack removing compile tests completed list based stack satisfy ing doubt tests passing youõll stack thing bit constructive implementing undo redoit surprisingly difficult stack overly academic nature usual examples involve solving towers hanoi puzzle implementing reverse polish notation rpn calculator reversing list values relate applications involved real examples encounter include xmlprocessing screen flow management forward buttons browser undo redo item undo imagine application holds listñmaybe shopping list list mail messages user interface displays list enables users add remove items letõs users undo actions time user performs action record state list memento gamma undo action future state pushed stack user requests undo action pop stack restore list state prior action performed obvious implement store copy list action formed works itõs ideal solution thing entire copy list time advantage fact insert inverse deleteñif insert element position òundoó simply deleting stacks08_596748 ch05 qxd    position conversely delete element position inserting original position òundoingó deletion complete discussion scope book presented easily extended support single undo stack multiple lists data structure matter encapsulating undo functionality external classes testing undo redo demonstrate time build reliable production code tests requirements preceding turn test cases outcreating running test class undoable list behave pretty list test lot functionality thankfully implement listinterface extendabstractlisttestcaseand predefined tests free package wrox algorithms stacks import wrox algorithms lists abstractlisttestcase import wrox algorithms lists arraylist import wrox algorithms lists list public class undoablelisttest extends abstractlisttestcase protected list createlist return undoablelist arraylist inserted list undo restore list original state public void testundoinsert undoablelist list undoablelist arraylist assertfalse list canundo list insert value_a asserttrue list canundo list undo assertequals list size assertfalse list canundo public void testundoadd chapter _596748 ch05 qxd    undoablelist list undoablelist arraylist assertfalse list canundo list add value_a asserttrue list canundo list undo assertequals list size assertfalse list canundo methods undoand canundoare listinterface methods add undoablelistclass delete remove undo valuerestored original position public void testundodeletebyposition undoablelist list undoablelist arraylist object value_a value_b assertfalse list canundo assertsame value_b list delete asserttrue list canundo list undo assertequals list size assertsame value_a list assertsame value_b list assertfalse list canundo public void testundodeletebyvalue undoablelist list undoablelist arraylist object value_a value_b assertfalse list canundo asserttrue list delete value_b asserttrue list canundo list undo assertequals list size assertsame value_a list assertsame value_b list assertfalse list canundo stacks08_596748 ch05 qxd    calling set doesnõt change size list modify contents expect changing element undo element torevert previous public void testundoset undoablelist list undoablelist arraylist object value_a assertfalse list canundo assertsame value_a list set value_b asserttrue list canundo list undo assertequals list size assertsame value_a list assertfalse list canundo purposes chosen clear differ meth ods wonõt record state subsequent undo decision purely grounds simplicity reason couldnõt implement undo functionality clear entire copy list prior cleared public void testclearresetsundostack undoablelist list undoablelist arraylist assertfalse list canundo list add value_a asserttrue list canundo list clear assertfalse list canundo youõve tested individual actions undo behavior wanted undo level wouldnõt stack fact roll number actions order test demonstrate works public void testundomultiple undoablelist list undoablelist arraylist assertfalse list canundo list add value_a list add value_b list undo assertequals list size assertsame value_a list chapter _596748 ch05 qxd    asserttrue list canundo list delete list undo assertequals list size assertsame value_a list asserttrue list canundo list undo assertequals list size assertfalse list canundo works tests ensure list starts undo asingle inserted list test class extends abstractlisttestcase confidentthat actual behavior inserting list works ensure calling undo removes inserted undo delete cases tests simple concern behavior actual delete methodñthis tested methods superclass list initialized predefined values delete calling undo ensure reappeared expected location final test starts list variously adds removes values invoking undo add undone test actions undone proves stack based undo working expected tests place itõs time implement undoablelistclass outimplementing undo action undoablelist class youõve enshrined requirements code implementing undoable list straightforward start describing undoablelistclass list meth ods turn note design enables add functionality minimal coding effort chosen implementation undoable list wrap reference real underlying list implement listinterface decorator gamma package wrox algorithms stacks import wrox algorithms iteration iterator import wrox algorithms lists list public class undoablelist implements list private final stack _undostack liststack private final list _list public undoablelist list list assert list null list null stacks08_596748 ch05 qxd    _list list private static interface undoaction public void execute start capturing state time inserted list intercepting calls insert private final class undoinsertaction implements action private final int _index public undoinsertaction int _index public void execute _list delete _index public void insert int object throws indexoutofboundsexception _list insert _undostack push undodeleteaction public void add object insert size intercept calls delete restore deleted stage private final class undodeleteaction implements action private final int _index private final object _value public undodeleteaction int object _index _value public void execute _list insert _index _value public object delete int throws indexoutofboundsexception object _list delete _undostack push undoinsertaction return chapter _596748 ch05 qxd    public boolean delete object int indexof return false delete return true method calls indexof determine position list thevalue isnõt falseis returned delete method takes called record state perform undo operation calling set modifiesthe state list restore private final class undosetaction implements action private final int _index private final object _value public undosetaction int object _index _value public void execute _list set _index _value public object set int object throws indexoutofboundsexception object originalvalue _list set _undostack push undosetaction originalvalue return originalvalue defined infrastructure record undo state write code undo method public void undo throws emptystackexception action _undostack pop execute convenience enable callers determine actions undo handy wanted enable disable undo button user interface public boolean canundo return _undostack isempty stacks08_596748 ch05 qxd    determine actions undo query undo stack itõs undo vice versa clear modifies list decided undo state berecorded list reset public void clear _list clear _undostack clear clearing underlying list undo stack cleared resetting entire structure completing interface requirements class formality public object int throws indexoutofboundsexception return _list public int indexof object return _list indexof public iterator iterator return _list iterator public boolean object return _list public int size return _list size public boolean isempty return _list isempty public string tostring return _list tostring public boolean equals object object return _list equals object remaining methods modifications state list sufficient simply delegate underlying instance chapter _596748 ch05 qxd    works underlying list class holds undo stack hold instances interface undoaction defines single method execute eventually becalled perform work involved implementing undo functionality undoactionclass command pattern gamma case mand pattern simple encapsulate undo behavior action responsible performing needed job effective elegantñand extensibleñalternative switchstatement route stant defined action action undodeleteactionclass implements undoactioninterface impor tant execute method undo insert delete execute called therecorded position delete underlying list insert method calls insert underlying list pushes undo action theadd method insert created special action delete list calling insert passing position requires code undodeleteactionclass implements undoactioninterface holds recorded position undo deletion insert execute called action reinserts underlying list delete calls delete underlying list retrieves deleted pushing insert action returning caller deleting trickier knowing list deleted implement delete based delete positionñnot efficient solution option acall set underlying list returns original contained posi tion case undosetaction sexecute method stores position order perform undo notice case previous undo actions execute method calls underlying list order prevent undo pushing additional undo action stack thereõs lot code write actual undo method hard work undoactionclasses making sim ple matter popping action stack calling execute fully tested implemented list supports undo functionality stacks08_596748 ch05 qxd    summary conceptually simple stacks underpin operation computers chapteryouõve learned cpus programming languages including stack based stacks add remove topñthus referred fifo queues stacks easily implemented lists constraining implementation oneparticular type list stacks chapter demonstrated easy augment data structureñin case listñwith undo feature simple algorithms string searching familiar managing data basic data structures lists queues stacks time solving complex problems chapter _596748 ch05 qxd    basic sorting understand fundamental data structures todayõs software appli cations data structures organize large amounts data applica tions process sorting data logical order critical prerequisite algorithms chapters potential performance bottleneck enor mous decades determine efficient sort types data chapter introduces sorting algorithms easy imple ment suited smaller sets data performance chapter coversmore complex sorting algorithms performance characteristics large data sets chapter discusses sortingthe role comparators bubble sort algorithm workshow selection sort algorithm workshow insertion sort algorithm worksthe meaning stabilitythe pros cons basic sorting algorithms sorting real sorting working searching algorithms word dictionary algorithm open dictionary point roughly equivalent wordõs position sorted list dictionary quick narrowing searches itõs finally scan word imagine dictionary sorted youõd decide time search unsorted data prohibitive youõd _596748 ch06 qxd    sorting searching impractical large sets data apply principle types data real names phone book books shelves library problem examples hope deal types data sorted youõve create efficient algorithm sorting computer uncommon encounter sets data large arrive program unsorted order agood grasp established algorithms helps tackle type problem sorting fundamentals sorting data kind meaningful order requires data structure capable maintaining order contents learned chapter distinguishing feature list lists data structure sorting algorithms operate objects sorted contained list sorting algorithms built fun damental operations comparing items determine order moving items sorted positionthe advantages disadvantages sorting algorithm based times funda mental operations performed expensive operations performance terms task comparing objects determine sorted larger topic imagine deal comparators list data structure ports methods moving objectsñnamely set insert delete theseoperations covered chapter understanding comparators languages compare integers int works fine primitive types things difficult dealing complex objects list files computer typically sorted filename order created order modified type file happen support orderings write algorithm comparators comparatoris responsible imposing specific ordering objects chapter _596748 ch06 qxd    youõre sort files comparator filenames file types modification times comparators enable single sorting algorithm sort list file objects ways design principle separation concerns case sep arate concern compare individual objects comparator concern efficiently sort large list objects algorithm enables extend algo rithm plugging comparators imagined creating enables reuse comparator multiple algorithm implementations compare performance comparator operationsacomparator consists single operation enables compare objects relative order returns negative integer positive integer depending argument equal greater throws classcastexceptionif type ofeither object prevents compared comparator interfaceacomparator simpleñit single method enables compare objects deter object equal greater object code comparatorinterface public interface comparator public int compare object left object compare operation takes arguments leftand chosen label context conceptually left arguments comparing primitive values calling compare left left result integer left left result integer greater left equals result comparison standard comparators addition custom comparators create standard comparators greatly simplify application code simple concept implementation powerful complex algorithms discussed book working natural comparator data types primitives strings integers natural sort order anatural comparator simply comparator supports natural ordering objects create single comparator sort object natural sorting order basing convention established language concept comparable interface implemented class provide natural sort order basic sorting _596748 ch06 qxd    comparable interfacethe comparableinterface simple consisting single method public interface comparable public int compareto object comparator returns negative integer positive integer object equal difference comparatoranda comparableobject comparatorcompares objects comparableobject compares object classes implement comparableto natural sortorder personclass defined sorting fact concept isreflected standard language enables create generic comparatorfor sorting based onthe natural ordering type create comparatorthat work class implementscomparable fact commonly classes lang package implement thisinterface handy comparator start desired behavior naturalcomparator scenarios handle types comparison result strings implement comparable strings test data test implement naturalcomparator outtesting natural comparator test negative integer left argument falls sorting public void testlessthan asserttrue naturalcomparator instance compare determine positive integer left argument sorts argument public void testgreaterthan asserttrue naturalcomparator instance compare finally arguments equal determine result public void testequalto asserttrue naturalcomparator instance compare works test case test method cases identified test method assumes naturalcomparatorprovides single static instance ing instantiate test method simple character strings test data validate thenaturalcomparatorbehaves expected chapter _596748 ch06 qxd    outimplementing natural comparator naturalcomparatorhas state instance public final class naturalcomparator implements comparator public static final naturalcomparator instance naturalcomparator private naturalcomparator ensure mark constructor private prevent instantiation provide pub licly accessible static variable holding single instance class mark class finalto prevent extended erroneously implement compare implementing comparableinter face actual work performed arguments making implementa tion trivial public int compare object left object assert left null left null return comparable left compareto ensuring havenõt passed nullargument cast left argument comparableand defined compareto method passing argument check left argument instance comparablebecause thecomparatorinterface classcastexceptionto thrown meaning form cast additional check works naturalcomparatoris designed compare objects implement comparableinterface built objects implement interface classes create free implement code cast left operand comparableinterface thecompareto method passing operand comparison performed leftoperand comparator required implement comparison logic handled objects working reverse comparator sort things reverse order list files computer files smallest largest reverse order largest smallest achieve reverse version naturalcomparatordescribed copy implementation reimplement compare method public int compare object left object assert null null return comparable compareto left basic sorting _596748 ch06 qxd    swap left arguments confirming argument nulland passingthe left argument compare method approach works perfectly case isnõt extensible complex type personor file creating comparators sort ascending sort descending abetter approach create generic comparator wraps òdecoratesó comparator reverse result comparator complex type sort generic reversecomparatorto sort oppositedirection outtesting reverse comparator naturalcomparator scenarios handle matching types comparison result tests defined naturalcomparatortoenable compare simple string values left argument sort reversecomparatorto causethe opposite occur underlying comparator returns negative integer indicating left argument argument ensure result reversecomparatoris positive integer public void testlessthanbecomesgreaterthan reversecomparator comparator reversecomparator naturalcomparator instance asserttrue comparator compare underlying comparator returns positive integer indicating left argument mally sort result negative integer public void testgreaterthanbecomeslessthan reversecomparator comparator reversecomparator naturalcomparator instance asserttrue comparator compare arguments equal result public void testequalsremainsunchanged reversecomparator comparator reversecomparator naturalcomparator instance asserttrue comparator compare chapter _596748 ch06 qxd    works preceding code works instantiating reversecomparatorobjects passing anaturalcomparatorto comparison logic delegated test methods thenmake nonsensical assertions acomes opposite true case test method case test method coun terintuitive final test method ensures objects equal remain equal reversecomparatoris implement reversecomparator outimplementing reverse comparator implement generic reversecomparatorwith lines code package wrox algorithms sorting public class reversecomparator implements comparator private final comparator _comparator public reversecomparator comparator comparator assert comparator null comparator null _comparator comparator start implementing comparatorinterface defining constructor accepts underlying comparatorto eventually delegate compare actual implementation compare public int compare object left object return _comparator compare left works glance code innocuous simply delegating underlying comparator carefully code arguments reversed pass reversecomparatorwas called underlying comparator passed inducing opposite result donõt access attributes argument solution pletely generic implement solution situations start build sorting algorithm bubble sort algorithm understanding bubble sort implementing bubble sort algorithm define test cases implementa tion pass sorting algorithms pass basic test prove sort objects correctly establish base class unit tests extend basic sorting _596748 ch06 qxd    specific implementation algorithms implements interface replaced easily single test case prove sorting algorithmõs basic features havenõt thought outperforming bubble sort imagine family gathering photograph decide youõd family members arranged age order youngest oldest theyõre arranged randomly figure  figure  randomly arranged family members apply bubble sort problem turn attention people left fam ily members older pair older sorted relative left older swap positions case swap needed happen figure  family swap place figure  swap place attention place address people person compared person compared person repeat procedure older swapping order chapter _596748 ch06 qxd    time pair people perform swaps willhave happened figure  family group pass figure  family passñthe oldest person group sorted oldest person bubbled final sorted position lot comparing swapping person sorted thatõs true algorithms youõll improved efficiency donõt worry pass bubble sort algorithm ignore person person sorted starting left pare swap process oldest person rightmost position figure  figure  oldest person rightmost position pass continue gradually sorting smaller smaller remaining groups group sorted picture figure  basic sorting _596748 ch06 qxd    figure  entire group sorted listsorter interface interfaces listsorterinterface extremely simple consisting single operation sort list sortoperation accepts list input produces result sorted version list depending implementation returned list provided listñthat implementations sort list place create list code listsorterinterface public interface listsorter public list sort list list testing abstractlistsorter written single sorting algorithm write test exercises implementation listsorterinterface abstract test class meaning canõt extended specific sorting algorithm implementation actual implementation test specific algorithm trivial result abstractlistsortertestperforms tasks creates unsorted list strings creates sorted list strings expected result test creates listsorter abstract method listsorterto sort unsorted listcompares sorted list expected result list chapter _596748 ch06 qxd    outtesting abstractsortertest code declaring lists setup implementation withstrings package wrox algorithms sorting import junit framework testcase import wrox algorithms lists list import wrox algorithms lists linkedlist import wrox algorithms iteration iterator public abstract class abstractlistsortertest extends testcase private list _unsortedlist private list _sortedlist protected void setup throws exception _unsortedlist linkedlist _unsortedlist add test _unsortedlist add driven _unsortedlist add development _unsortedlist add _unsortedlist add _unsortedlist add small _unsortedlist add step _unsortedlist add _unsortedlist add _unsortedlist add programmer _unsortedlist add _unsortedlist add _unsortedlist add _unsortedlist add giant _unsortedlist add leap _unsortedlist add _unsortedlist add programming _sortedlist linkedlist _sortedlist add _sortedlist add _sortedlist add development _sortedlist add driven _sortedlist add _sortedlist add _sortedlist add giant _sortedlist add _sortedlist add _sortedlist add leap _sortedlist add _sortedlist add _sortedlist add programmer _sortedlist add programming basic sorting _596748 ch06 qxd    _sortedlist add small _sortedlist add step _sortedlist add test implement teardown frees references listobjects protected void teardown throws exception _sortedlist null _unsortedlist null finally define abstract method create specific sorting algorithm test protected abstract listsorter createlistsorter comparator comparator public void testlistsortercansortsamplelist listsorter sorter createlistsorter naturalcomparator instance list result sorter sort _unsortedlist assertequals result size _sortedlist size iterator actual result iterator actual iterator expected _sortedlist iterator expected expected isdone assertequals expected current actual current expected actual works lines test method create sorting algorithm implementation sort unsorted list pass natural comparator expected set natu ral sequence strings bulk test verifies result sort matches expected result list creating iterator lists comparing item turn ensure item item exact match sorting algorithms pass test practice test specific bubble sort implementation outtesting bubblesortlistsorter extend abstractlistsortertestand implement abstract createlistsorter method asshown chapter _596748 ch06 qxd    package wrox algorithms sorting public class bubblesortlistsortertest extends abstractlistsortertest protected listsorter createlistsorter comparator comparator return bubblesortlistsorter comparator thatõs complete test bubblesortlistsorter preceding code wonõt compile donõt bubblesortlistsorterclass thatõs weõll implement bubble sort works fact implemented single method single code key point extending abstractlistsortertestclass preceding code abstract class test data test methods provide listsorterimple mentation tests thatõs outimplementing bubblesortlistsorter implementation bubble sort algorithm meet design criteria implement listsorterinterfaceaccept comparator determine ordering objects pass unit test preceding guidelines place implementation constructor package wrox algorithms sorting import wrox algorithms lists list public class bubblesortlistsorter implements listsorter private final comparator _comparator public bubblesortlistsorter comparator comparator assert comparator null comparator null _comparator comparator implement bubble sort algorithm recall description algorithm comprised number passes data pass item moved final sorted position thing determine passes needed item moved final sorted position item final position number passes num ber items code calls outerloop basic sorting _596748 ch06 qxd    pass compare pair items swap order determined comparator remember pass item moved final sorted position subsequent passes pass deals item previous pass number items list pass number comparisons ð pass ð iswhy loop code condition left size pass control comparisons performed public list sort list list assert list null list null int size list size int pass pass size pass outer loopfor int left left size pass left loopint left _comparator compare list left list swap list left return list preceding code supplied comparator determine items scrutiny order calls swap method correct relative placement list code swap private void swap list list int left int object temp list left list set left list list set temp compile test passes flying colors place delib erate mistake testõs expectation catch slip implementing sorting algorithm working selection sort imagine bookshelf filled books varying sizes arranged haphaz ardly mother coming visit impress housekeeping prowess decide arrange books neatly shelf order tallest shortest figure  book shelf youõd bubble sort case swapping waste time youõd book putting shelf times long cost moving items large measured cost comparing items aselection sort choice youõll chapter _596748 ch06 qxd    figure  haphazard bookshelf start scanning shelf tallest book pull left shelf books shelf room pull book hap pens space swap rest books books vary thickness wonõt matter software implementation ignore issue choosing swap books slide books implementation unstable topic covered chapter donõt worry figure  shelf swap figure  tallest book left position basic sorting _596748 ch06 qxd    leaving tallest book scan shelf tallest remaining books youõve swap book tallest book sorted books wonõt touch figure  shelf figure  tallest book position leaving largest books continue scan remaining books tallest time swapping book sorted books left shelf time scan shelf selecting book order moving final sorted position thatõs algorithm called selection sort figure  shelf book moved scanning unsorted books tallest isalready position swap required book moved set sorted books grows set unsorted books shrinks shelf sorted book moved directly final sorted position small steps final posi tion bubble sort good reason algorithm case chapter _596748 ch06 qxd    figure  shelf position filled book basic sorting _596748 ch06 qxd    lot work bubble sort algorithm test selection sort start creating test case implementing algorithm mak ing passes test prove implemented correctly outtesting selectionsortlistsorter test selectionsortlistsorteris bubble sort equivalent extend abstract test case instantiate selection sort implementation package wrox algorithms sorting public class selectionsortlistsortertest extends abstractlistsortertest protected listsorter createlistsorter comparator comparator return selectionsortlistsorter comparator implement selectionsortlistsorter works fact implemented single method single code key point extending abstractlistsortertestclass earlier chapter abstract class test data test methods provide listsorterimplementation tests outimplementing selectionsortlistsorter implementation shares common bubble sort counterpart imple ment listsorterinterface accept comparatorto determine ordering pass unit test create class declaration constructor package wrox algorithms sorting import wrox algorithms lists list public class selectionsortlistsorter implements listsorter private final comparator _comparator public selectionsortlistsorter comparator comparator assert comparator null comparator null _comparator comparator works implementation outer loop loop bubble sort subtle dif ferences escape attention donõt code closely outer loop ranges ð  ð bubble sort note number passes ð reflects focus selection sort filling òslotó chapter _596748 ch06 qxd    object pass pass goal object intoposition list pass goal position ð passes object naturally ends sorted position result sorting object swapping occurs loop bubble sort loop onlyrequirement remember position smallest item loop finishes swap smallest item slot earlier book shelf books sorted largest smallest algorithm work case fact simply plug reversecomparatoryou created earlier chapter public list sort list list assert list null list null int size list size int slot slot size slot outer loopint smallest slot int check slot check size check loopif _comparator compare list check list smallest smallest check swap list smallest slot return list small difference implementation swap selection sort compared bubble sort add guard clause ignore requests swap slot occur easily selection sort bubble sort private void swap list list int left int left return object temp list left list set left list list set temp understanding insertion sort insertion sort algorithm commonly people playing cards sort hand dealt imagine cards face sort rules separate suits order spades clubs diamonds hearts suit sort ascending order ace   jack queen king basic sorting _596748 ch06 qxd    figure  hand cards face unsorted order algorithm figure  hand cards turning card easier sorting single card hold hand case itõs diamonds figure  current situa tion sorted card unsorted cards lying face figure  card sorted pick card itõs jack spades spades diamonds insert hand left current card figure  situation d134chapter _596748 ch06 qxd    figure  card inserted pick card itõs ace clubs sorted cards inserted figure  state hand figure  card inserted middle insertion sort works dividing data groups sorted items unsorted items initially sorted group unsorted group items item unsorted group inserted position growing group sorted items eventually items sorted group unsorted group figure  pick final cards jsac7djs7d135basic sorting _596748 ch06 qxd    figure  cards inserted start creating test case insertion sort algorithm imple ment complete basic sorting algorithms chapter outtesting insertionsortlistsorter bubble sort selection sort extend abstractlistsortertestcase insertion sort algorithm package wrox algorithms sorting public class insertionsortlistsortertest extends abstractlistsortertest protected listsorter createlistsorter comparator comparator return insertionsortlistsorter comparator works implemented single method single code key point extending abstractlistsortertestclass earlier chapter abstract class pro vides test data test methods provide listsorterimplementa tion tests thatõs outimplementing insertionsortlistsorter familiar basic structure sorting algorithm implementations class declaration constructor insertionsortlistsorter jsac7dqhjsac9c7dqh136chapter _596748 ch06 qxd    package wrox algorithms sorting import wrox algorithms lists list import wrox algorithms lists linkedlist import wrox algorithms iteration iterator public class insertionsortlistsorter implements listsorter private final comparator _comparator public insertionsortlistsorter comparator comparator assert comparator null comparator null _comparator comparator works implementation sort method algorithms ear lier chapter algorithm sort objects place rearranging order list algorithm creates list inserts item original list result list sorted order addition original list processed iterator accessing items direct access items original list simply process turn natural idiom iterator public list sort list list assert list null list null final list result linkedlist iterator list iterator isdone int slot result size slot _comparator compare current result slot  break slot result insert slot current return result finally notice loop whileloop forloop task posi tion result list insert item finds position falls result list exits loop current item inserted result list times result list sorted item position relative items list maintaining sorted sequence linkedlistfor result list suited insertion operations basic sorting _596748 ch06 qxd    note algorithm searches backwards result list position forwards big advantage sorting sorted sorted objects demonstrated òcomparing basic sorting algorithms ó chapter reason algorithm stable subject understanding stability sorting algorithms share interesting characteristic called stability illustrate concept examine list people sorted names table  table  list sorted names namelast albertsmith brianjackson davidbarnes johnsmith johnwilson marysmith tombarnes vincedemarco walterclarke imagine sort people names list table  common names smith barnes expect happen order people expect people relative order original listñthat sorted group stability sorting algorithm maintains relative order items common sort key stable algorithm table  stable sort people table  stable sort table  namelast davidbarnes tombarnes walterclarke vincedemarco chapter _596748 ch06 qxd    namelast brianjackson albertsmith johnsmith marysmith johnwilson implementations discussed farñbubble sort insertion sortñare stable simple selection sort implementation stable advanced sorting algorithms chapters faster fail preserve stability account application comparing basic sorting algorithms number sorting algorithms action easily plug anyimplementation supports listsorterinterface wondering whichalgorithm compares algorithm practical approach theoretical mathematical approach intended definitive list criteria selecting algo rithm comparative analysis implementation choices systems build recall introduction chapter sorting algorithms perform basic steps times comparing items moving items discussion assesses behavior sorting algorithms regard operations puts algorithms paces larger data sets implementing diver gence relative performance clearer larger sets data algorithm receive input data varying arrangements sorted case sorted reverse order desired order worst case random order average case algorithm set input data cases aninformed decision relative merits real situation task gather times comparisons callcountinglistcomparatorall comparisons sorting algorithms performed respective comparator count number times comparatorõs compare method called alter code parator remember number calls alternatively compara tors extend common base class counting behavior basic sorting _596748 ch06 qxd    code youõve written add counting behavior decorating parator reversecomparator public final class callcountingcomparator implements comparator private final comparator _comparator private int _callcount public callcountingcomparator comparator comparator assert comparator null comparator null _comparator comparator _callcount public int compare object left object _callcount return _comparator compare left public int getcallcount return _callcount reversecomparator callcountingcomparatoraccepts comparatorin itsconstructor callcountingcomparatordelegates actual comparison check underlyingcomparator incrementing count left provide getcallcount methodto retrieve count sorting complete callcountingcomparator build program drive sort ing algorithms case worst case average case test data collect listsortercallcountingtest unit test program written drive algorithms junit test case setup discrete scenarios algorithm creating test class constant size lists data instance variables worst average case data sets instance variable holds reference callcountingcomparatorcreated previous package wrox algorithms sorting import junit framework testcase import wrox algorithms lists list import wrox algorithms lists arraylist public class listsortercallcountingtest extends testcase private static final int test_size private final list _sortedarraylist arraylist test_size private final list _reversearraylist arraylist test_size chapter _596748 ch06 qxd    private final list _randomarraylist arraylist test_size private callcountingcomparator _comparator set test data worst cases respective lists integerobjects values ranging  average case generate random numberswithin range create counting comparator wrapping naturalcomparator works lang integersupports comparableinterface strings earlier examples protected void setup throws exception _comparator callcountingcomparator naturalcomparator instance int test_size _sortedarraylist add integer int test_size _reversearraylist add integer int test_size _randomarraylist add integer int test_size math random algorithm worst case create relevant listsorterimplementation tosort reverse sorted list created setup method code method thisfor algorithms works reverse sorted list instance variable sort bubble sort algorithm reverse sorted algorithm starts reasons junit structure driver program junit creates instance driver class test methods method copy reverse sorted list setup independently tests interfering public void testworstcasebubblesort bubblesortlistsorter _comparator sort _reversearraylist reportcalls _comparator getcallcount public void testworstcaseselectionsort selectionsortlistsorter _comparator sort _reversearraylist reportcalls _comparator getcallcount public void testworstcaseinsertionsort insertionsortlistsorter _comparator sort _reversearraylist reportcalls _comparator getcallcount basic sorting _596748 ch06 qxd    produce output methods reportcalls method thissection methods case scenario algorithm sort sorted list created setup public void testbestcasebubblesort bubblesortlistsorter _comparator sort _sortedarraylist reportcalls _comparator getcallcount public void testbestcaseselectionsort selectionsortlistsorter _comparator sort _sortedarraylist reportcalls _comparator getcallcount public void testbestcaseinsertionsort insertionsortlistsorter _comparator sort _sortedarraylist reportcalls _comparator getcallcount create methods test average case randomly generated list numbers public void testaveragecasebubblesort bubblesortlistsorter _comparator sort _randomarraylist reportcalls _comparator getcallcount public void testaveragecaseselectionsort selectionsortlistsorter _comparator sort _randomarraylist reportcalls _comparator getcallcount public void testaveragecaseinsertionsort insertionsortlistsorter _comparator sort _randomarraylist reportcalls _comparator getcallcount lastly define reportcalls method produces output scenario defined private void reportcalls int callcount println getname callcount calls simple code subtle point getname method provided junit testcasesuperclass print scenario output produced program worst case testworstcasebubblesort callstestworstcaseselectionsort callstestworstcaseinsertionsort calls142chapter _596748 ch06 qxd    algorithms number comparisons tasked sort ing completely reverse sorted list donõt time measuring speed careful avoid jumping conclusions based simple statistics interesting thing algorithms scenario numbers produced case testbestcasebubblesort callstestbestcaseselectionsort callstestbestcaseinsertionsort callsonce interesting bubble selection sorts number compar isons insertion sort dramatically fewer review insertion sort implementation case numbers produced average case testaveragecasebubblesort callstestaveragecaseselectionsort callstestaveragecaseinsertionsort callsonce bubble selection sorts performed number comparisons inser tion sort required half number comparisons complete job understanding algorithm comparison draw conclusions comparative analysis performed careful draw understand difference behavior addi tional scenarios quantifying objects moved sort linkedlistand arraylistimplementations test datameasuring running times scenario bearing limitations analysis mind observations bubble selection sorts number comparisons number comparisons required bubble selection sorts independent state input data number comparisons required insertion sort highly sensitive state input data worst requires comparisons algorithms requires fewer comparisons number items input data point bubble selection sorts insensitive state input data òbrute forceó algorithms insertion sort adaptive work work required main reason insertion sort favored algorithms practice basic sorting _596748 ch06 qxd    summary highlights chapter include implemented simple sorting algorithmsñthe bubble sort selection sort insertion sortñcomplete unit tests prove work expected introduced concept comparators implemented includ ing natural comparator reverse comparator counting comparator looked comparative investigation algorithms informed decisions strengths weaknesses idea stability relates sorting discussed worked chapter understand sorting role plays supporting algorithms searching algorithms addition understand ways achieve simple task arranging objects sequence chapter introduces complex sorting algorithms sort huge amounts amazingly exercises1 write test prove algorithms sort randomly generated list double objects write test prove bubble sort insertion sort algorithms chapter stable write comparator order strings dictionary order uppercase lowercase letters considered equivalent write driver program determine objects moved algorithm sort operation chapter _596748 ch06 qxd    advanced sorting chapter learned sorting algorithms effective small medium problems algorithms easy implement sorting algo rithms tackle bigger problems algorithms chapter time stand skill implement effective general purpose sorting routines youõll great thing algorithms years stood test time chances good invented born s older authors rest assured time spend learning algorithms work paying years chapter discusses understanding shellsort algorithmworking quicksort algorithm understanding compound comparator stabilityhow mergesort algorithm understanding compound comparators overcome instability comparing advanced sorting algorithmsunderstanding shellsort algorithm main limitations basic sorting algorithms effort require items long final sorted position correct place sorted result advanced sorting algorithms covered chapter capability items long effective dealing larger sets data algorithms covered previous chapter shellsort achieves feat breaking large list items smaller sublists sorted independently insertion sort chapter sounds simple trick10_596748 ch07 qxd    lies repeating process times careful creation larger larger sublists list sorted insertion sort final pass learned previous chapter insertion sort effective sorted data state data final pass shellsort shellsort sorts letters figure  alphabetically figure  sample data demonstrate shellsort shellsort built concept sorting alist sorted starting posi tion item sorted position relative items concept clear work start sorting list figure  fourth element sort items relative figure  fourth item starting position figure  fourth item starting position ignoring items sort highlighted items relative list figure  highlighted items alphabetical order figure  fourth item starting position sorted relative fourth item starting position figure  items sorted relative figure  sorting fourth item starting position  sort starting position figure  begigninhalgnritoms bagigeinhmlgnnitors begigninhalgnritoms beginningalgorithms beginningalgorithms chapter _596748 ch07 qxd    figure  sorting fourth item starting position finally fourth item starting position figure  situation step figure  sorting fourth item starting position  sort sample list position set objects started position figure  list sorted sorted test choosing item list verifying equal item positions greater equal item positions left shellsort moves items long large lists items good shellsort start large start  sorting list moving items thousands positions time effort closer final sorted position list sorted large shellsort chooses smaller thing process continues list sorted final pass sort list pass figure  item starting position sorted relative notice arrangement letters figure  sorting position position coincidence figure  bagggeiihminnnltors bagggeiihminnnlsort bagigeinhmignnltors bagggeiihminnnltors bagigeinhmlgnnitors bagigeinhmignnltors advanced sorting _596748 ch07 qxd    figure  sorting position finally sort item starting position figure  figure  sorting position notice list sorted items position accomplish simple insertion sort quick list final sorted arrangement figure  compare previous list item positions reach final position figure  final sorted list shellsort revolved choice successive values original sequence suggested algorithmõs inventor    provably terrible compares items odd positions items odd positions final pass shellsort works item sorted relative items pass asimple effective sequence    implement shellsort outtesting shellsort implement shellsort algorithm test data drivethe sorting algorithms previous chapter test shellsort algorithm familiar simply extends abstractlistsortertestand instantiates written shellsort implementation package wrox algorithms sorting public class shellsortlistsortertest extends abstractlistsortertest protected listsorter createlistsorter comparator comparator return shellsortlistsorter comparator abeggghiiilmnnnorst bagggeiihminnnlsort baegggiihmilnnnsort bagggeiihminnnlsort bagggeiihminnnlsort chapter _596748 ch07 qxd    works preceding test extends general purpose test sorting algorithms created chapter test shellsort implementation instantiate overriding thecreatelistsorter method implement shellsort outimplementing shellsort implementation structure basic sorting algorithms implements listsorterinterface requires comparator impose order items create imple mentation class instance field hold comparator array integers repre senting values package wrox algorithms sorting import wrox algorithms lists list public class shellsortlistsorter implements listsorter private final comparator _comparator private final int _increments   public shellsortlistsorter comparator comparator assert comparator null comparator null _comparator comparator sort method create simply loops increments defined previ ous array calls hsort list increment note relies final increment feel free experiment sequences remember final or list ònearlyó sorted public list sort list list assert list null list null int _increments length int increment _increments hsort list increment return list create hsort implementation careful ignore increments large data sort thereõs point sorting list items compare item require increment half size list advanced sorting _596748 ch07 qxd    rest method simply delegates sortsublist method position startingat sample list private void hsort list list int increment list size increment return int increment sortsublist list increment finally create method sorts item relative place ver sion insertion sort twist considers item replace occurrence increment increment code and youõd abasic insertion sort refer chapter detailed explanation insertion sort private void sortsublist list list int startindex int increment int startindex increment list size increment object list int startindex increment object previousvalue list increment _comparator compare previousvalue break list set previousvalue list set works shellsort code works successively sorting sublists items evenly spaced inside larger list items lists start items large gaps items sublists progressively larger size fewer number items closely spaced outer loop main sort method concerned sorting sublists progressively smaller increments eventually sorting set list completely sorted hsort method concerned ensuring sublists items sepa rated current increment correctly sorted works looping number sublists indi cated current increment delegating actual sorting sublist sortsublist method method insertion sort algorithm explained chapter rearrange items sublist sorted relative chapter _596748 ch07 qxd    understanding quicksort quicksort sorting algorithm discussed recursion recast iter ative implementation recursion natural state quicksort quicksort works divide conquer approach recursively processing smaller smaller parts list level goal algorithm fold place item final sorted position place items smaller sorted item left sorted item place items greater sorted item sorted item maintaining invariants pass list divided parts note neces sarily divided halves sorted independently list letters figure  sample data figure  sample list quicksort step quicksort choose partitioning item item ends finalsorted position pass partitions list sections smaller items left arranged randomly larger items arranged randomly ways choose partitioning item simple strategy choosing item atthe list figure  item highlighted initialize indexes left rightmost remaining items figure figure  starting position initial quicksort pass algorithm proceeds advancing left indexes meet left proceeds stops finds item larger partitioning item proceeds stops encounters item smaller partitioning item items swapped list remember idea smaller items left larger items sorted order figure  left pointing letter larger titioning place left list initially pointing atu larger thatõs moves position left pointing letter smaller place list situation displayed figure  quicksortisgreatfun quicksortisgreatfun advanced sorting _596748 ch07 qxd    figure  place items place items closer final sorted position swap figure  figure  place items swapped left continues moving encounters item larger parti tioning item position proceeds mov ing left finds aout place figure  figure  place items items swapped figure  figure  pair place items swapped procedure continues left indexes pair place items figure  figure  place items faicksortisgreut qunfaicksortisgreut qunfuicksortisgreat qunfuicksortisgreat qunquicksortisgreatfun chapter _596748 ch07 qxd    swap items leaving list state figure  stage item left left partitioning item item islarger partitioning item items left indexes handled figure  letters swapped continue procedure place items figure  figure  letters place swap position figure  figure  letters swapped quicksort pass figure  demonstrates pair place items remain figure  letters place swap list state figure  figure  letters swapped faickegitrsorsut qunfaickegrtisorsut qunfaickegrtisorsut qunfaickeortisgrsut qunfaickeortisgrsut qun153advanced sorting _596748 ch07 qxd    things interesting algorithm proceeds left advancing finds item larger partitioning item case letter advances left stops reaches left advantage point items left dealt list state figure  left indexes pointing letter figure  left indexes meet partitioning position point indexes meet partitioning positionñthat place list partitioning belongs final swap location partitioning list partitioning final sortedposition letter partitioning position values leftbeing smaller values larger figure  figure  partitioning item final sorted position steps illustrated letter final sorted position list sorted list divided parts sorted indepen dently simply sort left list list list sorted recursion apply quicksort algorithm sublists left partitioning item cases building recursive algorithms base case general case quicksort base case occurs sublist sorted element definitionalready sorted general case occurs item case apply preceding algorithm partition list smaller sublists placing partitioning item final sorted position quicksort algorithm works test exercise faickeg reater inrsorsut qutfaickegitrsorsut qun154chapter _596748 ch07 qxd    outtesting quicksort algorithm start creating test case specific quicksort algorithm package wrox algorithms sorting public class quicksortlistsortertest extends abstractlistsortertest protected listsorter createlistsorter comparator comparator return quicksortlistsorter comparator works preceding test extends general purpose test sorting algorithms created chapter test quicksort implementation instantiate overriding createlistsorter method implement quicksort outimplementing quicksort create quicksortlistsorter familiar basic structure sorting algorithms implements listsorterinter face accepts comparator imposes sorted order objects sorted package wrox algorithms sorting import wrox algorithms lists list public class quicksortlistsorter implements listsorter private final comparator _comparator public quicksortlistsorter comparator comparator assert comparator null comparator null _comparator comparator sort method delegate quicksort method passing indexes firstand elements sorted case represents entire list method called recursively passing smaller sublists defined indexes public list sort list list assert list null list null quicksort list list size return list advanced sorting _596748 ch07 qxd    implement quicksort indexes provided partition list partitioning list recursively calling quicksort left sublists private void quicksort list list int startindex int endindex startindex endindex list size return endindex startindex return object list endindex int partition partition list startindex endindex _comparator compare list partition partition swap list partition endindex quicksort list startindex partition quicksort list partition endindex partition method perform algorithm place items swapped small items left large items private int partition list list object int leftindex int rightindex int left leftindex int rightindex left _comparator compare list left left continue _comparator compare list continue swap list left left return left chapter _596748 ch07 qxd    finally implement simple swap method protects calls swap item private void swap list list int left int left return object temp list left list set left list list set temp works quicksort method bounds checking indexes passed enables latercode simplified ignoring concern obtains partitioning list step partitioning position delegating partition method partition method test check partitioning location issmaller partitioning happen partitioning isthe largest list items choosing random happen easily case advance partitioning position code written left indexes explanation thealgorithm earlier chapter return method understanding compound comparator stabilitybefore advanced sorting algorithm elaborates discussion stability brought attention previous chapter good time algorithms discussed chapter share shortcoming stable algorithm covered nextñmergesortñis stable good opportunity deal lack stability shellsort quicksort learned chapter stability tendency sorting algorithm maintain relative posi tion items sort key sort process quicksort shellsort lack stability pay attention items original input list discusses compensate issue algorithms compound comparator chapter based list people sorted relative order people maintained ordered group algorithm stable achieve compound key personobject consisting boththe namewhen sorting boththe sorting chapter create general purpose comparators solve differ ent problems approach create compound compara tor wrap number standard single comparators achieve sort outcome based compound key advanced sorting _596748 ch07 qxd    outtesting compoundcomparator tests compound comparator services dummy comparator returns compare method obvious fixedcomparator codeis package wrox algorithms sorting public class fixedcomparator implements comparator private final int _result public fixedcomparator int result _result result public int compare object left object return _result writing tests compound comparator cover basic cases returns returns positive integer returns negative integer compare method tests adds multiple fixed comparators compound comparator set return indicating compound comparator element compound key sort items code test cases package wrox algorithms sorting import junit framework testcase public class compoundcomparatortest extends testcase public void testcomparisoncontinueswhileequal compoundcomparator comparator compoundcomparator comparator addcomparator fixedcomparator comparator addcomparator fixedcomparator comparator addcomparator fixedcomparator asserttrue comparator compare public void testcomparisonstopswhenlessthan compoundcomparator comparator compoundcomparator comparator addcomparator fixedcomparator comparator addcomparator fixedcomparator comparator addcomparator fixedcomparator comparator addcomparator fixedcomparator asserttrue comparator compare public void testcomparisonstopswhengreaterthan compoundcomparator comparator compoundcomparator chapter _596748 ch07 qxd    comparator addcomparator fixedcomparator comparator addcomparator fixedcomparator comparator addcomparator fixedcomparator comparator addcomparator fixedcomparator asserttrue comparator compare works test relies add number comparators compoundcomparatorin sequence test adds comparators return respective compare methods called idea compoundcomparatorchecks nested comparatorsin turn returning returns nonzero nested comparators return comparison determined objects test sets series nested comparators returns negative intended behavior compoundcomparatoris return nonzero nested comparators test asserts behavior correct final test job positive return implement compoundcomparator outimplementing compoundcomparator start creating class implement comparatorinterface private listinwhich hold unknown number comparators element compound sort key package wrox algorithms sorting import wrox algorithms iteration iterator import wrox algorithms lists arraylist import wrox algorithms lists list public class compoundcomparator implements comparator private final list _comparators arraylist provide addcomparator method number comparators wrapped thecompound comparator public void addcomparator comparator comparator assert comparator null comparator null assert comparator add comparator _comparators add comparator advanced sorting _596748 ch07 qxd    finally implement compare wrapped comparators turn returning returns nonzero result public int compare object left object int result iterator _comparators iterator isdone result comparator current compare left result break return result compoundcomparatoris extremely existing comparators lack stability simply sort compound key understanding mergesort algorithm mergesort advanced sorting algorithms covered chapter quicksort pos sible implement mergesort recursively iteratively implement recursively quicksort mergesort sort list provided place creates output list objects input list sorted order mergingmergesort built concept merging merging takes sorted lists produces output list items lists sorted order figure  input lists merged note lists sorted order figure  sorted lists merge process merging placing indexes head list point smallest items list figure  figure  merging head list afmdgl afmdgl chapter _596748 ch07 qxd    items start list compared smallest output list item list smallest item copied considered situation item moved output list figure  figure  item output list current items list compared smallest output list case itõs letter list figure  situation step place figure  item output list process continues time letter list smaller item copied output list figure  figure  item output list process continues input lists exhausted output item lists sorted order final state figure  aadf outputfmdgl aadoutputfmdgl aaoutputfmdgl advanced sorting _596748 ch07 qxd    figure  completed merge process mergesort algorithm mergesort algorithm based idea merging quicksort algorithm approach mergesort recursion quicksort divide conquer approach mergesort algorithm describes combine conquer technique sorting level recursion complete lower levels contrast quicksort item final sorted position level problem broken recursive places item sorted position list letters figure  sample data figure  sample list demonstrate recursive mergesort sorting algorithms mergesort built intriguingly simple idea mergesort simply divides list sorted half sorts half independently merges result sounds simple effective explaining figure  sample list split half halves sorted independently final step merge preceding merging figure  sample list split half akey difference mergesort quicksort list split mergesort completely independent input data mergesort simply halves list quicksort titions list based chosen split list point pass sort half list applying mergesort split half half sort half independently merge figure  half original list split half recursivemergesort recursivemergesort aadfglm outputfmdgl chapter _596748 ch07 qxd    figure  recursive mergesort half original list sort half half original list recursive mergesort doubt idea recursing reach sublist single item sorted single item list base case recursive algorithm general case alreadyñthat item list sorted split list half sort halves merge figure  situation level recursion figure  level recursion mergesort reached sublist item continue recursion level figure  figure  fourth level recursion mergesort level recursion figure  sort element sublist letters sublist item split sort halves figure  recursivemergesort recursive recrec urrecursivemergesort recursive recur recursivemergesort recursive advanced sorting _596748 ch07 qxd    figure  final level recursion mergesort finally reached level single item lists base case recursive algorithm merge single item sorted lists single item sorted sublist figure  figure  merge operation complete figure  sublists sublist sorted element sublist merged single item sublist letter sublists merged produce element sorted sublist figure  figure  merge operation complete recursivemergesort recursive cerur recursivemergesort recursive recerc urrecursivemergesort recursive recrerecur164chapter _596748 ch07 qxd    sublist sublist sorted sublist sorted thenext step sort sublist expect involves recursively mergesorting element sublist figure  figure  recursively sorting sublist single item sublists merged figure  figure  merging single item sublists sublists sublist sorted independently recursion unwind merging sublists figure  figure  unwinding recursion merging sublists algorithm continues sublist sorted figure  skipped number steps preceding figures sim ilar steps sorting sublist recursivemergesort cerrusive recursivemergesort recursive cerru recursivemergesort recursive cerur ur165advanced sorting _596748 ch07 qxd    figure  ready merge half original list final step sorting half original list merge sorted sublists result figure  figure  half list sorted algorithm continues half original list sorted asshown figure  figure  half original list sorted finally merge sorted halves original list form final sorted list figure  figure  final result mergesort elegant algorithm simple implement outtesting mergesort algorithm test mergesort algorithm tests chapter difference instantiate implementation class package wrox algorithms sorting public class mergesortlistsortertest extends abstractlistsortertest protected listsorter createlistsorter comparator comparator return mergesortlistsorter comparator ceeirrsuveegmorrst ceeeegimo rrrrsstuv ceeirrsuveegmorrst ceeirrsuvmergesort recursivemergesort cerrueisv chapter _596748 ch07 qxd    implement mergesort outimplementing mergesort implementation usual pattern implement listsorterinterface andaccept comparator impose order items sorted package wrox algorithms sorting import wrox algorithms lists list import wrox algorithms lists arraylist import wrox algorithms iteration iterator public class mergesortlistsorter implements listsorter private final comparator _comparator public mergesortlistsorter comparator comparator assert comparator null comparator null _comparator comparator sort method listsorterinterface mergesort method passing inthe lowest highest item indexes entire list sorted subsequent recursive calls pass ranges restrict sorting smaller sublists public list sort list list assert list null list null return mergesort list list size create mergesort method deal situations called sort asublist single item case creates result list adds single item ing recursion item sublist sorted code simply splits list recursively sorts half merges result private list mergesort list list int startindex int endindex startindex endindex list result arraylist result add list startindex return result int splitindex startindex endindex startindex list left mergesort list startindex splitindex list mergesort list splitindex endindex return merge left advanced sorting _596748 ch07 qxd    merge method complicated expect deal cases lists drained cases lists supplies item private list merge list left list list result arraylist iterator left iterator iterator iterator isdone isdone isdone result add current isdone result add current _comparator compare current current result add current result add current return result works recursive algorithms key implementation cater base case general case recursive method preceding code mergesort method separatesthese cases dealing base case returning method single element sublist considered item splits list half sorts recursively merges merge method merge method obtains iterator sublist required simple sequential traversal items sublist code complicated fact algorithmneeds continue sublists runs items case items sublist output list cases sublists items considered current items sublists compared smaller output list completes coverage advanced sorting algorithms chapter compares algorithms choose problem hand chapter _596748 ch07 qxd    comparing advanced sorting algorithms chapter compare algorithms chapter practical theo retical mathematical approach interested math algorithms excel lent coverage algorithms sedgwick idea approach inspire creativity evaluating code written encourage rely empiri cal evidence preference theoretical benefits general rule refer chapter details listsortercallcountingtestclass compare algorithms chapter create code extends driver program support advanced algorithms code worst case tests public void testworstcaseshellsort shellsortlistsorter _comparator sort _reversearraylist reportcalls _comparator getcallcount public void testworstcasequicksort quicksortlistsorter _comparator sort _reversearraylist reportcalls _comparator getcallcount public void testworstcasemergesort mergesortlistsorter _comparator sort _reversearraylist reportcalls _comparator getcallcount code cases public void testbestcaseshellsort shellsortlistsorter _comparator sort _sortedarraylist reportcalls _comparator getcallcount public void testbestcasequicksort quicksortlistsorter _comparator sort _sortedarraylist reportcalls _comparator getcallcount public void testbestcasemergesort mergesortlistsorter _comparator sort _sortedarraylist reportcalls _comparator getcallcount advanced sorting _596748 ch07 qxd    finally code average cases public void testaveragecaseshellsort shellsortlistsorter _comparator sort _randomarraylist reportcalls _comparator getcallcount public void testaveragecasequicksort quicksortlistsorter _comparator sort _randomarraylist reportcalls _comparator getcallcount public void testaveragecasemergesort mergesortlistsorter _comparator sort _randomarraylist reportcalls _comparator getcallcount evaluation measures number comparisons performed algorithm execution ignores issues number list item movements impact suitability algorithm purpose investiga tion efforts algorithms worst case sorting algorithms included basic algorithms chapter save trouble referring testworstcasebubblesort callstestworstcaseselectionsort callstestworstcaseinsertionsort callstestworstcaseshellsort callstestworstcasequicksort callstestworstcasemergesort callswow whatõs quicksort performed percent comparisons basic algorithms shellsort mergesort require comparison operations quicksort worst simple measurement recall worst case list completely reverse order meaning smallest item highest list algorithm recall quicksort implementation created chooses item list attempts divide list parts items smaller item larger worst case partitioning item alwaysthe smallest item partitioning fact swapping occurs thepartitioning item exhaustive comparison object partitioning isrequired pass imagine wasteful behavior inspired smarter strategies choosing partitioning item lot situation choose partitioning items left middle list choose median partitioning item pass type approach stands chance achieving partitioning place worst case chapter _596748 ch07 qxd    case tests testbestcasebubblesort callstestbestcaseselectionsort callstestbestcaseinsertionsort callstestbestcaseshellsort callstestbestcasequicksort callstestbestcasemergesort callsthe excellent result insertion sort surprise quicksort odd advanced algorithms wondering bothered improvement basic algorithms remember choice partitioning item vastly improved case stumps quicksortõs attempt partition data pass finds largest item position list wasting lot time separate data partitioning item pivot point insertion sort performer terms comparison effort sorted data shellsort eventually reduces insertion sort data sorted state common insertion sort final pass quicksort imple mentations sublists sorted threshold items quicksort recursing simply place insertion sort complete job average case tend realistic reflection type achieve production testaveragecasebubblesort callstestaveragecaseselectionsort callstestaveragecaseinsertionsort callstestaveragecaseshellsort callstestaveragecasequicksort callstestaveragecasemergesort callsfinally clear distinction basic algorithms advanced algorithms algorithms chapter  number comparisons sort average case data basic algorithms huge reduction effort required sort large data sets good news data sets larger gap algorithms wider decide start mergesort problem based excellent performance cases remember mergesort creates copy list sublist sorts requires memory time job algorithms careful draw conclusions justified evidence programming endeavors advanced sorting _596748 ch07 qxd    summary chapter covered advanced sorting algorithms algorithms complex subtle algorithms covered chapter solving large practical problems programming career advanced sort ing algorithmsñshellsort quicksort mergesortñwere explained imple mented tested learned lack stability inherent shellsort quicksort implementing pound comparator compensate shortcoming finally looked simple comparison algorithms covered previous chapter enable understand strengths weaknesses options chapter learn sophisticated data structure builds learned queues incorporates techniques sorting algorithms exercises1 implement mergesort iteratively recursively implement quicksort iteratively recursively count number list manipulations set add insert quick sort shellsort implement place version insertion sort create version quicksort insertion sort sublists fewer items chapter _596748 ch07 qxd    priority queuesafter studying broad selection sorting algorithms previous chapters return investigating data structures chapter apriority queue special type queue chapter access largest element contained ing applications book waited covered sorting algorithms discussing priority queues complex priority queue implementations require understand issues sorting priority queue imagine role playing game making hostile territory threatening characters characters lethal identify largest threat health good survival strategy notice maintain listof threatening characters sorted order fight time time threat largest time youõve dealt biggest arrived scene sort chapter covers topics understanding priority queuescreating unordered list priority queue creating sorted list priority queue understanding heap workscreating heap ordered list implementation priority queue comparing priority queue implementations _596748 ch08 qxd    understanding priority queues apriority queueis queue supports accessing items largest smallest simple queue supports accessing items order queue stack supports accessing items based stack priority queue enables flexible access objects contained structure apriority queue client program access largest item time donõt concerned term largest simple reverse comparator switch smallest cost point priority queue mechanism determine item largest compara tor access largest item queue time apriority queue general form queue ordinary fifo queue lifo stack imagine priority queue comparator supplied based time insertion fifo time insertion lifo apriority queue provide feature set normal stack queue simple priority queue exampleimagine priority queue letters imaginary client program insert letters series queue word inserted client remove largest letter queue figure  letters figure  input priority queue dogquickbrownfox jumpedover thelazy chapter _596748 ch08 qxd    adding letters word priority queue figure  situation figure  letters word priority queue largest letter priority queue highlighted client program removes largest item item returned depicted priority queue pool letters list letters specific order priority queues hold elements list understand implementation priority queue abstraction thequickbrownfox jumpedover dogthelazy priorityqueue175priority queues11_596748 ch08 qxd    figure  situation client takes largest item priority queue figure  largest letter removed priority queue thequickbrownfox jumpedover dogthelazy priorityqueueoutput176chapter _596748 ch08 qxd    client program adds letters word priority queue removes largest leading situation figure  figure  word queue largest letter removed thequickbrownfox jumpedover dogthelazy priorityqueueoutput177priority queues11_596748 ch08 qxd    process repeated word figure  figure  word processed thequickbrownfox jumpedover dogthelazy priorityqueueoutput178chapter _596748 ch08 qxd    youõll idea priority queue works weõll skip result processed figure  figure  final state priority queue final state items equal largest remaining items highlighted priority queue client program remove largest item remove items working priority queues examples follow implement priority queues implement queueinterface chapter vary simple complex version based heap structure add operations queueinterface priority queue ineffect alter semantics dequeue method return largest item queue outcreating abstractpriorityqueue test case define test priority queue implementations pass sorting algorithms define test abstract test case leaving factory method asa placeholder test specific implementation priority queue extend abstract class implement factory method instantiate implementation test thequickbrrownfoxjumpedovedogthelazypriorityqueueoutput179priority queues11_596748 ch08 qxd    start declaring test case specific values instance member hold thequeue public abstract class abstractpriorityqueuetestcase extends testcase private static final string value_a private static final string value_b private static final string value_c private static final string value_d private static final string value_e private queue _queue define setup teardown methods setup calls abstract factory methodcreatequeue method specific test implement protected void setup throws exception super setup _queue createqueue naturalcomparator instance protected void teardown throws exception _queue null super teardown protected abstract queue createqueue comparator comparable test establishes behavior queue test chapter4 testing types queues avoided duplicating code plex hierarchy test cases opted simplicity clarity recommend making choice production code public void testaccessanemptyqueue assertequals _queue size asserttrue _queue isempty _queue dequeue fail catch emptyqueueexception expected chapter _596748 ch08 qxd    method major test priority queue behavior adding items queue making size isempty methods working expected public void testenqueuedequeue _queue enqueue value_b _queue enqueue value_d _queue enqueue value_a assertequals _queue size assertfalse _queue isempty largest items case string returned dequeue method preceding code adds items queue ond items normal fifo queue lifo stack fails test straightaway removed item verify operations making sense assertsame value_d _queue dequeue assertequals _queue size assertfalse _queue isempty string bis largest remaining items returned dequeue method assertsame value_b _queue dequeue assertequals _queue size assertfalse _queue isempty add couple items queue common applications priority queues mixture enqueue dequeue invocations simply building emptying thequeue _queue enqueue value_e _queue enqueue value_c assertequals _queue size assertfalse _queue isempty elements priority queue strings queue order largest smallest test completes removing turn ensuring size isempty remain consistent expectations assertsame value_e _queue dequeue assertequals _queue size assertfalse _queue isempty assertsame value_c _queue dequeue assertequals _queue size assertfalse _queue isempty assertsame value_a _queue dequeue assertequals _queue size asserttrue _queue isempty priority queues11_596748 ch08 qxd    complete test case generic queue test verify behavior clear method public void testclear _queue enqueue value_a _queue enqueue value_b _queue enqueue value_c assertfalse _queue isempty _queue clear asserttrue _queue isempty thatõs general priority queue test implementation simple list based queue searches largest item required understanding unsorted list priority queue simplest implement priority queue elements sort collectionand search largest item dequeue called algorithm brute force search item operation dependingon application acceptable calls dequeue inyour case simple solution implementation enqueue hard beat implement simple priority queue holds queued items list outtesting implementing unsorted list priority queue linkedlistin case arraylistwould work extending abstractpriorityqueuetestcaseyou created implementing createqueue method instantiate created implementation public class unsortedlistpriorityqueuetest extends abstractpriorityqueuetestcase protected queue createqueue comparator comparator return unsortedlistpriorityqueue comparator implementation lot common queue implementations chapter chosen reproduce code common simplicity chapter _596748 ch08 qxd    start creating class declaring instance members list hold items comparatorto determine relative size items declare constructor set public class unsortedlistpriorityqueue implements queue private final list _list private final comparator _comparator public unsortedlistpriorityqueue comparator comparator assert comparator null comparator null _comparator comparator _list linkedlist implementation enqueue simpler add item list public void enqueue object _list add implement dequeue verifying queue throw exception method called queue item queue remove largest item determined getindexoflargestelement method public object dequeue throws emptyqueueexception isempty throw emptyqueueexception return _list delete getindexoflargestelement largest item list scan entire list keeping track largest item method suited arraylistthan chosen linkedlist private int getindexoflargestelement int result int _list size _comparator compare _list _list result result return result priority queues11_596748 ch08 qxd    complete class implement remaining methods queueinterface list based queueimplementation public void clear _list clear public int size return _list size public boolean isempty return _list isempty test implementation behaves expected implementing version priority queue aims eliminate brute force searching works unsorted list implementation priority queue simple enqueue item simply internal listõs add method append list remove item queue simply iterate items member list remembering scanned largest iteration return largest item removing list understanding sorted list priority queue avoid brute force scan list items queue dequeue iscalled largest item keeping items sorted order dequeue method fast sacrifice effort enqueue position insert item approach insertion sort mechanism calls enqueue place newly items sorted position underlying list calls dequeue extremely simpleñmerely remove largest item list outtesting implementing sorted list priority queue implement priority queue underlying list maintained sortedorder extend abstractpriorityqueuetestcasefor specific implementation public class sortedlistpriorityqueuetest extends abstractpriorityqueuetestcase protected queue createqueue comparator comparator return sortedlistpriorityqueue comparator chapter _596748 ch08 qxd    basic structure implementation unsorted version chapter instance members identical constructor public class sortedlistpriorityqueue implements queue private final list _list private final comparator _comparator public sortedlistpriorityqueue comparator comparator assert comparator null comparator null _comparator comparator _list linkedlist create enqueue method scan backwards items list finding place insert item public void enqueue object int pos _list size pos _comparator compare _list pos  pos _list insert pos implement dequeue removing item list remember throw exception list return public object dequeue throws emptyqueueexception isempty throw emptyqueueexception return _list delete _list size add final methods simple queueimplementa tions public void clear _list clear public int size return _list size public boolean isempty return _list isempty priority queues11_596748 ch08 qxd    thatõs sorted list implementation priority queue test meetsthe criteria established correct priority queue behavior addresses plex effective practical version priority queue based structure called heap works version enqueue implementation complex previous implementation function position list item inserted scanning backwards items turn finds smaller list inserts item queue position ensures times largest item list benefit expending extra effort implementation dequeue doexcept remove item list return understanding heap ordered priority queues aheap interesting data structure time explaining works grasp concept heap implement effective priority queue aheapis simply binary tree structure element larger children heap condition figure  note whichever node element larger children figure  heap careful heap sorted sorted property definition heap largest item sitting tree arrangement items notice small element heap case row tree expect wondering heapinterface treeinterface defined imple mented wonõt approach case simple list heap structure figure  demonstrates technique numbering elements heap easily start tree work left counting xmkeafd db186chapter _596748 ch08 qxd    figure  numbering items heap storage list approach enables mental model tree structure implementation tree structure exists figure  list sample heap structure figure  heap structure contained list xmkeafddb x012564378mkeafd dbx012564378mkeafd db187priority queues11_596748 ch08 qxd    heap navigate structure upwards item determine left child item rightchild item determine parent item hereõs left child item  child item  parent item ð  item parent refer figures satisfy formulas work expect mula parent item relies truncation result item question child parent youõll realize access list ò3 ó sink swimto heap build priority queue add items remove items sound obvious order perform operations maintain heap conditionñthat heap heap add remove items letõs extend sample heap adding letter pto start simply adding tree structure figure  figure  item heap breaking heap condition heap stored simple list add item problem heap longer heap parent item smaller item heap reestablish heap condition item work tree structure heap condition restored called swimmingto swimming matter exchanging item parent parent smaller continuing heap reached parent equal larger item swimming figure  situation item swapped parent item xmkeafd pdb188chapter _596748 ch08 qxd    figure  item exchanged parent heap condition met item larger parent swimming figure  item swapped parent item figure  item moves final position heap heap condition restored heap element larger item maintained heap condition challenge removing largest item heap locating largest item easy removing easy delete underlying list tree structure completely destroyed start feel free experiment enjoyment swap item tree figure  xpkemfd adbxmkepfd adb189priority queues11_596748 ch08 qxd    figure  largest item removed item tree structure intact heap condition violated smallest item tree tree heap condition restored process sinkingto sinking process repeatedly exchanging item larger children heap dition restored tree reached larger children sinking item ais exchanged figure  state heap exchange figure  element sunk level heap condition violated ais larger children larger chil dren swap item figure  state heap exchange pakemfd xdbapkemfd xdb190chapter _596748 ch08 qxd    figure  heap condition restored sinking heap condition restored largest item removed leaving heap item smaller armed understanding concept implement priority queue test implement priority queue stores elements queue heap ordered listñthat list arranged logically heap complex implementations covered chapter outtesting implementing heap ordered priority queue create test case specific heap ordered implementation public class heaporderedlistpriorityqueuetest extends abstractpriorityqueuetestcase protected queue createqueue comparator comparator return heaporderedlistpriorityqueue comparator structure implementation priority queues list hold items comparatorto order appropriately public class heaporderedlistpriorityqueue implements queue private final list _list private final comparator _comparator public heaporderedlistpriorityqueue comparator comparator assert comparator null comparator null _comparator comparator _list arraylist pmkeafd xdb191priority queues11_596748 ch08 qxd    create enqueue method add item underlying list swim heap public void enqueue object _list add swim _list size create swim method accepts parameter item swimmingup heap compare parent swapping parent smaller swim recursively continue process heap private void swim int return int parent  _comparator compare _list _list parent swap parent swim parent numerous swap methods trouble private void swap int index1 int index2 object temp _list index1 _list set index1 _list index2 _list set index2 temp create dequeue method returns item list swap item list list sink heap restore heap condition public object dequeue throws emptyqueueexception isempty throw emptyqueueexception object result _list _list size _list set _list _list size sink _list delete _list size return result chapter _596748 ch08 qxd    create sink method swap item largest children careful cater cases item children private void sink int int left  int  left _list size return int largestchild left _list size _comparator compare _list left _list largestchild _comparator compare _list _list largestchild swap largestchild sink largestchild youõll exhausted bit code good news remaining methods simple public void clear _list clear public int size return _list size public boolean isempty return _list isempty works enqueue method simple passes hard work swim methodafter adding item underlying list parameter passed swim method theindex item swim heap swim method task comparing theitem provided parent item heap exchanging item larger parent exchange required method calls recursively continue process higher heap method stops heap notice formula identify parent element matches explanation ear lier chapter priority queues11_596748 ch08 qxd    implementation dequeue locating item returned simple list item return item delete underlying list item deleted endof list item queue item return delete cases exchange item item sink heap reestablish heap condition sink lot complex swim couple interesting cases item question children child child left child child case ignore start calculating children indices fall valid range items queue item sink lower figure children child larger larger children exchange item question required start assuming left child larger change assump tion child child larger left child point children larger remains compare item larger children child larger swap recursively sink tinue process heap heap condition restored heap ordered implementation priority queue final version included chapter interesting adds items queue removes queue manner logn algorithm proportional depth binary tree elements question characteristic great advantage treat items long linear fashion compare priority queue implementations stack comparing priority queueimplementationsas previous chapters opt practical theoretical comparison implementations callcountingcomparatorto gain understanding howmuch effort implementations achieve remember single dimension evaluation total definitive gain insight inspire investi gation theoretically sound comparisons check appendix resources youõre interested delving area comparing sorting algorithms previous chapters chapter considers worst average cases priority queue implementations perform mixed set oper ations add remove items queues test case consists adding data sorted order worst case consists adding data reverse sorted order average case consists adding randomly generated data queue chapter _596748 ch08 qxd    basic structure test driver class declare constant control size tests declare lists worst average cases finally declare callcountingcomparatorto collect statistics public class priorityqueuecallcountingtest extends testcase private static final int test_size private final list _sortedlist arraylist test_size private final list _reverselist arraylist test_size private final list _randomlist arraylist test_size private callcountingcomparator _comparator setup method instantiates comparator fills lists test data protected void setup throws exception super setup _comparator callcountingcomparator naturalcomparator instance int test_size _sortedlist add integer int test_size _reverselist add integer int test_size _randomlist add integer int test_size math random worst case scenarios delegate runscenario method public void testworstcaseunsortedlist runscenario unsortedlistpriorityqueue _comparator _reverselist public void testworstcasesortedlist runscenario sortedlistpriorityqueue _comparator _reverselist public void testworstcaseheaporderedlist runscenario heaporderedlistpriorityqueue _comparator _reverselist priority queues11_596748 ch08 qxd    define case scenarios priority queue implementations public void testbestcaseunsortedlist runscenario unsortedlistpriorityqueue _comparator _sortedlist public void testbestcasesortedlist runscenario sortedlistpriorityqueue _comparator _sortedlist public void testbestcaseheaporderedlist runscenario heaporderedlistpriorityqueue _comparator _sortedlist finally average case scenarios public void testaveragecaseunsortedlist runscenario unsortedlistpriorityqueue _comparator _randomlist public void testaveragecasesortedlist runscenario sortedlistpriorityqueue _comparator _randomlist public void testaveragecaseheaporderedlist runscenario heaporderedlistpriorityqueue _comparator _randomlist runscenario method provided parameters queue test list input data approach iterate input data adding elements queue test items stops takes items queue numbers arbitrary serve mixture enqueue dequeue opera tions simulate priority queues practice method finishes pletely drains queue calls reportcalls output summarizing test private void runscenario queue queue list input int iterator iterator input iterator iterator iterator isdone queue enqueue iterator current  int  queue dequeue iterator queue isempty queue dequeue reportcalls chapter _596748 ch08 qxd    final method driver program simple dump number comparisons test private void reportcalls int callcount _comparator getcallcount println getname callcount calls comparison priority queue implementations worst case testworstcaseunsortedlist callstestworstcasesortedlist callstestworstcaseheaporderedlist callsthe heap ordered version clear winner difference simpler ver sions case testbestcaseunsortedlist callstestbestcasesortedlist callstestbestcaseheaporderedlist callsthatõs interesting recall insertion sort excellent sorted data youõll understand sorted list version work brute force version heap version performing percent operations measure finally happen real testaveragecaseunsortedlist callstestaveragecasesortedlist callstestaveragecaseheaporderedlist callsyou sorted list version half comparisons brute force ver sion heap ordered implementation remains clear leader implementation based heap structure effective based simple test depends specific circumstances balance extra complexity extra efficiency determine implementation suits application priority queues11_596748 ch08 qxd    summary chapter covered key points learned data structure called priority queue data structure general form queuethat covered chapter apriority queue access largest item queue time comparatoris determine relative size items queue implemented versions priority queue simply items underlying list scan items required return largest improvement items sorted order times allowing rapid retrieval largest item time final version list arranged heap struc ture achieve excellent performance add remove operations athorough explana tion heaps work provided implementations compared contrasted practical theo retical approach exercisesto test understanding priority queues exercises priority queue implement stack priority queue implement fifo queue priority queue implement listsorter write priority queue access smallest item largest chapter _596748 ch08 qxd    binary searching insertion book discussed basic structures storing sorting data touched rudimentary approaches searching data modern software applications deal enormous amounts data search data efficiently locate patientõs record tens thousands break application chapters book focus algorithms data structures designed efficient storage searching data binary searching basic techniques efficiently searching data mem ory binary insertion variation binary searching enables maintain data efficiently searched chapter discusses perform binary searching implementing binary search iteration recursion comparing binary searching search techniques comparing binary insertion sorting techniquesunderstanding binary searching binary searching technique locating items sorted list abinary search takes advantage characteristics sorted lists simple linear search doesnõt brute force linear search runs time binary search runs logn assuming data besearched sorted _596748 ch09 qxd    chapter simplest search unordered list start item tinue forward match items leads average case running time actual average running time traverse onaverage half items list data sorted lot binary searching fact continually divide data half progressively narrowing search space match items process english dictionary asked word algorithm start open book start flipping time asked word lama start middle start book reason dictionary arranged ascending alphabetical order aðz good guess searching lama open book mandarin thenyou youõd skip conversely encounter kangaroo hadnõt skip forwards discovering word searching question skip forwards backwards specific guess skip based knowledge language relative number letter alphabet idea contents knew book sorted abinary search involves continually dividing data half ñhence binaryñand searching lower upper half steps involved performing binary search summa rized start middle list compare search key item current location search key current location search key item current location lower half data exists divide list step lower half upper half list exists step usingthe upper half demonstrates search letter list letters figure  list letters sorted order figure  list letters ascending sorted order adfhiklmp chapter _596748 ch09 qxd    start search middle list comparing search key letter figure  figure  search middle item havenõt match divide list half search key sorts higher current item concentrate efforts upper half figure  figure  search key exist upper half list list consists letters pñan number finding middle item list number items nonsensical luckily doesnõt matter halves strictly equal arbitrarily choose middle items lor figure  figure  search continues òmiddleó item compare search key chosen middle itemñl itõs item divide list time search key sorts lower current itemñk sorts lñso assume lower half exists figure  search finally narrows item case figure  search finally narrows item adfhi klmp012345678adfhi klmp adfhi klmp adfh iklmp binary searching insertion _596748 ch09 qxd    search complete managed locate key comparisons intermedi ary comparisons final comparison match search brute force approach comparisons finally argue search key binary searching efficient key start list letter ahad search key brute force approach comparison binary search fair limited case brute force search binary search cases binary search betterña fact demonstrated concretely chapter binary search approaches youõve observed algorithm works principle itõs time turn code demonstrates binary search approaches involving recursion itera tion general performance characteristics littlemore intuitive list searcherin define interface common approaches recursive iterative implementing binary search enable plug implementations testing performance evaluation alist searcher enables search list case sorted list key single method search method comparator determine search key matches items list key search returns position  item search returns negative point existed point youõre wondering return position informa tion time search key wasnõt answer negative positive return values searches successful negative values unsuccessful searches simply negative position ð1 ð2 position list avalue ð0 doesnõt sense trick alter return position ð1 ð2 encode position andthe fact search key wasnõt outcreating list searcher interface thing create actual interface package wrox algorithms bsearch import wrox algorithms lists list chapter _596748 ch09 qxd    public interface listsearcher public int search list list object key works interface method single search operation discussed earlier method takes list search key arguments returns integer position list notice donõt pass comparator search isassumed searcher constructed comparator separation cerns enables list searcher passed code needing howthe ordering performed obvious write actual test code outwriting tests interface work write tests weõve identified list searcher implementations iterative recursive chapter finished weõll create suite tests list searcher satisfy wonõt rewrite tests implementation start creating test class package wrox algorithms bsearch import wrox algorithms lists arraylist import wrox algorithms lists list import wrox algorithms sorting comparator import wrox algorithms sorting naturalcomparator import junit framework testcase public abstract class abstractlistsearchertestcase extends testcase private static final object values private listsearcher _searcher private list _list protected abstract listsearcher createsearcher comparator comparator protected void setup throws exception super setup _searcher createsearcher naturalcomparator instance _list arraylist values binary searching insertion _596748 ch09 qxd    works abstractlistsearchertestcasedefines test data values list searcher list search thereõs abstract method createsearcher subclasses test classimplement return list searcher implementations setup create list searcher calling createsearcher finally construct list array values tests work notice createsearcher method takes comparator argument recall search method listsearchermakes mention comparator time worry construction time start writing tests outcreating tests simple test ensure searching existing values correct position list public void testsearchforexistingvalues int _list size assertequals _searcher search _list _list create test searches doesnõt exist list ensure return corresponds position located existed public void testsearchfornonexistingvaluelessthanfirstitem assertequals _searcher search _list test searches existing time belongs list position public void testsearchfornonexistingvaluegreaterthanlastitem assertequals _searcher search _list finally search existing time belonging middle list public void testsearchforarbitrarynonexistingvalue assertequals _searcher search _list chapter _596748 ch09 qxd    works test created iterates list _ list performs search result search checked ensure corresponds current position list iterator track current position independently integer position test searches doesnõt exist exist start listñposition ñas sorts items expect return ð  ð1 remember values return ð insertionpoint test searches expects result wasnõt time belongs list position return ð  ð13 test searches position existed search return ð  ð4to doesnõt exist recursive binary searcher tests place implement binary search algorithm binary searching process continually dividing problem smaller smaller pieces divide conquerapproach smacks recursion implementation develop recursion outtesting creating recursive binary searcher ensure recursive binary search works properly create test class package wrox algorithms bsearch import wrox algorithms sorting comparator public class recursivebinarylistsearchertest extends abstractlistsearchertestcase protected listsearcher createsearcher comparator comparator return recursivebinarylistsearcher comparator create list searcher package wrox algorithms bsearch import wrox algorithms lists list import wrox algorithms sorting comparator public class recursivebinarylistsearcher implements listsearcher private final comparator _comparator public recursivebinarylistsearcher comparator comparator assert comparator null comparator null _comparator comparator binary searching insertion _596748 ch09 qxd    private int searchrecursively list list object key int lowerindex int upperindex assert list null list null lowerindex upperindex return lowerindex int lowerindex upperindex lowerindex int cmp _comparator compare key list cmp searchrecursively list key lowerindex cmp searchrecursively list key upperindex return public int search list list object key assert list null list null return searchrecursively list key list size works youõve defined tests abstractlistsearchertestcase simply extend thisclass implement createsearcher return instance recursivebinarylistsearcher recursivelistsearcherclass addition implementing listsearcherinterface holds aninstance comparator initialized constructor holding comparator enables application code perform searches knowledge comparison mechanism method searchrecursively hard work performed list search search key searchrecursively takes addition arguments lowerindexand upperindex mark òboundsó search space refer figure  figure  youõll notice time list divided half range elements original list refer figure  considered elements positions  potential locations search key pared positions  refer figure  ultimately ended element position refer figure  upper lower bounds remaining search space correspond directly upperindexand lowerindexarguments ignoring termination condition step search process identify òmid dleó element subtracting lower upper dividing result int lowerindex upperindex lowerindex chapter _596748 ch09 qxd    starting figure  formula calculate middle element    fact figure  started obvious lower refer figure  lower upper bounds  numbers formula  ð     figure  donõt add lower position ð   incorrect subtracting lower upper relative distance set lower comparator compare key element position calculated result comparison stored variable cmp int cmp _comparator compare key list acomparator returns equal arguments match left argument sorts lower argument greater left argument sorts higher argument case binary search tells search key continue search key sorts current item recursive searching lower half list lower half list starts lower continues current position cmp searchrecursively list key lowerindex conversely search key sorts current item recursive upper half list upper half list starts current position contin ues upper cmp searchrecursively list key upperindex finally search key matches current item option searching required code falls return current position list piece code left termination conditionñthe bit brushed earlier recall time mismatch lower upper bounds incremented decre mented point crossñthat lower bound greater upper bound search encounters mismatch final element figure  point search narrowed element position lower upper values original amatch position mismatch sorts proceeded search upper half remaining elements binary searching insertion _596748 ch09 qxd    case check determine lowerindexand upperindexvariables havecrossed signal elements terminate point lower position search key existed list lowerindex upperindex return lowerindex finally created search method doesnõt pass lastelements list searchrecursively iterative binary searcher test create recursive binary iterative searcher iterative version turns simple understand recursive version outtesting implementing iterative binary searcher recursive version iterative version test class addition extend abstract test class package wrox algorithms bsearch import wrox algorithms sorting comparator public class iterativebinarylistsearchertest extends abstractlistsearchertestcase protected listsearcher createsearcher comparator comparator return iterativebinarylistsearcher comparator time createsearcher returns instance iterativebinarylistsearcherclass create package wrox algorithms bsearch import wrox algorithms lists list import wrox algorithms sorting comparator public class iterativebinarylistsearcher implements listsearcher private final comparator _comparator public iterativebinarylistsearcher comparator comparator assert comparator null comparator null _comparator comparator public int search list list object key assert list null list null chapter _596748 ch09 qxd    int lowerindex int upperindex list size lowerindex upperindex int lowerindex upperindex lowerindex int cmp _comparator compare key list cmp return cmp upperindex lowerindex return lowerindex works recursive version iterativebinarylistsearcherclass implements listsearcherandholds comparator constructor method class search method direct conversion recursivebinarylistsearcher aclose inspection recursive search code reveals time recurse modify upper lower variables lead realization recursion whileloop simply modifying upper lower indexvariables iterative version search starts initializing lower upper variables positions elements list int lowerindex int upperindex list size analogous search method passing positions elements tosearchrecursively recursive implementation enter whileloop predicted lowerindex upperindex return lowerindex binary searching insertion _596748 ch09 qxd    recursive version point expect values lower upper variables cross search key doesnõt exist loop continues processing occurs lowerindex upperindex loop terminates position atwhich search key existed returned lowerindex values search calculate position middle perform comparison int lowerindex upperindex lowerindex int cmp _comparator compare key list comparison detects match code return current position cmp return conversely search key sorts current item continue search lower half list adjusting upper cmp upperindex finally search key sorts current item continue search upper half list adjusting lower lowerindex assessing list searcherõs performance explore number scenarios gather statistics enable determine binary search algorithms performs brute force linear search comparing performance sorting algorithms chapters  comparison usea callcountingcomparatorto count number comparisons search performed linear searching comparisonbefore assessing performance binary searchers comparing linear search possibility indexof method directly list interface originally implemented brute force linear search indexof defined doesnõt comparator provide convenient count number comparisons youõll create list searcher forms linear search sorted list comparator enabling collect statistics assessment chapter _596748 ch09 qxd    outtesting implementing linear searcher develop linear list searcher purely comparison binary searching trust comparison bug code code developed start creating test suite package wrox algorithms bsearch import wrox algorithms sorting comparator public class linearlistsearchertest extends abstractlistsearchertestcase protected listsearcher createsearcher comparator comparator return linearlistsearcher comparator create searcher implementation class package wrox algorithms bsearch import wrox algorithms iteration iterator import wrox algorithms lists list import wrox algorithms sorting comparator public class linearlistsearcher implements listsearcher private final comparator _comparator public linearlistsearcher comparator comparator assert comparator null comparator null _comparator comparator public int search list list object key assert list null list null int iterator list iterator isdone int cmp _comparator compare key current cmp return cmp break return binary searching insertion _596748 ch09 qxd    works thankfully outward behavior linear search identical list searcher implementation advantage abstract test class createsearcher return instance linearlistsearcher linearlistsearcherclass implements listsearcherand holds comparator nodoubt expected search method essentially copied code developed indexof inchapter minor change calling equals youdid indexof code comparator calling comparator recording result local variable cmp values equal match return int cmp _comparator compare key current cmp return difference code chapter optimization search key isnõt original implementation continues list case advantage fact list sorted reasonable assumption binary search algorithms predicated continue searching chance search key exist list reach point list search key sort current item safely ter minate loop cmp break rest search identical original indexof implementation tests performance wonõt strictly speaking creating tests real sense asser tions junit framework excellent harness performance analysis willdevelop performance tests form test methods methods perform samesequence searches list searchers elapsed running times measuring performance count number comparisons callcountingcomparatorfrom chapter outcreating test class start creating test class named binarysearchcallcountingtest designed count number comparison calls chapter _596748 ch09 qxd    package wrox algorithms bsearch import wrox algorithms lists arraylist import wrox algorithms lists list import wrox algorithms sorting callcountingcomparator import wrox algorithms sorting naturalcomparator import junit framework testcase public class binarysearchcallcountingtest extends testcase private static final int test_size private list _sortedlist private callcountingcomparator _comparator protected void setup throws exception super setup _sortedlist arraylist test_size int test_size _sortedlist add integer _comparator callcountingcomparator naturalcomparator instance private void reportcalls println getname _comparator getcallcount calls works test class created defines constant test_size shortly populate andsearch instance variable _ sortedlistand instance variable _comparator hold callcounting comparator gathering statistics setup method constructed array list populated integers ascending order to test_size created counting comparator reporting wrapped nat ural comparator safely natural comparator integerclass implements thecomparatorinterface reportcalls method individual tests print number calls tothe comparator form test callsnow list sorted data comparator gathering statistics toreport statistics exercises implement tests list searchers perform binary searching insertion _596748 ch09 qxd    outimplementing tests set tests perform search values and test_size order print number comparisons public void testrecursivebinarysearch performinordersearch recursivebinarylistsearcher _comparator public void testiterativebinarysearch performinordersearch iterativebinarylistsearcher _comparator public void testlinearsearch performinordersearch linearlistsearcher _comparator private void performinordersearch listsearcher searcher int test_size searcher search _sortedlist integer reportcalls set performs random searches public void testrandomrecursivebinarysearch performrandomsearch recursivebinarylistsearcher _comparator public void testrandomiterativebinarysearch performrandomsearch iterativebinarylistsearcher _comparator public void testrandomlinearsearch performrandomsearch linearlistsearcher _comparator private void performrandomsearch listsearcher searcher int test_size searcher search _sortedlist integer int test_size math random reportcalls chapter _596748 ch09 qxd    works order tests construct list searchers passed performordersearch perform order  search finally report number comparisons random tests construct searcher counting comparator pass performrandomsearch randomly generate values tests depending tool testrecursivebinarysearch callstestiterativebinarysearch callstestlinearsearch callstestrandomrecursivebinarysearch callstestrandomiterativebinarysearch callstestrandomlinearsearch callsthese summarized table  easier comparison search methods table  performance comparison searches sorted list recursive binaryiterative binarylinear comparisons order   comparisons random   comparisons average actual vary random nature test data recursive iterative implementations perform number comparisons order search difference number comparisons random search recursive iterative implementations artifact random nature test expected itõs nice assumptions confirmed itõs worth noting therecursive version suffer slight penalty overhead recursive method calls difference negligible thing observe difference binary search linear search case binary search average number comparisons formed   average linear search   figures confirm original predictions performance characteristics binary searching linear searching expected binary search average logn comparisons linear search actual performance binary searching excellent long data structure array list supports fast indexed based lookup linked list number comparisons remains array list continual traversal list item comparison imposes considerable time penalties binary searching insertion _596748 ch09 qxd    understanding binary insertion binary insertion technique based binary searching enables maintain data sorted order sorting algorithms covered book data order performing sort insertion list expensive performing sort data list turns tobe expensive inserting data sorted order start binary insertion works pretty binary searching fact difference binary search returns position search key data binary insert suggests inserts key list position imagine wanted add letter list letters defined previous refer figure  binary search start middle item comparing determine insertion point lie lower half list sorts lower figure  letter compare time sorts higher current item concentrate upper half remaining list figure  search moves lower half list youõre letters figure  sorts higher current item figure  figure  search moves upper half remaining list sorts lower current item time items compare itõs time perform insertion figure  search narrows item adf hiklmp adfhiklmp adfhiklmp chapter _596748 ch09 qxd    belongs item shift elements including position room figure  figure  key inserted maintain correct ordering insert correct position ensures ordering list maintained binary insertion works write code perform binaryinsertion list list inserter develop simple class inserts list ordering list maintained reinvent wheel youõll list searcher inser tion point outcreating tests tests binary insert algorithm add numbers list add numbers sorted order randomly cases expect values inserted correct order start creating test class package wrox algorithms bsearch import wrox algorithms iteration iterator import wrox algorithms lists arraylist import wrox algorithms lists list import wrox algorithms sorting naturalcomparator import junit framework testcase public class listinsertertest extends testcase private static final int test_size private listinserter _inserter private list _list protected void setup throws exception super setup _inserter listinserter iterativebinarylistsearcher naturalcomparator instance hadf giklmp binary searching insertion _596748 ch09 qxd    _list arraylist test_size private void verify int previousvalue integer min_value iterator _list iterator isdone int currentvalue integer current intvalue asserttrue currentvalue previousvalue previousvalue currentvalue test involves inserting values list ascending order add numbers starting   maximum test_size public void testascendinginorderinsertion int test_size assertequals _inserter insert _list integer verify test variation inserting values ascending order time insert descending order start maximum work reach public void testdescendinginorderinsertion int test_size  assertequals _inserter insert _list integer verify final test inserts random values list ensures inserter isnõt work ing coincidence values order previous tests public void testrandominsertion int test_size _inserter insert _list integer int test_size math random verify chapter _596748 ch09 qxd    works test class holds instance listinserterand list tests insert val ues initialized setup method verify method called tests ensure contents list order iterating item list successive currentvalue thenchecked ensure previousvalue notice ini tialized previous integer min_value guarantees assertion succeedthe time previous speak test simple forloop enables add values ascending order instance inserter time inserted return accurately reflects insertion point case ascending insertion insertion point matches valueinserted goes position into position finally values verify ensure correct positionsñjust insert reported correct positions doesnõt test forloop add values descending order time insert ing descending order insert reports posi tion shifting existing values spot finally verify ensure insertion worked expectedñagain trust return accurately reflects actual insertion point final test adds test_sizeintegers list determined domly math random recall math random returns double precision floating point number range to ñtherefore multiply result test_sizeto ensure integers range to test_size notice time assertions valuereturned insert values inserted randomorder tests place implement actual inserter outimplementing inserter code perform binary insertion simple involves creating listinserterclass asshown package wrox algorithms bsearch import wrox algorithms lists list public class listinserter private final listsearcher _searcher public listinserter listsearcher searcher assert searcher null searcher null _searcher searcher public int insert list list object assert list null list null binary searching insertion _596748 ch09 qxd    int _searcher search list  list insert return works constructor listinserterclass takes sole argument listsearcher insertion pointñmost binary insertion binary search reinvent wheel insert method list searcher insertion point search successful element exists worry duplicates simply insert position existing spot wasnõt discussion searching convert return valid position insert list return insertion point caller assessing performance class efficient binary search mechanism adding items list time maintaining list sorted order question performance stack sorting algorithms developed chapters  surely create ordinary list populate data sort create test suite enables compare performance binary insertion code sorting algorithms outcomparing binary inserter sorting algorithms assessing performance list searchers create test suite exercises binary inserter compares sorting list sorting algorithms package wrox algorithms bsearch import wrox algorithms lists arraylist import wrox algorithms lists list import wrox algorithms sorting callcountingcomparator import wrox algorithms sorting listsorter import wrox algorithms sorting mergesortlistsorter import wrox algorithms sorting naturalcomparator import wrox algorithms sorting quicksortlistsorter chapter _596748 ch09 qxd    import wrox algorithms sorting shellsortlistsorter import junit framework testcase public class binaryinsertcallcountingtest extends testcase private static final int test_size private list _list private callcountingcomparator _comparator protected void setup throws exception super setup _list arraylist test_size _comparator callcountingcomparator naturalcomparator instance test write exercises binary inserter developed add number values list count number comparisons process public void testbinaryinsert listinserter inserter listinserter iterativebinarylistsearcher _comparator int test_size inserter insert _list integer int test_size math random reportcalls private void reportcalls println getname _comparator getcallcount calls test binary insertion create tests sorting alternatives sorting algorithms binary searching earlier chapter public void testmergesort populateandsortlist mergesortlistsorter _comparator public void testshellsort populateandsortlist shellsortlistsorter _comparator public void testquicksort populateandsortlist quicksortlistsorter _comparator binary searching insertion _596748 ch09 qxd    private void populateandsortlist listsorter sorter int test_size _list add integer int test_size math random _list sorter sort _list reportcalls works test class holds list values inserted comparator whenordering sorting previous performance tests array list counting comparator collect statistics order evaluate approaches method testbinaryinsert creates iterative binary list searcher recursive version iterative doesnõt overhead nested calls insert test_sizerandom integer values list method reportcalls toprint number calls comparator form test callsthe final tests create sorting algorithm passed populateandsortlist real work populateandsortlist add test_sizerandom integers list techniqueas sort provided sorting algorithm finally report number calls comparator multiply math random toensure inserted falls range to test_size tests output testbinaryinsert callstestmergesort callstestshellsort callstestquicksort callstable  summarizes whatõs table  performance comparison random inserts list sort typecomparisons binary insert41 mergesort43 shellsort102 quicksort97 actual vary random nature test data chapter _596748 ch09 qxd    table  binary insert performs mergesort coming close ond shellsort quicksort remember performance mergesort comparable requires list binary insert adds values list work average number comparisons performed binary insert binary insert works performing binary search binary search runs logn comparisons list starts initially log20compar isons required insert require log21comparisons log22 theway log2n asimplistic calculation performance nlog n itõs bet ter log2n comparisons unfair time binary insert adds directly correct position maintain ordering values list alwaysbe sorted order matter values add choose add conversely tests applied sorting algorithms allthe values inserted list remains unsorted happen sort list insertion table  summarizes changing populateandsort sort everyinsertion private void populateandsort listsorter sorter int test_size _list add nextvalue _list sorter sort _list reportcalls table  performance comparison sorting insert sort typecomparisons binary insert41 mergesort48  shellsort44  quicksortn actual vary random nature test data minutes killed process hadnõt completed binary searching insertion _596748 ch09 qxd    itõs plain sorting insertion viable option data remain sorted order inserting binary insertion wins hands forming  times fewer comparisons final point note preferably array list data structure supports fast based lookup achieve desired performance inserting items rela tively slow recall array list copy data items position insertion point room small data sets overhead negligible larger data sets noticeable impact performance summary chapter learned key points binary searching divide conquer approach locating search key achieves average number comparisons approaches logn binary searching achieved efficiently recursion iteration binary searching works data structure supports fast based lookup binary insertion builds binary searching add items list maintaining sort order logn comparisons binary insertion proves efficient performing asñand arguably thanñ sorting algorithms chapter _596748 ch09 qxd    binary search trees chapter introduced binary search algorithm enables efficiently search sorted array list binary search algorithm suffers insertions deletions elements copied binary search trees hand achieve logn average search insert delete time binary search algorithm overhead storing values tree structureñwhere values linked togetherñitõs easy insert values remove deleted chapters chapter theoretical donõt work practical examples binary search trees form basis data struc tures chapter confined discussion binary search trees work practice chapters sets chapter maps chapter trees chapter youõll data structures built code chapter template chapter discusses topics characteristics binary search trees interesting binary search tree operations works ordering data affect performance asimple technique restoring balance insertion deletion test implement nonbalancing binary search tree _596748 ch10 qxd    understanding binary search trees chapter mentioned file referred directory tree formally tree set linked nodes node children parent nodes singled root node parent nodes children referred leaf nodes directory tree number directories subdirectories files trees number children common type tree binary tree called nodemay children children referred left abinary search tree binary tree restriction children left node smaller values children larger values figure  binary search tree letter root node letters pare leaf nodes child left node smaller child larger node figure  simple binary search tree properties efficient searching insertion deletion fact average search time binary search tree directly proportional height case infigure  height treeñthe longest path root node leafñis expect average search time order comparisons balanced treeñsuch figure ñthe height tree logn circumstances height tree degenerate leading worst case search time ileft smaller larger rootleaf nodesdlafkm hp226chapter _596748 ch10 qxd    minimumthe minimumof binary search tree node smallest properties binary search tree finding minimum couldnõt simpler simply follow left links starting root tree smallest minimum leftmost node tree figure  follow left links starting root node leaf node letter añthe smallest tree maximumwhereas minimum binary search tree node smallest maximumis nodewith largest finding maximum finding minimum fol low links left maximum rightmost node tree prove links starting root node figure  leaf node letter pñthe largest tree successoranodeõs successoris largest tree tree figure  successor ais successor successor finding suc cessor difficult involves distinct cases case node child successor minimum tofind successor child minimum holds forthe letter child minimum case conversely node childñas case hñyou search tree òright hand turn ó tree node left child parent tree moving left hand links left finally hand turn predecessorthe predecessor node smallest predecessor pis predecessor predecessor algorithm finding predecessor essentially inverse youõd successor involves cases case node left child maximum caseñwhereby node left childñyou work tree òleft handó turn binary search trees _596748 ch10 qxd    searchwhen searching binary search tree start root node follow links left links fol low summarized steps start root node current node search proceed step  compare search key current node keys equal search key proceed step  search key sorts lower key current node follow left link step  search key sort higher key current node follow link step search letter binary search tree figure  starting root node step compare search letter figure  figure  search starts root node follow link step leads node letter figure  idlafkm hp228chapter _596748 ch10 qxd    figure  follow link search key sorts key current node donõt match smaller follow left link step figure  figure  follow left link search key sorts key current node finally match figure  search current node step search completes searched tree values comparisons addition note match levels treeñ time tree effectively discard half valuesñjust forming binary search sorted list fact sorted list easily construct equivalent binary search tree figure  idlafkmhpidlafkmhp229binary search trees _596748 ch10 qxd    figure  sorted list depicted balanced binary search tree compare search examples chapter order parisons identical thatõs balanced binary search tree performance charac teristics sorted list insertion insertion identical searching doesnõt exist tree leaf node previous search wanted insert left link discovered nodes safely add left child figure  figure  insertion involves creating leaf node idlafkmhpjidlafkm hp4a0d1f2h3i4k5l6m7p8160257 chapter _596748 ch10 qxd    newly inserted leaf case hasnõt height tree inserting random data enables tree maintain logn height hap pens insert nonrandom data word list dictionary names telephone directory imagine happen started tree inserted fol lowing values alphabetical order values inserted leaf nodes remembering larger values children parent inserting values ascending order leads severely unbal anced tree figure  figure  unbalanced tree insertion ordered data fact data inserted order binary search tree degenerate linked list height treeñand average search timeñbecomes ordered data lost variations binary search trees perform balancing including red black trees avltrees splay trees involve fairly complex restructuring restore balance tree reason cov ered book fairly simple variation tree introduced chapter adfhiklmp231binary search trees _596748 ch10 qxd    deletiondeletion involved searching insertion essentially cases sider node deleted reflect conditions children leaf case simply remove child left case replace deleted node child children case swap node successor case case weõll discuss cases starting simplest case deleting leaf node cases assume starting tree figure  simplest case involves deleting leaf node leaf node children break link parent figure  delete tree figure  leaf nodes deleted breaking link parent simplest case involves deleting node child deleting node onlyone child splice making parent point child figure  tree deleting letter figure  nodes child spliced idlafk mhpidlafkm hp232chapter _596748 ch10 qxd    note links parent child replaced direct link land deleting node children trickier imagine delete root node tree figure  node replacement technically child nodesñd lñand maintain properties binary search tree nodes children making difficult simply splice deleted node delete node children thing successor easily choose predecessor work switch values figure  result switching notice temporarily violates properties binary search tree figure  node deleted swapped successor moved delete original node deletethe node switch values process guaranteed fall case case start node originally wanted delete children meaning child successor node child minimum leftmost node child successor leaf node chil dren child left child definition wouldnõt minimum swapped values figure  safely delete leaf node taining figure  kdlafimhp233binary search trees _596748 ch10 qxd    figure  successor node deleted deletion unbalance binary search tree leading degradation performance inserting ordered data tree unbalanced deleting data order unbalanced figure  deleting values tree figure  figure  unbalanced tree deletion ordered data values listed left hand tree starting root lopsided tree event whichever deletion case required deletion tree remains balanced time spent finding node delete finding successor search insert time delete ilkmpkdlafimhp234chapter _596748 ch10 qxd    order traversal order traversal suggests visits values binary search tree sorted order printing processing values order tree figure  order traversal visit values order simple ways perform order traversal recursively iteratively perform recur sive order traversal starting root node traverse left subtree node visit node traverse subtree perform iterative order traversal binary search tree start minimum tree visit successor node pre order traversal pre order traversal visits root node subtrees apre order traversal tree figure  produce sequence values order traversal pre order traversal easily defined recursively perform pre order traversal starting root node visit node traverse left subtree traverse subtree order traversal iterative form involved requires explicit stack chapter place implicit processor stack making recursive calls post order traversal post order traversal visits root node aftereach subtrees apost order traversal tree figure  visit nodes order perform post order traversal starting root node traverse left subtree traverse subtree visit node pre order traversal iterative form involved requires stack binary search trees _596748 ch10 qxd    balancingthe order data inserted deleted binary search trees performance inserting deleting ordered data tree unbalanced worst case degenerate simple linked list mentioned balancingas ofrestoring desired characteristics tree implementation scope book understand balancing algorithms work ifwe provide coded examples short summary tree avl difficult tasks maintaining balanced tree detecting imbalance place imagine tree hundreds thousands nodes performing deletion insertion detect imbalance traversing entire tree russian mathematicians adelõson velõskii landis avl realized simple binary search tree balanced track height subtree siblings differ height tree unbalanced figure  tree rebalancing notice root nodeõs children differ height figure  difference height children root node greater imbalance detected correct solution involves rotating nodes remove imbalance perform rebalancing working tree inserted deleted node root rotating nodes anytime node inserted deleted avltree types rotation depending nature imbalance single rotation double rotation left version table  determine single double rotation required ilkm chapter _596748 ch10 qxd    table  determining rotation number inbalancedchild balancedchild left heavychild heavy left heavyonceoncetwice heavyoncetwiceonce figure  root node heavy child heavy table  perform rotationñto left demote pro mote tree figure  figure  avl height property restored rotating node left tree figure  rotations requiredñthe root node heavy child left heavy happen inserted figure  tree requiring rotations ikl lkim  binary search trees _596748 ch10 qxd    rotate lright rotate lleft figure  figure  rotation moves child node rotates unbalanced node left avltrees guaranteed perfectly balanced exhibit excellent performance char acteristics fact nodes perfectly balanced tree require log21000000 comparisons avltree requires log  comparisons certainlymuch  comparisons required worst case binary search tree covered variation balancing binary trees red black tree red black trees introduction algorithms cormen testing implementing binary search tree itõs finally time code youõre start developing tests thatõs write implementation code implementation create main classes nodeand binarysearchtree node suggests model nodes tree binarysearchtreewill provide wrapper root node search delete insert code binarysearchtreeclass doesnõt nodes write node tests youõll write node class ikkill chapter _596748 ch10 qxd    outtesting node class create node tests package wrox algorithms bstrees import junit framework testcase public class nodetest extends testcase private node _a private node _d private node _f private node _h private node _i private node _k private node _l private node _m private node _p protected void setup throws exception super setup _a node _h node _k node _p node _f node null _h _m node null _p _d node _a _f _l node _k _m _i node _d _l public void testminimum assertsame _a _a minimum assertsame _a _d minimum assertsame _f _f minimum assertsame _h _h minimum assertsame _a _i minimum assertsame _k _k minimum assertsame _k _l minimum assertsame _m _m minimum assertsame _p _p minimum public void testmaximum assertsame _a _a maximum assertsame _h _d maximum assertsame _h _f maximum assertsame _h _h maximum assertsame _p _i maximum binary search trees _596748 ch10 qxd    assertsame _k _k maximum assertsame _p _l maximum assertsame _p _m maximum assertsame _p _p maximum public void testsuccessor assertsame _d _a successor assertsame _f _d successor assertsame _h _f successor assertsame _i _h successor assertsame _k _i successor assertsame _l _k successor assertsame _m _l successor assertsame _p _m successor assertnull _p successor public void testpredecessor assertnull _a predecessor assertsame _a _d predecessor assertsame _d _f predecessor assertsame _f _h predecessor assertsame _h _i predecessor assertsame _i _k predecessor assertsame _k _l predecessor assertsame _l _m predecessor assertsame _m _p predecessor public void testissmaller asserttrue _a issmaller asserttrue _d issmaller assertfalse _f issmaller assertfalse _h issmaller assertfalse _i issmaller asserttrue _k issmaller assertfalse _l issmaller assertfalse _m issmaller assertfalse _p issmaller public void testislarger assertfalse _a islarger assertfalse _d islarger asserttrue _f islarger asserttrue _h islarger assertfalse _i islarger assertfalse _k islarger asserttrue _l islarger asserttrue _m islarger asserttrue _p islarger chapter _596748 ch10 qxd    public void testsize assertequals _a size assertequals _d size assertequals _f size assertequals _h size assertequals _i size assertequals _k size assertequals _l size assertequals _m size assertequals _p size public void testequals node node node node node node node node node node null node node null node node node node node node assertequals _a assertequals _d assertequals _f assertequals _h assertequals _i assertequals _k assertequals _l assertequals _m assertequals _p assertfalse _i equals null assertfalse _f equals _d works tests start node structure identical figure  good time refresh memory nodetestclass defines instance variablesñone node figure ñand initializes setup test cases nodes leaf nodes examples remaining nodes left children passed constructor parameters package wrox algorithms bstrees import junit framework testcase public class nodetest extends testcase private node _a private node _d binary search trees _596748 ch10 qxd    private node _f private node _h private node _i private node _k private node _l private node _m private node _p protected void setup throws exception super setup _a node _h node _k node _p node _f node null _h _m node null _p _d node _a _f _l node _k _m _i node _d _l design calls minimum maximum methods nodeclass enables minimum maximum tree querying root node testing easier methods testminimum testmaximimum pretty straightforward simply ensure node tree returns correct minimum maximum public void testminimum assertsame _a _a minimum assertsame _a _d minimum assertsame _f _f minimum assertsame _h _h minimum assertsame _a _i minimum assertsame _k _k minimum assertsame _k _l minimum assertsame _m _m minimum assertsame _p _p minimum public void testmaximum assertsame _a _a maximum assertsame _h _d maximum assertsame _h _f maximum assertsame _h _h maximum assertsame _p _i maximum assertsame _k _k maximum assertsame _p _l maximum assertsame _p _m maximum assertsame _p _p maximum chapter _596748 ch10 qxd    successor predecessor methods node havethem utility methods binarysearchtree method testsuccessor confirms successor earlier examples notice predecessor succes sor expect result nullin cases public void testsuccessor assertsame _d _a successor assertsame _f _d successor assertsame _h _f successor assertsame _i _h successor assertsame _k _i successor assertsame _l _k successor assertsame _m _l successor assertsame _p _m successor assertnull _p successor public void testpredecessor assertnull _a predecessor assertsame _a _d predecessor assertsame _d _f predecessor assertsame _f _h predecessor assertsame _h _i predecessor assertsame _i _k predecessor assertsame _k _l predecessor assertsame _l _m predecessor assertsame _m _p predecessor create pair testsñ testissmaller testislarger ñfor methods mentioned handy anode considered smaller child left child parent conversely node considered larger child itõs child parent public void testissmaller asserttrue _a issmaller asserttrue _d issmaller assertfalse _f issmaller assertfalse _h issmaller assertfalse _i issmaller asserttrue _k issmaller assertfalse _l issmaller assertfalse _m issmaller assertfalse _p issmaller public void testislarger assertfalse _a islarger assertfalse _d islarger asserttrue _f islarger asserttrue _h islarger assertfalse _i islarger assertfalse _k islarger binary search trees _596748 ch10 qxd    asserttrue _l islarger asserttrue _m islarger asserttrue _p islarger finally create tests equals equals method comestime test binarysearchtreeclass enables compare structure produced insert ing deleting nodes expected result implementation start current node compare values left children leaf nodes testequals construct replica node structure compare instance variables local variable counterparts check boundary conditions makesure havenõt hard coded equals return true public void testequals node node node node node node node node node node null node node null node node node node node node assertequals _a assertequals _d assertequals _f assertequals _h assertequals _i assertequals _k assertequals _l assertequals _m assertequals _p assertfalse _i equals null assertfalse _f equals _d tests place create node class outimplementing node class create node class package wrox algorithms bstrees public class node implements cloneable private object _value private node _parent private node _smaller private node _larger chapter _596748 ch10 qxd    public node object null null public node object node smaller node larger setvalue setsmaller smaller setlarger larger smaller null smaller setparent larger null larger setparent public object getvalue return _value public void setvalue object assert null null _value public node getparent return _parent public void setparent node parent _parent parent public node getsmaller return _smaller public void setsmaller node smaller assert smaller getlarger smaller larger _smaller smaller public node getlarger return _larger public void setlarger node larger assert larger getsmaller larger smaller _larger larger binary search trees _596748 ch10 qxd    public boolean issmaller return getparent null getparent getsmaller public boolean islarger return getparent null getparent getlarger public node minimum node node node getsmaller null node node getsmaller return node public node maximum node node node getlarger null node node getlarger return node public node successor getlarger null return getlarger minimum node node node islarger node node getparent return node getparent public node predecessor getsmaller null return getsmaller maximum node node node issmaller node node getparent chapter _596748 ch10 qxd    return node getparent public int size return size public boolean equals object object object return true object null object getclass getclass return false node node object return getvalue equals getvalue equalssmaller getsmaller equalslarger getlarger private int size node node node null return return size node getsmaller size node getlarger private boolean equalssmaller node return getsmaller null null getsmaller null getsmaller equals private boolean equalslarger node return getlarger null null getlarger null getlarger equals works node holds reference parent smaller left child larger child package wrox algorithms bstrees public class node private object _value private node _parent private node _smaller private node _larger binary search trees _596748 ch10 qxd    youõve provided constructors constructor creating leaf nodesñthose childrenñso argument public node object null null constructor convenience enabling create nodes children notice nullchild constructor conveniently sets childõs ent recall tests trivial wire nodes tree structure public node object node smaller node larger setvalue setsmaller smaller setlarger larger smaller null smaller setparent larger null larger setparent constructed access nodeõs parent children create standard getters setters strange youõve extra assertionsñfor checking havenõt set children node public object getvalue return _value public void setvalue object assert null null _value public node getparent return _parent public void setparent node parent _parent parent public node getsmaller return _smaller public void setsmaller node smaller assert smaller getlarger smaller larger _smaller smaller chapter _596748 ch10 qxd    public node getlarger return _larger public void setlarger node larger assert larger getsmaller larger smaller _larger larger follow convenience methods determining characteristics node methods issmaller islarger return trueonly node smaller larger child parent public boolean issmaller return isroot getparent getsmaller public boolean islarger return isroot getparent getlarger finding minimum maximum complex recall minimum node smallest child maximum largest children notice code maximum identical minimum minimum calls getsmaller maximum calls getlarger public node minimum node node node getsmaller null node node getsmaller return node public node maximum node node node getlarger null node node getlarger return node finding successor predecessor node bit involved recall successor node minimum largest childñif oneñor node encounter òright handó turn moving tree binary search trees _596748 ch10 qxd    successor node larger child minimum start moving tree òright handó turn checking current node larger parentõs children larger parent moving left tree essence moving tree node smaller left child parent making òright handó turn parentñprecisely notice case minimum maximum successor predecessor mirror images successor takes minimum predecessor takes themaximum successor calls islarger predecessor calls issmaller public node successor getlarger null return getlarger minimum node node node islarger node node getparent return node getparent public node predecessor getsmaller null return getsmaller maximum node node node issmaller node node getparent return node getparent finally equals method nodeõs complex fairly straightforward extensively check structure trees created binarysearchtreeclass boilerplate code public equals method compares aspects node equality smaller child larger child comparing values simple null simply delegating valueõs equals method sufficient public boolean equals object object object return true chapter _596748 ch10 qxd    object null object getclass getclass return false node node object return getvalue equals getvalue equalssmaller getsmaller equalslarger getlarger comparing child nodes involved children null check childrenõs children children leaf nodes created helper methods equalssmaller equalslarger meth ods compare children current node child node equalssmaller compares current nodeõs smaller child smaller child node children null nodes considered equal child null canõt beequal current node node smaller child recursively equals continue checking tree private boolean equalssmaller node return getsmaller null null getsmaller null getsmaller equals private boolean equalslarger node return getlarger null null getlarger null getlarger equals thatõs node class create tests preparation final binary search tree implementation outtesting binary search tree create test class package wrox algorithms bstrees import wrox algorithms sorting naturalcomparator import junit framework testcase public class binarysearchtreetest extends testcase private node _a private node _d private node _f private node _h private node _i private node _k private node _l private node _m private node _p binary search trees _596748 ch10 qxd    private node _root private binarysearchtree _tree protected void setup throws exception super setup _a node _h node _k node _p node _f node null _h _m node null _p _d node _a _f _l node _k _m _i node _d _l _root _i _tree binarysearchtree naturalcomparator instance _tree insert _i getvalue _tree insert _d getvalue _tree insert _l getvalue _tree insert _a getvalue _tree insert _f getvalue _tree insert _k getvalue _tree insert _m getvalue _tree insert _h getvalue _tree insert _p getvalue public void testinsert assertequals _root _tree getroot public void testsearch assertequals _a _tree search _a getvalue assertequals _d _tree search _d getvalue assertequals _f _tree search _f getvalue assertequals _h _tree search _h getvalue assertequals _i _tree search _i getvalue assertequals _k _tree search _k getvalue assertequals _l _tree search _l getvalue assertequals _m _tree search _m getvalue assertequals _p _tree search _p getvalue assertnull _tree search unknown public void testdeleteleafnode node deleted _tree delete _h getvalue assertnotnull deleted assertequals _h getvalue deleted getvalue _f setlarger null assertequals _root _tree getroot chapter _596748 ch10 qxd    public void testdeletenodewithonechild node deleted _tree delete _m getvalue assertnotnull deleted assertequals _m getvalue deleted getvalue _l setlarger _p assertequals _root _tree getroot public void testdeletenodewithtwochildren node deleted _tree delete _i getvalue assertnotnull deleted assertequals _i getvalue deleted getvalue _i setvalue _k getvalue _l setsmaller null assertequals _root _tree getroot public void testdeleterootnodeuntiltreeisempty _tree getroot null object key _tree getroot getvalue node deleted _tree delete key assertnotnull deleted assertequals key deleted getvalue works tests binarysearchtreeclass manipulate tree figure  node tests compare tree hand crafted match code works expected binarysearchtreetestclass defines nodes comparison constructs binarysearchtreewith values nodes notice inserted values avery alphabetical order remember tree performs balancing insert values alphabetical order degenerate treeñone linked list refer figure  insert values order designed pro duce balanced tree figure  works youõve inserted values pre order order insertion parent node subtree tree children package wrox algorithms bstrees import wrox algorithms sorting naturalcomparator import junit framework testcase public class binarysearchtreetest extends testcase private node _a private node _d binary search trees _596748 ch10 qxd    private node _f private node _h private node _i private node _k private node _l private node _m private node _p private node _root private binarysearchtree _tree protected void setup throws exception super setup _a node _h node _k node _p node _f node null _h _m node null _p _d node _a _f _l node _k _m _i node _d _l _root _i _tree binarysearchtree naturalcomparator instance _tree insert _i getvalue _tree insert _d getvalue _tree insert _l getvalue _tree insert _a getvalue _tree insert _f getvalue _tree insert _k getvalue _tree insert _m getvalue _tree insert _h getvalue _tree insert _p getvalue set initial state thing ensure tree built youõre comparison testinsert assume method getroot binarysearchtreethat enables toget root node advantage equals method nodeto check struc tural equality public void testinsert assertequals _root _tree getroot tree state tested insert process test remaining behavior binarysearchtreeclass starting search chapter _596748 ch10 qxd    expect search return node nullif testsearch perform lookup values comparing result ing node node handmade tree notice check ensure unknown null public void testsearch assertequals _a _tree search _a getvalue assertequals _d _tree search _d getvalue assertequals _f _tree search _f getvalue assertequals _h _tree search _h getvalue assertequals _i _tree search _i getvalue assertequals _k _tree search _k getvalue assertequals _l _tree search _l getvalue assertequals _m _tree search _m getvalue assertequals _p _tree search _p getvalue assertnull _tree search unknown method tested delete number scenarios test leaf nodes nodes child children starting simple deletion leaf node delete asshown figure  method testdeleteleafnode deletes tree records deleted node ensure node returned deleted node finally test node structure modified parent mñthe fñno longer larger child expect delete algorithm compare test node structure root tree equal public void testdeleteleafnode node deleted _tree delete _h getvalue assertnotnull deleted assertequals _h getvalue deleted getvalue _f setlarger null assertequals _root _tree getroot deleted node childñthe ômõ figure  time testdeletenodewithonechild deletes ômõ tree verifying return modify test node structure resembles expected structure tree compared equality note ôpõ larger child ôlõ splicing ômõ tree public void testdeletenodewithonechild node deleted _tree delete _m getvalue assertnotnull deleted assertequals _m getvalue deleted getvalue _l setlarger _p assertequals _root _tree getroot binary search trees _596748 ch10 qxd    lastly deleting node childrenñthe root node ôiõñas figure  figure  deleted ôiõ tree testdeletenodewithtwochildren updates theexpected structure compares root tree public void testdeletenodewithtwochildren node deleted _tree delete _i getvalue assertnotnull deleted assertequals _i getvalue deleted getvalue _i setvalue _k getvalue _l setsmaller null assertequals _root _tree getroot confident behavior tree tested implement binary search tree class outimplementing binary search tree create binarysearchtreeclass package wrox algorithms bstrees import wrox algorithms sorting comparator public class binarysearchtree private final comparator _comparator private node _root public binarysearchtree comparator comparator assert comparator null comparator null _comparator comparator public node search object assert null null node node _root node null int cmp _comparator compare node getvalue cmp break node cmp node getsmaller node getlarger return node chapter _596748 ch10 qxd    public node insert object node parent null node node _root int cmp node null parent node cmp _comparator compare node getvalue node cmp node getsmaller node getlarger node inserted node inserted setparent parent parent null _root inserted cmp parent setsmaller inserted parent setlarger inserted return inserted public node delete object node node search node null return null node deleted node getsmaller null node getlarger null node successor node assert deleted null deleted null node replacement deleted getsmaller null deleted getsmaller deleted getlarger replacement null replacement setparent deleted getparent deleted _root _root replacement deleted issmaller deleted getparent setsmaller replacement deleted getparent setlarger replacement deleted node object deletedvalue node getvalue node setvalue deleted getvalue deleted setvalue deletedvalue binary search trees _596748 ch10 qxd    return deleted public node getroot return _root works binarysearchtreeclass holds comparator comparing values root node nullif tree method providing access root node tests notice havenõt implemented interface extended base class binary search tree implementation intended form chapters  attend package wrox algorithms bstrees import wrox algorithms sorting comparator public class binarysearchtree private final comparator _comparator private node _root public binarysearchtree comparator comparator assert comparator null comparator null _comparator comparator public node getroot return _root simplest method implemented search method tree returns node nullif wasnõt starts root node continues finds match runs nodes pass whileloop search compared held current node values equal youõve node youõre exit loop follow smaller larger link public node search object assert null null node node _root node null int cmp _comparator compare node getvalue cmp break chapter _596748 ch10 qxd    node cmp node getsmaller node getlarger return node half insert simply searches tree leaf node attached smaller larger link whileloopterminates variable parentwill null case tree set node root node hold parent node determined parent node set smaller larger child appropriateñthe variable cmpstill result comparison notice whileloop insert search code insearch exit loop matching cmp insert treat equal smaller easily treated larger happen unbalanced tree public node insert object node parent null node node _root int cmp node null parent node cmp _comparator compare node getvalue node cmp node getsmaller node getlarger node inserted node inserted setparent parent parent null _root inserted cmp parent setsmaller inserted parent setlarger inserted return inserted delete imagine deleting binary search tree complicated searching insertion number situa tions itõs difficult combine cases fairly straightforward piece code delete method starts search node removed isnõt node null return bit work binary search trees _596748 ch10 qxd    node delete determine node removed successor remember node child removed straight conversely node children swap successor remove node decided node actuallyremove step replacement point previous step node removed child simply child exists parent deleted node chosen replacement link parent deleted node root node replacement root set replacement smaller larger child finally bit cleanup node removed tree originally foundñdue swapping successorñyou swap values returning deleted node caller public node delete object node node search node null return null node deleted node getsmaller null node getlarger null node successor node assert deleted null deleted null node replacement deleted getsmaller null deleted getsmaller deleted getlarger replacement null replacement setparent deleted getparent deleted _root _root replacement deleted issmaller deleted getparent setsmaller replacement deleted getparent setlarger replacement deleted node object deletedvalue node getvalue node setvalue deleted getvalue deleted setvalue deletedvalue return deleted chapter _596748 ch10 qxd    assessing binary search tree performance weõve talked performance binary search trees write code demonstrates characteristics binary search trees create tests measure number comparisons performed inserting data compare inserting randomly generated data inserting ordered data outimplementing running performance tests create performance test class package wrox algorithms bstrees import wrox algorithms lists arraylist import wrox algorithms lists list import wrox algorithms sorting callcountingcomparator import wrox algorithms sorting naturalcomparator import junit framework testcase public class binarysearchtreecallcountingtest extends testcase private static final int test_size private callcountingcomparator _comparator private binarysearchtree _tree protected void setup throws exception super setup _comparator callcountingcomparator naturalcomparator instance _tree binarysearchtree _comparator public void testrandominsertion int test_size _tree insert integer int math random test_size reportcalls public void testinorderinsertion int test_size _tree insert integer reportcalls public void testpreorderinsertion list list arraylist test_size int test_size list add integer binary search trees _596748 ch10 qxd    preorderinsert list list size reportcalls private void preorderinsert list list int lowerindex int upperindex lowerindex upperindex return int lowerindex upperindex lowerindex _tree insert list preorderinsert list lowerindex preorderinsert list upperindex private void reportcalls println getname _comparator getcallcount calls works convenience wrapped binarysearchtreecallcountingtestclass standard junit test class performance tests chapter binary searching tests arenõt òrealó testsñthey assertionsñbut familiarity junit compelling reason approach class defines binary tree insert values comparator comparing values constant defines number valuesñ test_sizeñto insert method reportcalls print number calls comparator form test calls package wrox algorithms bstrees import wrox algorithms sorting callcountingcomparator import wrox algorithms sorting naturalcomparator import junit framework testcase public class binarysearchtreecallcountingtest extends testcase private static final int test_size private callcountingcomparator _comparator private binarysearchtree _tree protected void setup throws exception super setup _comparator callcountingcomparator naturalcomparator instance _tree binarysearchtree _comparator chapter _596748 ch10 qxd    private void reportcalls println getname _comparator getcallcount calls testrandominsert insert test_sizerandomly generated numbers building youimagine balanced tree public void testrandominsertion int test_size _tree insert integer int math random test_size reportcalls testinorderinsertion insert order values and test_sizeto pro duce unbalanced tree public void testinorderinsertion int test_size _tree insert integer reportcalls tests depending environment output testrandominsertion callstestinorderinsertion callstable  summarizes whatõs table  performance comparison  inserts binary search tree insertion typecomparisons random insertion11 order insertion499 actual vary random nature test data insertion performs data unorderedñin fact table  average time perform random insertion   comparisons logn order   binary search trees _596748 ch10 qxd    summary chapter provided explanation binary search trees work solid foundation understanding practical examples chapters sets chapter maps chapter chapter demonstrated binary search trees hold data refer left child left children smaller parent children larger parent trees balanced unbalanced binary search trees average search time balanced trees height logn worst case unbalanced trees height inserting deleting random data generally produces balanced trees inserting deleting ordered data leads unbalanced trees asimple technique considers relative height child nodes restore tree balanced state exercises1 write recursive form minimum write recursive form search write method takes root node recursively prints values tree order write method takes root node iteratively prints values tree order write method takes root node recursively prints values tree pre order write method takes root node recursively prints values tree post order write method inserts values sorted list binary search tree maintain balance require explicit balancing add method nodeto recursively calculate size add method nodeto recursively calculate height chapter _596748 ch10 qxd    hashinghashing technique promises achieve data lookup doesnõt onlyone comparison number comparisons remain matter large data set compare search time simple linked lists logn binary search trees hashing starts attractive chapter discusses understanding hashingworking hash functions assessing performancecomparing understanding hashing realize chances good concepts hashing time walk bookstore head straight computer book youõve kind hashing algorithm music artist doubt straight cds artists letter artistõssurname processes involve property thing forña book category artistõs nameñand narrow search case book computer book head straight case artistõs hashing hash function hash functiontakes valueña string object num ber onñand produces hash integer numeric thishash locate position hash tableña special kind array idea hashing works produce hash strings proceeds hash store locate strings _596748 ch11 qxd    simplest string hashing techniques involves adding letters resultinghash position hash table storing string code theresults hashing strings òelvis ó òmadonna ó òsting ó assuming letters alphabet assigned values for athrough for   m    s   looking generated values string òelvisó array atposition òmadonnaó position òstingó position notice strings arenõt stored order positions random fact hashing referred random izing covered data structures algorithms relied kind ordering achieve adequate performance hash function appears working satisfactorily easily store values unique locations easily check existence major problems approach generated values positions array big accommodate largest position filled  posi tions availableñthat ñyou imagine values  insteadñyouõd slots sim plistic hashing scheme pretty inefficient terms storage solve problem modify hash function produce values range previous size hash table restricted positions hash function modified original result modulusñ remainder divisionñto remainder division     m     s    now addresses fall range  stored hash table size good chapter _596748 ch11 qxd    problem hash function suffers high rate collisionsñdifferent values hashing address illustrate meant collision code hashes string òlivesó notice result address gener ated òelvisó collides existing    youõve reduce number collisions increase address space increas ing address space reduce likelihood collision time increasing wasted memory hashing algorithms trade efficiencies space time reduce collisions selective choice hash table size turns prime numbers nonprime numbers choosing prime number close desired size reduce clustering number collisions works scope book ideally perfect hashing algorithmñone produces collisions finding perfect hashing algorithm harder small sets input data good hashing algo rithm likelihood finding produces collisions small abetter solution reduce number collisions manageable deal hash function discussed poor collisions onething order letters difference òelvisó òlivesó hash address fact anagramsñwords letters orderñwill hash algorithm considers order letters fairly simple effective hashing algorithm stringclass thejdk algorithm grounded sound mathematics proof scope book actual implementation pretty easy understand good hashing algorithms jdk string class based sound mathemat ics algorithm cyclic redundancy check crc applications compress transmit files networks crc ensure integrity data crc algorithm takes stream data computes integer hash properties crc calculation ordering data strings òelvisó òlivesó guaranteed hash values òalmostó standard crc isnõt perfect nonzero small chance collision idea add letter time working multiplied adding letter equation whatõs involved calculating hash string òelvisó   s267hashing14_596748 ch11 qxd    applying algorithm strings demonstrated code elvis      madonna        sting      lives     the values wildly note òelvisó òlivesó longer collide addition note large values arenõt hash table   slots hold strings remainder dividing hash hash table size modulus ñin case youõll nearest prime number ñto generate final address code sample elvis  madonna  sting  lives  the hash function performs markedly sample data longer collisions values safely stored individual positions point hash table collisions occur fills collision algorithm isnõt perfect imagine add fred existing hash table hash thisstring calculated  collides elvis option issimply increase decrease size hash table recompute addresses size code hash values resizing hash table store string fred elvis  madonna  sting  chapter _596748 ch11 qxd    lives  fred  now strings unique addresses stored retrieved substantial price paid maintain uniqueness addresses preceding size hash table increased accommodate hash table space strings stored thatõs utilization   impressive problem worse strings add larger hash table order prevent collisions wasted space resizing partially reduce number collisions occur technique required manage problem solution problem collision resolution linear probing linear probing simple technique detecting collision searches linearly slot figure  steps needed add string fred figure  linear probing free slot string òfredó madonnastinglives456789100123madonnaelvis456789100123madonnaelvislives45678910elvislivesfred269hashing14_596748 ch11 qxd    search starts position ñthe original hash caused collision position occupied search continues occupied eventually finds free slot position search reaches table finding free slot giv ing wraps continues start table figure  search involved adding string tim hash assuming youõve mary hash figure  adding string òmaryó òtimó search wrap start array original position determined hash filled position reaching table search continues start case finds slot place string event table fullñthat free slotsñresizing required point linear search work fine madonnastinglives456789100123madonnaelvis456789100123madonnaelvislives45678910elvislivesfredmarymaryfredtimmaryfred270chapter _596748 ch11 qxd    linear probing simple implement works fairly sparsely populated hash tablesñthat number free slots large compared number filled onesñbut pop ulation density increases searching performance rapidly degrade ñno brute force approach approach collision resolution involves bucketsto store item position bucket holds items hash figure  hash table size populated strings figure  bucket holds items sharing hash strings lynn paula joshua merle hash held bucket buckets enables hash table store items simple linear probing andrewkerrisaratalialynnroger45678910elvismarytimsamsueelinpaulajoshuamerleaaron271hashing14_596748 ch11 qxd    flexibility isnõt free hash table fills size bucket increases time required item generally markedly linear probing point cost searching buckets costly solution increase number buckets good hash function items redistributed rel atively evenly greater number buckets leading decrease size individ ual bucket challenge knowing resize decide resize hash table monitor load factorñthe ratio stored values buckets idea set threshold load factor reached trigger resize case figure  total number buckets number values stored load  or145 notional capacity result buckets large itõs good time resize balance space performance efficiency making load factor low leads lot wasted space high size buckets increases collisions aload factor  capacity fairly good trade space time working hashing turn concepts covered working code start defining unit tests hash table implementationsñlinear probing bucketsñ finish tests compare relative performance tests store strings hash function works strings thankfully language defines methodñ hashcode ñthat class implement jdk implementation hashcode stringclass closely followsthe provided chapter meaning donõt create itõs worthwhile implementing implementation hashcode strings public int hashcode int hash int length hash hash charat return hash code starts initializing hash adds character making multiply result time outcreating generic hash table interface order test linear probing bucketing implementations create interface defines methods common chapter _596748 ch11 qxd    package wrox algorithms hashing public interface hashtable public void add object public boolean object public int size works hashtableinterface defines methods add size implement create linear probing bucketing version methods familiar methods defined listinterface difference lists duplicates hash tables donõt calling add multiple times outcreating tests developing actual hash table implementations write test cases order ensure code write functions correctly advantage fact outward behavior hash table identical create generic suite tests extended package wrox algorithms hashing import junit framework testcase public abstract class abstracthashtabletestcase extends testcase private static final int test_size private hashtable _hashtable protected abstract hashtable createtable int capacity protected void setup throws exception super setup _hashtable createtable test_size int test_size _hashtable add string valueof public void testcontains int test_size asserttrue _hashtable string valueof public void testdoesntcontain int test_size assertfalse _hashtable string valueof test_size hashing14_596748 ch11 qxd    public void testaddingthesamevaluesdoesntchangethesize assertequals test_size _hashtable size int test_size _hashtable add string valueof assertequals test_size _hashtable size works abstracthashtabletestcaseclass defines single variable holding hash table instancecurrently test initialized setup method calling abstract methodcreatetable createtable method implemented subclasses return instance specific hashtableimplementation notice setup method adds data thehash table integers directly numbers  likelyhash position underlying table eliminating chance collisions occurring ideal doesnõt reflect reality numbers verted strings order exercise complex hash functionñnamely hashcode methoddefined stringclass public abstract class abstracthashtabletestcase extends testcase private static final int test_size private hashtable _hashtable protected abstract hashtable createtable int capacity protected void setup throws exception super setup _hashtable createtable test_size int test_size _hashtable add string valueof number strings hash table setup thing check thatcontainscould values useless store ability public void testcontains int test_size asserttrue _hashtable string valueof chapter _596748 ch11 qxd    test checked values donõt exist arenõt mistake public void testdoesntcontain int test_size assertfalse _hashtable string valueof test_size finally adding doesnõt result hash table grow ing size public void testaddingthesamevaluesdoesntchangethesize assertequals test_size _hashtable size int test_size _hashtable add string valueof assertequals test_size _hashtable size size checked addition duplicate values ensure size remains constant linear probingin create hash table linear probing nice thing linear prob ing implementation simple easy understand outtesting implementing hash table linear probing start creating test class package wrox algorithms hashing public class linearprobinghashtabletest extends abstracthashtabletestcase protected hashtable createtable int capacity return linearprobinghashtable capacity follow hash table implementation package wrox algorithms hashing public class linearprobinghashtable implements hashtable private object _values private int _size public linearprobinghashtable int initialcapacity assert initialcapacity initialcapacity _values object initialcapacity hashing14_596748 ch11 qxd    public void add object ensurecapacityforonemore int indexfor _values null _values _size public boolean object return indexof public int size return _size private int indexfor object int start startingindexfor int indexfor start _values length indexfor start assert free slots return private int indexfor object int start int assert null null int start _values null equals _values return return private int indexof object int start startingindexfor int indexof start _values length indexof start return chapter _596748 ch11 qxd    private int indexof object int start int assert null null int start equals _values return return private int startingindexfor object assert null null return math abs hashcode _values length private void ensurecapacityforonemore size _values length resize private void resize linearprobinghashtable copy linearprobinghashtable _values length int _values length _values null copy add _values _values copy _values works actual test cases defined abstracthashtabletestcase needed dowas extend implement createtable method return instance defined linearprobinghashtable class executed test cases base class included hash table linear probing package wrox algorithms hashing public class linearprobinghashtabletest extends abstracthashtabletestcase protected hashtable createtable int capacity return linearprobinghashtable capacity hashing14_596748 ch11 qxd    implementation code linear probing straightforward reflected class definition linearprobinghashtableclass array holding values single constructor maximum number values initially storedñthe capacity package wrox algorithms hashing public class linearprobinghashtable implements hashtable private object _values public linearprobinghashtable int initialcapacity assert initialcapacity initialcapacity _values object initialcapacity speaking capacity hash table resize times accommodate values method ensurecapacityforonemore imagine ensures hash table hold resize required private void ensurecapacityforonemore size _values length resize resize method neat effective technique increasing number slots temporary table created capacity values array table replace existing array private void resize linearprobinghashtable copy linearprobinghashtable _values length int _values length _values null copy add _values _values copy _values startingindexfor method central operation hash table method takes avalue returns array stored hash code defined itselfñall objects define hashcode methodñand takes remainder chapter _596748 ch11 qxd    dividing capacity table ensures falls bounds array values private int startingindexfor object assert null null return math abs hashcode _values length indexfor methods work slot method searches ònaturaló starting point array slot canõt search start array initial starting point private int indexfor object int start startingindexfor int indexfor start _values length indexfor start assert free slots return method performs actual search bounds method closely actual check notice slot chosen _values null equals _values point allowing stored occurrence private int indexfor object int start int assert null null int start _values null equals _values return return implementing add method simple ensures room storing position public void add object ensurecapacityforonemore _values indexfor indexof methods work indexfor methods slot whicha hashing14_596748 ch11 qxd    method coordinates search position calculated startindexfor search attempted lower portion array matching position returned is exists private int indexof object int start startingindexfor int indexof start _values length indexof start return method performs brute force search arrayñconstrained start positionsñin search private int indexof object int start int assert null null int start equals _values return return implementing liner public boolean object return indexof method required hashtableinterface size simply iterates thearray incrementing size time exercise tracking size calculating public int size int size int _values length _values null size return size chapter _596748 ch11 qxd    bucketing develop hash table buckets store values start tests moving implementation outtesting implementing hash table bucketing start creating test class package wrox algorithms hashing public class bucketinghashtabletest extends abstracthashtabletestcase protected hashtable createtable int capacity return bucketinghashtable capacity f add implementation class package wrox algorithms hashing import wrox algorithms iteration iterator import wrox algorithms lists linkedlist import wrox algorithms lists list public class bucketinghashtable implements hashtable private final float _loadfactor private list _buckets private int _size public bucketinghashtable int initialcapacity float loadfactor assert initialcapacity initialcapacity assert loadfactor loadfactor _loadfactor loadfactor _buckets list initialcapacity public void add object list bucket bucketfor bucket bucket add _size maintainload public boolean object list bucket _buckets bucketindexfor return bucket null bucket hashing14_596748 ch11 qxd    public int size return _size private list bucketfor object int bucketindex bucketindexfor list bucket _buckets bucketindex bucket null bucket linkedlist _buckets bucketindex bucket return bucket private int bucketindexfor object assert null null return math abs hashcode _buckets length private void maintainload loadfactorexceeded resize private boolean loadfactorexceeded return size _buckets length _loadfactor private void resize bucketinghashtable copy bucketinghashtable _buckets length _loadfactor int _buckets length _buckets null copy addall _buckets iterator _buckets copy _buckets private void addall iterator values assert values null values null values values isdone values add values current chapter _596748 ch11 qxd    works tests defined abstracthashtabletestcase time implementingcreatetable return instance bucketinghashtable notice extra constructor parameterñ f load factor case specifies hash table increase size anytime number values stored reaches number buckets package wrox algorithms hashing public class bucketinghashtabletest extends abstracthashtabletestcase protected hashtable createtable int capacity return bucketinghashtable capacity f bucketing complex linear probing implementation class requires explanation bucketinghashtableclass records load factor array buckets noticed òunderstanding hashingó buckets looked lot linkedlists thatõs youõve buckets number buckets useñ initialcapacityñis construction time desired load factor package wrox algorithms hashing import wrox algorithms iteration iterator import wrox algorithms lists linkedlist import wrox algorithms lists list public class bucketinghashtable implements hashtable private final float _loadfactor private list _buckets public bucketinghashtable int initialcapacity float loadfactor assert initialcapacity initialcapacity assert loadfactor loadfactor _loadfactor loadfactor _buckets list initialcapacity method maintainload simply checks current load desired load exceeded resize spread values larger number buckets resize methodworks method linearprobinghashtable anew hash table created values bucket array replace existing time resize performed capacity doubles choose trade space time smaller increment resize required larger increment wasted space hashing14_596748 ch11 qxd    private void maintainload loadfactorexceeded resize private boolean loadfactorexceeded return size _buckets length _loadfactor private void resize bucketinghashtable copy bucketinghashtable _buckets length _loadfactor int _buckets length _buckets null copy addall _buckets iterator _buckets copy _buckets private void addall iterator iterator assert iterator null iterator null iterator iterator isdone iterator add iterator current method bucketindexfor determines bucket stored linearprobinghashtable hashcode method called remainder dividing number buckets ensures falls bounds bucket array private int bucketindexfor object assert null null return math abs hashcode _buckets length bucketfor method obtains bucket ordinarily direct array lookup bucketfor method guarantees bucket exists yetat position created private list bucketfor object int bucketindex bucketindexfor list bucket _buckets bucketindex bucket null bucket linkedlist _buckets bucketindex bucket chapter _596748 ch11 qxd    return bucket add method obtains bucket doesnõt exist ensures equal valuesñthose equalswould return trueñcanõt exist hash table simultaneously public void add object list bucket bucketfor bucket bucket add maintainload method simple bucket return trueif abucket exists public boolean object list bucket _buckets bucketindexfor return bucket null bucket finally size method adds number values bucket calculate total size public int size int size int _buckets length _buckets null size _buckets size return size assessing performance hash table implementations itõs time perform onlyindividually evaluate performance develop tests exercise add methods timesequals called stored values smaller number efficiently implementa tion finds suitable location hashing14_596748 ch11 qxd    outcreating tests create test class package wrox algorithms hashing import junit framework testcase public class hashtablecallcountingtest extends testcase private static final int test_size private static final int initial_capacity private int _counter private hashtable _hashtable public void testlinearprobingwithresizing _hashtable linearprobinghashtable initial_capacity runall public void testlinearprobingnoresizing _hashtable linearprobinghashtable test_size runall public void testbucketsloadfactor100percent _hashtable bucketinghashtable initial_capacity f runall public void testbucketsloadfactor75percent _hashtable bucketinghashtable initial_capacity f runall public void testbuckets50percent _hashtable bucketinghashtable initial_capacity f runall public void testbuckets25percent _hashtable bucketinghashtable initial_capacity f runall public void testbuckets150percent _hashtable bucketinghashtable initial_capacity f runall public void testbuckets200percent _hashtable bucketinghashtable initial_capacity f runall chapter _596748 ch11 qxd    private void runall runadd runcontains private void runadd _counter int test_size _hashtable add reportcalls add private void runcontains _counter int test_size _hashtable reportcalls private void reportcalls string method println getname method _counter calls private final class private final string _value public int _value string valueof math random test_size public int hashcode return _value hashcode public boolean equals object object _counter return object null _value equals object _value works hashtablecallcountingtestextends testcase making easy class holds hash table instance current test counter recording number times equals method called package wrox algorithms hashing import junit framework testcase public class hashtablecallcountingtest extends testcase private static final int test_size hashing14_596748 ch11 qxd    private static final int initial_capacity private int _counter private hashtable _hashtable valueinner class enables intercept count calls equals store simple strings equals method called stringclass marked final extend override equals methoddirectly created class wraps string increments _ counteranytimeequals called notice constructor randomly assigns underlying ensure arenõt skewed insertion ordered data private final class private final string _value public _value string valueof math random test_size public int hashcode return _value hashcode public boolean equals object object _counter return object null _value equals object _value method reportcalls enables report number times equals called inthe form test method calls methodwill add depending test reported time private void reportcalls string method println getname method _counter calls methods runadd runcontains reset counter running test_sizeiterations ofthe add methods finally reporting private void runadd _counter int test_size _hashtable add reportcalls add private void runcontains _counter chapter _596748 ch11 qxd    int test_size _hashtable reportcalls method runall convenience enable test cases parts single private void runall runadd runcontains actual test cases set test cases linear probing arenõt configurations tryñonly factñas configurable option linearprobinghashtableis initial capacity creates hash table initial capacity smaller data setõs size leading number resize operations test capacity ensure resizing occurs public void testlinearprobingwithresizing _hashtable linearprobinghashtable initial_capacity runall public void testlinearprobingnoresizing _hashtable linearprobinghashtable test_size runall set tests exercises bucketing version demonstrate performance rela tive linear probing idea performance varies depending initial figuration case creates hash table initial capacity small guarantee number resize operations performed difference lies resize occur notice varying load factor values test public void testbucketsloadfactor100percent _hashtable bucketinghashtable initial_capacity f runall public void testbucketsloadfactor75percent _hashtable bucketinghashtable initial_capacity f runall public void testbuckets50percent _hashtable bucketinghashtable initial_capacity f runall public void testbuckets25percent _hashtable bucketinghashtable initial_capacity f runall hashing14_596748 ch11 qxd    public void testbuckets150percent _hashtable bucketinghashtable initial_capacity f runall public void testbuckets200percent _hashtable bucketinghashtable initial_capacity f runall running performance comparison produce output mind actual random nature tests testlinearprobingwithresizing add callstestlinearprobingwithresizing callstestlinearprobingnoresizing add callstestlinearprobingnoresizing callstestbucketsloadfactor100percent add callstestbucketsloadfactor100percent callstestbucketsloadfactor75percent add callstestbucketsloadfactor75percent callstestbuckets50percent add callstestbuckets50percent callstestbuckets25percent add callstestbuckets25percent callstestbuckets150percent add callstestbuckets150percent callstestbuckets200percent add callstestbuckets200percent callsin form numbers bit hard interpret summarized table  table  calls equals  iterations add configurationaddcontainstotalaverage linear probing resizing14    linear probing ð resizing18    buckets ð load9878691  buckets ð load8324331  buckets ð load5214309510 buckets ð load2622244860 buckets ð load1  buckets ð load1   actual vary random nature tests chapter _596748 ch11 qxd    striking thing obvious difference linear probing buckets column tableñaverageñshows linear probing performs generally linked listñ buckets appears work remarkably worst case hash table didnõt resize load reached number calls equals stillaveraged case average  values inthis case hash table populated leading lot wasted space cases buckets outperform linear probing orders magnitude direct correlation bucket load factor number calls load leads load values interesting feature matter load factor performance remains amazingly close conclude hash table implementation buckets excellent performance storing retrieving values achieving performance contingent finding good hash function summary chapter learned hashing acts kind randomizing function destroying sense order data aperfect hash function collisions hard achieve hashing function determined nature characteristics input data cases difficult impossible advance finding hash function minimizes number collisions eliminates altogether attainable increasing table size reduce number collisions expense wasted memory prime number table size linear probing degenerates linked list buckets coupled good hash function achieve search times hashing14_596748 ch11 qxd    exercises1 modify bucketinghashtableto prime number buckets performance modify linearprobinghashtableto maintain number values table thancalculate time modify bucketinghashtableto maintain number values table calcu late time create iterator access entries bucketinghashtable chapter _596748 ch11 qxd    setssets collections hold distinct values set guarantees item scientific applications provide structure lists holding data duplicate values needed list set intended chapter discusses topics basic operations setaset implementation designed small amounts data list set implementation efficiently manages large amounts unordered data hash setathird type set predictable iteration order tree set understanding sets set unordered pool data duplicates differs list array maintains order insertion duplicates figure  depicts set letters athrough notice explicit ordering values sets typically support operations table  _596748 ch12 qxd    figure  set pool distinct unordered values table  set operations operationdescription addadds set size set increased returns true returns falseif existed deletedeletes set deleted size set decreased returns true returns falseif didnõt exist containsdetermines exists set iteratorobtains iteratorover values set sizeobtains number values set isemptydetermines set returns trueif set size returns false cleardeletes values set size set reset set adding successful exists wonõt reason add operation indicateswhether delete deletedñthat existed addition adding deleting values query set determine contained check size set iterate values iterating set differs iterating list lists guarantee explicit ordering values sets promise ordering prohibitedñordered set implementations possibleñin general sets treat values equally guarantees order iteration bhfieadkcgj294chapter _596748 ch12 qxd    sets combined interesting ways assume sets figure  figure  sets union sets set values remembering set duplicates adding sets figure  union sets notice sets overlapping valuesñd fñ set duplicates figure  union sets bhfieadkcgjbhffiieaddkcgyxj295sets15_596748 ch12 qxd    intersection sets set values common remembering set duplicate values figure  intersection sets notice result values exist figure  intersection sets difference sets elements set members subtracting set figure  set yis subtracted set notice result values arenõt tained figure  difference sets ð easily plug set implementations depending application easily test type set cre ate interface defines required methods bhfieadkcgjbhfieadkcgj296chapter _596748 ch12 qxd    outcreating generic set interface create setinterface package wrox algorithms sets public interface set extends iterable public boolean add object public boolean delete object public boolean object public void clear public int size public boolean isempty works setinterface operations listed table  converted directly methods interface addition youõve extended iterableinterface defines iterator method enabling set iterableis required testing set implementations set implementation create behaves correctly develop suite tests work type set outcreating generic suite set tests create abstract test class package wrox algorithms sets import wrox algorithms iteration iterator import wrox algorithms iteration iteratoroutofboundsexception import wrox algorithms iteration reverseiterator import wrox algorithms lists linkedlist import wrox algorithms lists list import junit framework testcase public abstract class abstractsettestcase extends testcase private static final object private static final object private static final object private static final object private static final object private static final object private set _set protected void setup throws exception _set createset sets15_596748 ch12 qxd    _set add _set add _set add _set add protected abstract set createset public void testcontainsexisting asserttrue _set asserttrue _set asserttrue _set asserttrue _set public void testcontainsnonexisting assertfalse _set assertfalse _set public void testaddnewvalue assertequals _set size asserttrue _set add asserttrue _set assertequals _set size asserttrue _set add asserttrue _set assertequals _set size public void testaddexistingvaluehasnoeffect assertequals _set size assertfalse _set add assertequals _set size public void testdeleteexisting asserttrue _set delete assertfalse _set assertequals _set size asserttrue _set delete assertfalse _set assertequals _set size asserttrue _set delete assertfalse _set assertequals _set size asserttrue _set delete assertfalse _set chapter _596748 ch12 qxd    assertequals _set size public void testdeletenonexisting assertequals _set size assertfalse _set delete assertequals _set size assertfalse _set delete assertequals _set size public void testclear assertequals _set size assertfalse _set isempty _set clear assertequals _set size asserttrue _set isempty assertfalse _set assertfalse _set assertfalse _set assertfalse _set public void testiteratorforwards checkiterator _set iterator public void testiteratorbackwards checkiterator reverseiterator _set iterator private void checkiterator iterator list values linkedlist isdone values add current current fail catch iteratoroutofboundsexception assertequals values size asserttrue values asserttrue values asserttrue values asserttrue values sets15_596748 ch12 qxd    works class abstractsettestcaseextends testcasein order proper junit compatible test class defines sample entries map testing set assigned thesetup methodñwhich runs prior test caseñand sample values package wrox algorithms sets import wrox algorithms iteration iterator import wrox algorithms iteration reverseiterator import wrox algorithms iteration iteratoroutofboundsexception import wrox algorithms lists linkedlist import wrox algorithms lists list import junit framework testcase public abstract class abstractsettestcase extends testcase private static final object private static final object private static final object private static final object private static final object private static final object private set _set protected void setup throws exception _set createset _set add _set add _set add _set add protected abstract set createset method return truefor contained set falseotherwise sample values exist testcontainsexisting youcheck ensure returns truefor public void testcontainsexisting asserttrue _set asserttrue _set asserttrue _set asserttrue _set conversely testcontainsnonexisting ensures returns falsefor values exist chapter _596748 ch12 qxd    public void testcontainsnonexisting assertfalse _set assertfalse _set testaddnewkey method checks initial size set adding values time add called return checked ensure true indicating existing called ensure exists size checked ensure increased public void testaddnewvalue assertequals _set size asserttrue _set add asserttrue _set assertequals _set size asserttrue _set add asserttrue _set assertequals _set size method testaddexistingvaluehasnoeffect simply attempts add values eachtime duplicate return size checked ensure public void testaddexistingvaluehasnoeffect assertequals _set size assertfalse _set add assertequals _set size assertfalse _set add assertequals _set size assertfalse _set add assertequals _set size assertfalse _set add assertequals _set size testdeleteexisting removes values populate set ini tially time delete called return size set checked ensure reflect deletion public void testdeleteexisting assertequals _set size asserttrue _set delete assertfalse _set assertequals _set size asserttrue _set delete sets15_596748 ch12 qxd    assertfalse _set assertequals _set size asserttrue _set delete assertfalse _set assertequals _set size asserttrue _set delete assertfalse _set assertequals _set size naturally test delete existing checking size set testdeletenonexisting calls delete remove values exist time size checked ensure hasnõt changed public void testdeletenonexisting assertequals _set size assertfalse _set delete assertequals _set size assertfalse _set delete assertequals _set size method testclear ensures set clear called set isonce checked ensure longer values public void testclear assertequals _set size assertfalse _set isempty _set clear assertequals _set size asserttrue _set isempty assertfalse _set assertfalse _set assertfalse _set assertfalse _set finally verify iterating contents setñboth forwards backwardsñreturns expected values method checkiterator work iterates allthe values set adding list ensuring iterator throws exception completed list checked ensure expected values private void checkiterator iterator list values linkedlist isdone chapter _596748 ch12 qxd    values add current current fail catch iteratoroutofboundsexception expected assertequals values size asserttrue values asserttrue values asserttrue values asserttrue values test forwards iteration testiteratorforwards simply obtains iterator set hands checkiterator public void testiteratorforwards checkiterator _set iterator finally test reverse iteration testiteratorbackwards wraps iterator reverseiterator chapter calling checkiterator calls redi rected previous meaning donõt write separate set tests public void testiteratorbackwards checkiterator reverseiterator _set iterator list setin create set list underlying storage mechanism implementation straightforward easy follow isnõt efficient small data sets outtesting implementing list set start creating list set tests package wrox algorithms maps public class listmaptest extends abstractmaptestcase protected map createmap return listmap sets15_596748 ch12 qxd    follow list set class package wrox algorithms sets import wrox algorithms iteration iterator import wrox algorithms lists linkedlist import wrox algorithms lists list public class listset implements set private final list _values linkedlist public boolean object return _values public boolean add object return false _values add return true public boolean delete object return _values delete public void clear _values clear public int size return _values size public boolean isempty return _values isempty public iterator iterator return _values iterator works listsettestclass simply extends abstractsettestcase inherits testcases thing implement createset method return instance listsetclass test cases implementing listsetclass fairly straightforward delegate methods setinterface directly equivalent methods underlying list chapter _596748 ch12 qxd    alinked list underlying storage mechanism technically list implementation suffice methods liners delegating directly methods underlying listñthe exception add add method determines exists underlying list falseis returned set changed public boolean add object return false _values add return true list based set simple add delete methods form time sufficient handling small numbers values hash setif storing large number values ordering set imple mentation based hash tables covered chapter good choice implement hash set hashing familiarize withthe concepts implementation hash tables buckets outtesting implementing hash set start creating test class package wrox algorithms sets public class hashsettest extends abstractsettestcase protected set createset return hashset create hash set class package wrox algorithms sets import wrox algorithms hashing hashtableiterator import wrox algorithms iteration arrayiterator import wrox algorithms iteration iterator public class hashset implements set public static final int default_capacity public static final float default_load_factor f sets15_596748 ch12 qxd    private final int _initialcapacity private final float _loadfactor private listset _buckets private int _size public hashset default_capacity default_load_factor public hashset int initialcapacity initialcapacity default_load_factor public hashset int initialcapacity float loadfactor assert initialcapacity initialcapacity assert loadfactor loadfactor _initialcapacity initialcapacity _loadfactor loadfactor clear public boolean object listset bucket _buckets bucketindexfor return bucket null bucket public boolean add object listset bucket bucketfor bucket add _size maintainload return true return false public boolean delete object int bucketindex bucketindexfor listset bucket _buckets bucketindex bucket null bucket delete _size bucket isempty _buckets bucketindex null return true return false public iterator iterator return hashtableiterator arrayiterator _buckets chapter _596748 ch12 qxd    public void clear _buckets listset _initialcapacity _size public int size return _size public boolean isempty return size private listset bucketfor object int bucketindex bucketindexfor listset bucket _buckets bucketindex bucket null bucket listset _buckets bucketindex bucket return bucket private int bucketindexfor object assert null null return math abs hashcode _buckets length private void maintainload loadfactorexceeded resize private boolean loadfactorexceeded return size _buckets length _loadfactor private void resize hashset copy hashset _buckets length _loadfactor int _buckets length _buckets null copy addall _buckets iterator _buckets copy _buckets sets15_596748 ch12 qxd    private void addall iterator values assert values null values null values values isdone values add values current works hashsettestclass extends abstractsettestcase implement thecreateset method return instance hashsetto tested implementation hashsetis direct copy bucketinghashtablecodefrom chapter confine discussion code differences original bucketinghashtableimplementation required fulfill setinterface implementing setinterface major difference hashsetandbucketinghashtableis listfor buckets youõve listset sense bucket setñit duplicate valuesñand hash set dis tributes values sets based hash code order reduce lookup times set list buckets simplify code importantly clarify intent code reflected add method removing bucket adding public boolean add object listset bucket bucketfor bucket add _size maintainload return true return false difference youõve delete method required setinterface add advantage fact buckets sets bucket simple delete bucket needed toremove public boolean delete object int bucketindex bucketindexfor listset bucket _buckets bucketindex bucket null bucket delete _size bucket isempty _buckets bucketindex null return true chapter _596748 ch12 qxd    return false lastly youõve implemented iterator method traversal contained values youõve hashtableiteratorfrom chapter note hashtableiteratoris based iterableinterface list thing youõve add convenience constructors usability hashsetis pretty carbon copy bucketinghashtablefrom chapter hash table based buckets assuming good hash function form thehashcodemethod values stored expect achieve fairly close perfor mance start hashing precludes notion ordering iterator return values randomly tree set sets donõt guarantee ordering data predictable iteration orderñfor displaying options user selects alpha betical list names address book maintaining set semantics binary search trees chapter provide data structure proceeding implementation tree based sets recommend revisit binary search trees refresh understanding core concepts code discussion limited differences treesetcode presented original binarysearchtreecode outtesting implementing tree map start creating treesettestclass package wrox algorithms sets public class treesettest extends abstractsettestcase protected set createset return treeset follow class tree set implementation package wrox algorithms sets import wrox algorithms iteration iterator import wrox algorithms iteration iteratoroutofboundsexception import wrox algorithms sorting comparator import wrox algorithms sorting naturalcomparator sets15_596748 ch12 qxd    public class treeset implements set private final comparator _comparator private node _root private int _size public treeset naturalcomparator instance public treeset comparator comparator assert comparator null comparator null _comparator comparator public boolean object return search null public boolean add object node parent null node node _root int cmp node null parent node cmp _comparator compare node getvalue cmp return false node cmp node getsmaller node getlarger node inserted node parent parent null _root inserted cmp parent setsmaller inserted parent setlarger inserted _size return true public boolean delete object node node search node null return false node deleted node getsmaller null node getlarger null node successor node chapter _596748 ch12 qxd    assert deleted null deleted null node replacement deleted getsmaller null deleted getsmaller deleted getlarger replacement null replacement setparent deleted getparent deleted _root _root replacement deleted issmaller deleted getparent setsmaller replacement deleted getparent setlarger replacement deleted node object deletedvalue node getvalue node setvalue deleted getvalue deleted setvalue deletedvalue _size return true public iterator iterator return valueiterator public void clear _root null _size public int size return _size public boolean isempty return _root null private node search object assert null null node node _root node null int cmp _comparator compare node getvalue cmp break sets15_596748 ch12 qxd    node cmp node getsmaller node getlarger return node private static final class node private object _value private node _parent private node _smaller private node _larger public node node parent object setparent parent setvalue public object getvalue return _value public void setvalue object assert null null _value public node getparent return _parent public void setparent node parent _parent parent public node getsmaller return _smaller public void setsmaller node node assert node getlarger smaller larger _smaller node public node getlarger return _larger public void setlarger node node assert node getsmaller larger smaller _larger node public boolean issmaller chapter _596748 ch12 qxd    return getparent null getparent getsmaller public boolean islarger return getparent null getparent getlarger public node minimum node node node getsmaller null node node getsmaller return node public node maximum node node node getlarger null node node getlarger return node public node successor getlarger null return getlarger minimum node node node islarger node node getparent return node getparent public node predecessor getsmaller null return getsmaller maximum node node node issmaller node node getparent return node getparent sets15_596748 ch12 qxd    private final class valueiterator implements iterator private node _current public void _current _root null _root minimum null public void _current _root null _root maximum null public boolean isdone return _current null public void isdone _current _current successor public void previous isdone _current _current predecessor public object current throws iteratoroutofboundsexception isdone throw iteratoroutofboundsexception return _current getvalue works treesettestclass extends abstractsettestcaseto tests created earlier createset returning instance treesetclass code treesetfollows closely code developed binarysearchtreein chapter10 discussion code confined differences original binarysearchtreeimplementation difference treesetimplements setinterface originalinsert method renamed add change slight change behavior original insert method allowed duplicate values set semantics code add modified whileloop original insert methodlooked chapter _596748 ch12 qxd    node null parent node cmp _comparator compare node getvalue node cmp node getsmaller node getlarger notice duplicate inserted left child similarvalue add method duplicates node null parent node cmp _comparator compare node getvalue cmp return false node cmp node getsmaller node getlarger existing cmp method returns falseimmediately nochange proceeds original change search method private place method required setinterface method returns trueonly search finds matching node addition clear isempty size iterator methodsñagain man dated setinterfaceñthe change note nodeclass innerclass extra valueiteratorinner class iterates forwards backwards nodes order calling successor predecessor set implementation chapter average performance logn maintains stored values sorted order summary chapter demonstrated aset collection distinct values general set guarantee iteration order list based sets small data sets operations hash table based set operations random iteration order binary search tree based sets provide logn performance predictable iteration order sets15_596748 ch12 qxd    exercises1 write method takes sets determines equal write method takes sets produces set union write method takes sets produces set intersection write method takes sets produces set difference update delete method hashsetto free bucket itõs create set implementation sorted list create set implementation throws unsupportedoperationexceptionwhenever attempt modify chapter _596748 ch12 qxd    mapsmapsñalso dictionaries lookup tables associative arraysñare building indexes chapter discusses topics basic operations mapamap implementation designed small amounts data list map implementation efficiently manages large amounts unordered data hash mapathird type map predictable iteration order tree map understanding maps amap holds association key key map unique enables set retrieve creating lookup tables code entered description building indexes enable locate informationñfor personõs record based pertinent details fig ure  map peopleõs names represent keys values database record numbers thing remember maps keys map guaranteed unique promise values imagine maps telephone numbers database records easily phone number itõs conceivable person telephone numberñ business cellular case multiple keys map record number figure  leonardo vinci contacted numbers    _596748 ch13 qxd    figure  maps peopleõs names database record number maps dictionaries itõs hard understand fact original map class jdk called dictionary alanguage dictionary associates word definition case foreign language translation dictionary word cases word key definition lastly map associative array fact itõs arraysñor lists matterñas map recall arrays store values specific position map stores values specific key key sense array specialized map table  summarizes operations provided map leonardoda vi ncirecord michelangelorecord raphaelrecord renoirrecord monetrecord chapter _596748 ch13 qxd    figure  keys unique values table  map operations operationdescription getobtains key setsets map key returns previous deleteremoves key returns containsdetermines key exists map iteratorobtains iteratorover key pairs map sizeobtains number key pairs map isemptydetermines map returns trueif set isempty size returns false cleardeletes key pairs map size map reset  leonardoda vi nci555 monet555 raphael555 leonardoda vi nci555 renoir319maps16_596748 ch13 qxd    maps enable set key key remove key pair amap enables iterate key pairsñalso entriesñand sets maps generally guarantee ordering easily plug map implementations depending applica tion easily test type map create interface defines required methods outcreating generic map interface create mapinterface package wrox algorithms maps import wrox algorithms iteration iterable public interface map extends iterable public object object key public object set object key object public object delete object key public boolean object key public void clear public int size public boolean isempty public static interface entry public object getkey public object getvalue works mapinterface operations listed table  translated methods extends iterableinterface inherit iterator method usable iterableis required notice interface entry specifies common interface key pairscontained map instances map entrywill returned map iterators map entryinterface create default map entryimplementation map classes outcreating default entry implementation create defaultentryclass package wrox algorithms maps public class defaultentry implements map entry private final object _key private object _value chapter _596748 ch13 qxd    public defaultentry object key object assert key null key null _key key setvalue public object getkey return _key public object setvalue object object oldvalue _value _value return oldvalue public object getvalue return _value public boolean equals object object object return true object null getclass object getclass return false defaultentry defaultentry object return _key equals _key _value equals _value works defaultentryclass holds key pair getkey andgetvalue methods equals method enable deter entries equivalent tests follow notice key changed constructionñit marked finalñas change assigned modified notice provide key null practice nullkeys rarely nullvalues occur time database applications figure  typical situa tion database record represented map notice values cell phone drivers license null indicating beenassigned values unknown lastly recall map interface specifies key updated assigned returned behavior reflected fact setvalue method returns existing maps16_596748 ch13 qxd    figure  keys map mandatory values null start writing generic tests interface map implementation conform default map entryimplementation testing map implementations tests type map create abstract test class test cases extended test class specific mapimplementation create future outcreating generic suite map tests create abstractmaptestcaseclass package wrox algorithms maps import wrox algorithms iteration iterator import wrox algorithms iteration reverseiterator import wrox algorithms iteration iteratoroutofboundsexception import wrox algorithms lists linkedlist birth1st january1967namedavid cell phonenulldriverslicensenulladdresssomewhe rein london322chapter _596748 ch13 qxd    import wrox algorithms lists list import junit framework testcase public abstract class abstractmaptestcase extends testcase private static final map entry defaultentry akey avalue private static final map entry defaultentry bkey bvalue private static final map entry defaultentry ckey cvalue private static final map entry defaultentry dkey dvalue private static final map entry defaultentry ekey evalue private static final map entry defaultentry fkey fvalue private map _map protected void setup throws exception super setup _map createmap _map set getkey getvalue _map set getkey getvalue _map set getkey getvalue _map set getkey getvalue protected abstract map createmap public void testcontainsexisting asserttrue _map getkey asserttrue _map getkey asserttrue _map getkey asserttrue _map getkey public void testcontainsnonexisting assertfalse _map getkey assertfalse _map getkey public void testgetexisting assertequals getvalue _map getkey assertequals getvalue _map getkey assertequals getvalue _map getkey assertequals getvalue _map getkey public void testgetnonexisting assertnull _map getkey assertnull _map getkey public void testsetnewkey assertequals _map size assertnull _map set getkey getvalue maps16_596748 ch13 qxd    assertequals getvalue _map getkey assertequals _map size assertnull _map set getkey getvalue assertequals getvalue _map getkey assertequals _map size public void testsetexistingkey assertequals _map size assertequals getvalue _map set getkey cvalue2 assertequals cvalue2 _map getkey assertequals _map size public void testdeleteexisting assertequals _map size assertequals getvalue _map delete getkey assertfalse _map getkey assertequals _map size assertequals getvalue _map delete getkey assertfalse _map getkey assertequals _map size assertequals getvalue _map delete getkey assertfalse _map getkey assertequals _map size assertequals getvalue _map delete getkey assertfalse _map getkey assertequals _map size public void testdeletenonexisting assertequals _map size assertnull _map delete getkey assertequals _map size assertnull _map delete getkey assertequals _map size public void testclear assertequals _map size assertfalse _map isempty _map clear assertequals _map size asserttrue _map isempty assertfalse _map getkey assertfalse _map getkey chapter _596748 ch13 qxd    assertfalse _map getkey assertfalse _map getkey public void testiteratorforwards checkiterator _map iterator public void testiteratorbackwards checkiterator reverseiterator _map iterator private void checkiterator iterator list entries linkedlist isdone map entry entry map entry current entries add defaultentry entry getkey entry getvalue current fail catch iteratoroutofboundsexception expected assertequals entries size asserttrue entries asserttrue entries asserttrue entries asserttrue entries works class abstractmaptestcaseextends testcasein order proper junit compatible test class defines sample entries map testing map assigned thesetup method runs prior test case keys sample entries map abstract createmap method implemented concrete subclass abstractmaptestcase create specific instance map tested package wrox algorithms maps import wrox algorithms iteration iterator import wrox algorithms iteration reverseiterator import wrox algorithms lists linkedlist import wrox algorithms lists list import junit framework testcase maps16_596748 ch13 qxd    public abstract class abstractmaptestcase extends testcase private static final map entry defaultentry akey avalue private static final map entry defaultentry bkey bvalue private static final map entry defaultentry ckey cvalue private static final map entry defaultentry dkey dvalue private static final map entry defaultentry ekey evalue private static final map entry defaultentry fkey fvalue private map _map protected void setup throws exception super setup _map createmap _map set getkey getvalue _map set getkey getvalue _map set getkey getvalue _map set getkey getvalue protected abstract map createmap method return truefor key contained map falseotherwise sample keys exist testcontainsexisting check ensure returns truefor public void testcontainsexisting asserttrue _map getkey asserttrue _map getkey asserttrue _map getkey asserttrue _map getkey conversely testcontainsnonexisting ensures returns falsefor keys exist public void testcontainsnonexisting assertfalse _map getkey assertfalse _map getkey testgetexisting verifies returns correct key assigned setup method public void testgetexisting assertequals getvalue _map getkey assertequals getvalue _map getkey assertequals getvalue _map getkey assertequals getvalue _map getkey chapter _596748 ch13 qxd    testgetnonexisting verifies nullis returned keys exist map public void testgetnonexisting assertnull _map getkey assertnull _map getkey testsetnewkey method verifies retrieve stored values checking initial size map key pairs time set called return checked ensure null indicating existing called ensure key size checked ensure increased public void testsetnewkey assertequals _map size assertnull _map set getkey getvalue assertequals getvalue _map getkey assertequals _map size assertnull _map set getkey getvalue assertequals getvalue _map getkey assertequals _map size testsetexistingkey method checks initial size map set called toassociate existing key return checked ensure matches original alookup performed ensure key finally size checked original verify hasnõt changed public void testsetexistingkey assertequals _map size assertequals getvalue _map set getkey cvalue2 assertequals cvalue2 _map getkey assertequals _map size testdeleteexisting method calls delete remove keys setup return checked ensure correct method called ver ify key longer exists size checked ensure decremented public void testdeleteexisting assertequals _map size assertequals getvalue _map delete getkey assertfalse _map getkey assertequals _map size assertequals getvalue _map delete getkey assertfalse _map getkey assertequals _map size maps16_596748 ch13 qxd    assertequals getvalue _map delete getkey assertfalse _map getkey assertequals _map size assertequals getvalue _map delete getkey assertfalse _map getkey assertequals _map size checking size map testdeletenonexisting method calls delete remove key exist return tested null size checkedonce ensure change public void testdeletenonexisting assertequals _map size assertnull _map delete getkey assertequals _map size assertnull _map delete getkey assertequals _map size testclear method ensures map isnõt clear method thencalled size rechecked confirm reset finally called foreach original keys verify exist public void testclear assertequals _map size assertfalse _map isempty _map clear assertequals _map size asserttrue _map isempty assertfalse _map getkey assertfalse _map getkey assertfalse _map getkey assertfalse _map getkey work testing iterator checkiterator method iterates entries map time entry returned key create defaultentry list list checked ensure size matches expected number entries expected entries exists add entriesas returned map answer subtle aware instance working interfaces general method called determine expected entries exist list inturn calls equals determine entry searched matches list recall map entryis interface entries returned iterator class implements map entry defaultentry guarantee chapter _596748 ch13 qxd    equals method implemented work needed comparing itselfwith defaultentry authoritative discussion equals effective block cross fingers hope youõve key pairs list instances defaultentry implements equals method class expected entries private void checkiterator iterator list entries linkedlist isdone map entry entry map entry current entries add defaultentry entry getkey entry getvalue current fail catch iteratoroutofboundsexception expected assertequals entries size asserttrue entries asserttrue entries asserttrue entries asserttrue entries test forwards iteration testiteratorforwards simply obtains iterator map hands checkiterator public void testiteratorforwards checkiterator _map iterator finally test reverse iteration testiteratorbackwards wraps iterator reverseiterator chapter calling checkiterator calls beredirected previous respectivelyñmeaning donõt write separate set tests public void testiteratorbackwards checkiterator reverseiterator _map iterator list mapin create map list underlying storage mechanism implementation straightforward easy follow isnõt efficient small data sets maps16_596748 ch13 qxd    outtesting implementing list map start creating listmaptestas package wrox algorithms maps public class listmaptest extends abstractmaptestcase protected map createmap return listmap create listmapclass package wrox algorithms maps import wrox algorithms iteration iterator import wrox algorithms lists linkedlist import wrox algorithms lists list public class listmap implements map private final list _entries linkedlist public object object key defaultentry entry entryfor key return entry null entry getvalue null public object set object key object defaultentry entry entryfor key entry null return entry setvalue _entries add defaultentry key return null public object delete object key defaultentry entry entryfor key entry null return null _entries delete entry return entry getvalue public boolean object key return entryfor key null public void clear _entries clear chapter _596748 ch13 qxd    public int size return _entries size public boolean isempty return _entries isempty public iterator iterator return _entries iterator private defaultentry entryfor object key iterator iterator isdone defaultentry entry defaultentry current entry getkey equals key return entry return null works test cases created listmaptestis extendabstractmaptestand implement createmap return instance listmapclass package wrox algorithms maps public class listmaptest extends abstractmaptestcase protected map createmap return listmap tests place map implementation form listmapclass class holds list storing contained entries clear size isempty iterator methods delegate methods samename package wrox algorithms maps import wrox algorithms iteration iterator import wrox algorithms lists linkedlist import wrox algorithms lists list public class listmap implements map private final list _entries linkedlist public void clear maps16_596748 ch13 qxd    _entries clear public int size return _entries size public boolean isempty return _entries isempty public iterator iterator return _entries iterator private entryfor method obtains entry exists key method simply iterates entries list comparing key entry search key matching entry returned nullis returned entry exists private defaultentry entryfor object key iterator iterator isdone defaultentry entry defaultentry current entry getkey equals key return entry return null based implement return method entryfor iscalled entry key entry null returned nullis returned key exists public object object key defaultentry entry entryfor key return entry null entry getvalue null implement manner attempting entry key andreturning trueonly exists public boolean object key return entryfor key null set method calls entryfor determine entry exists key entry updated returned matching entry underlying list nullis returned chapter _596748 ch13 qxd    public object set object key object defaultentry entry entryfor key entry null return entry setvalue _entries add defaultentry key return null lastly delete called remove key pair map previous methods delete starts calling entryfor case entry nullis returned key exist entry deleted underlying list returned caller public object delete object key defaultentry entry entryfor key entry null return null _entries delete entry return entry getvalue itñyour map implementation code listmapclass simple andmost work performed underlying list case simplicity price theperformance listmapis dependent performance underlying list thisisnõt efficient small data sets list based map hash mapthe type map create based hash tables covered chapter point refresh understanding hashing conceptsñin hash tables bucketsñand code bucketinghashtableclass start creating tests ensure correct behavior creating hash map implementation proper outtesting implementing hash map create test class package wrox algorithms maps public class hashmaptest extends abstractmaptestcase protected map createmap return hashmap maps16_596748 ch13 qxd    create hash map implementation package wrox algorithms maps import wrox algorithms hashing hashtableiterator import wrox algorithms iteration arrayiterator import wrox algorithms iteration iterator public class hashmap implements map public static final int default_capacity public static final float default_load_factor f private final int _initialcapacity private final float _loadfactor private listmap _buckets private int _size public hashmap default_capacity default_load_factor public hashmap int initialcapacity initialcapacity default_load_factor public hashmap int initialcapacity float loadfactor assert initialcapacity initialcapacity assert loadfactor loadfactor _initialcapacity initialcapacity _loadfactor loadfactor clear public object object key listmap bucket _buckets bucketindexfor key return bucket null bucket key null public object set object key object listmap bucket bucketfor key int sizebefore bucket size object oldvalue bucket set key bucket size sizebefore _size maintainload return oldvalue public object delete object key listmap bucket _buckets bucketindexfor key chapter _596748 ch13 qxd    bucket null return null int sizebefore bucket size object bucket delete key bucket size sizebefore _size return public boolean object key listmap bucket _buckets bucketindexfor key return bucket null bucket key public iterator iterator return hashtableiterator arrayiterator _buckets public void clear _buckets listmap _initialcapacity _size public int size return _size public boolean isempty return size private int bucketindexfor object key assert key null key null return math abs key hashcode _buckets length private listmap bucketfor object key int bucketindex bucketindexfor key listmap bucket _buckets bucketindex bucket null bucket listmap _buckets bucketindex bucket return bucket private void maintainload loadfactorexceeded resize maps16_596748 ch13 qxd    private boolean loadfactorexceeded return size _buckets length _loadfactor private void resize hashmap copy hashmap _buckets length _loadfactor int _buckets length _buckets null copy addall _buckets iterator _buckets copy _buckets private void addall iterator entries assert entries null entries null entries entries isdone entries map entry entry map entry entries current set entry getkey entry getvalue works hashmaptestclass extends abstractmaptestcasein order tests created earlier implement createmap return instance hashmapclass hashmapclass copy code bucketinghashtableintroduced chapter reason discussion concentrates differences hashmapand original bucketinghashtablecode addition implementing mapinterface thing youõll noticeñbesides stants convenience constructorsñis youõve listmapfor buckets listas original bucketinghashtablecode hash map distributing fairly evenly key pairs list maps chapter buckets small list based maps perform fine map list buckets simplify codeñonce bucket work adding key pair delegated code set delete work carried bucket leaving hash map code perform housekeeping duties resizing obvious difference hashmapand bucketinghashtableis buckets store entries resizing addall iterates key pairs values case original chapter _596748 ch13 qxd    lastly mapis iterableñand listmapñyou hashtableiteratorfrom chapter iterate entries assuming good hash function keys expect achieve fairly close performancefor hashmap tree map mentioned maps donõt generally guarantee ordering keys listmap entries order insertion entries hashmapiterator willappear randomly predictable ordering keys case map implementation based binary search trees ideal proceeding implementation tree based maps recommend revisit binary search trees chapter refresh understanding core concepts code discussion limited differences treemapcode presented original binarysearchtreecode outtesting implementing tree map starting creating treemaptestclass package wrox algorithms maps public class treemaptest extends abstractmaptestcase protected map createmap return treemap follow tree map implementation package wrox algorithms maps import wrox algorithms iteration iterator import wrox algorithms iteration iteratoroutofboundsexception import wrox algorithms sorting comparator import wrox algorithms sorting naturalcomparator public class treemap implements map private final comparator _comparator private node _root private int _size public treemap naturalcomparator instance public treemap comparator comparator assert comparator null comparator null maps16_596748 ch13 qxd    _comparator comparator public boolean object key return search key null public object object key node node search key return node null node getvalue null public object set object key object node parent null node node _root int cmp node null parent node cmp _comparator compare key node getkey cmp return node setvalue node cmp node getsmaller node getlarger node inserted node parent key parent null _root inserted cmp parent setsmaller inserted parent setlarger inserted _size return null public object delete object key node node search key node null return null node deleted node getsmaller null node getlarger null node successor node assert deleted null deleted null node replacement deleted getsmaller null deleted getsmaller deleted getlarger replacement null replacement setparent deleted getparent chapter _596748 ch13 qxd    deleted _root _root replacement deleted issmaller deleted getparent setsmaller replacement deleted getparent setlarger replacement deleted node object deletedvalue node getvalue node setkey deleted getkey node setvalue deleted getvalue deleted setvalue deletedvalue _size return deleted getvalue public iterator iterator return entryiterator public void clear _root null _size public int size return _size public boolean isempty return _root null private node search object assert null null node node _root node null int cmp _comparator compare node getkey cmp break node cmp node getsmaller node getlarger return node private static final class node implements map entry maps16_596748 ch13 qxd    private object _key private object _value private node _parent private node _smaller private node _larger public node node parent object key object setkey key setvalue setparent parent public object getkey return _key public void setkey object key assert key null key null _key key public object getvalue return _value public object setvalue object object oldvalue _value _value return oldvalue public node getparent return _parent public void setparent node parent _parent parent public node getsmaller return _smaller public void setsmaller node node assert node getlarger smaller larger _smaller node public node getlarger return _larger public void setlarger node node chapter _596748 ch13 qxd    assert node getsmaller larger smaller _larger node public boolean issmaller return getparent null getparent getsmaller public boolean islarger return getparent null getparent getlarger public node minimum node node node getsmaller null node node getsmaller return node public node maximum node node node getlarger null node node getlarger return node public node successor getlarger null return getlarger minimum node node node islarger node node getparent return node getparent public node predecessor getsmaller null return getsmaller maximum node node node issmaller node node getparent maps16_596748 ch13 qxd    return node getparent private final class entryiterator implements iterator private node _current public void _current _root null _root minimum null public void _current _root null _root maximum null public boolean isdone return _current null public void isdone _current _current successor public void previous isdone _current _current predecessor public object current throws iteratoroutofboundsexception isdone throw iteratoroutofboundsexception return _current works treemaptestclass extends abstractmaptestcaseto tests created earlier createmap returning instance treemapclass code treemapfollows closely code developed binarysearchtreein chapter10 fact class implements mapinterface obvious difference youõll browse code original code referenced treemapuses thekey comparator compare keys values tree ordered key youõll notice nodehas class node hold anentry youõve nodeimplement map entrydirectly original node implementation chapter _596748 ch13 qxd    held needed add key modify setvalue return original defaultentryearlier original insert method renamed set original insert method worked values allowed duplicates map keys unique additionally set returns key whileloop original insert method looked node null parent node cmp _comparator compare node getvalue node cmp node getsmaller node getlarger notice duplicate inserted left child similarvalue set method node null parent node cmp _comparator compare key node getkey cmp return node setvalue node cmp node getsmaller node getlarger existing key cmp method updates returns code proceeds original change search method private method required mapinterface method returns trueonly searchactu ally finds matching node addition clear isempty size iterator methodsñagain man dated mapinterfaceñthe change note entryiteratorinner class iter ates forwards backwards nodes orderñand entriesñby calling successor predecessor thatõs map implementation chapter average performance logn bonus maintaining entries order sorted key summary chapter demonstrated maps store values key key map unique enables locate maps16_596748 ch13 qxd    maps associative arrays dictionaries indexes lookup tables general map guarantee iteration order common map implementations list map hash map tree map list based maps small data sets operations hash tableðbased map operations random iteration order binary search treeðbased sets provide logn performance predictable iteration order exercises1 create iterator returns keys contained map create iterator returns values contained map create set implementation map underlying storage mechanism values create map throws unsupportedoperationexceptionanytime attempt modify chapter _596748 ch13 qxd    ternary search trees youõve learned number ways store datañfrom simple unordered lists sorted lists binary search trees hash tables great storing objects arbitrary types youõre learn data structure storing strings itõs fast search enables perform interesting forms searching chapter discusses topics general properties ternary search trees stored looked ternary search trees creating dictionary implement simple application solve crossword puzzles understanding ternary search trees ternary search trees specialized structures storing retrieving strings binary search tree node holds reference smaller larger values binary search tree ternary search tree doesnõt hold entire node node holds single letter word referenceñhence ternaryñto subtree nodes ing letters follow word figure  store òcup ó òape ó òbat ó òmap ó òmanó ternary search tree notice depicted siblingsñsmaller larger lettersñas solid links childrenñletters followñas dashed links _596748 ch14 qxd    figure  sample ternary search tree òcó root highlighted nodes trace path òbat ó doesnõt child links level youõd perfectly valid binary search tree values youõve extra refer ence node child level binary search tree left node smallerñ bis larger smallerthan smaller mñand child node represents letter wordña òbat ósearching word level tree perform binary search starting letter word searching binary search tree start root follow links left matching node level child start time letter word continues lettersñ case matchñor nodes idea ternary search tree works searches word òbató tree figure  search starts root node letter search word figure  donõt match visit siblingsñif anyñand case search letter sorts current node left sibling seefigure  cupbatnapemap346chapter _596748 ch14 qxd    figure  search letter root tree figure  letter sorts follow left link compare search letter letter node mismatch bsorts time follow link figure  finally match letter word letter start ing child figure  cupbatnapemapcupbatnapemap347ternary search trees _596748 ch14 qxd    figure  letter sorts follow link figure  search letter starts child time hit straightaway repeating process letter andcontinue searching child node figure  matching letter letters search word matching word total individual character comparisons level youõre letter binary search tree level perform search binary search tree letter letters word deduce time performing lookup ternary search tree guess ternary search trees efficient binary search trees turns ternary search trees efficient simple binary search trees cupbatnapemapcupbatnapemap348chapter _596748 ch14 qxd    figure  search ends letter imagine word òmanó tree figure  count character compar isons compare òmó òcó compare òmó òmó òaó òaó youõre letter compare ònó òpó eventually ònó ònó compare search binary search tree stores figure  compare òmanó òcup ó mismatch letter node performed letter comparison compare òmanó òmapó thatõs extra comparisons finally compare òmanó òmanó compar isons grand total  single letter comparisons figure  equivalent binary search tree simple tree ternary search tree performs fewer individual character comparisons compared equivalent binary search tree share common prefix compressed traversed common letters pare compare binary search tree continually compare ters node cupapemapmanbatcupbatnapemap349ternary search trees _596748 ch14 qxd    addition efficient finding positive ternary search trees excel discarding donõt exist tree binary search tree continues searching runs nodes leaves ternary search tree terminate matching prefix understand searching works work general performance characteris tics ternary search trees imagine level contained letters alphabet arranged nodes binary search tree size alphabet ato english repre sentedby search level average logm comparisons ofcourse thatõs letter word length perform binarysearch letter nlogm comparisons practice performance turns common prefixes fact letter alphabet appears level branch tree inserting word inserting word ternary search tree isnõt difficult performing search sim ply add extra leaf nodes letters donõt exist figure  inserting word òbatsó requires addition single child node tacked existing word òbat ó inserting word òmató adds single node sibling letter òpó òmap ó figure  inserting òbatsó òmató requires addition extra node situation multiple wordsñóbató plural òbatsóñshare common prefix determine òbató word òbats ó òba ó òb ó òapó arenõt cupbatnsapemapt350chapter _596748 ch14 qxd    answer simple store node tells word figure  form simple boolean flag needed determine search word valid definition word implement dictionary doesnõt matter usedñthe point mark nodes represent letter word figure  nodes marked represent word youõve balanced trees binary search trees ternary search trees unbalanced tree figure  result inserting order òcup ó òape ó òbat ó òmap ó òman ó happen inserted sorted order òape ó òbat ó òcup ó òman ó òmapó order insertion leads unbalanced tree figure  searching balanced ternary search tree runs nlogm comparisons searching unbal anced tree requires nm comparisons difference substantial large values practice typically performance prefix sharing fact letter alphabet represented level prefix searchingperhaps application website allowed select list typ ing couple letters word type list possibilities narrows eventually handful values cupbatnsapemap351ternary search trees _596748 ch14 qxd    figure  order insertion leads unbalanced tree interesting ternary search tree finding common prefix trick perform standard search tree prefix perform order traversal word marker subtree prefix order traversal ternary search tree binary search tree include traversal child node node prefix follow steps traverse left subtree node visit node traverse nodeõs children traverse subtree figure  match prefix òma ó prefix start traversing left subtree case returns òman ó traverse node òma ó doesnõt mark word traverse children finally traverse subtree figure  match òmap ócupbatpapeman352chapter _596748 ch14 qxd    figure  point prefix òmaó òman ó figure  point prefix òmaó òmap ó traverse tree print collect wayñfor displaying list user pattern matching crossword puzzle playing game scrabble racked brain word fit existing letters letters òa tóñbut single possibility springs mind cupbatnapemapcupbatnapemap353ternary search trees _596748 ch14 qxd    ternary search trees solving problem ing match pattern apattern combination regular word tersña zñand special wildcard matches hyphen wildcard easily period question mark thing choose wonõt normal word familiar basic searching ternary search tree works simplest perform pattern match brute force pattern construct search word substituting wildcards combination letters previous start òaaraaató òaaraabtó òaaraact ó òazrzzzt ó work extremely slow large proportion fruitless searches sophisticated efficient approach structure ternary search tree advantage pattern matching straight word search anytime wildcard node matching letter wonõt visit node ifit match imagine pattern ò ó tree figure  regular word search start root node case character wildcard visit node current level sorted order figure  search smallest node figure  wildcard forces visit node current level starting smallest searching wildcard òpretendó node current level match proceed match letter pattern starting child current node figure  instance pattern characterñ añfails match child nodeñ pñso branch tree completely cupbatnapemap354chapter _596748 ch14 qxd    figure  nonmatching character terminates search current branch decided matches path search previous level continue searching largest node figure  figure  wildcard search continues higher level visiting largest node wildcard assume match proceed letter pattern starting child node figure  time òaó pattern matches òaó tree pattern match continue searching child node letter figure  cupbatnaxxxpemapcupbatnapemap355ternary search trees _596748 ch14 qxd    figure  time match pattern character figure  matching word wildcard nodes match youõve pattern reached word time figure  ñyouõve complete match òbat óthis process continues matching figure  matching nonmatching tree matched pattern ò ó òbat ó òman ó òmap ó character comparisons compare brute force approach attempted òaaaó òzaz ó case  combinations meaning perform character comparisons cupbatnaxxxpemapcupbatnaxxxpemap356chapter _596748 ch14 qxd    figure  search continues higher level largest node figure  completed search showing matching nonmatching putting ternary search trees practice understand ways ternary search trees itõs time hand creating real start creating test cases ensure implementation works correctly youõll creating actual ternary search tree finally develop simple application helping solve crossword puzzles cupbatnaxxxxxxpemapcupbatnaxxxpemap357ternary search trees _596748 ch14 qxd    outtesting ternary search tree create aptly named ternarysearchtreetestclass package wrox algorithms tstrees import wrox algorithms lists linkedlist import wrox algorithms lists list import junit framework testcase public class ternarysearchtreetest extends testcase private ternarysearchtree _tree protected void setup throws exception super setup _tree ternarysearchtree _tree add prefabricate _tree add presume _tree add prejudice _tree add preliminary _tree add apple _tree add ape _tree add appeal _tree add car _tree add dog _tree add cat _tree add mouse _tree add mince _tree add minty public void testcontains asserttrue _tree prefabricate asserttrue _tree presume asserttrue _tree prejudice asserttrue _tree preliminary asserttrue _tree apple asserttrue _tree ape asserttrue _tree appeal asserttrue _tree car asserttrue _tree dog asserttrue _tree cat asserttrue _tree mouse asserttrue _tree mince asserttrue _tree minty assertfalse _tree pre assertfalse _tree dogs assertfalse _tree unknown public void testprefixsearch chapter _596748 ch14 qxd    assertprefixequals string prefabricate prejudice preliminary presume pre assertprefixequals string ape appeal apple public void testpatternmatch assertpatternequals string mince mouse assertpatternequals string car cat private void assertprefixequals string expected string prefix list linkedlist _tree prefixsearch prefix assertequals expected private void assertpatternequals string expected string pattern list linkedlist _tree patternmatch pattern assertequals expected private void assertequals string expected list actual assertequals expected length actual size int expected length assertequals expected actual works ternarysearchtreetestclass holds instance ternary search tree individual test cases initialized setup adding number package wrox algorithms tstrees import wrox algorithms lists linkedlist import wrox algorithms lists list import junit framework testcase public class ternarysearchtreetest extends testcase private ternarysearchtree _tree protected void setup throws exception super setup _tree ternarysearchtree _tree add prefabricate ternary search trees _596748 ch14 qxd    _tree add presume _tree add prejudice _tree add preliminary _tree add apple _tree add ape _tree add appeal _tree add car _tree add dog _tree add cat _tree add mouse _tree add mince _tree add minty method testcontains verifies word setup exists tree addition youõve checked shouldnõt exist notice chosen care fully sequence letters pre dog tree prefixes return false unknown shouldnõt exist public void testcontains asserttrue _tree prefabricate asserttrue _tree presume asserttrue _tree prejudice asserttrue _tree preliminary asserttrue _tree apple asserttrue _tree ape asserttrue _tree appeal asserttrue _tree car asserttrue _tree dog asserttrue _tree cat asserttrue _tree mouse asserttrue _tree mince asserttrue _tree minty assertfalse _tree pre assertfalse _tree dogs assertfalse _tree unknown publicly accessible methods ternary search tree implementation finding common prefix finding matching pattern return list search created simple method verify search match expected custom assertequals compares array expected list returned search element element size contents list match array confident search successful private void assertequals string expected list actual assertequals expected length actual size chapter _596748 ch14 qxd    int expected length assertequals expected actual test prefix searching created method testprefixsearch method assembles list expected values prefix delegates work helper method assertprefixequals public void testprefixsearch assertprefixequals string prefabricate prejudice preliminary presume pre assertprefixequals string ape appeal apple method assertprefixequals creates list hold calls treeõs prefixsearch method populate list expected actual passed custom assertequals method validation private void assertprefixequals string expected string prefix list linkedlist _tree prefixsearch prefix assertequals expected method testpatternmatch assembles array expected pattern del egates helper method assertpatternequals public void testpatternmatch assertpatternequals string mince mouse assertpatternequals string car cat method assertpatternequals calls patternmatch tree validates notice question mark wildcard character choice character arbi trary question mark canõt word mistake obvious òsomething hereó private void assertpatternequals string expected string pattern list linkedlist _tree patternmatch pattern assertequals expected ternary search trees _596748 ch14 qxd    tests place create actual ternary search tree class outimplementing ternary search tree create ternarysearchtreeclass package wrox algorithms tstrees import wrox algorithms lists list public class ternarysearchtree public static final char wildcard private node _root public void add charsequence word assert word null word null assert word length word node node insert _root word _root null _root node public boolean charsequence word assert word null word null assert word length word node node search _root word return node null node isendofword public void patternmatch charsequence pattern list assert pattern null pattern null assert pattern length pattern assert null null patternmatch _root pattern public void prefixsearch charsequence prefix list assert prefix null prefix null assert prefix length prefix inordertraversal search _root prefix private node search node node charsequence word int assert word null word null node null return null chapter _596748 ch14 qxd    char word charat node getchar word length node search node getchild word node getchar node search node getsmaller word node search node getlarger word return node private node insert node node charsequence word int assert word null word null char word charat node null node node node getchar word length node setchild insert node getchild word node setword word tostring node getchar node setsmaller insert node getsmaller word node setlarger insert node getlarger word return node private void patternmatch node node charsequence pattern int listresults assert pattern null pattern null assert null null node null return char pattern charat wildcard node getchar patternmatch node getsmaller pattern ternary search trees _596748 ch14 qxd    wildcard node getchar pattern length patternmatch node getchild pattern node isendofword add node getword wildcard node getchar patternmatch node getlarger pattern private void inordertraversal node node list assert null null node null return inordertraversal node getsmaller node isendofword add node getword inordertraversal node getchild inordertraversal node getlarger private static final class node private final char _c private node _smaller private node _larger private node _child private string _word public node char _c public char getchar return _c public node getsmaller return _smaller public void setsmaller node smaller _smaller smaller public node getlarger return _larger chapter _596748 ch14 qxd    public void setlarger node larger _larger larger public node getchild return _child public void setchild node child _child child public string getword return _word public void setword string word _word word public boolean isendofword return getword null works class definition ternarysearchtreeis bare single instance variable hold ing root node defining constant wildcard character pattern matching package wrox algorithms tstrees import wrox algorithms lists list public class ternarysearchtree public static final char wildcard private node _root defined nodeclass structure tree simple class holding retrieving character references smaller larger siblings children notice strange variable _word recall needed mark word boolean purposes exercise weõve chosen store actual word consumes memory business collecting performing search easier convenience method isendofword thatreturns trueonly word stored node private static final class node private final char _c private node _smaller ternary search trees _596748 ch14 qxd    private node _larger private node _child private string _word public node char _c public char getchar return _c public node getsmaller return _smaller public void setsmaller node smaller _smaller smaller public node getlarger return _larger public void setlarger node larger _larger larger public node getchild return _child public void setchild node child _child child public string getword return _word public void setword string word _word word public boolean isendofword return getword null thing note remainder code algorithms oper ate ternary search trees lend easily recursion methods class coded method returns trueif word exists tree ignoring prefixes returns false validating input search passing chapter _596748 ch14 qxd    root node word search position character finally trueisreturned node marking word falseis returned word public boolean charsequence word assert word null word null assert word length word node node search _root word return node null node isendofword private search method takes node start word search position word start return search node character word nullif word current node node null search terminate charac ter current position retrieved search current search character matches current node characters string word length search progresses letter starting child node characters donõt match search character exist current node character sorts current node search continues starting smaller sibling sort current nodeñin case search continues larger sibling eventually letters search word nodes point whichever node returned result private node search node node charsequence word int assert word null word null node null return null char word charat node getchar word length node search node getchild word node getchar node search node getsmaller word node search node getlarger word return node methods add insert work add tree ternary search trees _596748 ch14 qxd    checking arguments method add calls insert passing root node word position character word thing update root node node returned insert public void add charsequence word assert word null word null assert word length word node node insert _root word _root null _root node insert method starts obtaining current character word cur rent node createdñyou adding current character compared character current node matches possibilities characters insert recurse character starting child node set word current node youõre character doesnõt match additional possibilities character sorts lower current node sorts higher case recurse charac ter smaller larger node notice return update reference child sibling node works insert method returns node inserted existing node node eventually returned add character word assumed private node insert node node charsequence word int assert word null word null char word charat node null node node node getchar word length node setchild insert node getchild word node setword word tostring node getchar node setsmaller insert node getsmaller word node setlarger insert node getlarger word return node chapter _596748 ch14 qxd    method prefixsearch performs general search node letter prefix node passed inordertraversal list storing theresults public void prefixsearch charsequence prefix list assert prefix null prefix null assert prefix length prefix inordertraversal search _root prefix method inordertraversal recursively traverses smaller sibling nodeõs child finally large sibling time word encountered node isendofword theresults private void inordertraversal node node list assert null null node null return inordertraversal node getsmaller node isendofword add node getword inordertraversal node getchild inordertraversal node getlarger patternmatch method calls private method passing root node pattern match position character pattern list whichthe stored public void patternmatch charsequence pattern list assert pattern null pattern null assert pattern length pattern assert null null patternmatch _root pattern patternmatch method order traversal tree restrictions traversing left siblings check performed determinewhether traversal required current pattern character sorts current node traversal smaller sibling sorts node traversal larger sib ling current node recursive character pattern starting child ternary search trees _596748 ch14 qxd    point current pattern character wildcard traverse matter wildcard character matches characters finally search length patternñfor pattern length match length private void patternmatch node node charsequence pattern int list assert pattern null pattern null assert null null node null return char pattern charat wildcard node getchar patternmatch node getsmaller pattern wildcard node getchar pattern length patternmatch node getchild pattern node isendofword add node getword wildcard node getchar patternmatch node getlarger pattern crossword helper examplearmed fully tested implemented pattern matching code turn hand asample application demonstrates ternary search trees crossword solving tion youõll develop small command application takes arguments file wordsñone word lineñand pattern match optionally wildcard characters outcreating crossword helper application create crosswordhelperclass package wrox algorithms tstrees import wrox algorithms iteration iterator import wrox algorithms lists linkedlist import wrox algorithms lists list import bufferedreader chapter _596748 ch14 qxd    import filereader import ioexception public final class crosswordhelper private crosswordhelper public static void main string args throws ioexception assert args null args null args length println usage crosswordhelper word list pattern repetitions exit int repetitions args length repetitions integer parseint args searchforpattern loadwords args args repetitions private static void searchforpattern ternarysearchtree tree string pattern int repetitions assert tree null tree null println searching pattern pattern repetitions times list null int repetitions linkedlist tree patternmatch pattern iterator iterator iterator iterator iterator isdone iterator println iterator current private static ternarysearchtree loadwords string filename throws ioexception ternarysearchtree tree ternarysearchtree println loading filename bufferedreader reader bufferedreader filereader filename ternary search trees _596748 ch14 qxd    string word word reader readline null tree add word finally reader close return tree works crosswordhelperclass defines application entry point main method verifies thatthere arguments command lineñone file word list pattern filename args passed loadwords seein moment returns ternary search tree passed pattern args tosearchforpattern actual matching package wrox algorithms tstrees import wrox algorithms iteration iterator import wrox algorithms lists linkedlist import wrox algorithms lists list import bufferedreader import filereader import ioexception public final class crosswordhelper private crosswordhelper public static void main string args throws ioexception assert args null args null args length println usage crosswordhelper word list pattern exit searchforpattern loadwords args args method loadwords takes file wordsñone lineñand returns fully populated ternary search tree starts creating ternary search tree stored opens file reading adding word tree file closed newly populated tree returned caller chapter _596748 ch14 qxd    private static ternarysearchtree loadwords string filename throws ioexception ternarysearchtree tree ternarysearchtree println loading filename bufferedreader reader bufferedreader filereader filename string word word reader readline null tree add word finally reader close return tree finally method performs search searchforpattern methodsimply creates list holding calls patternmatch passing pattern list andthen iterates printing console private static void searchforpattern ternarysearchtree tree string pattern assert tree null tree null println searching pattern pattern list linkedlist tree patternmatch pattern iterator iterator iterator iterator iterator isdone iterator println iterator current running crossword helper list  english pattern produced loading txt searching pattern abreactabreastacrobataeriestairboatairiestairliftairport373ternary search trees _596748 ch14 qxd    airpostalrightapricotpretty handy time youõre stuck solve crossword playing scrabble summary chapter demonstrated ternary search trees behavior storing strings regular lookup prefix searching pattern matching solving crossword puzzles binary search trees extra child node holding entire word nodes letter binary search trees ternary search trees unbalanced generally time efficient binary search trees performing average fewer numbers character comparisons exercise1 create iterative form search chapter _596748 ch14 qxd    b trees weõve covered designed work solely memory data lists chapter hash tables chapter binary search trees chapter data structures algorithms assumed entire data set held main memory data exists diskñas case databases wanted search database record millions chapter youõll learn handle data isnõt stored memory chapter discusses topics data structures youõve learned inadequate dealing data stored diskhow trees solve problems data structures implement simple tree based map implementation understanding trees youõve binary search trees build indexes maps itõs stretch imagine reading writing binary tree disk problem approach number records grows size tree imagine database table holding records keys length key maps record table stored integers length node tree references parent child nodes length reading writing        orapproximately megabytes mb time change thatõs lot disk aware disk expensive terms time compared main memory disk thousands millions times slower achieve data rate mb thatõs whopping  seconds ensure updates saved disk real applications involving tens hun dreds concurrent users  seconds unacceptable hope _596748 ch15 qxd    binary search tree composed individual nodes reading writing nodes individually sounds good idea practice turns ideal recall perfectly balanced binarysearch tree average number nodes traversed search key logn imagi nary database records log21  fine memory operations cost accessing node small great performing disk reads node smallñin bytesñdata stored disks larger blocks referred cost read ing node expensive reading nodes thatõs great read nodes read problem binary search tree built kind balancing occur ring itõs highly nodes located sector worse incur cost making disk reads transfertime disk read performed heads disks repositioned seek time disks rotated position latency adds employed sophisticated caching mechanisms order reduce number physical formed performance unacceptable trees designed managing indexes secondary storage hard disks pact discs providing efficient insert delete search operations variations standard tree including trees trees designed solve aspects searching external storage variations roots basic tree trees variations cormen sedgewick folk binary search trees trees nodes binary search trees nodes tree multiple keys defined maximumñusually determined size disk block keys node stored sorted order child node holding keys sort lower itñevery nonleaf node kkeys children figure  tree holding keys athrough node holds keys root node holding keysñd hñand children leftmost child holds keys sort lower middle child holds keys sort therightmost child holds keys greater figure  tree maximum keys node holding keys key tree key binary search tree node tains multiple keys making choice children tree search choice multiple children dhefg abcijk chapter _596748 ch15 qxd    search key tree figure  start root node search key compared figure  figure  search starts key root node sorts search continues key figure  figure  search continues key node time search key sorts current key node follow link left child figure  figure  search key falls current key search continues left child link continues eventually key searching figure  figure  search ends match search performed key comparisons nodes traversed process binary search tree number nodes traversed height tree dhefgabcijkdhefg abcijkdhefg abcijk dhefg abcijk b trees _596748 ch15 qxd    node tree multiple keys height tree remains lower comparable binary search tree fewer node traversals fewer disk original assume disk blocks hold  bytes meansthat node   keys keys translates    nodes binary search tree height tree logn nis number nodes number nodes traverse key order log3003  thatõs order magni tude binary search tree insert key tree start root search reach leaf node leaf node inserted order figure  tree figure  key lhas inserted figure  insertion occurs leaf nodes notice node key inserted exceeded maximum allowedñ maximum number keys allowed set node òfull ó split nodes half keys original figure  figure  nodes òfulló split òmiddleó key original node moved parent inserted order reference newly created node case pushed parent node references node figure  figure  middle key original node moves tree dhefg abci jkldhefg abcij kldhefg abcijk l378chapter _596748 ch15 qxd    tree spreads increasing height trees tend broader shal lower tree structures number nodes traversed smaller fact height tree increases root node split figure  tree figure  keys inserted node keys necessitating split figure  leaf node requiring split node split òmiddleó keyñthe lñis moved root figure  figure  root node time root node fullñit keysñand fore split splitting node pushes keys parent node case itõs root node parent root node split node created root figure  tree root node split node created increas ing height tree anew node key created parent nodes split original root node figure  splitting root node increases height tree dhefg abci jklmndhefg abci jklmndhefg abci jklm n379b trees _596748 ch15 qxd    deletion tree complicated search insert involves merging nodes figure  tree deleting key tree fig ure  longer valid tree longer middle child keys recall nonleaf node kkeys children figure  deleting key produces invalid tree correct structure redistribute keys childrenñin case key pushed node single key figure  figure  keys redistributed children correct tree structure simplest situation keys deleted tree figure  figure  redistribution required correct tree structure dhefg abc lmndhefg abci jlmndhefg abci jlmn380chapter _596748 ch15 qxd    redistribution keys required correct imbalance tree achieve ways matter keys redistributed keys parent nodes merged child nodes point root node pulled removed matter height tree reduced purposes youõll merge linto child pull root node parent figure  figure  height tree drops root node merged child deleted completely deletion complicated process involves scenarios depth explanation refer cormen putting trees practice understand trees work itõs time hand implementing mentioned earlier trees indexes simple youõll create implementation mapinterface chapter based tree avoid detracting underlying workings algorithms involved class create purely memory disk youõll implement methods mapinterface understanding trees basis underlying data structure youõll implement set methods based search insertion algorithms discussed earlier delete method youõre cheat algorithm deleting tree extremely complicatedñinvolving scenarios requiring entries redistributed nodesñrather delete entries youõll simply mark deleted unfortunate tree release memory sufficient purposes detailed explanation tree deletion cormen create tests ensure tree map implementation works correctly outtesting trees create btreemaptestclass package wrox algorithms btrees import wrox algorithms maps abstractmaptestcase import wrox algorithms maps map dhefg abc ijk b trees _596748 ch15 qxd    import wrox algorithms sorting naturalcomparator public class btreemaptest extends abstractmaptestcase protected map createmap return btreemap naturalcomparator instance works developed test cases chapter needed extend abstractmaptestcase thing implement method createmap return instance btreemapclass btreemapconstructor takes parameters parator ordering keys maximum number keys node case force number keys node small ensuring maximum number nodes defeat purpose treeñthe point height number nodes small possibleñby test youõll ensure special cases leaf node root node splitting exercised tests place create actual tree map implementation outimplementing tree map create btreemapclass package wrox algorithms btrees import wrox algorithms iteration iterator import wrox algorithms lists arraylist import wrox algorithms lists emptylist import wrox algorithms lists list import wrox algorithms maps defaultentry import wrox algorithms maps map import wrox algorithms sorting comparator public class btreemap implements map private static final int min_keys_per_node private final comparator _comparator private final int _maxkeyspernode private node _root private int _size public btreemap comparator comparator int maxkeyspernode assert comparator null comparator null assert maxkeyspernode min_keys_per_node maxkeyspernode min_keys_per_node _comparator comparator _maxkeyspernode maxkeyspernode clear public object object key chapter _596748 ch15 qxd    entry entry _root search key return entry null entry getvalue null public object set object key object object oldvalue _root set key _root isfull node newroot node false _root split newroot _root newroot return oldvalue public object delete object key entry entry _root search key entry null return null entry setdeleted true _size return entry setvalue null public boolean object key return _root search key null public void clear _root node true _size public int size return _size public boolean isempty return size public iterator iterator list list arraylist _size _root traverse list return list iterator private final class node b trees _596748 ch15 qxd    private final list _entries arraylist _maxkeyspernode private final list _children public node boolean leaf _children leaf arraylist _maxkeyspernode list emptylist instance public boolean isfull return _entries size _maxkeyspernode public entry search object key int indexof key entry entry entry _entries return entry isdeleted entry null return isleaf node _children search key null public object set object key object int indexof key return entry _entries setvalue return set key private object set object key object int isleaf _entries insert entry key _size return null node child node _children object oldvalue child set key child isfull child split return oldvalue private int indexof object key int lowerindex int upperindex _entries size lowerindex upperindex chapter _596748 ch15 qxd    int lowerindex upperindex lowerindex int cmp _comparator compare key entry _entries getkey cmp return cmp upperindex lowerindex return lowerindex public void split node parent int insertionpoint assert parent null parent null node sibling node isleaf int middle _entries size _entries middle sibling _entries _children middle sibling _children parent _entries insert insertionpoint _entries delete middle parent _children isempty parent _children insert insertionpoint parent _children insert insertionpoint sibling public void traverse list list assert list null list null iterator children _children iterator iterator entries _entries iterator children entries children isdone entries isdone children isdone node children current traverse list children entries isdone entry entry entry entries current entry isdeleted list add entry b trees _596748 ch15 qxd    entries private void list source int list target assert source null source null assert target null target null source size target add source delete private boolean isleaf return _children emptylist instance private static final class entry extends defaultentry private boolean _deleted public entry object key object super key public boolean isdeleted return _deleted public void setdeleted boolean deleted _deleted deleted works btreemapclass holds comparator ordering keys maximum number keys node root node number entries map notice minimum number keys allowed node node split key left child parent node minimum number keys set node considered keys perform split package wrox algorithms btrees import wrox algorithms iteration iterator import wrox algorithms lists arraylist import wrox algorithms lists emptylist import wrox algorithms lists list import wrox algorithms maps defaultentry import wrox algorithms maps map chapter _596748 ch15 qxd    import wrox algorithms sorting comparator public class btreemap implements map private static final int min_keys_per_node private final comparator _comparator private final int _maxkeyspernode private node _root private int _size public btreemap comparator comparator int maxkeyspernode assert comparator null comparator null assert maxkeyspernode min_keys_per_node maxkeyspernode min_keys_per_node _comparator comparator _maxkeyspernode maxkeyspernode clear classesñ entryand nodeñthat represent map entryand tree node addition extending defaultentry entryinner class holds boolean flag indicatingwhether deleted flag switched deleting entries private static final class entry extends defaultentry private boolean _deleted public entry object key object super key public boolean isdeleted return _deleted public void setdeleted boolean deleted _deleted deleted nodeinner class work performed weõll discuss class methods main btreemapclass node constructed boolean leaf node recall leaf nodes children reflected constructor node leaf list children set list array list allocated hold children reflected method isleaf determine node leaf addition method isfull determining node maximum allowable num ber keys b trees _596748 ch15 qxd    private final class node private final list _entries arraylist private final list _children public node boolean leaf _children leaf arraylist list emptylist instance public boolean isfull return _entries size _maxkeyspernode private boolean isleaf return _children emptylist instance thing method searching entries key indexof method forms simple linear search entries matching key position list  returned negative returned key existed youõre interested depth discussion linear searching works refer chapter code identical search method linearlistsearcherexcept retrieves key entry calling compare private int indexof object key int iterator _entries iterator isdone int cmp _comparator compare key entry current getkey cmp return cmp break return key node searching nodes entry fairly straightforward search method searches matching key returned node leaf search continues recursively child terminates finding matching entryñleaf nodes children notice search method ignores entries marked deleted point remember chapter _596748 ch15 qxd    public entry search object key int indexof key entry entry entry _entries return entry isdeleted entry null return isleaf node _children search key null insert keys node imple ment code split node split method takes reference parent node position newly created node inserted thing split create node siblingñhence leaf flag copied sibling leaf leaf entries children midpoint moved node sibling middle entry inserted parent reference sibling areference node split inserted parent parent newly created root node children public void split node parent int insertionpoint assert parent null parent null node sibling node isleaf int middle _entries size _entries middle sibling _entries _children middle sibling _children parent _entries insert insertionpoint _entries delete middle parent _children isempty parent _children insert insertionpoint parent _children insert insertionpoint sibling private void list source int list target assert source null source null assert target null target null source size target add source delete split node adding entries remembering map guarantees uniqueness keys reason entries inserted entry matching key exists updated b trees _596748 ch15 qxd    set method starts obtaining position key node key entry retrieved updated returned key wasnõt inserted exist childnode logic handled set method set method determines node leaf key doesnõt existanywhere tree inserted entry size map incremented node children child recursive set method case insertion child itwill split public object set object key object int indexof key return entry _entries setvalue return set key private object set object key object int isleaf _entries insert entry key _size return null node child node _children object oldvalue child set key child isfull child split return oldvalue method nodeñ traverse ñis iteration method adds entries tree list starts adding nondeleted entries current node recur sively calls children essentially pre order traversal implement order traversal exercise left reader public void traverse list list assert list null list null iterator entries _entries iterator entries entries isdone entries entry entry entry entries current entry isdeleted list add entry iterator children _children iterator chapter _596748 ch15 qxd    children children isdone children node children current traverse list youõve covered nodeinner class proceed remaining btreemapmethodsrequired mapinterface method returns key search method root node called key entry returned nullisreturned key doesnõt exist tree public object object key entry entry _root search key return entry null entry getvalue null method determines key exists tree search methodis called root node trueis returned entry public boolean object key return _root search key null set method adds updates key set methodon root node called work method returns root node checked determine root node created existing split special handling required case key returned caller required mapinterface public object set object key object object oldvalue _root set key _root isfull node newroot node false _root split newroot _root newroot return oldvalue delete method removes keyñand valueñfrom map search method called root node entry key entry nullis returned key didnõt exist entry marked deleted size map decremented returned caller public object delete object key entry entry _root search key entry null return null entry setdeleted true b trees _596748 ch15 qxd    _size return entry setvalue null iterator method returns iterator entries map order traverse method root node called passing list populate entries tree iterator returned passed caller public iterator iterator list list arraylist _size _root traverse list return list iterator clear method removes entries map tree root node set leaf nodeñas childrenñand size reset public void clear _root node true _size finally size isempty methods complete interface public int size return _size public boolean isempty return size implementation youõve created works memory creating version saved restored external medium hard disk requires work itõs straightforward cormen summary chapter demonstrated key points trees ideally suited searching external storage hard disks compact discs trees grow leaves nonroot node half nodes split òfull ó392chapter _596748 ch15 qxd    node splits keys pushed parent height tree increases root node splits trees remain òbalanced ó guaranteeing logn search times exercises1 implement traverse method nodeto return entries key order implement indexof method nodeto perform binary search linear search b trees _596748 ch15 qxd    _596748 ch15 qxd    string searchingthe problem finding string searching files disk dnasearches google rely strategies efficiently searching text youõve word processor text editor editor writing code stage performed string search findfunction string searching algorithmsñand doubt discovered timeñeach optimizations handling specific types data algorithms work plain text work text patterns lot repeti tion dnafragments chapter covers algorithms plain text searching start obvious brute force algorithm sophisticated boyer moore simple twist brute force approach enables boyer moore algorithm perform faster reading chapter implement brute force string searching algorithm implement boyer moore string searching algorithm understand performance characteristics algorithmdescribe implement generic string match iteratordescribe implement simple file searching application generic string searcher interfacebecause implement types string search algorithms implement variations arises conceive interface remains matter type underlying mechanism additionally string searches conform single api write single suite tests applied order assert correctness _596748 ch16 qxd    outcreating interface start creating simple interface package wrox algorithms ssearch public interface stringsearcher public stringmatch search charsequence text int create stringmatchclass return type search package wrox algorithms ssearch public class stringmatch private final charsequence _pattern private final charsequence _text private final int _index public stringmatch charsequence pattern charsequence text int assert text null text null assert pattern null pattern null assert  _text text _pattern pattern _index public charsequence getpattern return _pattern public charsequence gettext return _text public int getindex return _index works stringsearcherclass defines single search method method takes arguments text search initial starting position returns object represents match learn moment assumed pattern search fixed construction timeñfor concrete implementationñand required passed parameter search chapter _596748 ch16 qxd    notice charsequenceinstead stringfor text implementing word processor stringbufferto hold text edited document times search plain string ordinarily classesñ stringand stringbufferñhave common meaning write implementations algorithm handling strings versionfor stringbuffers thankfully standard library interface charsequence isimplemented stringand stringbufferclasses methods search algorithms search return instance stringmatchor nullif match class encapsulates concept match class holding position ofthe match  text pattern result search inde pendent object context generic test suite string searching conceptually simple algorithms subtleties easily trip things defense tests tests serve guarantee correctnessñour safety net ensure matter sophisticated algorithms outward behavior create test cases including tests pattern start text pattern text pattern middle text multiple overlapping occurrences pattern test aspect string searcher order prove correctness outcreating test class string searchers chapter share common behavior trusted method creating generic test suite hooks subclassing package wrox algorithms ssearch import junit framework testcase public abstract class abstractstringsearcher extends testcase protected abstract stringsearcher createsearcher charsequence pattern test case simplest scenarios searching string anytime search called pattern doesnõt exist text return nullto thatno match testing boundary conditions writing good quality code public void testnotfoundinanemptytext stringsearcher searcher createsearcher assertnull searcher search string searching19_596748 ch16 qxd    scenario searches pattern text public void testfindatthestart string text start string pattern stringsearcher searcher createsearcher pattern stringmatch match searcher search text assertnotnull match assertequals text match gettext assertequals pattern match getpattern assertequals match getindex assertnull searcher search text match getindex searched pattern text public void testfindattheend string text string pattern stringsearcher searcher createsearcher pattern stringmatch match searcher search text assertnotnull match assertequals text match gettext assertequals pattern match getpattern assertequals match getindex assertnull searcher search text match getindex test pattern middle text correctly identified public void testfindinthemiddle string text middle text string pattern middle stringsearcher searcher createsearcher pattern stringmatch match searcher search text assertnotnull match assertequals text match gettext assertequals pattern match getpattern assertequals match getindex assertnull searcher search text match getindex finally verify overlapping matches occurs plain text ensure algorithm working correctly test searcherõs ability multiple matchesñsomething havenõt chapter _596748 ch16 qxd    public void testfindoverlapping string text abcdefffff fedcba string pattern fff stringsearcher searcher createsearcher pattern stringmatch match searcher search text assertnotnull match assertequals text match gettext assertequals pattern match getpattern assertequals match getindex match searcher search text match getindex assertnotnull match assertequals text match gettext assertequals pattern match getpattern assertequals match getindex match searcher search text match getindex assertnotnull match assertequals text match gettext assertequals pattern match getpattern assertequals match getindex assertnull searcher search text match getindex works string searches create encapsulate pattern lookingñthink kind pattern òsmarts ó createsearcher declares pattern argument test method create searcher calling createsearcher performing rest test test searches string result nullto wasnõtfound test expect match start string ensure search returns nullvalue ensure details match correct including impor tantly verifying positionñin case character text matches tested initiate search start ing character position previous match returns null test identical previous time single occurrence pat tern exists hand text left test involved previous time multiple occurrences patternñthree preciseñall overlapping test confirms searcher finds correct order thatõs test cases written tests implement good coverage enable turn attention actual business searching string searching19_596748 ch16 qxd    brute force algorithm simplest obvious solution perform brute force scan text algorithm performs pretty cases easy code brute force algorithm straightforward defined simple steps imagine overlaying text pattern starting left hand continuing slide pattern character match start leftmost character text compare left character pattern text characters match reached text matches preceding occur pattern character repeat step brute force search algorithm action pattern ringin text stringsearching ringis compared substring striñclearly matchñ ringwith trin eventually match attempt note sliding pat tern brute force approach compare character string search1 ring2 ring3 ringnow suppose wanted continue searching additional occurrences ring pattern exists character point starting start charac ter rightñthe fourth characterñand follow process remaining steps search sliding pattern position time string search4 ring5 ring6 ring7 ring8 ring9 ring10 ringin occurrences ring stringsearch eventuallyrun text finding match notice didnõt pattern character fact canõt text attempt tenth character comparing ring rch strings match sizes characters long pattern lines text chapter _596748 ch16 qxd    itõs easy determine search text characters compare pattern length mand text length character position case length text pattern   ñjust understand algorithm works ahead implement code create tests algorithm outcreating test class youõve hard work creating actual test case earlier chapter time test cases created chance package wrox algorithms ssearch public class bruteforcestringsearchertest extends abstractstringsearchertestcase protected stringsearcher createsearcher charsequence pattern return bruteforcestringsearcher pattern works extending abstractstringsearchertestcase test class inherits predefined test meth ods meaning donõt construct instance specific searcher classñ case bruteforcestringsearcherñwith pattern outimplementing algorithm create bruteforcestringsearcherclass package wrox algorithms ssearch public class bruteforcestringsearcher implements stringsearcher private final charsequence _pattern public bruteforcestringsearcher charsequence pattern assert pattern null pattern null assert pattern length pattern _pattern pattern public stringmatch search charsequence text int assert text null text null assert  int text length _pattern length int _pattern length _pattern charat text charat string searching19_596748 ch16 qxd    _pattern length return stringmatch _pattern text return null works bruteforcestringsearcherclass implements stringsearcherinterface defined earlier constructor performs bit sanity checking ensuring pattern passed character stores reference pattern search method nested loops control algorithm outer whileloop controls algorithm proceeds text whileloop performs actualleft character comparison pattern text loop terminates characters pattern compared match returned conversely mismatch encountered current position text incre mented outer loop continues process repeats match text process case nullis returned matches discussed earlier algorithm called brute force reason tricks shortcuts optimizations reduce number comparisons worst case compare character pattern character text making worst case running time nm practice performance demonstrated chapter boyer moore algorithm brute force approach works fairly optimal average case numerous false starts partial matches simple enhancements menñr boyer mooreñcame algorithm basis fastest string searching algorithms observed moves brute force algorithm redundant cases characters text donõt exist pattern case skip original search time boyer moore algorithm note large portions text skipped reducing total number string comparisons compare brute force algorithm performed total chapter _596748 ch16 qxd    string search1 ring3 ring4 ring8 ringthe secret knowing places shift mismatch determine analyzing pattern time encounter failed match search pattern rightmost occurrence offending character proceed bad characterheuristic original boyer moore algorithm heuristic suffix papers subject safely improves performance long repetitive patterns purposes discussion focus purely simplified version character exists pattern shift places align character inthe pattern text unsuccessful comparison gwith determine iexists pattern places untilthey meet character doesnõt exist pattern shift places justbeyond position compares gwith space pattern nospaces places skip completely heuristic proposes negative shift case naive approach moving position returning boyer moore algorithm proper point explanation imagine searching pattern overin text everythingover starting left pattern compare rand eand vuntil eventuallyencounter mismatch oand blindly follow heuristic discover case heuristic proposes backwards everythingover pattern òeó mismatch isnõt shift pattern position continue comparing left characters òoveró òveryó efficient ways handle case simply moving char acter position algorithm simple worst case boyer moore implementation performs brute force practice performs considerably string searching19_596748 ch16 qxd    demonstrated capability skip entire sections text leads pretty amazing performance improvements brute force search fact highly text character pattern occurs entire length pattern skipped time leading case running time nis length text search mis length pattern lines previous implementation create test class searcher named algorithm creating tests tests defined abstract test case time define additional test specific boyer moore implementation outcreating test class create test class package wrox algorithms ssearch public class boyermoorestringsearchertestextends abstractstringsearchertestcase protected stringsearcher createsearcher charsequence pattern return boyermoorestringsearcher pattern public void testshiftsdonterroneouslyignorematches string text aababaa string pattern baba stringsearcher searcher createsearcher pattern stringmatch match searcher search text assertnotnull match assertequals text match gettext assertequals pattern match getpattern assertequals match getindex assertnull searcher search text match getindex works boyer moore algorithm shift position time ensure shifts correct number places pattern case occurrences character bug calculation occurrence shift places implementing algorithm steps involved implementing boyer moore algorithm create string searcher code compute occurrence table finally perform search chapter _596748 ch16 qxd    outcreating boyermoorestringsearcher class start basic class definition package wrox algorithms ssearch public class boyermoorestringsearcher implements stringsearcher private final charsequence _pattern private final short _lastoccurrence public boyermoorestringsearcher charsequence pattern assert pattern null pattern null assert pattern length pattern _pattern pattern _lastoccurrence computelastoccurrence pattern works class brute force code presence array _lastoccurrenceand computelastoccurrencesto initialize recall boyer moore algorithm position occurrence character pattern calculate repeatedly scanning pattern needed add overhead calculate values store needed construction lookup table incur overhead proportional length pat tern size character set small character sets ascii overhead minimal larger character sets required represent asian middle eastern lan guages require sophisticated techniques scope book outcomputing occurrence table method computelastoccurrences takes pattern returns array posi tion  occurrence character stored _lastoccurrencevariable private static short computelastoccurrence charsequence pattern short lastoccurrence short charset_size int lastoccurrence length lastoccurrence int pattern length lastoccurrence pattern charat short return lastoccurrence string searching19_596748 ch16 qxd    works assumed ascii character set construct array elementsñone characterñand initialize to default itdoesnõt exist pattern iterate left character pattern character code element record position processing pattern ensures posi tion character overwritten duplicate guaranteeing array holds position rightmost occurrence imagine simplistic character set characters define pattern decade construct occurrence table figure  figure  occurrence table pattern aat position and cat position beenset dand occur assigned rightmost positionñ and outperforming search brute force approach simply increment current position text time boyer moore algorithm calls sophisticated public stringmatch search charsequence text int assert text null text null assert  int text length _pattern length int _pattern length char  _pattern charat text charat return stringmatch _pattern text b2c3a4d5e406chapter _596748 ch16 qxd    math max _lastoccurrence return null works search method structurally brute force version notable differences pattern compared backwards left determining shift involves array lookup calculation code performs shift calculation math max _lastoccurrence performing calculation straightforward mismatched character text knownposition  pattern subtracted current position pattern imagine compare pattern abcdwiththe text bdaaedccda bdaaedccdaabcd mismatch occurs position pattern compared thelast occurrence awithin pattern position subtracting shift  moving place compare abcdwith aaed bdaaedccda abcd match previous characters position pattern ewithin pattern table lookup yields calculation shift  moving places leads comparison abcdwith dccd bdaaedccda abcd mismatch position pattern cfrom text place coccurs pattern position shift  donõtwant sliding backwards recall heuristic deals negative shifts cases procedure naive approach shifting math max ensures matter calculated increment string searching19_596748 ch16 qxd    string match iteratorif test cases notice anytime wanted iterate number matches needed remember current location approach good ultimately force duplication coding effort time perform search remember text searching current position class sit searcher encapsulate behavior outcreating stringmatchiterator class chapter introduced iterator book good create class demonstrates power flexibility iterator stringsearcher design encapsulating behavior state required perform multiple successive searches package wrox algorithms ssearch import wrox algorithms iteration iterator import wrox algorithms iteration iteratoroutofboundsexception public class stringmatchiterator implements iterator private final stringsearcher _searcher private final charsequence _text private stringmatch _current public stringmatchiterator stringsearcher searcher charsequence text assert searcher null searcher null assert text null text null _searcher searcher _text text public void throw unsupportedoperationexception public void previous throw unsupportedoperationexception public boolean isdone return _current null public void _current _searcher search _text public void isdone _current _searcher search _text _current getindex chapter _596748 ch16 qxd    public object current throws iteratoroutofboundsexception isdone throw iteratoroutofboundsexception return _current works stringmatchiteratorclass holds string searcher text search current match assumed created string searcher constructing string match iterator previous throw unsupportedoperationexception thestringsearcherinterface searching forwards text implementing isdone simple string searcher returns nullwhen matches finding match matter calling string searcher initial character position ñthe start string finding subsequent matches gain iterator hold result previous match easily calculate character position order continue search finally current match accessible current method making throw iteratoroutofboundsexceptionif isnõt comparing performance working string searching algorithms pare pretty confident boyer moore algorithm outperform brute force algorithm prove suite tests calculating worst average case times thought practical inter searching file develops simple application exercises string searchers patterns file process youõll demonstrate simple technique enable measuring relative formance search implementation measuring performance ways measure performance algorithms obvious record elapsed running time running times susceptible unpredictable interference string searching19_596748 ch16 qxd    operating functions virtual memory swapping task switching network interrupts predictable measure performance discussion centered number comparisons fact entire basis deviating brute force algorithm reduce number string comparisons number character comparisonsñby reducing number charac ter comparisons reduce work reducing work theory reduce running time count number comparisons performed measure performance algorithm reviewing code apparent implementations comparison character lookups character text pattern infer direct relationship character lookups comparisons count number lookups measure relative performance outa class counting character lookups recall strings text pattern interfacecharsequence reason interface trivial create wrapper decorator gamma intercept count charat ñyet good reason interfaces concrete classes class needñnamely count character lookups package wrox algorithms ssearch public class callcountingcharsequence implements charsequence private final charsequence _charsequence private int _callcount public callcountingcharsequence charsequence charsequence assert charsequence null charsequence null _charsequence charsequence public int getcallcount return _count public char charat int _count return _charsequence charat public int length return _charsequence length public charsequence subsequence int start int return _charsequence subsequence start chapter _596748 ch16 qxd    works implementing charsequence class callcountingcharsequencewraps eventuallydelegates method calls underlying charsequence notice charat increments counter counter accessible getcallcount method thisway easy determine character comparisons outa class searches file count character lookups search files import wrox algorithms iteration iterator import fileinputstream import ioexception import nio bytebuffer import nio charbuffer import nio channels filechannel import nio charset charset public final class comparativestringsearcher private static final int number_of_args private static final string charset_name _1 private final string _filename private final string _pattern public comparativestringsearcher string filename string pattern assert filename null filename null assert pattern null pattern null _filename filename _pattern pattern public void throws ioexception filechannel fileinputstream _filename getchannel bytebuffer bbuf map filechannel mapmode read_only int size charbuffer file charset forname charset_name newdecoder decode bbuf println searching _filename file length _pattern search bruteforcestringsearcher _pattern file search boyermoorestringsearcher _pattern file finally close private void search stringsearcher searcher charsequence file string searching19_596748 ch16 qxd    callcountingcharsequence text callcountingcharsequence file iterator stringmatchiterator searcher text int occurrence long starttime currenttimemillis isdone occurrence long elapsedtime currenttimemillis starttime println searcher getclass getname occurrences occurrence comparisons text getcallcount time elapsedtime public static void main string args throws ioexception assert args null args null args length number_of_args err println usage comparativestringsearcher file pattern exit comparativestringsearcher searcher comparativestringsearcher args args searcher works modern operating systems enable open memory mapped filesñinstead reading stream address contiguous array bytes memory advan tage memory mapped files programs nio charbufferclass weõre talking great thing charbufferis implements charsequence havenõt guessed file input searching algorithms class method opens file constructor creates charbufferthat enables youto read file memory mapped passed string searcher search method string searcher implementations created earlier search method wraps file callcountingcharsequenceña charbufferis acharsequenceñto count number character lookups stringmatchiteratortofind occurrences pattern chapter _596748 ch16 qxd    finally main method called program simply ensures correct number arguments passedñone file search patternñbefore calling search real work performed noticed strange _1 character set whenusing charbuffers knowing decode text file character set _1 corresponds iso latin western european languages including english unicode orgfor character sets character encoding big questions efficient algorithms faster compare good idea performs thought weõd good workout searching large text files patterns leo tolstoyõs war peace ñjust mb sizeñavailable plain text format gutenberg projects website gutenberg org table  table  pattern searching war peace patternoccurrencesbrute forceboyer moore difference a198    the43    zebra03   military1083   independence83   figures boyer moore include extra lookup character building occurrence table boyer moore algorithm performs consistently naive algorithmñin cases fast cases times faster fact carefully notice longer pattern greater improvement boyer moore algorithm skip large chunks textñthe longer pattern characters skip performance summary chapter covered commonly understood string searching algorithmsñbrute force boyer mooreñand iterator sits common string searcher interface removes coding burden making multiple successive searches highlights chapter include main points string searching19_596748 ch16 qxd    brute force algorithm works scanning left position time match worst case compare character pattern character text worst case running time nm ñparticularly nasty ideal scenario brute force approach scenario character comparison fails time successful match text running time case boyer moore algorithm performs character comparisons left pat tern skips multiple character positions time worst case running time bad worse overhead initial pattern processing brute force algorithm practice performs remarkably brute force algo rithm achieve case running time continually skip entire pattern implement iterator avoids cumbersome state management performing repeated searches iterator depends stringsearcherinter face string searcher search types text characteristics required sophisticated varied string searching algorithms iterator enables assuming algorithm conforms stringsearcherinterface leaving application code oblivious thechange search technique compared algorithms searching english large mb text file real vary depending type text search length pattern hoped thinking effort achieve order magnitude improve ment performance brute force boyer moore search algorithms string searching algorithms havenõt discussedñrabin karp cormen knuth morris pratt cormen spring mind ofthese perform boyer moore applications brute force approach plain text searching rabin karp clever hashing scheme searching multiple patterns application thing ana lyze type text searching identify characteristics enable avoid unnecessary comparisons chapter _596748 ch16 qxd    string matchingchapter concentrated efficient techniques finding string chapter focuses matching strings attempting matches identical strings detecting duplicate entries database spell checking documents searching genes dna chapter discusses topics understanding soundexunderstanding levenshtein word distance understanding soundex soundex encoding class algorithms phonetic encoding algorithms phoneticencoding takes strings converts sounding encoded hash function soundex developed russell process data collected census russell soundex algorithm original form variationsin numerous applicationsñranging human resource management genealogy census takingñin attempt eliminate data duplication occurs differ ences spelling peopleõs surnames robert taft working york state identification intelligence pro ject nysii published paper titled òname search techniques ó presented findings phonetic encoding schemes soundex algorithm developedby nysii based extensive statistical analysis real data nysii project concluded soundex  accurate selectivity  search presented  accurate selectivity  search phonetic encoding schemes include metaphone double metaphone variationson original soundex _596748 ch17 qxd    soundex algorithm straightforward fairly simple understand involves number rules processing input string input string surname processed left transformation applied character produce character code form lddd lrepresents letter drepresents digit range  input character transformed rules rela tionships group letters characters processed uppercase letter drop characters translate remaining characters d lto r drop consecutive letters code pad zeros letter drop vowels english read vowels removed notice yare pronunciation vowel sound letters pronunciation shape mouth making sound notice ignore consecutive letters code sense double letters english sound single letter idea encoding works practice surnames smith smythe encode soundex algorithm start initializing result buffer space charactersñthe maximum length soundex code fourñas figure  start processing input string character time left rule copy character input string charac ter result buffer copy figure  character input string rule encoded figure  character position result chapter _596748 ch17 qxd    figure  start initializing result buffer space characters figure  input string character character result figure  encoded input string character position rule vowels contribute result figure  figure  vowels letter algorithm encoded result position figure  figure  encoded sinputm5ithresults3sinputm5ith resultssinputm5ith resultssinputmith resultssinputmith result417string matching20_596748 ch17 qxd    character special character treated vowel figure  figure  treated vowels youõve input characters havenõt filled result buffer rule pad remainder zeros figure  soundex character string smith s530 figure  result padded zeros achieve required characters quick encoding smythe start result buffer length figure  figure  initializing result buffer space characters weõre step process time easily weõve summarized result figure  figure  final encoding òsmytheó sinputmythe result5s30 sinputmythe resultsinputm5ith results30 sinputm5ithresults3418chapter _596748 ch17 qxd    figure  smytheencodes s530 smith creating database soundex surnames search smithwould return records smytheand vice versa hope designed catch spelling mistakes andfind people names huge concern instance algorithm runs time onlyone pass string feel soundex algorithm works theory write tests ensure actual implementation outtesting soundex encoder create test class rules cover ensure implement algorithm correctly package wrox algorithms wmatch import junit framework testcase public class soundexphoneticencodertest extends testcase private soundexphoneticencoder _encoder protected void setup throws exception super setup _encoder soundexphoneticencoder instance public void testfirstletterisalwaysused char string result _encoder encode assertnotnull result assertequals result length assertequals result charat public void testvowelsareignored assertallequals char public void testlettersrepresentedbyone assertallequals char public void testlettersrepresentedbytwo assertallequals char public void testlettersrepresentedbythree string matching20_596748 ch17 qxd    assertallequals char public void testlettersrepresentedbyfour assertallequals char public void testlettersrepresentedbyfive assertallequals char public void testlettersrepresentedbysix assertallequals char public void testduplicatecodesaredropped assertequals b100 _encoder encode bfpv assertequals c200 _encoder encode cgjkqsxz assertequals d300 _encoder encode ddt assertequals l400 _encoder encode lll assertequals m500 _encoder encode mnmn assertequals r600 _encoder encode rrr public void testsomerealstrings assertequals s530 _encoder encode smith assertequals s530 _encoder encode smythe assertequals m235 _encoder encode mcdonald assertequals m235 _encoder encode macdonald assertequals h620 _encoder encode harris assertequals h620 _encoder encode harrys private void assertallequals char expectedvalue char chars int chars length char chars string result _encoder encode assertnotnull result assertequals result length assertequals expectedvalue result works soundexphoneticencodertestclass holds instance soundexphoneticencoderthat ini tialized setup test cases package wrox algorithms wmatch import junit framework testcase public class soundexphoneticencodertest extends testcase chapter _596748 ch17 qxd    private soundexphoneticencoder _encoder protected void setup throws exception super setup _encoder soundexphoneticencoder instance rule letter circumstances start testing assumption testfirstletterisalwaysused method cycles character ato encoding character string encoded ensure return string nulland length fourñall soundex values characters length verify character result input string public void testfirstletterisalwaysused char string result _encoder encode assertnotnull result assertequals result length assertequals result charat tests remaining rules pretty helper method work method assertallequals accepts expected array characters touse character letter letter input string encoded return checked nulland ensure correct length encoded pared expected result cases character remained unchanged encoded character string digits padded zeros leaves character result checked case expected indicating input character private void assertallequals char expectedvalue char chars int chars length char chars string result _encoder encode assertnotnull result assertequals result length assertequals expectedvalue result rule drop vowels including special letters sound vowels method testvowelsareignored checks constructing string arbi trary characterñwhich copied isñfollowed single vowel encoding string matching20_596748 ch17 qxd    expect characters encoded indicating vowel beenignored result padded remaining character spaces public void testvowelsareignored assertallequals char tested cases rule case called assertallequals passing inthe expected set input characters public void testlettersrepresentedbyone assertallequals char public void testlettersrepresentedbytwo assertallequals char public void testlettersrepresentedbythree assertallequals char public void testlettersrepresentedbyfour assertallequals char public void testlettersrepresentedbyfive assertallequals char public void testlettersrepresentedbysix assertallequals char rule specifies drop consecutive letters code testduplicatecodesaredropped checks obvious tests essentially group letters form string letter directly letter encodedñnone ters test vowelsñbut subsequent letters code expect ensuring digits encoded string zeros public void testduplicatecodesaredropped assertequals b100 _encoder encode bfpv assertequals c200 _encoder encode cgjkqsxz assertequals d300 _encoder encode ddt assertequals l400 _encoder encode lll assertequals m500 _encoder encode mnmn assertequals r600 _encoder encode rrr finally testsomerealstrings takes pairs names encode validates result chapter _596748 ch17 qxd    public void testsomerealstrings assertequals s530 _encoder encode smith assertequals s530 _encoder encode smythe assertequals m235 _encoder encode mcdonald assertequals m235 _encoder encode macdonald assertequals h620 _encoder encode harris assertequals h620 _encoder encode harrys youõre confident test suite sufficient ensure correctness implementa tion write actual soundex encoder outimplementing soundex encoder starting creating interface definition common phonetic encoder package wrox algorithms wmatch public interface phoneticencoder public string encode charsequence string create soundex encoder class package wrox algorithms wmatch public final class soundexphoneticencoder implements phoneticencoder public static final soundexphoneticencoder instance soundexphoneticencoder private static final char character_map tochararray private soundexphoneticencoder public string encode charsequence string assert string null string null assert string length string char result   result character touppercase string charat int stringindex int resultindex stringindex string length resultindex result length char map string charat stringindex result resultindex result resultindex resultindex string matching20_596748 ch17 qxd    stringindex return string valueof result private static char map char int character touppercase return isvalid character_map private static boolean isvalid int return character_map length works defining phoneticencoderinterface develop variations usedin applications depending directly specific implementation presented package wrox algorithms wmatch public interface phoneticencoder public string encode charsequence string soundexphoneticencoderclass implements phoneticencoderinterface ensure plug gability encoding schemes desire notice constructor marked private prevents instantiation recall earlier mentioned single instance class access class viathe publicly constant instance notice character array character_map crucial algorithm map ping characters coded digits map assumed start aand continue alphabet limits implementation working english language algorithm works english names isnõt problem package wrox algorithms wmatch public final class soundexphoneticencoder implements phoneticencoder public static final soundexphoneticencoder instance soundexphoneticencoder private static final char character_map tochararray private soundexphoneticencoder chapter _596748 ch17 qxd    core algorithm weõll cover simple helper methods map andisvalid methods character input string translate soundex rules character converted val ues array character_map falls bounds array character trans lated is returned ignoredñjust vowels private static char map char int character touppercase return isvalid character_map private static boolean isvalid int return character_map length finally actual soundex encoding algorithm encode method starts initializinga character array zeros shortcut method padding final encoded valueñyou result characters length start zeros character input string character resultñand converted uppercase caseñas rule method loops character input string character passed map return stored result bufferñ or stored case continues result buffer fullñfour characters storedñor input characters process result buffer converted string returned caller public string encode charsequence string assert string null string null assert string length string char result   result character touppercase string charat int stringindex int resultindex stringindex string length resultindex result length char map string charat stringindex result resultindex result resultindex resultindex stringindex return string valueof result string matching20_596748 ch17 qxd    understanding levenshtein word distance phonetic coding soundex excellent fuzzy matching misspelled english names andeven minor spelling mistakes isnõt good detecting large typing errors soundex values òmistakesó òmsitakesó values òshopó òsjopó transposing òjó òhó common mistakeñboth letters standard qwertykeyboard levenshtein word distance edit distance algorithm compares similarity calculating smallest number insertions deletions substitutions required transform string choose limitñsay ñbelow distance short algorithm presented forms basis number techniques word processor spell checking dnamatching plagiarism detection algorithm effective brute force approach essentially transforming source string target string number operations performed operation assigned cost smallest distanceis set smallest total cost calculate levenshtein distance start creating grid rows columns letters source target word figure  grid calculating edit distance òmsteakó òmistakeó figure  initialized grid comparing msteak mistake notice weõve included extra row values ð7 extra column values ð6 row corresponds source word values represent cumulative cost inserting character column corresponds target word values represent cumula tive cost deletion step calculate values remaining cells grid cell calculated formula min left diagonal substitution cost delete cost left insert cos calculate cell apply formula mistake msteak426chapter _596748 ch17 qxd    min    min  the cost insertion deletion cost substitution thesource target characters donõt match vary cost operationsñspecifically insertion deletionñas substitution character costly inserting deleting acharacter calculating cell leads grid figure  figure  calculating cell cell min    min  this result grid figure  figure  calculating cell mistake msteak01234567mistake msteak427string matching20_596748 ch17 qxd    process continues cell assigned figure  figure  completed grid cell minimum distance cell grid minimum distance òmsteakó andòmistakeó grid set operations alignments apply trans form source target figure  paths set trans formations figure  paths grid showing order operations transforming òmsteakó òmistakeó interpret figure  followsó substitute òmó òmó cost insert òió cost  substitute òsó òsó cost mistake msteak012345673332233234564443234111234522212345554323mistake msteak428chapter _596748 ch17 qxd    substitute òtó òtó cost delete òeó cost  substitute òaó òaó cost insert òeó cost deduce diagonally substitution insertion straight deletion algorithm defined performs time relative character source compared character target produce fully populated grid algorithm stands couldnõt producing spell checker appreciable number time calculate distances prohibitive word proces sors typically combination techniques presented chapter build tests ensure implementation algorithm runs correctly outtesting distance calculator create test class package wrox algorithms wmatch import junit framework testcase public class levenshteinworddistancecalculatortest extends testcase private levenshteinworddistancecalculator _calculator protected void setup throws exception super setup _calculator levenshteinworddistancecalculator default public void testemptytoempty assertdistance public void testemptytononempty string target assertdistance target length target public void testsameprefix assertdistance unzip undo public void testsamesuffix assertdistance eating running public void testarbitrary string matching20_596748 ch17 qxd    assertdistance msteak mistake assertdistance necassery neccessary assertdistance donkey mule private void assertdistance int distance string source string target assertequals distance _calculator calculate source target assertequals distance _calculator calculate target source works levenshteinworddistancecalculatortestclass holds instance alevenshteinworddistancecalculatorto tests initialized default instance earlier package wrox algorithms wmatch import junit framework testcase public class levenshteinworddistancecalculatortest extends testcase private levenshteinworddistancecalculator _calculator protected void setup throws exception super setup _calculator levenshteinworddistancecalculator default method assertdistance tests ensure calculated distance expected takes source string target string runs calculator comparing result expected thing note methodñand reason cre ated itñis runs calculation swapping source target time ensures matter strings presented calculator distance produced private void assertdistance int distance string source string target assertequals distance _calculator calculate source target assertequals distance _calculator calculate target source method testemptytoempty ensures distance strings zeroñeven strings effectively public void testemptytoempty assertdistance chapter _596748 ch17 qxd    method testemptytononempty compares string arbitrary string distance length string public void testemptytononempty string target assertdistance target length target testsameprefix tests strings sharing common prefix distance length longer string minus prefix public void testsameprefix assertdistance unzip undo conversely testsameprefix test strings sharing common suffix time distance length longer string minus suffix public void testsamesuffix assertdistance eating running finally tested combinations distances public void testarbitrary assertdistance msteak mistake assertdistance necassery neccessary assertdistance donkey mule tests create actual distance calculator outimplementing distance calculator create distance calculator package wrox algorithms wmatch public class levenshteinworddistancecalculator public static final levenshteinworddistancecalculator default levenshteinworddistancecalculator  private final int _costofsubstitution private final int _costofdeletion private final int _costofinsertion public levenshteinworddistancecalculator int costofsubstitution int costofdeletion int costofinsertion assert costofsubstitution costofsubstitution assert costofdeletion costofdeletion string matching20_596748 ch17 qxd    assert costofinsertion costofinsertion _costofsubstitution costofsubstitution _costofdeletion costofdeletion _costofinsertion costofinsertion public int calculate charsequence source charsequence target assert source null source null assert target null target null int sourcelength source length int targetlength target length int grid int sourcelength targetlength grid  int row row sourcelength row grid row row int col col targetlength col grid col col int row row sourcelength row int col col targetlength col grid row col mincost source target grid row col return grid sourcelength targetlength private int mincost charsequence source charsequence target int grid int row int col return min substitutioncost source target grid row col deletecost grid row col insertcost grid row col private int substitutioncost charsequence source charsequence target int grid int row int col int cost source charat row target charat col cost _costofsubstitution return grid row col cost private int deletecost int grid int row int col return grid row col _costofdeletion chapter _596748 ch17 qxd    private int insertcost int grid int row int col return grid row col _costofinsertion private static int min int int int return math min math min works levenshteinworddistancecalculatorclass instance variables storing unit cost operations substitution deletion insertion class defines defaultwhereby operations unit cost case discussion earlier public constructor enables play weightings package wrox algorithms wmatch public class levenshteinworddistancecalculator public static final levenshteinworddistancecalculator default levenshteinworddistancecalculator  private final int _costofsubstitution private final int _costofdeletion private final int _costofinsertion public levenshteinworddistancecalculator int costofsubstitution int costofdeletion int costofinsertion assert costofsubstitution costofsubstitution assert costofdeletion costofdeletion assert costofinsertion costofinsertion _costofsubstitution costofsubstitution _costofdeletion costofdeletion _costofinsertion costofinsertion core algorithm letõs start examining intermediate calcula tions calculation substitutioncost implies method calculates cost substituting character recall substitution cost letters diagonally left cell method starts assuming characters match initializing cost compare characters differ cost updated finally add cumulative stored diagonally left cell grid returning caller private int substitutioncost charsequence source charsequence target int grid int row int col int cost string matching20_596748 ch17 qxd    source charat row target charat col cost _costofsubstitution return grid row col cost method deletecost calculates cost deletion adding cumulative cell directly unit cost deletion private int deletecost int grid int row int col return grid row col _costofdeletion lastly insertcost calculates cost insertion time add cumulative cell directly left unit cost insertion return caller private int insertcost int grid int row int col return grid row col _costofinsertion method minimumcostcalculates cost operations passes min ña convenience method finding minimum values private int minimumcost charsequence source charsequence target int grid int row int col return min substitutioncost source target grid row col deletecost grid row col insertcost grid row col private static int min int int int return math min math min algorithm proper defined method calculate takestwo stringsña source targetñand returns edit distance method starts initializing grid rows columns accommodate calcu lation left cell grid initialized column row row column initialized grid figure  iterate combination source target character calculating minimum cost storing cell eventually finish processing character combinations point select cell grid figure  return caller minimum distance public int calculate charsequence source charsequence target assert source null source null chapter _596748 ch17 qxd    assert target null target null int sourcelength source length int targetlength target length int grid int sourcelength targetlength grid  int row row sourcelength row grid row row int col col targetlength col grid col col int row row sourcelength row int col col targetlength col grid row col minimumcost source target grid row col return grid sourcelength targetlength summary called phonetic coders soundex efficiently sounding soundex values duplicate entries misspelled names databases soundex calculates character code time levenshtein word distance calculates number operations transform word anotherñthe smaller distance levenshtein algorithm forms basis spell checkers dnasearches plagiarism detec tion applications levenshtein algorithm runs time space complexity string matching20_596748 ch17 qxd    _596748 ch17 qxd    computational geometry chapter taste fascinating area algorithm design computationalgeometry topic dozens books scratching surfacehere check references search internet material computational geometry foundations computer graphics intend pur sue developing software games graphical areas youõll solid understanding computational geometry topics covered chapter limited dimensional geometry grasp concepts dimensions understanding dimensions topic scope chapter excellent books specialize explanation algorithms dimensional graphics check references appendix aor good puter bookstore chapter discusses topics aquick geometry refresher finding intersection point straight linesfinding closest pair points large set scattered points quick geometry refresher saves trouble digging high school mathematics textbook recapping concepts youõll understand sense rest chapter coordinates points dimensional spatial concepts coordinate represented straight lines called axesthat perpendicular figure  _596748 ch18 qxd    figure  coordinate axes horizontal axis called axisand vertical axis called axis positions axisare numbered left increasing values positions axis values increase upwards apointis position dimensional space defined numbers form axis directly point axis directly left point figure  point  coordinate figure  point  coordinate coordinate extends left axes positions ends axes defined negative coordinates figure  points plotted regions linesaline simply straight path points points needed define determine length slope interesting things weõll figure   ð  axis4x axis  y axisx axis438chapter _596748 ch18 qxd    figure  coordinates negative axes figure  coordinate triangles wonõt insult telling triangle apologies describing preceding interested angled trianglesin chapter theyõre degree angle figure  thing angled triangles lengths sides canuse pythagorasõtheorem figure length figure  sides labeled pythagorasõ theorem states c2as long refers longest hypotenuse usual triangle infigure  lengths            computational geometry _596748 ch18 qxd    figure  angled triangle figure  angled triangle lengths figure itõs easy  or  thatõs background explore computational geometry problem determining lines intersect finding intersection lines walks computational geometry problem finds point lines intersect figure  lines intersecting point marked points define points lines figure lines intersect thing comfortable algebraic formula isy mx bwhere coordinates youõre familiar slope point cuts axis donõt worry weõll explain concepts cba440chapter _596748 ch18 qxd    figure  intersecting lines slopethe slopeof simply steep simple method depicted figure  figure  slope expressed ratio rise travel riseis vertical distance axis covered travelis horizontal dis tance axis covered finally slope ratio rise travel rise travel slope figure  figure  slope slope   rise travel risetravel p32112345441computational geometry _596748 ch18 qxd    slopes negative figure  slope ð2 rise fall point point downward negative large travel figure  negative slope couple special cases note horizontal lines slope matter large travel rise issue vertical travel matter rise recall slope ratio rise travel divide riseby travel derive slope dividing impossible vertical lines infinite slope meaning computer careful coding avoid issues vertical lines crossing axis lines slope parallel lines slope differ point cross axis vertical donõt worry fig ure  parallel lines slope  cross axis points figure  pair parallel lines note higher crosses axis formula x y x y x    slope rise    travel  chapter _596748 ch18 qxd    lower crosses axis ð1 formula x finding intersection point background work finding intersection point lines figure  purpose figure  sample pair intersecting lines trick coordinates point intersection sense formulas lines formula mx band formula nx cto point intersection mx nx crearrange mx nx brearrange y x y x    computational geometry _596748 ch18 qxd    formulas lines coordinate point intersection formula formula    or if refer figure  coordinate point intersection figuring coordinate trivial discovered coordinate formula x y   y  y the point intersection ð1  lines method varies lines vertical steps coordinate point intersection apply coordinate point intersection lines vertical simply coordinate vertical solving nonvertical lineõs equation finish job itõs time theory discussed previ ous sections work code exercise concepts map directly objects effort spent concepts clear worthwhile creating class represent points outtesting implementing point class start defining pointclass form junit test case behaviors point determine point coor dinates determine distance point code package wrox algorithms geometry import junit framework testcase public class pointtest extends testcase public void testequals assertequals point  point  chapter _596748 ch18 qxd    assertequals point  point  assertequals point  point  assertfalse point  equals point  assertfalse point  equals point  assertfalse point  equals point  assertfalse point  equals point  assertfalse point  equals point  assertfalse point  equals point  public void testdistance assertequals d point  distance point  assertequals d point  distance point  assertequals d point  distance point  assertequals d point  distance point  assertequals d point  distance point  assertequals d point  distance point  implementation point declare instance variable hold coordi nates constructor initialize note fields final making objects class immutable package wrox algorithms geometry public class point private final double _x private final double _y public point double double _x _y provide simple accessors coordinates public double getx return _x public double gety return _y pythagorasõ theorem calculate distance point supplied dis tance method computational geometry _596748 ch18 qxd    public double distance point assert null null double rise gety gety double travel getx getx return math sqrt rise rise travel travel left implement equals hashcode public int hashcode return int _x _y public boolean equals object obj obj return true obj null obj getclass getclass return false point point obj return getx getx gety gety works pointclass holds coordinates member variables variables initialized constructor changed determine distance point point code treats points corners angled triangle pythagorasõ theorem determine length hypotenuse triangle distance points code determines points equal required points consid ered equal matching coordinates code simply compares coordinates points returns trueif thatõs pointclass model slope outtesting slope writing test case proves slope itõs vertical package wrox algorithms geometry import junit framework testcase public class slopetest extends testcase public void testisvertical asserttrue slope  isvertical chapter _596748 ch18 qxd    asserttrue slope  isvertical asserttrue slope  isvertical assertfalse slope  isvertical assertfalse slope  isvertical create test prove slope determine parallel slope standard equals method public void testequals asserttrue slope  equals slope  asserttrue slope  equals slope  assertfalse slope  equals slope  assertfalse slope  equals slope  asserttrue slope  equals slope  create test method ensure nonvertical slope calculate double public void testasdoublefornonverticalslope assertequals slope  asdouble assertequals slope  asdouble assertequals slope  asdouble assertequals slope  asdouble assertequals slope  asdouble assertequals slope  asdouble assertequals slope  asdouble assertequals  slope  asdouble finally verify silly calculate slope vertical doublevalue exception thrown message public void testasdoublefailsforverticalslope slope  asdouble fail blown catch illegalstateexception assertequals vertical slope represented double getmessage works code assumes slopeobject instantiated providing integer values rise travel slope remember represent fixed point dimensional space likewise slope length purely interested rep resenting slope lines points share slope lines share slope parallel represented code test proves slope determine equal slope achieved providing positive negative test cases ensure implementation robust computational geometry _596748 ch18 qxd    recall description formula mx mis floating point valuethat ratio rise travel preceding test code assertions establish implementation correctly calculate separate tests deal vertical lines deal nonvertical lines attempting calculate vertical impossible tests prove raise exception passing set tests robust implementation weõll build outimplementing slope slope implementation pair final member variables constructor initialize package wrox algorithms geometry public class slope private final double _rise private final double _travel public slope double rise double travel _rise rise _travel travel implement isvertical trivial public boolean isvertical return _travel implement hashcode equals determine slopes public int hashcode return int _rise _travel public boolean equals object object object return true object null object getclass getclass return false slope slope object isvertical isvertical return true isvertical isvertical chapter _596748 ch18 qxd    return false return asdouble asdouble finally calculate numerical representation slope careful avoid vertical lines public double asdouble isvertical throw illegalstateexception vertical slope representedas double return _rise _travel works classes member variables final initialized structor slopeclass basic structure class familiar determining slopes equal challenging implement simple hashcode build equals implementation cases mind case slopes vertical case equal case oneof slopes vertical case equal finally general case slopes equal representation doubleratio code eliminate cases involving vertical slopes attempting calculate numerical representation slope final method calculates ratio slopeõs rise travel doublevalue trick toavoid dividing slope vertical code deals issue throwing exception set tests determine qualities including point falls vertical parallel outtesting class final class intersection problem writing series test cases define functionality lineto provide start test proves linewhether pointñthat pointfalls package wrox algorithms geometry import junit framework testcase public class linetest extends testcase public void testcontainsfornonverticalline point point  point point  asserttrue computational geometry _596748 ch18 qxd    asserttrue asserttrue point  asserttrue point  asserttrue point   assertfalse point   assertfalse point  assertfalse point  assertfalse point  separately test functionality vertical special case covered public void testcontainsforverticalline point point  point point  asserttrue asserttrue asserttrue point  asserttrue point  asserttrue point  assertfalse point  assertfalse point  assertfalse point  assertfalse point  parallel careful treat vertical lines special case test proves correct behavior lines parallel vertical public void testisparallelfortwononverticalparallellines point point  point point  point point  point point  asserttrue isparallelto asserttrue isparallelto chapter _596748 ch18 qxd    test behavior nonvertical nonparallel lines public void testisparallelfortwononverticalnonparallellines point point  point point  point point  point point  assertfalse isparallelto assertfalse isparallelto test address edge casesñfirst lines vertical fore definition parallel public void testisparallelfortwoverticalparallellines point point  point point  point point  point point  asserttrue isparallelto asserttrue isparallelto final test isparallel method case lines vertical otheris public void testisparallelforoneverticalandonenonverticalline point point  point point  point point  point point  assertfalse isparallelto assertfalse isparallelto define tests determining point intersection lines create method linecalled intersectionpoint passed lineobject method beallowed return nullif lines intersect pointobject defines point intersec tion extra care cover cases involving vertical lines computational geometry _596748 ch18 qxd    prove nonvertical lines parallel correctly determined intersection test method public void testparallelnonverticallinesdonotintersect point point  point point  point point  point point  assertnull intersectionpoint assertnull intersectionpoint establish behavior pair vertical lines public void testverticallinesdonotintersect point point  point point  point point  point point  assertnull intersectionpoint assertnull intersectionpoint test case lines easily determined point intersection prove works expected public void testintersectionofnonparallelnonverticallines point point  point point  point point  point point  point point  assertequals intersectionpoint assertequals intersectionpoint cover case lines vertical chapter _596748 ch18 qxd    public void testintersectionofverticalandnonverticallines point point  point point  point point  point point  point point  assertequals intersectionpoint assertequals intersectionpoint finally lines arranged theoretical point intersection lines long include point lines lines called disjointlines figure  pair disjoint lines theoretical point intersec tion marked figure  pair disjoint lines code ensure correct behavior case public void testdisjointlinesdonotintersect point point  point point  point point  point point  assertnull intersectionpoint assertnull intersectionpoint y x y x    computational geometry _596748 ch18 qxd    works preceding test cases work examples lines intersect vertical tests drive implementation cover suchcases assume cases covered lot test cases remember testing lot behaviors require tests ways break functionality multiple classes slopeclass created implement lineclass pass tests outimplementing class lineclass instance members pointobjects define points aslopeobject encapsulate slope create fields constructor package wrox algorithms geometry public class private final point _p private final point _q private final slope _slope public point point assert null point defining null assert null point defining null _p _q _slope slope _p gety _q gety _p getx _q getx implement isparallelto method relying slopeõs ability determine itis equal slope public boolean isparallelto return _slope equals _slope implement method determine supplied point public boolean point iswithin getx _p getx _q getx return false iswithin gety _p gety _q gety return false _slope isvertical return true chapter _596748 ch18 qxd    return gety solvey getx create method calculate coordinate point coordinate private double solvey double return _slope asdouble base create method determine bin formula mx private double base return _p gety _slope asdouble _p getx create simple utility determine number range numbers private static boolean iswithin double test double bound1 double bound2 return test math min bound1 bound2 test math max bound1 bound2 create method determines intersection point lines public point intersectionpoint isparallelto return null double getintersectionxcoordinate double getintersectionycoordinate point point return return null support preceding code create method determine coordinate theoretical point intersection lines private double getintersectionxcoordinate _slope isvertical return _p getx _slope isvertical computational geometry _596748 ch18 qxd    return _p getx double _slope asdouble double base double _slope asdouble double base return finally create method determine coordinate point intersection private double getintersectionycoordinate double _slope isvertical return solvey return solvey works lineclass instance members pointobjects define points aslopeobject encapsulate slope functionality lineclass provided encapsulated member objects determine parallel anotherline simply determine respective slopes equal determine point falls pointõs coordinate falls range coordinates defined points point repeat process coordinate span point question candidate fact vertical canconclude point figure  point passed tests figure  point coordinates span final check determine pointõs coordinates sense plugged formula mx create solvey  chapter _596748 ch18 qxd    coordinate calculates coordinate pointõs coordinates evaluate correctly point lies heart matter determining intersection point lines basic ideais lines parallel intersection point arenõt determine coordi nate theoretical intersection point determine coordinate theoretical intersection point finally confirm lines theoreti cal intersection point returning determine coordinate intersection point determine question vertical answer coordinate point vertical formula earlier determine coordinate intersection point final method determines coordinate point intersection guard case lines vertical wonõt vertical simply nonvertical calculate coordinate point intersection tests work nicely abstracted set classes representing geometrical concepts tested valuable functionality challenge finding closest pair arbitrary set points finding closest pair points imagine large set scattered points figure  figure  number scattered points pair points closest thatõs pretty easyñjust compare point point compute distance remember pair points minimum distance work forming anallergy brute force solutions process item relation item wonõt bother implementing naive solution problem algorithm plane sweep algorithm    computational geometry _596748 ch18 qxd    plane sweep algorithm considers point order left coordinate single pass sweep dimensional plane points remembering smallest distance points separated minimum distance itõs easier understand algorithm progressed figure  state algorithm point left processed axes removed avoid cluttering diagram figure  plane sweep algorithm progress notice figure identified closest pair points separated distance thepoint considered sweep progresses treated edge ectangular box referred drag net key thing notice drag net width isalso dñthat create imaginary box behindthe current point wider distance current closest pair points thatõs mouthful sense idea point considered pair point left closer pair current closest pair point pair lie drag net form closer pair identified pair algorithm checks distance point sweep points drag net deter combination forms closer pair identified closer pair algorithm proceeds smaller drag net point processed depending distribution points comparisons required amore advanced form algorithm ignore points drag net farther dfrom point considered direction restricting number comparisons figure  situation points processed main aspects implementing plane sweep algorithm points sorted coordinates scanned algorithm thing sort points logical order involves creating comparator plugged sorting algorithm write tests comparator sweep rectiondddragnet458chapter _596748 ch18 qxd    figure  algorithm complete outtesting xy point comparator start simple test proves points equal correctly handled comparatorñthat result package wrox algorithms geometry import junit framework testcase public class xypointcomparatortest extends testcase private final xypointcomparator _comparator xypointcomparator instance public void testequalpointscomparecorrectly point point  point point  assertequals _comparator compare assertequals _comparator compare test prove points sort coordinate expect setting points testing relative public void testxcoordinateisprimarykey point point  point point  point point  assertequals _comparator compare assertequals _comparator compare assertequals _comparator compare assertequals _comparator compare sweep rectiondddragnet459computational geometry _596748 ch18 qxd    assertequals _comparator compare assertequals _comparator compare finally test establish points coordinates account coordinates hereõs code test public void testycoordinateissecondarykey point point  point point  point point  assertequals _comparator compare assertequals _comparator compare assertequals _comparator compare assertequals _comparator compare assertequals _comparator compare assertequals _comparator compare works comparator sort points coordinates negative coordinates precede positive points share coordinate sort arbitrarily choose sort coordi nate circumstance wondering handle points ycoordinates answer wonõt thatñby simply setto pointsunder consideration recall semantics setdo duplicate items pointobjects considered equal coordinates previous tests work creating broad set cases asserting comparator expected behavior comparator implement outimplementing xypointcomparator start declaring singleton instance private constructor object state package wrox algorithms geometry import wrox algorithms sorting comparator public final class xypointcomparator implements comparator public static final xypointcomparator instance xypointcomparator private xypointcomparator chapter _596748 ch18 qxd    implement compare delegates typed version casting parameters pointobjects public int compare object left object throws classcastexception return compare point left point finally create typed version compare public int compare point point throws classcastexception int result double getx compareto double getx result return result return double gety compareto double gety works donõt concerned comparator takes fewer lines code accompanying unit testñ itõs perfectly normal method implement compare delegates typed version casting parameters pointobjects throw classcastexceptionwhenobjects points passed explicitly allowed comparatorinterface implementation compare method objects class point real logic lives return based coordinates respective objects equal method coordinates account comparator place ready implement plane sweep algorithm assume algorithms solve problem ing closest pair exercises chapter create abstract test prove behavior implementations extend test specific version algorithm outtesting plane sweep algorithm define abstract factory method specific implementations instantiate algo rithm class package wrox algorithms geometry import wrox algorithms sets listset import wrox algorithms sets set import junit framework testcase public abstract class abstractclosestpairfindertestcase extends testcase protected abstract closestpairfinder createclosestpairfinder computational geometry _596748 ch18 qxd    test case simply proves supply set points nullin return public void testemptysetofpoints closestpairfinder finder createclosestpairfinder assertnull finder findclosestpair listset itõs pretty hard closest pair thereõs single point prove case nullas return public void testasinglepointreturnsnull closestpairfinder finder createclosestpairfinder set points listset points add point  assertnull finder findclosestpair points case occurs points provided input set case itõs easy determine closest pair test code public void testasinglepairofpoints closestpairfinder finder createclosestpairfinder set points listset point point  point point  points add points add set pair finder findclosestpair points assertnotnull pair assertequals pair size asserttrue pair asserttrue pair interesting case imagine points evenly spaced pair closest pair youõd algorithm pair encounters sweep depend comparator created sort points test public void testthreepointsequallyspacedapart closestpairfinder finder createclosestpairfinder set points listset point point  point point  chapter _596748 ch18 qxd    point point  points add points add points add set pair finder findclosestpair points assertnotnull pair assertequals pair size asserttrue pair asserttrue pair asimilar case occurs larger set points pairs distance decide algorithm return pair encounters prove test case public void testlargesetofpointswithtwoequalshortestpairs closestpairfinder finder createclosestpairfinder set points listset points add point  points add point  points add point  points add point  points add point  points add point  points add point  points add point  points add point  set pair finder findclosestpair points assertnotnull pair assertequals pair size asserttrue pair point  asserttrue pair point  finally extend abstract test case making version specific plane sweep algo rithm package wrox algorithms geometry public class planesweepclosestpairfindertest extendsabstractclosestpairfindertestcase protected closestpairfinder createclosestpairfinder return planesweepclosestpairfinder instance computational geometry _596748 ch18 qxd    works test cases preceding code works number unusual cases set points set points item set points items items distance number test cases behigher expect indication complexity problem youõre solve individual test method simple implement algorithm tests pass outcreating closestpairfinder interface interface defines algorithm simple single method accepts setof pointobjects returns setcontaining pointobjects closest pairin original set points return nullif determine closest pair forexample pointprovided package wrox algorithms geometry import wrox algorithms sets set public interface closestpairfinder public set findclosestpair set points outimplementing plane sweep algorithm create declaration class including binary inserter enable turn setofpoints receive sorted list package wrox algorithms geometry import wrox algorithms bsearch iterativebinarylistsearcher import wrox algorithms bsearch listinserter import wrox algorithms iteration iterator import wrox algorithms lists arraylist import wrox algorithms lists list import wrox algorithms sets listset import wrox algorithms sets set public final class planesweepclosestpairfinder implements closestpairfinder public static final planesweepclosestpairfinder instance newplanesweepclosestpairfinder private static final listinserter inserter listinserter iterativebinarylistsearcher xypointcomparator instance private planesweepclosestpairfinder chapter _596748 ch18 qxd    algorithm closest pair code public set findclosestpair set points assert points null points null points size return null list sortedpoints sortpoints points point point sortedpoints point point sortedpoints return findclosestpair sortedpoints create method explained private set findclosestpair point point list sortedpoints set result createpointpair double distance distance int dragpoint int sortedpoints size point point sortedpoints double sweepx getx double dragx sweepx distance point sortedpoints dragpoint getx dragx dragpoint int dragpoint point test point sortedpoints double checkdistance distance test checkdistance distance distance checkdistance result createpointpair test return result preceding code relies method arrange points coor dinates comparator defined earlier chapter private static list sortpoints set points assert points null points null list list arraylist points size iterator points iterator computational geometry _596748 ch18 qxd    isdone inserter insert list current return list utility method simple create setto represent closest pair pointobjects private set createpointpair point point set result listset result add result add return result works plane sweep algorithm implements closestpairfinderinterface defined preceding implemented singleton private constructor state early exit points comprise single pair sort points coordinates sorted list extract pointobjectsand assume closest pair delegate method sweeps remaining points determine pairs closer initial pair method heart plane sweep algorithm itõs complex methods class examine carefully refer figure  figure  illustrate algorithm earlier chapter confirm understanding works principle private set findclosestpair point point list sortedpoints set result createpointpair double distance distance int dragpoint int sortedpoints size point point sortedpoints double sweepx getx double dragx sweepx distance point sortedpoints dragpoint getx dragx dragpoint int dragpoint point test point sortedpoints double checkdistance distance test checkdistance distance distance checkdistance result createpointpair test chapter _596748 ch18 qxd    return result note key points code resultcontains pointobjects closest pair distancerepresents identified distance closest pair width drag net dragpointis leftmost pointwithin drag net sweepxis coordinate pointunder sweep dragxis coordinate representing left edge drag net algorithm ignores points sorted list starting sweep point assumed closest pair ignores points slipped drag net advancing dragpointvariable finally checks distance point sweep points drag net updating closest pair distance closer pair identified wraps implementation plane sweep algorithm tests defined algorithm youõll pass summary chapter covered theory dimensional geometry including coor dinate points lines triangles covered geometric problems finding intersection point straight lines finding closest pair set points implemented solutions problems fully tested code barely time scratch surface subject computational geometry fascinating field covers areas including trilateration mechanism global positioning graphics computer aided design hope stimulated pursue future exercises1 implement brute force solution closest pair problem optimize plane sweep algorithm points distant vertical direction computational geometry _596748 ch18 qxd    _596748 ch18 qxd    pragmatic optimizationyou wondering chapter optimization book placement reflects philosophy optimization belong forefront mind building applications chapter describes role optimization including apply demonstrates practical techniques great performance improvements software build youõll encouraged design clean clear order business hard facts drive optimization process armed knowledge measure progress identify optimization effort stopped adding chapter learn optimization fits development process profiling works profile application standard virtual machine mechanism profile application free memory profiler tool identify performance issues cpu memory usage achieve huge performance increases small strategic alterations code optimization fits optimization software development recommend time accumulate awareness types issues affect performance programming environment mind code stringbufferto build long character sequence preferable mul tiple concatenations stringobjects matter stray dangerous territory awareness change design called premature optimization encourage resist temptation build implementation faster harder understand experience _596748 ch19 qxd    surprised performance bottlenecks applications measuring behavior yoursystem locating real issue greatest benefit simply optimized code worry code critical path surprised code youõve writtenit profiling topic key thing remember clean simple design easier optimize original developers thoughtfully optimized writing choosethe algorithm initially aware performance profile chosen implementation optimize itñthat conscious algorithm logn choosing wrong class algorithm problem hand hard limit benefits optimization provide thatõs reason chapter book experience cut program performing experience guess exact reason performance suffer ing nontrivial application writing program work making fast fact good idea separate activities developmentprojects test driven development ensure correct func tioning programs òmake workó recommend approach outlined chapter òmake fast ó tests code track alter implementationto performance unit tests remove guesswork functional success program techniques learn chapter guesswork performance success program good news programs small number bottlenecks identified addressed areas code change typically large number techniques enable prove achieved benefits recommend avoid guessing code faster relying subjective opinions codeõs performance avoid refactoring creating automated unit tests avoid optimizing automated performance measurements program takes nontrivial time bottleneck constraining perfor mance remember true program running acceptably fast optimization process goal meet objective performance criteria remove performance bottlenecks careful avoid setting impossible performance targets enable mb photo squeeze k modem seconds optimization performance toolkit skill youõll yourapplications fast good design skills knowledge trade offs choosing data structures algorithms skills disposal understanding profiling profiling process measuring behavior program lends profiling support built virtual machine youõll chapter profiling lan guages varies difficulty popular technique major areas measured profiling program cpu usage memory usage concurrency threading behavior chapter _596748 ch19 qxd    concurrency issues scope chapter check appendix afor reading topic aprofiler measures cpu usage determining long program spends method program running aware typically gathered sam pling execution stack thread virtual machine regular intervals determine methods active moment longer running programs program fast accurate program fast donõt optimize aprofiler report statistics times method calledhow cpu time consumed methodhow cpu time consumed method methods called itwhat proportion running time spent method statistics enable identify parts code benefit optimization memory usage profiler gather statistics memory usage object creation garbage collection provide objects class instantiated instances class garbage collected memory allocated virtual machine operating giventime heap size heap free time kind deeper insight runtime behavior code source informative surprises youõll chapter optimize program profiler lot evidence base optimization efforts profile program techniques profiling features built virtual machine features simple nature technique involves open source tool memory profiler jmp helpful nice graphical interface requires download install software started explains sample program profiling exercises filesortinghelper program contrived program purposes profiling optimization program simple unix style filter takes input standard input assuming word sorts prints standard output sorted order twist things comparator sort sort alphabetical order printed backwards word òantó sort word òpieó pragmatic optimization22_596748 ch19 qxd    printed backwards òtnaó òantó backwards sorts òeipó òpieó backwards simply program work harder profiling interesting donõt worry pointlessñit sample program sort list testdrivendevelopmentisonesmallstepforprogrammersbutonegiantleapforprogrammingthen youõd output oneoneprogrammingsmalldrivenleapstepforforisprogrammersgiantdevelopmenttestbuthere code comparator package wrox algorithms sorting public final class reversestringcomparator implements comparator public static final reversestringcomparator instance newreversestringcomparator private reversestringcomparator public int compare object left object throws classcastexception assert left null left null chapter _596748 ch19 qxd    assert null null return reverse string left compareto reverse string private string reverse string stringbuffer result stringbuffer int length result append charat length return result tostring thereõs great code works wonõt programs implements standard comparatorinterface assumes arguments stringobjects compares creating reversed version outimplementing filesortinghelper class filesortinghelperclass package wrox algorithms sorting import wrox algorithms iteration iterator import wrox algorithms lists linkedlist import wrox algorithms lists list import bufferedreader import ioexception import inputstreamreader public final class filesortinghelper private filesortinghelper public static void main string args throws exception sort loadwords err println finished press ctrl exit thread sleep works class private constructor prevent instantiation code main method delegates work methods loadwords sort doesan strange thingñit prints message advising kill program puts sleep thread sleep simply time profiling jmpwhen program finishes donõt worry pragmatic optimization22_596748 ch19 qxd    code sort method accepts list comparator defined shell sort implementation sort finally simply prints sorted list private static void sort list wordlist assert wordlist null tree null println starting sort comparator comparator reversestringcomparator instance listsorter sorter shellsortlistsorter comparator list sorted sorter sort wordlist iterator sorted iterator isdone println current final method sample program loadwords simply drains standard input adding listthat returned caller input issue catch ioexceptionthat private static list loadwords throws ioexception list result linkedlist bufferedreader reader bufferedreader newinputstreamreader string word word reader readline null result add word finally reader close return result compile program direct read input file command wrox algorithms sorting filesortinghelper txtto command directory compiled class files sample program create file called txtwith large number lines text aquick internet search dictionary files lead files thousands purpose appendix urlof developing book chapter _596748 ch19 qxd    pentium laptop running program file  minute cpu running percent longer prepared wait opti mization order letõs whatõs profiling program profiling hprofthe standard sun virtual machine supports basic profiling box determine yourjava environment support command xrunhprof helpthe xruncommand option loads extra modules virtual machine starts case youõre running hprofmodule youõre passing module commandñin case helpñto instructions listing output command hprof usage xrunhprof option option description default heap dump sites heap profiling allcpu samples times cpu usage offmonitor monitor contention nformat ascii binary output afile file write data file hprof txt ascii net host port send data socket write filedepth size stack trace depth cutoff output cutoff point lineno number traces ythread thread traces ndoe dump exit ygc_okay gc sampling yexample xrunhprof cpu samples file log txt depth fooclassnote format cpu timesthe preceding output parameters passed hprofto tailor behav ior parameter cpu samples sample based profiling application command profiling option sample application redirects input output files current directory xrunhprof cpu samples wrox algorithms sorting filesortinghelper txt sorted txtwhen program profiling turned noticeably slower understandable bit work required collect statistics profilers big impact performance idea relative measures time spent parts program accurate program finishes message dumping cpu usage sampling running threads pragmatic optimization22_596748 ch19 qxd    doesnõt created file working directory called hprof txtthatcontains gathered profiling open file text editor contents boilerplate text file thread start obj b76bc0 finalizer group thread start obj b76cc8 reference handler group thread start obj b76da8 main group main thread start obj b79bc0 hprof cpu profiler group threads running virtual machine hprofcreates thread work thread series small stack traces trace lang stringbuffer init unknown unknown lang stringbuffer init unknown unknown wrox algorithms sorting reversestringcomparator reverse reversestringcomparator wrox algorithms sorting reversestringcomparator compare reversestringcomparator trace wrox algorithms sorting reversestringcomparator reverse reversestringcomparator wrox algorithms sorting reversestringcomparator compare reversestringcomparator wrox algorithms sorting shellsortlistsorter sortsublist shellsortlistsorter wrox algorithms sorting shellsortlistsorter hsort shellsortlistsorter stack traces occupying bulk contents output file simply stack contents encountered sampling effort idea time sample hproflooks stack determine combination methodcalls encountered statistics updated tracerecord cre ated number trace trace21 simply identifier fartherdown profiling output shortly final output interesting program spending time lines final cpu samples total jun   rank accum count trace method1    reversestringcomparator reverse2    linkedlist getelementbackwards3    linkedlist getelementforwards4    linkedlist getelementbackwards5    linkedlist getelementforwards6    linkedlist getelementbackwards7    linkedlist getelementbackwards8    linkedlist getelementforwards chapter _596748 ch19 qxd    columns selfand accumcolumns final column identi fies method row selfcolumn percentage execution time spent method accumcolumn defines percentage time spent method methods called list ordered selfcolumn descendingorder assumption interested finding individual method consum ing time tracecolumn identifying number enables refer trace file execution stack method question improve situation youõll profiling program memory profiler profiling jmpthe memory profiler free tool download khelekore org jmp jmpcomes great documentation started youõll follow instructions carefully bear mind jmpis program installation familiar main programming environment windows copy dllinto windows directory determine jmpinstalled correctly test hprofexamplein preceding type command xrunjmp helpthis jmpto instructions jmp jmp  win initializing wanted xrunjmp options package classoptions comma separated list include text nomethods disable method profiling noobjects disable object profiling nomonitors disable monitor profiling allocfollowsfilter group object allocations filtered methods nogui jmp user interface dodump called signals dumpdir directoryr dump heapdumpfiles dumptimer automatic dump filter somefilter initial recursive filter threadtime timing methods monitorsshould thread cpu time absolute time simulator jmp perform jni tricks debug jmp xrunjmp nomethods dumpdir tmp jmpdump rabbit proxy proxy477pragmatic optimization22_596748 ch19 qxd    jmphas options tailor behavior purposes weõll simply default configuration sample program mand xrunjmp wrox algorithms sorting filesortinghelper txt sorted txtthree windows statistics figure  main jmpwindow figure  graphical view memory running application values changing time total heap size allocated virtual machine allocated object fluctuating shape graph memory constantly objects created garbage collected memory needed exceeds current total heap size allocated virtual machine requested operating extra space store objects figure  jmp windows profiling chapter _596748 ch19 qxd    jmpobjects window figure  lists interesting statistics instances virtual machine column class current number instances class maximum number instances active point running program memory current instances number instances garbage collected execution column youõll optimize program shortly jmpmethods window middle figure  statistics methods called programõs execution class method number calls long calls seconds long methods called method seconds prove extremely attempt speed sample program understanding optimization attempt optimize program aware chosen wrong algorithm absolutely wasting time attempting optimize wondering sorting program slow sorting records bubble sort donõt turn optimization answer tweaking change fact algorithm large data set plenty time coffee itõs running lunch optimization chapter book weõll assume rest chapter chosen algo rithm purposes optimization efforts good waste time optimize program bottleneck formance sound obvious extremely common developers twist knots create faster version code rarely called called application startup efforts inevitably result code harder understand harder maintain contributes performance application runs faster remember thing chapter remember donõt guesswhy program slow facts performance profiling targeted approach improving recommended approach program optimization measure performance program profiler identify contributors performance problem oneof problems preferably easier measure performance ensure change effected desired result undo change repeat steps benefits longer worth effort performance acceptable mystery method simply targeted approach based hard facts ensuring change measurable benefit technique tooptimize sample program pragmatic optimization22_596748 ch19 qxd    putting optimization practiceyouõve profiled sample application jmp youõre interested slow closer jmpmethods window figure  time figure  jmp methods window youõll notice youõre spending lot time reversing stringobjects youõre spending lot time linkedlistmanipulations ignore item list thatõs time spent screen pressed ctrl kill application figure efficient reversing stringobjects itseems easier deal linkedlistissue initially linkedlist didnõtknow coming input knew lot thought adding linkedlistwould recall sorting lot based access items list thatõs losing profiler callscolumn figure  youõll linkedlistoperations called times sort leads conclusion wrong choice data structure build ing initial list involve calls add choose data structure supports operations case thatõs based access items listhas built arraylistinstead outimplementing arraylist itõs extremely simple replace linkedlistwith arraylistin loadwords method oursample filesortinghelper private static list loadwords throws ioexception list result arraylist bufferedreader reader bufferedreader inputstreamreader string word word reader readline null result add word chapter _596748 ch19 qxd    finally reader close return result step recompile program profile command xrunjmp wrox algorithms sorting filesortinghelper txt sorted txtthis time jmpprofiler produces figure  works closer jmpmethods window figure  thereõs sign linkedlistanymore thereõs sign arraylistyou change problem worse isnõt case measure change ensure optimization efforts moving forward figure  profiling switching arraylist pragmatic optimization22_596748 ch19 qxd    figure  jmp methods window arraylist implementation notice figure  reverse method reversestringcomparatoris seconds largest method takes seconds itõs time stringreversing business youõre big step forward times reverse method calledñalmost  times seconds called fairly written method itõs issue itõs called situation clearer jmpobjects window figure  figure  jmp objects window gccolumn objects class garbage collected program execution total  objects garbage collected surely thatõs ridiculous created list wouldnõt clue number stringobjects garbage collected itõs  number calls reverse method methods window feel confident issue caused fact reversing stringobjects comparing time pairs stringobjects evaluated sorting process stringwill beinvolved multiple pairwise comparisons youõre reversing stringobjects repeatedly creat ing stringobjects time spinning thousands objects garbage collection  input reduce work program reversing stringonce reversed putting list sorting reversestringcomparatorat natural comparator reversed stringobjects eliminate tedious work current chapter _596748 ch19 qxd    sorting routine drastically reduce number temporary objects create youõll measure problem printing sorted list sorting process youõll reverse stringobjects original correct character sequences output wonõt user expects  reverse operations lot effective wonõt change measure outoptimizing filesortinghelper filesortinghelperis change create class sample code base called optimizedfilesortinghelperto implementations quick reference start optimizedfilesortinghelperclass package wrox algorithms sorting import wrox algorithms iteration iterator import wrox algorithms lists arraylist import wrox algorithms lists list import bufferedreader import ioexception import inputstreamreader public final class optimizedfilesortinghelper private optimizedfilesortinghelper filesortinghelper optimized version private constructor prevent inadvertently instantiated programs main method public static void main string args throws exception list loadwords reverseall println starting sort comparator comparator naturalcomparator instance listsorter sorter shellsortlistsorter comparator list sorted sorter sort reverseall sorted printall sorted err println finished press ctrl exit thread sleep pragmatic optimization22_596748 ch19 qxd    main method delegates work methods note loaded input stream reverseall method called toñyou guessed itñ reverse list reversed sorted naturalcomparatorthat treats normal strings strings sorted list reversed printed loadwords method unchanged filesortinghelperclass private static list loadwords throws ioexception list result arraylist bufferedreader reader bufferedreader inputstreamreader string word word reader readline null result add word finally reader close return result reverse method salvaged redundant reversestringcomparatorthat created earlier chapter private static string reverse string stringbuffer result stringbuffer int length result append charat length return result tostring reverseall method simply iterates listprovided treating element stringthat reversed list private static void reverseall list int size set reverse string printall method simple list iteration routine print elements listsup plied chapter _596748 ch19 qxd    private static void printall list stringlist iterator iterator stringlist iterator iterator iterator isdone string word string iterator current println word iterator works itõs time running optimized version sample application command jmpto profile optimizedfilesortinghelper xrunjmp wrox algorithms sorting optimizedfilesortinghelper txt sorted txtthe jmpoutput figure  figure  jmp output optimizedfilesortinghelper pragmatic optimization22_596748 ch19 qxd    closer jmpmethods window figure  determine eliminated seconds effort spent string reversing figure  jmp methods window optimizedfilesortinghelper sign reverse method list bottleneck methods note alsothat biggest contributor seconds huge improvement closer jmpobjects window figure  determine prediction reduced garbage collection panned hoped figure  jmp objects window optimizedfilesortinghelper dramatic change gccolumn total numberof objects classes garbage collected program execution  note number stringobjects garbage collected  fits expectation reversing  input verify numbers sense context change check time change profile application rounds optimization sample application dramatically reducing time bottleneck execution methods final thing leave profiling normal execution runs recall program originally minute machine jmpcommand switch wrox algorithms sorting optimizedfilesortinghelper txt sorted txt486chapter _596748 ch19 qxd    works program runs seconds thatõs times faster version typical real experience optimizing code thing didnõt thought performance writing code carefully select algorithm characteristics designed code clear sim ple lends optimization fact unplug imple mentations listand comparatorinterfaces program key achieving performance wanted summary chapter learned optimization aspect software development good understanding algorithms profiling technique gather hard facts runtime behavior code virtual machine supports profiling simple command argument syntax free memory profiler graphical view memory usage applica tion allowing problem areas address slow running program times faster targeted methodical approach optimization pragmatic optimization22_596748 ch19 qxd    _596748 ch19 qxd    afurther reading hoped book inspired delve algorithms hope youõll design patterns ideas test driven develop ment books topics peruse time youõre bookstore wealth resources internet easily typ ing keywords favorite search engine weõll leave algorithms edition parts ð4 fundamentals data structures sorting searching byrobert sedgewick addison wesley design patterns erich gamma addison wesley file structures michael folk zoellick addison wesley introduction algorithms edition thomas cormen mit press performance tuning edition jack shirazi oõreilly associates junit action vincent massol ted husted manning test driven development kent beck addison wesley test driven development apractical guide david astels prentice hall ptr art computer programming volume fundamental algorithms edition donald knuth addison wesley art computer programming volume sorting searching edition donald knuth addison wesley _596748 appa qxd    _596748 appa qxd    bresourcesapache jakarta commons jakarta apache org commonsjava memory profiler khelekore org jmp junit junit orgnational institute standards technology nist govproject gutenberg gutenberg orgunicode unicode orguniversity southern denmark department mathematics computer science imada sdu dkuniversity calgary department computer science cpsc ucalgary cawikipedia wikipedia orgword lists wordlist sourceforge net _596748 appb qxd    _596748 appb qxd    cbibliography astels astels david test driven development apractical guide prentice hall ptr beck beck kent extreme programming explained boston addison wesley beck beck kent test driven development addison wesley longman bloch bloch joshua effective addison wesley cormen cormen thomas introduction algorithms edition mit press crispin crispin lisa house testing extreme programming addison wesley fowler fowler martin refactoring addison wesley gamma gamma erich richard helm ralph johnson john vlissides design patterns addison wesley hunt hunt andy dave thomas pragmatic programmer addison wesley knuth knuth donald fundamental algorithms volume art computerprogramming edition addison wesley knuth knuth donald sorting searching volume art computer programming edition addison wesley massol massol vincent junit action manning sanchez nchez crespo dalmau daniel core techniques algorithms game programming riders publishing sedgewick sedgewick robert algorithms edition parts ð4 fundamentals data structures sorting searching addison wesley _596748 appc qxd    _596748 appc qxd    danswers exercises solutions provided appendix sample answers chapter exercises hoped provided ample opportunity youõve learned practice encourage experiment chapterõs concepts chapter exercises create iterator returns nthelement nis integergreater create predicate performs boolean predicates implement powercalculatorusing recursion iteration replace arrays iterators recursive directory tree printer create iterator holds single create iterator exercise solution package wrox algorithms iteration public class skipiterator implements iterator private final iterator _iterator private final int _skip public skipiterator iterator iterator int skip assert iterator null iterator null assert skip skip _iterator iterator _skip skip public void _iterator _596748 appd qxd    skipforwards public void _iterator skipbackwards public boolean isdone return _iterator isdone public void _iterator skipforwards public void previous _iterator previous skipbackwards public object current throws iteratoroutofboundsexception return _iterator current private void skipforwards int _skip _iterator isdone _iterator private void skipbackwards int _skip _iterator isdone _iterator previous exercise solution package wrox algorithms iteration public final class andpredicate implements predicate private final predicate _left private final predicate _right public andpredicate predicate left predicate assert left null left null assert null null _left left _right public boolean evaluate object object return _left evaluate object _right evaluate object appendix d26_596748 appd qxd    exercise solution package wrox algorithms iteration public final class recursivepowercalculator implements powercalculator public static final powercalculator instance powercalculator private recursivepowercalculator public int calculate int base int exponent assert exponent exponent return exponent base calculate base exponent  exercise solution package wrox algorithms iteration import file public final class recursivedirectorytreeprinter private static final string spaces public static void main string args assert args null args null args length err println usage recursivedirectorytreeprinter dir exit println recursively printing directory tree args print file args private static void print iterator files string indent assert files null files null files files isdone files print file files current indent private static void print file file string indent assert file null file null assert indent null indent null print indent println file getname file isdirectory answers exercises _596748 appd qxd    print arrayiterator file listfiles indent spaces exercise solution package wrox algorithms iteration public class singletoniterator implements iterator private final object _value private boolean _done public singletoniterator object assert null null _value public void _done false public void _done false public boolean isdone return _done public void _done true public void previous _done true public object current throws iteratoroutofboundsexception isdone throw iteratoroutofboundsexception return _value exercise solution package wrox algorithms iteration public final class emptyiterator implements iterator public static final emptyiterator instance emptyiterator private emptyiterator appendix d26_596748 appd qxd    public void public void public boolean isdone return true public void public void previous public object current throws iteratoroutofboundsexception throw iteratoroutofboundsexception chapter exercises write constructor arraylistthat accepts standard array initially populate list write equals method work listimplementation write tostring method work listimplementation prints tents single values surrounded square brackets separated commas ò ó ò ó list create iteratorthat work listimplementation performance implications update linkedlistto traverse backwards inserting deleting desired halfway list rewrite indexof work list create listimplementation throws unsupportedoperationexceptionif attempt modify answers exercises _596748 appd qxd    exercise solution public arraylist object array assert array null array null _initialcapacity array length clear arraycopy array _array array length _size array length exercise solution public boolean equals object object return object instanceof list equals list object false public boolean equals list null size size return false iterator iterator iterator iterator isdone isdone current equals current break return isdone isdone exercise solution public string tostring stringbuffer buffer stringbuffer buffer append isempty iterator iterator isdone buffer append current append buffer setlength buffer length appendix d26_596748 appd qxd    buffer append return buffer tostring exercise solution package wrox algorithms lists import wrox algorithms iteration iterator import wrox algorithms iteration iteratoroutofboundsexception public class genericlistiterator implements iterator private final list _list private int _current public genericlistiterator list list assert list null list null _list list public void _current public void _current _list size public boolean isdone return _current _current _list size public void _current public void previous _current public object current throws iteratoroutofboundsexception isdone throw iteratoroutofboundsexception return _list _current answers exercises _596748 appd qxd    exercise solution private element getelement int _size return getelementforwards return getelementbackwards private element getelementforwards int element element _headandtail getnext int element element getnext return element private element getelementbackwards int element element _headandtail int _size element element getprevious return element exercise solution public int indexof object assert null null int iterator iterator isdone equals current return return exercise solution package wrox algorithms lists import wrox algorithms iteration emptyiterator import wrox algorithms iteration iterator public final class emptylist implements list appendix d26_596748 appd qxd    public static final emptylist instance emptylist private emptylist public void insert int object throws indexoutofboundsexception throw unsupportedoperationexception public void add object throw unsupportedoperationexception public object delete int throws indexoutofboundsexception throw unsupportedoperationexception public boolean delete object throw unsupportedoperationexception public void clear public object set int object throws indexoutofboundsexception throw unsupportedoperationexception public object int throws indexoutofboundsexception throw unsupportedoperationexception public int indexof object return public boolean object return false public int size return public boolean isempty return true public iterator iterator return emptyiterator instance answers exercises _596748 appd qxd    chapter exercises implement thread safe queue performs waiting queue work multi threaded environment blocking implement queue retrieves values random order dealing cards deck random selection process exercise solution package wrox algorithms queues public class synchronizedqueue implements queue private final object _mutex object private final queue _queue public synchronizedqueue queue queue assert queue null queue null _queue queue public void enqueue object synchronized _mutex _queue enqueue public object dequeue throws emptyqueueexception synchronized _mutex return _queue dequeue public void clear synchronized _mutex _queue clear public int size synchronized _mutex return _queue size public boolean isempty synchronized _mutex return _queue isempty appendix d26_596748 appd qxd    exercise solution package wrox algorithms queues import wrox algorithms lists linkedlist import wrox algorithms lists list public class randomlistqueue implements queue private final list _list public randomlistqueue linkedlist public randomlistqueue list list assert list null list null _list list public void enqueue object _list add public object dequeue throws emptyqueueexception isempty throw emptyqueueexception return _list delete int math random size public void clear _list clear public int size return _list size public boolean isempty return _list isempty chapter exercises write test prove algorithms sort randomly generated list doubleobjects write test prove bubble sort insertion sort algorithms chapter stable answers exercises _596748 appd qxd    write comparator order strings dictionary order uppercase lowercase ters considered equivalent write driver program determine objects moved algorithm sort operation exercise solution public class listsorterrandomdoublestest extends testcase private static final int test_size private final list _randomlist arraylist test_size private final naturalcomparator _comparator naturalcomparator instance protected void setup throws exception super setup int test_size _randomlist add double test_size math random public void testsortingrandomdoubleswithbubblesort listsorter listsorter bubblesortlistsorter _comparator list result listsorter sort _randomlist assertsorted result public void testsortingrandomdoubleswithselectionsort listsorter listsorter selectionsortlistsorter _comparator list result listsorter sort _randomlist assertsorted result public void testsortingrandomdoubleswithinsertionsort listsorter listsorter insertionsortlistsorter _comparator list result listsorter sort _randomlist assertsorted result private void assertsorted list list int list size object list asserttrue _comparator compare list list exercise solution import wrox algorithms lists arraylist import wrox algorithms lists list import junit framework testcase public class listsorterstabilitytest extends testcase appendix d26_596748 appd qxd    private static final int test_size private final list _list arraylist test_size private final comparator _comparator fractioncomparator protected void setup throws exception super setup int test_size _list add fraction public void teststabilityofbubblesort listsorter listsorter bubblesortlistsorter _comparator list result listsorter sort _list assertstablesorted result public void teststabilityofinsertionsort listsorter listsorter insertionsortlistsorter _comparator list result listsorter sort _list assertstablesorted result private void assertstablesorted list list int list size fraction f1 fraction list fraction fraction list f1 getnumerator getnumerator f1 getdenominator getdenominator fail private static class fraction private final int _numerator private final int _denominator public fraction int numerator int denominator _numerator numerator _denominator denominator public int getnumerator return _numerator public int getdenominator return _denominator private static class fractioncomparator implements comparator answers exercises _596748 appd qxd    public int compare object left object throws classcastexception return compare fraction left fraction private int compare fraction fraction throws classcastexception return getnumerator getnumerator exercise solution public final class caseinsensitivestringcomparator implements comparator public int compare object left object throws classcastexception assert left null left null assert null null string leftlower string left tolowercase string rightlower string tolowercase return leftlower compareto rightlower exercise solution public class listsortercallcountinglisttest extends testcase private static final int test_size private final list _sortedarraylist arraylist test_size private final list _reversearraylist arraylist test_size private final list _randomarraylist arraylist test_size private comparator _comparator naturalcomparator instance protected void setup throws exception super setup int test_size _sortedarraylist add integer int test_size _reversearraylist add integer int test_size _randomarraylist add integer int test_size math random public void testworstcasebubblesort list list callcountinglist _reversearraylist bubblesortlistsorter _comparator sort list reportcalls list appendix d26_596748 appd qxd    public void testworstcaseselectionsort list list callcountinglist _reversearraylist selectionsortlistsorter _comparator sort list reportcalls list public void testworstcaseinsertionsort list list _reversearraylist list result callcountinglist arraylist insertionsortlistsorter _comparator sort list result reportcalls result public void testbestcasebubblesort list list callcountinglist _sortedarraylist bubblesortlistsorter _comparator sort list reportcalls list public void testbestcaseselectionsort list list callcountinglist _sortedarraylist selectionsortlistsorter _comparator sort list reportcalls list public void testbestcaseinsertionsort list list _sortedarraylist list result callcountinglist arraylist insertionsortlistsorter _comparator sort list result reportcalls result public void testaveragecasebubblesort list list callcountinglist _randomarraylist bubblesortlistsorter _comparator sort list reportcalls list public void testaveragecaseselectionsort list list callcountinglist _randomarraylist selectionsortlistsorter _comparator sort list reportcalls list public void testaveragecaseinsertionsort list list _randomarraylist list result callcountinglist arraylist insertionsortlistsorter _comparator sort list result reportcalls result private void reportcalls list list answers exercises _596748 appd qxd    println getname list chapter exercises implement mergesort iteratively recursively implement quicksort iteratively recursively count number list manipulations set add insert quick sort shellsort implement place version insertion sort create version quicksort insertion sort sublists smaller items exercise solution public class iterativemergesortlistsorter implements listsorter private final comparator _comparator public iterativemergesortlistsorter comparator comparator assert comparator null comparator null _comparator comparator public list sort list list assert list null list null return mergesublists createsublists list private list mergesublists list sublists list remaining sublists remaining size remaining mergesublistpairs remaining return list remaining private list mergesublistpairs list remaining list result arraylist remaining size  iterator remaining iterator isdone list left list current isdone appendix d26_596748 appd qxd    result add left list list current result add merge left return result private list createsublists list list list result arraylist list size iterator list iterator isdone list singletonlist arraylist singletonlist add current result add singletonlist return result private list merge list left list list result arraylist iterator left iterator iterator iterator isdone isdone isdone result add current isdone result add current _comparator compare current current result add current result add current return result answers exercises _596748 appd qxd    exercise solution public class iterativequicksortlistsorter implements listsorter private final comparator _comparator public iterativequicksortlistsorter comparator comparator assert comparator null comparator null _comparator comparator public list sort list list assert list null list null quicksort list return list private void quicksort list list stack jobstack liststack jobstack push range list size jobstack isempty range range range jobstack pop range size continue int startindex range getstartindex int endindex range getendindex object list endindex int partition partition list startindex endindex _comparator compare list partition partition swap list partition endindex jobstack push range startindex partition jobstack push range partition endindex private int partition list list object int leftindex int rightindex int left leftindex int rightindex left _comparator compare list left left continue _comparator compare list appendix d26_596748 appd qxd    continue swap list left left return left private void swap list list int left int left return object temp list left list set left list list set temp private static final class range private final int _startindex private final int _endindex public range int startindex int endindex _startindex startindex _endindex endindex public int size return _endindex _startindex public int getstartindex return _startindex public int getendindex return _endindex exercise solution public class advancedlistsortercallcountinglisttest extends testcase private static final int test_size private final list _sortedarraylist arraylist test_size private final list _reversearraylist arraylist test_size private final list _randomarraylist arraylist test_size private comparator _comparator naturalcomparator instance protected void setup throws exception answers exercises _596748 appd qxd    super setup int test_size _sortedarraylist add integer int test_size _reversearraylist add integer int test_size _randomarraylist add integer int test_size math random public void testworstcasequicksort list list callcountinglist _reversearraylist quicksortlistsorter _comparator sort list reportcalls list public void testworstcaseshellsort list list callcountinglist _reversearraylist shellsortlistsorter _comparator sort list reportcalls list public void testbestcasequicksort list list callcountinglist _sortedarraylist quicksortlistsorter _comparator sort list reportcalls list public void testbestcaseshellsort list list callcountinglist _sortedarraylist shellsortlistsorter _comparator sort list reportcalls list public void testaveragecasequicksort list list callcountinglist _randomarraylist quicksortlistsorter _comparator sort list reportcalls list public void testaveragecaseshellsort list list callcountinglist _randomarraylist shellsortlistsorter _comparator sort list reportcalls list private void reportcalls list list println getname list appendix d26_596748 appd qxd    public class callcountinglist implements list private final list _list private int _insertcount private int _addcount private int _deletecount private int _getcount private int _setcount public callcountinglist list list assert list null list null _list list public void insert int object throws indexoutofboundsexception _list insert _insertcount public void add object _list add _addcount public object delete int throws indexoutofboundsexception _deletecount return _list delete public object delete object _deletecount return _list delete public object int throws indexoutofboundsexception _getcount return _list public object set int object throws indexoutofboundsexception _setcount return _list set public void clear _list clear public int indexof object return _list indexof public boolean object answers exercises _596748 appd qxd    return _list public boolean isempty return _list isempty public iterator iterator return _list iterator public int size return _list size public string tostring return stringbuffer counting list append add _addcount append insert _insertcount append delete _deletecount append set _setcount append _getcount tostring exercise solution public class inplaceinsertionsortlistsorter implements listsorter private final comparator _comparator public inplaceinsertionsortlistsorter comparator comparator assert comparator null comparator null _comparator comparator public list sort list list assert list null list null int list size object list int object previousvalue list _comparator compare previousvalue break list set previousvalue list set return list appendix d26_596748 appd qxd    exercise solution public class hybridquicksortlistsorter implements listsorter private final comparator _comparator public hybridquicksortlistsorter comparator comparator assert comparator null comparator null _comparator comparator public list sort list list assert list null list null quicksort list list size return list private void quicksort list list int startindex int endindex startindex endindex list size return endindex startindex return endindex startindex doinsertionsort list startindex endindex doquicksort list startindex endindex private void doinsertionsort list list int startindex int endindex int startindex endindex object list int startindex object previousvalue list _comparator compare previousvalue break list set previousvalue list set private void doquicksort list list int startindex int endindex object list endindex int partition partition list startindex endindex _comparator compare list partition partition answers exercises _596748 appd qxd    swap list partition endindex quicksort list startindex partition quicksort list partition endindex private int partition list list object int leftindex int rightindex int left leftindex int rightindex left _comparator compare list left left continue _comparator compare list continue swap list left left return left private void swap list list int left int left return object temp list left list set left list list set temp chapter exercises priority queue implement stack priority queue implement fifoqueue priority queue implement listsorter write priority queue access smallest item largest appendix d26_596748 appd qxd    exercise solution package wrox algorithms stacks import wrox algorithms queues emptyqueueexception import wrox algorithms queues heaporderedlistpriorityqueue import wrox algorithms sorting comparator public class priorityqueuestack extends heaporderedlistpriorityqueueimplements stack private final static comparator comparator stackitemcomparator private long _count public priorityqueuestack super comparator public void enqueue object super enqueue stackitem _count public object dequeue throws emptyqueueexception return stackitem super dequeue getvalue public void push object enqueue public object pop throws emptystackexception return dequeue catch emptyqueueexception throw emptystackexception public object peek throws emptystackexception object result pop push result return result private static final class stackitem private final long _key private final object _value public stackitem long key object _key key _value public long getkey return _key public object getvalue answers exercises _596748 appd qxd    return _value private static final class stackitemcomparator implements comparator public int compare object left object throws classcastexception stackitem si1 stackitem left stackitem si2 stackitem return int si1 getkey si2 getkey exercise solution package wrox algorithms queues import wrox algorithms sorting comparator public class priorityqueuefifoqueue extends heaporderedlistpriorityqueue private static final comparator comparator queueitemcomparator private long _count long max_value public priorityqueuefifoqueue super comparator public void enqueue object super enqueue queueitem _count public object dequeue throws emptyqueueexception return queueitem super dequeue getvalue private static final class queueitem private final long _key private final object _value public queueitem long key object _key key _value public long getkey return _key public object getvalue return _value appendix d26_596748 appd qxd    private static final class queueitemcomparator implements comparator public int compare object left object throws classcastexception queueitem si1 queueitem left queueitem si2 queueitem return int si1 getkey si2 getkey exercise solution public class priorityqueuelistsorter implements listsorter private final comparator _comparator public priorityqueuelistsorter comparator comparator assert comparator null comparator null _comparator comparator public list sort list list assert list null list null queue queue createpriorityqueue list list result arraylist list size queue isempty result add queue dequeue return result private queue createpriorityqueue list list comparator comparator reversecomparator _comparator queue queue heaporderedlistpriorityqueue comparator iterator list iterator isdone queue enqueue current return queue answers exercises _596748 appd qxd    exercise solution public class minimumorientedheaporderedlistpriorityqueueextends heaporderedlistpriorityqueue public minimumorientedheaporderedlistpriorityqueue comparator comparator super reversecomparator comparator chapter exercises write recursive form minimum write recursive form search write method takes root node recursively prints values tree order write method takes root node iteratively prints values tree order write method takes root node recursively prints values tree pre order write method takes root node recursively prints values tree post order write method inserts values sorted list binary search tree maintain balance require explicit balancing add method nodeto recursively calculate size add method nodeto recursively calculate height exercise solution public node minimum return getsmaller null getsmaller exercise solution public node search object return search _root private node search object node node node null return null int cmp _comparator compare node getvalue cmp return node return search cmp node getsmaller node getlarger appendix d26_596748 appd qxd    exercise solution public void inorderprint node node node null return inorderprint node getsmaller println node getvalue inorderprint node getlarger exercise solution public void inorderprint node root node node root minimum node null node node successor println node getvalue exercise solution public void preorderprint node node node null return println node getvalue preorderprint node getsmaller preorderprint node getlarger exercise solution public void postorderprint node node node null return postorderprint node getsmaller postorderprint node getlarger println node getvalue exercise solution public void preorderinsert binarysearchtree tree list list preorderinsert tree list list size private void preorderinsert binarysearchtree tree list list int lowerindex int upperindex lowerindex upperindex answers exercises _596748 appd qxd    return int lowerindex upperindex lowerindex tree insert list preorderinsert tree list lowerindex preorderinsert tree list upperindex exercise solution public int size return size private int size node node node null return return size node getsmaller size node getlarger exercise solution public int height return height private int height node node node null return return math max height node getsmaller height node getlarger chapter exercises modify bucketinghashtableto prime number buckets performance modify linearprobinghashtableto maintain number values table thancalculate time modify bucketinghashtableto maintain number values table calcu late time create iterator access entries bucketinghashtable appendix d26_596748 appd qxd    exercise solution package wrox algorithms hashing public final class simpleprimenumbergenerator public static final simpleprimenumbergenerator instance simpleprimenumbergenerator private simpleprimenumbergenerator public int generate int candidate int prime candidate isprime prime prime return prime private boolean isprime int candidate int candidate  candidate return false return true package wrox algorithms hashing import wrox algorithms iteration iterator import wrox algorithms lists linkedlist import wrox algorithms lists list public class bucketinghashtable implements hashtable public bucketinghashtable int initialcapacity float loadfactor assert initialcapacity initialcapacity assert loadfactor loadfactor _loadfactor loadfactor _buckets bucket simpleprimenumbergenerator instance generate initialcapacity answers exercises _596748 appd qxd    exercise solution package wrox algorithms hashing public class linearprobinghashtable implements hashtable private int _size public void add object ensurecapacityforonemore int indexfor _values null _values _size public int size return _size exercise solution package wrox algorithms hashing import wrox algorithms iteration iterator import wrox algorithms lists linkedlist import wrox algorithms lists list public class bucketinghashtable implements hashtable private int _size public void add object list bucket bucketfor bucket bucket add _size maintainload public int size return _size appendix d26_596748 appd qxd    exercise solution package wrox algorithms hashing import wrox algorithms iteration emptyiterator import wrox algorithms iteration iterable import wrox algorithms iteration iterator import wrox algorithms iteration iteratoroutofboundsexception public class hashtableiterator implements iterator private final iterator _buckets private iterator _values emptyiterator instance public hashtableiterator iterator buckets assert buckets null buckets null _buckets buckets public void _buckets _values emptyiterator instance public void _buckets _values emptyiterator instance previous public boolean isdone return _values isdone _buckets isdone public void _values _values isdone _buckets isdone _buckets iterable bucket iterable _buckets current bucket null _values bucket iterator _values public void previous _values previous _values isdone _buckets isdone _buckets previous iterable bucket iterable _buckets current bucket null _values bucket iterator _values answers exercises _596748 appd qxd    public object current throws iteratoroutofboundsexception isdone throw iteratoroutofboundsexception return _values current chapter exercises write method takes sets determines equal write method takes sets produces set union write method takes sets produces set intersection write method takes sets produces set difference update delete method hashsetto free bucket itõs create set implementation sorted list create set implementation throws unsupportedoperationexceptionwhenever attempt modify exercise solution public boolean equals set set assert null null assert null null iterator iterator isdone current return false return size size exercise solution public set union set set assert null null appendix d26_596748 appd qxd    assert null null set result hashset iterator iterator isdone result add current iterator iterator isdone result add current return result exercise solution public set intersection set set assert null null assert null null set result hashset iterator iterator isdone current result add current return result exercise solution public set difference set set assert null null assert null null set result hashset iterator iterator isdone current result add current return result answers exercises _596748 appd qxd    exercise solution public boolean delete object int bucketindex bucketindexfor listset bucket _buckets bucketindex bucket null bucket delete _size bucket isempty _buckets bucketindex null return true return false exercise solution package wrox algorithms sets import wrox algorithms bsearch iterativebinarylistsearcher import wrox algorithms bsearch listsearcher import wrox algorithms iteration iterator import wrox algorithms lists arraylist import wrox algorithms lists list import wrox algorithms sorting comparator import wrox algorithms sorting naturalcomparator public class sortedlistset implements set private final list _values arraylist private final listsearcher _searcher public sortedlistset naturalcomparator instance public sortedlistset comparator comparator _searcher iterativebinarylistsearcher comparator public boolean object return indexof public boolean add object int indexof _values insert return true _values set return false public boolean delete object appendix d26_596748 appd qxd    int indexof _values delete return true return false public iterator iterator return _values iterator public void clear _values clear public int size return _values size public boolean isempty return _values isempty private int indexof object return _searcher search _values exercise solution package wrox algorithms sets import wrox algorithms iteration emptyiterator import wrox algorithms iteration iterator public final class emptyset implements set public static final emptyset instance emptyset private emptyset public boolean object return false public boolean add object throw unsupportedoperationexception public boolean delete object throw unsupportedoperationexception public void clear answers exercises _596748 appd qxd    public int size return public boolean isempty return true public iterator iterator return emptyiterator instance chapter exercises create iterator returns keys contained map create iterator returns values contained map create set implementation map underlying storage mechanism values create map throws unsupportedoperationexceptionanytime attempt ismade modify exercise solution package wrox algorithms maps import wrox algorithms iteration iterator import wrox algorithms iteration iteratoroutofboundsexception public class mapkeyiterator implements iterator private final iterator _entries public mapkeyiterator iterator entries assert entries null entries null _entries entries public void _entries public void _entries public boolean isdone return _entries isdone appendix d26_596748 appd qxd    public void _entries public void previous _entries previous public object current throws iteratoroutofboundsexception return map entry _entries current getkey exercise solution package wrox algorithms maps import wrox algorithms iteration iterator import wrox algorithms iteration iteratoroutofboundsexception public class mapvalueiterator implements iterator private final iterator _entries public mapvalueiterator iterator entries assert entries null entries null _entries entries public void _entries public void _entries public boolean isdone return _entries isdone public void _entries public void previous _entries previous public object current throws iteratoroutofboundsexception return map entry _entries current getvalue answers exercises _596748 appd qxd    exercise solution package wrox algorithms maps import wrox algorithms iteration iterator import wrox algorithms sets set public class mapset implements set private static final object object private final map _map public mapset map map assert map null map null _map map public boolean object return _map public boolean add object return _map set null public boolean delete object return _map delete public iterator iterator return mapkeyiterator _map iterator public void clear _map clear public int size return _map size public boolean isempty return _map isempty exercise solution package wrox algorithms maps import wrox algorithms iteration emptyiterator import wrox algorithms iteration iterator public final class emptymap implements map appendix d26_596748 appd qxd    public static final emptymap instance emptymap private emptymap public object object key return null public object set object key object throw unsupportedoperationexception public object delete object key throw unsupportedoperationexception public boolean object key return false public void clear public int size return public boolean isempty return true public iterator iterator return emptyiterator instance chapter exercise create iterative form search exercise solution private node search node node charsequence word int assert word null word null node null char word charat node getchar word length node node getchild break answers exercises _596748 appd qxd    node node getchar node getsmaller node getlarger return node chapter exercises implement traverse method nodeto return entries key order implement indexof method nodeto perform binary search linear search exercise solution public void traverse list list assert list null list null iterator children _children iterator iterator entries _entries iterator children entries children isdone entries isdone children isdone node children current inordertraversal list children entries isdone entry entry entry entries current entry isdeleted list add entry entries exercise solution private int indexof object key int lowerindex int upperindex _entries size lowerindex upperindex int lowerindex upperindex lowerindex int cmp _comparator compare key appendix d26_596748 appd qxd    entry _entries getkey cmp return cmp upperindex lowerindex return lowerindex chapter exercises implement brute force solution closest pair problem optimize plane sweep algorithm points distant vertical direction exercise solution package wrox algorithms geometry import wrox algorithms iteration iterator import wrox algorithms lists arraylist import wrox algorithms lists list import wrox algorithms sets listset import wrox algorithms sets set import wrox algorithms bsearch listinserter import wrox algorithms bsearch iterativebinarylistsearcher public final class bruteforceclosestpairfinder implements closestpairfinder public static final bruteforceclosestpairfinder instance newbruteforceclosestpairfinder private bruteforceclosestpairfinder public set findclosestpair set points assert points null points null points size return null list list sortpoints points point null answers exercises _596748 appd qxd    point null double distance double max_value int list size point point list int list size point point list distance distance distance distance return createpointpair private static list sortpoints set points assert points null points null list list arraylist points size iterator points iterator isdone inserter insert list current return list private set createpointpair point point set result listset result add result add return result exercise solution package wrox algorithms geometry import wrox algorithms bsearch iterativebinarylistsearcher import wrox algorithms bsearch listinserter import wrox algorithms iteration iterator import wrox algorithms lists arraylist import wrox algorithms lists list import wrox algorithms sets listset import wrox algorithms sets set public final class planesweepoptimizedclosestpairfinder implementsclosestpairfinder appendix d26_596748 appd qxd    public static final planesweepoptimizedclosestpairfinder instance newplanesweepoptimizedclosestpairfinder private static final listinserter inserter listinserter iterativebinarylistsearcher xypointcomparator instance private planesweepoptimizedclosestpairfinder public set findclosestpair set points assert points null points null points size return null list sortedpoints sortpoints points point point sortedpoints point point sortedpoints return findclosestpair sortedpoints private set findclosestpair point point list sortedpoints set result createpointpair double distance distance int dragpoint int sortedpoints size point point sortedpoints double sweepx getx double dragx sweepx distance point sortedpoints dragpoint getx dragx dragpoint int dragpoint point test point sortedpoints math abs gety test gety distance continue double checkdistance distance test checkdistance distance distance checkdistance result createpointpair test return result private static list sortpoints set points answers exercises _596748 appd qxd    assert points null points null list list arraylist points size iterator points iterator isdone inserter insert list current return list private set createpointpair point point set result listset result add result add return result appendix d26_596748 appd qxd    index27_596748 bindex qxd    _596748 bindex qxd    indexindexnumbers0 data lookup achieving hashing  sort ð147 aabstract test classcreating generic suite set tests ð299for fifo queue ð80 abstractfifoqueuetestcaseclass explanation abstracthashtabletestcaseclasseffect hash tables bucketing hash tables linear probing abstractlistsearchertestcaseusing list searcher recursive binary searcher abstractlistsorter testing ð126 abstractlistsortertest extending shellsort ð149 abstractlisttestcaseclassextending extending array lists ð60 extending linked lists ð67 extending undo redo abstractmaptestclass extending list maps abstractmaptestcaseclasscreating ð325 extending trees extending hash maps tree maps abstractpriorityqueuetest case creating ð182abstractpriorityqueuetestcaseextending sorted list priority queue extending unsorted list priority queue abstractsettestcaseclassusing hash sets list sets set tests tree sets abstractstringsearchertestcaseclass extending brute force algorithm accessors coordinates providing pointclass add methodtesting lists array lists hash sets hash tables ð290 hash tables bucketing hash tables linear probing list sets lists set tests ternary search trees  _596748 bindex qxd    add method continued tree sets  undoablelistclass unsorted list priority queue add set operation description addall method hash maps addcomparator method compoundcomparator ð160 algorithms alsodeterministic algorithms complexity ð4 definition ð2 describing pseudo code expected runtime performance representing computational effort required running quadratic time answer method center simulator argumentsfor compare operation reverse comparators array iterators implementing ð25 testing ð25 array lists alsolinked lists lists completing interface ð66 creating test class ð60 deleting values ð65 implementing methods finding values ð64 methods inserting adding values ð62methods storing retrieving values position ð63 array based problems overcoming iterators arrayindexoutofboundsexceptionclass avoiding array lists arraylistclasscreating ð61 implementing ð483 unsorted list priority queue arrays processing reverse hash tables liner probing ð280using lists assertallequals method soundex encoder  assertdistance method distance calculator assertequals methodusing junit ternary search trees ð361 assertpatternequals method ternary search trees assertprefixequals method ternary search trees asserttrue method junit associative arrays seemapsattachbefore method linked lists avl binary search trees determining rotation numbers ð238 axes relationship computational geometry ð438bbalancing binary search trees ð238 base case relationship recursive algorithms base numberdefinition raising powers baseexp significance big notation overview ð5 alsoperformance binary insertion alsolist inserter comparing algorithms ð224 comparing sorting algorithms overview ð217 binary search trees assessing performance ð263 balancing ð238 versus trees deletion ð234 implementing ð260 order traversal insertion ð231 minimum maximum overview post order traversal predecessors nodes add method continued _596748 bindex qxd    pre order traversal searching values ð230 successors nodes testing ð256 testing node classes ð244 variations binary searching iterative binary searcher ð210 versus linear searching list searcher ð205 overview ð202 performing ternary search trees ð349 recursive binary searcher ð208 binarysearchcallcountingtestclass list searcher ð213 binarysearchtreeclasscreating ð258 versus treemap ð254 black box testing explanation blocking queues overview ð86 blockingqueue code ð84 bookshelf examples selection sorts ð131 bounded queue definition boyer moore algorithm comparing brute force creating tests ð407 implementing ð407 overview ð404 brute force algorithm comparing boyer moore creating implementing ð402 bruteforcestringsearcherclass b tree map implementing ð392 btreemapclass comparator btreemaptestclass creating ð382 trees alsoindexesdeletion inserting keys overview ð381 redistributing keys testing ð382 bubble sorts alsosorting comparing sorting algorithms ð171 overview ð122 performing ð124 bubblesortlistsorterimplementing ð128 testing ð127 bucketfor method ð285 bucketindexfor method bucketing versus linear probing hash tables ð285 ð290 bucketinghashtableclass versus hashmap ccalculate method distance calculator calculations performing testing ð18 calculator implementing ð18 center simulator alsoqueuescreating class creating customerserviceagentclass features ð88 running ð96 callcenterclass creating ð92 callcentersimulatorclass creating ð94 callcountingcharsequenceclass callcountingcomparatorsorting algorithm list searcher ð215 priority queues ð195 callcountinglistcomparatorsorting algorithm ð140 callgeneratorclass creating ð93 cards insertion sorts ð136 cell values calculating levenshtein word distance ð427 character lookups counting ð411 character_map array soundex encoder  characters seeletters charat method counting calls  charsequenceclassusing counting character lookups stringsearcher class checkiterator methodusing generic suite map tests set tests ð303 child nodes comparing child nodes comparing index27_596748 bindex qxd    classcastexception throwing comparator interface classes naming unit testing clear map operation description clear methodimplementing abstractpriorityqueue trees generic suite map tests linked lists ð74 lists  peek stacks set tests stacks undoablelistclass undo redo clear queue operationdescription  clear set operation description close method center simulator ð92 closestpairfinderinterface creating collisionsrelationship hash functions resolving comparableinterface overview comparators alsoxy point comparatorand bubble sorts ð124 compound comparator ð160 natural comparators ð119 overview ð117 reverse comparators ð121 btreemapclass filesortinghelperprogram ð473using heap ordered priority queues recursive binary searcher unsorted list priority queues compare methodarguments callcountinglistcomparator ð140 compoundcomparator natural comparators reverse comparators ð120 xypointcomparator compareto method calling comparison linear searching ð212 complexitymeasures versus performance ð4 composition implementing stacks compoundcomparatorimplementing ð160 testing ð159 compressed relationship ternary search trees computational geometry coordinates points ð438 finding intersection lines ð441 finding intersection points ð444 lines ð439 overview slope ð442 triangles ð440 computelastoccurences method boyer moore algorithm ð406 constant time overview constants absence orders constructors alsoprivate constructor blockingqueue callgeneratorclass node class binary search tree consumers relationship queues map operation description methodimplementing array lists ð64 trees generic suite map tests ð328 hash sets hash tables ð290 class ð455 list maps lists ð58 set tests  ternary search trees  tree maps set operation description coordinates points role computational geometry ð438 costs operations significance levenshtein word distance ð427 cpu usage role profiling classcastexception throwing comparator interface _596748 bindex qxd    createfifoqueue abstract method explanation createlist methodimplementing implementing array lists createlistsorter methodimplementing bubblesortlistsorter ð127using shellsort createmap methodusing generic suite map tests ð326 hash maps list maps createqueue method abstractpriorityqueue createsearcher methodusing iterative binary searcher linear searcher list searcher stringsearcherinterface createset methodusing hash sets list sets createtable abstract methodusing hash tables hash tables bucketing hash tables liner probing crossword helper application creating ð374 alsoternary search trees current iterator operation description current methodusing lists stringmatchiteratorclass customerserviceagentclass creating center simulator ð90 ddefaultentryclasscreating maps ð322 trees generic suite map tests delete elements creating linked lists delete map operation description delete methodusing array lists binary search tree  trees generic suite map tests  hash sets linked lists list maps lists set tests ð302 stacks ð105 undoablelistclass ð111 undo redo  delete set operation description deletecost method distance calculator deleting values lists ð55 deletion binary search trees process ð234dequeue methodand blocking queues calling fifo queue description ð77 implementing implementing fifo queues ð82 abstractpriorityqueue heap ordered priority queues  priority queues sorted list priority queue stacks unsorted list priority queues detach method linked lists deterministic algorithms definition alsoalgorithmsdictionaries seemapsdirectory tree printing contents ð40 relationship binary search trees relationship recursion disjoint definition disk expense distance calculatorimplementing ð435 testing ð431 distance method point class ð446double valuecalculating nonvertical slope calculating ration slopeõs rise double valueindex27_596748 bindex qxd    doubly linked list definition drag net relationship plane sweep algorithm dummypredicateinner class eelement class creating linked lists ð69 emptyqueueexceptionrelationship blocking queues ð83 significance emptystackexception throwing encode method soundex encoder enqueue methodcalling fifo queue description ð77 implementing blockingqueue abstractpriorityqueue fifo queues heap ordered priority queues  priority queues sorted list priority queue  unsorted list priority queues ensurecapacity methodimplementing inverse array lists ensurecapacityforonemore method hash tables linear probing entries mapsremoving delete method significance entryfor method list maps enumerators seeiterators equals methodimplementing slope class ð449 test slope generic suite map tests ð329 hash tables ð288 maps nodeclass binary search tree using nodeclass binary search tree using pointclass equalslarger method node class binary search tree equalssmaller method node class binary search tree evaluate method predicate class  execute method undoablelistclass exponent definition ffactorial time overview ð9 fifo queues ð81 implementing ð82 significance ð76 figures adding strings hash tables binary insertion ð217 binary search tree binary search tree search ð234 binary search trees ð238 binary searching ð201 bookshelf examples selection sorts ð131 trees ð381 center simulator cards insertion sorts ð136 coordinates lines computational geometry directory tree structure disjoint lines family member examples bubble sorts ð124group members greeting heap ordered priority queues ð191 mapping names record numbers intersecting lines  keys values maps occurrence table levenshtein word distance ð428 linear probing mergesort algorithm ð166 orders complexity parallel lines plane sweep algorithm  point coordinate doubly linked list definition _596748 bindex qxd    point coordinates span priority queues ð179 producers consumers interacting queues pushing popping values stacks quadratic time quicksort lists ð154 angled triangle scattered points sets ð296 shellsort data ð148 slope  soundex encoding ð418 stack pictured vertically ternary search trees ð357 tree branches trees coordinate axes files searching ð413 filesortinghelper alsooptimizationimplementing ð475 optimizing ð487 overview ð479 filterforwards predicate class filtering iterators ð29 filteriterator predicate class methodcalling reverse iterators implementing array iterators ð25 relationship iterator idioms lists predicate class  loops iterators formulas crossing axis ð443 intersection lines intersection points ð444 lines pythagorasõ theorem functional testing explanation gc column jmp objects window examining  general case relationship recursive algorithms generatecalls method center simulator map operation description methodusing array lists ð63 trees generic suite map tests  linked lists list maps lists getcallcount method getelement method linked lists ð71 getindexoflargestelement method unsorted list priority queue getkey method maps getlarger method node class binary search tree getname method listsortercallcountingtest ð143 getroot method binary search tree getsmaller method node class binary search tree getvalue method maps hhandshakes quadratic time ð7hash functionsand collisions definition modifying hash maps testing implementing ð337 hash sets testing implementing ð309 hash tables alsolinear probingadding values ð269 assessing performance ð291 creating interface ð273 creating tests ð275 definition resizing bucketing ð285 linear probing ð280 hash definition hash definition index27_596748 bindex qxd    hashcode methodcode definition ð279 implementing implementing slope class ð449 point class hashingexample overview ð272 hashtablecallcountingtest ð288 heap ordered priority queuesexample overview ð191 testing implementing ð194 heuristics significance ð3 horizontal lines slope hprof command profiling ð477 hsort method calling shellsort ð150 sorting relationship shellsort  hypotenuse definition iid assigning calls center simulator illustrations seefigures indentation increasing spaces constant ð39indexes alsob trees implementing quicksort mapping names record numbers role mergesort algorithm quicksort  indexfor method hash tables linear probing indexof methodusing array lists ð64 trees hash tables linear probing lists  undoablelistclass indexoutofboundsexceptionthrowing lists ð51 ð54 throwing stacks loop insertionsortlistsorter order traversal binary search trees ternary search trees inordertraversal method ternary search trees insert methodusing array lists binary search tree linked lists list inserter  lists ternary search trees  tree maps tree sets undoablelistclass  insertion binary search trees process ð231insertion sorts alsosorting comparing sorting algorithms ð171 overview ð138 insertions performance binary search trees insertionsortlistsorter testing implementing ð138 instance constant soundex encoder instance member field setting null junit integerobjects listsortercallcountingtestsorting algorithm integers comparators ð117 integration testing explanation intersecting lines alsolinesdetermining coordinate ð456 testing intersection points determining  finding ð444 intersectionpoint method class isdone methoddescription implementing stringmatchiteratorclass using array iterators lists isempty methodimplementing abstractpriorityqueue array lists trees hashcode metho27_596748 bindex qxd    fifo queues linked lists ð74 lists isempty operationperforming maps performing queues performing sets performing stacks isendofword convenience method ternary search trees ð366 isfull method trees islarger method node class binary search tree isleaf method trees isparallel method lineclass  issmaller method nodeclass ofbinary search tree isvalid helper method soundex encoder isvertical method implementing slope class iterableinterfaceexplanation extending map interface iterationdefinition  performing calculations ð18 processing arrays testing lists ð57 iterative binary searcher testing implementing ð210 iterator idioms iteratorinterfacecreating predicate class stringmatchiteratorclass ð409iterator map operation description iterator methodoverview testing generic suite map tests array lists trees hash sets lists iteratorset operation description iteratoroutofboundsexception throwing lists iterators advantages array iterators ð25 creating linked lists ð73 filtering iterators ð29 reverse iterators ð28 solving array based problems jjava creating iterator interface memory profiler jmp profiling ð479jdk string class hashing algorithm jmp memory profiler profiling ð479jmp methods windowdisplaying arraylistimplementation displaying optimizedfilesortinghelperin examining linkedlist jmp objects window displaying optimizedfilesortinghelper jmp output displaying optimizedfilesortinghelper junitperforming unit tests ð14 testing array iterators ð23 kkeys deleting trees inserting trees managing btreemapclass ð387 redistributing trees key pairs maps removing delete method significance llast methodcalling reverse iterators implementing array iterators ð25 last methodindex27_596748 bindex qxd    method continued relationship iterator idioms predicate class ð34 occurrence table computing boyer moore algorithm ð406 latency definition leaf nodesand trees creating binary search tree deleting binary search trees ð233 relationship binary search trees role insertion letters alsowordsadding jdk string class algorithm ð268 adding string hashing binary insertion binary search trees ð234 ð238 binary searching ð201 trees ð381 heap ordered priority queues ð191 manipulating priority queues ð179 searching ternary search trees ð348 sets ð296 sorting quicksort ð154 sorting shellsort ð148 soundex encoding ð418 ternary search tree ð357 levenshtein word distance overview ð429levenshteinworddistancecalculatorclass description levenshteinworddistancecalculatortestclass contents lifo queues stacks classimplementing ð457 instance members testing ð454 intersections finding computational geometry ð441 linear probing alsohash tablesversus buckets relationship hashing  hash tables ð280 linear searcherversus binary searching testing implementing ð212 linear time overview linearprobinghashtableclass ð278lines alsointersecting lines determining points formula role computational geometry ð439 slopes ð442 testing slopes ð448 linked lists alsoarray lists lists completing interface ð74 creating element class ð69 creating iterators ð73 creating test class ð67 definition versus linear probing methods deleting values methods finding values ð72 methods inserting adding values ð70methods storing retrieving values ð71overview fifo queues linkedlistclassversus arraylist ð483 creating ð68 insertionsortlistsorter unsorted list priority queue list inserter alsobinary insertion assessing performance ð224 creating tests ð219 implementing ð220 listinterfacecompleting array lists ð66 creating ð46 implementing undoablelistclass ð110using array lists undo redo list maps testing implementing ð333 list searcherassessing performance ð215 creating interface ð203 creating test class ð213 creating tests ð205 implementing tests ð215 last method continued _596748 bindex qxd    iterative binary searcher writing tests ð204 list sets testing implementing ð304 listfifoqueueimplementation classcoding problems lists alsoarray lists linked lists creating generic test class ð47 implementing ð59 overview ð46 sorting ð139 versus stacks testing iteration ð57 testing methods deleting values ð55testing methods finding values ð58 testing methods inserting adding values ð50 testing methods retrieving storing values ð52 testing clearing heap ordered priority queues  listsorterinterfaceimplementing shellsort sorting listsortercallcountingtest using mergesort listsortercallcountingtestsorting algorithmextending ð143 liststackclass implementing ð104 load factor monitoring hash tables loadwords methodusing crossword helper application filesortinghelper filesortinghelperclass  lock objects blocking queues logarithmic time log log overview lookup tables seemapslooping definition lowerindexvariableusing iterative binary searcher recursive binary searcher  mmain methodof callcentersimulatorclass role searching files crossword helper application filesortinghelper ð484 maintainload method hash tables bucketing ð284 map helper method soundex encoder map implementations performance mapinterface creating map tests creating generic suite ð329 mapscreating defaultentryclass ð322 hash maps ð337 list maps ð333 overview ð320 tree maps ð343 math algorithms resource maximum method node class binary search tree  maximum binary search tree explanation merge method mergesort algorithm alsosorting algorithms comparing sorting algorithms ð171 implementing ð168 overview ð162 versus quicksort testing ð167 ð166 methodsfor deleting values array lists ð65 deleting values linked lists distinguishing junit finding values array lists ð64 finding values linked lists ð72 inserting adding values array lists ð62for inserting adding values linked lists ð70for storing retrieving values position array lists ð63 storing retrieving values linked lists ð71553methodsindex27_596748 bindex qxd    minimum method node class binary search tree  minimum binary search tree explanation minimumcost method distance calculator multiplication addition algorithm multiplyfunction demonstrating pseudo code multi threaded code resource mutexes blocking queues mutual exclusion semaphore seelock objectsnn expressionexamples meaning big notation ð5 subtracting n2 comparing small integers ð9 òname search techniquesó robert taft naming convention applying unit testing natural comparators implementing ð120 testing ð119 ð119 listsortercallcountingtest methodcalling reverse iterators lists predicate class   nodeclassimplementing binary search tree ð251 testing binary search trees ð244 trees ternary search trees nodesand trees marking ternary search trees successors nullreturning plane sweep algorithm setting instance member field junit null objects linked lists null values maps orders examples  constant time overview log log logarithmic time overview log relationship heap ordered priority queues factorial time overview ð9 linear time overview quadratic time overview ð8 open method center simulator ð92operationsorder magnitude lists optimization alsofilesortinghelper approach examples ð487 overview ð470 profiling ð471 optimizedfilesortinghelperclass code order magnitude operations significance orders iterating array orders complexity absence constants outer loopusing bubblesortlistsorter ð128 selectionsortlistsorter pparallel linesindicating proving significance parents manipulating heap oriented priority queues ð189 partition method quicksort pattern matching performing ternary search trees ð357 pattern searching comparing performance patternmatch methodusing crossword helper application ternary search trees  minimum method node class binary search tree _596748 bindex qxd    patterns searching text peek methoddescription stacks ð105 testing stacks ð102 performance alsobig notationof algorithms binary search trees ð263 brute force algorithm versus complexity ð4 hash tables ð291 levenshtein word distance list inserter ð224 list searcher ð215 map implementations set implementations string searching algorithms ð413 ternary search trees performordersearch method list searcher performrandomsearch method list searcher phonetic encoding algorithm soundex encoding phoneticencoderinterface defining soundex encoder plane sweep algorithm implementing ð467 overview ð467 testing ð464 pointclassversus class ð450 testing implementing ð446 pointsand coordinates computational geometry ð438determining position lines finding closest pair ð459 pop methoddescription stacks stacks ð101 ð105 populateandsortlist method binary inserter post order traversal binary search trees overview powercalculatorclass implementing calculate method ð18 powers raising base numbers  predecessor method node class binary search tree predecessors nodes role binary search trees predicateclassimplementing ð35 testing ð32 prefix searchingperforming ternary search trees ð353 testing ternary search trees prefixsearch method ternary search trees premature optimization definition ð470 pre order traversal binary search trees trees ð391 previous iterator operation description previous methodcalling reverse iterators lists predicate class ð34 print method recursive directory tree  printall method filesortinghelper ð485 printing directory tree contents ð40 priority queues alsoqueuescomparing implementations ð197 ð179 heap ordered priority queues ð194 overview sorted list priority queue ð186 unsorted list priority queue ð184 private constructor calculator alsoconstructors problems indicating sizes producers relationship queues profilingwith hprof command ð477 jmp ð479 relationship optimization ð471 programming coincidence significance pseudo code describing algorithms push method stacks ð101 push method stacks index27_596748 bindex qxd    push operation stacks description pythagorasõ theorem applying ð446 qquadratic time overview ð8 queue testing behavior junit ð13 queueinterfaceimplementing sorted list priority queue unsorted list priority queue queue operations overview ð77 queues alsocall center simulator priority queuesblocking queues ð86 creating center simulator interaction producers consumers interface overview ð76 versus stacks quicksort algorithm alsosorting algorithms comparing sorting algorithms ð171 implementing ð157 versus mergesort overview ð154 testing rrecursion definition ð40 overview ð37 recursive algorithms anatomy ð41 recursive binary searcher testing creating ð208redo undo stacksimplementing stacks ð106 testing ð113 reportcalls methodusing binary search tree ð263 hash tables list searcher listsortercallcountingtest using priority queues ð197 resize methodusing hash tables bucketing hash tables linear probing resourcesfor algorithms math algorithms multi threaded code reverse comparators implementing testing ð121 reverse iterators implementing testing ð28 testing lists reverse methodabsence jmp methods window foroptimizedfilesortinghelper arraylist filesortinghelper reverseall method filesortinghelper reverseiterator predicateclass ring pattern searching rise relationship slope root nodes splitting trees rotations determining avl binary search trees ð238 rpn reverse polish notation calculator stacks rules testing calculations explanations ð17run method role searching files runadd method hash tables runall method hash tables runcontains method hash tables runnableinterface implementing center simulator runscenario method priority queues  russell soundex ssearch keys recursive binary searcher push operation stacks description _596748 bindex qxd    search methodusing binary search tree ð255  brute force algorithm trees ð389 files  linear searcher list searcher ð203 recursive binary searcher stringsearcherinterface  ternary search trees ð367 tree maps tree sets searches performing boyer moore algorithm ð407 searchforpattern method crossword helper application  searchrecursively method recursive binary searcher  seek time definition selection sorts alsosorting comparing sorting algorithms ð171overview ð133 selectionsortlistsorter testing implementing ð133 sentinels linked lists separation concerns relationship sorting set implementationsperformance testing ð303 setinterfacecreating implementing tree sets plane sweep algorithm set map operation description set methoddescriptions testing lists ð52 array lists ð63 trees  generic suite map tests linked lists list maps lists  tree maps undoablelistclass undo redo setscombining hash sets ð309 intersection list sets ð305 overview ð297 tree sets ð315 setup methodoverriding junit abstractpriorityqueue abstractsortertest fifo queues generic suite map tests  hash tables list searcher  listsortercallcountingtest using priority queues set tests soundex encoder ð421 ternary search trees  setvalue methodusing maps tree maps shellsort algorithm alsosorting algorithms comparing sorting algorithms ð171 implementing ð150 testing ð149 simulator seecall center simulatorsink method heap ordered priority queues  sinking relationship heap oriented priority queues size map operation description size methodimplementing abstractpriorityqueue array lists trees hash tables linear probing linked lists ð74 size operation stacks description size operations lists size operation stacks description index27_596748 bindex qxd    size queue operation description size set operation description slopeimplementing ð449 role computational geometry ð442 testing ð448 slopeobjectinstantiation class sort methodimplementing insertionsortlistsorter using filesortinghelperclass  mergesort quicksort shellsort  sortoperation listsorterinterface sort order reversing reverse iterators sorted list depicting balanced binary search tree sorted list priority queue testing implementing ð186 sorting alsobubble sorts insertion sorts selection sorts compound comparator ð160 ð116 listsorterinterface stability ð139 testing abstractlistsorter ð126 sorting algorithms alsomergesort algorithm quicksort algorithm shellsort algorithmcomparing ð143 ð171 ð224 limitations sortsublist method shellsort soundex encoderimplementing ð425 overview ð419 testing ð423 soundexphoneticencoderclass implementing spaces constant increasing indentation ð39split method trees stabilityrelationship sorting algorithms ð139 relationship sorting compound comparator ð160 stable algorithm definition stack traces generating hprof stackoverflowexception throwing recursive algorithms stacks alsoundo redoimplementing ð105 lifo queues operations overview ð99 popping values ð105 test cases ð102 startindexfor method hash tables linear probing  stringclass jdkhashing algorithm hash tables string hashing technique stringmatchiteratorclass creating ð409stringsearcherinterfacecreating creating test class ð399 implementing withbruteforcestringsearcherclass sublists merging mergesort substitutioncost method distance calculator ð434 successor method node class binary search tree  successors nodes role binary search trees  swap methodusing bubblesortlistsorter heap ordered priority queues quicksort swim method heap ordered priority queues  swimming relationship heap ordered priority queues ð191 synchronization implementing blocking queues size queue operation description _596748 bindex qxd    ttaft robert òname search techniquesó tdd test driven development overview teardown methodimplementing abstractsortertest abstractpriorityqueue templates iterators ternary search trees alsocrossword helperapplicationimplementing ð370 inserting ð351 overview ð346 pattern matching ð357 performance performing binary searches ð349 prefix searching ð353 testing ð362 test casesfor abstractpriorityqueue ð182 stacks ð102 test classesfor binary search trees ð262 creating running undo redo ð109 creating array lists ð60 creating linked lists ð67 creating list searcher ð213 creating lists ð47 creating string searcher interface ð399 test prefix methods junit test_size constant list searcher testadd method lists testaddexistingvaluehasnoeffect method set tests testaddnewkey method set tests testbinaryinsert method binary inserter testcaseextending calculations extending abstractmaptestcaseclass testclear methodusing generic suite map tests lists set tests testcontains methodusing lists ternary search trees testcontainsnonexisting methodusing generic suite map tests set tests ð301 testdeletebyvalue method lists testdeleteexisting methodusing generic suite map tests set tests ð302 testdeletefromlastelementinarray method array lists testdeletenodewithonechild method binary search tree testdeletenonexisting method generic suite map tests testdeleteoutofbounds method lists testduplicatecodesaredropped method soundex encoder testemptytoempty method distance calculator testemptytononempty method distance calculator testequals method node class binary search tree testfirstletterisalwaysused method soundex encoder testforwarditeration method lists testgetexisting method generic suite maps testgetnonexisting method generic suite map tests testgetoutofbounds method lists testindexof method lists testingabstractsortertest ð126 binary search trees ð256 trees ð382 bubblesortlistsorter ð127 compoundcomparator ð159 distance calculator ð431 hash maps ð337 hash sets ð309 testingindex27_596748 bindex qxd    testing continued hash tables bucketing ð285 hash tables linear probing ð280 heap ordered priority queues ð194 implementing tree maps ð343 insertionsortlistsorter intersecting lines iterative binary searcher ð210 lineclass ð454 linear searcher ð212 list maps ð333 list sets ð304 mergesort algorithm ð167 natural comparators nodeclass binary search trees ð244 plane sweep algorithm ð464 pointclass ð446 quicksort algorithm recursive binary searcher ð208 clearing lists reverse comparators ð121 selectionsortlistsorter set implementations ð303 shellsort algorithm ð149 slope ð448 sorted list priority queue ð186 soundex encoder testing ð423 ternary search trees ð362 undo redo ð113 unsorted list priority queue ð184 xy point comparator ð460 testing iteration lists ð57 testing methodsfor deleting values lists ð55 finding values lists ð58 inserting adding values ð50 inserting adding values lists ð49 retrieving storing values lists ð52 testinorderinsertion method binary search trees testinsert method binary search tree testinsertbeforefirstelement method lists testinsertbetweenelements method lists testinsertintoanemptylist method lists testinsertoutofbounds method lists testiteratorbackwards methodusing generic suite map tests set tests testiteratorforwards methodusing generic suite map tests set tests testpatternmatch method ternary search trees testprefixsearch method ternary search trees testrandominsert method binary search trees testresizebeyondinitialcapacity method array lists testscreating boyer moore algorithm ð407 creating hash tables ð275 creating list inserter ð219 creating list searcher ð205 hash tables ð291 implementing list searcher ð215 writing list searcher ð204 testsameprefix method distance calculator testsearch method binary search tree testsetexistingkey method generic suite map tests testsetnewkey method generic suite map tests testsetoutofbunds method lists testsomerealstrings method soundex encoder ð423 testsuccessor method node class binary search tree testvowelsareignored method soundex encoder ð422 text searching patterns threadsgetting blockingqueue ð85 thread sleep method filesortinghelper class towers hanoi puzzle solving stacks testing continued _596748 bindex qxd    transfer time definition travel relationship slope traverse method trees tree maps testing implementing ð315 ð343trees seedirectory tree treesettestclasscreating description triangles role computational geometry ð440try class counting character lookups ð411a class searches file ð413 comparing binary inserter sorting algorithms ð224 completing interface array lists ð66 completing interface linked lists ð74computing occurrence table boyer moore algorithm ð406 creating default entry implementation maps ð322 creating generic hash table interface ð273creating generic mapinterface creating generic setinterface creating generic suite map tests ð329creating generic suite set tests ð303 creating generic test class lists ð47 creating generic test class stacks creating stringmatchiteratorclass ð409creating abstractpriorityqueuetest case ð182 creating element class linked lists ð69creating interator linked lists ð73 creating running test class undo redo ð109 creating arraylistclass ð61 creating boyermoorestringsearcherclass creating callclass simulator creating callcenterclass ð92 creating callcentersimulatorclass ð94creating callgeneratorclass ð93 creating closestpairfinderinterface creating crossword helper application ð374creating customerserviceagentclass ð90creating interface string searcher ð397creating linkedlistclass ð68 creating listinterface ð46 creating list searcher interface ð203 creating test class array lists ð60 creating test class boyer moore algorithm creating test class brute force algorithm creating test class linked lists ð67 creating test class string searcher interface ð399 creating tests hash table ð275 ð291creating tests list inserter ð219 creating tests list searcher ð205 implementing binary search tree ð260 implementing tree map ð392 implementing node class ð251 implementing ternary search tree ð370 implementing arraylist ð483 implementing running performance tests binary search trees ð263 implementing bubblesortlistsorter ð128implementing dequeue implementing insertionsortlistsorter ð138implementing mergesort ð168 implementing quicksort ð157 implementing slope ð449 implementing algorithm brute force ð402implementing array iterator ð25 implementing calculator ð18 implementing clear method try index27_596748 bindex qxd    continued implementing distance calculator ð435 implementing filesortinghelperclass ð475implementing inserter ð220 implementing class ð457 implementing liststackclass ð104 implementing natural comparator implementing plane sweep algorithm ð467implementing predicateclass ð35 implementing reversecomparator implementing reverseiterator implementing size isempty methods implementing soundex encoder ð425 implementing tests list searcher ð215implementing undo action theundoablelistclass ð113 implementing xypointcomparator ð461methods deleting values array lists ð65methods deleting values linked lists methods finding values array lists ð64methods finding values linked lists ð72methods inserting adding values array lists ð62 ð70 methods storing retrieving values position ð63 methods storing retrieving values linked lists ð71 optimizing filesortinghelper ð487 performing bubble sort ð124 performing search boyer moore algorithm ð407 popping stack ð105 testing binary search tree ð256 testing nodeclass binary search tree ð244testing shellsort ð149 testing ternary search tree ð362 testing abstractsortertest ð126 testing implementing hash map ð337testing implementing hash table bucketing ð285 testing implementing hash table linear probing ð280 testing implementing heap ordered priority queue ð194 testing implementing list map ð333 testing implementing linear searcher ð212testing implementing pointclass ð446testing trees ð382 testing bubblesortlistsorter ð127 testing calculations ð18 testing compoundcomparator ð159 testing insertionsortlistsorter testing iteration lists ð57 testing methods deleting values lists ð55testing methods finding values lists ð58testing methods inserting adding values lists ð50 testing methods retrieving storing values lists ð52 testing selectionsortlistsorter testing array iterator ð23 testing distance calculator ð431 testing fifo queue ð80 testing class ð454 testing mergesort algorithm ð168 testing naturalcomparator ð119 testing peek method stacks ð102testing plane sweep algorithm ð464 testing predicateclass ð32 testing quicksort algorithm testing reversecomparator ð121 testing reverseiterator ð27 testing slope ð448 testing soundex encoder ð423 testing xy point comparator ð460 testing list cleared using blockingqueue ð84 try continued _596748 bindex qxd    push pop methods withstacks ð101 writing tests list searcher ð204 catch block junit uunbounded queue definition undoablelistclass implementing undo action ð113 undoactioninterface implementing undodeleteactionclass undoablelist class undo redo alsostacksimplementing stacks ð106 testing ð113 unit testsimportance ð14 overview ð11 running ð14 unordered lists searching unsorted list priority queue testing implementing ð184 unsorted lists determining positions values ð64unsupportedoperationexception throwing  upperindexvariableusing iterative binary searcher recursive binary searcher  vvalue class hash tables valueiteratorclass linked lists valuesadding hash tables ð269 calculating levenshtein word distance ð427deleting array lists ð65 deleting linked lists deleting lists ð55 enqueuing dequeuing ð80 finding array lists ð64 finding linked lists ð72 finding lists ð58 inserting adding array lists ð62 inserting adding linked lists ð70 popping stacks ð105 retrieving storing lists ð52 searching binary search trees ð230 storing retrieving position array lists ð63storing retrieving linked lists ð71 enqueue dequeue operations values inserting adding lists ð49 verify method list inserter vertical lines slope testing ð453 testing functionality wwaitfornotification method blockingqueue ð85 waitfortermination method center simulator websites jmp memory profiler junit loopsusing binary search tree  insertionsortlistsorter iterative binary searcher iterators tree maps tree sets white box testing explanation widgetclass naming convention unit testing wildcard pattern character ternary search trees wildcards pattern matching ternary search trees  word distance overview ð429 _wordvariable ternary search trees words inserting ternary search trees ð351 alsoletters coordinatedetermining intersecting lines ð456 determining intersection point x coordinateindex27_596748 bindex qxd    coordinate relationship computational geometry ð438 xy point comparator testing ð460 alsocomparators xypointcomparator implementing ð461 yy axiscrossing ð443 relationship computational geometry coordinatecalculating class determining intersection point x coordinate relationship computational geometry _596748 bindex qxd   