1 previewto introduce general approach studyingalgorithms examine classic elementary problem ﬁreduce givenfraction lowest terms ﬂwe write       solving problem equival ent finding greatest commondivisor gcd numerator denominator largest integer whichdivides fraction reduced lowest terms dividing bothnumerator denominator greatest common divisor pascala concise description pascal language wirth jensenpascal user manual report serves definition language purpose repeat book toexamine implementation simple algorithms illustrate someof basic features language style pascal rigorous high level syntax easy identification ofthe main features program variables var functions function program declared ollowed body program major program parts program declaredbefore program body constants types functions format main program return set assigning function body function functions return called procedures built function readln reads input assigns thevalues variables arguments writeln standardbuilt predicate eof set true input input andoutput read write eoln declarationof input output program statement program isusing ﬁstandardﬂ input output reams  chapter to pascal program essentially transla tion definition concept greatest common divisor aprogramming language program input output var integer function gcd integer integer var integer beginif mod vmod  gcd tend beginwhile eof dobeginreadln writeln gcd abs abs endend body program trivial reads numbers theinput writes greatest common divisor output gcd function implements ﬁbrute forceﬂ method start smaller ofthe inputs test integer decreasing  reached integer divides inputs built functionabs ensure gcd called positive arguments modfunction test numbers divide mod remainderwhen divided result  divides examples pascal user manual andreport reader encouraged scan manual implement testsome simple programs read manual carefully reason ably comfortable features pascal euclid algorithma efficient method finding greatest common divisor thanthat discovered euclid years ago euclid smethod based fact greater greatestcommon divisor greatest common divisor vand applying rule successively continue subtract offmultiples number number preview11exactly remainder left dividing whatthe mod function computes greatee common divisor thesame greatest common divisor  mod mod  vdivides greatest common divisor mathematical description explains compute greatestcommon divisor numbers computing greatest common divisorof smaller numbers implement method directly pascal simply gcd function smaller arguments function gcd integer integer beginif gcd uelse gcd gcd mod note recursive calljust exchanges things work time inputs   table thevalues time gcd invoked        o           turns algorithm small number ofsteps discuss fact moire recursiona fundamental technique design efficient algorithms recursion solving problem solving smaller versions problem theprogram general approach book encounter recursion tirnes usto close features elementary recursive program essential feature recursive program terminationcondition chapter something obvious point stated probablythe common mistake recursive programming reasons oneshouldn recursive larger problem lead toa loop program attempts solve larger larger problems programming environments support general purpose recursionfacility intrinsic difficulties involved recursionis provided source unacceptable inefficiency reasons ways removing recursion easy todo recursive involved function wesimply replace recursive goto insertingsome assignment statements reset values parameters directedby recursive cleaning program left mechanicaltransformations implementation euclid algorithm function gcd integer integer var integer beginwhile dobegin mod gcd uend recursion removal complicated thanone recursive algorithm produced recognizable andindeed fferent fundamental gorithm removing recursion efficient implemen tation examples book analysis algorithmsin short chapter algorithms sameproblem problems algorithms choose implementation developed area study computer science frequently occasion describing formance fundamental algorithms comparing algorithms challenging general guidelines problems solve natural ﬁsizeﬂ theamount data processed magnitude ofthe numbers theresources time function interested average case time program expected ﬁtypicalﬂ input data worst case amountof time program worst input configuration algorithms book understood pointthat accurate mathematical formulas average worst case running time formulas developed carefully studyingthe program running time terms fundamental mathematicalquantities mathematical analysis quantities involved algorithms easy hgure running time ample brute force algorithm requires min gcd iterations loop quantity dominates running time ifthe inputs small statements executed either0  times algorithms substantial analysis volved running time recursive euclidean algorithmobviously depends ﬁoverheadﬂ required recursive whichcan determined detailed1 knowledge programming vironment number calls canbe determined extremely sophisticated mathematical analysis factors analysis programmer domain influence pascal programs aretranslated machine code computer challenging task figure long pascal statement execute environment resources shared sothat program varying performance characteristics programs extremely sensitive input data formance fluctuate wildly depending input average case mathematical fiction representative actual data program worst case bizarre construction occur practice programs understood specific mathematical finally case programs comparable runs efficiently kind input runs efficiently circumstances caveats mind rough estimates runningtime programs purposes classification secure knowledgethat fuller analysis programs rough estimates easy programmingsaw ﬁ90 time spent  code ﬂ quoted inthe values ﬁgo ﬁ step rough estimate running time programis identify loop instructions program executedmost generally instructions nested deep chapter control structure program absorb machine cycles isalways worthwhile programmer aware loop tobe unnecessary expensive instructions analysis estimate times innerloop iterated scope book themathematical mechanisms analyses fortunatelythe running times programs fall distinct classes rough description analysis programs refer literature specific references major book sophisticated mathematical argument number ofrecursive steps euclid algorithm chosen random isapproximately   r2 n mathematical analysisare exact approximate precise technical sense result mightbe expression consisting sequence decreasing terms concerned loop program concerned leading term largest term mathematical expression mentioned algorithms primary parameter number data items processed runningtime parameter degree polyno mial size file sorted searched number nodes agraph virtually algorithms book running time proportional functions most instructions programs executed mostonly times instructions program property running time constant situation strive algorithm design log nwhen running time program logarithmic programgets slower grows running time commonly occursin programs solve big problem transforming asmaller problem cutting size constant fraction forour range running time considered lessthan yargeﬂ constant base logarithm theconstant log  thebase   base  ogn twiceas great doubles log increases constant butlog double increases nwhen running time program linear generally casethat small processing input element running time prevtew15doubles running time optimal situationfor algorithm process inputs produce outputs nlogn running time arises algorithms solve problem byn2n32nbreaking smaller subpr oblems solving independently combining solutions lack adjective linearithmic running time algorithmis ﬁn log ﬂwhen log twentymillion doubles running time doubles butnot running time algorithm quadratic practicalfor small problems quadratic running timestypically algorithms process pairs data items double nested loop running time doubles running time increases fourfold algorithm prlocesses triples data items perhapsin triple nested loop cubic running time practical foruse small problems vvhen runningtime doubles running time increaseseightfold algorithms exponential running time propriate practical algorithms naturally asﬁbrute forceﬂ solutions problems runningtime doubles running time squares running time prlogram constanttimes terms ﬁleading termﬂ smaller terms thevalues constant coefficient terms included depends resultsof analysis implementation details roughly coefficient theleading term number instructions loop level algorithm design prudent limit number suchinstructions large leading term dominates smalln carefully engineered algorithms terms contribute andcomparisions algorithms difficult cases simply referto running time programs ﬁlinear ﬂ ﬁn log ﬂ ﬁcubic ﬂ withthe implicit understanding detailed analysis empirical studiesmust cases efficiency functions algorithm n2inputs running time cubic properly classedas n3j2 algorithm algorithms stages subproblemdecomposition leads running time proportional log  chapter of functions considered closer log ton2 large note ﬁlogﬂ function mentioned baseof logarithm things constant factor usuallydeal analytic constant factor matter base refer ﬁlogn ﬂ hand case concepts explained whensome specific base mathematics natz ral logarithm base   arises frequently special abbreviation commonlyused log computer science binary logarithm base  arisesso frequently abbreviation log lg commonly forexample lg rounded nearest integer number bits requiredto represent binary implementing algorithmsthe algorithms discuss book understood avoid excessively detailed comparisons goalwill identify algorithms perform fora type input application common mistake selection algorithm toignore performance characteristics faster algorithms compli cated implementors accept slower algorithm toavoid deal complexity case thata faster algorithm complicated dealing withslight complexity small price pay avoid dealing slowalgorithm users surprising number computer systems lose substantialtime waiting simple quadratic algorithms finish complicated log algorithms fraction time common mistake selection algorithmis pay attention performance characteristics log nalgorithm complicated quadratic algorithmfor problem log algorithm rise asubstantial increase complexity faster verylarge values programs times time required implement debug optimized algorithm besubstantially time required simply slower programs book basic features pascal thantaking advantage advanced capabilities pascaland programming environments purpose study algorithms systems programming advanced features programming languages preview17it hoped essential features algorithms exposedthrough simple direct implementations universal language reason programming style terse short variable names comments control structures stand theﬁdocumentationﬂ algorithms accompanying text expectedthat readers programs actual applications flesh outsomewhat adapting exercises1          solve initial problem writing pascal program reduce givenfraction lowest terms check values pascal computes mod andv positive versions gcd work properlywhen arugments original gcd program faster nonrecursiveversion euclid algorithm values time recursive gcd invoked afterthe initial gcd   pascal statements executed threegcd implementations previous exercise efficient test recursive implementationof euclid algorithm write recursive program compute largest integer log nbased fact function div  greaterthan  write iterative program problem previous exercise write program computation pascal library routines computer compare performanceof programs write program compute greatest common divisor integersu values nlgn n2 quadratic algorithmis slower nlogn sources background materiala reader interested learning pascal large numberof introductory textbooks clancy andcooper holt hune experience programming languages learn pascal effectively directly manual wirth andjensen thing learn languageis implement debug programs introductory pascal textbooks material data struc tures pascal reference infor mation basic data structures volume knuth series theart computer programming book provide encyclopediccoverage books series primary references formuch material covering book interested learning euclid algorithm fifty pagesdevoted knuth volume reason study knuth volume covers detailthe mathematical techniques needed analysis algorithms readerwith mathematical background sh ould warned substantialamount discrete mathematics required properly analyze algo rithms mathematically inclined reader material ablysummarized knuth book applied methods llbe studying books clancy cooper pascal norton company york  holt hume programming standard pascal reston prentice hall reston virginia  knuth art computer programming volume  fundamentalalgorithms addison wesley reading  knuth art computer programming volume  seminumericalalgorithms addison wesley reading edition  jensen wirth pascal user manual report springer verlag york  mathematical algorithms5 ﬁ mm    arithmeticclalgorithms elementary arithmetic operations addition multiplication division long history dating tothe origins algorithm studies work arabic mathematicianal khowdrizmi roots greeks thebabylonians situation change raison tre manycomputer systems capability fast accurate numerical cal culations computers built capabilities perform arithmetic tegers floating point representations real numbers pascalallows numbers type integer normal arithmeticoperations defined types algorithms play opera tions performed complicated mathematical objects polynomials matrices pascal implementations simplealgorithms addition multiplication polynomials matrices thealgorithms straightforward examining sophisticated algorithms problems chapter  main purpose treating ese mathematical objects objectsfor manipulation pascal programs translation abstract data tosomething processed computer fundamental algorithmdesign examples book properrepresentation lead efficient algorithm vice versa thischapter fundamental ways structuring data array andthe linked list data structures algorithms inthis book sections study advanced data structures polynomialssuppose write program adds polynomials would23 cjuj ter like perform calculations  x x3   x3 general suppose program compute polynomials coefficients followingprogram straightforward implementation polynomial addition program pojyadd input output maxn loo var array maxn real integer beginreadln read read write wri telnend program polynomial pix isrepresented array polynomial degreen defined coefficients input assumed bythe coefficients coefficients pascal decideahead time large program handle polynomialsup degree  maxn set maximum degreeanticipated inconvenient program differenttimes sizes wide range programming environments ﬁdynamic arraysﬂ case set size technique handling situation program addition trivial repre sentation polynomials chosen operations easilycoded multiply replace loop byfor  dofor dorti qb arithmeticalso declaration suita bly changed accomodate asmany coefficients product coefficients multipliedby coefficients quadratic algorithm advantage representing polynomial array itscoefficients easy reference coefficient directly disadvantageis space saved numbers program multiply     loooo      input involves oefficients output alternate represent pol ynomial linked list thisinvolves storing items noncontiguous memory locations itemcontaining address pascal mechanisms linked lists aresomewhat complicated arrays pro gram computes sum polynomials linked list representation bodies readlist add functions writelist procedure aregiven text program polyadd input output type link mode node record real link var integer link function readlist integer link procedure writelist link function add link link beginreadln writelist add readlist readlist nend polynomials represented linked lists built thereadlist procedure format type statement lists nodes node coefficient linkto node list link node list thenwe examine coefficients order links nodeon list link special dummy node called reach zwhen scanning list getby dummy nodes manipulations onthe lists simpler type statement describes formatsof nodes nodes created builtin procedure iscalled creates node putting pointer chapter it nodes lists processed program createdin readlist add routines procedure write list simplest simplysteps list writing coefficient nodeencountered procedure writelist link beginwhile dobegin write wri telnend output program indistinguishable theprogram simple array representation building list involves calling create node filling inthe coefficient linking node partial list built sofar function reads coefficients assuming formatas constructs linked list represents correspondingpolynomial function readlist integer link var integer link begint dobegin read readlist zf zf zend dummy node hold link points nodeon list list constructed list built setto link ensures reach list staythere convention convenient leave zpointing provide finally program adds polynomials constructs listin manner readlist calculating coefficients resultby stepping argument lists adding correspondingcoefficients arithm73tic27function add link link var link begint repeatnew qf qf nextuntil add zt nextend employing linked lists nodes arerequired program larger simply calls reason linked lists program clumsy comlpared array implementationabove space link storedalong coefficient suggested wecan advantage possibility coefficients list nodes represent nonzero terms polynomial byalso including degree term represented list node thateach list node values represent cxj convenientto separate function creating node adding list asfollows type link fnode node record real integer link function listadd link real integer link beginnew listadd listadd function creates node fields linksit list node readlist routine changed toaccept input format create list nodes nonzerocoefficients input coefficient exponent directly terms withnonzero coefficient write ist function changedsuitably process polynomials organized ciz4pter way list nodes increasing order degree termrepresented add function interesting performan addition terms degrees match noterm coefficient  output function add link link begint repeatif qf qf thenbegint listadd qt qf nextendelse qt thenbegin listadd endelse qf thenbegin listadd qf q1 qt add zf nextend complications worthwhile processing ﬁsparseﬂ polynomialswith coefficients array representation areonly terms coefficients savings operations polynomials multiplication matriceswe proceed manner implement basic operations dimensional matrices programs complicated pose compute sum matricesthis term term addition polynomials addition pro gram straightforward extension program polynomials arithmetic29program matrixadd input output const maxn var array maxn maxn real integer beginreadln read read doif writeln write matrix multiplication complicated operation element dot product ith row jth columnof dot product simply sum term term multiplica tions   followingprogram  dofor dobegint tend elements result matrix computed mul tiplications n3 operations required multiply nmatrices previous chapter cubicalgorithm number data items case polynomials sparse matrices elements canbe processed efficient manner linked list representation dimensional structure intact nonzero matrix elementis represented list node links pointingto nonzero element row pointing thenext nonzero element column implementing addition sparse chapter matrices represented implementation sparsepolynomials complicated fact node appears twolists data structureseven terms coefficients polynomial zeroelements matrix advantage linked list representation wedon advance big objects processingare advantage linked structures preferablein situations hand links consume asignificant space disadvantage situations access individual elements linked structures restricted arrays examples data structures algo rithms complicated data structures involve moreconstraints elements array pointers linked repre sentation multidimensional arrays defined usemultiple indices access individual items encounter manyﬁmultidimensionalﬂ linked structures pointer node tradeoffs competing structures complicated anddifferent structures turn situations wise data specific operationsto performed abstract data structure realized inseveral ways abstract data structure polynomials theexamples set coefficients user providing input theprograms linked list array modern programming systems sophisticated mechanisms change representations easily large tightly integratedsystems afuthajetic31exercises1          represent polynomials write form multiply polynomials thisrepresentation add polynomials represented exercise write pascal program multiplies polynomials linkedlist representation list node term write pascal program multiplies sparse polynomials linkedlist representation nodes terms  coefficients write pascal function returns element ithrow jth column sparse matrix assuming matrix isrepresented linked list representation nodes  entries write pascal procedure sets element ithrow jth column sparse matrix assuming matrix isrepresented linked list representation nodes  entries running time matrix multiplication terms numberof data items running time polynornial addition programs nonsparseinput depend coefficients experiment determine polynomial addition programs runs fastest computer large counterexample assertion user abstract datastructure representation  random numbersour set algorithms bie methods computer togenerate random numbers random numberslater idea conversation people term random reallymean arbitrary asks trrbitrary number thatone care number number contrast random number precisely defined mathematical concept number equally occur random number satisfysomeone arbitrary number ﬁevery number equally occurﬂ sense mustrestrict numbers finite domain arandom integer random integer range random real number random fraction range fixed precision case random number asequence random numbers needed arbitrary number mightdo mathematics prove factsabout properties sequences random numbers expectto number times long sequenceof random numbers small domain random sequences model manynatural situations great deal properties beconsistent current usage refer numbers random sequencesas random numbers produce true random numbers computer anydeterministic device program written numbers willproduce deduced random hopeto write programs produce isequences numbers ofthe properties random numbers numbers commonly calledpseudo random numbers random useful33 chaf ter as approximations random numbers floating point numbers approximations real numbers sconvenient distinction situations properties random numbers crucial irrelevant situations generate quasi random numbers properties properties random numbers applications quasi random numbers provablypreferable pseudo random numbers easy approximating property ﬁeach number equallylikely occurﬂ long sequence number inthe range loo appears sequence   loo sequenceis approximation random sequence fact random sequence length  numbers range loo islikely numbers notappear happen sequence pseudo random numbers wrong random number generator sophisticated tests based specific observations devised random number generators testing long sequence pseudo random numbers property random numbers randomnumber generators study tests talking exclusively uniform randomnumbers equally common deal randomnumbers obey distribution values morelikely pseudo random numbers uniform distributionsare performing operations uniformly distributedones applications studying uniform randomnumbers applicationslater book meet applications random numberswill outlined obvious application incryptography major goal encode message beread intended recipient chapter  oneway message random pseudo randomsequence encode message recipient thesame pseudorandom sequence decode area random numbers insimulation typical simulation involves large program models someaspect real random numbers natural input suchprograms true random numbers needed simulations typically arbitrary numbers input conveniently provided random number generator random numbers35when large data analyzed sometimessufficient process small data chosen accordingto random sampling applications widespread prominentbeing national political opinion polls choice factors considerationseem equal national draft lottery  mechanismsused college campuses decide students choice dormitoryrooms examples random numbers decision making responsibility decision ﬁfateﬂ computer readers book random numbers exten sively simulation provide random arbitrary inputs programs examples algorithms gain efficiency random numbers sampling aid decision making linear congruential methodthe method generating random numbers beenused exclusively introduced lehmer  theso called linear congruential method arbitrary number statement fills array random numbers usingthis method  doa  mod mthat random number previous multiplyit constant add  remainder divided secondconstant result integer  isattractive computers mod function trivial toimplement ignore overflow arithmetic operations puter hardware throw bits overflowed effectively perform mod operation equal largest integerthat represented computer word simple linear congruential random number generatorhas subject volumes detailed difficult mathematical analysis work guidance choosing constants someﬁcommon senseﬂ principles apply case common sense enoughto ensure good random numbers large thecomputer word size mentioned largeif inconvenient implementation beconvenient power   large ortoo small safe choice number digit chapter arbitrary constant pattern digits  requirement isadmittedly peculiar prevents occurrence bad cases thathave uncovered mathematical analysis rules developed knuth textbookcovers subject knuth choices makethe linear congruential method produce good random numbers passseveral sophisticated statistical tests potential problem apparent generator caughtin cycle produce numbers produced sooner thanit choice l9  produces thesequence       notrvery random sequence integers and  initial random number generator startedwith initial values giverise random sequences store thewhole sequence program simply maintain globalvariable initialized updated computationa mod pascal programming languages stepaway working implementation allowed ignoreoverflow defined error condition lead unpredictable suppose computer  bit word choose  f  initially  values arecomfortably largest integer represented firsta operation overflow product theoverflow relevant computation interested lasteight digits trick avoid overflow breaking multiplication pieces multiply write pr qr qo product ispq pl q1 qo lo8plql  p1qo poq1 poqo interested digits result ignorethe term digits term leads thefollowing program raajdom numbers37program random inpu output  loooo  var integer function mult integer integer var  ql q0 integer beginpl div mod ql div qo mod mult ql qo mod qo mod function random integer begina mult mod random beginread writeln random function mult program computes mod overflowas long half largest integer represented thetechnique applied values numbers produced program input    there obvious randomness numbers digits cycle digits  easy prove theformula happen generally speaking digits chapter not random leads common mistake theuse linear congruential random number generators bad program producing random numbers range   function randombad integer integer begina mult mod randombad mod random digits digits sequence desired properties problem iseasily fixed digits left compute numberbetween  computing mod overflow becircumvented implementation function randomint integer integer begina mult mod randomint div div mlend common technique generate random real numbers between0  treating numbers fractions pointto left implemented simply returning real integer user integer range simply multiplying truncating nearest integer random real number   needed additive congruential methodanother method generating random numbers based linear feedbackshift registers early cryptographic encryption machines idea start register filled arbitrary pattern thenshift step time filling vacated positions leftwith bit determined contents register diagram belowshows simple  bit register bit ﬁexclusive orﬂ ofthe rightmost bits random numbers39below listed contents register sixteen steps ofthe process                             notice nonzero bit patterns occur starting valuerepeats  steps linear congruential method mathe matics properties registers studied extensively choices ﬁtapﬂ positions bits feedback lead generation bit patterns registers ofvarious sizes interesting fact calculation word atime bit time recursion formula bitwise ﬁexclusive orﬂ successive word appears places list leadsus random number generator suitable easy implementation ageneral purpose computer feedblack register bits tappedcorresponds recursion mod keepthe correspondence shift register model ﬁ ﬂ recursionshould bitwise ﬁexclusive ﬂhowever goodrandom numbers produced normal integer addition isused termed additive congwential method implement method table size alwayshas generated num bers computation proceeds byreplacing numbers table sum othernumbers table initially tablse filled numbers thatare small large easy numbersis simple linear congruential generator knuth recommends thechoices   work applications leads theimplementation chapter procedure randinit integer begina repeat mult alj mod  function randomint integer integer beginj mod   alj  mod  jf54 mod  mod randomint div div mlend program maintains  generated numbers lastgenerated pointed global variable replaced bya table pointer large ﬁglobal stateﬂ adisadvantage generator applications advantagebecause leads extremely long cycle modulus small function randomint returns random integer  ofcourse easily changed function returns arandom real number   testing randomnessone easily detect numbers random certifying asequence numbers random difficult task mentioned sequence produced computer random sequencethat exhibits properties random numbers isoften articulate properties random numbersare application hand good idea perform kind teston random number generator degenerate situations haveturned random number generators good whenthey bad horrid tests developed determining sequenceshares properties random sequence testshave substantial basis mathematics thescope book examine statistical test chi square test fundamental nature easy implement applications examine carefully idea test check numbers producedare spread generate positive numbers rah dom nua4bers41we expect numbers frequencies ofoccurrence values berandom turns calculating sequence numbers distributed random sequence simple followingprogram function hisquare integer real var integer array rmax integer beginran nit rmax ndobegint ranndomint chisquare simply calculate sum squares frequencies occur rence scaled expected frequency subtract thesize sequence number called ﬁx2 statistic ﬂ beexprebsed mathematically asx2 wyn statistic close numbers random faraway notions ﬁcloseﬂ ﬁfar awayﬂ moreprecisely defined tables exist relate statistic properties random sequences simple test performing statistic fi valid bigger about107 test times bewrong times test simple implement includedwith random number generator ensure unexpectedcan problems ﬁgood generatorsﬂ discussedpass test ﬁbad onesﬂ generators generate numbers  statistic   chapter linear congruential method   additive congruential method   ﬁbadﬂ generator rightrhand bits linear congruential generator statistic  linear congruential method bad multiplier  statistic   range implementation notesthere number facilities commonly random numbergenerator variety applications desirable set generator function initialized called repeatedly returning random number time possibility callthe random number generator array random numbers needed computation case desirable generator produce sequence successive calls initial debugging comparison programs inputs produce arbitrary sequence debugging facilities involve manipulating ﬁstateﬂ retained random number generator calls inconvenient programming environments additive generator disadvantage large state thearray produced advantage cycle user initialize conservative protect eccentricities random numbergenerator combine generators linear congruentialgenerator initialize table additive congruential generator elementary easy implement combinationgenerator generator table chooserandom table positions fetch numbers output store numbersfrom generator debugging program random number generator isusually good idea trivial degenerate generator asone returns  returns numbers order rule random number generators fragile treatedwith respect difficult generator goodwithout investing enormous effort statistical tests devised moral good generator based mathematical analysis experience examine numbers ﬁlookﬂ random wrong blame random number generator rah dom mjm73ers43exercises1 write program generate random letter collections ofletters estimate program generate beforea word repeated  simulate generating random numbers throwing twodice sum complication dice arenonstandard painted numbers        wrong linear feedback shift register  ﬁorﬂ ﬁandﬂ function ﬁexclusive orﬂfunction work linear feedback shift registers  write program produce randorn dimensional image generate random bits write ﬁ ﬂ  generated ﬂ ﬂ  isgenerated random numbers coordinates atwo dimensional cartesian write ﬁ ﬂ addressed points  additive congruential random number generator generate positive integers  design test determine random apply test  linear congruential generator parameters choos ing generate  positive integers  design test todetermine random apply test  unwise   additivecongruential generator  statistic degenerate generator whichalways returns number  generate random numbers bigger thanthe computer word size  polynomialsthe methods arithmetic operations chapter  aresimple straightforward solutions familiar problems theyprovide excellent basis applying allgorithmic thinking produce moresophisticated methods efficient itis thing write formula implies mathematical calculation thing write computer program performs calculation efficiently operations mathematical objects diverse cataloguedhere concentrate variety algorithms manipulating polyno mials principal method study polynomial multiplication scheme practical butwhich illustrates basic design paradigm called divide conquer ispervasive algorithm design applies matrixmultiplication polynomial multiplication sections applied problems encounter book evaluationa problem arises naturally compute givenpolynomial point evaluatep x4 x3 x2 x for compute x4 compute add x3 thismethod requires recomputation powers alternate method whichrequires extra storage save powers computed simple method avoids recomputation extra spaceis homer rule alternat ing multiplication additionoperations appropriately degree polynomial evaluated only45 chapter n  multiplications additions parenthesizationp    makes order computation obvious downto  program assume array representationfor polynomials discussed chapter  complicated problem evaluate polynomial manydifferent points algorithms depending manyevaluations simul taneously large number evaluations worthwhile ﬁprecomputingﬂ reduce costfor evaluations note horner method require aboutn2 multiplications evaluate degree polynomial points sophisticated methods designed solve theproblem logn steps chapter  method usesonly log multiplications specific set points polynomial term polynomial evalua tion problem reduces exponentiation problem compute horner srule case degenerates trivial algorithm requires multiplications easy considerthe sequence computing x32 z2 x4 x8 x16 i  f7x term squaring previous term multiplica tions required  ﬁsuccessive squaringﬂ method easily extended general nif computed values saved x55 computed theabove values multiphcations general binary representation choose whichcomputed values    x8are successive squares computed bits testedwithin loop methods implement polynomlals47one ﬁaccumulator ﬂlike horner method algorithm involves scanningthe binary representation left starting  theaccumulator step square accumulator multiply zwhen  binary representation sequenceof values computed method    x6 xl226     xlzi alforithm whks bht scans toleft problem standard introductory programming exercise ishardly practical interpolationthe ﬁinverseﬂ problem problem evaluating polynomial degree nat points simultaneously problem polynomial interpolation givena set points values yn theunique polynomial degree  which1 hasp y21 yn interpolation problem polynomial set points andvalues evaluation problem values polynomial points problem finding points polynomial values root finding classic solution interpolation problem lagrange sinterpolation formula proof polynomial ofdegree  completely determined points formula formidable simple forexample polynomial degree       byp x x    s s5 jwhich simplifies tox2  formula constructed yk for1   product evaluates  evaluates chapter to  terms   lastterms   terms   convert polynomial form lagrange formulato standard coefficient representation straightforward atleast operations required terms sum consisting product factors takes clevernessto achieve quadratic algorithm factors numbers polynomials degree hand term tothe previous reader interested discover takeadvantage achieve quadratic algorithm exercise leaves onewith appreciation trivial nature writing efficient programto perform calculation implied mathematical formula polynomial evaluation sophisticated methodswhich solve problem log  steps chapter  seea method log multiplications specific set pointsof multiplicationour sophisticated arithmetic algorithm problem polynomialmultiplication polynomials compute productp chapter  polynomials degree  terms including constant product degree n  asmany n  terms  x2 x3  x s2   z3 x4  x7 naive algorithm problem implemented chapter requires multiplications polynomials degree  nterms multiplied terms improve naive algorithm powerful technique foralgorithm design called divide conquer split problem smallerparts solve recursively someway algorithms designed principle divide conquer applies thepolynomial multiplication problem analysis good estimate saved split polynomial divide coefficients half polynomial degree coefficients split twopolynomials  coefficients assume  low order coefficients polynomial  high order coefficients polmvomials49for pla definef pla ﬁ   ph    xn  splitting zn ph  ﬁn qh terms smaller polynomials product pdx ql pdxk  qh split previous chapter avoid overflow sinteresting multiplications compute theseproducts compute ql qh andtm ql qh product bycomputingp  polynomial addition requires linear algorithm straightforward poly nomial multiplication algorithm chapter  quadratic worthwhile easy additions save difficult multiplication lllook closely savings achieved method  x2 x3  x x2 x3 haveq   x x x2  x  x  x x2  x   x x2  x x2 product computed asp  x x2  x x2  x x2 x4  x x3 x4 x5 x6 divide conquer approach solves polynomial multiplication problemof size solving subproblems size  polynomialaddition set subproblems combine solutions thisprocedure easily recursive program chapter function mult array real integer array   real var  qh array div  real array red integer beginif mult elsebeginn2 div   dobegin ql dobegin qh  ql qh mult mult  mult qh  mult mult  mult  domult mult code succinct description method unfortu nately legal pascal program functions dynamically declare arrays problem handled pascal representing polync mials linked lists chapter  program assumes apower details general worked easily themain complications recursion terminates properlyand polynomials divided properly odd method multiplying integers care mustbe treat ﬁcarriesﬂ properly subtractions recursivecalls polynomial evaluation interpolation sophisticatedmethods polynomial multiplication chapter  methodthat works time proportional log polynomials51divide conquer recurrenceswhy divide conquer method iven improvement thissection simple recurrence formulas tomeasure savings achieved divide conquer algorithm recursive program clear number integer multi plications required multiply polynomials size thenumber multiplications multiply pairs polynomials size  note multiplications required compute data movement number multiplications required tomultiply polynomials size havem m           ingeneral n repeatedly apply recurrence toitself solution n m ﬂ m ﬂ  m  n n n   s31n n1s3 s3 solution exactonly n works general thatm fz nlg3 n1  substantial savings naive method note wereto multiplications simple divide conquer method recurrence m  solution n n method previous nicely illustrates divide conquer technique seldom usled practice betterdivide conquer method study chapter  thismethod dividing original subproblems extra processing recurrence describing number multiplica tions required ism m  dwell mathematics solving recur rences formulas form frequently worthwhile examine development approximate solution write  n m  ﬁ ﬂ chapter the trick making simple apply recursive formula isto divide sides n n  n  nnow applying formula times ends simply ncopies ﬁ1 ﬂ n  turns holds true roughly solutionm nlgn algorithms applications areas perfor mance characteristics recurrences type fortunately recurrences thesame techniques situation algorithm dividesthe problem solved half ignore half recursively solve running time algorithm describedby recurrencem   easier solve previous paragraph immediatelyhave i14  turns gn trivial manipula tions difficult algorithm typedescribed previous paragraph examine ele ment recursive step running time algorithm recurrencem  substituting n applying recurrence times nowgivesthis evaluated result  n   translatesto n general summarize interesting algorithms willencounter based divide conquer technique combining thesolutions recursively solved smaller subproblems running time suchalgorithms recurrence relationships adirect mathematical translation structure algorithm polynomials53such relationships challenging solve precisely easy tosolve values solutions reasonableestimates values purpo discussion gain someintuitive feeling divide conquer algorithms achieve efficiency notto detailed analysis algorithms recurrencesthat solved sufficient performance ofthe algorithms studying simply referring matrix multiplicationthe famous application divide conquer technique arith metic problem strassen method matrix multiplication gointo details sketch method polynomial multiplication method studied straightforward method multiplying matrices quires n3 scalar multiplications elements productmatrix multiplications strassen method divide size problem half cor responds dividing matrice quarters   remaining problem equivalent multiplying   matrices aswe reduce number multiplications required tothree combining terms polynomial multiplication problem strassenwas combine terms reduce number multiplica tions required   matrix multiplication problem   therearrangement terms required complicated number multiplications required matrix multiplication usingstrassen method defined divide conquer recurrencem m  solutionm n1g7 fz  result surprising appeared previouslybeen thought n3 multiplications absolutely matrixmultiplication problem studied intensively years methods strassen ﬁbestﬂalgorithm matrix multiplication oneof famous outstanding problems computer science note counting multiplications choosing algorithm practical application costs theextra additions subtractions combining terms costs chapter recursive calls considered costs depend heavily theparticular implementation computer overhead strassen method efficient standard method smallmatrices large matrices terms number data items input strassen method represents improvement  n1  improvement hard notice large nwould strassen method timesas multiplications standard method overhead permultiplication times large algorithm theoretical practical contribution illustrates general tradeoff appears applications thoughthe dramatic simple algorithms work smallproblems sophisticated algorithms reap tremendous savings large problems polynomials55exercises1 method evaluating polynomial roots   compare method horner method  write program evaluate polynomials horner method wherea linked list representation polynomials program works efficiently sparse polynomials  write program lagrang ian interpolation  suppose polynomial interpolated sparse hasfew coefficients modify lagrangianinterpolation time proportional times number coefficients  write polynomial multipllications performed divide conquer polynomial multiplication method text isused tosquare   s4 x5 x6   polynomial multiplication routinie mult efficientfor sparse polynomials returning  coefficients input are0 multiplications constant factor wouldsuch program square   x32 computed multiplications whichones  x55 computed multiplications whichones  modify mult multiply polynomial ofdegree degree  representation programs add andmultiply multivariate polynomials xy2z    givethe single reason choosing representation  gaussian eliminationcertainly fundam ental scientific computations thesolution systems simultaneous equations basic algorithm forsolving systems equations gaussian elimination simple andhas changed  years invented algorithm understood years confidence efficiently produce accurate algorithm surely mostcomputer installations primitive computer languages notably apl basic basic algorithm easy understandand implement special situations desirable implement modified version algorithm work standard subroutine method deserves learned numeric methods today mathematical material studied ourtreatment method highlight basic principles beself contained familiarity linear algebra required understandthe basic method develop simple pascal implementation mightbe easier library subroutine simple applications examples problems large orimportant application expertly tuned implementation calledfor familiarity underlying mathematics simple examplesuppose variables threeequations y     y    chapter our goal compute values variables simultaneouslysatisfy equations depending equations solution problem equations contradictory    solutions equations variables thanequations assume number equations variables thesame algorithm unique solution exists easier extend formulas cover threepoints renaming variables subscripts s1 s2       x2 x3  avoid writing variables repeatedly convenient matrixnotation express simultaneous equations equations areexactly equivalent matrix equationthere operations performed equations whichwill alter solution interchange equations order equations arewritten affect solution matrix representation operation corresponds interchanging rows matrix andthe vector hand rename variables corresponds interchanging columns thematrix representation columns switched variablesxi considered switched multiply equations constant matrix representation corresponds multiplying row matrix cor responding element vector righbhand constant add equations replace sum takes alittle thought convince oneself affect solution equations equivalent aboveby replacing equation difference gaussian elimination59notice eliminates equation manner eliminate equation replacing equationby sum variable eliminated equation sys tematically proceeding transform original ofequations solution easier solve requires step combines theoperations replacing equation difference thesecond elements maindiagonal  systems equations form easy solve simultaneous equations result xs   x2 s  s  equation solved  substitutethis equation compute x2    substituting values equation valueof computed     completes solution equations illustrates basic phases gaussian elimination forward elimination phase original trans formed systematically eliminating variables equations systemwith zeros diagonal process called triangula tion phase backward substitution phase valuesof variables computed riangulated matrix produced thefirst phase outline methodin general solve equations unknowns allxl a1222 alnxn a2121 a2252  a2nxn bz anlx1 an252 annxn chaj ter in matrix form equations written single matrix equation simply represents matrix represents variables represents rightrhand sides equations rows aare manipulated elements convenient regard asthe  column  array hold forward elimination phase summarized firsteliminate variable equation adding propriate multiple equation equations eliminate variable equations adding theappropriate multiple equation thenth equations eliminate variable threeequations eliminate ith variable jth equation tween  multiply ith equation aji aii subtract itfrom jth equation process succinctly bythe program reads  matrix performs forward elimination writes triangulated result input output ith ith row matrix program gauss input output const maxn  var array maxn maxn real integer beginreadln dobegin  read readln dofor dofor downto doab aij dobegin  write writeln gaussian ellmlnation61 polynomials wtint program takes nas input pascal decide large ﬁlegal ﬂand declare array suitably note code consists ofthree nested loops total running time essentially proportionalto n3 loop backwards avoid destroying beforeit needed adjust values elements row program paragraph simple division occur easily fixed becausewe exchange row  ith row outer loop row matrix issingular unique solution fact advisable row anon entry ith column row if1 entry ith column largest absolute reason forthis severe computational errors isused scale row small small scaling factorab eliminate ith variable jth equation large fact large todwarf actual coefficients ali point alj getsdistorted ﬁround error ﬂput simply numbers differ greatly magnitude accuratelyadded subtracted floating point number commonly torepresent real numbers small greatly increases thelikelihood operations performed largestvalue ith column rows ensure scaling factoris  prevent occurrence type error onemight contemplate ith column large element accurate answers resorting extra complication code forward elimination phase gaussian elimina tion straightforward implementation process  ton scan ith column largest element rows theith row element exchanged ith ithvariable eliminated equations chapter procedure eliminate var max integer real beginfor ndobeginmax doif abs aij abs max max dobegin max max dofor downto doab endend eliminate replace nested loops programgauss algorithms required thepivot eliminate ith variable equation theith nth process called pivoting forward elimination work process calledpartial pivoting forward elimination phase completed array hasall zeros diagonal backward substitution phase beexecuted code straightforward procedure substitute var integer real beginfor downto  dobegintr ali alj eliminate substitute computes solution inthe element array division  occur singular matrices gausslan elmnation63obviously ﬁlibraryﬂ routine check explicitly alternate proceed forward elimination created allzeros diagonal precisely method produce allzeros diagonal column adding multiple column ﬁpartial pivotingﬂ otherﬁpartﬂ column working backwards columns thisprocess called gauss jordan reduction complete diagonal elementsare yields trivial solution computational errors prime source concern gaussian elimina tion mentioned wary situations mag nitudes coefficients vastly differ largest element column partial pivoting ensures large coefficients bitrarily created pivoting process avoid severe errors small coefficients turn differentequations coefficients close actuallypossible determine advance problems inaccurate answers solution matrix haa numerical quantitycalled condition number ble estimate accuracy ofthe computed answer good library subroutine gaussian eliminationwill compute condition number matrix solution accuracy solution lknown treatment issuesinvolved scope book gaussian elimination partial pivoting largest availablepivot ﬁguaranteedﬂ produce small computational errors carefully worked mathematical thecalculated answer accurate ill conditioned matrices whichmight indicative problems equations themethod solution algorithm subject fairly detailedtheoretical studies recommended computational procedureof wide applicability variations extensionsthe method matrices withmost elements problems specialtechniques sparse matrices elements are0 situation corresponds systems equations equationhas terms elements structure linkedlist representation discussed chapter  node foreach matrix element linked row column chapter standard method implemented representation usualextra complications create destroy elements technique worthwhile afford memory hold matrix complicated standardmethod sparse matrices sparse thegaussian elimination process matrices elements havea simple structure linked lists commonexample ﬁband matrix elements fall veryclose diagonal cases loops gaussian eliminationalgorithms iterated times total running time storage requirement proportional n3 interesting special case band matrix ﬁtridiagonalﬂ matrix elements directly directly directly diagonalare general form tridiagonal matrixfor a11a12000 a22a23000a32a33a34000a43a44a45i a54a55for matrices forward elimination backward substitution reduceto single loop dobegina ifl downto  doxb  xb  forward elimination case included case skipped sets an array element examined change bemade straight gaussian elimination dimensional arrayof size tridiagonal matrix storage required forthe program reduced linear maintaining arraysinstead matrix nonzero diagonals onefor column note program pivot onthe largest element insurance division gaussian elmnation65or accumulation computational errors types tridiagonalmatrices commonly proven reason concern gauss jordan reduction implemented pivoting replacea matrix inverse sweep rough inverse matrixa written property equations couldbe solved performing matrix multiplication n3operations required compute topreprocess matrix ﬁdecomposeﬂ component parts makeit solve equations givenrightchand time proportional v2 savings factor overusing gaussian elimination time roughly involves rememberingthe operations performed  column forwardelimination phase result forward elimination  stcolumn computed efficiently substitution performed asusual solving systems linear equations computationallyequivalent multiplying matrices tlhere exist algorithms strassen matrix multiplication algorithm solve systems equations variables time proportional matrixmultiplication worthwhile method verylarge systems equations processed routinely actual running time gaussian elimination terms number inputs n312 difficult imnrove uoon nractice exercises1          matrix produced forward elimination phase gaussianelimination gauss eliminate solve equations  x z  and3x   equations unknowns gauss eliminate fails solution storage requirement gaussian elimination nmatrix n nonzero elements eliminate matrix row ofall  eliminate substitute amatrix column  arithmetic operations gauss jordan reduction backsubstitution interchange columns matrix cor responding simultaneous equations test contradictory identical equations usingeliminate gaussian elimination presented asystem equations unknowns showing pivoting largest availableelement mythical primitive computer numbers represented digits numbers form  single digit integers    curve fittingthe term curve fitting data fitting generalproblem finding function matches set observed values ata set points pointsand valuesyl yn goal function type thatf zl z2 zn ynand assumes ﬁreasonableﬂ values data points couldbe unknown function goalis function general definition ﬁreasonableﬂdepends application easy identifyﬁunreasonableﬂ functions curve fitting obvious application analysis experimental data computer graphicsto produce curves ﬁlook niceﬂ withlout overhead storing largenumber points plotted application curve fittingto provide fast algorithm computing function atan arbitrary point short table exact values curve fit othervalues principal methods approach problem isinterpolation smooth function matches thegiven values points method squares data fitting values exact function sought whichmatches  chapter polynomial interpolationwe method solving data fitting problem isknown polynomial degree  polynomial inter polation problem chapter  knowledge aboutf solve data fitting problem letting interpolatingpolynomial degree  points values becomputed methods outlined book manyreasons polynomial interpolation data fitting thing fair computation involved advanced log  methods areavailable elementary techniques quadratic computing polynomialof degree  overkill interpolating curve through100 points main problem polynomial interpolation high degreepolynomials complicated functions unexpectedproperties suited function fitted result classical mathematics weierstrass approximation theorem tells pos sible approximate reasonable function polynomial sufficientlyhigh degree polynomials high degree tend fluctuatewildly turns functions closely approximated closed interval interpolation polynomial thereare places approximation terrible theory assumes data values exact values unknown function case data values proximate approximate values unknown low degree polynomial hope coefficients high degree terms interpolating polynomial  work interpolating polynomial high degree terms achieve exact fit effects interpolating polynomials inappropriate curve fitting applications spline interpolationstill low degree polynomials simple curves easy work withanalytically curve fitting trick abandon idea polynomial points polynomials connect adjacent points piecing togethersmoothly elegant special case involves relativelystraightforward computation called spline interpolation ﬁsplineﬂ mechanical device draftsmen draw aestheticallypleasing curves draftsman fixes set points knots drawing thenbends flexible strip plastic wood spline tracesit produce curve spline interpolation mathematical equivalentof process curve curve fitting69it elementary mechanics shape assumed bythe spline adjacent knots degree cubic polynomial translated data fitting problem curve  cubic polynomialssi aix3 bix2 cix   defined cubic polynomial interval betweenxi  diagram yps ﬁ ﬁ spline represented obvious dimensionalarrays   dimensional array creating spline consistsof computing coefficients points andy values physical constraints spline correspond simultaneousequations solved yield coefficients yi yi fori    spline touch knots thespline touch knots curves smoothly sharpbends kinks mathematically derivatives thespline polynomials equal knots    fact turns derivatives polynomialsmust equal knots conditions total n  equationsin   unknown coefficients conditions specifiedto situation endpoints spline options areavailable called ﬁnaturalﬂ spline derives  xr   theseconditions n  equationsin n  unknowns solved gaussian elimination tocalculate coefficients spline spline computed efficiently becausethere  ﬁunknownsﬂ spline conditions areredundant suppose derivativeof spline _   withpr  values phr dcoefficients computed spline segments chapter equations unknowns spline segment    havesi yi   pis  fully determine spline compute values ofp21  discussion considered conditions thatthe derivatives match  conditions provide exactlythe  equations needed solve  unknowns secondderivative values express coefficients terms derivativevalues substitute expressions equations listed abovefor spline segment leads unnecessarily complicated expressions convenient express equations spline segments acertain canonical form involves fewer unknown coefficients changevariables  spline expressed thefollowing sip tyi   yi  xd2 qpi   ﬂ  pjnow spline defined interval equation formi dable interested endpoints     points trivial check splineinterpolates continuous yi  difficult verify derivative tinuous cubic polynomials whichsatisfy requisite conditions endpoints equivalent thespline segments substitute thecoefficient expressions terms methoddescribed previous paragraph reason checked spline segments satisfy conditions wecan evaluate point interval computing theabove formula solve set derivatives splinesegments equal endpoints derivative respect ofthe equation iss  zj t2   curve fitting71where yi yi setting    equations solve      equations simple ﬁtridiagonalﬂ form easily solvedwith degenerate version gaussian elimination chapter  ifwe   forexample simultaneous equ ations  fact symmetric tridiagonal diagonal themain diagonal equal diagonal main diagonal turns thatpivoting largest element accuratesolution equations method paragraph computing cubicspline translates easily pascal procedure makespline var integer beginreadln readln     dow    dobeginw  downto  dop chapter the arrays representation tridiagonal matrix issolved program chapter  inthat program construction cubic spline fitting aspline data points                       function  spline parameters bysolving equationswith result     p4     evaluate spline  range zr zn simplyfind interval compute formulaabove turn computed values function eval real real var real integer function real red begini repeat eval program check error condition betweenx ivl large number spline segments nis large efficient ﬁsearchingﬂ methods finding theinterval study chapter  variations idea curvefitting piecing togetherpolynomials ﬁsmoothﬂ computation splines developed field study types splines involve types smooth ness criteria relaxing condition splinemust touch data point computationally involve curve fitting73the steps determining coefficients spline pieces bysolving linear equations derived imposing constraints onhow joined method squaresa common experimental situation data values wehave exact idea form function whichis fit data function depend parametersand curve fitting procedure choice parameters ﬁbestﬂmatches observed values points function poly nomial parameters coefficients values exact interpolation generalfunctions inaccurate data simplify discussion concentrateon fitting functions expressed linear combination simplerfunctions unknown parameters coefficients clfl c2f2 ca4fdx includes functions interested studyingthis case general functions common measuring function fits squarescriterion error calculated adding squares errors ateach observation points  natural measure squaring cancellationsamong errors signs desirable choice parameters minimizes turns choice becomputed efficiently called method squares method directly definition simplify thederivation case   general method followdirectly suppose points valuesyi fitted function form job choice coefficients minimizesthe squares errore clfl czfdxd yd2 nf1 czfz  clfi c2f2 y3  chapter to choices minimize error simply toset derivatives dq dcz  czfz    clfl czfz z2 yz f1   clfl  czf2  y3 setting derivative equal leaves equation variables cland satisfy ﬁconstantsﬂ values clvl vl z3   z2  z3 yzfl  y3fl  equation set derivative dc2 formidable equations greatly simplified usingvector notation ﬁdot productﬂ operation encountered brieflyin chapter  define vectors   yi yz andthen dot product real number defined byx z1y1 xzy2 y3now define vectors xz   thenour equations coefficients verysimply expressed clfi czfi fz ficlfz c2f2 solved gaussian elimination desired coefficients suppose data points                       fit function form data points areslightly perturbed exact values  case havefi               haveto solve equations curve fitting75with result     close  expected method outlined easily generalizes twocoefficients constants   inf clfl czfz ca4fm minimize squares error point observation vectorsfirst compute function component vectorsfl f1 zn   z2 ziv linear equations witha ﬂ solution simultaneous equations yields requiredcoefficients method easily implemented maintaining dimensionalarray vectors  vector arraya filled mdofor dobeginit   fb solved gaussian elimination procedure chapter  method squares extended handle nonlinear func tions function cle c2zsincg chapter used type application idea fundamentally theproblem derivatives easy compute usedis iterative method estimate coefficients thesewithin method squares compute derivatives producinga estimate coefficients basic method today outlined gauss s curve fitting77exercises1 approximate function lgx degree  interpolating polynomialat points      estimat quality fit computingthe sum squares errors          solve previous problem function sinx plot function andthe approximation computer  solve previous problems cubic spline interpolat ing polynomial  approximate function lgx cubic spline knots n forn   experiment placements knots inthe range fit  happen squares data fitting functionswas function   happen squares data fitting observed valueswere  values minimize squares error functionf ux log approximate observations        excluding gaussian elimination phase multiplications areinvolved method squares coefficients basedon observations  circumstances matrix arises squarescurve fitting singular  squares method work observations cluded point  integrationcomputing integral fundamental analytic operation formed functions processed computers pletely approaches depending function isrepresented explicit representation function symbolic integrathn compute representationfor integral extreme function defined table function values points common situation function integrated represented sucha point computed case goal compute reasonable approximation integral func tion performing excessive number function evaluations thiscomputation called quadrature numerical analysts symbolic integrationif function worthwhileto method involves manipulating representation function working numeric values goal totransform representation function representation integral indefinite integration hand simple integ ration polynomials chapters and  examined methods ﬁsymbolicallyﬂ computing sums productsof polynomials programs work representation forthe polynomials produced representation answers rep resentation inputs operation integration differentiation polynomials polynomial79 chapter is represented simply keeping values coefficients array pthen integral easily computed downto  direct implementation symbolic integrationrule jc tie  wider class functions polynomials handledby adding symbolic rules addition composite rules asintegration parts udv uv sv greatly expand set functions handled integrationby parts requires differentiation capability symbolic differentiation easier symbolic integration reasonable set elementary rules composite chain rule suffice common functions large number rules applied functionmakes symbolic integration difficult task beenshown algorithm task procedure returns integral function answer expressed terms elementary functions description algorithm generality scope book functions processed small restricted class symbolicintegration powerful tool symbolic techniques fundamental limitation thatthere great integrals occur practice tbe evaluated symbolically examine techniques developed compute approximations values real integrals simple quadrature methodsperhaps obvious approximate integral therectangle method evaluating integral computing areaunder curve estimate area curve summing theareas small rectangles fit curve diagrammedbelow integration81to precise suppose compute jab theinterval integral computed divided nparts delimited points rectangles width ith rectangle     theheight ith rectangle seemthat result accurate midpoint ofthe interval  diagram leads tothe quadrature formulawhich estimates integral interval x1to common case intervals samesize    i approximationr integral easily computed function inf rect real integer real var intieger real beginr  intrect larger answer accurate forexample table estimate produced function forj dxlx    invoked withthe intrect      chapter       when  answer accurate places sophisticated quadrature methods achieve accuracy withmuch work difficult derive analytic expression error inthe rectangle method expanding taylor series midpointof interval integrating summing intervals details calculation purpose derive detailed error bounds error estimates simple methods estimates accurate methods appreciated reader familiar taylor series turns bf dz   w5e5f interval width depends ofthe derivative interval midpoints isa good approximation ﬁreasonableﬂ functions small high order derivatives true chooseto correspond  formula integral computed procedure beaccurate places approximate integral divide area thecurve trapezoids diagrammed trapezoid method leads quadrature formulat  integration83 recall area trapezoid half product height andthe sum lengths bases error method derived rectangle method turns thatsp w3e3 w5e5 rectangle method accurate trapezoid method borne procedure implements thetrapezoid method common case intervals samewidth function inttrap real integer real var integer real begint  inttrap procedure produces estimates j12       it surprising rectangle method accuratethan trapezoid method rectangles tend fall partly curve partly error cancel interval thetrapezoids tend fall completely completely curve perfectly reasonable method spline quadrature spline inter polation performed methods discussed integralis computed piecewise application trivial symbolic polynomial tegration technique bel relates theother methods compound methodsexamination formulas error rectangle andtrapezoid methods leads simple method greater accuracy called simpson method idea eliminate leading term error chapter by combining methods multiplying formula rectanglemethod  adding formula trapezoid method dividing by3 equations d5 r w5t5 w3 term disappeared formula tells methodthat accurate w5 combining quadrature formulas thesame interval size simpson rule integral canbe computed place accuracy borne ourexample implementation simpson method complicated case intervals width function intsimp real integer real var integer real ndos    intsimp program requires ﬁfunction evaluationsﬂ theinner loop produces accurate previous twomethods       more complicated quadrature methods devised gainaccuracy combining simpler methods errors romberg integration sets subintervalsfor ﬁmethods ﬂ integration85it turns simpson method equivalent interpolatingthe data piecewise quadratic function integrating interestingto note methods discussed cast piecewise interpolation methods rectangle rule interpolates constant degree polynomial trapezoid rule degree polynomial simpson rule quadratic polynomial spline qua drature cubic polynomial adaptive quadraturea major flaw methods discussed errorsinvolved depend subinterval size high order derivatives function integrated implies methods work functions thosewith large high order derivatives functions large high orderderivatives reasonable small intervals derivatives large large intervals derivatives small method systematic called adaptive quadrature routine general approach adaptive quadrature differentquadrature methods subinterval compare subdividethe interval difference great care exercised equally bad methods agree quiteclosely bad result avoid ensure methodalways overestimates result underestimates result avoid ensure method accurate method type overhead involved recursively subdividing terval pays good method estimating integrals thefollowing implementation function adapt real real beginif abs intsimp  intsimp  tolerancethen adapt intsimp  adapt adapt  adapt  estimates integral derived simpson method oneusing subdivisions essentially amounts tochecking accuracy simpson method interval question andthen subdividing good chapter unlike methods decide work wantto accuracy adaptive quadrature dohowever work achieve degree accuracy decide ahead time tolerance chosen carefully routine loop indefinitely achieve impossibly hightolerance number steps required depends nature ofthe function integrated function fluctuates wildly requirea large number steps function lead inaccurateanswer ﬁfixed intervalﬂ methods smooth function handled reasonable number steps table values produced number ofrecursive calls required routine compute jrz                  the program improved ways scertainly intsimp fact function valuesfor shared intsimp  tolerance boundcan accuracy answer closely tolerance isscaled ratio size current interval size fullinterval routine developed evenbetter quadrature rule simpson basic law recursion adaptive routine good idea sophisticated adaptivequadrature routine provide accurate problems tbe handled careful attention paid types functions processed algorithms recursive struc ture adaptive quadrature method general techniqueof adapting simple methods work hard difficult parts complexproblems powerful algorithm design integration87exercises1          write program symbolically integrate differentiate polynomialsin lnx recursive implementation based integration parts quadrature method produce answer tegrating functions x   sin result elementary quadrature methods rectangle trapezoid simpson spline integrate inter val answer previous question function sinx discuss adaptive quadrature integrate thefunction interval   answer previous question elementary quadrature methods points evaluation adaptive quadrature tegrate function interval tolerance compare accuracy adaptive quadrature based simpson smethod adaptive quadrature sed rectangle method theintegral previous problent answer previous question function sinx specific function adaptive quadrature wouldbe drastically accurate result methods sources mathematical algorithmsmuch material falls domain numeri cal analysis excellent textbooks paysparticular attention computational issues  book forsythe malcomb moler material chapters5   based presentation book major reference volume knuth comprehensive treatment ﬁthe art computer programming ﬂknuth term ﬁseminumericalﬂ algorithms lie atthe interface numerical symbolic computation randomnumber generation polynomial arithmetic topics knuths volume  covers great depth material chapters1    book borodin munro additional referencefor strassen matrix multiplication method topics ofthe algorithms considered principally symbolicmethods mentioned chapter  embodied computer called macsyma regularly mathematical work reader seeking mathematical algorithmsshould expect topics treated advanced mathemati cal level references material considered chapter  concerned elementary data structures poly nomials references mentioned previous reader terested learning subject study elementary datastructures handled modern programming languages ada whichhave facilities building abstract data structures borodin munro computational complexity algebraic andnumerical problems american elsevier york  forsythe malcomb moler computer methods formathematical computations prentice hall englewood cliffs  knuth art computer programming volume seminumericalalgorithms addison wesley reading edition  mit mathlab group macsyma reference manual laboratory comput science massachusetts institute technology  wegner programming ada introduction graduatedexamples prentice hall englewood cliffs  sorting  elementary sorting methodsas excursion area sorting algorithms studysome ﬁelementaryﬂ methods small files orfiles special structure reasons studying thesesimple sorting algorithms provide relativelypainless learn terminology basic mechanisms sorting algorithmsso adequate background studying sophisticated algorithms great applications sorting sbetter simple methods powerful general purposemethods finally simple methods extend general purpose methods improve efficiency powerfulmethods prominent recursive sortswhich ﬁdivide conquerﬂ big files small isadvantageous deal small files situations mentioned sorting applications arelatively simple algorithm method choice sorting programsare times number items besorted large elements bemore efficient simple method implement debug acomplicated method elementary metho suitable small files fifty elements sophisticated algorithmwould justified small file large number files sorted types files easy sort sorted sorted large numbersof equal keys simple methods structuredfiles general purpose methods rule elementary methods discussing aboutn2 steps sort randomly arranged items small maynot problem items randomly arranged the91 chapter methods faster sophisticated itmust emphasized methods notable exception shouldnot large randomly arranged files rules gamebefore specific algorithms discuss somegeneral terminology basic assumptions sorting algorithms methods sorting files records keys keys records small control thesort objective sorting method rearrange records keys order defined ordering rule numerical alphabetical order file sorted fit memory context willfit pascal array sorting method called internal sortingfiles tape disk called external sorting main difference betweenthe record easily accessed internal sort whilean external sort access records sequentially large blocks external sorts chapter  algorithms internal sorts usual main performance parameter interested isthe running time sorting algorithms mentioned elemen tary methods examine chapter require time proportional sort items advanced methods sort items intime proportional log sorting algorithmcan log comparisons keys methods digital properties keys total running time proportional extra memory sorting algorithm secondimportant factor basically methods divide threetypes sort place extra memory small stack table linked list representation usen extra memory list pointers extramemory hold copy array sorted characteristic sorting methods inpractice stability sorting method called stable preserves relativeorder equal keys file alphabetized class list issorted grade stable method produce list studentswith grade alphabetical order stable method islikely produce list evidence original alphabetic order simple methods stable sophisticatedalgorithms stability vital forced appending elementary sorting methods93small key sorting y lengthening sort key someother easy stability granted people react theunpleasant effects instability disbelief methods achieve stability extra time space program sorting records intended illustratethe general conventions main program isa peculiar exercise program work  point sorting programs substituted sort3 ﬁdriverﬂ program program threesort input output maxn  var array maxn integer integer procedure sort3 var integer beginif  thenbegin if   endbegin     thenbegin     beginreadln read  sort3 write wri telnend assignment statements implement anﬁexchangeﬂ operation write code exchanges thanuse procedure fundamental sorting programsand fall loop order concentrate algorithmjc issues work algorithmsthat simply sort arrays integers numerical order generally straight forward adapt algorithms practical application involving large keys records basically sorting programs access records ways keys accessed comparison entire records accessed chapter to moved algorithms study recast termsof performing operations arbitrary records records besorted large wise ﬁindirect sortﬂ recordsthemselves rearranged array pointers orindices rearranged pointer points smallest record keys records large pointers small programs simply operate global array ignoringﬁpackaging problemsﬂ troublesome programming environ ments array passed sorting routine parameter sorting routine sort arrays integers arraysof reals arrays arbitrarily complex records simpleassumptions usual circumvent lack dynamic array sizes pascal predeclaring maximum concerns easier deal programming environments future modern languages developed facilities packaging programs large systems hand mechanisms required applications small programs work directly global arrays operating systems easy simple programs serve ﬁfiltersﬂ input output comments apply algorithms examining effects acutely felt sortingalgorithms programs global variables declarationswhich obvious included program code llsometimes assume array bounds   hold special keysused algorithms frequently letters alphabetrather numbers examples handled obvious usingpascal chr ﬁtransfer functionsﬂ integers characters sort3 program constrained access file instructions form ﬁcompare records exchange themif smaller key ﬂ programs useonly type instruction interesting suited forhardware implementation study issue chapter35 selection sortone simplest sorting algorithms works smallestelement array exchange element position smallest element exchange element elementary sorting methods95the position continuing entire array sorted method called selection sort works repeatedly ﬁselectingﬂthe smallest remaining element program sorts  intonumerical order procedure selection var min integer beginfor dobeginmin doif min min min min tend simplest sorting methods work forsmall files running time proportional number comparisonsbetween array elements  outer loop executed ntimes loop executed  times average itturns statement min executed order log times loopdespite simplicity selection sort application method choice sorting files large records smallkeys records long keys long exchange takes time proportional total running timeis proportional comparisons nm exchanges ifm proportional running time linear datainput difficult beat advanced method ifit absolutely required records rearranged anﬁindirect sortﬂ avoid nm term method whichuses comparisons justified selection sort attractivefor sorting looo word records word keys insertion sortan algorithm simple selection sort flexible isinsertion sort method people sort bridge hands elements time inserting proper place amongthose considered keeping orted element consideredis inserted moving larger elements position chxpter inserting element vacated position code algorithmis straightforward procedure insertion var integer beginfor  dobeginv  dobegin   vend code work left endof array smallest element array isto ﬁsentinelﬂ key making small smallestelement array sentinels situations common insorting programs avoid including test case almostalways succeeds loop reason inconvenient touse sentinel array bounds  standardpascal clean alternative ﬁconditionalﬂand instruction test a1j work becauseeven evaluated causean bounds array access goto loop required programmers prefer goto lengths avoid goto instructions performing action loop ensure loopterminates case solution justified makesthe program clearer adds extra overhead everytime theloop guard rare event average loop insertion sort executed times ﬁaverageﬂ insertion halfway subfile size  inherent method point insertion moreefficiently searching techniques chapter   moves tomake room element inserted required numberof moves lowered linked list array methods chapter  apply  comparisons required insertion point elementary sorting methods97shellsortinsertion sort slow exchang adjacent elements ample smallest element array takesn steps belongs shellsort simple extension insertionsort problem allowing exchanges elements thatare replace occurrence ﬁ1ﬂ ﬁhﬂ ﬁ2ﬂ ﬁh lﬂ ininsertion sort program rearranges file propertythat hth element starting yields sorted file afile sorted sorted file independentsorted files interleaved sorting large values wecan elements array long distances easier sortfor smaller values procedure sequence values ofh ends  produce sorted file shellsort sample file elements issorted increments    a  e13a  exampls4a  s1aaeegil h4  xin pass position  compared position  thenthe position  compared exchanged position  inthe pass positions     rearranged toput positions positions     pass insertion sort element description shellsort gains efficiency necessarilyimprecise analyze algorithm somesequences values work explanation thishas discovered sequence empirically wellis        program chapter procedure shellsort label  var integer beginh repeat  repeath div  dobeginv dobegina goto end  vend  note sentinels largest increment sequence program easy leads anefficient sort increment sequences lead amore efficient sort reader amused discover itis difficult beat program  relativelylarge possibility increment sequences exist real hand bad incrementsequences shellsort implemented starting insteadof initializing ensure sequence thisvirtually ensures bad sequence turn comparing shellsort methods analytically difficult becausethe functional form running time shellsort anddepends increment sequence program conjectures1 are logn  running time sensitive tothe initial ordering file contrast insertion sort linear file order quadratic file reverseorder shellsort method choice sorting applications ithas acceptable running time moderately large files thousandelements requires srnall code easy elementary sorting methods99working methods efficient chapters fast large andthey complicated short sorting problem program determine vvhether extra effort required toreplace sophisticated method worthwhile otherhand quicksort algorithm chapter moredifficult implement digression bubble sortan elementary sorting method taught introductory classes isbubble sort passing file exchanging adjacent elements ifnecessary exchanges required pass file sorted implementation method procedure bubblesort var integer beginrepeatt  doif alj thenbegin  enduntil takes moment reflection convince oneself works running time quadratic clear methodis taught insertion sort simpler efficient byalmost measure loop bubble sort manyinstructions insertion sort selection sort distribution countinga special situation simple sorting algorithm thefollowing ﬁsort file records keys distinct integers and ﬂ algorithm problem isfor chapter this algorithm temporary array morecomplicated solve problem auxiliary array realistic problem solved algorithm spirit ﬁsort file records keys integers   ﬂ mis large algorithm called distribution counting solvethis problem idea count number keys thenuse counts records position pass thefile code countlj ndocount count docount count count downto  dobegint count count count end code works sample file integers                           the loop initializes counts  produces counts0              this loop adds thesenumbers produce0             that numbers  numbers  addresses sort array                            elementary sorting methods101for  file encountered intolocation  count   keys equal to4 count  decremented key orequal  loop  sort bestable reader check method work type files postulated extended produce powerful method llexamine chapter  random fileswe sorting files arbitrarily scrambled order case lot file sorted add elements asorted file produce larger sorted file simplyappend elements file sorting algorithm general purpose sorts commonly mi sused applications elementary methods advantage order file operation insertion sort file isalready sorted element determined proper inthe file total running time linear true bubble sort selection sort quadratic leading term running time ofselection sort depend order file sorted file completely sorted insertion sort usefulbecause running time insertion sort depends heavily orderpresent file running time depends number inversions foreach element count number iements left greater distance elements inserted fileduring insertion sort file order fewer inversions arbitrarily scrambled cited file formed tacking elenientsonto large sorted file case number inversionsis low file constant number elements place linear number inversions file element constant distance final position files created initial stages advanced sorting methods point worthwhile switch jnsertion sort short insertion sort method choice ﬁalmost sortedﬂ fileswith inversions files outperform sophisticatedmethods chapters exercises1          sequence ﬁcompare exchangeﬂ operations sorting records elementary methods runs fastest file isalready sorted elementary methods runs fastest file reverseorder test hypothesis selection sort fastest elemen tary methods insertion sort bubble sort good reason inconvenient sentinel key forinsertion sort implementation shellsort comparisons shellsort  sort sort thekeys easyquestion     good finishoff shellsort increment sequence selection sort stable insertion sort bubble sort specialized version distribution counting sorting files whereelements values experiment increment sequences shellsort thatruns faster random file  elements  quicksortin chapter study sorting algorithm probablymore quicksort basic algorithm wasinvented  hoare studied peoplesince time quicksort popular difficult implement good ﬁgeneral purposeﬂ sort works variety situations andit consumes resources sorting method situations desirable features quicksort algorithm place small auxiliary stack requires nlogn operationson average sort items extremely short loop drawbacks algorithm recursive implementation iscomplicated recursion worst case takes operations fragile simple mistake implementationmight unnoticed tea perform badly files performance quicksort understood beensubjected mathematical analysis precise statementscan performance issues analysis verified byextensive empirical experience algorithm refined thepoint method choice broad variety practical sorting applications worthwhile carefully ways efficiently implementing quicksort algorithms implementation techniques algorithms withquicksort confidence performance wellunderstood tempting develop ways improve quicksort fastersorting algorithm computer science ﬁbetter mousetrap ﬂ themoment hoare published algorithm ﬁimprovedﬂ versions beenappearing literature ideas analyzed butit easy deceived algorithm balanced the103 chapter effects improvements program offset bythe effects bad performance program examinein modifications improve quicksort carefully tuned version quicksort fasterthan sorting method computers becautioned tuning algorithm fragile leading undesirable unexpected effects inputs version developed free effects program library sort utility sorting application invest effort quicksort implementation flawed shellsort safer choice perform adequately implementation effort basic algorithmquicksort ﬁdivide conquerﬂ method sorting works partition ing file parts sorting parts independently exact position partition depends file algorithm hasthe recursive structure procedure quicksort integer var beginif thenbegini partition  quicksort   quicksort endend parameters delimit subfile original file tobe sorted quicksort sorts file crux method partition procedure rearrangethe array conditions hold element final place array elements equal iii elements greater equal simply easily implemented generalstrategy arbitrarily choose element quicksort105its final position scan left array findingan element greater scan array untilfinding element elements stopped scansare place final srtitioned array exchange turns reasons thescans elements equal involve someunnecessary exhanges cont inuing ensures array elementsto left left pointer array elements rightof pointer greater scan pointers cross thepartitioning process complete remains exchange leftmost element subfile table sample file keys partitioned usingthis method a  tingexamplha lma eoxsmplnaa ehtingoxsmplrthe rightmost element chosen partitioning element firstthe scan left stops scan stops thea exchanged table scan left stops  scan stopsat exchanged thetable pointers cross scan left stops andthe scan stops proper point toexchange leaving partitioned file table sort finished sorting subfiles oneither partitioning element recursively program implementation method chapter procedure quicksort  integer var integer beginif thenbeginv repeatrepeat repeat  alj quicksort quicksort endend implementation variable holds current ﬁpartition ing elementﬂ left scan pointers extra exchange pointers crossbut crossing detected outer repeat loop exited thiscould avoided goto assignment statements thatloop implement exchanges undo extra exchange anda partitioning element position insertion sort sentinel key needed scan thecase partitioning element smallest element file thisimplementation sentinel needed scan partitioning element largest element file partitioning elementitself file scan shortly easyway avoid sentinel key ﬁinner loopﬂ quicksort consists simply incrementing pointerand comparing array element fixed whatmakes quicksort quick hard imagine simpler loop subfiles sorted recursively finishing sort thefollowing table traces recursive calls depicts resultof partitioning displayed subfile boxed partitioning element quicksort107123456789101112131415asortingexampleaaemtingoxsmplra el0a ai l  mux sligmopnl lg li0n u0 p0pcls xwaaeegilmnoprstxnote element eventually place apartitioning element disturbing feature program runs veryinefficiently simple files called file alreadysorted partitions degenerate program times knocking element time required  space requiredto handle recursion unacceptable fortunately easy ways ensure worst casedoesn occur actual applications program equal keys file subtleties apparent question pointers keys chapter equal partitioning element pointer otherscan pointers scan question studied mathematically result thatit pointers balance partitions inthe presence equal keys question properly handling pointer crossing presence equal keys program improved terminating scans quicksort recursive improvementbecause elements position partitioning letting loop iterate time case occurs rwere worth making change becausethe program leaves record key equal partitioning key ina partition quicksort degeneratebecause rightmost key smallest implementation partitioninggiven bit easier understand leave discussions understanding change large numbers equal keys thing happen partitioning stage todivide file half number comparisonsused quicksort satisfy divide conquer recurrencec c  c  covers cost subfiles cost ofexamining element partitioning pointer fromchapter  recurrence solutionc lg things true partition fallsin middle average precise probability parti tion position account recurrence complicated difficult solve final result turns thatc  nlnn implies total running time quicksort proportional ton log average implementation perform applica tions reasonable general purpose sort sort tobe great times sort large file thenit worthwhile implement improvements discussedbelow ensure worst case occur reduce average running time   easily eliminate sentinel key quicksort109removing recursionin chapter  recursive removed euclid salgorithm yield recursive program controlled simple loop thiscan programs recursive situationis complicated recursive calls involved quicksort dealing recursive saved processing recursive calls pascal programming environment pushdown stack managethis time procedure values variables arepushed stack saved time procedure returns stack ispopped removed stack represented linked list case push isimplemented linking node list popby removing node list array case apointer maintained points stack pushis implemented storing incrementing pointer pop decrementing pointer retrieving companion data structure called queue items arereturned order linked list implementation ofa queue items arrayimplementation queues complicated bookwe examples data structures support twin operationsof inserting items deleting items prescribed rule mostnotably chapters   recursive calls values variables saved animplicit stack programming environment improvedprogram explicit stack save determine variables saved examiningthe program carefully approach rework algorithm based onusing explicit stack explicit recursion approach quicksort manysimilar algorithms stack ﬁwork ﬂin form subfiles sorted time subfile process pop stack partition create subfiles processed pushed stack leads recursiveimplementation quicksort chapter procedure quicksort var  integer stack array integer integer begin1   repeatif thenbegini partition stack stack endelse stack stack  endelsebegin  stack stack oend program differs description ways simply putting subfiles stack arbitrary order sizes checked larger stack smaller subfiles stack valuesof parameters simply reset euclid algorithm thistechnique called ﬁend recursion removalﬂ applied procedurewhose action recursive quicksort combination recursion removal policy processing smaller subfilesfirst turns ensure stack room lg nentries entry stack represent subfileless half size previous entry sharp contrast size stack worst case therecursive implementation large thecase file sorted subtle real difficulty recursive implementation quicksort underlying stack degenerate case large file program terminate abnormally lack memory behavior undesirablefor library sorting routine ways degenerate casesextremely avoid problem completely ina recursive implementation switching order subfiles areprocessed recursion removal recursive method processes subfiles quicksort111recursive method order asshown table       asortingexampleaaeie ingoxsmplra elua a0aling0pm0r tels ttsxl igmo n0g lal0i0n  ppaaaeegilmnoprstxthe simple explicit stack leads efficientprogram direct recursive implementation overheadthat removed problem subfiles oneelement entries  stack takenoff discarded straightforward change program simply notput files stack change nextimprovement included involves ignoring small subfiles sameway chapter small subfilesthe improvement stems observation recursive programis guaranteed small subfiles changed method small subfiles encountered obvious todo change test recursive routine ﬁifr thenﬂ insertion sort modified accept parameters definingthe subfile sorted ﬁif insertion  ﬂ mis parameter exact depends implementation thevalue chosen algorithm works aboutthe range   reduction therunning time order  applications easier method efficient justchange test ﬁif thenﬂ simply ignoresmall subfiles partitioning recursive implementation thiswould putting files stack afterpartitioning left file sorted mentioned theprevious chapter insertion sort method choice files insertion sort work file collection files directly method caution insertion sort sort evenif quicksort bug work excessivecost sign wrong median partitioningthe improvement partitioning element areseveral possibilities safest thing avoid worst case wouldbe random element array partitioning element thenthe worst case happen negligibly small probability simpleexample ﬁprobabilistic algorithm ﬂwhich randomness achievegood performance arrangement input tool algorithm design bias input suspectred quicksort overkill fullrandom number generator purpose arbitrary number willdo improvement elements file thenuse median partilioning element elementschosen left middle array ofsentinels avoided sort elements exchange method chapter exchange middlewith air partitioning algorithm    thisimprovement called median partitioning method quicksort113the median method helps quicksort ways itmakes worst case occur actual sort orderfor sort time elements examined beamong largest smallest elements file musthappen consistently partitions eliminates theneed sentinel key partitioning function served elements examined partitioning reduces total running time algorithm  combination nonrecursive implementation median method cutoff small subfiles improve running time ofquicksort naive recursive implementation   furtheralgorithmic improvements median moreelements time saved marginal moresignificant time savings realized effort coding innerloops program assembly machine language pathis recommended experts sorting applications exercises1          implement recursive quicksort cutoff insertion sort subfileswith elements empirically determine forwhich runs fastest random file  elements solve previous problem nonrecursive implementation solve previous problem incorporating median provement long quicksort sort file equal elements maximum number times largest element bemoved execution quicksort file abababa partitioned methodssuggested text comparisons quicksort sort keys easy question ﬁsentinelﬂ keys needed insertion sort called directlyfrom quicksort reasonable queue stack recursiveimplementation quicksort squares curvefitter values thebest formula form describing total numberof instructions executed quicksort random file  radix sortingthe ﬁkeysﬂ define order records files manysorting applications complicated considerthe ordering function telephone book library catalogue reasonable define sorting methods terms basic operations ﬁcomparingﬂ keys ﬁexchangingﬂ records methods studied terms fundamental operations applications totake advantage fact keys thought numbers fromsome restricted range sorting methods advantage digitalproperties numbers called radix sorts methods justcompare keys process compare pieces keys radix sorting algorithms treat keys numbers represented abase number values radix work withindividual digits numbers imaginary problemwhere clerk sort pile cards digit numbers printed reasonable proceed piles numbers  numbers   place cards piles deal piles individually byusing method dig simpler methodif cards slimple radix sort withm  examine methods chapter computers convenient work  orsome power   represented inside digital computer treatedas binary number sorting applications recast makefeasible radix sorts operating keys binary numbers pascal lari guages intentionally difficultto write program depends binary representation numbers  cyhpter  reason pascal intended language expressing programsin machine independent manner computers differentrepresentations numbers philosophy eliminates types ﬁbit flickingﬂ techniques situations handled fundamental pascal constructs records sets radix sorting casualty progressive philosophy fortunately difficult arithmetic operations simulate operations needed write inefficient pascal programs algorithms easily translated efficient programs programming languages support bit operations binary numbers key represented binary number fundamental operationneeded radix sorts extracting contiguous set bits number suppose process keys integers  and1000 assume represented bit binary numbers machine language bits extracted binary numbers bitwiseﬁandﬂ operations shifts leading bits bitnumber extracted shifting bit positions bitwiseﬁandﬂ mask  pascal operations simulatedwith div mod leading bits bit number xare div  mod  general ﬁshift  bit positionsﬂcan simulated computing div k ﬁzero rightmostbits xﬂ simulated computing mod j description ofthe radix sort algorithms assume existence function bits integer integer combines operations return bits whichappear bits  computing div ak mod  forexample rightmost bit returned bits  thisfunction efficient precomputing defining constants powers  note program function willdo radix sorting representation numbers hope improved efficiency representation binary compiler clever notice computation machine language ﬁshiftﬂ ﬁandﬂ instructions pascal implementations extensions language operations directly armed basic tool types radixsorts differ order examine bits keys weassume keys short worthwhile effortof extracting bits keys short distribution countingmethod chapter  recall method sort keys integers   linear time auxiliarytable size counts size rearranging records afford table size  bit keys easily sorted radix sorting117in linear time radix sorting play keys long  basic method radix sorting examines thebits keys left based fact outcome ofﬁcomparisonsﬂ keys depend bits thefirst position differ reading left keyswith leading bit  keys leading bit  sorted file keys leading bit  keys bit  beforeall keys bit  left radix sort whichis called radix exchange sort sorts tematically dividing keys inthis basic method called straight radix sort examines bits keys left based interestingprinciple reduces sort bit keys sorts bit keys seehow combined distribution counting produce sort thatruns linear time generous assumptions running times basic radix sorts sorting records bbit keys essentially nb hanil running timeas essentially log ince numbers ogn hand methods usemany fewer nb operations left method stoponce differences keys yound left method process bits radix exchange sortsuppose rearrange records file keysbegin  bit keys  bit thisimmediately defines recursive sorting method subfiles sortedindependently file sorted rearrangement file partitioning quicksort scan left tofind key starts  bit scan key whichstarts  bit exchange continue process scanningpointers cross leads recursive sorting procedure similarto quicksort chapter procedure radixexchange integer var integer beginif thenbegini repeatwhile bits   bits    bits  radixexchange  radixexchangedj endend simplicity assume  positive integers  represented  bit binary numbers callradixexchange   sort array variable track ofthe bit examined ranging  leftmost  rightmost adapt implementation bits machinerepresentation negative numbers negative numbers handled ina uniform sort implementation recursive implemen tation quicksort previous chapter essentially partitioning inradix exchange sort partitioning quicksort number2b number file partitioning element b file guarantee elementis final place partitioning bit ing examined rely sentinels pointer scans tests included scanning loops quicksort extra exchange case undo thisexchange loop ﬁexchangeﬂ aswith quicksort care algorithm ensure ﬁfalls cracksﬂ recursive calls partitioning stops elements bits bth position elements left  bits thebth position element  bit keys thefile  position implementation extra test justafter partitioning loop cover case radix sorting119the table rample file keys partitioned andsorted method table compared table inchapter  quicksort operation partitioning method iscompletely opaque binary representation keys asortingexampleaeolmingeaxtprs aeaeginmlo l l mn0stprxs saaeegilmnoprstxthe binary representation keys simplefive bit code ith letter alphabet represented binaryrepresentation number simplified version real charactercodes bits represent characters upper lower case letters numbers special symbols translating keysin table bit characte code compressing table thesubfile partitioning ﬁin parallelﬂ ciiaf ter transposing rows columns leading bits keyscontrol partitioning a00001a00001s10011e00101001111001111r10010l01100t10100m01101i01001i01001n01110n01110g00111g00111e00101e00101x11000a00001a00001x11000m01101t10100p10000p10000l01100r10010e00101s10011a00001e00101a00001e00101g00111i01001n01110m01101l01100001111s10011t10100p10000r10010x11000a00001a00001e00101e00101g00111i01001n01110m01101l01100001111s10011r10010p10000t10100l011 mn01110001111p011  r10010s10011a a e e l m n  r s one potential problem radix sort brought thisexample degenerate partitions keys forthe bit happen frequently arises commonlyin real files small numbers leading zeros sorted occurs characters suppose  bit keys characters encoding standard bit code thenputting degenerate partitions happen thebeginning character position lower case letters allbegin bits character codes effects concern sorting encoded data key distinguished fromall keys left bits bits examined adistinct advantage situations disadvantage thekeys random bits key differ aboutlg bits fewer number bits keys random situation expect partition divide thesubfile half sorting file  records involveonly examining bits key keysare  bit keys hand notice bits equalkeys examined radix sorting simply work files sorting121contain equal keys radix exchange sort faster thanquicksort keys sorted comprised random bits quicksort adapt randon situations straight radix sortan alternative radix sorting method examine bits left method computer card sorting machines deck ofcards machine  times column proceedingfrom left left bit bitradix sort works file sample a00001r10010s10011t10100001111n01110r10010x11000t10100p10000i01001l01100n01110a00001g00111s10011e00101001111x11000i01001a00001g00111m01101e00101p10000a00001l01100m01101e00101e00101t10100x11000p10000l01100a00001i01001e00101a00001m01101e00101r10010n01110s10011001111g00111 c11000i fl00001 ii00001i110010310011 y101001 i n01110001111g00111p10000a00001a00001a00001a00001e00101r10010e00101s10011g00111t10100i01001e00101l01100e00101m01101g00111n01110x11000001111i01001p10000l01100r10010m01101s10011n01110t10100001111x11000the ith column table sorted trailing bits keys ith column derived column extracting keyswith  ith bit keys  ith bit easy convinced method works fact twork bit partitioning process stable stabilityhas identified trivial proof method workscan putting keys bit  ith bit  stable manner keys proper order onthe basis bits examined file ith bitsare case partitioning puts proper order ith bits case proper order stability requirement  stability crapter the partitioning method radix exchange sort thisright left sort partitioning sorting file values dis tribution counting sort looked chapter  appropriatefor assume  distribution counting program andreplace bits program method sortingthe elements array bit positions puttingthe result temporary array reason  infact large realizing table ofm counts corresponds bits time sort withm m straight radix sort generalizationof distribution counting sort implementation sortinga rightmost bits procedure straig radix integer var pass integer beginfor pass  div  dobeginfor countlj docount bits pass count bits pass docountij countij countb downto  dobegint count bits pass count bits pass count bits pass clarity procedure calls bits increment decrementcount suffice correspondence m beenpreserved variable names versions ﬁpascalﬂ tellthe difference procedure works properly multiple restrictive assumption radix sort simply cor responds dividing keys sorted integral number equalsize pieces distribution counting sort radix sorting123have straight radix sort rightrto left bit radix sort theexample implementation moves file dis tribution counting phase simple loop ﬁarray copyﬂloop eliminated desired making copies distributioncounting code sort sort linear sortthe straight radix sort implementation previous makesb passes file making large efficient sortingmethod long m memory reasonablechoice fourth word size  radixsort distribution counting passes keys treated base mnumbers base digit key examined areonly digits key directly corresponds architecturalorganization computers typical organization  bit consisting bit bytes bits procedure winds upextracting bytes case bedone efficiently computers distribution counting pass linear entire sort linear performance hope sort fact turns distribution countingpasses careful reader  difficulty telling fromleft time caution called understand thismethod achieved advantage fact filewill sorted leading  bits bbit keys aswith quicksort sort completed efficiently insertion sorton file method trivial modification implementation left sort leading halfof keys simply start outer loop pass div  thanpass conventional insertion sol orderedfile convinced file sorted leading bitsis ordered reader examine columns thetable radix exchange sort insertion sort thethe file sorted bits require exchanges distribution counting passes fourth wordsize insertion sort finish job yield sorting methodthat faster large fileswhose keys random bits main disal dvantage requires extraarray size array sorted eliminatethe extra array linked list techniquies extra space proportional ton links required chapter a linear sort desirable applications arereasons panacea doesdepend keys random bits randomly ordered condition sati sfied severely degraded performance requires extraspace proportional size array sorted ﬁinner loopﬂof program instructions linear faster quicksort expect large files point extra array realliability choice quicksort radix sort difficult depend features application key record file size features programming machine environment relate efficiency access individual bits tradeoffs studied expert type studyis worthwhile sorting applications radlx sorting125exercises1 compare number exchanges radix exchange sort withthe number exchanges qlricksort file            remove recursion radix change sort quicksort  modify radix exchange sort skip leading bits identical allkeys situations worthwhile  true false running time sti aight radix sort depend onthe order keys input file explain answer  method faste file equal keys radixexchange sort straight radix sort  true false radix exchange sort straight radix sort examineall bits keys file explain answer  extra memory reqciirement major disad vantage strategy straight radix sorting leadingbits keys cleaning insertion sort  memory requirl  pass straight radix sortof bit keys  type input file radix exchange sort slowly large  empirically compare straight radix sort radix exchange sort arandom file   bit keys  priority queuesin applications records keys processed order sorted order set records collected largest processed thenperhaps records collected largest processed data structure environment supportsthe operations inserting element deleting largest element contrasted queues delete oldest stacks delete thenewest data structure called priority queue fact priorityqueue thought generalization stack queue andother simple data structures data structures implementedwith priority queues priority assignments applications priority queues include simulation systems thekeys correspond ﬁevent timesﬂ processed order job scheduling computer systems keys correspond toﬁprioritiesﬂ users processed numeri cal computations keys computational errors largestcan worked book priority queues basicbuilding blocks advanced algorithms chapter  develop afile compression algorithm routines chapter chapters31  priority queues serve basis severalfundamental graph searching algorithms examples ofthe role served priority queue basic tool algorithmdesign precise priority queue willbe manipulated operations performon priority queues order maintain effectively forapplications mentioned main reason that127 chapter priority queues flexibility allowing variety differentoperations efficiently performed set records keys tobuild maintain data structure records numerical keys priorities suppor operations construct priority queue items insert item remove largest item replace largest item item item larger change priority item delete arbitrary item join priority queues large records duplicate keys ﬁlargestﬂ ﬁany recordwith largest key ﬁ replace operation equivalent insert aremove difference insert remove requires priority queueto grow temporarily element note fromdoing remove insert included separate capabilitybecause implementations priority queues thereplace operation efficiently change operation beimplemented delete insert construct imple mented repeated insert operation operations bedirectly implemented efficiently choices data structure thejoin operation requires advanced data structures efficient implemen tation concentrate ﬁclassicalﬂ data structure called heap efficient implementations operations priority queue excellent anabstract data structure defined terms operationsperformed independent data organized processedin implementation basic premise abstract datastructure definitions data structureand algorithms operating refer inside exceptthrough function procedure calls fundamental operations main motivation development abstract data structures mechanism organizing large programs provide limit size complexity interface complicated algorithms data structures large numberof programs algorithms data structures iteasier understand large program convenient change improve fundamental algorithms priority queues129context methods implementing operationslisted performance characteristics defining priority queues terms operations abstract data structure providesthe flexibility experimentation alternatives implementations priority queues involve performancecharacteristics operations performed leading costtradeoffs performance differences differences lowed abstract data structure concept illustrate point examining elementary data structures implementing priorityqueues examine advanced data structure showhow operations implemented efficiently data structure examine sorting algorithm naturally implementations elementary implementationsone organize priority queue unordered list simply keepingthe items array paying attention keys thusconstruct ﬁno opﬂ organization insert simply increment andput item constant time operation replace requiresscanning array element largest key whichtakes linear time elements array examined thenremove implemented exchanging element thelargest key decrementing organization sorted list array  keeping items increasing order keys remove simplyinvolves returning decrementing constant time insert volves moving larger elements array position couldtake linear time linked lists unordered list sorted list change fundamental performance characteristics insert remove replace delete join inconstant time priority queue algorithm turned sorting algorithm bysuccessively insert build priority queue items besorted successively remove priority queue receivingthe items reverse order priority queue represented unorderedlist corresponds selection sort sorted list corresponds insertion sort usual wise simple implementations mind becausethey outperform complicated methods practical situations method application crapter only ﬁremove largestﬂ operations performed opposed largenumber insertions method items inserted tended close largest element priorityqueue implementations methods searching problem record key chapter  heap data structurethe data structure support priority queue operationsinvolves storing records array key isguaranteed larger keys specific positions turn keys larger keys thisordering easy draw array dimensional ﬁtreeﬂstructure lines key keys smaller structure called ﬁcomplete binary treeﬂ place node called theroot proceeding left connect nodesbeneath node previous level nodes thenodes node called sons node node called father kinds ﬁbinary treesﬂ ﬁtreesﬂ chapter and chapters book keys tree satisfythe heap condition key node larger equal keys sons note implies thatthe largest key root represent complete binary trees sequentially array bysimply putting root position  sons positions   nodes atthe level positions     numbered diagram array representation tree xtogsmnaerai priority queues131this natural representation easy anode father sons father node position positionj div  conversely sons node position position2j j  raversal tree easier treewere implemented standard linked representation elementcontaining pointer father sons rigid structure completebinary trees represented arrays limit utility data structures flexibility implementation efficient priority queue algorithms heap complete binary tree represented array node satisfies heap condition thelargest key position array algorithms operate path root bottomof heap moving father son son father easyto heap nodes paths gn nodes  nodes  nodes sons thebottom  nodes grandsons ﬁgenerationﬂ half nodes implies lg generations priority queue operations exceptjoin logarithmic time heaps algorithms heapsthe priority queue algorithms heaps work making simplestructural modification violate heap condition travelingthrough heap modifying ensure heap condition satisfiedeverywhere algorithms travel heap algorithms assume records word integer keys stored array maximumsize current size heap integer note asmuch definition heap keys records build heap implement insertoperation operation increase size heap nmust incremented record inserted butthis violate heap property heap property violated newnode greater father violation fixed exchanging node father turn violation fixed inserted heap stored son greater exchanged greater  exchanged  process terminates heap chapter the code method straightforward implementation insert adds item calls upheap heap conditionviolation nprocedure upheap integer var integer beginv maxint div  dobegin div  div  procedure insert integer beginn whew insertion sort exchange theloop involved exchanges sentinel key beput loop case greater keys inthe heap replace operation involves replacing key root newkey moving heap restore heapcondition heap replaced withc step store root violates heap condition violation fixed exchanging larger sons root creates violation level fixed priority queues133again exchanging larger sons case theprocess continues heap condition longer violated node occupied heap leaving ﬁremove largestﬂ operation involves process heap element smaller operation necessaryto decrement leaving place element stored lastposition largest element removed remove operationamounts replace element thefollowing heap removing heap implementation procedures centered operationof fixing heap satisfies heap condition exceptpossibly root operation heapafter position lowered implemented chapter procedure downheap integer label  var integer beginv div  dobeginj goto  vend procedure moves heap starting position exchangingthe node position larger sons stopping whenj larger sons reached exchangeis needed involved exchanges loop inthis program loop distinct exits case heap hit case heap condition satisfied theinterior heap implementation remove operation simple function remove integer beginremove  downheap  return set element size heap decremented leaving downheap fixup heap condition implementation replace operation plicated priority queues135function replace integer integer begina downheap  replace code artificial sons   islarger largest element heap heap touched otherwisev heap  returned delete operation arbitrary element heap thechange operation implemented simple combination ofthe methods priority element position kis raised upheapcan called lowered downheapdoes job hand join operation difficult andseems require sophisticated data structure basic operations insert remove replace downheap upheup delete change involve moving path root hot tom heap includes log elements heapof size running times programs logarithmic heapsortan elegant efficient sorting method defined basic opera tions heaps outlined method called heapsort extramemory guaranteed sort elements mlog steps nomatter input loop bit longerthan loop quicksort slow quicksort average idea simply build heap elements sortedand remove order continue bethe size heap number elements sorted sort implement construct operation insertoperations lines code removeoperations putting element removed place vacated theshrinking heap insert downto  remove chapter this code breaks rules abstract data structures assuming ticular representation priority queue loop priority queue resides  reasonable becausewe implementing sort priority queue priority queue proce dures descriptive purposes actual implementa tion sort simply code procedures avoid unnecessary procedure calls build heap backwards throughit making heaps note position thearray root small heap downheap work equally forsuch small heaps big heap remove beimplemented exchanging elements decrementing andcalling downheap  leads implementation heapsort procedure heapsort var integer beginn div  downto  downheap repeatt  downheap   lines code constitute implementation construct integer build heap elements keys div   eachform heaps element trivially satisfy heap condition anddon checked interesting note loops program things built fundamental procedure table contents heap operated bydownheap sorting downheap heapcondition hold priority queues137123456789      asortingexamplenl epm ixt arg ep0 nm exr tg axtprsongeaamiletspreongeaamilsrpleongeaamir pieongeaamp iemngeaaolniemageanlmieaagem eieaagliegeaaigeaeag aa aaaaeegilmnoprstxas mentioned primary reason heapsort practicalinterest number steps required sort elements guaranteedto proportional log matter input othermethods ﬁworst caseﬂ input heap sort slower proof simple m  calls todownheap  construct heap sort ofwhich examines log heap elements heap morethan elements proof overestimate fact proventhat construction process takes linear time small heaps areprocessed heapsort timeis dominated log time sorting forother priority queue applications linear time construct lead toa linear time algorithm note constructing heap successiveinserts requires log steps worst case turns belinear average chapter indirect heapsfor applications priority queues records movedaround priority queue routine whichof records largest returning values akinto ﬁindirect sortﬂ ﬁpointer sortﬂ concept ning chapter  modification programs work straightforward confusing worthwhile amine convenient heaps thisway rearranging keys array priorityqueue routines work array heap indices array suchthat heap key kth element heap  andn maintain array inv heapposition kth array element inv entry largest element array  wished change heap position inv upheap downheap thefollowing table values arrays sample heap a  eheap lo5134237891111261415a heap   tingexampleinv note heap inv inv heap  start heap inv  thatno rearrangement code heap construction muchthe procedure pqconstruct var integer beginn dobegin heap inv div  downto  pqdownheap priority queues139we prefix implementations priority queue routines based indirect heapswith ﬁpqﬂ indentification chapters modify downheap work indirectly examine theplaces references comparison nowaccess indirectly heap nowmake heap modify inv leadsto implementation procedure pqdownheap integer label  var integer beginv heap div  dobeginj heapij heapb  heaplj goto  heap heap inv heaplj heap inv kend procedures modified fashion toimplement ﬁpqinsert ﬂ ﬁpqchange ﬂ indirect implementation developed based maintainingheap array pointers separately allocated records case alittle work required implement function inv heapposition record advanced implementationsif join operation efficiently implementations thatwe insufficient advanced techniques needed space details methods wecan discuss considerations design ﬁefficiently ﬂ join sametime operations rules linkless repre sentation heaps large heaps bejoined moving elements largearray easy translate algorithms examining uselinked representations fact reasons chapter so inconvenient large contiguous array direct linked representation links nodepointing father sons turns heap condition strong allowefficient implementation join operation advanced data structuresdesigned solve problem weaken heap balance condition order gain flexibility needed join structures operations completed logarithmic time priority queues141exercises1          draw heap operations performedon intitially heap insert insert  insert  replate  insert  insert  remove insert insert  file reverse sorted order heap heap constructed successive application insert keyseasyquestion positions occupied rd largest key heap ofsize  positions occupied rd smallest keyin heap size  sentinel avoid test downheap functions stacks normal queues specialcases priority queues minimum number keys moved aremove largest operation heap draw heap size  whichthe minimum achieved write program delete element postion heap empirically compare methods heap construction inthe text building heaps  random keys contents inv pqconstruct keys question  selection mergingsorting programs applications sort isnot operations sortingbut efficiently selection finding kth smallestelement finding smallest elements file merging combiningtwo sorted files larger sorted file selection merging areintimately sorting wide applicability selection process finding median set ofnumbers student test scores situation mergingmight statistic large class scores divided number individually sorted sections selection merging complementary operations sense thatselection splits file independent files merging joins inde pendent files file relationship operations evident apply theﬁdivide conquerﬂ paradigm tocreate sorting method file rearranged twoparts sorted file sorted broken parts sortedand combined sorted file instance quicksort consists basically selection procedure recursive calls mer gesort quicksort complement consists basically recursivecalls merging procedure selection merging easier sorting sense theirrunning time essentially linear programs time proportional nwhen operating items methods perfect case ways merge place extra space complex reduced practical programs selection methods guaranteed linear worst case  chapter selectionselection applications processing experimental otherdata prominent special case mentioned findingthe median element file item greater half itemsin file smaller half items file medianand order statistics divide file smaller percentile groups isvery common small large file saved furtherprocessing cases program select percent elements file sort algorithm selection kth smallest item file ofn items algorithm guarantee item thekth smallest examined identified  items aresmaller elements larger selection algorithmscan return smallest elements file great deal extracalculation algorithms suitable direct adapta tion selection methods small selection sort work verywell requiring time proportional nk smallest element thenfind smallest finding smallest remaining items larger priority queues provide selection mechanism firstinsert items replace largest times remaining items leaving smallest items priority queue heaps imple ment priority queue place approximaterunning time proportional log interesting method faster average beformulated partitioning procedure quicksort recall thatquicksort partitioning method rearranges array returns aninteger equal greater equal kth smallestelement file fortunate kth smallest element theleft subfile smallest elementin subfile leads recursive formulation selection aad merging145procedure seject integer var begil if thenbegini partition  seject seject endend procedure rearranges array lhat orequal  greater equal forexample seject div partitions array medianvalue keys sorting program threerecursive calls median table       asortingexamplea emtingoxsmplrlingopmmxtsl  nm file rearranged median place smaller elementsto left larger elements equal elements eitherside fully sorted select procedure  notreally recursive sense stael needed remove recursion time recursive simply reset parametersand chapter procedure select integer var  integer   beginl dobeginv  repeatrepeat repeat  alj alj  identical partitioning procedure quicksort quicksort changed equal keys expected note inthis recursive program eliminated simple calculations involving method worst case quicksort tofind smallest element sorted file result quadraticrunning time worthwhile arbitrary random partitioning element median smallestelement sought file split middle theaverage running time proportional iclog linearfor allowed modify quicksort based selection procedure itsrunning time guaranteed linear modifications importantfrom theoretical standpoint extremely complex practical mergingit common data processing environments maintain large sorted data file entries regularly typically anumber entries ﬁbatched ﬂ appended larger mainfile thing resorted situation tailor merging strategy sort small batch entries merge large main file merging applications selection merging147make worthwhile study examine sorting method based onmerging chapter concentrate programs merging pro grams combine sorted input files sorted output file inthe chapter delii multiway merging morethan files involved application multiwaymerging external sorting subject chapter suppose sorted arrays  ofintegers merge array  followingis direct implementation obvious method successively choosing forc smallest remaining element maxint maxint doif blj endelw bb implementation simplified making room arrays forsentinel keys values larger keys arrayis exhausted loop simply moves array array time method proportional implementation extra space proportional size themerge desirable place method input methods exist complicated log inplace sort bemore efficient practical values extra space appears required practical implementation linked list imy lementation fact method isvery suited linked lists implementation illustrates theconventions note code actual merge simple code chapter program listmerge input output type link tnode node record integer link var integer link function merge link link var link beginc repeatif bf kthen endelse bf enduntil maxint merge zf zt zend beginreadln zf maxint zt writelist merge readlist read program merges list pointed list pointed auxiliary pointer lists initially built thereadlist routine chapter  lists defined dummynode points serves sentinel duringthe merge points newly merged list mannersimilar implementation readlist points thenewly merged list node link field changed add newelement list merged list built pointer node retrieved reset point key comparison merge includes equality merge bestable list considered follow list thisstability merge implies stability sorting programs thismerge merging procedure difficult basisfor recursive sorting procedure sort file divide half sort thetwo halves recursively merge halves involvesenough data movement linked list representation mostconvenient program direct recursive implementation afunction takes pointer unsorted list input returns pointer sorted version list program byrearranging nodes list temporary nodes lists allocated selection mierging149 convenient pass list length parameter recursive program alternatively stored list program scan thelist length function sort link integer link var link integer beginif sor elsebegina  div  sort merge sort div  sort div  program sorts splitting list nted halves pointedto sorting halves recursively merge producethe final result program adheres convention listsend input list list explicit instruction puts list thisprogram simple understand recursive formulation thoughit sophisticated algorithm running time program fits standard ﬁdivide conquerﬂrecurrence m  program guaranteed runin time proportional nlogn chapter  file sample sorting keys processed followingtable table result merge wemerge   merge  eventuallywe merge merged  toget  chapter a  tingexample0sa0sr ninrtainorste xa xm paeeglmpxaaeegilmnoprstxthus method recursively builds small sorted files larger version mergesort processes files order scan list performing merges produce sorted sublistsof size  scan list performing   merges producesorted sublists size    merges sorted sublists size8 list sorted sample file sorted passesusing ﬁbottom upﬂ mergesort asortingexamplea sio itig xia pieaorsgintaemxelpaginorstaeelmpxaaeegilmnoprstxin general ogn passes required sort file elements eachpass doubles size sorted subfiles detailed implementation thisidea selection merging151function mergesort link link var head todo link integer beginn ntw head headf repeattodo ieadt head repeatt todo tﬂ todo nest merge  nextuntil hf adf mergesort headf nextend program ﬁlist headerﬂ node pointed head link fieldpoints file sorted iteration outer repeat loop passesthrough file producing linked list comprised sorted subfiles aslong previous pass maintaining pointers oneto list todoi ofthe list subfiles merged repeatloop merges subfiles length starting node pointed bytodo producing subfile length vrhich linked result list actual merge accomplished saking link subfile bemerged skipping nodes temporary link linking zonto list list nodespointed updating todo link node visited thencalling merge updated simply chasing thelist merged simpler efficient method alternatives merge return pointers maintaining multiple pointers list node heapsort mergesort gual anteed log running time likequicksort short loop combines virtues thesemethods perform puts quick chapter as quicksort random files main advantage mergesort thesemethods stable main disadvantage mergesort thesemethods extra space proportional links required itis develop nonrecursive implementation mergesort usingarrays switching array pass discussed chapter  straight radix sort recursion revisitedthe programs chapter quicksort typical plementations divide conquer algorithms algorithms structure chapters worthwhile detailed basic characteristics implementations quicksort ﬁconquer divideﬂ algorithm recursiveimplementation work recursive calls theother hand recursive mergesort spirit divide conquer file divided parts conquered individually problem mergesort actual processing small finish largest subfile processed quicksort starts actualprocessing largest subfile finishes small difference manifests recursive implementations ofthe methods quicksort maintain stack save largesubproblems divided data dependent manner mergesort admits simple recursive version divides file independent data order processes problems rearranged simpler program practical difference manifests mergesort isstable properly implemented quicksort extratrouble mergesort assume inductively subfiles beensorted stably merge stablemanner easily arranged quicksort easy partitioning stable manner suggests possibility stable foreclosed recursion play algorithms simply expressed recursive formulation modern programming environments recursive programs implementing suchalgorithms worthwhile study nature recursive structure program possibility remov ing recursion result simpler efficient implementation algorithm study lead understanding method selection merging153exercises1  empirically determine quick sort based partitioning procedure omes faster heaps findthe smallest element randc file  rearrange array n elements smallest keys fall isositions keys fall thenext positions positions largestin positions  recursive calls select median ofthe keys easyquestion  write program rearrange file elements keysequal median place smaller elements left andlarger elements  method application requires selection ofthe lath largest element arbitrary large number timeson file  true false running time mergesort depend orderof keys input file explair answer  smallest number steps mergesort aconstant factor  implement recursive mergesort arraysinstead linked lists  contents linked lists assed arguments whenthe recursive mergesort sort keys easy  contents linked iteration recursive mergesort sort keys easy tio  external sortingmany sorting applications involve processing large files large fit primal memory computer methodsappropriate applications led external methods volve large processing external central processing unit asopposed internal methods studying major factors external algorithms differ ent irst cost accessing itemis orders magnitude greater bookkeeping calculating costs higher cost severe restrictions access depending external storage medium items magnetic tape accessed sequential manner wide variety external storage device types costs velopment external sorting methods dependent current technology methods complicated parameters affect perfor mance clever method unappreciated unused simple change technology definite possibility external sorting reason concentrate general methods chapter ratherthan developing specific implementatjons short external sorting ﬁs istemsﬂ aspect problem cer tainly ﬁalgorithmsﬂ ispect areas carefullyconsidered effective external sort developed primary costs inexternal sorting input output good exercise planning implement efficient program sort large file implementan efficient program copy large file easy implementan efficient program reverse order elements large file systems problems solve problems efficiently external sorts permuting large external filein trivial diffictllt sorting key155 cwapter comparisons required external sorting concernedwith limiting number times piece data moved theexternal storage medium primary memory suchtransfers efficiently allowed hardware external sorting methods developed suitable thepunched cards paper tape magnetic tapes disks ofthe bubble memories videodisks future sential differences devices relative size speedof storage types data access restrictions centrate basic methods sorting magnetic tape disk devices remain widespread illustrate fundamen tally modes access characterize external storage sys tems modern computer systems ﬁstorage hierarchyﬂ progressively slower cheaper larger memories algorithms adapted environment butwe deal exclusively ﬁtwo levelﬂ memory hierarchies consisting mainmemory disk tape sort mergemost external sorting methods general strategy firstpass file sorted breaking blocks size internal memory sort blocks merge sorted blockstogether making passes file making successively largersorted blocks file sorted data accessed ina sequential manner method externaldevices algorithms external sorting strive reduce number passes file reduce cost single pass close cost copy cost external sorting method input output rough measure cost sort merge counting numberof times word file read written number passes data applications methods involve order passes note implies reinterested methods eliminate single pass runningtime external sort easily estimated running time ﬁreverse file copyﬂ exercise suggested balanced multiway mergingto trace steps simplest sort mergeprocedure file suppose records keys asortingandmergingexampleonaninputtape external sorting157are sorted output tape ﬁtapeﬂ simply meansthat restricted read records isequentially record tbe read assume enoughroom records computer memory plenty oftapes step read file lree records time sort tomake record blocks output sorted blocks read ina  output block  read output blocki order blocks merged tapes merge wewould tapes configuration thesorting pass tape  s1 xtape  tel ptape  ngin enow ready merge sorted blocks size weread record input tapl room thememory output smallest key recordfrom tape record output read recordin memory smallest key output wordblock input encountered tape blocks tapes processed records output process repeated merge word block tape word block whic1 output tape getready merge continuing long blocks configuredas taped  ttape  rtape   xnow merge completes sort muchlonger file blocks size  tape finish thesecond pass blocks size  tapes    pass produce blocks size  tapes    needsix tapes sort arbitrarily large file input chapter output merge fourtapes output tape blocks thattape distributed input tapes merging passes method called balanced multiway merge reasonable gorithm external sorting good starting point implementationof external sort sophisticated algorithms thesort  faster hand whenexecution times measured hours uncommon externalsorting small percentage decrease running time helpful and50 suppose manipulated sort aninternal memory size ﬁsortﬂ pass produces sortedblocks estimate assumes word records larger records numberof sorted blocks computed multiplying record size ifwe merges subsequent pass number subsequentpasses logp pass reduces number sortedblocks factor small examples understand details gorithm terms large files working withexternal sorts formula  merge sort  word file computer  memory total passes rough estimate runningtime multiplying running time reverse filecopy implementation suggested replacement selectionit turns details implementation developed anelegant efficient priority queues priorityqueues provide natural implement multiway merge impor tant turns priority queues initial sorting passin produce sorted blocks longer fit internal memory basic operation needed merging repeatedly outputthe smallest smallest elements output blocksto merged element replaced element fromthe block replace operation priority queueof size needed ﬁindirectﬂ verions thepriority queue routines chapter  forthis application merge filling priority queue size smallest element inputsusing pqinsert procedure chapter  appropriately modified external sorting159the smallest element larl heap pqreplace procedure chitpter  modified output smallest element replace priority queue thenext element block table result merging  withi merge a aai0gi0in0nr00rr ttthe lines table represent contents heap size usedin merging process keys block theﬁheap conditionﬂ key smaller andthird output replaced  key itsblock violates heap condition  exchanged othera output replaced key block violate heap condition change continuing produce sorted file read tableto keys order heap positionand output block exhausted sentinel heapand considered larger keys heap consistsof sentinels merge completed priority queues issometimes called replacement selection merge replacement selection priorityqueue size element output ogp steps thisperformance difference practical relevance brute force implementation elernent output steps isnormally small cost dwarfed cost outputtingthe element real placement selection thatit scrt merge process form initialsorted blocks provide basis merging passes chapter the idea pass unordered input large priority queue writing smallest element priority queue andalways replacing element input additional proviso element smaller sinceit current sorted block bemarked member block treated greater elements current block marked element thepriority queue block ended block started thisis easily implemented pqinsert pqreplace chapter  againappropriately modified smallest element heap pqreplace changed treat marked elements greater unmarked elements file demonstrates replacement selection internal memory capable holding records canproduce sorted blocks size      illustrated followingtable step diagram key input boxed contents heap key input theorder keys occupy position heap order inwhich output asterisks keys heap belong blocks element marked element root belongs current sorted block belong sorted block heap condition key maintained elements sorted block considered greater elements current sorted block illi0t0i lla did a0rstg  sssi aaa00e eﬂq riri eipi t0g  t111 riel mﬂ qn r0m llg rup qe r0en dial pqreplace called returns output andd considered greater sifts heap external sorting161it keys random runs produced usingreplacement selection size produced usingan internal method practical save merging pass starting sorted runs size internal memoryand merging pass produce runs size theinternal memory start runs size ofthe internal memory replacement selection priority queue ofsize order keys runs longer key larger keys file file completely sorted replacement selection pass merging practical reason method summary replacement seleclion technique boththe ﬁsortﬂ ﬁmergeﬂ steps balanced multiway merge sort word records internal memo size  tapes firstuse replacement selection priority queue size produce initialruns size m random situation longer file partiallyordered replacement selection priority queue size forabout log m fewer merge passes practical considerationsto complete implementation llorting method outlined isnecessary implement inputroutput functions transferdata processor ernal devices functions areobviously key good performance external sort justas require careful consideratisw systems opposed toalgorithm issues readers unfamiliar computers ﬁsystemsﬂ levelmay skim paragraphs major goal implementation overlap reading writing computing large computer systems haveindependent processing units controlling large scale input output devices overlapping pos ible efficiency achievable anexternal sorting method depends number devices file read written standard systems program ming technique called double buffering maximize theoverlap computing idl maintain ﬁbuffers ﬂ onefor main processor device processorwhich controls device input processor buffer input device filling processor finished usingits buffer waits input device filled buffer buffersswitch roles processor data filled buffer chapter the input device refills buffer data processor technique works output roles processor andthe device reversed time greater processingtime double buffering overlap computation timeentirely buffers large difficulty double buffering halfthe memory space lead inefficiency large numberof buffers involved case merging small problem dealt technique called forecasting whichrequires extra buffer merging process forecasting works overlap input withcomputation replacement selection process overlap inputof buffer filled processing thealgorithm easy determine buffer inputbuffer emptied lust item smallest whenmerging  buffer bethe simple overlap processing withinput multiway merging extra buffer filledby input device rule processor encounters anempty buffer waits input buffer filled filledalready switches buffer directs input deviceto filling buffer emptied forecasting rule decision implementation themultiway merge choice ﬁorderﬂ merge fortape sorting sequential access allowed choice easy pmust chosen number tape units themultiway merge input tapes output tape thereshould input tapes sense tapesorting tapes disk sorting access arbitrary positions allowed issomewhat expensive sequential access reasonable tochoose number disks avoid thehigher cost sequential access involved iftwo input files disk alternative commonly pick large sort complete mergingphases unreasonable sort pass pass sort small replacementselection produces m runs merging pass divides thenumber runs chosen smallest integerwith m sorting  word file acomputer word memory implies  asafe choice ensure pass sort computed external sorting163exactly sort phase completed choice twoalternatives lowest reasonable highest reasonablevalue dependent systems parameters bothalternatives considered polyphase mergingone problem balanced multiway merging tape sorting itrequires excessive number tape units excessive copying forp merging p lpes input output copy file single output tape inputtapes merging passes effectively doubles number passesto og m severalclevl tape sorting algorithms beeninvented eliminate virtually copying changing inwhich small sorted blocks merged prominent ofthese methods called polyphase mergir basic idea polyphase merging distribute sorted blocksproduced replacement selection unevenly availabletape units leaving thc apply ﬁmerge emptyﬂstrategy point output tapes input tape switchroles suppose tapes start outwith initial configuration sorted blocks tapes thiscomes applying replacement selection file internal memory hold records tape  tin agn demr gintape  egx amp eltape   merges tape3   tape  tapebecomes left configuration tapel demr intape  tapes aegor stx aimnp aeglnthen  merges tapes   tape  tapebecomes leaving tape  tapez adeegmorrstx agiimnnptape3 aegln chapter the sort completed steps merge fromtapes   tape  leaves file tape  file tape  atwoway merge tapes   tape  leaves entire sorted file ontape  ﬁmerge emptyﬂ strategy extended work bitrary number tapes tape units t4 start output tape initial runs  initial runs t4  initial runs afterrunning  ﬁmerge ﬂwe t4  long runs  runs  runs point rewindtl input tape rewind t4 output tape continuing eventually sorted file t4013                 the merge broken phases involve data direct copying involved main difficulty implementing polyphase merge determinehow distribute initial runs difficult build thetable working backwards largest number add numbers previous corresponds defining highest order merge previous technique works number tapes numbers ﬁgeneralized fibonacci numbersﬂwhich interesting properties number initial runsmay advance generalized fibonacci number number ﬁdummyﬂ runs number initial runs needed table analysis polyphase merging complicated interesting yieldssurprising turns method fordistributing dummy runs tapes involves extra phases andmore dummy runs needed reason thatsome runs merges external sorting165there factors ken consideration implement ing efficient tape sorting method major factor whichwe considered timt takes rewind tape thissubject studied extensively ant fascinating methods beendefined mentioned savings achievable simplemultiway balanced merge limited polyphase merging onlybetter balanced merging small forp  balanced merging aster polyphase smallerp polyphase basically sue tapes balanced merge withtwo extra tapes faster easier waymany modern computer systems provide large virtual memory capabilitywhich overlooked imp ementing method sorting verylarge files good virtual memory syf tem programmer abilityto address large data leaving responsibilityof making addressed data lransferred external internalstorage needed strategy relict fact programs havea small ﬁlocality referenceﬂ reference memory tobe area memory close referencedareas implies transfers rternal internal storage neededinfrequently int ernal sorting method small locality reference canwork virtual memory quicksort twoﬁlocalitiesﬂ references partitioning pointers check systems programmclr large file method radix sorting locality reference whatsoever disastrous virtual memory quicksort couldcause problems depending virtual memory systemis implemented hand strategy simple internalsorting method sorting disk files desl rves consideration goodvirtual memorv environment exercises1 external selection kth largest afile elements large file fit mainmemory  implement replacement selection algorithm test theclaim runs produced internal memory size  worst happen replacement selection toproduce initial runs file records priority queue sizem  sort contents disk storage exceptmain memory  sort contents disk tape mainmemory  compare  tape  tape multiway balanced merge polyphasemerge number tapes  initial runs  phases  tape polyphase merge started withfour tapes     runs  suppose  initial runs  tape polyphase merge onerecord long distributed     initially records arethere files involved merge  small files handled quicksort implementation berun large file virtual memory environment  organize external priority queue designa support insert remove operations chapter  number elements priority queue grow large queue fit main memory sources sortingthe primary reference volume knuth sseries sorting searching virtually topicthat touched book quoted performance chal acteristics algorithmsare backed complete mathematic analyses knuth book vast literatllre sorting knuth rivest s1973 bibliography hundreds entries include thetreatment sorting countless books ind articles subjects tomention work  quicksort reference hoare original  paper whichsuggests variants including selection discussedin chapter  details mathematical analysis practical effects modifications embellishments suggested years fat author  thesis good advanced priority queue structure mentioned inchapter  vuillemin ﬁbinomial cueuesﬂ implemented analyzedby brown data structure supports priority queueoperations elegant efficient manner impression myriall details reducing algorithms likethose discussed general purpoire practical implementations readerwould advised study reference material computersystem sort utility material necef sarily deals formats ofkeys records files details interestingto identify algorithms themselv brought play brown ﬁimplementation lysis binomial queue algorithms ﬂsiam journal computing   august  hoare ﬁquicksort ﬂ computer journal    knuth art computer programming volume sorting andsearching addison wesley reading m9 printing  rivest knuth ﬁbibliogiaphy  computing sorting ﬂ puting reviews   june  sedgewick quicksort garland york  appeared theauthor dissertation stanford university  searchingcfi  elementary searching methodsa fundamental operation intrinsic great computational tasksis searching retrieving partic liar large amountof stored asdivided records record haling key searching thegoal search records keys matching search key purpose search ccess record key processing common terms data structures searchingare dictionaries symbol tables english language dic tionary ﬁkeysﬂ ﬁrecordsﬂ entries withthe definition pronunciation formation prepare learning appreciating searching methodsby thinking implenent allowing access anenglish language dictionary symbol table dictionary program ﬁkeysﬂ symbolic names program ﬁrecordsﬂcontain describing objet named searching sorting havt programs widespreaduse frequent basis vrill worthwhile study varietyof methods sorling someelementary methods small tables specialsituations illustrate fundamental techniques exploited advancedmethods methods stelre records arrays eithersearched key comparisons key afundamental method builds structures defined key values priority queues search algorithms belong ing packages implementing variety generic operations beseparated implementations alternate implementations substituted easily operations include  chapter initialize data structure search record records key insert record delete record join dictionaries large sort dictionary output records sorted order priority queues convenient combine theseoperations search insert operation included forefficiency situations records duplicate keys keptwithin data structure methods determinedthat key data structure internal state ofthe search procedure precisely needed insert record key records duplicate keys handled ways depending application insist primary searchingdata structure records distinct keys ﬁrecordﬂ inthis data structure link list records key convenient arrangement point view design searching algorithms convenient applications records search key returned onesearch possibility leave records equal keys theprimary searching data structure return record keyfor search simpler applications process record time order records duplicate keys processed inconvenient algorithm design point view mechanism retrieving records key provided possibility assume record unique identifier key require search record witha identifier key complicated mechanism couldbe distinguish records equal keys fundamental operations listed applica tions large number basic organizations suggested tosupport efficient combinations operations chapters concentrate implementations fundamental functions search insert initialize comment ondelete sort priority queues join operationnormally requires advanced techniques considerhere sequential searchingthe simplest method searching simply store records array elementary searching methcds173then array sequentially time record sought thefollowing code implementation basic functions simple organization illustrates sorle conventions usein implementing searching methods type node record key info integer var array maxn node integer procedure initialize function seqsearc integer integer integer begina key thenrepeat  key seqsearch xend function seqinsel integer integer beginn key seqinsert code processes records integer keys key ﬁassociatedinformationﬂ info sorting vrill applicat ionsto extend programs handle complicated records keys butthis fundamentally change algorithms info bemade pointer arbitrarily complicated record structure sucha case field serve unique identifier record distinguishing records equal keys search procedure takes arguments implementation thekey sought array includedto handle case records key succes sively executing search starting successively set tothe record key sentinel record key sought whichensures search terminate involves onlyone completion test loclp loop finished testing returned reater thesearch sentinel key table analogous ouruse sentinel record smallest largest key simplify chaf ter the coding loop sorting algorithms method takes steps unsuccessful search recordmust examined decide record key absent  steps average successful search ﬁrandomﬂsearch record table require examining half entries average sequential list searchingthe seqsearch program purely sequential access records naturally adapted linked list representation records advantage easy listsorted implementation type link rnode node record key info integer link var head link integer procedure initialize beginnew zt head headf function listsearch integer link link beginzf key repeat key key listsearch telselis tsearch zend function listinsert integer link link var link beginzf key nextt key key jistinsert sorted list search terminated unsuccessfully recordwith key larger search key half elementary searching metho ds175records examined unsuccessful search sortedorder easy maintain record simply inserted thelist point unsuccessful search terminates usual linked lists dummy header node head tail node code tobe simpler listinsert head node key pointed field thehead listsearch repeated calls listsearch linksreturned return records duplica keys tail node asentinel lis6search returns search wasunsuccessful relative frequency access variousrecords substantial savings oftc realized simply ordering therecords intelligently ﬁoptimalﬂ arrangement frequentlyaccessed record frequently accessed record position technique effective small set records frequently accessed frequency access anapproximation optimal arrangerlent achieved ﬁself organizingﬂ search time record accessed beginningof list method conveniently implemented linked listimplementation running time method dependson record access distributions difficult predict ingeneral suited common situation mostof accesses record tend happen close binary searchif set records large total search time significantlyreduced search procedure based applying ﬁdivide conquerﬂ paradigm divide set records parts determine whichof parts key sought elongs concentrate thatpart reasonable divide sets records parts therecords sorted indices sorted array delimit array worked key table compareit element middle position table smaller thenit half table greater thesecond half table apply method recursively onerecursive involved simpler express method iteratively thisbrings directly implementation assumes thearray sorted chapter function binarysearch integer integer var  integer begin1  repeatx div  key  until key key binarysearch xelsebinarysearch end quicksort radix exchange sort method pointers  andr delimit subfile worked time theloop variable set point midpoint current interval andthe loop terminates left pointer changed  theright pointer changed depending search isequal greater key record stored table subfiles examined method whensearching table built inserting keys aaaceeeghilmnprsxaaaceeegmilmnprsxilmmprsx pns xrls xthe interval size halved step total number oftimes loop gn time required toinsert records high array sorted records bemoved room records record smaller key record table entry movedover position random insertion requires  records moved average method applications involve insertions elementary searching methods177some care exercised pro erly handle records equal keysfor algorithm returned cmluld fall middle block ofrecords key loops scan directions indexshould pick records case runningtime search proportional lg number records sequence comparisons binary search algorithm ispredetermined specific sequence based keybeing sought comparison structure simplydescribed binary tree structure binary tree describes thecomparison structure keys searching key instance compared isgreater compared otheruise compared toc algorithms explicitly constructed binarytree structure guide search improvement suggested binary search guess moreprecisely key sought falls tvithin current interval blindly middle element step mimics theway number telephone directory thename sought ear beginswith method called interpolation search requires simple modification program programabove place search midpoint interval computedwith statement div  derived computationz   middle interval computed adding half sizeof interval left endpoint inte polation search simply amounts toreplacing formula estima key basedon values middle theinterval key key luck chapter x jcey div jcey key assumesnumerical key values suppose ith letter thealphabet represented number search firsttable position examined         thesearch completed steps aaaceeeghilmnprsxphs x0 sxother search keys efficiently arefound step interpolation search manages decrease number elements amined oglogn slowly growing function whichcan thought constant practical purposes billion glgn  record accesses stantial improvement conventional binary search method thisassumes keys distributed interval require computation small ogn cost straight binarysearch close log log cost interpolating likelyto worthwhile interpolation search considered forlarge files applications comparisons expensive orfor external methods high access costs involved binary tree searchbinary tree search simple efficient dynamic searching method whichqualifies fundamental algorithms computer science sclassified ﬁelementaryﬂ method simple factit method choice situations idea build explicit structure consisting nodes eachnode consisting record key left links theleft links null point nodes called left sonand son sons roots trees called leftsubtree subtree followingdiagram nodes represented encircled key values links bylines connected nodes elementary searchtng methods179eare chithe links diagram point linkpoints left link null defining property tree node pointed onlyone node called father assume existence imaginarynode points root defining property binary tree thateach node left links arching node recordwith key binary search tree insist records smallerkeys left subtree  records subtree havelarger equal key values simple ensurethat binary search trees built successively inserting nodes satisfy defining property search procedure binarysearch suggests thisstructure record  key compare theroot smaller left btree equal itis greater subtree apljy method recursively eachstep guaranteed parts tlie tree current subtreecould records key size interval binarysearch shrinks ﬁcurrent subtreeﬂ smaller procedure stopseither record key founcl record whenthe ﬁcurrent subtreeﬂ ﬁbinary ﬂ ﬁsearch ﬂ andﬁtreeﬂ admittedly overuse  point reader shouldbe understand difference betlveen binarysearch function givenabove binary search trees binarytree sequence comparisons function searching array construct2 data structure records connectedwith links search chapter type link tnode node record key info integer  link var head link function treesearch integer link link beginzt key repeatif key runtil key treesearch xend sequential list searching coding program simplifiedby ﬁtailﬂ node insertion code issimplified tree header node head link points theroot search record key set treesearch head node left subtree left link set topoint sequential search sought stopan unsuccessful search ﬁcurrent subtreeﬂ pointed neverbecomes searches ﬁsuccessfulﬂ calling program cancheck link returned points determine searchwas successful convenient links point aspointing imaginary external nodes unsuccessful searches atexternal nodes normal nodes cont keys called internalnodes introducing external nodes internal nodepoints nodes tree implementation allof external nodes represented single node sought tree compared againste key root compared keyin left son node continuing comparednext node links node containingc pointers search terminates compared itselfin search unsuccessful insert node tree unsuccessful search hook place point search terminated inthe code elementary searching methods181function treeinsert integer link link var link beginrepeatf key  x7  key key  treeinsert xend insert key tree tree header node pointed head wecall treeinsert head insertion track ofthe father proceeds tree tree reached points node link changed point tothe node inserted function returns link newly created nodeso calling routine info field node key equal key treeis inserted inserted node tree records key equal processed successively setting tosearch sequential searching mentioned convenient tree header node headwhose link points actual root node tree key issmaller key values simplicity  assuming keysare positive integers left link head tree isrepresented link head point constructed thefollowing code procedure treeinitialize beginnew head headt key headf head node insertedinto tree constructed treeinitialize diagram tree constructed sample keys areinserted initially tree chapter the nodes tree numbered order inserted nodes tree construction process traced diagram tree records beeninserted simply tree consisting nodes numbersless keys letters sort function free binary search trees areused binary search tree represents sorted file theright recursive program procedure treeprint link beginif thenbegintreeprint printnode treeprint endend elementary searching methodsthe treeprint head7 print keys tree order thisdefines sorting method remarkably quicksort thenode root tree playing role partitioning element quicksort major difference tree sorting method extra memory links quicksort sorts extramemory running times algorithms binary search trees depen dent shapes trees case tree shaped likethat describing comparison structure binary search lg nodes root external node roughly expect logarithmic search times average ele ment inserted root tree keys inserted random element divide keys half average leading logarithmic search times argument subtrees equal keys happen tree abovefor describing comparison structure binary search built thiswould case algorithm guaranteed logarithmic running time searches root equally key random situation perfectly balanced tree extremely rare random keys inserted turns trees nicely balanced average number steps treesearch tree built bysuccessive insertion random keys proportional  hand binary tree searching susceptible worst case problems quicksort keys inserted order reverse order binary tree search method thesequential search method chapter chapter examine technique eliminating worst case making trees case tree implementations fundamental search insert andsort functions binary tree structures straightforward binary trees provide good recurrent theme studyof searching algorithms delete function cumbersome toimplement delete node binary tree easy node nosons tree lop making linkin father null son tree link son father link aboutnodes sons tree suppose alink node delete node pointed sety node highest key examining treeprint routine convinced node null left link thatit deletion canbe accomplished copying yfkey yf info key info cifapter deleting node pointed delete aboveby copying deleting delete node  copying node  node  deleting node  implementation treedelete procedure description involves fair code cover cases forego details complicated manipulations trees chapter typical searching algorithms require complicated implementations deletion keys tend integral thestructure removal key involve complicated repairs indirect binary search treesas heaps chapter  applications search ing structure simply records moving array records keys wewould search routine array recordmatching key remove record givenindex searching structure array someother adapt binary search trees situation simply theinfo field nodes array eliminate key fieldby search routines access keys records directly viaan instruction info tomake copy key code lluse function bstinsert info integer link refer functionjust treeinsert sets info field givenin argument function bstdelete info integer link todelete node key array info binary search treerooted refer implementation delete function describedabove functions extra copy keys array onein tree function array chapter  key field array ways achieve procedure tree extracts keys records direct achieve ﬁindirectionﬂ binary search trees tosimply linked implementation links justbecome indices array  records key field and fields link references key x7  array references key nocalls tree exists record array head head  insert mth node wewould pass treeinsert simply refer key insteadof replace treeinsert elementary searching methods185way implementing binary search trees aid searching large arrays ofrecords preferred applications avoids extra expense copying keys previous paragraph avoids overhead storage allocation mechanism implied disadvantage space reserved record array links whichcould lead problems large arrays dynamic situation exercises1 implement sequential searching algorithm averages steps successful unsuccessful search keeping records ina sorted array  order keys records keys  intially table search insertusing organizing search heuristic  recursive implementation binary search  suppose i    table positions examinedby interpolation search unsuccessful search k  draw binary search tree inserting records thekeys  initially tree  write recursive program compute height binary tree thelongest distance root external node  suppose estimate ahead time search keysare accessed binary tree keys inserted thetree increasing decreasing order frequency access  modify binary tree search equal keystogether tree nodes tree key node father sons shouldhave equal key  write nonrecursive program print keys binary searchtree order  squares curvefitter values bestformula form describing total number ofinstructions executed binary search tree built randomkeys  balanced treesthe binary tree algorithms previous work fora wide variety applications problem badworst case performance quicksort embarrassinglytrue bad worst case occur practice person algorithm watching files order files reverse order files alternating large small keys files large segment simple structure binary tree search algorithm perform badly quicksort recourse improving situation toresort randomness choosing random partitioning element couldrely laws probability save worst case fortunately binary tree searching general technique enable guarantee worst case occur technique called balancing basis differentﬁbalanced treeﬂ algorithms closely algorithm anddiscuss relates methods apparent implementation balanced treealgorithms case ﬁeasier ﬂ generalconcept algorithm easily implementation morass special symmetric cases program developed chapter searching method nice illustrationof relationship ﬁhigh levelﬂ algorithm description ﬁlow levelﬂ pascal program implement algorithm    treesto eliminate worst case binary search trees flexibilityin data structures flexibility assume wecan nodes trees hold key ll187 chapter allow nodes nodes hold keys node hree links coming records keys smallerthan keys records keys keys andone records keys larger keys  node links coming intervals defined keys nodes standard binary search tree called nodes key links efficient ways definingand implementing basic operations extended nodes sassume manipulate conveniently form trees  tree keys oursearching easy search tree search for0 tree follow middle link root is terminate unsuccessful search linkfrom node insert node    tree unsuccessfulsearch hook node easy thenode search terminates  node turn  node  node easily turned  node wedo insert node  node answer weshould split  node  nodes pass keys furtherup tree keys inserted intoan initially tree start node  node node  node notice asthe search procedure concerned  node exactlyequivalent binary tree balanced trees189efeiia sif algorithm ﬁsplitsﬂ  node binary tree toinsert room ef5b laa snow inserted time inserted room  node  node split  nodes room butthis time extra key inserted father changing  node node inserted splits gcauses split turning root  node split  node father  node method split father happeningall tree easier father node  node splitting  node tree inserted tree this ensures handle situation wereto  node inserting insertion finally leads tree easily insert nodes    trees search splitting  nodes tree time encounter  node connected  node transform  node connected  nodes time encounter  node connected  node shouldtransform  node connected  nodes balanced treesthese transformations purely ﬁlocalﬂ tree examinedor modified diagrammed transformationspasses keys  node father tree restructuringlinks note worry explicitly fatherbeing  node transformations ensure pass eachnode tree node  node tree  node wecan directly insert node transforming  node  nodeor  node  node convenient treat insertion split imaginary  node passes key inserted root tree  node split  nodes node split tree grow level ﬁhigher ﬂthe algorithm sketched previous paragraph dosearches insertions    trees  nodes split theway trees called   trees sinteresting worrying balancing atall trees perfectly balanced distance root toevery external node implies time required asearch insertion proportional log proof treesare perfectly balanced simple transformations performhave distance node root splitthe root case distance nodes root increasedby description sufficient define algorithm search ing binary trees guaranteed worst case performance halfway actual implementation bepossible write algorithms perform transformations dis tinct data types representing    nodes things needto inconvenient direct representation convinced implement simpler twonode transformations overhead incurred manipulatingthe complex node structures algorithms slower thanstandard binary tree search primary purpose balancing provideﬁinsuranceﬂ bad worst case unfortunate haveto pay overhead cost insurance algorithm fortunately simple representation of2   nodes transformations uniformway overhead costs incurred standard binarytree search chapter red black treesremarkably represent    trees standard binary trees  nodes extra bit node idea represent3 nodes nodes small binary trees bound ﬁredﬂ linkswhich contrast ﬁblackﬂ links bind    tree therepresentation simple  nodes represented  nodes connectedby red links  nodes represented  nodes connected red link red links drawn double lines orientation  node legal binary tree drawn oneway represent final tree eliminate links collapse nodes connect result   tree extra bit node store color link pointing node refer    trees represented asred black trees balanced trees193the ﬁslantﬂ  node determined dynamics algorithmto red black trees    tree enforce rule  nodes slant reason trees structural properties follow directly theway defined red links ina row path root external node pathshave equal number black links note path alternating black red long black allpath lengths proportional ogn striking feature tree positioning duplicate keys reflection clear balanced tree algorithm recordswith keys equal node fall sides node severe imbalance result long strings duplicate keys impliesthat nodes key repeated calls searchingprocedure previous chapter real problem nodes subtree rooted node thesame key node simple recursive procedure likethe treeprint procedure previous chapter option requiring distinct keys data structure linked lists records duplicatekeys nice property red black trees treesearch procedurefor standard binary tree search works modification theproblem duplicate keys discussed previous paragraph llimplement link colors adding boolean field red node istrue link pointing node red false black treesearchprocedure simply examines field ﬁoverheadﬂ addedby balancing mechanism time fundamental searching procedure key inserted searched times typical application result improved search times trees balanced cost work balancing searches overhead insertion small thing  nodes  nodes inthe tree breaking loop onlyone extra test node red sons  node shownin implementation insert procedure chripter function rbtreeinsert integer jink link var gg link beginf repeatgg key red red spjit gg  key key rbtreeinsert spjit gg program moves tree gg keptpointing great grandfather grandfather father tree seewhy links needed addition tree external node  node isreached gg  nodecontaining tree pointer gg link changed pointto theoperation split procedure understand implement split operation black representation transformations perform wehave  node connected  node convert balanced trees1953 node connected nodes node connected  node convert  node connected  nodes anew node considered middle node ofan imaginary  node red getsexplicitly tested transformation required encounter node connected node easy transformation works  node connected  node inthe ﬁrightﬂ split marking red sons black leaves situations encounter node connected  node chapter gfx6 situations mirror images canalso occur nodes orientation cases split ofthe  node left red links row illegal situation corrected easily tested code marked red father red action situation bad nodes connected red links transform tree red links point node fortunately simple operation achieves desired easier case red linksare oriented problem  node oriented thewrong restructure tree switch orientation ofthe  node reducing case thecolor flip sons sufficient restructuring tree reorient node involves changing links balanced trees197in diagram represents tree records keysless tz records keys soforth transformation switches orientation node containinga disturbing rest tree keys inti tz touched case transformation effected bythe link gsf gst note carefully thecolors switched analogous cases  nodecould oriented oriented disregarding colors single rotation operation defined anybinary search tree basis balanced tree algorithms isimportant note single rotation improve balance tree diagram rotation bringsall nodes step closer root nodes arelowered step nodes tree afterthe rotation balanced balanced   trees viewed simply convenient identify single rotationswhich improve balance single rotation involves structurally modifying tree thing caution convenient handle fourdifferent cases outlined search key ﬁrediscoverﬂ relevant son grandson node reorienting  node search node leads tosomewhat simpler code alternative remembering searchnot links areright left links function reorienting  node search path father function rotate integer link link var link beginif key yf yf keythen gsf gst endelse gsf gsf key yf yf rotate gsend left link left link linktransformations diagram reader check chapter other cases function returns link node doesnot color switch handle case split red set torotate gg black reorients  node consisting thetwo nodes pointed reduces case thesecond case  node oriented finally handle case red links oriented differentdirections simply set rotate reorients ﬁillegalﬂ nodeconsisting nodes pointed nodes samecolor color change reduced tothe case combining rotation case called adouble rotation obvious reasons completes description operations performedby split switch colors sons adouble rotation single rotation function split integer gg link link beginxf red true red false red false red thenbegingf red true gf key key rotate rotate gg red falseend headf red false split xend procedure takes care fixing colors rotation restartsx high tree ensure search lost dueto link long argument list included clarity thisprocedure properly declared local rbtreeinsert accessto variables root  node split procedure root red transforming dummy node node reason statement included atthe split ihe root black assembling code fragments efficient relativelysimple algorithm insertion binary tree structure guaranteed balanced treesto logarithmic number steps searches insertions thisis searching algorithms property justified bad worst case performance simply tolerated achieved cost searching asquickly balanced tree constructed elementary algorithm insertion involves extra bit test occasional split forrandom keys height tree close gn onlyone splits average insertion ableto analyze statistic balanced tree algorithm key fileof half records comparing abouttwenty keys algorithmsthe ﬁtop    treeﬂ implementation ﬁred blackﬂ frameworkgiven previous strategies proposed implementing balanced binary trees ﬁrotateﬂ operations balance trees view trees easy decide rotate views trees lead algorithms mentionbriefly oldest data structure balanced trees theavl tree trees property heights subtreesof node differ condition violated ofan insertion turns reinstated rotations thisrequires extra loop basic algorithm search beinginserted proceed tree path travelled adjusting theheights nodes rotations eachnode height greater heheight brother requires bits encoded straightforwardway bit node balanced tree structure   tree only2 nodes  nodes allowed implement insert anﬁextra loopﬂ involving rotations avl trees quiteenough flexibility convenient version chapter  study type balanced tree anextension    trees called trees keys node forlarge searching applications involving largefiles exercises1 draw    tree built keys  inserted initially tree order  draw red black representation tree previous question  links modified split rotate inserted tree chapter  draw red black tree letters insertedin order general keys inserted trees ascending order  tree links changed double rotation andhow changed implementation  generate random  node red black trees draw handor program compare unbalanced binary searchtrees built keys  generate random looo node red black trees compute number ofrotations required build trees average distance theroot external node trees generate discuss   bit node ﬁcolor ﬂwe represent    nodes types nodes represent  bitsper node ﬁcolorﬂ  rotations required red black trees nodes  nodes ﬁunbalancedﬂ eliminate rotations allowing4 nodes represented nodes connected red links perfectly balanced  squares curvefitter values thebest formula form gn describing total numberof instructions executed red black tree built randomkeys  hashinga completely approach searching comparison based tree structures provided hashing directlyreferencing records table arithmetic transformations keysinto addresses keys distinct integersfrom  store record key table position ready access key hashing generalizationof trivial method typical searching applications havesuch specialized knowledge key values step search hashing compute hush functionwhich transforms search key table address hash function isperfect keys hash table address hashing search collision resolution process whichdeals keys collision resolution methods studyuses linked lists highly dynamic situation thenumber search keys predicted advance collisionresolution methods examine achieve fast search times recordsstored fixed array hashing good ﬁtime space tradeoff ﬂ nomemory limitation search memory accessby simply key memory address time limitation minimum memory asequential search method hashing reasonable amountof memory time strike balance extremes efficientuse memory fast access memory prime concerns ofany hashing method hashing ﬁclassicalﬂ computer science problem sense thevarious algorithms studied depth great deal empirical analytic evidence support utility201 chapter of hashing broad variety applications hash functionsthe problem address computation hash functionwhich transforms keys table addresses arithmetic computationwith properties random number generators studied needed function transforms keys integers shortcharacter strings integers range  amountof memory ideal hash function easy computeand approximates ﬁrandomﬂ function input output shouldbe ﬁequally ﬂsince methods arithmetic step totransform keys numbers operated large aspossible involve removing bits character stringsand packing machine word assumethat operation performed keys integerswhich fit machine word commonly method prime keyk compute mod straightforward method easyto compute environments spreads key values commonly method linear congruentialrandom number generator m leading bits bkmod word size computer chosen forthe random number generator efficiently computed thanthe method computers advantage spread key values close templ temp temp3 languages pascal suited tosuch operaiions separate chainingthe hash functions convert keys table addresses needto decide handle case keys hash address themost straightforward method simply build linked list tableaddress records keys hash address keys whichhash table position linked list wellbe order leads directly generalization elementary listsearching method discussed chapter  maintaining single list single list header node head discussed maintainm lists list header nodes initialized hashtng203type link fnode node record key info integer link var heads array link link procedure initialize var integer beginnew zt dobegin heads heads procedures chapter  hash functionused choose lists listinsert heads mod add table listsearch heads mod record key successively set listsearch untilt subsequent records key ith letter alphabet represented thenumber hash function kmod thefollowing hash values sample set keys  key asearchingexamplehash if keys successively inserted initially table follow ing set lists result amceg ner saelpobviously time required search depends lengthof lists relative positions keys lists beleft unordered maintaining sorted lists applicationas elementary sequential search lists short ﬁunsuccessful searchﬂ record key table wecan assume hash function scrambles things chapter the lists equally searched sequential list searching list searched traversed halfway average averagelength list examined counting unsuccessfulsearch               theaverage time unsuccessful search lists unordered keepingthem ordered cut time half ﬁsuccessful searchﬂ records table assume record equally sought keys list item examined befound item examined average            count assumes equal keys distinguished witha unique identifier mechanism search routine modifiedappropriately search individual key number keys table larger goodapproximation average length lists chapter  unsuccessful successful searches expected halfwaydown list hashing easy cut time required sequential search factor average separate chaining implementation typically chosen rela tively small large area contiguous memory sprobably choose large lists short tomake sequential search efficient method ﬁhybridﬂ methods binary trees linked lists worth trouble implementation hash table links headersof lists actual keys maintaining list header nodes issomewhat wasteful space worthwhile eliminate andmake heads table links keys lists leads complication algorithm adding record list operation adding record list involves modifying entry table links field record alternate implementation key table space premium carefullyanalyze tradeoff wasting space table links wastingspace key link list bigger thenthe alternate method small enoughthat extra convenience list header nodes justified open addressingif number elements hash table estimated inadvance worthwhile links hashtable methods devised store records table hashing205of size relying places table collisionresolution methods called open addressing hashing methods simplest open addressing method called linear probing thereis collision hash place table occupiedand key search key probe position table compare key record search key outcomes probe keysmatch search terminates record search terminates unsuccessfully probe position continuing search key table position ifa record search key inserted unsuccessfulsearch simply table space terminated search method easily implemented type node record key info integer var array node function integer integer mod mend procedure hashinitialize var integer beginfor key maxint function hashinsert integer integer var integer beginx key maxint  mod key hashinsert linear probing requires special key signal spot thetable program maxint purpose computation  mod corresponds examining position wrapping thebeginning table reached note program doesnot check table filled capacity happen thiscase implementation hashsearch hashinsert simply addthe condition ﬁa key vﬂto loop delete followinginstruction stores leaves calling routine task chapter of checking search unsuccessful testing tableposition returned successful maxi unsuccessful conventions hashsearch return mfor unsuccessful search reasons obvious openaddressing large numbers records duplicate keys processed hashsearch easily adapted handle equal keys case record unique identifier set keys  hash values key asearchingexamplehash the table steps successively inserting aninitially hash table  saaesaam esaac e0hsaac ehiiisaac eh i0nsaac e0ghinsaac ghisaac smbimweeghixnsaacaeeghix0mnsaacaeeghixmnsaacaeeghixl llmnsaaca lmn0rrrrrr rr0p rp rpr hashing207the table size greater thetotal memory space links theaverage number items examined successful search     linear probing hashing method works guaranteesthat searching key key hashesto table address key table linear probing keys examined especiallywhen table search xinvolved hash worse insertion key hash drastically increasethe search times keys hash values insertionat position  greatly increased search times position  phenomenon called clustering linear probing slowly tables fortunately easy virtually eliminate clusteringproblem double hashing basic strategy difference isthat examining successive entry collided position hash function fixed increment ﬁprobeﬂsequence easily implemented inserting beginningof procedure changing  mod mod withinthe loop hash function chosen care program work lead aninfinite loop collision relativelyprime probe sequences short case u easily enforced makingm prime hash function ﬁdifferentﬂfrom complicated clustering occur function hz  mod  produce good rangeof ﬁsecondﬂ hash values sample keys hash values keyasearchingexamplehash1 hash2 the table produced successively inserting sample keysinto initially table double hashing values chapter    a0s aais asms asb0ccccccccccc0clele0aeal eareihiarehl2 lareh i0nar eigi inar0eth imn0ar0eghienm areghiem0nx arcleghiear lmnx areghieamnx eghieammnxpar pmrthis technique space linear probing theaverage number items examined successful search smaller   z1  table avoided probes insert open addressing methods inconvenient dynamic situation unpredictable number insertions deletions beprocessed big table estimate insertions expected performance degrades drastically table starts common solution problem rehash larger table infrequent basis word caution deletion record simply removed froma table built linear probing double hashing reason laterinsertions table skipped record searchesfor records terminate hole left deleted record solve problem special key serve placeholder searches identified remembered hashing209empty position insertions note table size deletion aparticular problem separate chaining analytic resultsthe methods discussed analyzed completely pos sible compare performance formulas summarized detailed analyses knuth book onsorting searching average number items examined probes forunsuccessful successful searching methods studied theformulas conveniently expressed terms ﬁload factorﬂ thehash table note separate chaining  methods  unsuccessfulsuccessfulseparate chaining    zlinear probing           double hashing   ofor small turns formulas reduce basic result thatunsuccessful search takes  probes successful search takesabout  m probes cost unsuccessfulsearch separate chaining reduced half ordering lists formulas badly performance degrades open addressing close  large table  linearprobing  probes unsuccessful search compared to10 double hashing comparing linear probing double hashing againstseparate chaining complicated memory availablein open addressing methods links usedshould modified account based relative size keysand links justified choose separatechaining double hashing basis performance choice hashing method applica tion difficult method rarely neededfor situation methods performancecharacteristics long memory resource severely strained generally action simple separate chainingmethod reduce search times drastically number records beprocessed advance good storage allocator double hashing search set keys size beroughly predicted ahead time hashing methods developed applicationin special situations details chapter consider examples illustrate nature specially adapted hashingmethods methods fully knuth book called ordered hashing method making orderingwithin open addressing table standard linear probing thesearch table position record key equalto search key ordered hashing search arecord key greater equal search key table becleverly constructed work method turns reducethe time unsuccessful search successful search kind improvement separate chaining thismethod applications unsuccessful searching frequentlyused text processing algorithm forhyphenating works bizarre cases ﬁbizarreﬂ situation handled small exception dictionary handled ina special searches unsuccessful methods moving records duringunsuccessful search successful searching efficient fact brent developed method average time successful search bounded constant method applications frequent successful searching large tables dictionaries examples large number algorithmic improve ments suggested hashing improvementsare interesting applications usual cautionsmust raised premature advanced methods expertswith searching applications separate chaining doublehashing simple efficient acceptable applications hashing preferred binary tree structures previous twochapters applications simpler canprovide fast constant searching times space large table binary tree structures advantages dynamic advance number insertions needed provide guaranteed worst case performance hash place hashing method support wider range operations sort function factors notimportant hashing searching method choice  hashing211exercises1 implement hash function making agood random number generator sense implement arandom number generator making hash function  long worst case insert keys initiallyempty table separate chaining unordered lists answer thesame question sorted lists  contents hash table keys  inserted order initially table size  linear probing kmod  hash functionfor lath letter alphabet  contents hash table keys yq  inserted order initially tableof size  double hashing previous question hz  mod  hash function  probes involved double hashing tobuild table consisting equal keys  hashing method application manyequal keys  suppose number items hash table knownin advance condition separate chaining preferable double hashing  suppose programmer bug double hashing code oneof hash functions returns  describewhat situation wrong wrong  hash function advance keyvalues fall small range  criticize algorithm deletion hash table built withlinear probing scan element deleted wrapping asnecessary position scan left elementwith hash replace element deleted withthat element leaving table position  radix searchingseveral searching methods proceed examining search keys onebit time comparisons keys eachstep methods called radix searching methods work bits ofthe keys opposed transformed version keys usedin hashing radix sorting methods methods bits search keys easily accessible values searchkeys distributed principal advantages radix searching methods providereasonable worst case performance complication balanced trees provide easy handle variable length keys sav ings space storing key search structure provide fast access data competitive binary search trees hashing disadvantages biased data lead degeneratetrees bad performance data comprised characters biased andthat methods inefficient space radix sorting methods designed advantage particularcharacteristics computer architecture digital propertiesof keys difficult impossible efficient implementations lan guages pascal examine series methods correcting problem inherentin previous culminating method usefulfor searching applications long keys involved addition llsee analogue ﬁlinear time sortﬂ chapter  ﬁconstant timeﬂ search based principle digital search treesthe simplest radix search method digital tree searching algorithm isprecisely binary tree searching than213 chapter branching tree based result comparison keys branch key bits level leading bit isused level leading bit externalnode encountered code virtually codefor binary tree search difference key comparisons arereplaced calls bits function radix sorting recallfrom chapter  bits bits rightand efficiently implemented machine language shifting kbits setting  rightmost bits function digitalsearch integer link link var integer beginzf key maxb repeatif bits    key digitalsearch xend data structures program forelementary binary search trees constant maxb number bits inthe keys sorted program assumes bit key maxb  key result tobits argument maxb searching setting digitalsearch head head link tree header node  keyand left link pointing search tree initialization procedurefor program binary tree search beginwith headf headt chapter  equal keys anathema radix sorting thesame true radix searching algorithm theones examining assume chapter allthe keys data structure distinct linked listcould maintained key records keys thatvalue previous chapters assume ith letter alphabetis represented bit binary representation thefollowing sample keys chapter radlx searching215aserchingxmpl0000110011   to consistent hits bits numbered  fromright left bit  nonzero bit bit  nonzerobit insert procedure digital search trees derives directly thecorresponding procedure binary search trees function digitajinsert integer link link var link integer beginb maxb repeatf bits  key bits  digitalinsert xend algorithm works key  tree leading bits  left hit external node left ofx inserted crapter the worst case trees built digital searching betterthan binary search trees length longest path digitalsearch tree length longest match leading bits betweenany keys tree short isobvious path longer number bits thekeys digital search tree built character keys bits character path longer  thereare hundreds thousands keys random keys digital search treesare perfectly balanced height gn providean attractive alternative standard binary search trees provided bitextraction easily key comparison thecase pascal radix search triesit case search keys long consisting oftwenty characters situation cost comparing searchkey equality key data structure dominant costwhich neglected digital tree searching comparison ateach tree node onlyone comparison search cases idea store keys tree nodes allthe keys external nodes tree externalnodes structure nodes search keys types nodes internal nodes links nodes external nodes keys links fredkin radlx searching217named method ﬁtrieﬂ retrieval conversation susually pronounced ﬁtry eeﬂ ﬁtryﬂ obvious reasons search fora key structure branch bits compare external node keyin tree stored external node path leadingbit pattern key search key winds external node soone key comparison completes search unsuccessful search insert key sought replacingthe external node terminated search imternal node whichwill key sought key terminated search externalnodes keys agree bit positions add external nodes correspond keysin tree internal nodes emptyexternal node son binary radix search trie sample keys inserting llolo tree involves replacing internalnode left son internal node sons implementation method pascal plicated necessity maintain types nodes ofwhich pointed links internal nodes algorithm low level implementation simpler high level implementation omit code improvement avoids problem left subtree binary radix search trie keys have0 leading bit subtree keys  chapter leading bit leads correspondence radix sorting binary trie searching partitions file radix exchange sorting compare trie partitioning diagram examined radix exchange sorting noting keys correspondence analogous binary tree searching quicksort annoying feature radix ﬁone wayﬂ branching required forkeys large number bits common keys differonly bit require path length equal key length nomatter keys tree number internal nodes larger number keys height trees limited number bits keys thepossibility processing records long keys  bits uniformity occur character encodeddata shorten paths trees thantwo links node exacerbates ﬁspaceﬂ problem toomany nodes ﬁcollapseﬂ paths branchesinto single links discuss methods sections multiway radix searchingfor radix sorting improvement inspeed bit time true radixsearching examining bits time speed search factor m catch morecareful applying idea radix sorting problemis bits time corresponds tree nodes m links lead considerable wasted space forunused links  tree formed oursample keys hil radlx searchtngnote wasted space tree large numberof unused external links larger worse turns outthat number links random keys theother hand efficient searching method running timeis log reasonable compromise struck time efficiency multiway space efficiency methods usinga ﬁhybridﬂ method large levels small elementary method efficient implementations methods complicated becauseof multiple node types level  tree divide keys  cate gories accessible steps tree usefulfor files thousands keys keysper category hand smaller filesof hundreds keys categories andtoo space wasted larger forfiles millions keys categories toomany keys time wasted amusing note ﬁhybridﬂ searching corresponds closelyto humans search things names telephonebook step multiway decision ﬁlet starts aﬂ decisions ﬁit andrews aitkenﬂ sequential search ﬁ algonquin algren algorithms listed ﬁ computers somewhatbetter humans multiway search levels  branching levels reasonable alternativeto keys composed simply letters dictionary chapter systematic adapt structure totake advantage multiway radix searching arbitrary file sizes patriciathe radix trie searching method outlined annoying flaws ﬁone branchingﬂ leads creation extra nodes thetree types nodes tree complicatesthe code insertion code morrison discovereda avoid problems method named patricia ﬁpractical algorithm retrieve coded alphanumericﬂ algorithm precisely form presented morrison interested ﬁstring searchingﬂ applications type chapter  context patricia chapter searching arbitrarily long keys tree nodes requiresonly key comparison search branching avoided simple device node containsthe bit tested decide path thatnode external nodes avoided replacing links external nodes withlinks point upwards tree normal type tree nodewith key links patricia keys nodes notused tree control search stored reference tree reached patricaworks search algorithm operating typical tree thenwe examine tree constructed place examplekeys patricia tree constructed keys successivelyinserted search tree start root proceed tree usingthe bit node bit examine search key bit  left  keys nodes examined tree eventually upwards link isencountered upward link points unique key tree hasthe bits search link theonly key tree matches bit pattern x11 key node pointed upward link encountered equal search key search successful unsuccessful searches terminate external nodes key comparison determine search successful patricia allsearches terminate upwards links key comparison isdone determine search successful futhermore seasy test link points bit indices nodes radlx searching221definition decrease travel tree leads followingsearch code patricia simple code radix tree triesearching type link fnode node record key info integer  link var head link function patriciasearch integer link link var link beginrepeatf bits  patriciasearch xend function returns link unique node recordwith key calling routine st search successfulor search llolo tie tree atthe link key search unsuccessful diagram ransformations rightsubtree tree art x37 pz11r0 search llolo ends node ontaining  definingproperty tree key  tree search wouldterminate node inserted nodes sothe upward link node madeto point node bit theleftmost point differ upward links pointingto pointing corresponds precisely replacing chapter external node internal node sons inradix trie insertion branching eliminated including bitindex insertion loloo illustrates complicated case searchfor ends loooo indicating key tree thepattern x0x differ bit  position skippedduring search requirement bit indices decrease godown tree dictates inserted upward pointer bit  note carefully fact bit  skipped insertion implies bit  examples illustrate cases insertionfor patricia implementation details function patriciainsert integer link link var link integer begint patriciasearch maxb bits bits key  repeatf bits  theu key bits then endelse bits  patriciainsert tend code assumes head initialized key field  bit ofmaxb links upward pointers search key distinguished determine leftmost bit position differ travel tree point insert node point patricia quintessential radix searching method manages toidentify bits distinguish search keys build adata structure surplus nodes leads searchkey key data structure equal radlx searching223same technique patricia binary radix trie searchingto eliminate branching exacerbates multiple nodetype problem standard binary tree search radix methods insensitive tothe order keys inserted thtty depend structure ofthe keys patricia icement upwards links dependon order insertion tree structure depends bits inthe keys methods patricia troublewith set keys     normal key sets tree balanced number bit inspections long keys roughly proportional gn nodes tree feature radix trie searching doneefficiently keys varying length searching methodswe length key ﬁbuilt intoﬂ searching procedure insome running time dependent length keysas number keys spetific savings depends themethod bit access suppose computer whichcan efficiently access bit ﬁbytesﬂ tlata search amonghundreds looo bit keys patricia require access about9  bytes search key thl search  byte equalitycomparison hashing requires accest  bytes search key forcomputing hash function elluality comparisons comparison based methods require long comparisons patricia radix trie searching branching removed search method choice long keys involved exercises1          draw digital search tree keys  inserted initially tree order generate  node digital search tree compare height thenumber nodes level standard binary search tree anda red black tree chapter  built keys set  keys particulary badly balanced digitalsearch trie draw radix search trie keys  inserted initially tree order problem  multiway radix search lettersof alphabet infrequently thisproblem delete element multiway radix searchtree draw patricia tree keys i0 inserted initially tree order set  keys particulary badly balanced patriciatree write program prints keys patricia tree thesame initial bits search key squares curvefitter values bestformula form gn describing total number ofinstructions executed patricia tree built random keys  external searchingsearching algorithms accessing items largefiles immense practical impcrtance searching fundamentaloperation large data files consumes fractionof resources computer installations concerned met hods searching large disk files disk searching practical sequential devicessuch tapes searching degenel ates trivially slow method tosearch tape item mount tapeand read item remarkably methods studycan item disk large billion threedisk accesses external sorting ﬁsystemsﬂ aspect complex ohardware primary factor perfo mance external searching methodsthat study detai sorting theexternal methods differer internal methods seethat external searching methods ogil extensions internal methodsthat studied searching fundamental operaticin disk devices files typicallyorganized advantage device characteristics accessof efficient sorting work witha simple imprecise model diskﬂ devices order explain theprincipal characteristics fundamental methods determining bestexternal searching method particlllar application extremely compli cated dependent characteristics hardware systemssoftware scope book cansuggest general approaches applications frequently change add deleteor access small bits inside very225 chapter large files chapter examine methods dynamicsituations offer kinds advantages straightforwardmethods binary search trees hashing offer binary search andsequential search large collection processed computeris called database great deal study methods building maintaining databases large databases highinertia large database built searchingstrategy expensive rebuild reason older static methods widespread remain thoughthe newer dynamic methods databases database applications systems typically support complicatedoperations simple search item based single key searchesare based criteria involving key expected return large number records chapters examplesof algorithms search requests type general search requests complicated typical doa sequential search entire database testing record meets criteria methods discuss practical plementation large file systems file unique identifierand purpose file support efficient access insertion anddeletion based identifier model disk storageto divided contiguous blocks beefficiently accessed disk hardware hold records task organize records record accessed reading assume thei time required read completely dominates processing timerequired computing involving mentioned thisis oversimplified model reasons retains charac teristics actual external storage devices thefundamental methods indexed sequential accesssequential disk searching natural extension elementary sequentialsearching methods considered chapter  records storedin increasing order keys searches simply readingin records key greater orequal search key search keys frome diskscapable holding records theconfiguration external searching227diskl eeghidisk nnprrstxxas external sorting small examples stand algorithms large examples theirperformance pure sequentizl searching unattractive searching exainple require reading allthe vastly improve speed search disk anﬁindexﬂ keys belong disk followingexample disk  lc2eaaaceeeedisk eli2neghillmndisk3 nlr2xnprrs xthe disk lower case letters thatonly key stored record numbers indices number follotved key andpreceded key previous ﬁ ﬂ asentinel key smaller fordisk  records keys iinclusive records keys ninclusive possil fit keys pageindices records ﬁdataﬂ fact fora disk require indices coupled ﬁmaster indexﬂ tells keys disk master    ﬂ boldface integers disknumbers master small keptin memory records accessed disl theapproriate record searc involve readingthe disk  reading disk  whichis arches keys theindex require reading irdex flanking thekey duplicate keys file extra pageaccess avoided hansl equal keys chapter file accesses called records equal keys mightfill combines sequential key organization indexed access organization called indexed sequential method choice forapplications database infrequently disadvantage indexed sequential access inflexible adding configuration requires virtually thewhole database rebuilt positions keys values indices treesa handle searching dynamic situation balancedtrees order reduce number expensive disk accesses itis reasonable large number keys node nodes large branching factor trees named trees bayer mccreight multiway balancedtrees external searching people reserve term ﬁb treeﬂ todescribe exact data structure built algorithm suggested bayer mccreight generic term ﬁexternal balancedtrees ﬁ algorithm    trees extends tohandle keys node assume  keys node  links node searchingproceeds analogous    trees node thenext proper interval search key current node exit link node continue external node reached insert key intothe internal node reached    trees necessaryto ﬁsplitﬂ nodes ﬁfullﬂ tree time node attached node replace  node attachedto  nodes guarantees reached thereis room insert node tree constructed  oursample keys diagrammed external searching229this tree  nodes disk node mustcontain links records choice  leaves uswith familiar    trees meant emphasize point couldfit records fit leave room links actual space depends relative size recordsand links method wh avoids mixing records andlinks root node stored ﬁ10  ﬂ indicatingthat root subtree records keys equalto  disk  master indexedsequential search memory reasonable root node tree memory nodes stored disk1   h31l3240  disk oaooaocoeo oeodisk3   go0 olomodisk4 onoporoos00x0x0the assignment nodes disk simply proceeddown tree working level assigning nodes todisk  disk  actual ihpplication assignments mightbe avoid searchesgoing disk  assigning  disks intruth sophisticated strategies needed dynamics tree construction diffic ulty implementing split routinethat respects strategies nodes level trees containmany  links eliminated  marking nodes larger  higher levels thetree store keys records interior nodes indexedsequential access aclvantage observations ourexample suppose fit keys links sothat  interior rodes  levelnodes  space  nks reserved node splits record split involvesﬁinsertingﬂ key middle recortl tree operatesas normal tree  stored keys records leads tothe tree chapter the typical application dramatic sincethe branching factor tree increased roughly ratio recordsize key size large type organization ﬁindexﬂ keys links separated actualrecords indexed sequential search diskl         disk aa edisk  gh mdisk4 rst xas root node memory issues discussedabove node placement disks values interior nodes determinesthe branching factor tree mi level nodes whichdetermines allocation records mb minimize numberof disk accesses mi mb large evenat expense extra computation hand wantto mi huge tree nodes andspace wasted mb huge thiswould reduce sequential search level nodes isbest relate mi mb size obvious choice mbis number records fit goal search tofind record sought mi numberof keys fit tree bethree levels deep large files level tree mi can handle  billion entries recall rootnode tree accessed operation tree inmemory disk accesses required element file discussed chapter  complicated ﬁbottom upﬂ insertionmethod commonly trees distinction external searching231down methods loses iml ortance level trees othervariations balanced trees iriportant external searching forexample node itting resultant half emptynodes forestalled dumping contents node ﬁbrotherﬂ node leads space utilizationwithin nodes central concern large scale disksearching application extendible hashingan alternative trees extends digital searching algorithms applyto external searching developed  fagin nievergelt pippenger strong method called extendible hashing guaranteesthat disk accesses search etrees records stored split pieces whenthey indexed sequential access maintain access records match search key extendible hashing combines approaches digital properties ofthe search keys extendible hashing worlcs handles suc cessive insertions keys capacity records start ﬁindexﬂ entry pointer pagewhich hold records records fit leavingthe trivial structure disk  disk  zetxthe directory disk  records  disk  wherethey sorted order keys reference thebinary keys standard encoding bit binaryrepresentation ith letter alphabet split order add ks loolo strategy simple records keys  records keysthat  thi necessitates doubling size thedirectory moving half keys  disk  leaving structure chapter   e0101 e1   rdisk1  tdisk ertx111000 xnow olllo  split neededbefore olloo   a0101 edisk   disk2 aeen rtx10100 t11000 xrecall basic assumption disk units thatprocessing time negligible compared time input output keeping records sorted order keys real expense add record read memory modify write extra time required insert record maintain sorted order noticable typical case whenthe small proceeding split room  splitting pieces keys and keys  clear todo directory alternative simply add entry pointer unattractive essentially reduces indexed sequential search albeit radix version directory scanned sequentially proper search alternatively double size directory structure    a0  e0  e01  lidiski  ndisk elnrtx10   r11   t11000 xnow access record bits key accessdirectly directory entry address external searching233the record continuing add looll oolol beforeanother split add ooool split requires doublingthe directory leaving structure diskl disk  aeee lndisk3 xin general structure built exl endible hashing consists directoryof d bit pattern set leaf containall records keys specific bit pattern orequal bits search entails leading bits key indexinto directory pointc ea referencedleaf accessed searched usin strategy proper record leaf pointed tlian directory entry precise leaf records uith keys specific kbits marked vertical diagram d directory entries pointing   disk  records keys thatbegin  bit dirl ctory entries pointing directory pointc besmaller keys records directory entries fit assume fit directory entriesas records ratio higher practice directory spans ﬁroot nodeﬂ inmemory tells directott indexingscheme directory spans root node mightcontain entries ﬁ10  ﬂ indicatir directory recordswith keys   disk  directory allkeys   disk  splitoccurs inserted continuing weget disk storage structure chapter disk1 disk ceeee gdisk3 illmnndisk4 prr txxas illustrated insertion extendible hashingstructure involve operations leaf couldcontain search key accessed room leaf record simply inserted leaf split half records moved directory entry pointing leaf directory entries split size directory doubled algorithm susceptible bad inputkey distribution largest number bits required toseparate keys sets small fit leaf ifa large number keys agree large number leading bits directory unacceptably large actual large scale applications problem headed hashing keys leadingbits pseudo random search record hash key bitsequence access directory tells tosearch record key hashing standpoint canthink algorithm splitting nodes care hash collisions ﬁextendible hashing ﬂthis method presents attractivealternative trees indexed sequential access usesexactly disk accesses search indexed sequential retaining capability efficient insertion trees hashing extraordinary steps large numbersof equal keys directory artificially large andthe algorithm breaks equal keys fit leaf occurs ifmany equal keys assume distinct keysin data structure pointers linked lists records equal keys leaf complication involved theinsertion structure virtual memorythe ﬁeasier wayﬂ discussed chapter  external sortingapplies directly trivially searching problem virtual memoryis general purpose external searching method address key return address external searching235however direct virtual men ory recommended easysearching application mentioned chapter  virtual memories performbest accesses close previous accesses sorting algorithms adapted nature searching requests arbitr parts database exercises1 contents tree keys  inserted order initially tree withm   contents tree keys  inserted order initially tree withm  variant method records inexternal nodes  draw tree built sixteen equal keys inserted aninitially tree   suppose database destroyed youwould handle event tree structures thetext  contents extendible hashing table thekeys  inserted order initiallyempty table capacity records text hash bit binary representation key ith letter  sequence distinct keys exten dible hashing directory grow size  initially table capacity records  outline method deleting item extendible hashing table  ﬁtop downﬂ trees ﬁbottom upﬂ trees concur rent access data suppose programs insert node time  implement search insert internal searching extendiblehashing method  discuss program previous exercise compares doublehashing radix trie searching internal searching applications sources searchingagain primary reference knuth volume algorithms ldied treated great inthat book including mathematical analyses suggestions practicalapplications material chapter  guibas sedgewick paper fit classical balanced tree algorithms intothe ﬁred blackﬂ framework implementations large literature balanced trees comer survey references subject btrees extendible hashing algorithm presented chapter  fromfagin nievergelt pippenger stron  paper paper mustfor wishing external searching methods tiestogether material chapters   bring algorithm inchapter  trees binary trees purely mltthematical objects studiedextensively computer science great deal aboutthe combinatorial properties objects reader interested studyingthis type material icnuth volume  practical applications thl methods discussed especiallychapter  context slatabase systems introduction tothis field ullman  book comer ﬁthe ubquitous tree ﬂ colrlputing surveys   fagin nievergelt pippenger aild strong ﬁextendible hashing fast access method dynamic ﬂ acm transactions databasesystems   september  guibas sedgewick ﬁa dichromatic framework balanced trees ﬂin th annual sym posium foundations computer science ieee  decade progress   xerox parc palo alto knuth art computer gramming volume  fundamentalalgorithms addison wesley reading iaa  knuth art computer ogramming volume  sorting andsearching addison wesley reading printing  ullman principles database terns computer science press rock ville md  ﬂ ﬁ  ﬁ ﬁ ﬁ ﬁ    string searchingdata processed decompose logically indepen dent records small identifiable pieces type data charac terized fact written string linear typically long sequence characters strings central ﬁword processingﬂ systems providea variety capabilities manipulation text systems process textstrings loosely defined sequences letters numbers andspecial characters objects large bookcontains characters efficient algorithms play importantrole manipulating type string binary string simple sequence  values sense special type text string worthmaking distinction algorithms appropriatebut binary strings naturally applications computer graphics systems represent pictures binary strings book printed represented time binary string consisting millions bits sense text strings objects binary strings characters large alphabet twotypes strings equivalent text character representedby binary bits binary string viewed text string bytreating bit chunks characters size alphabetfrom characters form string factorin design string processing algorithms fundamental operation strings pattern matching textstring length pattern length occurrence thepattern text term ﬁtextﬂ referring toa sequence values special type string algorithms241 chapter for problem easily extended occurrences patternin text scan sequentially text restartedat point directly match match pattern matching problem characterized searching prob lem pattern key searching algorithms havestudied apply directly pattern long ﬁlines upﬂ text unknown interesting problemto study surprising algorithms onlyrecently discovered provide spectrum practicalmethods illustrate fundamental algorithm design techniques short historythe development algorithms examining interestinghistory summarize place methods perspective obvious brute force algorithm string processing inwidespread worst case running time proportional strings applications lead running time whichis virtually proportional suited togood architectural features computer systems optimized versionprovides ﬁstandardﬂ difficult beat clever algorithm  cook proved theoretical result type ofabstract machine implying algorithm exists solves pattern matching problem time proportional worst case knuth pratt laboriously construction cookused prove theorem intended practical algorithm refine relativelysimple practical algorithm rare satisfying atheoretical result unexpected practical applicability turned morris discovered virtually algorithmas solution annoying practical problem confronted whenimplementing text editor ﬁback upﬂ text string fact algorithm arose approaches lends credibility fundamental solution problem knuth morris pratt publishing algorithmuntil  boyer moore indepen dently gosper discovered algorithm faster applications examines fraction characters text string text editors algorithm achieve noticeabledecrease response time string searches knuth morris pratt boyer moore algorithms requiresome complicated preprocessing pattern difficult understand string searching243and limited extent fact story goesthat unknown systems programmer morris algorithm difficult understand replaced brute force implementation  karp  rabin observed problem notas standard searching problem cameup algorithm simple brute force algorithm virtually runs time proportional theiralgorithm extends easily dimensional patterns text makesit picture processing story illustrates search ﬁbetter algorithmﬂ veryoften justified suspects developments thehorizon problem brute force algorithmthe obvious method pattern matching mind isjust check position text pattern couldmatch fact match program searches occurrence pattern  text string  function brutesearch integer var integer begini repeatif plj endelse   brutesearch brutesearch iend program pointer text pointer intothe pattern long point matching characters pointers areincremented pattern reached match hasbeen point mismatching characters reset pointto pattern reset correspond moving thepattern position matching text endof text reached match pattern notoccur text returned text editing application loop program seldomiterated running time proportional number chapter text characters examined suppose thepattern sting text stringa string searching consisting simple textthen statement executed times actual match encountered theother hand program slow patterns ifthe pattern  text string then incremented    times match encountered suchdegenerate strings english pascal text algorithmdoes slowly binary character text occur picture processing systems programming applications table algorithm search  binary string there table time body repeat loopis entered character time incremented theﬁfalse startsﬂ occur pattern obvious goal isto limit number length knuth morris pratt algorithmthe basic idea algorithm discovered knuth morris prattis mismatch detected ﬁfalse startﬂ consists charactersthat advance pattern beable advantage backing pointerover characters string searching245for simple suppose character thepattern pattern pattern  suppose false start characters long position inthe text mismatch detected dint factthat characters matched ﬁback upﬂ text pointer previous characters text match character pattern change implemented byreplacing  program practical ofthis change limited specialized pattern particularlylikely occur idea worth thinking knuth morris pratt algorithm generalization surprisingly possibleto arrange things pointer decremented fully skipping pattern detecting mismatch describedin previous paragraph work pattern match itselfat point mismatch searching  in1010100111 detect mismatch character hadbetter character continue search otherwisewe match figure ahead time depends pattern table     the array  determine amismatch detected table imagine slide copy firstj characters pattern left starting thefirst character copy character pattern stoppingwhen overlapping characters match overlapping characters define place pattern match mismatch detected pbl distance exactlyone number overlapping characters thevalue nextb maximum characters ofthe pattern match characters characters thepattern vertical drawn plj chapter table convenient define  array limit fact eliminate ﬁbackupﬂ text pointer generalization methodabove point mismatching characters testing patternmatch position  text string possibleposition pattern match position nextij bydefinition table nextb characters positionmatch nextb characters pattern toback pointer simply leave pointer unchangedand set pointer program function kmpsearch integer var integer begini repeatif pb endelse nextlj kmpsearch kmpsearch match pattern overlap wantto increment set pattern achieved bydefining  set  incrementedand set  time loop trick work patternarray declared start  standard pascal complainabout subscript range toaccess determine truth functionally program isthe brutesearch faster patterns arehighly repetitive remains compute table program short buttricky basically program tomatch pattern string searching247procedure initnext var integer begini repeatif plj endelse nextij incremented determined lcharacters pattern match characters positions    thelast characters characters pattern thelargest property ﬁpossible matchﬂ patternwith missed assignedto interesting view algorithm pattern asfixed table ﬁwired inﬂ program program equivalent program thepattern efficient   goto   goto   goto   goto   goto   goto   goto   goto  search  goto labels program correspond precisely table infact program computes table easilybe modified output program avoid checking eachtime incremented assume pattern stored endof text sentinel optimization alsobe applied standard implementation simple aﬁstring searching compilerﬂ pattern produce efficient chapter program scan pattern arbitrarily long text string generalizations concept chapters program basic operations solve thestring searching problem easily termsof simple machine model called finite state machine diagram finite state machine program _      _ machine consists states circled letters transi tions arrows state transitions leaving matchtransition solid match transition dotted statesare machine executes instructions transitions goto structions state labeled ﬁ5 ﬂ machine perform justone instruction ﬁif current character scan thematch transition match transition ﬂ ﬁscan pastﬂa character character string ﬁcurrent characterﬂ machine scans characters matches thereis exception match transition state markedwith double requires machine scan charac ter essentially corresponds scanning occurrence thefirst character pattern chapter asimilar powerful machine develop powerful pattern matching algorithm alert reader noticed room provement algorithm account characterwhich caused mismatch suppose encounter when searching sample pattern  matching  wefind mismatch fourth character point table saysto check character matched  thirdcharacter match mismatch weknow character text  required pattern string searching249another version program nexttable ﬁwired inﬂ label    label  goto    directly fortunately easyto change algorithm replace statementnext initnext program byif plj nextb change increment reset table mostonce algorithm linear knuth morris pratt algorithm fasterthan brute force method actual applications plications involve searching highly repetitive patterns highly repetitive text method major virtue practi cal point view proceeds sequentially input ﬁbacksupﬂ input method convenient large file read external device algorithms require backup require complicated buffering situation boyer moore algorithmif ﬁbacking upﬂ problem faster string searchingmethod developed scanning pattern left whentrying match text searching sample pattern10100111 matches eighth seventh sixth character butnot immediatelyi slide pattern positions tothe check fifteenth character partial matchfound  elsewhm pattern thepattern general tableas left version tablefor pattern   xt nextb   chapter the number jth table maximumnumber character positions pattern shifted mismatch toleft scan occurred jth characterfrom pattern manner bysliding copy pattern characters left starting character copy lined thelast character pattern stopping overlapping characters match account character caused mismatch leads directly program aboveimplementation knuth morris pratt method thisin skip characterswith left pattern scanning cases idea decide based character causedthe mismatch tezt pattern simplest realization ofthis leads program examplethat studied searching pattern sting text stringa string searching consisting simple textproceeding left match pattern check gin pattern character text dothese match notice anywherein pattern slide nextcomparison pattern character searching time slide pattern rightuntil matches text pattern comparedagainst searching pattern canbe slid places character skips arrive consisting point align patternso matches text match thismethod brings match position cost examining sevencharacters text verify match alphabetis small pattern long ﬁmismatched character algorithmﬂ pattern length text string length inabout steps mismatched character algorithm easy implement itsimply improves brute force left pattern scan arrayskip tells character alphabet skip thatcharacter appears text mismatch string searching251function mischarsearch integer var integer begini repeatif pb   endelsebegini skip  theni skip mischarsearch lend statement  resets position text string asthe pattern moves left resets patternpointer prepare left character character match nextstatement moves pattern text warranted forsimplicity assume function char integer thatreturns  blanks ith letter alphabet procedureinitskip initializes skip array tll characters patternand  sets skip pb forthe pattern sting skip entry  entry be1 entry  entry  entry wouldbe  entries letters vould  whenan encountered lefi search pointer incrementedby  pattern alig ned positions thes pattern lines text ifthere pattern rightmostone calculation skip array built scanning left toright boyer moore suggested combining methods outlinedfor left patt ern scanning choosing larger skips calledfor mismatched character algorithm nary strings possibilities characters causethe mismatch pattern bits grouped ﬁcharactersﬂ crai ter as bits time skip table b entries chosen small table toolarge large bit sections text tobe pattern  bit sections inthe pattern starting bit position   wewant  b tobe lg m skip table quarters filledwith entries  thepattern split bit text sections rabin karp algorithma brute force approach string searching examine abovewould large memory advantage treating character text key standard hash table isnot hash table problem set key sought compute hashfunction character sections text check ifit equal hash function pattern problem methodis hard compute hash function mcharacters text check equal thepattern rabin karp easy problem hash function kmodq table size large prime theirmethod based computing hash function position textgiven position  method directly themathematical formulation assume translate charactersto numbers packing computer word thentreat integer corresponds writing characters numbers ina base number number characters number thusz dmp1 lidme assume xmodq shiftingone position text simply corresponds replacing dmel fundamental property mod operation perform anytime operations answer remainder divided arithmetic operation numbers dealing small sameanswer perform arithmetic operations remainder divided string searchtng253this leads simple pattelm matching algorithm implementedbelow program assumes ldex function  isused efficiency multiplications implemented shifts function rksearch integer const   var hl dm integer begindm  dm dm mod hl hl hl mod  mod hloh2 dobeginh2 dm mod mod rksearch program computes hash valle hl pattern hashvalue characters text computes valueof dﬂ modq variable dm proceeds text string technique compute hash function charactersstarting position comparing hash hl prime chosen large small qdoesn overflow requires mod operations thelargest repesentable prime extra calculationto stays positive mod operation worksas algorithm takes time proportional note thatit finds position text hash thepattern direct comparison textwith pattern suc large bythe mod computations fact actualhash table make8 extremely collision occur theoretically algorithm nm steps unbelievably worst case practice algorithm relied aboutn steps chapter multiple searchesthe algorithms discussing oriented specificstring searching problem occurrence pattern giventext string text string object patternsearches worthwhile processing string tomake subsequent searches efficient large number searches string searching problem canbe viewed special case general searching problem studiedin previous simply treat text string overlappingﬁkeys ﬂ ith key defined entire text string starting atposition manipulate keys pointersto compare keys character character compares starting positions text string ﬁsentinelﬂcharacter larger characters keyswill greater hashing binary tree algorithms previous directly entirestructure built text string efficient searches beperformed patterns details worked applying searchingalgorithms string searching intent point asa viable option string searching applications methods situations searches patterns length hash table constructed single scan rabin karp method yield constant search times average hand patterns varying length tree based methods patricia adaptable tosuch application variations problem difficultand lead drastically methods discover twochapters string searching255exercises1          implement brute force pattern tching algorithm scans pat tern left table knuth morris pratt algorithm patternaaiwuaa table knuth morris pratt algorithm patternaeracadabra draw finite state machine search pattern ae3racadafba search text file string  consecutive blanks left skip table left scan patternaenacadabra construct left pattern scan onlythe mismatch heuristic performs badly modify rabin karp algorithm search givenpattern additional proviso middle character ﬁ wildcardﬂ text character match implement version rabin karp algorithm giventwo dimensional pattern dimensional text assume pattern text rectangles characters write programs generate random looo bit text string alloccurrences bits string    methods values  pattern matchingit desirable string searching thancomplete pattern theuser text editor specif pattern maywish pattern match mightwish number occurrences specific charactersshould chapter pattern matching thistype efficiently algorithms previous chapter fundamental depen dence complete specification pattern differentmethods basic mechanisms powerful string searching facility match complicated characterpatterns character text strings time proportional develop patterns ﬁlanguageﬂthat rigorous kinds partial stringsearching problems suggested language involve powerfulprimitive operations simple ﬁcheck ith character textstring matches jth character patternﬂ operation previous chapter chapter basic operations terms animaginary type machine capability searching patternsin text string pattern matching algorithm simulate operation type machine chapter totranslate pattern specification user employs describehis string searching task machine specification algorithm employs carry search solution pattern matching problem intimatelyrelated fundamental processes computer science themethod program perform string searching taskimplied pattern description akin method the257 chapter pascal perform computational task implied pascalprogram describing patternswe pattern descriptions symbols tied thefollowing fundamental operations concatenation operation chapter twocharacters adjacent pattern match onlyif characters adjacent text ai3means operation alternatives thepattern ﬁorﬂ characters amatch characters occurs text lldenote operation symbol parentheses toallow combined concatenation arbitrarily complicatedways ﬁeither bﬂ meansﬁeither cacd cbdﬂ ﬁeither abd orcbd acd ccd ﬂ iii closure operation parts pattern repeatedarbitrarily closure symbol match ifand symbol occurs number times including  closurewill denoted placing character parenthesized groupto repeated matches strings consisting afollowed number ﬂ matches strings consistingof alternating string symbols built operations called regularexpression regular expression describes specific text patterns goal develop algorithm determine patternsdescribed regular expression occur text string concentrate concatenation closure order showthe basic principles developing regular expression pattern matching gorithm additions commonly actual systems venience meanﬁmatch character ﬂthis operation involving characters excepta easier ﬁ7ﬂ ﬁmatch letter ﬂagain compact large examplesof additional symbols specification large patterns easier symbols match letter anynumber operations remarkably descriptive patterndescription matches pattern h4atchlivgare misspelled     describes strings andl consecutive  differentpattern descriptions strings specifysuccinct pattern descriptions write efficient algorithms pattern matching algorithm examine viewed asa generalization brute force left string searching method thefirst method looked chapter  algorithm leftmost substring text string matches pattern description byscanning text string left rignt testing position whetherthere substring position matches patterndescription pattern matching machinesrecall view knuth morris pratt algorithm finite statemachine constructed search pattern scans text method regular expressior pattern matching generalization finite state machine knuth morris pratt algorithm changesfrom state state character text string thenchanging state match state mismatchat point pattern occur text starting point algorithm thought simulation machine characteristic machine easy simulate deterministic state transition completely determined nextinput character handle regular expressions morepowerful abstract machine operation machine tdetermine pattern occur point examin ing character fact  closure determine howmany characters exam ned mismatch discovered natural overcome problems endow machinewith power nondeterminism faced totry match pattern machine ﬁguessﬂ thisoperation impossible easy write program simulate actions machine diagram nondeterministic finite statemachine search pattern description din text string chapter as deterministic machine previous chapter machine cantravel state labeled character state ﬁpointed toﬂ thatstate matching scanning character text string whatmakes machine nondeterministic states called nullstates labeled ﬁpoint toﬂ differentsuccessor states null states sta  diagram ﬁno opﬂ states exit affect operation machine easier implementation program constructsthe machine state  null state exits stopsthe machine state machine successorstate input scanning themachine power guess transition lead match thegiven text string note ﬁnon matchﬂ transitionsas previous chapter machine fails match isno guess sequence transitions leads match machine unique initial state pointed ﬁfreeﬂarrow unique final state arrows startedout initial state machine ﬁrecognizeﬂ stringdescribed pattern reading characters changing state accordingto rules ﬁfinal state ﬂ power ofnondeterminism machine guess sequence state thatcan lead solution simulate machine astandard computer possibilities todetermine pattern description occur text stringcdaabcaaabddacdaacthe machine report failure started secondcharacter work report failure characters report failure sixth characters guess sequence state transitions pattern imatching5   to recognize aaae started seventh character construct machine regular expression buildingpartial machines parts expref sion defining ways whichtwo partial machines composed larger machine thethree operations concatenation closure start trivial machine recognize character sconvenient write state machine initial state whichalso recognizes character final state  onow build machine concatenation expressions themachines individual expressions simply merge final state ofthe initial state machine operation built adding null statepointing initial states making final state point final state combined machine finally machine closure operation built making finalstate initial state making point initial state anew final state chapter a machine built corresponds regular expression bysuccessively applying rules numbers states examplemachine order creation machine built scanningthe pattern left construction machine therules easily traced note  state trivial machinefor letter regular expression state tobe created concatenation deleted number states iscertainly number characters regular expression representing machineour nondeterministic machines constructed threecomposition rules outlined advantage simple structure manipulate straightforward statehas arrows leaving fact types states labeled character input alphabet arrow leaving unlabeled null states fewer arrows leaving machine represented pieces node machine represented statecharacter  a22313b4 a7 c8 d9900the rows table interpreted instructions nondeter ministic machine iorm ﬁif state character thenscan character state  ﬂ state  finalstate state  pseudo initial state entry pattern matchingis number actual initial state note special representation usedfor null states   exits access states number suitableorganization machine array representation thethree arraysch amty mmax char nextl next2 array mmax integer mmax maximum number states maximum patternlength thirds space state rreaningful pieces butwe forsake improvement sake clarity patterndescriptions long build mach nes regular expression patterndescriptions machines represented arrays write program translation regular expression thecorresponding nondeterministic machine representation automatically quiteanother matter fact writing program determine regularexpression legal challenging uninitiated chapter llstudy operation called parsing moment assume translation availablethe nextl next2 arrays representing nondeterministicmachine corresponds regular expression pattern description ofinterest simulating machinethe step development general regular expression pattern matching algorithm write program simulates opera tion nondeterministic pattern matching machine idea writing program ﬁguessﬂ answer ridiculous inthis case turns track matches asystematic eventually encounter correct possibility develop recursive program mimicsthe nondeterministic machine possibilities guessingthe approach nonrecursive implementation exposes basic operating principles methodby keeping states consideration peculiar data structurecalled deque idea track states encounteredwhile machine ﬁlooking atﬂ lrrent input character chapter states processed turn null states lead fewer states states forcharacters match current input eliminated states characters match current input lead states usewhen machine input character maintaina list states nondeterministic machine inat point text problem design data structure list processing null states require stack essentiallypostponing things removed therecursion quicksort state current list postponed indefinitely processing states require queue examine states thenext input character finished current character thenew state current list choosingbetween data structures deques ﬁdouble endedqueuesﬂ combine features stacks queues deque list whichitems ﬁoutput restricteddeque ﬂ remove items thatwould ﬁdealing deck ﬁ crucial property machine ﬁloopsﬂ consisting ofjust null states decide nondeterministically loop forever turns implies number states deque anytime number characters pattern description program deque simulate actions deterministic pattern matching machine examin ing character input nondeterministic machine states program track deque dq pointer head head deque maintained items inserted removed pointer tail tail deque maintained items inserted pattern description characters deque beimplemented ﬁcircularﬂ manner array integers tents deque elements ﬁbetweenﬂ head tail inclusive ifhead tail meaning obvious head tail elements thatwould fall head tail elements dq arranged acircle dq head dq head dq dq dq dq tail isquite simply implemented head head  mod increment headand tail head head  mod refers ele ment head therrray position element shouldbe deque main loop program removes state deque pattern matching265incrementing head mod referring dq head performs theaction required character matched input checked therequired character sate transition effected puttingthe state deque states involving currentcharacter processed involving state null states simulated deque states involving curren input character separatedfrom involving marker scan  deque whenscan encountered pointer input string advanced loopterminates input reached match state  isreached legal match item scan marker left thedeque match leads directly implementation function match intege integer const scan  var head tail integer dq array mmax integer procedure addhead integer dq head head head  mod procedure addtail integer tail tail mod dq tail beginhead taij addtail next1 addtail scan match  repeatif dq head scan thfsnbegin addtail scan endelse dq head alj thenaddtail next1 dq head dq head thenbeginnl nextl dq next2 dq head addhead n1 addhead head head mod muntil dq head head tail dq head match  function takes argument osition text string giaf ter20it start match returns character inthe match returns  table contents deque time state isremoved sample machine text string aabd forclarity details involving head tail maintenance circulardeque suppressed table elements dequebetween head tail pointers characters lefthandcolumn table point program finished scanningthem scan2613366scana scan22713377scana scan22scan133scanb scan44scan8scand scan99scan0scanscan6scanscan227scan7scanscan22scanthus start state  scanning character state leads states   state  leads states   scan character deque state1 leads state  deque input character state  leads state scanning whilean scanned ﬁscanﬂ sentinel finally reaches deque machine state  state  afterscanning continuing program eventually ends final state transitions consistent text string pattern matchingthe running time program depends heavily onthe pattern matched input characters itprocesses states mac nne worst case running timeis proportional nondeterministic machines besimulated efficiently discussed chapter  useof simple hypothetical pattern matching machine application leadsto reasonable algorithm difficult problem tocomplete algorithm program translates arbitrary regularexpressions ﬁmachinesﬂ interpretation code nextchapter implementation program context ofa general discussion compilers parsing techniques exercises1 regular expression recognizing occurrences fewerconsecutive binary string  draw nondeterministic pattern matching machine patterndescription  state transitions machine previous exercise wouldmake recognize abbac  explain modify nondeterministic machine handlethe ﬁnotﬂ function  explain modify nondeterministic machine handleﬁdon careﬂ characters  happen match simulate chine  modify match handle regular expressions ﬁnotﬂ function andﬁdon careﬂ characters  construct pattern description length textstring length running time match large aspossible  deque match ﬁscanﬂ sentinel  contents deque time state removed matchis simulate machine text text stringacd  parsingseveral fundamental algorithms developed recognize legalcomputer programs decomi ose structure form suitablefor processing operation called parsing application beyondcomputer science directly study structureof language general parsing plays role sys tems ﬁunderstandﬂ natural human languages systemsfor translating language case inter translating ﬁhigh levelﬂ nputer language pascal suitablefor human ﬁlow levelﬂ assembly machine language suitable formachine execution program translation called piler general approaches parsing methods lookfor legal program parts legal program lookingfor parts parts pieces small match input directly methods pieces input structuredway making bigger bigger pieces legal program constructed general methods recursive methods iterative methods thought easier implement methodsare thought efficient treatment issues involved parser compiler constructionwould scope thi book building simpleﬁcompilerﬂ complete pattern mats hing algorithm previous chap ter fundamental concepts involved construct parser simple language describingregular expressions modify parser program whichtranslates regular expressions pattern matching machines thematch procedure previous chapter intent chapter feeling basic principles269 chapter of parsing compiling time developing patternmatching algorithm treat issues involved level depth deserve reader warned subtle difficulties applying approach prob lems advised compiler construction developed field variety advanced methods applications context free grammarsbefore write program determine program written ina language legal description constitutes legal program description called grammar ter minology language english read ﬁsentenceﬂ ﬁprogramﬂ previous sentence occurrence programming lan guages type grammar called context free grammar context free grammar defines setof legal regular expressions previous chapter givenbelow expression term  term expression term factor  factor term factor expression   factor grammar describes regular expressions lastchapter grammar iscalled production replacement rule productions consist terminalsymbols symbols language beingdescribed  ﬂ special symbol stands letter digit nonterminalsymbols expression term factor internal grammar metasymbols meaning theproductions symbol read s ﬂ defines left handside production terms hand  symbol whichmay read ﬁorﬂ alternative choices productions expressed concise symbolic notation correspond simpleway intuitive description grammar secondproduction grammar read ﬁa term factor factor term ﬂone nonterminal symbol case expreswon distinguished sense string terminal symbols isin language grammar touse productions derive string distinguished nonterminal replacing number steps nonterminal symbol ﬁorﬂ clauses hand production nonterminal symbol parsing271one natural result derivation process calleda purse tree diagram complete grammatical structure stringbeing parsed parse tree string language grammar circled internal nodes labeled represent expression factor term parse trees english break ﬁsentenceﬂ ﬁsubject ﬂ ﬁverb ﬂ ﬁobject ﬂ main function parser accept strings derivedand reject attempting construct parse tree forany string parser recognize string language grammar determining exists parse tree string parsers building tree starting distinguished nonterminal working string recognized parsers starting string working backwards distinguished nonterminal strings reo gnized meanings implyingfurther processing parser convert internal repre sentation facilitate processing context free grammar appen dix pascal user manual report describes legal pascal programs principles considered recognizing legal pressions apply directly complex job compiling executing pascal chapter programs grammar describes small subsetof pascal arithmetic expressions involving addition multiplication expression term  term expression term factor  factor term factor expression again special symbol stands letter grammarthe letters represent variables numeric values examples oflegal strings grammar defined things strings perfectly legal arith metic expressions regular expressions mightmean ﬁadd multiply result aﬂ ﬁtake number sfollowed ﬂ points obvious fact checkingwhether string legally formed thing understanding itmeans return issue toparse string check grammar regular expression context free grammar language regular expression bedescribed context free grammar converse true concept ﬁbalancingﬂ parentheses captured regular pressions types grammars languages bedescribed context free grammars context sensitive grammarsare left hand sides productions single nonterminals differences classes languages hierarchy grammars describing carefully worked form beautiful theory lies heart computerscience parsingone parsing method recursion recognize strings languagedescribed grammar simply grammar issuch complete specification language turned directly program production corresponds procedure terminal left hand nonterminals hand theinput correspond recursive procedure calls terminals correspondto scanning input string procedure ofa parser regular expression grammar parsing273procedure expression beginterm plj thenbegin  expression endend array regular expre sion parsed jpointing character examined parse regularexpression sentinel character whichis grammar set  expression inj set  regular ression language describedby grammar error conditions arehandled thing expression term morecomplicated implementation procedure term beginfact  letter ptj term enda direct translation grammar simply term factorand term work leaves toexit term program infinite recursive loop ifcalled loops unpleasant effects systems implementation checking input decide term called thing term callfactor proc dures detect mismatchin input grammar factor called thecurrent input character ﬁ ﬂ input letter representedby process checking nez character incrementing jto decide called lookahead grammars notnecessary lookahead required implementation factor fallows directly grammar ifthe input character scanned ﬁ ﬂ input letter procedureerror called handle error condit chapter procedure factor beginif pb thenbeginj expression  errorendelse letter plj error pb error condition occurs ﬁ ﬂ missing procedures recursive fact intertwinedthat compiled pascal forward constructto rule procedure beingdeclared parse tree string recursive cal structure duringparsing reader refer tree trace throughthe operation procedures andexpression called  origin ﬁtop downﬂ nameobvious parsers called recursive descent parsers becausethey parse tree recursively approach work context free gram mars production expression  expression term haveprocedure badexpression beginif letter pb elsebeginbadexpression error elsebegin term endendend procedure called plj nonletter forj infinite recursive loop avoiding loops isa principal difficulty implementation recursive descent parsers parsing275term lookahead avoid loop case proper toget problem switch grammar term expression occurrence nonterminal thing hand ofa replacement rule called left recursion problem subtle left recursion indirectly exampleif productions expression term term  expression term recursive descent parsers work suchgrammars transformed equivalent grammars leftrecursion parsing method general intimate studied connection parsers grammars recognize choice parsing technique dictated characteristics grammar parsed parsingthough recursive calls programs structive exercise remove recursion systematically recall chapter  removed recursion quicksort procedure replaced stack push procedure return stack pop mimicking pascal implement recursion reasonfor calls recursive trulyrecursive procedure action procedure asimple goto turns expression term simple loops incorporated combined factor produce asingle procedure true recursive expression withinfactor view leads directly simple check regularexpressions legal procedure calls removed thateach terminal symbol simply scanned encountered realprocessing check parenthesis match eachleft parenthesis ﬂ letter ﬁ checking regular expression legal essentially equivalentto checking balanced parentheses simply implemented bykeeping counter initialized  incremented left paren thesis encountered decremented parenthesis encountered counter expression reached ﬂof expression letter ﬁ ﬁ expressionwas legal parsing simply checking theinput string legal main goal build parse tree animplicit parser processing turns programs essential structure parenthesis checker previous paragraph type parser chapter which works called shift reduce parser idea tomaintain pushdown stack holds terminal nonterminal symbols step parse shift step input characteris simply pushed stack reduce step characterson stack matched hand production thegrammar ﬁreduced toﬂ replaced nonterminal left sideof production eventually input characters shifted thestack eventually stack reduced single nonterminal symbol main difficulty building shift reduce parser deciding toshift reduce complicated decision dependingon grammar types shift reduce parsers studied ingreat extensive literature developed arequite preferred recursive descent parsers tend beslightly efficient flexible space justice field forgo details implementation compilersa compiler thought program translates lan guage pascal compiler translates programs fromthe pascal language machine language computer illustrate continuing ourregular expression pattern matching translate language regular expressions ﬁlanguageﬂ pattern matching machines nextl next2 arrays match program pre vious chapter essentially translation process ﬁone oneﬂ character inthe pattern exception parentheses produce statefor pattern matching machine entry arrays trickis track next1 next2arrays convert procedures recursive descentparser functions create pattern matching machines functionwill add states nextl next2arrays return initial state machine created thefinal state entry arrays function expression productioncreates ﬁorﬂ states pattern matching machine parsing277function expression integer var integer begintl term expression plj thenbeginj state state state expression state state setstate expression setstate state state function procedure setstate simply sets nextl andnext2 array entries indexed argument values thesecond fourth arguments state trackof ﬁcurrentﬂ state machine built time state created state simply incremented state indices machine procedure range state entry state exit final state valueof state exit ﬁcreateﬂ final state incrementingstate exiting easy ﬁmergeﬂ final state initial states convention easy check beware recursive program implements rule composing machines withthe ﬁorﬂ operation diagramed previous chapter machine expression built recursively null states expression built null state  final state machine ofthe expression ﬁno opﬂ state skip final state forthe machine expression required null state initial state return expression next1 next2 entries point initialstates expressions note carefully constructed theopposite order expect state opstate recursive expression function term builds machine factor ifnecessary merges final state machine initial state themachine term easier state thefinal state factor term incrementingstate trick chapter function term var integer beginterm factor pb letter termend initial state returned toterm pascal requires throw atemporary variable function factor techniques handle cases parenthesis calls recursive expression calls simpleconcatenation state calls operations inexpression closure diagram previous function factor var integer begintl state plj thenbeginj expression  errorendelse letter pb thenbeginsetstate state plj state  state state state iendelse error factor elsebeginsetstate state state factor state next1 state state state reader instructive trace construction ofthe machine pattern previous chapter parsing279the final step development general regular expression pat tern matching algorithm procedures matchprocedure state ytl  expression setstate state  foi doif match writeln program print character positions text string pattern leads match compiler compilersthe program general regular expresr ion pattern matching havedeveloped previous chapter efficient aversion program capabilities handling ﬁdon careﬂ characters amenities heavilyused utilities computer systems interesting confusing reflect algorithmfrom philosophical point view chapter consideredparsers unraveling structure regular expressions based formaldescription regular expressions context free grammar anotherway context free gramma ﬁpatternﬂ sequences characters legally balz nced parentheses parser thenchecks pattern occurs input considers matchlegal covers entire input string parsers check aninput string set strings defined context free grammar pattern matchers check input string set ofstrings defined regular expression essentially performing samefunction principal difference context free grammars capableof describing wider class strings set regularexpressions regular expressions difference implemented programs thecontext free grammar ﬁbuilt inﬂ parser match procedureis ﬁtable drivenﬂ program wol ks regular expressions oncethey translated propel format turns possibleto build parsers table driven sameprogram parse language  context free grammars parser generator program takes grammar asinput produces parser language grammar chapter output carried step build compilerswhich table driven terms input output languages acompiler compiler program takes grammars formalspecification relationships input produces acompiler translates strings language output parser generators compiler compilers general inmany computing environments tools usedto produce efficient reliable parsers compilers small effort hand recursive descent parsers type considered serviceable simple grammars applications algorithms considered straightforward method applications great deal implementation effort justified vanced methods lead performance improvements forlarge scale applications case understat ing point scratched surface extensively researched parsing281exercises1          recursive descent parser error regular expressionsuch incomplete parse tree regular expression extend arithmetic expression grammar include exponentiation divand mod context free grammar scribe strings thantwo consecutive  procedure calls recursive descent parser torecognize regular expression terms number concatenation closure operations number parentheses next1 next2 arrays result building patternmatching machine pattern modify regular expression grammar handle ﬁnotﬂ function andﬁdon careﬂ characters build general regular expression pattern matcher based improvedgrammar answer previous question remove recursion recursive descent compiler simplifythe code compare running time thenonrecursive recursive methods write compiler simple arithmetic expressions gram mar text produce list instructionsﬂ machinecapable operations pugh variable stack add values stick removing stack thenputting result ltiply values stack inthe  file compressionfor algorithms studied signed time secondarily toconserve space examine algorithms posite orientation methods designed reduce space consumptionwithout time ironically techniques examineto save space ﬁcodingﬂ methods theory veloped minimize communicationssystems originally intended save time space general files stored computer systems great deal ofredundancy methods examine save space advantageof fact files low ﬁinformation content ﬂ file compression techniques text files charac ters ﬁrasterﬂ files encoding pictures large homogeneous areas files digital repre sentation sound analog signals large repeated patterns elementary algorithm problem quiteuseful advanced ﬁoptimalﬂ method space saved bythese methods vary depending characteristics file savings   typical text files savings   achieved binary files types files files consisting random bits gained fact interesting note general purpose compression method files longer continually apply method produce arbitrarily small file hand argue file compression techniques lessimportant cost computer storage deviceshas dropped dramatically storage typical userthan hand argued file compression283 chapter techniques storage inuse savings greater compression techniques arealso storage devices extremely high speed accessand nature expensive small length encodingthe simplest type redundancy file long runs repeated characters string aaaabbbaabbbbbccccccccdabcbaaabbbbcccdthis string encoded compactly replacing repeatedstring characters single instance repeated character witha count number times repeated thisstring consists     compressing string called length encoding thereare ways proceed idea depending characteristics theapplication runs tend long bits usedto encode characters encoded method discuss options string letters encodecounts simply interspersing digits letters string mightbe encoded ﬁ4aﬂ ﬁfour ﬂand note worthwhileto encode runs length characters needed theencoding binary files solely refined version thismethod typically yield dramatic savings idea simply storethe lengths advantage fact runs alternate   avoid storing assumes short runs length encoding method work runs long left figure ﬁrasterﬂ representation letter ﬁqﬂ lying isrepresentative type processed atext formatting print book list numbers store letter compressed form file compression000000000000000000000000000011111111111111000000000000000000000000000000000001111111111111111110000000000000000000000000000001111111111111111111111110000                                                       that consists    moreo  counts table number bits  sufficient reconstruct bit array notethat ﬁend lineﬂ indicator needed bits represent count entire file represented  bits substantial savings  bits required store explicitly length encoding requires separate representation file beencoded encoded version file work files inconvenient character file compressionmethod suggested work character strings digits characters encode counts work stringsthat characters illustrate encode string froma fixed alphabet characters characters alphabet assume  letters alphabet spaces work letters represent digits representparts string encoded solution characterwhich rarely text called escape character appearance character signals letters form count character pair counts represented ith letter ofthe alphabet represent number string berepresented escape character chapter qdabbbaaqebqhcdabcbaaaqdbcccdthe combination escape character count copyof repeated character called escape sequence note notworthwhile encode runs characters long threecharacters required encode escape character occur input afford simply ignore possibility difficultto ensure character occur encode string encoded solution problem escape sequence count represent escape character space character representzero escape sequence ﬁq space ﬂ represent anyoccurrence input interesting note files containq files longer compression method file compressed compressed grows number characters equal number escape sequences long runs encoded multiple escape sequences forexample  encoded qzaqya conventionsabove long runs expected worthwhile reservemore character encode counts practice advisable compression expansionprograms sensitive errors including smallamount redundancy compressed file expansion program tolerant accidental minor change file compressionand expansion worthwhile ﬁend lineﬂcharacters compressed version letter ﬁqﬂ theexpansion program resynchronize case error length encoding effective text files theonly character repeated blank simpler ways toencode repeated blanks great advantage press text files created reading punched card decks necessarilycontained blanks modern systems repeated strings blanks entered stored repeated strings blanks oflines encoded ﬁtabs ﬂ blanks ends lines obviated theuse ﬁend lineﬂ indicators length encoding implementation modified handle representable characters saves  text file chapter savings allcomes letter ﬁqﬂ variable length encodingin examine file compression technique called huffman file compression287encoding save substantial space text files andmany kinds files idea abandon text files areusually stored usual bits character huffman method bits characters bits rarely convenient examine code consideringhow created suppose encode string ﬁa simplestring encoded minimal number bits ﬂencoding standard compact binary code bit binaryrepresentation representing ith letter alphabet  blank bit sequence      to ﬁdecodeﬂ message simply read bits time convertaccording binary encoding defined standard code appears requires number bits appears times huffman code achieves economy space encodingfrequently characters bits total numberof bits message minimized step count frequency character themessage encoded code fills array count   thefrequency counts message character array programuses procedure chapter  frequency countfor ith letter alphabet count count  blanks  count docount count  string count table produced is0           chapter which blanks step build ﬁcoding treeﬂ accordingto frequencies create tree node nonzero frequencyfrom table pick nodes smallest frequencies create newnode nodes sons frequency sum values sons matter nodes thesmallest frequency continuing build larger larger subtrees forest trees nodes frequency  nodes frequency  creating nodesof frequency  ultimately nodes combined asingle tree file compression289c lb1 c pnote nodes low frequencies tree nodeswith high frequencies root tree numbers labelingthe external square nodes tree frequency counts thenumber labeling internal round node sum labels sons small number node tree intothe count array label stored reference examining theprogram constructs tree labels internal nodeswill stored count   order determined dynamics theconstruction  leftmost external node thefrequency count stored count   external node frequency count stored count   father ofthese stored count  turns structural description frequencies formof tree needed create efficient encoding beforelooking encoding code constructing tree general process involves removing smallest set unorderedelements pqdownheap procedure chapter  build andmaintain indirect heap frequency values interested insmall values assume sense inequalities pqdownheaphas reversed advantage indirection easy toignore frequency counts table heap constructed cwter k123456789101112131415161718heap pi371621121562094131452181910count heap specifically heap built initializing heap array point tothe frequency counts pqdownheap procedure fromchapter   doif count  thenbegin heap downto  pqdownheap mentioned assumes sense inequalities thepqdownheap code reversed procedure construct tree straightfor ward smallest elements heap add theresult heap step create count decrease size heap process creates counts internal nodes tree created code repeatt heap heap heap  pqdownheap count  count heap count dad  dad heap  heap  pqdownheap   dad  lines loop pqremove size heap isdecreased internal node ﬁcreatedﬂ  nandgiven equal sum root removed node root raises priority necessitating pqdownheap restore order heap tree represented array ﬁfatherﬂ links dad fatherof node weight count sign dad whetherthe node left son father tree abovewe dad  count   dad   count   file compression291 indicating node weight   father index28 weight  huffman code derived coding tree simply replacing thefrequencies nodes letters viewingthe tree radix search trie cpnow code read directly tree code  code  code  program fragment reconstructs representation coding tree computed sifting process code represented arrays code binary representation kth letter len number bits code code isthe th letter code  code   len   chapter for  doif count thenbegin code len endelsebegini dad  repeatif dad iuntil code len finally computed representations code encode themessage dofor ien downto  dowrite bits code   program bits procedure chapters   access singlebits sample message encoded  bits versus  forthe straightforward encoding  savings an interesting feature huffman code reader undoubtedlyhas noticed delimiters characters stored thoughdifferent characters coded numbers bits canwe determine character stops decode themessage answer radix search trie representation thecode starting root proceed tree bits themessage time external node encountered output character atthat node restart root tree built time encode flle compression293the message save tree messagein order decode fortunately real difficulty store code array radix search trie inserting entries array initially tree decoding tree storage savings quoted accurate becausethe message decoded trie accountthe cost storing trie code array message huffman encoding effective long files savings inthe message offset cost situations coding triecan precomputed large number messages atrie based frequencies occurrence letters english languagecould text documents matter trie based thefrequency occurrence characters pascal programs forencoding programs ﬁ ﬂ atrie huffman encoding algorithm saves  textfor chapter random files clever encoding scheme twork character occur number oftimes lead fully balanced coding tree equal number ofbits letter code           exercisesimplement compression expansion procedures length coding method fixed alphabet text theescape character ﬁqqﬂ occur file compressed methoddescribed text ﬁqq ﬂ occur implement compression expansion procedures binary file coding method text letter ﬁqﬂ text processed sequence bit characters discuss pros cons order acharacter based length encoding method draw huffman coding tree string ﬁabracadabra ﬂ howmany bits encoded message require huffman code binary file showingthe maximum number bits huffman code character ternary valued file suppose frequencies occurrence characters beencoded huffman encoding tree unique huffman coding extended straightforward encodein bit characters  trees mainadvantage main disadvantage result breaking huffman encoded string intofive bit characters huffman encoding string implement procedure decode huffman encoded string thecode len arrays  cryptologyin previous chapter looked methods encoding strings ofcharacters save space importantreason encode strings characters secret cryptology study systems secret communications consists oftwo competing fields study cryptography design secret communica tions systems cryptanalysis study ways compromise secret munications systems main application cryptology militaryand diplomatic communications systems applications apparent principal examples computer file systems user prefer files private ﬁelectronic funds transferﬂ systems large amounts money involved puter user computer files private papers file cabinet bank electronic funds transfer secure funds transfer armored car military applications assume cryptographers ﬁgoodguysﬂ cryptanalysts ﬁbad guysﬂ goal protect computerfiles bank accounts criminals point view unfriendly philosophical cryptography assuming existence unfriendliness ﬁgood guysﬂ cryptanalysis verybest secure compromise documented instances wars brought anend lives saved successes cryptanalysis cryptology close connections computer science gorithms arithmetic string processing algorithms wehave studied art science cryptology intimate relation ship computers computer science fullyunderstood algorithms cryptosystems longer295 chapter than computers secrecy design algorithm design commonheritage people attracted clear branch cryptology mostby availability computers cryptographer muchmore powerful encryption machine moreroom mistake cryptanalyst powerful tools breaking codes codes broken complicated cryptanalysis place incredible strain computationalresources applications areas computers remains principal applications area modern supercomputers widespread computers led emergenceof variety applications cryptology mentioned cryptographic methods developed applications led discovery fundamental relationship cryptology area theoretical computer sciencethat examine chapter  chapter examine basic characteristics cryp tographic algorithms cryptography moderncomputer systems close relationships algo rithms studied refrain delving detailed implementa tions cryptography field left experts difficult ﬁkeep people honestﬂ encrypting things simple cryptographic algorithm dangerous rely method implemented expert rules gameall elements providing secure communicationsbetween individuals called cryptosystem canonicalstructure typical cryptosystem diagramed ﬁattackat dawnﬂthe sender wishes send message called plaintezt thereceiver transforms plaintext secret form suitable cryptologyfor transmission called ciphertext cryptographic algorithm theencryption method key parameters read message receiver matching cryptographic algorithm decryptionmethod key parameters transform theciphertext plaintext message assumed thatthe ciphertext insecure communications lines cryptanalyst assumed encryption anddecryption methods cryptanalyst aim recover theplaintext ciphertext knowing key parameters note depends separate prior method communication sender receiver agree key parameters rule key parameters secure cryptosystem inconvenient situation akin conventional security systems combination safe secure numbers combination lock harder remember combination parallelwith conventional systems serves reminder security systemis secure trustworthiness people key remember economic questions play central rolein cryptosystems economic motivation build simple encryptionand decryption devices provided complicated devices cost economic motivation reduce theamount key distributed secure andexpensive method communications balanced cost implementing cryptographic algorithms distributing key money cryptanalyst pay break applications cryptographer aim develop alow cost property cost cryptanalyst muchmore read messages pay applications ﬁprovably secureﬂ cryptosystem required ensured cryptanalyst read messages matter iswilling spend high stakes applications cryptologynaturally imply large amounts money cryptanalysis algorithm design track costs choose algorithms cryptology costs play central role design process simple methodsamong simplest oldest methods encryption thecaesar cipher letter plaintext nth letter alphabet replace letter alphabet fixedinteger caesar  table amessage encrypted method  chapter plaintext attack dawnciphertext buubdlabuaeb this method weak cryptanalyst guess valueof  choices read themessage method general table define substitutionto letter plaintext table tells letter putin ciphertext table correspondenceabcdefghi jklmnopqrstuvwxyzthe quickbrownfxjmpdvrlazygthen message encrypted plaintext attack dawnciphertext hwh othvtqhafthis powerful simple caesar cipher crypt analyst   tables sureof reading message ﬁsimple substitutionﬂ ciphers areeasy break letter frequencies inherent language ample frequent letter english text cryptanalyst good start reading message frequent letter ciphertext assuming replaced choice  letters letter combinations ﬁdigramsﬂ digrams occur english text whileothers common examining frequencies lettersand combinations letters cryptanalyst easily break simplesubstitution cipher type attack difficult thanone table simple extension caesar cipher calledthe vigenere cipher small repeated key determine kfor letter step key letter plaintextletter determine ciphertext letter sample plaintext key abc encrypted key abcabcabcabcabplaintext attack dawnciphertext bvwbenacwafdx cryptology299for letter ciphertext th letter thealphabet plaintext letter th letter key letter nd letter vigenere cipher complicated usingdifferent general tables letter plaintext simpleoffsets obvious longer key fact key long plaintext cipher commonlycalled time pad provably secure cryptosystem reportedly washington moscow hotline vitalapplications key letter cryptanalyst key letter message position hopeless situation difficult messages key letter leads severe key distribution problem time pad short messages infrequently message key encoded binary common schemefor position position encryption ﬁexclusive orﬂ function toencrypt plaintext ﬁexclusive orﬂ bit bit key attractivefeature method decryption operation encryption ciphertext exclusive plaintext key doinganother exclusive ciphertext key returns plaintext notice exclusive ciphertext plaintext key surprising cryptographic systems property cryptanalyst discover key plaintext encryption decryption machinesmany cryptographic applications voice systems militarycommunications involve transmission large amounts data thismakes time pad infeasible needed approximation tothe time pad large ﬁpseudo keyﬂ generatedfrom small true key distributed usual setup situations encryption machineis fed cryptovariables true key sender generatea long stream key bits pseudo key exclusive bits andthe plaintext forms ciphertext receiver machineand cryptovariables generate key stream toexclusive ciphertext retrieve plaintext key generation context random numbergeneration random number generation methods forkey generation cryptovariables initial seeds random number chapter generator fact linear feedback shift registers discussed inchapter  developed encryption decryption machinessuch key generators morecomplicated random number generators easy ways toattack simple linear feedback shift registers problem beeasy cryptanalyst plaintext silence voicesystem key cryptanalyst key thathe entire contents shift register keyfrom point cryptographers ways avoid problems tomake feedback function cryptovariable assumed thatthe cryptanalyst structure machine stole cryptovariables cryptovariables ﬁconfigureﬂ machine difficulty finding values method commonly confuse cryptanalyst productcipher machines combined produce complicatedkey stream drive method nonlinear substitution translation plaintext ciphertext large chunks bit bit general problem complex methods theycan complicated cryptographer understand thatthere possibility things degenerate badly somechoices cryptovariables public key cryptosystemsin commercial applications electronic funds transfer real puter mail key distribution problem onerous traditional applications cryptography prospect providing longkeys changed citizen maintain ing security cost effectiveness inhibits development ofsuch systems methods developed promiseto eliminate key distribution problem completely systems calledpublic key cryptosystems widespread nearfuture prominent systems based thearithmetic algorithms studying close works idea public key cryptosystems ﬁphone bookﬂ encryp tion keys encryption key denoted public knowledge aperson key listed number telephone book secret key decryption secret key denoted transmit message sender receiver public key encrypt message transmits message denote encrypted message ciphertext cryptologyby receiver private decryption key decrypt readthe message work properties s message pairs distinct iii deriving hard reading easy compute fundamental cryptographic property twoprovide security fourth feasible general scheme outlined diffie hellman  method satisfied properties amethod discovered rivest shamir adleman scheme rsa public key cryptosystem based arithmetic algorithms performed largeintegers encryption key integer pair decryptionkey integer pair secret numbers areintended large typically  digits mightbe  digits encryption decryption methods simple firstthe message broken numbers lg bits time binary string characterencoding message numbers independently raised apower modulo encrypt piece message compute mpmod decrypt ciphertext compute cﬂmodn computation easily performed modifying theelementary exponentiation algorithm studied chapter  takethe remainder divided multiplication than2 log operations required piece message tot alnumber operations  digit numbers required linear numberof bits message property satisfied property easilyenforced cryptovariables bechosen satisfy properties iii convinced requiresan exposition number theory scope book butwe outline main ideas generate large loo digit ﬁrandomﬂ prime numbers largest andwe chosen product xand chosen mod   provethat chosen mps mod allmessages large prime generated generating largerandom number testing successive numbers starting point chapter a prime simple method performs calculation randomnumber probability  ﬁproveﬂ number testedis prime number prime survive  applications ofthis test time  applications  time billion step compute turns variant euclid algorithm chapter  needed difficult compute knowledge andn prove case finding requires knowledge necessaryto factor calculate factoring thought verydifficult factoring algorithms millions years factor  digit number current technology attractive feature rsa complicated putations involving performed user whosubscribes frequent operations encryp tion decryption involve breaking message applying thesimple exponentiation procedure computational simplicity combinedwith convenience features provided public key cryptosystems makethis attractive secure communications computersystems networks rsa method drawbacks exponentiation procedure tually expensive cryptographic standards worse linger ing possibility read messages encrypted method true cryptosystems cryptographic method mustwithstand cryptanalytic attacks confidence methods suggested implementing public keycryptosystems interesting linked classof problems generally thought hard discuss chapter  cryptosystems interesting property successful attack provide insight solve difficult unsolved problems factoring rsa method link cryptology fundamental topicsin computer science potential widespread ofpublic key cryptography active area current exercises1          decrypt message encrypted vigenerecipher pattern cab repeated key a27 letter alphabet blank preceding dobhbuaasxfzwjqqwhat table decrypt messages encryptedusing table substitution method suppose vigenere cipher character key encrypta long message write program infer key based assumption frequency occurrence character odd positions roughly equal frequency occurrence character positions write matching encryption decryption procedures theﬁexclusive orﬂ operation binary version message witha binary stream linear congruential random numbergenerators chapter  write program ﬁbreakﬂ method previous exercise assuming  characters message blanks encrypt plaintext ﬁandﬂing bit bit key explain true false public key cryptography convenient send thesame message users discuss answer rsa method public key cryptography rsa encoding involve computing digitnumber represented array integers manyoperations required computation implement encryption decryption procedures rsa method sume represented arrays integersof size  sources string processingthe references algorithms inthis original sources knuth morris pratt  paperand boyer moore  paper form basis materialfrom chapter   paper thompson basis regular expression pattern matcher chapters   huffman  paper thoughit predates algorithmic considerations interesting reading rivest shamir adleman fully implementation andapplications public key cryptosystem  paper book standish good general reference topicscovered chapters chapters    parsing andcompiling viewed heart computer science thereare large number standard references bookby aho ullman extensive background oncryptography book kahn aho ullman principles compiler design addison wesley reading  boyer moore ﬁa fast string searching algorithm ﬂ communica tions acm   october  huffman ﬁa method construction minimum redundancycodes ﬂproceedings ire   kahn codebreakers macmillan york  knuth morris pratt ﬁfast pattern matching strings ﬂsiam journal computing   june  rivest shamir adleman ﬁa method obtaining digitalsignatures public key cryptosystems ﬂ communications acm   february  standish data structure techniques addison wesley reading  thompson ﬁregular expression search algorithm ﬂ communications theacm   june  geometric algorithms  elementary geometric methodscomputers solve large scale problemswhich inherently geometric geometric objects points linesand polygons basis broad variety applications andgive rise interesting set problems algorithms geometric algorithms design analysis systems forphysical objects ranging buildings automobiles large scaleintegrated circuits designer working physical object geometric intuition difficult support computer representation applications directly involve processing geometric data political ﬁgerrymanderingﬂ scheme divide district areas whichhave equal population satisfy criteria putting members party area sophisticated geometricalgorithm applications abound mathematics statistics wheremany types problems naturally set geometric representation algorithms studied involved text num bers represented processed naturally programmingenvironments primitive operations required implemented inthe hardware computer systems geometric problems seethat situation elementary operations pointsand lines computationally challenging geometric problems easy visualize liability problems solved instantly person pieceof paper point inside polygon require trivial computer programs complicated problems otherapplications method solution implementation computer method solution person  cwapter one suspect geometric algorithms long historybecause constructive nature ancient geometry usefulapplications widespread work field case work cient mathematicians application development algorithms modern computers field geometric algorithms interesting tostudy strong historical context fundamentalalgorithms developed large scaleapplications require algorithms points lines polygonsmost programs study operate simple geometric objectsdefined dimensional space algorithmswhich work higher dimensions fundamental object point whichwe pair integers ﬁcoordinatesﬂ point inthe usual cartesian points integer coordinatesleads simpler efficient algorithms severe restriction pair points assume areconnected straight segment polygon list points weassume successive points connected lines point connected closed figure work geometric objects decide torepresent programs obvious representationstype point record integer record point note points restricted integer coordinates real repre sentation note restricting algorithms process integers timesaver computing environments integer calculations typically efficient ﬁfloating pointﬂ calculations dealing integers introducing extra complica tion complicated geometric objects represented terms thesebasic components polygons represented arrays ofpoints note arrays lines result point polygon included natural repre sentation algorithms applications include extra point clearlybe handled adding info field records elementary geometric methods309we set sixteen points illustrate operation ofseveral geometric algorithms l hl bthe points labeled single letters reference explaining theexamples programs reason refer points ﬁnameﬂ simply stored array referred order points array someof programs goal geometric algorithms ﬁsortﬂ points order labels assignedin order points assumed input thesepoints integer coordinates abcdefgh jklmnopx y a typical program maintain array  points simplyread pairs integers assigning pair coordinatesof pair coordinates  pis representing polygon convenient maintain ﬁsentinelﬂvalues cxapter at point ﬁdrawﬂ geometric objects evenif inherent application pleasant workwith pictures numbers developing debugging implemen tation clear fundamental operation drawing manytypes hardware devices capability reasonable drawing lines characters print approximations picture objects directly output pascal programs restriction integer point coordinates helps simply collection points approximates recursive program draws drawing endpoints splitting half drawing halves procedure draw var integer point   begindot dot   abs abs thenbegint div  div  draw l1   draw  procedure dot assumed ﬁdrawﬂ single point toimplement maintain dimensional array characters onecharacter point allowed initialized ﬁaﬂ dot simply corresponds tostoring character sayrr ﬁ array position tothe referenced point picture ﬁdrawnﬂ printing array procedure dot procedurewith x33 picture array ﬁdrawﬂ lines connecting sample pointsbg resolution characters unit measure picture elementary geometric methods311 algorithms converting geometric objects points manner calledscan conversion algorithms illustrates easy drawnice diagonal lines harder tomake lines arbitrary slope nice coarse matrix characters recursive method disadvantages efficient points plotted times draw lines lines horizontal vertical advantages simple handles cases orientation endpoints linein uniform sophisticated scan conversion algorithms beendeveloped efficient accurate recursive array large number dots ragged edges ofthe lines discernible types algorithms high resolution high quality lines canrequire large amounts memory computer time sophisticatedalgorithms called technologies text book printed device capable printing millions dots square inch lines figures drawn chapter with pen ink intersectionas elementary geometric problem theproblem determining segments intersect diagram illustrates situations e0when segments intersect bg situation quitestraightforward endpoint fall case kp intersect extend segments position intersection point extended lines point fall segments case bg lie segments case oe lines parallel case oe straightforward solve problem intersection point lines defined segments check intersection point falls endpoints segments easy method tool thatwe andoints interested points fall samethe function straightforward compute thefor lines elementary geometric methods313function point integer var dxl dx2 dyl dy2 integer begindx   dxl   dyl   dx2  dy2  dyl ddy dxl dy2 dpdx2 terms variables program easy check quantity dyl dzl  positive andnegative holds true point sothe product quantities points positive thepoints fall negative points fall sides  points fall algorithms treat points fall lines ways test implementation intersect function ifthe endpoints segments opposite sides thenthey intersect function intersect boolean beginintersect     case function returns wrong answer endpoints collinear report intersection eventhough lines separated special cases type thebane geometric algorithms reader gain appreciation thekind complications cases lead finding clean repair intersect handle cases lines involved situation complicated sophisticated algorithm determining pairin set lines intersects simple closed pathto flavor problems dealing sets points theproblem finding path set points chaf ter intersect visits points returns point itstarted path called simple closed path imagine manyapplications points represent homes path routethat mailman homes crossing hispath simply reasonable draw points amechanical plotter elementary problem asks closed path connecting points problem finding path called traveling salesman problem difficult problem chapters book chapter easier problem finding shortest path surrounds set points chapter  llsee ﬁconnectﬂ set points easy solve elementary problem hand pick points serve ﬁanchor ﬂ compute angle madeby drawing points set anchor positive horizontal direction polar coordinate point anchor point origin sort points angle finally connect adjacent points result simple closed path connecting points drawn elementary geometric methods315in anchor points visited orderb  simple closed polygon betraced delta distances point anchorpoint angle needed algorithm tan dyldx althoughthe arctangent built function pascal programmingenvironments slow leads annoying extraconditions compute quadrant point isin angle sort algorithm senseto function easier compute orderingproperties arctangent sort result good candidate function simply dz testing forexceptional conditions simpler programreturns number   angle andp2 horizontal order properties trueangle function theta point real var integer real begindx abs abs oelse  telse  theta   programming environments worthwhile suchprograms standard trigonometric functions leadto savings cases worthwhile change thetato integer avoid real numbers inclusion polygonthe problem natural polygon repre sented array points point determine point inside straightforward solution problem suggests draw long segment point direction long endpoint guaranteed polygon chapter count number lines polygon crosses number isodd point inside point easily tracing endpoint hit inside proceed number times point theoriginal point situation simple intersections mightoccur vertices input polygon drawing showssome situations handled lines   straightforward  leaves polygon vertex andline  coincides edges polygon point line3 exits count  intersection polygon points lines intersect vertices count   reader amused simple test distinguish cases reading handle cases polygon vertices fall test linesforces count segments polygon whichintersect test essentially travel polygon incrementing intersection counter test elementary geometric methods317line implement simply ignore points whichfall test program function inside point boolean var count integer lp begincount ppi ppi plx maxint dobeginip intersect lp thenbeginip pij intersect lp count count inside count mod   program horizontal test ease calculation imagine theabove diagram rotated  degrees variable maintained theindex point polygon lie test theprogram assumes point smallest coordinate amongall points smallest coordinate testline  choice asthe ﬁanchorﬂ procedure suggested computing simple closedpolygon polygon represented arrays butas illustrates convenient standard rule ifthe point polygon test sideof test jth point increment intersectioncounter count intersection reader tocheck algorithm works properly lines lines   diagram polygon sides true applications complex program called simpler procedure based oncalls adequate chapter perspective examples clear easy underestimatethe difficulty solving geometric problem computer elementary geometric computations nottreated program compute area polygonmakes interesting exercise problems studied provided basic tools sections forsolving difficult problems algorithms study involve building geometric struc tures set points ﬁsimple closed polygonﬂ elementaryexample decide representations structures develop algorithms build investigate theiruse applications areas usual considerations tertwined algorithm inside procedure thischapter depends essential representation simple closedpolygon ordered set points unordered set lines algorithms study involve geometric search wewant points set close point whichpoints fall rectangle points closest manyof algorithms search problems closely tothe search algorithms studied chapters   parallels evident geometric algorithms analyzed point precisestatements relative performance characteristics aswe running time geometric algorithm depend onmany things distribution points order whichthey input trigonometric functions needed affect running time geometric algorithms usual situations empirical evidence suggestsgood algorithms applications algorithms aredesigned nerform worst case matter theinoutis elementary geometric methods319exercises1          list points plotted draw plotting    quick algorithm determining segments areparallel divisions array lines test form simpleclosed polygon draw simple closed polygons result asﬁanchorsﬂ method text suppose arbitrary point ﬁanchorﬂ method forcomputing simple closed polygon text conditionswhich point satisfy method work intersect function return called copies ofthe segment write program draw ﬁfill inﬂ arbitrary triangle programshould dot points inside triangle inside vertex polygon inside maximum achievable count inside executedon polygon vertices supporting answer write efficient program determining point inside agiven quadrilateral  finding convex hulloften large number points process inter ested boundaries point set diagram ofa set points plotted plane human trouble distinguishingthose ﬁinsideﬂ point set lie edge distinction fundamental property point sets chapter precisely characterized algorithms separating ﬁboundaryﬂ points point set mathematical notion natural boundary point set dependson geometric property called conwezity simple concept thereader encountered convex polygon polygon theproperty connecting points inside polygon mustitself lie inside polygon ﬁsimple closed polygonﬂ thatwe computed previous chapter decidedly nonconvex triangleor rectangle convex mathematical natural boundary point set isthe convex hull convex hull set points plane defined tobe smallest convex polygon equivalently convexhull shortest path surrounds points obvious property convex hull easy prove vertices convex polygon defining hull points original point set points someof form convex polygon contained theproblem points algorithms developed convex hull chapter examine representative large number points convex hull as3 points points form large triangle asmany points points fall convex polygon allcomprise convex hull algorithms work aremany points convex hull work  chapter below diagramed sample set points convex hull fundamental property convex hull hull moved direction hull hits hull vertexpoints alternate define hull subset pointsfrom point set hit moving angle frominfinity easy points guaranteed beon hull applying rule horizontal vertical lines pointswith smallest largest coordinates convex hull convex hull naturally defines ﬁboundariesﬂ point set isa fundamental geometric computation plays role manystatistical computations generalized higher dimensions rules gamethe input algorithm finding convex hull anarray points point type defined previous chapter output polygon represented array points theproperty tracing points order inthe array traces outline polygon reflection appearto require extra ordering condition computation convex hull finding convexhull323 return points hull order output inthe ordered form theunordered computation easier algorithms weconsider convenient computation place array forthe original point set hold output algorithms simply rearrange points original array convex hull appears inthe positions order description clear computing convexhull closely sorting fact convex hull algorithm usedto sort numbers sort turn points polar coordinates treating numbers angles suitably normalized fixed radius point convex hull point set ann gon points output orderedin order points polygon thesorted order original values remember input unordered formal proof computing convex hull easier sorting cost trigonometric functions required convert original numbers sorted points polygon considered comparing convex hull algorithms involve trigonometric operations sorting algorithms involve comparisons bet ween keys bit comparing apples oranges anyconvex hull algorithm require log operations sorting operations allowed helpful view finding convex hull set points kind ofﬁtwo dimensional sortﬂ frequent parallels sorting algorithms arisein study algorithms finding convex hull fact algorithms study finding convex hullis harder sorting algorithms timeproportional log worst case algorithms tend time actual point sets running time depends points distributed number points onthe hull methods finding convex hull ofa set points discuss relative running times package wrappingthe natural convex hull algorithm parallels method humanwould draw convex hull set points systematic toﬁwrap upﬂ set points starting point guaranteed theconvex hull smallest coordinate horizontal rayin positive direction ﬁsweepﬂ upward hitting point chapter point hull anchor point continue ﬁsweepingﬂuntil hitting point ﬁpackageﬂ fully ﬁwrappedﬂ point included diagram hull discovered sweep angles astandard minimum computation point hitnext method easily implemented function theta point developed previous chapter thought returningthe angle horizontal returns moreeasily computed number ordering properties followingprogram finds convex hull array points represented asdescribed previous chapter array position tohold sentinel finding convex hull325function wrap integer var min integer minangle real point beginmin  ndoif min min  min minangle repeatm  mj min min min minangle minangle    doif theta thenif theta minangle thenbegin min minangle theta min min  wrap point lowest coordinate copied order loop variable maintainedas number points included hull currentvalue ﬁsweepﬂ angle angle horizontal betweenp repeat loop puts point thehull exchanging mth point theta function fromthe previous chapter compute angle horizontal point points included hull searching angle smallest angles bigger loop stops point copy point  encountered program return points fall convex hulledge point theta withp execution algorithm implementation takesthe application points fallingon convex hull edges achieved changing theta distance points arguments account closer point smaller points angle table traces operation algorithm mth lineof table contents array mthpoint hull chapter    p18  bmc  p83  mwd  p144 bmlmefghijkcadop190  nhf  p225  emg p257  omh p315   gmi pone attractive feature method generalizes ormore dimensions convex hull set points  space convexthree dimensional object flat faces ﬁsweepingﬂ aplane hull hit ﬁfoldingﬂ faces plane anchoring lines boundary hull ﬁpackageﬂ ﬁwrapped ﬂthe program selection sorting successivelychoose ﬁbestﬂ points chosen brute force search forthe minimum major disadvantage method worst case points fall convex hull running time proportionalto graham scanthe method examine invented graham  interesting computation involved sorting thealgorithm includes sort inexpensive mediately obvious computation algorithm starts construction simple closed polygon points method previouschapter sort points keys theta function values correspondingto angle horizontal connecting point anchor point lowest coordinate tracingp closed polygon set points simple closed polygon previous note  consecutive points hull essentially thefirst iteration package wrapping procedure directions computation convex hull completed proceeding place point hull eliminating pointsthat hull points finding iye convexhull327in order  test points toeliminate difficult point assume wehave eliminated points traced convex hull based points algorithm based fact point point set thesame edge convex hull time point weeliminate hull edge violates condition test eliminating point wecome examine point eliminate hull linebetween areon hull teliminate diagram situation whenl considered kl jm extended jm runs hull nowl hull eliminated considered extended np leaving situation considered chapter  bat point eliminated runs fand eliminated nkf runs continuingin finally arrive illustrated finding convex hull329the dotted lines diagrams edges included theneliminated initial sort guarantees point considered apossible hull point turn points considered earlier smallertheta survives ﬁeliminationsﬂ property thatevery point implies onthe hull basic method understood implementation straightfor ward point minimum exchanged shellsort sorting routine rear range points modified compare points theirtheta values finally scan performed thefollowing program finds convex hull point set  sentinelis needed function grahamscan integer var min integer  point beginmin  doif min min min min shellsort   ndobeginm  repeatm  grahamscan loop maintains partial hull text considered decremented toeliminate points partial hull exchanged  tentatively add partial hull table thecontents array time point considered chaf ter bbb bb bb bb bb bbb2m345678910111213141516 npkfiec ahgd mmjnpkfiecoahgdmlmjmkfiecoahgdm bymfiecoahgd mlnhjpbiecoahgdmlnkmpjmecoahgd mlnkfwjpncoahgd iel ici  dmln6 ijpkymahgd mlnemijpkfcmhgdmlneoajpkfcimgd mlneoanpkfci mlneomhpkfcijlc lej aumlneogmpkfcij table depicts  solution considered boxed program fail point withthe lowest coordinate theta modified properly sort collinearpoints subtle point reader maywish check alternatively min computation modified point lowest coordinate points lowest coordinate canonical form chapter  reason method interesting study simpleform backtracking algorithm design technique ﬁtry itdoesn work elseﬂ compli cated forms chapter  hull selectionalmost convex hull method vastly improved method developedindependently eddy floyd general idea simple pick points hull throw inside thequadrilateral formed points leaves fewer points finding convexhull331be considered graham scan package wrapping technique method applied recursively worththe trouble points hull chosen eyetowards input points absenceof simplest points thesmallest largest  coordinates adaptthe choice points distribution input andy values ranges equally rectangular distribution choosing points scanning corners points largest smallest sum difference thetwo coordinates diagram survive theapplication technique set points gthe recursive version technique quicksort select procedure selection discussed chapter  thatprocedure vulnerable worst case running time ifall original points convex hull points thrownout recursive step select running time linear average discussed chapter performance issuesas mentioned previous chapter geometric algorithms somewhatharder analyze algorithms areas studiedbecause input output difficult characterize oftendoesn sense speak llrandomﬂ point sets ngets large convex hull points drawn rectangular distribution isextremely close rectangle defining distribution thealgorithms looked depend properties point setdistribution practice incomparable compare themanalytically require understanding complicated interactionsbetween understood properties point sets hand things performance algorithms helpchoosing application easiest analyze graham scan requires timeproportional log sort scan moment reflectionis convince oneself scan linear havea repeat ﬁloop loop ﬂhowever easy point isﬁeliminatedﬂ total number times code withinthat repeat loop iterated ﬁpackage wrappingﬂ technique hand takesabout steps number vertices hull comparethis graham scan analytically require formula termsof difficult problem stochastic geometry circular distribution answer n1  values nwhich large j3 comparable log expected valuefor rectangular distribution method compete favorablywith graham scan practical problems worstcase consideration analysis floyd eddy method requires sophisticatedstochastic geometry general result byintuition points fall inside quadrilateral discarded running time tbe convex hull algorithm proportional points examined thrown average matter method application floyd eddy met hod points beleft protect worst case points thehull prudent graham scan algorithm isalmost linear time practice guaranteed time proportional log _r finding convex hull333exercises1          suppose advance convex hull set points isa triangle easy algorithm finding triangle answer question quadrilateral efficient method determining point falls agiven convex polygon implement convex hull algorithm insertion sort methodfrom previous exercise strictly graham scan start point guaran teed hull explain strictly package wrapping method start apoint guaranteed hull explain draw set points graham scan finding convexhull inefficient graham scan work finding convex hull pointswhich vertices simple polygon explain counterexample showing points floyd eddy method inputis assumed randomly distributed circle random polarcoordinates package wrapping method large points sets  andy equally   curve fitting routineto approximate formula running time program point set size curve fitting routine approximate formula thenumber points left floyd eddy method point sets equally    range searchinggiven set points plane natural thosepoints fall area ﬁlist cities  miles ofprovidenceﬂ question type asked aset points cities geometric shape restricted rectangle issue extends geometric problems ﬁlist people  and25 incomes    ﬂ asks ﬁpointsﬂ afile data people names ages incomes fall rectanglein age income plane extension dimensions listall stars  light years sun dimensional problem rich young people paragraph tall female dimensional problem fact dimension high problems general assume set records tributes values ordered set calleda database precise complete definitions developedfor term problem finding records databasewhich satisfy range restrictions set attributes iscalled range searching practical applications difficult portant problem chapter concentrate dimensionalgeometric problem records points attributes coor dinates discuss generalizations methods direct generalizations methods thatwe searching single keys dimension presume thatmany queries set points problem splits intotwo parts preprocessing algorithm builds points structure supporting efficient range searching range searching335 chapter algorithm structure return points falling multidimensional range separation methods difficultto compare total cost depends distribution points involved number nature queries range searching problem dimension return pointsfalling interval sorting pointsfor preprocessing binary search points giveninterval binary search endpoints interval return thepoints fall solution build binary search tree simple recursive traversal tree returning points interval ignoring parts tree interval binary search tree built coordinates ofour points previous chapter inserted order program required points intervalis direct generalization treeprint procedure chapter  theleft endpoint interval falls left point root recursively search left subtree checking eachnode encounter point falls interval range searchingtype interval record integer procedure bstrange link int interval var txl tx2 boolean beginif thenbegintxl key int tx2 key int txl bstrange int txl tx2 write tx2 bstrange int endend program efficient maintaining inter val int global variable passing unchanged values throughthe recursive calls called interval   ample tree range prints note points returneddo connected tree methods require time proportional log preprocess ing time proportional log range numberof points falling range reader check thatthis true goal chapter achieve runningtimes multidimensional range searching parameter facility rangequeries easy user formulate queries require ornearly points type query occur applications sophisticated algorithms queries type algorithms designed efficient queries expected return large number points elementary methodsin dimensions ﬁrangeﬂ area plane simplicity llconsider problem finding points  coordinates fall agiven interval coordinates fall interval thatis seek points falling rectangle assume atype rectangle record integers horizontal verticalinterval endpoints basic operation test apoint falls rectangle assume function insiderect point rect rectangle checks obvious returning true chapter p falls rect goal points fall givenrectangle calls insiderect simplest solve problem sequential search scan throughall points testing falls range callinginsiderect point method fact database applications easily improved ﬁbatchingﬂ range queries testing scan points large database data external device time read data dominating cost factor reasonablemethod collect queries fit internal memory searchfor pass large external data file type ofbatching inconvenient database smaller thereare methods simple improvement sequential search apply directly aknown dimensional method dimensions besearched suppose search rectangle forour sample set points l mone proceed points coordinates fall xrange rectangle check coordinates points range searchingto determine fall rectangle points thatcould rectangle coordinates rangeare examined technique called projection couldalso project check xprojection check  projection points uniformly distributed rectangular shaped region trivial calculate average number points checked thefraction points expect rectangle simply ratio area rectangle area region fraction points expect check projection ratio width rectangle width region projection   rectangle   region thatwe expect  points rectangle  inan projection  projection suchcircumstances project axis narrowerof rectangle dimensions hand easy constructsituations projection technique fail miserably exampleif point set forms ﬁlﬂ shape search range enclosesonly point corner ﬁl ﬂ projection axis wouldeliminate half points glance projection technique improvedsomehow ﬁintersectﬂ points fall range pointsthat fall range attempts examining eitherall points range points range worst caseserve appreciation sophisticated methodsthat study grid methoda simple effective technique maintaining proximity relationships amongpoints plane construct artificial grid divides area tobe searched small squares short lists points fall square technique reportedly archaeology points fall rectangle sought listscorresponding squares intersect rectangle searched inour examined sketched crapter the main decision implementing method determiningthe size grid coarse grid square manypoints fine grid squares search mostof strike balance tochoose grid size number grid squares constant fraction total number points number points square expected equal small constant   grid sixteen point set grid square expected point straightforward implementation program read zycoordinates set points build grid structure thosepoints variable size control big grid squares andthus determine resolution grid simplicity assume thecoordinates points fall  maximum max grid set size max width ofthe grid square grid square point belongs divide itscoordinates size implementation range searching341program rangegrid input output const gmax  type point record info integer jink tnode node record point link var grid array gmax gmax link point size integer link procedure insert point var link beginnew grid div size div size grid div size div size beginnew gmax dofor gmax grid readln dobeginreadjn info insert program standard linked list representations dummy tailnode point type extended include field info containsthe integer jcth point read convenience referencing points keeping style examples assume function return jcth letter alphabet generalnaming mechanism actual applications mentioned setting variable size omittedfrom program depends number points ofmemory range coordinate values roughly mpoints grid square size chosen nearest integer maxdivided leads grid squares estimatesaren accurate small values parameters formost situations estimates easily formulated specialized applications chaf ter now work range searching handled simply indexinginto grid array procedure gridrange rect rectangle var link integer beginfor rect div size rect div size dofor rect div size rect div size dobegint grid dobeginif insiderect rect write info nextendendend running time program proportional number grid squarestouched careful arrange things grid square constant number points average proportional average number points examined number points search rectangle number grid squares examined isproportional number grid squares examined fallcompletely inside search rectangle small constanttimes total running time average linear numberof points sought large number points examined fallin search rectangle small points fall grid squarewhich intersects edge search rectangle number suchsquares proportional large note argument fallsapart grid squares small grid squares insidethe search rectangle large points grid squares perimeter search rectangle search rectangle thinner grid squares intersect grid squares pointsinside grid method works points distributed theassumed range badly clustered allthe points fall grid box gridmachinery gained method examine makesthis worst case subdividing space nonuniform range searching343adapting point set hand d treestwo dimensional trees dynamic adaptable data structures verysimilar binary trees divide geometric space manner convenientfor range searching problems idea build binary search trees points nodes coordinates points keys strictly alternating sequence algorithm inserting points d trees normalbinary search trees root coordinate pointto inserted smaller coordinate point root left level  coordinate atthe level coordinate alternating external node isencountered d tree built sample set ofpoints elthe coordinate node pointname nodes coordinate drawn vertically coordinates drawn horizontally chapter this technique corresponds dividing plane simple allthe points point root left subtree inthe subtree points point root leftof point subtree left subtree subtree ofthe root external node tree corresponds rectangle inthe plane diagram division plane tree numbered region corresponds external node tree point lies horizontal vertical segment defines division tree point point inserted tree region  inthe diagram left root points points points insertion point region  correspond drawing vertical diagram code construction d trees straightforward modificationof standard binary tree search switch coordinates eachlevel range searching345function twodinsert point link link var link boolean begind true repeatif xelsetd twodinsert tend usual header node head artificial point  isﬁlessﬂ points tree hangs link ofhead artificial node represent external nodes thecall twodinsert head insert node tree aboolean variable toggled tree alternatingtests coordinates procedure identical thestandard procedure chapter  fact turns randomlydistributed points d trees performance characteristics ofbinary search trees average time build tree isproportional log worst case range searching d trees test point nodeagainst range dimension divide plane thatnode root node search rectangle node subtrees falls range defined rectangle note carefully falling rectangle left subtrees checked correspondingto checking areas   plane overlap search rectangle process easily implemented straightforward generalization ofthe d range procedure examined chapter chapter procedure twodrange link rect rectangle boolean var txl tx2 tyl ty2 boolean beginif thenbegintxl rect tx2 rect tyl rect ty2 rect txl tx2 endelse tyl ty2 twodrange rect insiderect rect write info twodrange rect endend procedure subtrees dividing cuts therectangle happen infrequently small rectangles method fully analyzed running time proportional log retrieve points reasonable ranges ina region points competitive gridmethod multidimensional range searchingboth grid method d trees generalize directly dimen sions simple straightforward extensions algorithms immediatelyyield range searching methods work dimensions nature multidimensional space dictates caution called performance characteristics algorithms mightbe difficult predict application implement grid method dimensional searching simplymake grid dimensional array dimension mainproblem pick reasonable size problem quiteobvious large considered type grid dimensional search problem divisionsper dimension  grid squares forreasonable values generalization d kd trees straightforward simplycycle dimensions dimensions alternatingbetween tree random situation trees characteristics binary search trees natural correspondence trees simple range searching347geometric process dimensions branching node correspondsto cutting dimensional region plane general cut dimensional region  dimensional hyperplane large imbalancein kd trees practical point sets large totake notice randomness large number dimensions typically allpoints subtree dimensions whichleads branches trees alleviate thisproblem simply cycle dimensions thedimension divide point set techniquecan applied d trees requires extra dimension discriminated stored node relieve imbalance high dimensional trees summary easy generalize programs forrange searching developed handle multidimensional problems step lightly large application large databaseswith attributes record complicated objects andit good understanding characteristics ofthe database order develop efficient range searching method aparticular application problem beingactivelv studied exercises1          write nonrecursive version d range program text write program print points binary tree notfall interval maximum minimum number grid squares besearched grid method functions dimensions gridsquares search rectangle discuss idea avoiding search grid squares usinglinked lists grid square linked nonempty gridsquare row nonempty grid square samecolumn scheme affect grid square sizeto draw tree subdivision plane build a2d tree sample points starting vertical dividing thatis range argument false true set points leads worst case d tree nodeswith sons subdivision plane modify methods return pointsthat fall circle search rectangles area shape makeeach methods perform worst method preferred range searching case thatthe points cluster large groups spaced draw tree points                   inserted initially tree  geometric intersectiona natural problem arising frequently applications involving geometricdata ﬁgiven set objects intersect ﬂ ﬁobjectsﬂinvolved lines rectangles circles polygons types geometricobjects designing processing integrated circuits printed circuit boards wires intersect short circuit industrial application designing layouts executed numerically controlled cutting tool parts layout intersect computer graphics problem determining set objects obscured viewpoint formulated geometric intersection problem projections objects viewing plane operations mathematical formulation problems leadsnaturally geometric intersection problem obvious solution intersection problem check pair ofobjects intersect nﬂ pairs objects therunning time algorithm proportional applications problem factors limit number objects whichcan processed geometric applications systems ambitious uncommon process hundreds thousands millions objects brute force algorithm isobviously inadequate applications study ageneral method determining set objects intersect time proportional log based algorithms presented shamos hoey seminal paper  algorithm returning intersecting pairsamong set lines constrained horizontal vertical thismakes problem easier sense horizontal vertical lines rela tively simple geometric objects difficult sense returning all349 chapter intersecting pairs difficult simply determining suchpair exists implementation develop applies binary search treesand interval range searching program previous chapter doublyrecursive program examine problem determining aset lines intersect constraints lines generalstrategy horizontal vertical case applied fact thesame basic idea works detecting intersections types geometric objects lines objects extension return intersecting pairs complicated horizontal vertical case horizontal vertical linesto assume lines horizontal vertical twopoints defining equal coordinates equal coordinates sample set lines iij called manhattan geometry chrysler buildingnotwithstanding manhattan skyline sketched horizon tal vertical lines constraining lines horizontal vertical cer tainly severe restriction ﬁtoyﬂ problem case restriction imposed reason geometric intersectionapplication large scale integrated circuits typicallydesigned constraint general plan algorithm intersection setof lines imagine horizontal scan sweeping topin diagram projected scan vertical lines points horizontal lines intervals scan proceeds points representing vertical lines disappear horizontal lines periodically encountered intersection horizontal encountered represents interval scan point representing vertical point vertical intersects scan horizontal lies scan horizontal vertical lines intersect dimensional problem finding intersecting pair lines reduced dimensional range searching problem previous chapter ﬁsweepﬂ horizontal allthe set lines action whenendpoints lines encountered sorting linesaccording coordinate processing lines order thebottom endpoint vertical encountered add coordinate ofthat tree endpoint vertical encountered wedelete tree horizontal encountered doan interval range search coordinates care required handle equal coordinates endpoints reader accustomed encountering difficulties geometric algorithms trace operation algorithm set samplepoints sort endpoints coordinate bbdefhjcgdicagjfeieach vertical appears list horizontal appearsonce purposes intersection algorithm sorted listcan thought sequence insert vertical lines endpoint encountered delete vertical lines endpoint countered range endpoints horizontal lines commands allof ﬁcommandsﬂ simply calls standard binary tree routinesfrom chapters   coordinates keys sequence binary searchtrees chapter d ede3ffirst inserted tree deleted areinserted point encountered range search interval defined performed rightmost tree diagram search discovers intersection proceeding listabove order add sequence trees dei kfjnext upper endpoint encountered deleted addedand deleted sequence trees point encountered range search interval defined geometric intersection353by performed rightmost tree diagram searchdiscovers intersections recall visited search points left touched finally upper endpoints encountered points successively deleted leading tree step implementation sort endpoints theiry coordinate binary trees maintain thestatus vertical lines respect horizontal scan initial sort ﬁindirectﬂ binary trees set header node header node hx tree endpoints processed inorder time tree lines intersect currenthorizontal scan initializing hx  keys pointers dummy external node treeinitialize chapter  tree constructed inserting coordinates verticallines coordinate horizontal lines binary search tree withheader node procedure buildytree var integer beginreadln dobeginreadln lines lines lines lines bstinsert insert program reads groups numbers lines putsthem lines array binary search tree coordinate thestandard insert routine chapter  coordinates askeys indices array lines info field setof lines tree constructed chapter now sort effected recursive program recursivestructure treeprint routine binary search trees chapter  wevisit nodes increasing order visiting nodes left subtreeof tree visiting root visiting nodes rightsubtree tree time maintain separate tree rootedat hx simulate operation passing horizontalscan code point node ﬁvisitedﬂ straightforward description coordinates theendpoint fetched lines array indexedby info field node key field node comparedagainst determine node corresponds upper thelower endpoint lower endpoint inserted hx tree upper endpoint deleted hx tree anda range search performed implementation differs thisdescription horizontal lines inserted hx tree thenimmediately deleted range search point interval performedfor vertical lines code properly handle case overlapping vertical lines considered ﬁintersect ﬂ geometric intersectionprocedure scan link var integer int interval beginif thenbeginscan nextf  lines nextt info lines nextf info lines nextf info lines nextf info nextf key bstinsert nextf info hx nextf key thenbeginbstdelete nextt info hx write nextt info bstrange hxf int wri teln scan nextf endend running time program depends number intersections thatare number lines tree manipulation operationstake time proportional ogn average balanced trees ogn worst case guaranteed time spent range alsodepends total number intersections returns total runningtime proportional log number intersecting pairs general number intersections large ifwe  horizontal lines  vertical lines arranged crosshatchpattern number intersections proportional withrange searching advance number intersectionswill large brute force approach typical applications involve ﬁneedle haystackﬂ sort situation large set lines checked intersections approach intermixed application recursive procedures operat ing coordinates geometric algorithms d tree algorithm previous chapter chapter chapter general intersectionwhen lines arbitrary slope allowed situation morecomplicated illustrated orientations test explicitlywhether pairs lines intersect simple intervalrange test ordering relationship lines binary tree complicated depends current range intersections occur add ﬁinterestingﬂ yvalues set values getfrom endpoints turns problems handled algorithm thesame basic structure simplify discussion consideran algorithm detecting exists intersecting pair ina set lines discuss extended return allintersections sort divide space strips whichno endpoints proceed sorted listof points adding binary search tree point isencountered deleting point encountered binary tree order lines horizontal geometric intersection357ﬁstripﬂ consecutive values strip betweenthe endpoint endpoint diagram lines order assume intersections current horizontal strip goal tomaintain tree structure intersection build tree simply  coordinates endpointsas keys wrong order exampleabove instance general ordering relationship aline defined endpoints thesame point infinitely left  ﬁleftﬂ defined analagously diagram rightof left neitherto left intersect generalizedﬁline comparisonﬂ operation simple extension procedure ofchapter  function comparison isneeded standard binary search tree procedures balanced trees desired sequence diagrams manipulation tree time encountered time encountered bh gbfh9gdeach ﬁcomparisonﬂ performed tree manipulation procedures isactually intersection test binary search tree procedure decide left lines question intersect andwe finished story generalized comparisonoperation transitive left becauseb left left itis essential note binary tree deletion procedure assumes comparison operation transitive deleted tree sequence tree chapter is formed explicitly compared ourintersection testing algorithm work correctly explicitly test thatcomparisons valid time change tree structure time left link node  point node explicitly testthat left definition comparison result detection intersection summary test intersection set lines usethe program range removed binarytree routines extended generalized comparison intersection start null tree null treewithout finding incomparable lines intersection thetwo lines intersect compared pointduring scanning process intersection discovered intersection simply press hopeto lines intersect swap places inthe ordering directly point intersection handle thisproblem priority queue binary tree ﬁysortﬂ initially lines priority queue coordinates oftheir endpoints work scan successively smallest coordinate priority queue binary tree insert delete intersection entries priorityqueue intersection point lower endpoint intersections toomany expected simply remove intersecting lines whenan intersection scan completed allintersecting pairs involve lines brute forcemethod enumerate intersections interesting feature procedure adapted tosolve problem testing existence intersecting pair amonga set general geometric shapes changing generalizedcomparison procedure implement procedure geometric intersection359compares rectangles edges horizontal vertical tothe trivial rule rectangle  left rectangle edge ofx left left edge method testfor intersection set rectangles circles coordinates centers ordering explicitly test intersection compare distance centers sum theradii comparison procedure method wehave algorithm testing intersection set circles theproblem returning intersections cases complicated brute force method mentioned previous paragraph willalways work intersections expected approach willsuffice applications simply complicated objects setsof lines intersection procedure exercises1 determine triangles intersect squares regular gons   horizontal vertical intersection algorithm pairs oflines tested intersection set lines intersections inthe worst case diagram supporting answer  horizontal vertical intersection procedure usedon set lines arbitrary slope  write program number intersecting pairs setof random horizontal vertical lines generated tworandom integer coordinates   random bit todistinguish horizontal vertical  method testing polygon simple intersect  method testing polygon totally contained withinanother describe solve general intersection problem giventhe additional fact minimum separation lines isgreater maximum length lines  binary tree structure exists intersectionalgorithm detects intersection set lines  comparison procedures circles manhattan rectangles thatare text transitive  write program number intersecting pairs setof random lines generated random integer coordinatesbetween    closest point problemsgeometric problems involving points plane involve plicit explicit treatment distances points ample natural problem arises applications nearest neighbor problem point set points closest givennew point involve checking distance point toeach point set solutions distance problems prototype algorithm fundamental geometric structure called voronoi diagram canbe effectively variety problems plane approachwill general method solving closest point problems throughcareful consideration prototype implementation developingfull implementations programs solve problems problems chapter therange searching problems chapter  grid d tree methodsdeveloped suitable solving nearest neighbor prob lems fundamental shortcoming methods rely randomness point set bad worst case performance aim chapter examine general approach guaranteed good performance problems matter input methods complicated examine implementation involve sufficient overhead simpler methods actual applications point set large sufficientlywell dispersed study methods good worst case performance uncover fundamental properties point sets thatshould understood simpler methods turn suitable general approach examining ample doubly recursive procedures intertwine processing alongthe coordinate directions previous methods type that361 chapter we icd trees intersection based binary searchtrees case method based mergesort closest pairthe closest pair problem points closest togetheramong set points problem nearest neighbor prob lem applicable serve prototype closest point problem solved algorithm general recursive structure problems examine distances pairs ofpoints smallest distance points arunning time proportional turns usesorting examining log distances pointsin worst case fewer average worst case running time proportional ogn average llexamine algorithm algorithm based straightforward ﬁdivide conquerﬂ strategy idea sort points coordinate thex coordinate ordering divide points half closestpair set closest pair halves closest pair member half interesting case closest pair crosses dividing closest pair halfcan recursive calls pairs oneither dividing checked efficiently seek closest pair point set examine points distance min dividing wheremin smaller distances closest pairs halves observation worst case pairs points close dividing points half lined thedividing handle situations sort points limit number distance computations involving pointas proceeding points increasing order check point inside vertical strip consisting points plane min dividing point compute distance point strip coordinate coordinate current point min fact distance pairs points half min fewpoints checked demonstrated set points closest point problems363iii  vertical dividing points left eightpoints closest pair left half closestpair jm points sorted closest pairwhich split checking pairs fk isthe closest pair point set finally ek algorithm simply stated care required imple ment efficiently expensive sort pointson recursive subroutine algorithms running time recurrence t  impliesthat proportional log sort thenthe recurrence t  nlog turns outthat implies proportional log2 avoid weneed avoid sort solution problem simple subtle mergesort methodfrom chapter  based dividing elements sorted asthe points divided problems solve samegeneral method solve solve simultaneously write recursive routine sorts finds theclosest pair splitting point set half calling recursively sort halves closest pair half chapter then merging complete sort applying procedure tocomplete closest pair computation avoid cost doingan extra sort intermixing data movement required sort withthe data movement required closest pair computation sort split half forthe closest pair computation required points half allhave smaller coordinates points half easilyaccomplished sorting division fact aswell routine sort general plan accepted implementation difficult understand mentioned implementation recursive sort andmerge procedures chapter  step modify list structuresto hold points keys modify merge check global variable pass decide comparison pass comparison shouldbe coordinates points pass  ycoordinates points dummy node appears theend lists ﬁsentinelﬂ point artificially high ycoordinates step modify recursive sort chapter  theclosest point computation pass  replacing linecontaining merge recursive calls sort programby code pass  middle merge sort div  sort div  sort pass  thenbegina zt zt zt p4 zf repeatif abs middle min thenbegincheck check check  check  p4 p4 pend nextuntil zend closest point problems365if pass  straight mergesort returns linked list thepoints sorted coordinates change merge themagic implementation pass  program sortson completes closest point computation detailbelow procedure check simply checks distance points arguments global variable min resets min distance saves points global variables cpl cp2 global min distance cpl andcp2 closest pair sort sort closest pair invokingsort zf zf maxint zt maxint ht readlist min maxint pass hf sort hf pass  hf sort hf calls closest pair points global variables cpland cp2 managed check ﬁfind minimumﬂ procedure crux implementation operation sort pass  recursive calls points sorted ordering todivide points half coordinate dividing ajterthe recursive calls points sorted distance everypair points half greater min ordering ony scan points dividing min tolimit number points tested point distance minof dividing checked previous points distance min dividing guaranteed pair points closer min member pair eitherside dividing amusing geometric fact readermay check points fall thedividing spaced min number points falling anycircle radius min limited interesting examine order vertical dividinglines algorithm aid thefollowing binary tree chapter g kb jm leach node tree represents vertical dividing points leftand subtree nodes numbered order verticallines algorithm  triedand pair retained closest change min between0 pairs gd  successively closer pairs closer pairs fk isthe pair checked dividing diagram reflects difference mergesort versionof closest pair problem developed mergesort tree numbered left rightand general approach closest pair problem canbe solve geometric problems problem ofinterest nearest neighbors problem point point nearest problem solved program extra processing dividing point point closer closest point ﬁfreeﬂ sort helpful computation voronoi diagramsthe set points closer point point set pointsin set interesting geometric structure called voronoi polygon forthe point union voronoi polygons point set called itsvoronoi diagram ultimate closest point computations seethat problems involving distances points facehave natural interesting solutions based voronoi diagram thediagram sample point set comprised thick lines diagrambelow closest point problems367basically voronoi polygon point perpendicularbisectors separating point points closest actualdefinition voronoi polygon defined theset points plane closer point point point set points ﬁclosest toﬂ point defined lead edges voronoi polygon dual voronoi diagram correspondence explicit dual drawn pointand points ﬁclosest toﬂ connected inthe voronoi dual voronoi polygons edge common dualfor comprised dotted lines diagram voronoi diagram dual properties lead toefficient algorithms closest point problems property thesealgorithms efficient hat number lines diagram thedual proportional small constant times lineconnecting closest pair points dual problem ofthe previous solved computing dual simply finding minimum length lines dual connecting point nearest neighbor dual theall nearest neighbors problem reduces directly finding dual convexhull point set dual computing voronoi dual chapter another convex hull algorithm chapter of problem efficiently solved finding voronoi dual defining property voronoi diagram usedto solve nearest neighbor problem identify nearest neighbor apoint set point voronoi polygon point falls organize voronoi polygons structure d tree search efficiently voronoi diagram computed algorithm samegeneral structure closest point algorithm points firstsorted coordinate ordering split points half leading recursive calls voronoi diagram pointset half time points sorted finally thetwo voronoi diagrams halves merged merging pass  fact pointsare sorted recursive calls sorted thevoronoi diagrams halves built recursive calls aids complicated task presentationof implementation scope book voronoi diagram natural structure closest pointproblems understanding characteristics problem terms ofthe voronoi diagram dual worthwhile exercise problems direct implementation based generalschema chapter suitable powerful tocompute voronoi diagram powerful algorithms basedon voronoi diagram admit simpler efficient code justas closest nair nroblem exercises1          write programs solve nearest neighbor problem gridmethod d trees closest pair procedure setof points fall horizontal equally spaced closest pair procedure setof points fall vertical equally spaced algorithm set n points half positive zcoordinates half negative coordinates finds closest pair withone member pair half successive pairs points assigned cpl cp2 theprogram text points removed test effectiveness making min global comparing performanceof implementation purely recursive implementation forsome large random point set algorithm finding closest pair set lines draw voronoi diagram dual points fromthe sample point set ﬁbrute forceﬂ method require time proportional ton2 computing voronoi diagram write program recursive structure closest pairimplementation text convex hull set points sources geometric algorithmsmuch material developedquite fewer references older central areas sorting mathematical algorithms problems solutions discussed presented shamos in1975 shamos manuscript treats large number geometric algorithms andhas stimulated geometric algorithms discussedis original reference convex hull algorithms treatedin chapter  papers jarvis graham eddy therange searching methods chapter  bentley freidman ssurvey article references original sources particularinterest bentley original article kd trees written anundergraduate treatment closest point problems chapter  isbased shamos hoey  paper intersection algorithms ofchapter   paper article bentley ottmann route interested learning geomet ric algorithms implement work learn abouttheir behavior types point sets field infancy algorithms discovered bentley ﬁmultidimensional binary search trees associativesearching ﬂ communications acm   september  bentley friedman ﬁdata structures range searching ﬂcomputing surveys   december  bentley ottmann ﬁalgorithms reporting counting geomet ric intersections ﬂieee transactions computing   september  eddy ﬁa convex hull algorithm planar sets ﬂ acm transactionson mathematical software   graham ﬁan efficient algorithm determining convex hull afinite planar set ﬂ processing letters   jarvis ﬁon identification convex hull finite set pointsin plane ﬂ processing letters   shamos problems computational geometry unpublished manuscript  shamos hoey ﬁclosest point problems ﬂ th annual sympo sium foundations computer science ieee  shamos hoey ﬁgeometric intersection problems ﬂ th annualsymposium foundations computer science ieee  graph algorithms  elementary graph algorithmsa great problems naturally formulated terms objectsand connections airline routemap eastern interested questions ﬁwhat sthe fastest providence princeton ﬂ interested money time cheapest providence princeton answer questions interconnections airline routes objects towns electric circuits obvious interconnections tween objects play central role circuit elements transistors resistors capacitors intricately wired circuits represented processed computer order answer simple questions ﬁis connected ﬂas complicated questions ﬁifthis circuit built work ﬂ case answer ques tion depends properties interconnections wires theanswer question requires detailed thewires objects connect ﬁjob scheduling ﬂwhere objects tasks beperformed manufacturing process interconnections indicatewhich jobs interested inanswering questions ﬁwhen task performed ﬂa graph mathematical object accurately models situations chapter examine basic properties graphs nextseveral chapters study variety algorithms answering questions ofthe type posed encountered graphs instances pre vious chapters linked data structures representations graphs algorithms processing graphs toalgorithms processing trees structures  chapter for finite state machines chapters   representedwith graph structures graph theory major branch combinatorial mathematics hasbeen intensively studied hundreds years usefulproperties graphs proved difficult problems resolved scratch surface graphs covering understand fundamental algorithms problem domains studied graphshave begun examined algorithmic point view fundamental algorithms theinteresting discovered years trivialgraph algorithms lead interesting computer programs nontrivial algorithms examine elegant interesting difficult understand algorithms glossarya good deal nomenclature graphs termshave straightforward definitions convenient placeeven graph collection vertices edges vertices simple objectswhich names properties edge connection betweentwo vertices draw graph marking points vertices anddrawing lines connecting edges borne mind graph defined independently representation drawings represent graph define graph consists set vertices set edges vertices al3 aclmjmjljkedfdhifeaf elementary graph algorithms375for applications airline route mightnot sense rearrange placement vertices diagramsabove applications electric circuit application concentrate edges vertices independent geometric placement applications finite state machines chapters   geometric placement nodes implied relationship graph algorithms geometric problems discussed chapter  concentrate ﬁpureﬂ graph algorithms process simple collections edges nodes path vertex graph list vertices successivevertices connected edges graph bafeg pathfrom graph graph connected pathfrom node node graph intuitively vertices physical objects edges strings connecting connected graph stay piece picked vertex graph connected connected components graphdrawn connected components simple path path inwhich vertex repeated bafegac simple path cycle path simple vertex thesame path point path afega cycle graph cycles called tree path betweenany nodes tree note binary trees types trees thatwe built algorithms special cases included general definition trees group disconnected trees called forest spanning tree agraph subgraph vertices edgesto form tree spanning tree large componentof sample graph note add edge tree form cycle becausethere path vertices connects iseasy prove induction tree vertices  edges chapter if graph vertices  edges connected  edges cycle exactlyv  edges tree denote number vertices graph numberof edges note range   graphswith edges called complete graphs graphs fewedges vlog called sparse graphs ofthe edges missing called dense fundamental dependence parameters comparativestudy graph algorithms complicated algorithmsthat studied possibilities algo rithm v2 steps algorithm prob lem log steps algorithm forsparse graphs preferred dense graphs graphs defined point called undirected graphs simplesttype graph complicated type graphs inwhich nodes edges weightedgraphs integers weights assigned edge represent distancesor costs directed graphs edges ﬁone wayﬂ edge toy directed weighted graphs called net works discover extra weighted directed graphscontain difficult manipulate simple directed graphs representationin order process graphs computer program decidehow represent computer commonly usedrepresentations choice depends graph denseor sparse step representing graph map vertex names tointegers  main reason itpossible access vertex usingarray indexing standard searching scheme purpose instance translate vertex names integers  vby maintaining hash table binary tree searched findthe integer vertex alreadystudied techniques assume function indexto convert vertex names integers  function nameto convert integers vertex names order algorithms easyto follow examples letter vertex names ith letterof alphabet integer elementary graph algorithms377are trivial implement examples easy extendthe algorithms handle graphs real vertex names techniques fromchapters   straightforward representation graphs called jacenc matrix representation array boolean values main tained set true edge vertex vertex yand false adjacency matrix graph givenbelow abcdefghijklma1110011000000b1100000000000c1010000000000d0001110000000e0001111000000f1001110000000g1000101000000h000000011000010000000110000j0000000001111kooooooooo11  l0000000001011m0000000001011notice edge represented bits edge connectingx represented true values itis save space storing half symmetric matrix itis inconvenient pascal algorithms simpler matrix convenient assume ﬁedgeﬂ vertex set   graph defined set nodes set edges connecting read graph settle format reading sets obvious format read vertex names read pairs vertex names define edges mentioned easyway proceed read vertex names hash table binary searchtree assign vertex integer accessing vertex indexed arrays adjacency matrix ith vertex read assignedthe integer mentioned assume simplicity ourexamples vertices letters alphabet wecan read graphs reading pairs letters chapter v letters alphabet order edges isnot relevant orderings edges represent graph resultin adjacency matrix computed program program adjmatrix input output const maxv  var integer array maxv maxq boolean beginreadln  vdofor false  true dobeginreadln vl v2 vl v2 true trueend types vl v2 program code forindex straightforward manner depending thegraph input representation desired examples vl v2 oftype char simple function pascal function adjacency matrix representation satisfactory graphsto processed dense matrix requires v2 bits storage v2steps initialize number edges number bitsin matrix proportional v2 problem becauseabout v2 steps required read edges case graphis sparse initializing matrix dominant factor therunning time algorithm representation forsome algorithms require v2 steps execution lllook representation suitable graphs dense adjacency structure representation vertices connected toeach vertex listed adjacency list vertex easilyaccomplished linked lists program buildsthe adjacency structure sample graph elementary graph algorithms379program adjlist input output const maxv  type link fnode node record integer link var integer link array maxv link beginreadln zt adjb dobeginreadln vl v2 vl v2 usual linked list ends link artificial node whichlinks representation order edges input relevant list insertion method determines order vertices adjacency lists graph represented ways adjacencylist structure difficult predict adjacency lists examining sequence edges edge involvesinsertions adjacency lists order edges adjacency list turn theorder edges processed algorithms adjacency liststructure determines algorithms examiningﬁseeﬂ graph algorithm produce correct answer nomatter order edges adjacency lists thatanswer sequences computations orders andif ﬁcorrect answer ﬂdifferent input orders leadto output edges order listed drawing samplegraph chapter program builds followingadjacency list structure cxapter a gb dg mk jl mm lnote edge represented edge connecting andy represented node adjacency list nodecontaining adjacency list include sinceotherwise simple questions ﬁwhich nodes connected directly nodex ﬂ answered efficiently simple operations supported representation forexample delete vertex edges connected toit sufficient delete nodes adjacency list node theadjacency list specifies vertex adjacency list searchedfor node deleted problem corrected bylinking list nodes correspond edge making adjacency lists doubly linked edge removed list nodes edge deleted extra links cumbersome process certainlyshouldn included operations deletion needed considerations plain ﬁdirectﬂrepresentation graphs data structure models graph vertices represented allocated records edge lists links vertices vertex names add edge graph represented directed weighted graphs represented structures fordirected graphs edge representedjust edge represented true inthe adjacency matrix appearance adjacency list theadjacency structure undirected graph thought adirected graph directed edges ways pair ofvertices connected edge weighted graphs thesame adjacency matrix weights boolean elementary graph algorithmsvalues existent weight represent false include afield edge weight adjacency list records adjacency structure associate verticesor nodes graph model complicated objects tosave bookkeeping complicated algorithms extra vertex accommodated auxiliary arrays indexed vertex number making array records adjacency structure representation extra edge adjacency list nodes array records adjacency matrix representation auxiliary arrays indexed edge number requires numbering edges depth searchat chapter natural questions ariseimmediately processing graph graph connected connected components graph cycle problems easily solved technique called depth search natural ﬁvisitﬂ node check edge graphsystematically chapters follow simple variationson generalization method solve variety graphproblems concentrate mechanics examining pieceof graph organized implementation depth firstsearch fills array vaj vl visits vertex graph array initially set zeros vaj vertex hasnot visited goal systematically visit vertices thegraph setting vaj entry nowth vertex visited   program recursive procedure visit visits thevertices connected component vertex argument visit vertex check edges lead vertices whichhaven visited  vaj entries visit chapter procedure dfs var integer val array maxv integer procedure visit integer var link beginnow val dobeginif val visit nextendend beginnow val doif val visit visit called vertex nonzero val valuesbeing set vertices connected vertex dfs scans throughthe vaj array entry vertex beenseen calls visit vertex continuing verticeshave visited follow operation depth search redrawthe graph recursive calls visit procedure thisgives structure h98ivertices structure numbered val values vertices elementary graph algorithmsactually visited order connectedcomponent leads tree called depth search tree importantto note forest depth search trees simply ofdrawing graph vertices edges graph examined algorithm solid lines diagram lower vertex thealgorithm edge list upper vertex visitedat time recursive dotted lines correspond edges vertices visited test visit failed edge ﬁfollowedﬂ recursive comments apply time edge encountered test visit guardsagainst edge time encountered encountering adjacency list wedon encountering adjacency list dotted links checked checkedthat visited encountering adjacencylist check visited onencountering adjacency list crucial property depth search trees undirected graphsis dotted links node ancestor tree node tree higher path root point execution algorithm vertices divide intothree classes visit finished visit onlypartially finished definition ofvisit encounter edge pointing vertex class encounter edge vertex class recursive callwill edge solid depth search tree theonly vertices remaining class precisely vertices path current vertex root tree edge correspond dotted link depth firstsearch tree running time dfs proportional graph set val values term examine eachedge term method applied graphs represented adjacencymatrices visit procedure chapter procedure visit integer var integer beginnow vai vdoif thenif val visit traveling adjacency list translates scanning row inthe adjacency matrix true values correspond edges asbefore edge vertex ﬁfollowedﬂ viaa recursive edges connected vertex examined adifferent order depth search forest underscores point depth search forest simplyanother representation graph structure depends bothon search algorithm internal representation runningtime dfs visit procedure proportional v2 everybit adjacency matrix checked testing graph cycle trivial modification aboveprogram graph cycle nonaero val entry discoveredin visit encounter edge pointing vertex vealready visited cycle equivalently dotted links thedepth search trees belong cycles depth search finds connected components graph nonrecursive visit corresponds connected component easy print connected components visit print elementary graph algoritmms385the vertex visited inserting write exiting print ut indication connected component startjust visit dfs inserting writeln statements technique produce output dfs theadjacency list representation sample graph gdefcbai hkmljnote adjacency matrix version visit compute nected components vertices printed order extensions complicated processing connected ponents straightforward simply inserting invaj kafter vaj ﬁinverseﬂof vaj array nowth entryis nowth vertex visited inverse heapthat studied chapter  serves differentpurpose vertices connected components contiguous thisarray connected component time visit called dfs values stored mark delimiters inval entry connected componentcould negative table produced ourexample adjacency list version dfs modified vajik1 invaj a1 b763c654d575e346f237g428h8 i9910j10 k111112l121213m1313with techniques graph divided connected chapter ponents processing sophisticated algorithms mazesthis systematic examining vertex edge graph adistinguished history depth search stated formally hundredsof years ago method traversing mazes left thediagram popular maze graph constructed byputting vertex point path connecting vertices paths complicated early english garden mazes constructed paths tall hedges mazes allwalls connected outer walls gentlemen ladies couldstroll clever simply keeping hand wall laboratory mice reportedly learned trick independent inside walls occur moresophisticated strategy maze leads depth firstsearch depth search place maze weuse visit starting vertex graph startingpoint time visit ﬁfollowsﬂ edge recursive walk path maze trick walk path enter vertex visitfinishes vertex puts vertex step higher upin depth search tree ready follow edge maze graph interesting ﬁmedium sizedﬂ graphwhich reader amused input algorithms inlater chapters fully capture correspondence maze weighted elementary graph algorithms387version graph weights edges todistances maze vertices perspectivein chapters follow variety graph algorithms largelyaimed determining connectivity properties undirected directedgraphs algorithms fundamental processing graphs butare introduction subject graph algorithms interestingand algorithms developed scope ofthis book interesting problems studied goodalgorithms efficient algorithms developed toocomplicated determine efficientlywhether graph drawn plane intersectinglines problem called planarity problem efficient algorithmfor solving  tarjan developed ingenious intricate algorithm solving problem linear time usingdepth search graph problems naturally easy state seemto difficult good algorithms solve forexample efficient algorithm finding minimum cost tourwhich visits vertex weighted graph problem called thetraveling salesman problem belongs large class difficult problems thatwe discuss chapter  experts noefficient algorithms exist problems graph problems efficient algorithms hasbeen graph isomorphism problem determinewhether graphs identical renaming vertices efficientalgorithms problem special types graphs butthe general problem remains open short wide spectrum problems algorithms dealingwith graphs expect solve problem comesalong problems simple bafflingthe experts problems easy solve graph algorithms study serve great variety applications exercises1 undirected graph representation determin ing vertex isolated connected vertices  suppose depth search binary search tree rightedge left node order nodesvisited  bits storage required represent adjacency matrixfor undirected graph nodes edges required adjacency list representation  draw graph written piece paper withouttwo edges crossing  write program delete edge graph represented jacency lists  write version adjlist adjacency lists sorted order ofvertex discuss merits approach  draw depth search forests result textwhen dfs scans vertices reverse order bothrepresentations  times visit called depth search anundirected graph terms number vertices number ofedges number connected components  shortest path connects vertices maze graphexample assuming edge length   write program generate ﬁrandomﬂ graph vertices edgesas pair integers  include anedge randomint div  thane experiment determine connected components arecreated     connectivitythe fundamental depth search procedure previous chapterfinds connected components graph llexamine algorithms problems graph connectivityproperties trivial graph algorithm generali zation connectivity called biconnectivity interested knowingif vertex graph graph biconnected pathsconnecting pair vertices vertex edgestouching removed graph connected thata graph connected application thatit stay connected method testing graph isbiconnected depth search depth search traverse nodes ofa graph strategies problems breadth search method finding shortestpath vertex vertex method turns differfrom depth search data structure save unfinished pathsduring search leads generalized graph traversal program thatencompasses depth breadth search classical algorithms finding minimum spanning tree shortest paths graph chapter  version connectivity problem arises frequentlyinvolves dynamic situation edges graph interspersed queries vertices belongto connected component interesting family ofalgorithms problem problem called ﬁunion findﬂproblem nomenclature application algorithms389 chapter to processing simple operations sets elements biconnectivityit reasonable design route points agraph handle failures connection points vertices fly providence princeton york snowed philadelphia main communications lines integrated circuit biconnected rest circuit function component fails application realistic illustrates concept imagine wartime stituation enemy bomb stations order cut rail lines articulation point connected graph vertex deleted break graph pieces graph articulationpoints biconnected biconnected graph distinctpaths connecting pair vertices graph biconnected itdivides biconnected components sets nodes mutually accessible twodistinct paths undirected graph whichis connected biconnected graph graph previous chapter addingthe edges gc gh jg lg examples assume thesefours edges order input adjacency lists theprevious chapter entries lists reflect fournew edges articulation points graph connects rest graph connects rest graph connects rest graph graphwould fall pieces deleted biconnectedcomponents acgdef gjlm individual nodes determining articulation points turns simple extension connectivity391of depth search depth search tree thisgraph adjacency list representation deleting node disconnect graph havedotted links point alternate paths father tree hand deleting disconnect graphbecause alternate paths father vertex articulation point son nodelower tree connected dotted link node higher treethan providing alternate connection test work root depth search tree nodesﬁhigher tree ﬂ root articulation point moresons path connecting sons root root tests easily incorporated depth search changing thenode visit procedure function returns highest point thetree lowest val search chapter function visit integer integer var link min integer beginnow val min dobeginif val thenbeginm visit min min val write endelse val min min val nextendvisit min procedure recursively determines highest point tree reach dotted link descendant vertex infor mation determine articulation point calculationsimply involves testing minimum reachable son ishigher tree extra test determine theroot depth search tree equivalently callto visit connected component samerecursive program cases test properly performed therecursive visit code program simply prints articulation points easily extended additional processing articulationpoints biconnected components depth searchprocedure running time proportional ﬁreliabilityﬂ sort application mentioned biconnected ness helpful decomposing large graphs manageable pieces isobvious large graph processed connected componentat time applications obvious asuseful graph processed biconnected componentat time connectmtygraph traversal algorithmsdepth search member family graph traversal algorithms thatare natural viewed nonrecursively methods solve simple connectivity problems posed chapter program implement graph traversal methods characteristics changing variable method solve graph problems chapters follow analogy traveling maze time face achoice vertices visit path ﬁsaveﬂ visit implement programbased idea remove recursion recursive depth firstalgorithm previous chapter result program thatsaves stack point adjacency list vertex visitedat search resume vertices connected previousvertices adjacency list visited examining implementation general framework encompasses algorithms thinking vertices divided classes tree visited vertices connected paths trav ersed fringe vertices adjacent tree vertices visited andunseen vertices encountered search aconnected component graph systematically implement visit procedure previous chapter vertex fringe unseen perform step vertices visited ﬁmove vertex fringe tree unseenvertices adjacent fringe ﬂgraph traversal methods differ howit decided vertex moved fringe tree depth search choose vertex thefringe encountered implemented byalways moving vertex fringe tree putting unseen vertices adjacent vertex fringe andmoving vertices adjacent happen fringe thefront note carefully completely traversal method ifwe leave untouched vertices adjacent fringe undirected graph ofthis chapter table contents fringe timea vertex moved tree search tree chapter agedfchijmlkbag fechjlbf dfchjlb fchjlb chjlb jlbj bmlkblkbk bbin algorithm fringe essentially operates pushdown stack weremove vertex  fringe throughx edge list adding unseen vertices fringe movingfringe vertices note strictly stack additional operation moving vertex algorithm efficiently implemented maintaining fringe linkedlist keeping pointers list array indexed vertex number omit implementation favor program implement traversal strategies depth search tree drawn thebiconnectivity edges stack atime order reversed stack popped tree recursive depth search result append edge list stack delete stack occurrences vertices edge list reader interesting compare process result directly removing recursion visit procedure previous chapter fringe table reconstructthe search tree order build tree store node fringe table father tree thisis node entered table node causedthe entry changed node moves fringe needed node removed table determine tree attach classic traversal method derives maintaining fringeas queue pick encountered vertex bemaintained putting unseen vertices adjacent fringe coivnectnity395in general strategy method called breadth search firstwe visit node nodes adjacent nodes adjacentto nodes leads fringe table search treefor graph afcbgedljhmkiaf gc eb dg hl hjhmhmkmkik iidhwe remove vertex fringe gothrough edge list putting unseen vertices fringe efficient implementation linked list representation forthe fringe omit favor general method fundamental feature general graph traversal strategy thefringe operating priority queue vertices assignedpriorities property ﬁhighest priorityﬂ vertex moved fringe tree directly priority queue routines chapter  implement general graph searching program applications chapter convenient assign highest priority lowest assume inequalities switched programs chapter  program ﬁpriority firstsearchﬂ routine graph represented adjacency lists mostappropriate sparse graphs chapter procedure sparsepfs var integer link beginnow dobegin vai unseen dad pqconstruct repeatk pqremove val unseen thenbegin val endt dobeginif val unseen onpq val priority thenbegin pqchange priority dad nextenduntil pqempty functions onpq pqempty priority queue utility routines whichare easily implemented additions set programs chapter  pqempty returns true priority queue onpq returns true thegiven vertex priority queue chapter  substitution expressions priority program yields classical graph traversal algorithms program operates vertices sentinel unseen maxi initialize dad array storethe search tree construct indirect priority queue allthe vertices construction trivial values initially thesame terminology tree vertices onthe priority queue unseen vertices priority queue valueunseen fringe vertices priority queue theseconventions understood operation program straightforward itrepeatedly removes highest priority vertex queue puts onthe tree updates priorities fringe unseen vertices connectedto vertex vertices priority queue unseen vertex connectnlty397encountered connected vertex queue enteringa connected component automatically handled priorityqueue mechanism separate visit procedure inside amain procedure note maintaining proper morecomplicated recursive depth search program previous chapter convention program leave val entry unseen andzero root depth search tree connected component convenient set applications recall increases  execution thealgorithm assign unique priorities vertices wechange occurrences priority sparsepfs depth search newly encountered nodes highest priority ifwe priority breadth search nodes havethe highest priority priority assignments priority queuesoperate stacks queues onlyinterested depth breadth search directimplementation stacks queues priority queues sparsepfs chapter priority assignments lead otherclassical graph algorithms running time graph traversal implemented waydepends method implementing priority queue general wehave priority queue operation edge vertex worst case running time proportional log priorityqueue implemented heap notedthat depth breadth search advantage ofthe fact priority highest lowest encountered running time proportional priority queueimplementations graph isdense simply priority queue unordered array worst case running time proportional v2 justv2 edge simply requires setting resetting priority eachvertex requires searching queue highestpriority vertex implementation works thenext chapter difference depth breadth search evi dent large graph considered diagram left theedges nodes visited depth search halfway maze graph previous chapter starting upper left corner diagram picture breadth search chapter tree nodes blackened diagrams fringe nodes crossed andunseen nodes blank depth search ﬁexploresﬂ graph lookingfor vertices start point closer vertices whendead ends encountered breadth search completely covers area close starting point moving farther close looked depth search person maze ﬁnext place lookﬂ close breadth search group people fanning directions operational differences interesting reflect thefundamental differences implementations methods depth firstsearch simply expressed recursively underlying data struc ture stack breadth search admits simple nonrecursive implementation underlying data structure queue true underlying data structure graph algorithms priority queue admits wealth interesting properties examples chapter union algorithmsin applications simply vertex connectedto vertex graph actual path connecting berelevant problem carefully studied years someefficient algorithms developed independent processing sets collections objects graphs correspond sets objects natural verticescorresponding objects edges meaning ﬁis set ﬂthus sample graph previous chapter corresponds sets eac connected component correspondsh connectivity399to set sets interested fundamental question sx set ﬂ corresponds fundamental graphquestion ﬁis vertex connected vertex ﬂgiven set edges build adjacency list representation thecorresponding graph depth search assign vertex theindex connected component questions form ﬁis connectedto ﬂcan answered array accesses comparison theextra twist methods dynamic theycan accept edges arbitrarily intermixed questions answer questions correctly received correspondencewith set problem addition edge called union operation queries called jind operations objective write function check vertices andy set graph representation connectedcomponent set edge graph building direct adjacency list representation graph gain efficiency internal structure oriented supporting union operations internal structure forest trees connectedcomponent vertices belong sametree combine trees turns bothof operations implemented efficiently illustrate algorithm works forest structed edges sample graph inthis chapter processed arbitrary order initially nodes inseparate trees edge node tree formed witha root choice arbitrary equally atthe root edges add tree leavingthe edges lm jm jl jk build tree thathas structure note jl contribute lm jm component edges fd build trees leaving forest chapter this forest edges processed point graphwith connected components equivalently set union opera tions processed point led sets edge fe contribute structure component edge combines thefirst trees gc contribute gh jg resultin combined tree emphasized depth search trees onlyrelationship union trees underlying graph withthe edges divide vertices sets correspondence paths connect nodes trees paths connect nodes graph represent trees thatwe represented graph search trees array integers dad vertex father  entry fornodes root tree father vertex wesimply set dad root tree belongs werepeat operation reaching  union operations coivivectmty401very easily implemented function integer union boolean boolean var integer begini dad dad dadb dadlj union dadb function returns true vertices component addition component union flag set component method simple dad array root tree vertex check tosee merge tree rooted tree rootedat simply set dadb table abcdefgh ijklmag aab aaac aaalm aaljm aaaj ljl aaajl jk aaaj led aaeaj lfd aaef lhi aaef lfe aaef hjjl aaefaa lge aaefaa hjjl gc aaefaa hjjl gh aaefaaahj ljg jaaefaaahj llg jaaefaaahjjl asterisk vertices samecomponent time edge processed usual assuming chapter that functions translate ver tex names integers  table entry ofthe dad array entry function callf a test vertex named component vertex named introducing edgebetween algorithm bad worst case performance becausethe trees formed degenerate edges al3 bccd fg gh yz order produce long chainwith pointing pointing kind structure takes timeproportional v2 build time proportional averageequivalence test methods suggested deal problem onenatural method occurred reader todo ﬁrightﬂ thing merging trees arbitrarily settingdadij tree rooted merged tree rooted oneof nodes remain root descendants mustgo level tree minimize distance root nodes sense root node descendant idea called weight balancing easily implemented maintaining thesize tree number descendants root dad array entryfor root node encoded nonpositive number root nodecan detected traveling tree ideally node point directly root tree matter strategy achieving ideal require examiningat nodes smaller trees merged thiscould lot compared nodes path theroot examines approach ideal makingall nodes examine point root drasticstep blush easy rememberedthat sacrosanct structure trees theycan modified algorithm efficient thismethod called path compression easily implemented making anotherpass tree root setting dadentry vertex encountered point root combination weight balancing path compression ensures thatthe algorithms implementation showsthat extra code involved small price pay guard degeneratecases connectivity403function fastfind integer union boolean boolean var integer begini dad dad dadlj  dadb dad  dobegin dad dad dad  dobegin dad dad union thenif dad dad dadlj dadb dad dad endelse dad dad dadb  dadlj fastfind dad array assumed initialized  assume chaptersthat separate procedure findinit sample set edges program builds trees edges trees def jklm flatter ofpath compression fe contribute afcombines trees root tree larger thegc contribute gh puts tree jgputs jklm tree tree followingconstructed table contents dad array forest chapter abcdefgh jklmag a000000ab aooooa000000ac aaoooaooooo0lm aa00oa00 ljm aa00oa0ol02ljl aaoooaoolo2l jk aaoooaooll3led aaeloaooll3lfd aae2eaooll3lhi aae ea hll  lfe aae2ealhll3l gaaeaealhll lge gaaeaealhll l gc gaaeaealhll l gh aaeaeaahll3ljg aaeaeaahllallg aaeaeaahllal clarity table positive entry replaced ith letter thealphabet father negative entry complementedto positive integer weight tree techniques developed avoid degenerate struc tures path compression disadvantage requiresanother pass tree technique called halving tomake node point granddad tree anothertechnique splitting halving applied nodeon search path combination weight balancing height balancing tree height stead tree size decide merge trees choose methods howﬁflatﬂ trees produced analysis problem difficultbecause performance depends parameters butalso number operations worse order whichthe union operations sorting actual filesthat practice close ﬁrandom ﬂ hard model graphs request patterns practice reason algorithms worst case preferred union graph algorithms overlyccnservative approach connectmty405even worst case considered analysis union findalgorithms extremely complex intricate thenature clear indications algorithmswill perform practical situation weight balancing heightbalancing combination path compression halving orsplitting total number operations required build structurewith edges proportional function soslowly growing  large lg thentaking lg result lg result continuing  timesstill number bigger  stunningly large number allpractical purposes safe assume average time toexecute union operation constant result tarjan algorithm problem certaingeneral class function intrinsic tothe problem practical application union algorithms theycan determine graph vertices edges isconnected space proportional linear time anadvantage depth search situations toever store edges connectivity graph thousands vertices millions edges determined quick pass theedges exercises1 articulation points biconnected components graphformed deleting adding ik sample graph  write program print biconnected components graph  adjacency lists graph breadth search acycle depth search graph depth firstsearch cycle  draw search tree depth search ignorenodes fringe breadth search  draw search tree breadth search changethe priority nodes fringe depth search  draw union forest constructed text butassuming changed set  solve previous problem assuming path compression isused  draw union forests constructed edges yz assuming weight balancing path compression isused path compression weight balancing thenthat  implement union variants text empiricallydetermine comparative performance  union operations arguments random integers    write program generate random connected graph verticesby generating random pairs integers  estimate howmany edges needed produce connected graph function   weighted graphsit model practical problems graphs whichweights costs edge airline map whereedges represent flight routes weights represent distances fares electric circuit edges represent wires length cost wire natural weights job scheduling chart weights represent time cost performing tasks waiting tasks performed questions entailing minimizing costs naturally situations chapter examine algorithms problems ﬁfindthe lowest cost connect points ﬂ ﬁfind lowest cost path points ﬂthe graphsrepresenting electric circuit called minimzlm spanningtree problem graphs representingsomething airline route map called shortest path problem theseproblems representative variety problems weightedgraphs algorithms involve searching graph ourintuition supported thinking weights distances speak ﬁtheclosest vertex  ﬂetc fact bias built nomenclature forthe shortest path problem remember theweights proportional distance represent time cost weights actuallydo represent distances algorithms issue isdiscussed chapter typical weighted undirected graph diagramed edgescomprising minimum spanning tree drawn double lines note thatthe shortest paths graph edges minimum spanning tree shortest path vertex vertex isaf  chapter it obvious represent weighted graphs adjacency matrixrepresentation matrix edge weights boolean values adjacency structure representation list element represents edge weight start assuming weights positive ofthe algorithms adapted handle negative weights becomesignificantly complicated cases negative weights change thenature problem essential require sophisticatedalgorithms considered type difficulty suppose situation sum weights edges cycle negative infinitely short path begenerated simply spinning cycle minimum spanning treea minimum spanning tree weighted graph collection edges thatconnects vertices sum weights edges atleast small sum weights collection edges connects vertices minimum spanning tree unique forexample diagram minimum spanning treesfor sample graph weighted graphs409it easy prove ﬁcollection edgesﬂ referred definitionabove form spanning tree cycle edge cycle deleted collection edges connects vertices smaller weight previous chapters graph traversal procedurescompute spanning tree graph arrange things aweighted graph tree computed lowest total weight answer simple visit vertex connected tree edge lowest weight sequence diagrams illustrates sequence edges visited strategy graph implementation strategy trivial application prioritygraph search procedure previous chapter simply add weight fieldto edge record modify input code read weights weight priority program visit thevertex fringe closest tree traversal diagramed asabove comparison completely method examinebelow redraw graph standard search tree format chapter this method based fundamental property minimumspanning trees ﬁgiven division vertices graph sets minimum spanning tree shortest edges connecting vertex sets vertex set ﬂ wedivide vertices sets abcd efg sample graph thissays minimum spanning tree easy prove contradiction shortest edge connecting sets assumethat minimum spanning tree graph formedby adding purported minimum spanning tree graph acycle cycle edge connectingthe sets deleting edge adding shorter spanning tree contradicting assumption minimum spanning tree priority searching sets nodes question arethe visited nodes unvisited step pick shortestedge visited node fringe node edges visitednodes unseen nodes property edge picked ison minimum spanning tree previous chapter priority graph traversal algerithm worst case running time proportional logv thougha implementation priority queue v2 algorithm dense graphs chapter examinethis implementation priority graph traversal dense graphs fulldetail minimum spanning trees reduces method discovered prim  independently dijkstra methods essence graph representation plementation priority queues differ refer sparsepfs program ofthe previous chapter priority replaced weight ﬁpriority firstsearch solutionﬂ minimum spanning tree problem adjacencymatrix version chapter dense graphs ﬁprim weighted graphs411gorithm ﬂ note prim algorithm takes time proportional v2 evenfor sparse graphs factor v2 ogv slower priority firstsearch solution priority search solution factor ogvslower prim algorithm dense graphs completely approach finding minimum spanning tree isto simply add edges time step shortest edge thatdoes form cycle algorithm gradually builds tree edge time disconnected components illustrated sequence diagrams sample graph d8f correctness algorithm general property ofminimum spanning trees proved code method pieced programs thatwe priority queue data structure toconsider edges order weight job testing cycles union structures data structure graph simply array edge entry edge indirect priority queue procedures pqconstruct pqremove chapter  maintain priority queue weight fields edgearray priorities program findinit fastfind proceduresfrom chapter  program simply prints edges comprisethe spanning tree work dad array representationcould computed chapter program kruskai input output const maxv  maxe  type edge record weight integer var integer edges array maxe edge beginreadln forj toedobeginreadln edges weight edgesb edgesb findinit pqconstruct repeatm pqremove edges edges fastfind true thenbeginwriteln edges weight lenduntil running time program dominated time spent processingedges priority queue suppose graph consists clusters ofvertices connected short edges edge long connecting clusters longest edge graph minimum spanning tree edge priority queue running time proportional eloge inthe worst case expect smaller typicalgraphs takes time proportional build priorityqueue initially alternate implementation strategy sort edges byweight initially simply process order cycle testingcan time proportional elog simpler strategythan union minimum spanning tree algorithm takese log steps method proposed kruskal  earlierthan prim algorithm refer modernized version whichuses priority queues union structures ﬁkruskal algorithm ﬂthe performance characteristics methods weighted graphs413priority search method faster graphs prim someothers kruskal mentioned worst case priority search method logv worst case prim sis v2 worst case kruskal elog unwise choosebetween algorithms basis formulas ﬁworstrcaseﬂgraphs occur practice fact priority searchmethod kruskal method time proportional toe graphs practice edges reallyrequire priority queue adjustment takes ogv steps secondbecause longest edge minimum spanning tree sufficientlyshort edges priority queue prim method runs time proportional dense graphs itshouldn sparse graphs shortest paththe shortest path problem path weighted graph connectingtwo vertices property sum weights ofall edges minimized paths weights  problem interesting findthe path minimum number edges connects considered algorithm solves problem breadth search easy prove induction breadth searchstarting visit vertices reached edge vertices reached  edges visitingall vertices reached edges encountering thatrequire  edges encountered shortest path fromx shorter paths reached general path touch vertices usuallyconsider problem finding shortest paths connecting vertexx vertices graph turns theproblem simple solve priority graph traversal algorithm theprevious chapter draw shortest path vertex graph cycles spanning tree vertex leadsto spanning tree diagrams shortest path spanning trees vertices graphthat chapter the priority search solution problem thesolution minimum spanning tree build tree vertex byadding step vertex fringe closest closest tree fringe vertex closestto val array tree vertex val distancefrom vertex shortest path comprised oftree nodes tree update fringe goingthrough adjacency list node list shortest distanceto val weight algorithm triviallyimplemented quantity priority priority graph traversalprogram sequence diagrams construction theshortest path search tree vertex b b ca1kb d0f weighted graphs415first visit closest vertex aredistance  visit order priority queuereturns attached path distance  algorithm attaches tree beforef fringe tree tprovide shorter path finally visited usual tree represented dad array father links table thearray computed priority graph traversal procedure abcdefgdad abbfaeval thus shortest path total weight  valentry tracing backwardsin dad array starting note correct operation program depends val entry root convention adopted sparsepfs priority graph traversal algorithm worst case runningtime proportional log implementation thepriority queue v2 algorithm dense graphs examine implementation priority graph traversal densegraphs shortest path problem reduces method discovered dijkstra  methods inessence refer sparsepfs program previous chapter withpriority replaced val weight ﬁpriority search solutionﬂ tothe shortest paths problem adjacency matrix version asﬁdijkstra algorithm ﬂdense graphsas discussed graph represented adjacency matrix isbest unordered array representation priority queue orderto achieve v2 running time priority graph traversal algorithm thatis linear algorithm priority search theminimum spanning tree shortest path problems dense graphs maintain priority queue val array insparsepfs implement priority queue operations directly thanusing heaps adopt convention priority values theval array negated sign val entry tells thecorresponding vertex tree priority queue change crapter priority vertex simply assign priority vaj entry thatvertex remove highest priority vertex simply scan thevaj array vertex largest negative closest  vaj complement vaj entry making mechanical tothe sparsepfs program previous chapter left followingcompact program procedure densepfs var min integer beginfor vdobegin vaj unseen dad vaj unseen min repeatk min vaj vaj min vaj unseen vaj vdoif vaj thenbeginif vaj priority thenbegin vaj priority dad vaj vaj min min enduntil min note loop update priorities loop minimumare combined time remove vertex fringe pass vertices updating priority keeping track theminimum note unseen thanmaxint higher sentinel minimum negative representable priority program prim algorithmfor finding minimum spanning tree vaj prioritywe dijkstra algorithm shortest path problem chapter30 include code maintain number vertices farsearched priority depth search nowwe breadth search program differs sparsepfs programof chapter  graph representation adjacency matrix adjacency list priority queue implementation unordered array weighted graphs417instead indirect heap yield worst case running timeproportional v2 opposed logv sparsepfs therunning time linear dense graphs proportional v2 butsparsepfs faster sparse graphs geometric problemssuppose points plane theshortest set lines connecting points geometric problem called euclidean minimum spanning tree problem solved ing graph algorithm clear geometryprovides extra structure efficient algorithms bedeveloped solve euclidean problem algorithm aboveis build complete graph vertices   edges oneedge connecting pair vertices weighted distance thecorresponding points minimum spanning tree algorithm dense graphs time proportional proven point thegeometric structure edges complete graph irrelevantto problem eliminate edges startingto construct minimum spanning tree fact proven minimum spanning tree subset graph derived edges dual voronoi diagram chapter  knowthat graph number edges proportional kruskal salgorithm priority search method work efficiently sparse graphs principle compute voronoi dual takes time proportional nlog kruskal algorithm thepriority search method euclidean minimum spanning tree algo rithm runs time proportional log writing programto compute voronoi dual challenge experiencedprogrammer approach random point sets takeadvantage distribution points limit number edgesincluded graph grid method chapter  rangesearching divide plane squares squareis  points include graph edges connecting point points neighboring squares guaranteed edges minimum spanning tree kruskal algorithm priority search method efficiently finish job interesting reflect relationship graph geometricalgorithms brought problem posed previous paragraphs chapter is true problems formulated geometricproblems graph problems actual physical placement objectsis dominating characteristic geometric algorithms previoussection interconnections objects offundamental graph algorithms bebetter euclidean minimum spanning tree fall interface approaches input involves geometry output involves interconnections development simple straightforward methods problems remains elusivegoal interaction geometric graph algo rithms problem finding shortest path graphwhose vertices points plane edges lines connectingthe points maze graph chapter  viewed graph solution problem simple priority searching setting priority fringe vertex encountered distance tree fringe vertex algorithm plusthe euclidean distance fringe vertex isadded tree method shortest path standard graph algorithm toﬁsearchﬂ corner large maze graph likethat chapter  require examining number nodesproportional standard algorithm examine virtuallyall nodes weighted graphs419exercises1 minimum spanning tree graph ning chapter  algorithm minimum spanning forest connectedgraph vertex touched edge graphdoesn connected  graph vertices edges priority firstsolution minimum spanning tree problem algorithm requiretime proportional log explain youranswer  suppose maintained priority queue sorted list generalgraph traversal implementations worst case ning time constant factor method beappropriate  counterexamples ﬁgreedyﬂ strategydoesn work shortest path minimum spanning treeproblems ﬁat step visit unvisited vertex closest justvisited ﬂ6 shortest path trees nodes graph  shortest path upper hand corner lowerleft hand corner maze graph chapter  assuming edgeshave weight   write program generate random connected graphs vertices minimum spanning tree shortest path tree somevertex random weights  weights thetrees compare values  write program generate random complete weighted graphs vvertices simply filling adjacency matrix random numbers tween  empirical tests determine method finds theminimum spanning tree faster    prim kruskal  counterexample method finding theeuclidean minimum spanning tree work ﬁsort points theirx coordinates minimum spanning trees half andthe half shortest edge connects ﬂ  directed graphsdirected graphs graphs edges connecting nodes structure difficult determine variousproperties processing graphs akin traveling city withmany streets traveling country airlines rarelyrun round trip routes point situationscan challenge edge direction reflects type precedence relationship inthe application modeled directed graph usedto model manufacturing nodes jobs edge node node job node job node decide perform jobs precedence relationships areviolated chapter depth search directed graphs wellas algorithms computing transitive closure summarizes nectivity topological sorting computing stronglyconnected components precedence relationships mentioned chapter  representations directed graphs aresimple extensions representations undirected graphs adjacencylist representation edge appears edge isrepresented list node linked list adjacency matrix representation maintain vmatrix  bit row column row andcolumn edge directed graph undirected graph sidering drawn graph consists edges ai3 lm jmjljkeddfhifeafgegchggjlgmml  chapter the order edges notation agdescribes edge points ispossible edges nodes direction haveboth lm graph note representations difference perceivedbetween undirected graph directed graph opposite directededges edge undirected graph algorithms chapter considered generalizations algorithms previous chapters depth searchthe depth search algorithm chapter  works properly directedgraphs fact operation straightforwardthan undirected graphs concerned doubleedges nodes explicitly included graph search trees complicated structure depth search structure describes operation recur sive algorithm chapter  sample graph redrawn version graph solid edges correspond directed graphsing edges visit vertices recursive callsand dotted edges edges pointing vertices visited time edge considered nodes visited order note directions edges depth search forestquite depth search forests undirectedgraphs original graph connected thedepth search structure defined solid edges connected isa forest tree undirected graphs kind dotted edge thatconnected vertex ancestor tree directed graphs thereare kinds dotted edges edges point vertex someancestor tree edges point vertex descendant tree cross edges point vertex vertex descendant ancestor tree undirected graphs interested connectivity properties ofdirected graphs answer questions ﬁis therea directed path vertex vertex path edges inthe direction ﬂand ﬁwhich vertices vertex xwith directed path ﬂand ﬁis directed path vertex vertexy directed path ﬂ undirected graphs beable answer questions appropriately modifying basic depth firstsearch algorithm types dotted edges modifications complicated transitive closurein undirected graphs simple connectivity vertices reachedfrom vertex traversing edges graph connected component directed graphs ofteninterested set vertices reached vertex bytraversing edges graph direction easy prove recursive visit procedure depth firstsearch method chapter  visits nodes reached thestart node modify procedure print nodes isvisiting inserting write entering printingout nodes reached start node note carefullythat true tree depth search forestcontains nodes reached root tree ourexample nodes graph reached toget nodes visited node simply visit vtimes node chapter for vdobeginnow  vaili visit wri telnend program produces output sample graph afedbg jklmcbcafedbgjklmdfeedffedgjklmcafedbhgjklmcafedbiihgjklmcafedbjklgcafedbmklgjkmcafedbmlgjkcafedbfor undirected graphs computation produce table theproperty nodes connected component lists nodes component table property lines list identical sets nodes examine thegeneralization connectedness explains property usual add code extra processing justwriting table operation perform add anedge directly  graphwhich adding edges form directed graph calledthe transitive closure graph large number edges beadded transitive closure dense adjacency matrix representation called analogue connected components undirected graph performed computation answer questions s ﬂusing depth search compute transitive closure requires v3steps worst case examine bit directed graphs425adjacency matrix depth search vertex aremarkably simple nonrecursive program computing transitive closureof graph represented adjacency matrix dofor  doif thenfor vdoif true warshall invented method  simple observation thatﬁif node node node tonode node node ﬂ trick makethis observation stronger computation pass matrix wit ﬁif node tonode nodes indices nodey node node node nodeswith indices  ﬂthe program direct implementationof warshall method converts adjacency matrix sample graph left table adjacency matrix transitiveclosure abcdefghijklma1100011000000boloooooooooooc1010000000000dooololoooooooeooolloooooooofoooollooooooogoolololoolooohoooooollloooo10000000110000jooooooooollllkoooooooooolool0000001000011mooooooooooollabcdefghi jklma1111111001111boloooooooooooc1111111001111dooollloooooooeooolllooooooofooolllooooooogllllllloollllhlllllllllllll11111111111111jllllllloollllkoooooooooolool1111111001111mllllllloollll chapter for large graphs computation organized theoperations bits computer word time lead tosignificant savings environments intendedthat optimizations pascal topological sortingfor applications involving directed graphs cyclic graphs graph modeled manufacturing imply job job job job situation inconsistent applications directed graphs directed cycles cycles edges pointing called graphs arecalled directed acyclic graphs dags short dags manycycles directions edges account definingproperty simply cycle edges inthe direction dag directed graph afew edges removed directions switched order remove cycles givenbelow edge list graph connected graph chapter30 order vertices edgeis difference dags objects general directed graphs ina sense tree graph advantage oftheir special structure processing viewed vertex dag tree depth search forest dag edges depth search forest describes operation dfs dag directed graphs427a fundamental operation dags process vertices graphin order vertex processed vertex pointsto nodes graph processed order jklmaghifedbcif edges drawn vertices positions edgeswould left mentioned obvious application graphs represent manufacturing processes aspecific proceed constraints represented graph thisoperation called topological sorting involves ordering verticesof graph general vertex order produced topological sort unique orderajgfklembhcidis legal topological ordering manufacturing application mentioned situation occurs onejob direct indirect dependence beperformed order occasionally interpret edges graph wayaround edge directed vertex xﬁdependsﬂ vertex vertices represent terms bedefined programming language manual book algorithms withan edge definition case ordering property term defined definition corresponds positioning vertices edges left reverse topologicalorder sample graph defcbihgakmlj chapter the distinction crucial performing reverse topological sort agraph equivalent performing topological sort graph byreversing edges algorithm reverse topological sorting thestandard recursive depth search procedure chapter  simply chang ing visit print vertex visited exiting byinserting write dfs print verticesin reverse topological order input graph dag simple inductionargument proves works print vertex afterwe printed names vertices points visitis changed prints vertices inthe reverse topological order printing vertex onexit recursive procedure equivalent putting vertexname stack entry popping printing exit ridiculous explicit stack case mechanism recursion automatically mention stack difficult problem considered connected componentsif graph directed cycle node itselfby edges direction dag itcan topologically sorted whichever vertex cycle printed firstwill vertex points printed nodes cycle mutually accessible sense node cycle node cycle andback hand graph connected notlikely true node reached directed path fact nodes divide sets called connectedcomponents property nodes componenl mutuallyaccessible node component nodein component connected components thedirected graph chapter single nodes pair nodes triple nodes large component withsix nodes vertex componentfrom vertex path toget connected components directed graph foundusing variant depth search reader learned expect method examine discovered tarjan  sinceit based depth search runs time proportional isactually ingenious method requires simple modificationsto basic visit procedure tarjan presented method linear dlrected graphs429time algorithm problem people hadworked modified version depth search stronglyconnected components graph program westudied chapter  finding biconnected components recursive visit function min computation highestvertex reachable link descendant vertex usesthe min write connectedcomponents function visit integer integer var link min integer beginnow val min stack dobeginif vaj othen visit vaj min min nextend min vaj thenbeginrepeatp  write stack vaj stack iuntil stack wri telnend visit min program pushes vertex names stack entry visit thenipops prints exit visiting member eachstrongly connected component point computation testwhether min vaj vertices encountered entry printed belong connected chapter component usual program easily modified moresophisticated processing simply writing components method based observations alreadymade contexts reach visit fora vertex encounter vertices stronglyconnected component vertices reached thatvertex processed topological sorting ﬁupﬂ links tree provide path vertex bind strong components algorithm chapter  finding articulation points track highest ancestor reachable ﬁupﬂ link descendants node vertex xhas descendants ﬁupﬂ links depth search tree adescendant depth search tree ﬁupﬂ link points descendants ﬁupﬂ links point higher tree itand descendants vertices satisfying property andtheir descendants comprise connected component depth search tree chapter nodes satisfy thefirst condition represent connected components nodes representing representing representinga satisfy condition members componentrepresented deleting descendants discovered components descendant thatdoes satisfy property descendant ﬁupﬂlink points higher tree path downthrough tree path fromy vertex ﬁupﬂ link reaches continuing thesame process reached crucial extra twist donewith vertex high val ﬁcrossﬂ links vertex willbe program deceptively simple solution difficultproblem testimony subtleties involved searchingdirected graphs subtleties handled case carefully crafted recursive program directed graphs431exercises1 adjacency matrix transitive closure daggiven chapter  result running transitive closure algorithms onan undirected graph represented adjacency matrix  write program determine number edges transitive closureof directed graph adjacency list representation  discuss warshall algorithm compares transitive closurealgorithm derived depth search technique describedin text adjacency matrix form visit removing recursion  topological ordering produced dag inthe text suggested method adjacency matrixrepresentation dfs scans vertices reverse order downto  unvisited vertices  shortest path algorithm chapter  work directedgraphs explain fails  write program determine directed graph adag  connected components dag graphwith directed cycle size  programs chapters   produce large randomdirected graphs vertices connected ponents graphs tend  write program functionally analogous chapter30 maintains connected components directed graphdescribed input edges easy problem certainlywon efficient program  network flowqweighted directed graphs models types applica tions involving commodities flowing interconnected network network oil pipes varying sizes interconnectedin complex ways switches controlling direction flow junctions suppose network single source oil field asingle destination large refinery pipes ultimatelyconnect switch settings maximize oil flowing fromsource destination complex interactions involving material flow junc tions problem called networkflow problem nontrivial problemto solve general setup traffic flowing alonghighways materials flowing factories versionsof problem studied practical situations applied strong motivation efficient algorithm problems type problem lies interface computer scienceand field operations operations researchers generallyconcerned mathematical modeling complex systems purposeof preferably optimal decision making network flow typical operations problem touch chapters   modeling lead complex mathematical equationsthat require computers solution classical solution thenetwork flow problem closely graph algorithms examining problem actively studied problems looked ﬁbestﬂsolution good algorithms beingdiscovered  crapter the network flow problemconsider idealized drawing small network oil pipes pipes fixed capacity proportional size oil ilowin direction downhill haveunidirectional pumps switches junction control howmuch oil direction matter switches set reaches state equilibrium oil flowing left equal flowing quantity maximize oil flowing junction equal oil flowing measure flow pipe capacity terms integral ﬁunitsﬂ gallons obvious switch settings affect thetotal flow illustrate supposethat switches open diagonal pipes andbottom pipes configuration total flow network case half thecapacity input pipe half capacity theoutput pipe suppose upward diagonal pipe shut thisshuts flow equal capacity unaffectedbecause room replace flow input pipe network flow435the total flow network increased situation modeled directed graph itturns programs studied apply define networkas weighted directed graph distinguished vertices noedges pointing source edges pointing sink theweights edges assume negative called edgecapacities flow defined set weights edges suchthat edge equal capacity flowinto vertex equal flow vertex flowis flow source sink network flow problem isto flow maximum network networks represented adjacency matrixor adjacency list representations graphs previouschapters single weight weights edge size aow represented fields adjacency list node matrices adjacency matrix representation fields single record representation networks directed graphs algorithms examining traverse edges ﬁwrongﬂ direction undirected graph representation edge size flow alsokeep edge size flow adjacency listrepresentation maintain links connecting list nodeswhich represent edge change flow update ford fulkerson methodthe classical approach network flow problem developed ford fulkerson  method improve legalflow maximum starting flow applythe method repeatedly long method applied produces anincreased flow applied maximum flow directed path network source sink flow increased smallest unusedcapacity edge path increasing flow edges crapter path rule applied thepath adebcf path abcdef cu4  fe2  and path abcf directed paths network edge whichis filled capacity increase flow arbitrary paths network edges point ﬁwrong wayﬂ sink source path flow network flow437be increased path increasing flow edges sourceto sink decreasing flow edges sink source simplify terminology edges flow source sink path forward edges edges flow sink tosource backward edges flow network beincreased  path abef corresponds shutting oil pipe units redirected losing flow  units replaced units notice flow increased limited bythe minimum unused capacities forward edges minimumof flows backward edges flow atleast forward edges path ofthe backward edges path flow increased path forward edge backward edge paragraph method increasing flow anynetwork provided path forward edges backwardedges crux ford fulkerson method observationthat path flow maximal proof ofthis fact path source sink fullforward edge backward edge graph andidentify edge path set edges cuts graph intwo parts diagram chaf ter for cut network parts measure flow ﬁacrossﬂthe cut total flow edges source sinkminus total flow edges examplecut  equal total flow network turns cut flow equals total flow flow maximal cut minimal othercut high flow ﬁacrossﬂ called maxfiow mincuttheorem flow larger cut belarger smaller cuts exist flow besmaller network searchingthe ford fulkerson method summarized ﬁstart flow increase flow path fromsource sink forward edges backward edges continuinguntil paths network ﬂ algorithm inthe sense accustomed method findingpaths based intuition longer path network filled long pathsshould preferred classical careshould exercised  b0  loo0d0 now path chosen abdc flow increased path chosen adbc increasing flow network flow439one leaving situation identical initial situation theflows edges increased  algorithm chose paths long paths continue requiring  pairs iterations maximum flow isfound numbers sides billion billion iterationswould undesirable situation pathsabc adc maximum flow steps thealgorithm avoid running time dependenton magnitude capacities fortunately problem easily eliminated proven edmondsand karp breadth search path thenumber paths maximum flow network vvertices edges worstccase bound atypical network require fewer steps simplyuse shortest path source sink ford fulkerson method priority graph traversal method chapters   wecan implement method suggested edmonds karp thepath network increases flow largest achieved simply variable priority valueis set appropriately adjacency list sparsepfs chapter  orthe adjacency matrix densepfs chapter  followingstatements compute priority assuming matrix representation size priority size aow priority flow priority val priority val node highest priority musteither reorient priority queue mechanisms programs returnthe maximum minimum priority setto maxim priority process reversed removed modify priority search procedure source sinkas arguments start source path sink path partial priority search treedefines mincut network finally val source setto maxi search started flowcan achieved source restricted thetotal capacity pipes leading directly source densepfs implemented previous paragraph ing maximum flow simple chapter program repeatdensepfs dad xc  dobeginaow aow val vl aow aow dad enduntil val unseenthis program assumes adjacency matrix representation usedfor network long densepfs path increases flow maximum trace path thedad array constructed densepfs increase vremains unseen densepfs mincut andthe algorithm terminates network algorithm increases flow thepath abcf adef abcdef backwards edgesare algorithm unwise choiceadebcf illustrate backwards edges nextchapter graph algorithm backwards edges tofind maximum algorithm easily implemented work wellfor networks practice analysis method plicated usual densepfs requires v2 steps worst case wecould sparsepfs time proportional log iteration algorithm faster stopswhen reaches sink iterations required edmonds karp worst case  logmimp1 costof flow maximum number edges cut network complicated compute large forreal networks formula included indication long algorithm actual network complexity analysis problem studied andcomplicated algorithms worst case time bounds beendeveloped network flow problem extended ways manyvariations studied network flow441actual applications multicommodity flow problem involvesintroducing multiple sources sinks types material network thismakes problem difficult requires advanced algorithmsthan considered analogue max flow min cut theorem hold general case extensions thenetwork flow problem include placing capacity constraints vertices easily handled introducing artificial edges handle capacities allowing undirected edges easily handled replacing undirected edges pairs directed edges introducing lower bounds edge flows easily handled realistic assumption pipes costs capacities min cost flow problem difficult nroblem onerations irl exercises1 algorithm solve network flow problem case thenetwork forms tree sink removed  paths traced algorithm text findingthe maximum flow network  draw priority search trees computed densepfs theexample discussed text  true false algorithm maximum flow examiningevery edge network  ford fulkerson method case networkhas directed cycle  shortest path traversal produce differentset paths method text  counterexample depth search propriate network flow problem  assignment sizes algorithm thetext backward edge graph prove exists  implement breadth search solution network flow problem sparsepfs  write program maximum flows random networks vnodes ov edges calls sparsepfs forv   loo  matchinga problem arises ﬁpair upﬂ objects prefer ence relationships conflict quitecomplicated set place graduating medicalstudents hospital residence positions student lists hospitalsin order preference hospital lists students order ofpreference problem assign students positions fair respecting stated preferences sophisticated algorithm requiredbecause students preferred hospitals andthe hospital positions preferred students clear hospital position filled student thehospital listed student assigned position thestudent listed respect order preference lists actuallythis frequently occurs algorithm minute scramble unmatched hospitals students tocomplete process special case difficult fundamental problem ongraphs studied graph matching subsetof edges vertex appears vertextouched edges matching paired vertex edge vertices left unmatched insist edges connecting unmatched vertices waysof choosing edges lead numbers leftover unmatched vertices mazimum matching manyedges equivalently minimizes number unmatchedvertices hope set edges vertex appears matching graph with2v vertices edges achieve  chapter for sample undirected graph edges hl jk lm maximum matching graph edge matching forthe subgraph consisting vertices edges connectingthem medical student matching problem studentsand hospitals correspond nodes graph preferences toedges assign values preferences time honored ﬁl ﬂ scale weighted matching problem givena weighted graph set edges vertex appears thanonce sum weights edges set chosen maximized alternative respect order preferences require arbitrary values assigned matching problem attracted attention intuitivenature wide applicability solution general case involvesintricate beautiful combinatorial mathematics scope book intent provide reader appreciation problem interesting special cases time developing algorithms bipartite graphsthe mentioned matching medical students residencies iscertainly representative matching applications matching men women dating service job applicants toavailable positions courses hours congressmen committeeassignments graphs modeling cases called bipar tite graphs defined graphs edges twosets nodes nodes divide sets edges connecttwo nodes set ﬁmatchﬂ jobapplicant committee assignment reader amused search maximum matching thetypical lipartite graph drawn adjacency matrix representation bipartite graphs achieveobvious savings including rows set columns set adjacency list representation saving suggests naming vertices intelligently easy set vertex belongs examples letters nodes set numbers nodesin maximum matching problem bipartite graphs besimply expressed representation ﬁfind largest subset set ofletter number pairs property pairs letteror number ﬂfinding maximum matching bipartite graphcorresponds solving puzzle pairs e5 b4 d3 a4d5 interesting exercise attempt direct solution thematching problem bipartite graphs problem easy firstglance subtleties apparent pairings possibilities solution problem clever ways match vertices solution examine indirect solve particularinstance matching problem construct instance networkflow problem algorithm previous chapter thesolution network flow problem solve matching problem reduce matching problem network flow problem reduction arnethod algorithm design akin library subroutine systems programmer fundamental theoryof advanced combinatorial algorithms chapter  moment reduction provide efficient solution bipartite matchingproblem construction straightforward instance bipartite match chapter ing construct instance network flow creating source vertex withedges pointing members set bipartite graph makeall edges bipartite graph point set adda sink vertex pointed members set edges graph capacity  bipartite graph corresponds network darkened edges showthe paths network flow algorithm previouschapter graph note bipartite property graph direction flow andthe fact capacities  force path network tocorrespond edge matching paths farcorrespond partial matching d5 time network flow algorithm calls pfs finds path increases flow orterminates forward paths network algorithmmust backward edges path path04alc3ez path increases flow network inthe previous chapter context path setof instructions create partial matching edge current construction natural tracing path order ﬁ4aﬂ add matching requires matchingthat ﬁalﬂ deleted ﬁ1cﬂ add matching requiresthat ﬁc3ﬂ deleted ﬁ3eﬂ add matching afterthis path processed matching d5 equivalently flow network pipes edges connecting nodes pipes leaving  entering proof matching edges filled tocapacity maxflow algorithm straightforward network flowalways legal matching vertex edge capacity either coming sink source unitof flow vertex implies vertex beincluded matching matching edges matching lead directly flow thatproduced maxflow algorithm compute maximum matching bipartite graph simplyformat graph suitable input network flow algorithmof previous chapter graphs presented network flow algorithm case simpler general graphs algorithm designed handle turns algorithm efficient case construction ensures pfs addsone edge matching  calls topfs execution algorithm total timeto maximum matching dense bipartite graph vertices adjacency matrix representation proportional v3 stable marriage problemthe chapter involving medical studentsand hospitals participants butthe method examine matching betterunderstood terms whimsical model situation assume men women expressed mutual preferences man feels women vice versa problem set marriages respects preferences preferences expressed method usethe ﬁ1 ﬂ scale assigning absolute score members ofthe marriage problem weightedmatching problem difficult problem solve ofabsolute scales lead inaccuracies peoples scales beinconsistent woman  woman  naturalway express preferences person list order preferenceall people opposite sex tables chapter preferences set women men usual protectthe innocent assume hashing method totranslate actual names single digits women single letters men  eadbcb  debacc  adbced  cbdaee  dbceaclearly preferences conflict list  astheir choice  mustget problem engage women men respect preferences perform nmarriages grand ceremony developing solution assume thatanyone assigned choice disappointed prefer higher list set marriages called unstable people married prefer totheir spouses assignment d4 e5 unstablebecause prefers    prefers acting preferences leave    leave leaving  andc choice finding stable configuration face difficultproblem assignments determiningwhether configuration stable simple reader discover reading paragraph unstable couple matches general stable assignments set preference lists finding stable assignments difficult problem algorithm finding stable configuration toremove unstable couples time slow becauseof time required determine stability process terminate matched  unstable couple leads configuration d4 e5 arrangement  unstable couple leads configuration d4 e5 finally  unstable configuration leads originalconfiguration algorithm attempts solve stable marriageproblem removing stable pairs bound caught thistype loop matching449instead algorithm build stable pairingssystematically method based happen somewhatidealized ﬁreal lifeﬂ version problem idea man turn ﬁsuitorﬂ seek bride step quest propose woman list engaged man prefers suitor woman hislist continuing finds woman engaged prefershim current fiancee women engaged becomesengaged suitor man suitor engaged breaks engagement engaged suitor prefers leaves fiancee thesuitor starting left list eventually finds anew fiancee engagement broken continue inthis breaking engagements suitor finds womanwho engaged method model th century novels butsome careful examination required produces stable set ofassignments diagram sequence events initial stages process proposes  choice accepted proposes  choice accepted proposes  turned proposes  accepted depictedin diagram diagram sequence events man sets thesuitor seek fiancee ﬁusedﬂ preference list thecorresponding man link labeled integer telling thatlink man propose woman extra informationis tracking sequence proposals thesuitor figure cwter when proposes  broken engagement  prefersd suitor proposes  broken engagement  prefers suitor proposes  leaves stable situation reader trace sequence proposals suitor things settle proposals note takes onthe suitor role process implementation data structures represent thepreference lists structures men thewomen preference lists ways men simply preference lists order straightforward implementation dimensional array called maintain dimensionalarray preference list prefer wthwoman preference list mth man addition keeptrack man progressed list handledwith dimensional array initialized  theindex woman man preference list identifier inprefer woman track fiancee fiancee willbe man engaged woman answer thequestion ﬁis man preferable fiancee ﬂ searchingthe preference list sequentially fiancee thismethod inefficient calledfor ﬁinverseﬂ preference list rank man onwoman preference list array matching4511                         the suitability suitor tested statement ifrank rank fiancee arrays easily constructed rectly preference lists things started ﬁsentinelﬂ man0 initial suitor women preferencelists data structures initialized implementation asdescribed straightforward dobegins repeatnext prefer rank rank fiancee thenbegin fiancee fiancee iteration starts unengaged man ends engagedwoman repeat loop terminate man list containsevery woman iteration loop involves incrementing man slist unengaged woman encountered man list exhausted set engagements produced algorithm stable woman man prefers fiancee engaged tosomeone prefers obvious built biases algorithm themen women lists order women mustwait ﬁright manﬂ bias corrected asomewhat easier manner real life interchanging order whichthe preference lists input produces stable configuration e d3a c b women choice  hersecond general stable configurations shownthat ﬁoptimalﬂ women sense stableconfiguration woman choice list stable configuration optimal men chapter another feature algorithm biased order inwhich men suitor man propose engaged choice reduced chance suffer indignities abroken engagement answer bias tmatter order men suitor long man makesproposals woman accepts lists stableconfiguration advanced algorithmsthe special cases examined indication plicated matching problem general problemsthat studied maximum matching problemfor general bipartite graphs weighted matching bipartitegraphs edges weights matching maximum total weight sought weighted matching general graphs treating tech niques matching general graphs entirevolume extensively studied problems graph theory exercises1          matchings edges sample bipartitegraph algorithm text maximum matchings forrandom bipartite graphs  vertices  edges edges matchings construct bipartite graph nodes edges athree edge matching prove exists suppose vertices bipartite graph represent jobs people andthat person assigned jobs reduction networkflow algorithm problem prove answer modify network flow program chapter  advantage thespecial structure networks bipartite matching write efficient program determining assignment themarriage problem stable men choice stable marriagealgorithm prove answer construct set preference lists  stable marriageproblem choice prove suchset exists stable configuration stable marriage problem casewhere preference lists men women ascend ing order stable marriage program  random permutationsfor preference lists proposals theexecution algorithm sources graph algorithmsthere textbooks graph algorithms reader shouldbe forewarned great deal learned graphs thatthey fully understood traditionally studiedfrom mathematical opposed algorithmic standpoint manyreferences rigorous deeper coverage difficulttopics treatment topics treated covered book byeven network flow chapter  sourcefor material book papadimitriou steiglitz mostof book advanced topics treatment matching general graphs coverage algorithms discussed including pointers reference material application depth search solve graph connectivity otherproblems work tarjan original paper merits furtherstudy variants algorithms union problem chapter30 ably categorized compared van leeuwen tarjan thealgorithms shortest paths minimum spanning trees dense graphsin chapter  original papers dijkstra prim andkruskal interesting reading treatment stable marriage problem chapter  based entertaining account knuth dijkstra ﬁa note problems connexion graphs ﬂ numer ishe muthemutik   graph algorithms computer science press rockville md  knuth marriages stables presses universite montreal montreal  kruskal ﬁon shortest spanning subtree graph thetraveling salesman problem ﬂ proceedings ams    papadimitriou steiglitz combinatorial optimization algorithmsand complexity prentice hall englewood cliffs  prim ﬁshortest connection networks generalizations ﬂ bellsystem technical journal   tarjan ﬁdepth search linear graph algorithms ﬂ siam journalon computing    van leeuwen tarjan ﬁworst case analysis set union algo rithms ﬂ journal acm advanced topics  algorithm machinesthe algorithms studied remarkablyrobust applicability methods seenare decade survived radical incomputer hardware software hardware designs softwarecapabilities impact specific algorithms butgood algorithms machines good algorithms onnew machines reason fundamental design ﬁconventionalﬂcomputers changed years design vast majorityof computing systems guided underlying principle wasdeveloped mathematician von neumann early days moderncomputing speak von neumann model computation werefer view computing instructions data stored thesame memory single processor fetches instructions memoryand executes operating data elaboratemechanisms developed computers cheaper faster smaller physically larger logically architecture computersystems viewed variations von neumann theme radical cost computing componentshave plausible radically types machines onesin large number instructions executed time instant instructions ﬁwired inﬂ special purpose machines capable solving problem large number smaller machines cooperate solve problem short thanhaving machine execute instruction time instant canthink large number actions performed simultaneously chapter potential ideas problems algorithms  chapter general approachescertain fundamental algorithms frequently large prob lems pressure bigger faster puters result series ﬁsupercomputersﬂ body latest technology concessions fundamental von neumann concept designed general purpose usefulfor programs common approach machine typeof problem studying start algorithms conventional machines adapt features machine approach encourages persistence algorithms architecture machines microprocessors computing capabilities quiteinexpensive obvious approach large number processorstogether solve large problem algorithms adapt beingﬁdistributedﬂ simply kind ofimplementation development inexpensive powerful processors volved appearance general purpose tools designing build ing processors led increased activity developmentof special purpose machines problems machine ticularly suited execute algorithm designand build problems machine bedesigned built fits large scale integrated circuit chip common thread approaches parallelism tohave things happening instant canlead chaos orderly manner examples illustrate techniques achieving high degree parallelism specific classes problems idea assume processors program things work hope program times fasterthan problems involved processorsto work solve problem theymust communicate wires interconnecting themand specific mechanisms sending data wires physical limitations type interconnectionallowed suppose ﬁprocessorsﬂ integrated circuitchips circuitry small computers  pins interconnection such processors connect  choiceof interconnect processors fundamental parallel computing algorithm machines459moreover remember decision aheadof time program change things depending onthe instance problem solved machine generally change parts wired general view parallel computation terms independent proces sors fixed interconnection pattern applies threedomains supercomputer specific processors interconnection patterns integral architecture affect aspects performance interconnected microprocessors involve small number powerful processors simple interconnections large scale integrated circuits involve large number simpleprocessors circuit elements complex interconnections views parallel computation studied extensivelysince von neumann renewed inexpensive processors havebecome scope book treat issues involved specific machines proposed familiar problems machines illustrate effects machine architecture algorithm design andvice versa symbiosis work tdesign computer idea onewould computers execute importantfundamental algorithms perfect shuflesto illustrate issues involved implementing algorithms chines programs interesting method mergingwhich suitable hardware implementation generalmethod developed design ﬁalgorithm machineﬂ whichincorporates fundamental interconnection pattern achieve parallel opera tion processors solving problems addition merging mentioned fundamental difference writing programto solve problem designing machine program adapt itsbehavior instance problem solved themachine ﬁwiredﬂ ahead time perform sequence operations difference sorting program studied sort3 chapter  matter numbers thedata program performs sequence fundamentalﬁcompare exchangeﬂ operations sorting algorithms thatwe studied property perform sequence comparisonsthat depends outcome previous comparisons presents severeproblems hardware implementation crapter specifically piece hardware input wires twooutput wires compare numbers input exchangethem output wire togetheras produce sorting machine inputs thefigure outputs box wouldexchange box exchangethe box exchange andthe produce sorted result details worked actualsorting machine based scheme built methodof encoding inputs left unspecified eachwire diagram ﬁbusﬂ wires carry data withone bit wire compare exchangers read theirinputs bit time single wire bit alsoleft unspecified timing mechanisms included ensure thatno compare exchanger performs operation input ready delve deeper circuit design questions concentrate higher level issues interconnectingsimple processors compare exchangers solving larger problems algorithm merging sortedfiles sequence ﬁcompare exchangeﬂ operations independentof numbers merged suitable hardwareimplementation suppose sorted files keys bemerged sorted file write file thencompare vertically adjacent exchange larger smaller algorithm machines461aeggimnrabeeimnrabeelmpxaegglmpxnext split half interleave halves perform samecompare exchange operations numbers lines note comparisons involving pairs lines becauseof previous sorting eabeeimnraeggaeggimnrl xlmpxthis leaves rows columns table sorted fact isa fundamental property method reader check true rigorous proof trickier exercise turns property preserved operation split eachline half interleave halves compare exchanges itemsnow vertically adjacent lines mp xa xwe doubled number rows halved number columns stillkept rows columns sorted step completes merge chapter aabaabeeeeeeggggiimllmmmnnrpprxxat  rows  column sorted method obviouslyextends merge files equal lengths powers sizescan handled adding dummy keys straightforward manner number dummy keys large larger power of2 basic ﬁsplit half interleave halvesﬂ operation inthe description easy visualize paper translatedinto wiring machine surprising elegant answer thisquestion directly writing tables differentway writing dimensional fashion write simple dimensional list numbers organized column major order elements column elements column compare exchanges onlydone vertically adjacent items stage involvesa group compare exchange boxes wired ﬁsplit interleaveﬂ operation bring items thecompare exchange boxes leads diagram corresponds precisely thedescription tables tables written column major order including initial   table file reader check correspondence diagramand tables compare exchange boxes drawn explicitly explicit lines drawn showing elements ﬁsplit interleaveﬂ operation algorithm machines463aeggimnrabeelmpxilla it3 xaxaxaxbaeeeggimlmnrp xabeeeggilmmnprxaasurprisingly representation ﬁsplit interleaveﬂ operation duces precisely interconnection pattern pattern called perfect shufle wires interleaved waythat cards halves interleaved ideal mix deckof cards method named odd merge batcher whoinvented  essential feature method thecompare exchange operations stage parallel demonstrates files elements merged ognparallel steps number rows table halved step usingless log compare exchange boxes description thismight straightforward result problem finding sucha machine stumped researchers time batcher developed closely difficult understand merging algorithm bitonic merge leads simpler machine chaf ter this method terms ﬁsplit interleaveﬂ operationon tables file reverse sorted order compare exchanges vertically adjacentitems lines proof thismethod works removes annoying feature odd merge compare exchange boxes stage shifted position stages diagram stage bitonic merge number comparators positions aeggimnrxpmleebaaeggimnrxpmleebaaxepgmgliemenbraaxepgmgliemenbraaxepgmgleiembnaraxepgmgleiembnari3abegimxneaegmlprabegimxneaegmlprabeglmnxae eglmprabeglmnxae eglmpri aabeeeggilmmnprxaabeeeggilmmnprxnow regularity interconnections positions ofthe compare exchange boxes compare exchange boxes thanfor odd merge problem numberof parallel steps involved method leadsdirectly merge compare exchange boxes algorithm machines465idea simply collapse rows table pair rows produce cycling machine wired such machine log compare exchange shuffle ﬁcycles ﬂ eachof stages figure note carefully ﬁidealﬂ parallel performance sincewe merge files elements processor numberof steps proportional hope constant number steps processors case proven achieve ideal machine achieves parallel performance merging compare exchange boxes perfect shuffle interconnection pattern variety ofother problems n n square matrix row majororder perfect shuffles transpose matrix convert column major order examples include fast fourier transform examine chapter sorting developed byapplying methods recursively polynomial evaluation host problems solved cycling perfect shuffle machine interconnections diagramed complicated processors researchers suggested perfect shuffle interconnection ﬁgeneral purposeﬂ parallel computers chapter systolic arraysone problem perfect shuffle wires interconnectionare long wire crossings shuffle wiresinvolves number crossings proportional properties turnout create difficulties perfect shuffle machine constructed long wires lead time delays crossings interconnection expen sive inconvenient natural avoid problems insist processorsbe connected processors physically adjacent weoperate processors synchronously step processor reads inputs neighbors computation writes outputs neighbors turns restrictive fact kung  arrays processors termed systolic arrays data flows reminiscent heartbeat allowvery efficient processors fundamental problems typical application systolic arrays formatrix vector multiplication matrixoperation  computation carried row simple processors ofwhich input lines output lines depicted processors presenting inputs readingthe outputs carefully timed manner step processor reads input left fromthe performs simple computation writesone output left output rightoutput left input left output resultcomputed multiplying left inputs adding rightinput crucial characteristic processors perform adynamic transformation inputs outputs ﬁrememberﬂ computed values true processors perfect shuffle machine ground rule imposed low level constraints algoritha4 machtnes467hardware design addition ﬁmemoryﬂ capability expensive paragraph ﬁprogramﬂ systolic machine tocomplete description computation exactlyhow input values presented timing essential feature thesystolic machine marked contrast perfect shuffle machine whereall input values presented time output values time general plan bring matrix inputs theprocessors reflected main diagonal rotated degrees vector left input processor passed theother processors intermediate passed left thearray output eventually appearing left output processora specific timing table whichgives values left inputs processor eachstep abcde abcdeabcd1                         the input vector presented left input processor steps    passed processors subsequent steps inputmatrix presented inputs processors starting steps  skewed tcfleft diagonals matrix presented successivesteps output vector appears left output processor steps6   table appears input imaginaryprocessor left collecting answer actual computation traced inputs leftoutputs left array computationsproduce result step  processor  left inputand  input computes result  passed chapter as processor input step  step  processor zerovalues inputs computes  passedon processor step  processor computes  forprocessor step  step  processor computes value8 presented output step  computes value6 step  computes nonaero  byd step  computation output completed bat step  passed output step  computation ofthe output completed step  passed anda output step  process checked detailed level previousparagraph method understood higher level thenumbers middle table simply copy input matrix rotated reflected required presentation inputsof processors check numbers positions atthe left table copies input vector located positions times multiplication rows matrix positions intermediate multiplication input vector matrix row multiplication input vector middle matrix row requires partial computations           entries    reflected middlerow hand table systolic machine manages timethings matrix element ﬁmeetsﬂ proper input vector entry andthe proper partial computation processor input itcan incorporated partial result method extends obvious manner multiply matrixby vector n  processors n  steps comeclose ideal situation processor perform work atevery step quadratic algorithm reduced linear algorithm alinear number processors systolic arrays oncesimple powerful output vector edge appears ifby magic individual processor performing simplecomputation magic interconnection thetimed presentation inputs generalmethod parallel computation details logical design tobe worked systolic machine constructed perfect shuffle machines systolic arrays manydifferent types problems including string matching matrix multiplica tion researchers suggested algoritmm h4achiajes469interconnection pattern ﬁgeneral purposeﬂ parallel machines study perfect shuffle systolic machines illustratesthat hardware design algorithm design ing provide interesting algorithms fresh challengesfor algorithm designer interesting fruitful area forfurther conclude sobering notes greatdeal engineering effort required translate general schemes parallelcomputation sketched actual algorithm machines withgood performance applications resource expenditure requiredis simply justified simple ﬁalgorithm machineﬂ consisting ventional inexpensive microprocessor running conventional algorithm willdo instances problemto solve microprocessors solve idealparallel performance achieved microprocessor aconventional algorithm working instance problem withno interconnection required files sort proces sors sort simply processor foreach sort processors labor sorts techniques discussed chapter justified onlyfor applications special time space requirements studyingvarious parallel computation schemes effects performance ofvarious algorithms forward development general purposeparallel computers provide improved performance wide varietyof algorithms exercises1          outline ways parallelism quicksort write conventional pascal program merges files batcher sbitonic method write conventional pascal program merges files batcher sbitonic method shuffles program previous exercise advantage ventional merging perfect shuffles bring elements array size2 original positions draw table text illustrate operation ofthe systolic matrix vector multiplier problem write conventional pascal program simulates operation ofthe systolic array multiplying matrix vector systolic array transpose matrix processors steps required systolicmachine multiply matrix vector simple parallel scheme matrix vector multiplication proces sors capability ﬁrememberﬂ computed values  fast fourier transformqone arithmetic algorithms fast fouriertransform applications provide stantial reduction time required multiply polynomials thefourier transform fundamental mathematical analysis subject volumes study emergence efficient algorithm computation milestone history computing scope book outline mathematicalbasis fourier transform survey applications pur pose learn characteristics fundamental algorithm context algorithms studying ticular examine algorithm polynomial multiplication problem studied chapter  elementary facts complex analysis needed fourier transform multiply polynomials fast fourier transform algorithm fully understanding underlying mathematics divide conquer technique applied impor tant algorithms evaluate multiply interpolatethe general strategy improved method polynomial multiplicationthat examining takes advantage fact polynomial degreen  completely determined points wemultiply polynomials degree  polynomial ofdegree n  polynomial n  points itis completely determined result pointsimply evaluating polynomials multiplied point multiplying numbers leads general scheme multiplying polynomials degree   chapter evaluate input polynomials n  distinct points multiply values point interpolate unique result polynomial valueat points compute   evaluate points      values                  multiplying term term values productpolynomial         coefficients interpolation lagrange formula x lx r       x x lx         x           x       sl  x      fl   simplifies resultr  x2 x4 method good algorithm polynomial multi plication algorithms evaluation repeatedapplication horner method interpolation lagrange formula requiren2 operations hope finding algorithm method works choice n  distinct points whatsoever reasonable expect evaluation interpolation easierfor sets points fast fourier transform473complex roots unityit turns convenient points polynomial interpolationand evaluation complex numbers fact set complex numbers called complex roots unity review facts complex analysis thenumber imaginary number meaningless asa real number convenient perform algebraicmanipulations replacing  appears complexnumber consists parts real imaginary written reals multiply complex numbers apply usual rules replace  appears real imaginary cancel complex multi plication performed  i  ﬂ    scaling equation dividing  thatin general complex numbers evaluate  raisedto power called complex roots unity fact turns complex numbers zn  named wn called principal nth root unity othersare raising wn kth power     forexample list eighth roots unity root  wj principal root forn root wei2   precise values roots unimportant moment beusing simple properties easily derived basic factthat nth power nth root unity  cxapter evaluation roots unitythe crux implementation procedure evaluating poly nomial degree  nth roots unity proceduretransforms coefficients define polynomial valuesresulting evaluating polynomial nth roots unity step ofthe polynomial multiplication procedure evaluate polynomials ofdegree  n  points problem viewa polynomial degree  polynomial degree n  coefficients terms largest degree  algorithm evaluate polynomial degree at points simultaneously based simple divide conquerstrategy dividing polynomials middle themultiplication algorithm chapter  divide parts byputting alternate terms division easily expressed terms polynomials half number coefficients forn  rearrangement terms p1a pzx2 p3x3 p4x4 p5x5 psx6 p7x7     p3x2 p5x4 p7x6 xp nth roots unity convenient decomposition yousquare root unity root unity fact istrue square nth root unity nth root ofunity number evaluates  raised nth power thisis needed divide conquer method work toevaluate polynomial coefficients points split polynomials coefficients polynomials evaluatedon points nth roots unity compute values needed thefull evaluation evaluation degree  polynomialp eighth roots unityw  sequencew squaring term sequence copies sequence w4 ofthe fourth roots unity fast fourlex trahbform475now equationtells evaluate eighth roots unity fromthese sequences evaluate fourth roots unity substitute eighth roots unity equationabove requires adding product theappropriate eighth root unity     ﬁ pm3   pew2  pebi     pob4in general evaluate nth roots unity recursively evaluatep nth roots unity perform multiplicationsas works assume thatn power remains recursion therecursion stops  pix evaluated   number multiplications satisfies ﬁfundamental divide conquerﬂ recurrencem m  solution lg substantial improvementover straightforward method interpolation worksonly roots unity method transforming polynomial representationas coefficients conventional manner representation terms ofits values roots unity conversion polynomial representation fourier transform efficient recursive calculation procedure called ﬁfastﬂ fourier transform fft techniques apply generalfunctions polynomials precisely ﬁdiscreteﬂ fouriertransform chapter interpolation roots unitynow fast evaluate polynomials specific set points fast interpolate polynomials points fast polynomial multiplication method surprisingly works complex roots unity running evaluation program set points interpolation specific instanceof fundamental ﬁinversionﬂ property fourier transform whichmany mathematical derived  interpolation problem thepolynomialr tlx r3x3 r4x4 r5x5 qx6 r7x7which valuesr wk wg sg  tﬂ    interpolation problem ﬁinverseﬂ evalua tion problem points consideration complex roots ofunity literally true letthen coefficientsjust evaluating polynomial inverses complex roots ofunityw wi1     w8   yw8which sequence complex roots unity differentorder w18 routine interpolation asfor evaluation simple rearrangement points evaluated isrequired proof fact requires elementary manipulations finitesums unfamiliar manipulations skip endof paragraph evaluating inverse tth nth root unity fast fourler transform477givess wg wj wf joq nnearly disappears term sum triviallyn evaluates tocw _ j _ nwn nnote extra scaling factor arises ﬁinversion theoremﬂfor discrete fourier transform method convert polynomial ways representation coefficients representation values complex roots unity mathematics complicated arequite easy apply interpolate polynomial nth roots unity procedure evaluation interpolation values polynomial coefficients rearrange scale answers implementationnow pieces divide conquer algorithm multiplytwo polynomials lg operations general scheme isto evaluate input polynomials n  roots unity multiply values point interpolate result evaluating polynomial defined bythe numbers computed n  roots unity description directly translated program aprocedure evaluate polynomial degree  nth rootsof unity arithmetic algorithm complexarithmetic pascal built type complex chapter to user defined type complex numbers necessaryto define procedures functions arithmetic operations onthe numbers obscures algorithm unnecessarily followingimplementation assumes type complex obvious arithmeticfunctions defined eval outn  eval outn  outndo eval outn  dobegin outn  outn outn outn program assumes global variable outn set n  arrays indexed  n  hold complexnumbers polynomials multiplied degree  coefficients arrays initially set  procedureeval replaces coefficients polynomial argument bythe values polynomial evaluated roots unity argument specifies degree polynomial thenumber coefficients roots unity argument describedbelow code computes product leaves resultin left implementation eval recursive programs involving arrays cumbersome implement itturns algorithm usual storage management problem reusing storage clever recursive procedure takes input contiguous array  coefficients returns  values array recursive step involves processing noncontiguous arrays odd andeven coefficients reflection reader ﬁperfect shuffleﬂof previous chapter needed odd coefficients contiguous subarray half coefficientsin contiguous subarray half ﬁperfect unshuffleﬂ ofthe input diagramed  fast fourler transform479po p4 p5 p6 p7  plo pi1 p12 p13 p14 p15this leads implementation fft procedure eval var poly integer var integer thenbegint plelsebeginfori oto ndiv dobeginj  pb ndiv  eval div  eval div  div  outn div nfl fori oto ndiv dobegint div  ndiv   tend endend program transforms polynomial degree inplace subarrayp recursive method outlined simplicity thecode assumes power dependence hardto remove  easy computation evaluate   chapter performed procedure shuffles recursively calls itselfto transform halves combines computations actual values complex roots unity needed implementation thatthese values easily computed conventional trigonometric functions program array assumed hold outn roots ofunity roots unity needed program selects arrayat interval determined variable outhj  fourth roots unity    thiseliminates recompute roots unity time mentioned outset scope applicability fft fargreater algorithm intensivelyused studied variety domains fundamentalprinciples operation advanced applications thepolynomial multiplication problem discussed fft classic application ﬁdivide conquerﬂ algorithmdesign paradigm achieve computational savings fast fourler transform481exercises1 explain improve simple evaluate multiply interpolatealgorithm multiplying polynomials withknown roots     qn   set real numbers polynomial degree beevaluated fewer operations  set real numbers polynomial degree beinterpolated fewer operations   worthwhile multiply sparse polynomials fft  fft implementation calls eval polynomialmultiplication procedure chapter  calls mult thefft implementation efficient  multiply complex numbers fewer thanfour integer multiplication operations  storage fft circumvent theﬁstorage management problemﬂ perfect shuffle  technique perfect shuffle avoid theproblems dynamically declared arrays polynomial multiplica tion procedure chapter   write efficient program multiply polynomial degree apolynomial degree powers  dynamic programmingthe principle divide conquer guided design ofthe algorithms studied solve large problem break intosmaller problems solved independently dynamic programmingthis principle carried extreme whichsmaller problems solve simply solve store answersaway solving larger problems principal difficulties application technique combine solutions problemsto form solution larger unacceptably large number small problems solve precisely characterized problems effectively solved dynamic programming ﬁhardﬂ problems applicable chapters   ﬁeasyﬂ problems isless efficient standard algorithms class ofproblems dynamic programming effective examples problems involve ﬁbestﬂ general property decision involved finding small subproblem remains good decision subproblem included piece larger problem knapsack problemsuppose thief robbing safe finds items varying size valuethat steal small knapsack capacity hecan carry goods knapsack problem combinationof items thief choose knapsack order maximize total suppose knapsack capacity  safe items sizes values  chapter name esize34789value4     single letter names items integerindices programs knowledge complicated names translated integers standard searching techniques thenthe thief total  couldfill knapsack total  trymany combinations commercial applications solutionto knapsack problem shipping pany load truck cargo plane items shipment applications variants problem limited number kind item variants handled approach examine solving basic problem stated dynamic programming solution knapsack problem calcu late combination knapsack sizes turns wecan perform calculation efficiently things appropriateorder program dobeginfor doif sizeb thenif cost cost sizeb valij thenbegincost cost sizeb valb jend program cost highest achieved aknapsack capacity item achievethat maximum recover contents knapsack asdescribed calculate knapsacksizes items type calculate solution reduces simplecalculation cost suppose item chosen knapsack thebest achieved total va1b item dynamic programming485plus cost sizeb rest knapsack exceedsthe achieved item update cost leave simple induction proof showsthat strategy solves problem table traces computation firstpair lines contents cost andbest arrays pair lines bedone      aaaaaaaaaaaaaaa0045589101213       abbabbabbabbabb00455810101214       abbacbaccaccacc00455810111214       abbacdaccaccdcc00455810111314       abbacdecceccdecthus highest achieved knapsack size   order compute result solved smaller subproblems highest achieved knapsack size16  actual contents optimal knapsack computed theaid array definition included remainingcontents optimal knapsack size size size included l7 type item size  type itemat size  obvious inspection code running time thisalgorithm proportional nm fine large unacceptable large capacities crucialpoint overlooked method work ifm sizes values real numbers integers minor annoyance fundamental difficulty goodsolution problem chapter  chapter people good solution exists difficulty theproblem reader solving case values areall  size jth item  capacities sizes values integers fun damental principle optimal decisions bechanged pack knapsacks size thefirst items reexamine problems whatthe items time general principle work dynamic programming applicable algorithm small previousoptimal decisions saved dynamic programming applica tions requirements regard examplesbelow matrix chain productsuppose matricesare multiplied multiplications valid number columns matrix number rowsin total number scalar multiplications involved dependson order matrices multiplied couldproceed left multiplying   matrix afterusing  scalar multiplications multiplying result  matrix  scalar multiplications multiplying result givesa   matrix  scalar multiplications continuing   result grand total  scalar multiplications proceed left   result  scalar multiplications orders order multiplication beexpressed parenthesization left wright order describedabove ordering left order legal parenthesization lead correct answer leads fewest scalar multiplications substantial savings achieved large matrices involved matrices havea dimension  dimension  left order require  scalar multiplications left order dmvamlc prograhdming487astronomical   calculations assuming standardmethod matrix multiplication strassen methodcould save work large matrices considerations aboutthe order multiplications apply multiplying matrix bya matrix produce pby matrix entry computed qmultiplications total pqr multiplications general suppose matrices multiplied matrices satisfy constraint mi rows columnsfor   task order multiplying matricesthat minimizes total number multiplications tryingall orderings impractical number orderings studied combinatorial function called catalan number number ofways parenthesize variables n nm certainlyworthwhile expend effort good solution generallyquite small compared number multiplications dynamic programming solution problem involvesworking ﬁbottom ﬂsaving computed answers small partial problems toavoid recomputation multiply mz mzby record costs calculate bestway multiply successive triples computed multiply mlmzms costof computing mi mz table saved add cost ofmultiplying result total compared cost firstmultiplying mzm3 multiplying computed thesame smaller saved procedure forall triples calculate multiply successive groups gained continuing eventually multiply matrices general     minimum cost computingmimi jfor    finding cost ofcomputing mimi mk  mkmk ﬂ mi adding costof multiplying break group twosmaller groups minimum costs groups looked table recomputed maintain array entries cost  minimum cost computing mlml thenthe cost group cost cost chapter group cost cost final multiplication easily determined mk  rz rk matrix mkmk mi rk lmatrix cost multiplying rirkri wayto compute cost    increasing   reach  minimum cost ofcomputing mze desired leads program dofor cost maxint cost dofor dofor  dobegint cost cost cost thenbegin cost track decisions separate arraybest recovery actual sequence multiplications begenerated table derived straightforward cost andbest arrays sample problem ea24142226ab cdb61014bc cdc610cd cdd4deef36cd22cd19cd10ef12effor entry row column  scalar multiplica tions required multiply matrices dynamic progr ammlng489be achieved multiplying optimal multiply ing optimal multiplying matrices array optimal splits indicatedby pairs letters table clarity multiply throughc optimal row column followingprogram implements process extracting optimal parenthesizationfrom cost arrays computed program procedure order integer beginif write elsebeginwrite order  write order write endend parenthesization computed mentioned requires  scalar multiplications cited earlier dimensions  changed  parenthesization optimal requiring  scalar multiplications triple loop dynamic programming code leads running timeproportional n3 space required proportional substantiallymore knapsack problem palatablecompared alternative n possibilities optimal binary search treesin applications searching search keys occurwith varying frequency program checks thespelling english text ﬁandﬂ ﬁtheﬂfar ﬁdynamicﬂ ﬁprogramming ﬂ pascal compiler keywords ﬁendﬂ ﬁdoﬂ moreoften ﬁlabelﬂ ﬁdownto ﬂ binary tree searching clearlyadvantageous frequently sought keys tree dynamic programming algorithm determine arrangethe keys tree total cost searching minimized node binary search tree keys islabeled integer assumed proportional frequencyof access chapter that  searches tree expect   tobe   searches requires nodeaccesses  searches requires  node accesses compute measure ﬁcostﬂ tree simply multiplyingthe frequency node distance root summing isthe weighted internal path length tree tree theweighted internal path length              binary search tree keys givenfrequencies smallest internal path length trees problem problem minimizing weighted externalpath length studying huffman encoding huffmanencoding maintain order keys binarysearch tree preserve property nodes left theroot keys requirement problem verysimilar matrix chain multiplication problem treated virtuallythe program assume set search keys k1 kz kn frequencies anticipatedfrequency reference key ki binary search tree thatminimizes sum keys frequencies times distance ofthe key root cost accessing node proceed matrix chain problem compute foreach increasing   build subtree containingk  ki    computation eachnode root precomputed values determine todo subtrees optimaltree ki ki kk root tree formedby optimal tree ki kk left subtree theoptimal tree kk kk k2 as subtree internal pathlength tree sum internal path lengths subtrees dynmc programming491plus sum frequencies nodes node stepfurther root tree leads program dofor cost maxint ndo cost cost dofor dobeginfor dobegint cost cost cost thenbegin cost cost cost note sum frequencies cost notneeded minimum cost  tocover possibility node son analogto matrix chain problem short recursive program required recover actual treefrom array computed program optimal tree computed isd3aﬂy b2c es2f73g weighted internal path length  chapter as algorithm requires time proportional n3 workswith matrix size spends time proportional entry case reduce time requirement bytaking advantage fact optimal position root treecan optimal position root smaller tree range values theprogram shortest pathsin cases dynamic programming formulation method solvea problem produces familiar algorithm warshall algorithm chapter  finding transitive closure directed graph directly dynamic programming formulation general pairs shortest paths problem graphwith vertices   determine shortest distance vertexto vertex problem calls v2 numbers output adjacency matrixrepresentation graph chapters  and32 assume input array edge weights witha edge vertex vertex weight represent undirected graph itrepresents directed graph task directed path minimumweight connecting pair vertices solve problem tosimply shortest path algorithm chapter  vertex atotal running time proportional tov3 simpler algorithm thesame performance derived dynamic programming approach dynamic programming algorithm problem directlyfrom description warshall algorithm chapter  compute    shortest path vertex vertex whichuses vertices   shortest path vertex vertexj vertices   shortest path vertex ito vertex vertices    path composed theshortest path vertex vertex vertices   and shortest path vertex vertex vertices from1   leads program dynamlc programmlng493for vdofor  vdoif maxint div  thenfor vdoif jl jl maxint div  sentinel matrix positions correspondingto edges graph eliminates test explicitlyin loop edge ﬁsmallﬂsentinel overflow virtually program compute transitiveclosure directed graph logical operations replaced arithmeticoperations table adjacency matrix afterthis algorithm directed graph chapter  edgeweights set  abcdefghijklma011 b cl0d0 e10f10g1101h101i10j0111k0l10 m10abcdefghijklma01232112  cl2043223444d021e102f210g2312130122 h342324101233314534352103444j45343520111k0l3423241230 m45343523410thus shortest path length  note thisalgorithm weight edge vertex  nonzero entries  bits exactlythe bit matrix produced transitive closure algorithm chapter  dynamic programming standpoint note formation saved small subproblems amountof output space wasted chapter one advantage algorithm shortest paths algorithm ofchapter  works properly negative edge weights allowed long cycles negative weight graph case shortest paths connecting nodes cycle defined cycleof negative weight graph algorithm detect thatfact case negative pointduring algorithm time space requirementsthe examples demonstrate dynamic programming applications canhave time space requirements depending ofinformation small subproblems saved shortestpaths algorithm extra space required knapsack problem space proportional size knapsack needed problems space needed problem time required afactor greater space required range applicability dynamic programming largerthan covered examples dynamic programming point view divide conquer recursion thought special case whicha minimal small cases computed stored exhaustive search examine chapter  thought special case maximal small cases computed stored dynamic programming natural design technique appears guises solve problems range dynamic programming495exercises1 knapsack problem items sorted bysize algorithm work properly arbitrary order  modify knapsack program account constraintdefined array num  number items ofeach type  knapsack program values negative  true false matrix chain involves multiplication optimal solution multiplication defend answer  write program multiplies matrices timal assume matrices stored dimensional ray matrices nmax  dmax  dmax dmax maximumdimension ith matrix stored matrices  draw optimal binary search tree text withall frequencies increased   write program text constructing theoptimal binary search tree  suppose computed optimum binary search tree someset keys frequencies frequency incremented  write program compute optimum tree  solve knapsack problem matrix chainand optimum binary search tree problems minimizing to sum achievable knapsack size achievable knapsack size  extend program shortest paths problem include procedurepaths integer array path shortest path fromi procedure time proportional length thepath time called auxiliary data structure built bya modified version program text   linear programmingmany practical problems involve complicated interactions anumber varying quantities network flowproblem discussed chapter  flows pipes networkmust obey physical laws complicated network scheduling tasks manufacturing process face deadlines priorities develop precise math ematical formulation captures interactions involved reduces problem hand straightforward mathematical problem thisprocess deriving set mathematical equations solution implies thesolution practical problem called mathematical programming inthis fundamental variant mathematical programming linear programming efficient algorithm solving linear programs thesimplex method linear programming simplex method fundamental impor tance wide variety problems amenable formula tion linear programs efficient solution simplex method betteralgorithms specific problems problem solvingtechniques applicable process formulating theproblem linear program computing solution simplex method linear programming extensive standing issues involved requires mathematical maturity somewhatbeyond assumed book hand basic ideas easy comprehend actual simplex algorithm difficult implement fast fourier transform chapter  intent provide practical implementation learn basic properties algorithm relationship algorithms studied  chapter linear programsmathematical programs involve set variables set mathe matical equations called constraints objective function involving thevariables maximized subject constraints ofthe equations involved simply linear combinations variables wehave special case called linear programming theﬁprogrammingﬂ solve problem involves choosingthe variables setting equations solution equationscorresponds solution problem art pursue examples ﬁprogrammingﬂ interested involves writing pascal programs solutionsto mathematical equations linear program corresponds network flow problemthat considered chapter  maximize xab xadsubject constraints2 xcd xad xcf  xbc xebi xde sxef sxab xeb xbc xad xcd xde xef xeb xde xcf xbc eb  variable linear program flow ineach pipes variables satisfy types equations inequalities capacity constraints pipes equalities correspond ing flow constraints junction inequalityxab   pipe capacity  equation xab xeb xbcsays inflow equal outflow junction note adding allthe equalities implicit constraint xab xad xcf xefwhich inflow equal outflow network flows positive mathematical formulation network flow problem asolution mathematical problem solution linear programming499instance network flow problem point notthat linear programming provide algorithm problem linear programming general technique beapplied variety problems generalize thenetwork flow problem include costs capacities linear programming formulation problem difficult solve directly linear programs richly expressive exists analgorithm solving simplex algorithm proven bequite efficient problems arising practice problems network flow algorithm oriented problem perform linear programming simplex problems including extensions network flow algorithms algorithm complicated difficult implement procedure developing linear program solving simplex library routine straightforward ﬁgeneral purposeﬂ aspect method attractive led widespread danger relying heavily lead inefficient solutions simple problems studied algorithms book geometric interpretationlinear programs cast geometric setting linearprogram easy visualize variables involved maximize subject constraints  x2   x1  x1 x2     corresponds diagram ciiapter each inequality defines halfplane solution linear programmust lie   solution lie rightof  axis  solution lie andto     solution linear program satisfy constraints theregion defined intersection halfplanes shaded diagramabove set solutions solve linear program point region maximizes objective function case region defined intersecting halfplanes isconvex encountered definitions convexhull chapter  convex region called simplex forms basisfor algorithm solution linear program maximizesthe objective function fundamental property simplex exploited algo rithm objective function maximized vertices thesimplex points examined points inside dotted corresponds objective function objective function bethought defining slope case  unknownposition interested point hits simplex moved infinity point solution linear program itsatisfies inequalities simplex maximizes theobjective function points larger values encountered linear programmingour hits simplex   maximizes objectivefunction  objective functions correspond lines slopes alwaysthe maximum occur vertices simplex algorithmthat examine systematic moving vertex vertex search minimum dimensions choice aboutwhat simplex complicated objectwhen variables involved geometric representation math ematical programs involving nonlinear functions difficultto handle objective function nonlinear curve strike simplex edges vertex inequalities nonlinear complicated geometric shapes correspond simplex geometric intuition clear anomalous situations canarise suppose add inequality    linearprogram clear diagram thatin case intersection half planes linear program called infeasible points satisfy inequalities maximizes objective function hand inequality    redundant simplex contained halfplane represented simplex redundant inequalities affectthe solution dealt search solution problem simplex open unbounded region case solution defined thecase inequalities deleted simplex unbounded solution defined objective functions algorithm difficulty unbounded region emphasized problems easy tosee variables inequalities muchless apparent general problem variables inequalities detection anomalous situations thecomputational burden solving linear programs geometric intuition holds variables  dimensionsthe simplex convex  dimensional solid defined intersection ofhalfspaces defined planes equations changing theinequalities equalities add inequalities   andx3   linear program simplex solid objectdiagramed chapter    dimensional suppose change theobjective function   s defines plane perpendicular theline zl plane infinity wehit simplex point    solution inthe diagram path vertices simplex  thesolution reference description algorithm dimensions intersect halfspaces defined  dimensionalhyperplanes define dimensional simplex bring dimensional hyperplane infinity intersect simplex solutionpoint mentioned risk oversimplification concentrating onintuitive dimensional situations proofs facts aboveinvolving convexity intersecting hyperplanes involve facility withlinear algebra scope book geometricintuition valuable understand fundamental characteristics basic method practice solve higher dimensional problems linear programmingthe simplex methodsimplex commonly general approach solvinglinear programs pivoting fundamental operation ingaussian elimination turns pivoting corresponds natural geometric operation moving point point simplex search solution algorithms commonly differ essential details order simplex vertices aresearched ﬁalgorithmﬂ solving problem couldmore precisely generic method refined ways encountered sort situation gaussian elimination ford fulkerson algorithm reader surely noticed linear programs onmany forms linear program networkflow problem mixture equalities inequalities geometric examples inequalities convenient reduce number possibilities insisting linear programs presented standard form equations equalities aninequality variable stating nonnegative likea severe restriction difficult convert general linearprograms standard form linear program isthe standard form dimensional maximize x3subject constraints  y1 zl  yz  yg x1 x2 y4 x3 y5 xl y3 y4 y5   inequality involving variable converted equalityby introducing variable called slack variables theytake slack allowed inequality inequality involving onevariable converted standard nonnegative constraint simply byrenaming variable constraint  behandled replacing  appears formulation obvious parallels linear programmingand simultaneous equations equations unknown variables constrained positive case note slackvariables equation started inequalities chapter we assume implies solutions tothe equations problem maximizes objectivefunction trivial solution equations z1 xz  assign values slack variables satisfy theequalities works   point simplex thisneed case general explain simplex method restrictattention linear programs case thisis large class linear programs numberson hand inequalities standard form linear program positive slack variables positive coefficients solution original variableszero return general case solution variables set  turns canfind solution property familiar operation pivoting essentially operation gaussian elimination element chosen matrix coefficients defined equa tions pth row multiplied scalar allother rows qth column  entry row whichis  matrix represents thelinear program                                                                                              this   matrix coefficients linear programin standard form  column numbers theright hand sides equations gaussian elimination th rowcontaining coefficients objective function sign reversed significance th row discussed treat justlike rows carry computations places issues computational accuracy accumulated error arejust gaussian elimination variables correspond solution called basis variablesand set  solution called basis variables matrix columns basis variables with values  basis variables correspond columns withmore nonzero entry linear programmtng505now suppose pivot matrix   thatis multiple fourth row otherrows column   row  produces result                                                              operation removes th column basis adds st columnto basis basis column removed basis column  row definition solution linear program setting thenon basis variables trivial solution basis solution matrix s zerobecause basis variables  matrix correspondsto point    simplex interested thevalues slack variables note upper hand corner thematrix row  column  objective function atthis point design suppose perform pivot operation   f0                                                           this removes column  basis adds column  setting basisvariables  solving basis variables matrix corresponds point    simplex objectivefunction  note objective function isstrictly increasing design decide values pivoting thisis row  basis variable row  theamount objective function increase variable werechanged   sign reversed sign reversed thestandard pivoting operation maintain row  pivotingusing column amounts changing variable crapter from  positive objective function willincrease column negative entry row  pivoting row positive entry column willincrease objective function resultin matrix point simplex central concernis entries column  negative beforestalled finding positive elements column includingrow  smallest divided  stelement row row containingthis element pivot objective function willincrease entries column  negative ensure matrix corresponds point onthe simplex potential problems procedure finding thepivot row positive entries column isan inconsistent situation negative entry row  objectivefunction increased increase turns thatthis situation arises simplex unbounded algorithmcan terminate report problem subtle difficulty arises thedegenerate case  entry row positive entryin column  row chosen objective functionwill increase  problem problem arises whenthere rows natural policies choosing rows lead cycling infinite sequence pivots increase objective function possibilities avoiding cycling method break ties randomly cycling extremely mathematically impossible anti cycling policy isdescribed avoiding difficulties cycling makethe description method clear emphasized suchdegenerate cases practice generality offered byusing linear programming implies degenerate cases general problemwill solution specific problems pivot   row0 column    positive column  matrix                                                                                         lihjear programming507this corresponds point    simplex ofthe objective function  general negative entries row  severaldifferent strategies choosing suggested wehave proceeding popular methods called greatest increment method choose column smallestvalue row  largest absolute lead thelargest increase objective function scaling row chosen column selection policy combined rowselection policy case ties row result columnof lowest removed basis cycling happen anticycling policy bland possibility column selection calculate objective function increase column column largest result called steepest descent method interestingpossibility choose randomly columns finally pivot   arrive solution i0                                                           this corresponds point    simplex maximizes theobjective function  entries row  nonnegative pivotwill serve decrease objective function outlines simplex method solving linear pro grams summary matrix coefficients correspondingto point simplex series pivot steps adjacent points simplex increasing objective function maximum reached fundamental fact crucialto correct operation procedure reach point nosingle pivot improve objective function ﬁlocalﬂ maximum thenwe reached ﬁglobalﬂ maximum basis simplexalgorithm mentioned proof factswhich obvious geometric interpretation general quitebeyond scope book simplex algorithm generalcase operates essentially manner simple problem tracedabove chapter implementationthe implementation simplex method case aboveis straightforward description requisite pivoting procedure code implementation gaussian elimination chapter  procedure pivot integer var integer beginfor dofor downto  doif then4 kl kl kl     iend program adds multiples row row columnq  row chapter  isnecessary care change doneusing gaussian elimination processed rows matrixduring forward elimination rows backward substitu tion gauss jordan method linear equations nunknowns solved calling pivot ranging  thenback  simplex algorithm consists simply finding values pand calling pivot repeating process theoptimum reached simplex determined unbounded repeatq repeat repeat doif thenif pivot linear programming509if program terminates  optimal solution beenfound achieved objective function  andthe values variables recovered basis programterminates unbounded uation detected program ignores problem cycle avoidance implementbland method track column leavethe basis pivot row easily settingoutb pivot loop calculate modifiedto set equality holds ratio test outb outb alternatively selection random element implemented bygenerating random integer replacing array reference mod mod hasthe searching column starting random point sort technique choose random column negative entry row  pivot program treat simple case illustrates theprinciple simplex algorithm avoids substantial complica tions actual applications main omission program requires matrix feasible basis set rows andcolumns permuted identity matrix program startswith assumption solution variables pearing objective function set submatrixinvolving slack variables ﬁsolvedﬂ submatrix identity matrix easy type linear program stated inequalities positive variables general weneed point simplex solution wecan transformations mapping point origin tobring matrix required form outset solution exists fact detecting asolution exists difficult computationally finding optimum solution exists surprising technique commonly usedto detect existence solution simplex algorithm weadd set artificial variables   add variable theith equation simply adding columns matrix filledwith identity matrix feasible basis thisnew linear program trick algorithm objectivefunction solution original linear program objective function maximized  maximum reachedis original linear program infeasible maximumis normal situation   basis crapter variables computed feasible basis original linear program degenerate cases artificial variables remain basis pivoting remove changing cost summarize phase process solve general linearprograms solve linear program involving artificial variablesto point simplex original problem dispose ofthe variables reintroduce original objective function proceed fromthis point solution analysis running time simplex method extremelycomplicated problem ﬁbestﬂpivot selection strategy pivotsteps expect reasonable class problems constructartificial examples running time simplex large exponential function number variables algorithm practical settings unanimous testifying efficiency solving actual problems simple version simplex algorithm considered whilequite general beautiful mathematical frameworkproviding complete set tools solve variety practical problems linearprograh4mlng511exercises1          draw simplex defined inequalities        x2     sequence matrices produced text thepivot column chosen largest negative sequence matrices produced text forthe objective function x2 s simplex algorithm matrix witha column  simplex algorithm number steps rows ofthe input matrix permuted linear programming formulation previouschapter knapsack problem pivot steps required solve linear program ﬁmaximizexl subject constraints   ﬂ construct linear program consisting inequalities variablesfor simplex algorithm requires  pivots dimensional linear programming problem illustratesthe difference greatest increment steepest descent column selection methods modify implementation text write thecoordinates optimal solution point  exhaustive searchsome problems involve searching vast number potentialsolutions answer simply amenable tosolution efficient algorithms chapter examine charac teristics problems sort techniques proven tobe solving reorient thinking whatconstitutes ﬁefficientﬂ algorithm applications wehave discussed conditioned algorithm mustbe linear time proportional nlogn n3  tobe considered efficient generally considered quadratic algorithms bebad cubic algorithms awful problems chapter computer scientist absolutely delighted cubic algorithm fact n5 algorithm bepleasing theoretical standpoint problems believedto require exponential time suppose algorithm takes time proportional n ifwe computer  times faster fastest supercomputeravailable today solve problem  hour time generous assumptions simplicity algorithm hour time  year time  computer developed times speed havea computers  year stime realistically settle order   ﬁmoreefficientﬂ algorithm situation solve problemfor  realistic time money famous problem type traveling salesman problem set cities shortest route connecting no513 chapter city visited problem arises naturally number plications studied extensively chapter examine fundamental techniques advanced methods developed problem unthinkable solve instance problem  traveling salesman problem difficult noway avoid check length large number possibletours check tour exhaustive search howthat modify procedure greatly reducethe number possibilities checked discover incorrect decisions early decision making process mentioned solve large traveling salesman problem thinkable techniques nextchapter true practical problems butwhat problems practice sort answer isexpected traveling salesman simply ignore existence problem state hard solve chapter examples methods developed coping practical problems require exhaustive search chapter examine reasons efficientalgorithm problems exhaustive search graphsif traveling salesman restricted travel pairs ofcities traveling air problem directlymodeled graph weighted directed graph tofind shortest simple cycle connects nodes brings mind problem tobe easier undirected graph connect thenodes simple cycle starting node ﬁvisitﬂ allthe nodes return original node visiting node thegraph hamilton cycle problem thenext chapter computationally equivalent travelingsalesman problem strict technical sense chapters   number methods systematically visitingall nodes graph algorithms chapters waspossible arrange computation node visited leads efficient algorithms hamilton cycle problem solution apparent visit node times problems building tree ﬁdead endﬂ reached search start working exhaustive search515part tree problem tree structure cycle discover search tree built cycle rebuild illustrate issues involved hamilton cycleproblem traveling salesman problem graph fromchapter  depth search visit nodes graph order assuming adjacency matrix sorted adjacency list representation simple cycle hamilton cycle wayto visit nodes turns systematically possibilitieswith simple modification visit procedure procedure visit integer var integer beginnow val vdoif thenif val visit  va1 oend leaving node touches marked nonzeroval entry procedure ﬁcleans itselfﬂ leaves valarray marked nodes whichvisit completed correspond simple path lengthnow graph initial node visited tovisit node simply visit unmarked adjacent nodes marked wouldnot correspond simple path recursive procedure checks simple paths graph start initial node chapter the tree order paths checked theabove procedure graph node treecorresponds visit descendants node adjacentnodes unmarked time path tree node root corresponds simple path graph path checked point vertices adjacentto marked val entries visit unmarks andreturns visit unmarks returns visit fwhich path note carefully thatin depth search remain marked visited fwould visited ﬁunmarkingﬂ nodes exhaustivesearch essentially depth search reader besure understand distinction mentioned current length path val position node path visitprocedure test existence hamilton cycle havingit test edge  val exampleabove hamilton cycle appears tree traversed directions program solve travelingsalesman problem keeping track length current path theval array keeping track minimum lengths hamilton exhxjstive search517cycles backtrackingthe time exhaustive search procedure proportionalto number calls visit number nodes exhaustivesearch tree large graphs large ifthe graph complete node connected node simple cycles arrangement nodes case studied examine techniques togreatly reduce number possibilities techniques involveadding tests visit discover recursive calls forcertain nodes corresponds pruning exhaustive search tree cuttingcertain branches deleting connected pruning technique remove symmetries aboveexample manifested fact cycle traversedin directions case ensure cycle justonce insisting nodes order insist node node node inthe visit node node cis path leads drastically smaller tree technique applicable suppose tryingto minimum cost path cycle connecting vertices path connects vertices chapter it cycle technique apply knowin advance path lead cycle pruning technique cut search itis determined successful suppose thatwe minimum cost path graph cost  fruitless search path cost  implemented simply making recursive calls visit cost current partial path greater cost path foundso minimum cost path adhering sucha policy pruning effective low cost path early inthe search visit nodes adjacentto current node order increasing cost fact evenbetter compute bound cost paths beginwith partial path suppose additionalinformation edges diagram weight  couldbe determined initial scan edges weknow path starting cost  thave search path solution whichcosts  time cut search node avoid searching theentire subtree node large trees substantialsavings savings worthwhile muchas visit avoid making recursive calls bound cost path starts partial path marked nodes adding cost minimumspanning tree unmarked nodes rest path spanning treefor unmarked nodes cost lower cost ofthe minimum spanning tree nodes paths divide graph unmarked nodes connected search paths implemented returning artificially high cost spanning tree simple path starts abe drawn search tree rules areapplied problem finding hamilton path sample graphthat exhaustive search5196gagain tree drastically smaller note savingsachieved toy problem indicative situation largerproblems cutoff high tree lead savings missing obvious cutoff lead waste general procedure solving problem systematically generatingall solutions called backtracking wehave situation partial solutions problem successively aug mented ways produce complete solution recursive implemen tation program process exhaustive search tree nodes correspond thepartial solutions tree corresponds forward progresstowards creating complete solution tree correspondsto ﬁbacktrackingﬂ generated partial solution whichpoint worthwhile proceed forwards general techniqueof calculating bounds partial solutions order limit number fullsolutions examined called branch bound knapsack problem previouschapter values restricted integers forthis problem partial solutions selection items theknapsack backtracking corresponds item someother combination pruning search tree removing symmetries quiteeffective problem order objects theknapsack affect cost backtracking branch bound applicable general chapter problem solving techniques form basis pro grams play games chess checkers case partialsolution legal positioning pieces board scendant node exhaustive search tree position bethe result legal ideally program couldexhaustively search possibilities choose lead win matter opponent possibilities backtracking search typically sophisticated pruning rules ﬁinterestingﬂ positions amined exhaustive search techniques applications artificial intelligence chapter problems thosewe studying attacked techniques solvinga problem involves development sophisticated criteria whichcan limit search traveling salesman problem vegiven examples techniques equally sophisticated methods developed problems sophisticated criteria generally true runningtime backtracking algorithms remains exponential roughly nodein search tree sons average length solutionpath expect number nodes tree proportionalto backtracking rules correspond reducing number choices node worthwhile expend effortto reduction lead increase size theproblem solved algorithm runs timeproportional   ncan solve problem times large onewhich runs time proportional n digression permutation generationan interesting computational puzzle write program generates allpossible ways rearranging distinct items simple program thispermutation generation problem derived directly exhaustivesearch program complete graph visit vertices graph orders exhaustive search521procedure visit integer var integer beginnow vai writeperm vdoif vai visit val oend program derived procedure eliminating referenceto adjacency matrix edges complete graph theprocedure writeperm simply writes entries val array isdone time discovery complete pathin graph program improved skippingthe loop point val entriesare nonzero print permutations integers  weinvoke procedure visit initialized  theval array initialized  corresponds introducing dummy node tothe complete graph checking paths graph starting node0 invoked  procedure produces followingoutput rearranged columns                                                                            admittedly interpretation procedure generating paths acomplete graph barely visible direct examination procedurereveals generates permutations integers  generating permutations  position crapter  calling recursively place  generating permutations  position unthinkable program    study form basisfor backtracking program solve problem involving reordering setof elements euclidean traveling salesman problem givena set points plane shortest tour connects themall ordering points corresponds legal tour program exhaustively search solution problemsimply changing track cost tour minimumof costs tours manner thesame branch bound technique applied variousbacktracking heuristics specific euclidean problem iseasy prove optimal tour cross search cut partial paths cross search heuristics mightcorrespond ways ordering permutations techniquescan save enormous work leave enormous amountof work simple matter exact solution euclidean traveling salesman problem low  reason permutation generation thereare number procedures generating combinatorial objects cases number objects generated numerous permutations procedures larger practice procedure generate ways choosing subset ofsize set items large small number waysof roughly proportional tonk procedure usedas basis backtracking program solve knapsack problem approximation algorithmssince finding shortest tour require computation isreasonable easier tour short shortest relax restriction absolutely shortest path turns deal problems larger techniques easy tour longer afactor optimal tour method based simply finding theminimum spanning tree mentioned lower bound length tour turns provide upper boundon length tour tour produced visitingthe nodes minimum spanning tree procedure exhaustive search523process node visit visit son applying visiting procedurerecursively returning node son visited upat node tour traverses edge spanning tree itscost cost tree simple tour node bevisited times converted simple tour simply deleting occurrence node deleting occurrence node corresponds shortcut node increase cost tour simple tour cost minimum spanning tree diagram minimum spanning tree set sample points computed chapter  simple tour tour optimum intersects largerandom point set tour produced willbe close optimum analysis support thisconclusion approach develop techniques prove existing tour hope short tour plying improvements repeatedly euclidean traveling salesman problem graph distances distances chapter between points plane intersecting tour improved byremoving intersection al3 intersects situation diagramed left loss generality shorter tour formed deleting adding cb diagramed applying procedure successively tour produce tour thatis longer intersecting procedureapplied tour produced minimum spanning tree exampleabove shorter tour agoenlpkfjmbdhica fact effective approaches producing approximate solutions euclidean traveling salesman problem developed lin generalize procedure improve tours switching edges existing tour good applying procedure successively longer leads improvement initially randomtour start tour isalready close optimum lin studies bethe case approaches producing approximate solutions travel ing salesman problem indicative thetypes techniques order avoid exhaustive search thebrief descriptions justice ingenious ideas developed formulation analysis algorithms type active area computer science legitimately question traveling salesman problem andthe problems alluding require exhaustive search clever algorithm finds minimal tour easilyand minimum spanning tree chapterwe computer scientists algorithmand approximation algorithms type discussed musttherefore studied exhaustal search525exercises1           prefer algorithm requires n5 steps orone requires n steps ﬁmazeﬂ graph chapter  hamilton cycle draw tree describing operation exhaustive search procedurewhen hamilton cycle sample graph starting vertex vertex long exhaustive search hamilton cycle graphwhere nodes connected nodes answer thesame question case nodes connected threeother nodes calls visit function permutationgeneration procedure derive nonrecursive permutation generation procedure pro gram write program determines adjacencymatrices represent graph vertex names write program solve knapsack problem chapter  thesizes real numbers define cutoff rule euclidean traveling salesman problem search tree leads points oursample point set write program count number spanning trees set ngiven points plane intersecting edges solve euclidean traveling salesman problem sixteen samplepoints  np complete problemsthe algorithms studied book generally solvepractical problems consume reasonable amounts sources practical utility algorithms obvious manyproblems luxury efficient algorithms choose algorithms studied routinely solve actual practical problems pointed previous chapter problems practice admit efficient solutions worse large class problems efficient solution exist state affairs source extreme frustration pro grammers algorithm designers efficient algorithm fora wide range practical problems theoreticians reason problems difficult great dealof area led development ofmechanisms problems classified ﬁas difficult asﬂold problems technical sense work isbeyond scope book central ideas difficult learn itis faced problem appreciationfor types problems efficient algorithm fine ﬁeasyﬂ ﬁhardﬂ problems efficient algorithm chapter  followingproblem ﬁfind shortest path vertex vertex weightedgraph ﬂ longest path cycles wehave problem solution thanchecking paths fine striking problems ﬁyes noﬂ answers  chapter easy path weight  hard path weight  breadth search lead solution problem linear time algorithms problem exponential time precise ﬁcould exponential time ﬂ butthat discussion generally usefulto exponential time algorithm input ofsize takes time proportional n substance theresults discuss changed  replaced anynumber  exponential time algorithmcould guaranteed work problems size  greater wait algorithm ﬂ steps ofthe speed computer exponential growth dwarfs technological supercomputer trillion times faster abacus neithercan close solving problem requires   steps deterministic nondeterministic polynomial time algorithmsthe great disparity performance ﬁefficientﬂ algorithms typewe studying brute force ﬁexponentialﬂ algorithms check eachpossibility study interface simpleformal model model efficiency algorithm function numberof bits encode input ﬁreasonableﬂ encoding scheme theprecise definition ﬁreasonableﬂ includes common methods encodingthings computers unreasonable coding scheme unary bits represent number wouldexpect number bits represent number beproportional log interested identifying algorithmsguaranteed time proportional polynomial number ofbits input problem solved algorithm belong set problems solved deterministicalgorithms polynomial time deterministic time algorithm thing general notion coversthe programs actual computers note polynomialis definition covers standard algorithms studied sorting belongs np complete problems529example  insertion sort runs time proportional existence ofn log sorting algorithms relevant discussion thetime algorithm depends computer itturns computer affect running time onlya polynomial factor assuming reasonable limits notparticularly relevant discussion theoretical discussing based acompletely model computation general state ments making proved intent examine central ideas develop rigorous definitions theorem statements reader rest assured apparent logical flaws theinformal nature description theory ﬁunreasonableﬂ extend power computer endow itwith power nondeterminism algorithm faced choiceof options power ﬁguessﬂ purposes discussion algorithm nondeterministic machine ﬁguessingﬂ solution problem verifying thesolution correct chapter  nondeterminism usefulas tool algorithm design theoretical device helpclassify problems havenp set problems solved nondeterministicalgorithms polynomial time problem np bemany problems np problem np onlyfind polynomial time algorithm check solution guessedsolution valid ﬁyes noﬂ version longest pathproblem np problem np satisfiabilityproblem logical formula form  icl z2 x4  x4  x5 represent variables truth values true false ﬁ ﬂ represents ﬁ ﬂ represents represents satisfiabilityproblem determine exists assignment truthvalues variables formula true ﬁsatisfiesﬂ seebelow problem plays special role theory nondeterminism powerful operation surd bother imaginary tool thatmakes difficult problems trivial answer powerful determinism prove helps anyparticular problem single chapter example problem proven np evenprove exists np aquite frustrating situation practical problems belongto np solved efficiently deterministic machine butmay belong efficient algorithms forthem deterministic machine prove problem tbelong abandon search efficient solution toit absence proof lingering possibility someefficient algorithm undiscovered fact current stateof knowledge case efficient algorithmfor problem np imply efficient algorithmshave undiscovered virtually believes np siderable effort proving contrary remainsthe outstanding open problem computer science np completenessbelow list problems belong np butwhich belong easy solve anon deterministic machine considerable effort beenable efficient algorithm conventional machine prove exists problems additional propertythat convincing evidence np problems besolved polynomial time deterministic machine problemsin np np collective failure researchersto efficient algorithms problems viewed acollective failure prove np problems np complete turns large number interesting practical problemshave characteristic primary tool prove problems np complete usesthe idea polynomial reducibility algorithm solve anew problem np solve np complete problemby process transform instance np completeproblem instance problem solve problem algorithm transform solution solution np complete problem process chapter  reduced bipartite matching network flow ﬁpolynomiallyﬂ reducible transformations polynomial time theexistence polynomial time algorithm problem imply existence polynomial time algorithm np complete problem definition imply existence polynomial time algorithmsfor problems np np complete problems531the concept reduction mechanism classifyingalgorithms prove problem np np complete np complete problem polynomiallyreducible polynomial time algorithm problemcould solve np complete problem turn beused solve problems np reduction thefollowing problems traveling salesman set cities distances betweenall pairs tour cities distance hamilton cycle graph simple cycle includesall vertices suppose hamilton cycle problem np complete andwe determine traveling salesman problem alsonp complete algorithm solving traveling salesman problemcan solve hamilton cycle problem reduction instance hamilton cycle problem graph construct instance traveling salesman problem set cities distancesbetween pairs cities traveling salesman setof vertices graph distances pair cities  thereis edge vertices graph  edge algorithm traveling salesman problem tour distance equal number vertices graph tour correspond precisely hamilton cycle efficient algorithm traveling salesman problem efficient algorithm hamilton cycle problem hamilton cycle problem reduces traveling salesman problem np completeness hamilton cycle problem implies np completeness traveling salesman problem reduction hamilton cycle problem traveling salesmanproblem simple problems polynomial time reductions complicated connect problems dissimilar toreduce satisfiability problem hamilton cycle problem withoutgoing details sketch proof showthat polynomial time solution hamilton cycle problem polynomial time solution satisfiability problem bypolynomial reduction proof consists detailed method construc tion showing instance satisfiability problem booleanformula construct polynomial time instance hamilton cycleproblem graph property knowing graph ahamilton cycle tells formula satisfiable graph builtfrom small components variables traversed chxpter by simple path ways truth falsityof variables small components attached clauses complicated subgraphs traversed simple paths truth falsity clauses large step description construction pointis illustrate polynomial reduction applied dissimilarproblems polynomial time algorithm travelingsalesman problem polynomial time algorithm thehamilton cycle problem polynomial time algorithm satisfiability problem problem proven np completeprovides potential basis proving future problem np complete proof simple reduction thehamilton cycle problem traveling salesman problem complicated transformation sketched satisfiability problem hamilton cycle problem literally thousands problems proven np complete years bytransforming cook theoremreduction np completeness problem imply np pleteness case apply thefirst problem proven np complete cook in1971 cook direct proof satisfiability np complete ifthere polynomial time algorithm satisfiability problems innp solved polynomial time proof extremely complicated general method plained mathematical definition machine capable solvingany problem np developed simple model general purposecomputer turing machine read inputs perform certainoperations write outputs turing machine perform computa tion general purpose computer oftime polynomial factor additional advantage concisely mathematically endowed additional power nondeterminism turing machine solve problem np step proof feature machine includ ing instructions executed terms logical formulas satisfiability problem correspondence estab lished problem np expressed program onthe nondeterministic turing machine instance satisfiability thetranslation program logical formula solution satisfiability problem essentially corresponds simulation machine complete problemsrunning program input produces solution aninstance problem details proof scope book fortunately proof easier reduction prove np completeness np complete problemsas mentioned literally thousands diverse problems benp complete list purposes illustrating wide range problems studied list beginswith satisfiability includes traveling salesman hamilton cycle wellas longest path additional problems representative partition set integers divided setswhose sum equal integer linear programming linear program therea solution integers multiprocessor scheduling deadline set oftasks varying length performed identical processors canthe tasks arranged deadline met vertex cover graph integer set ofless vertices touches edges problems natural practical applica tions strong motivation time good algo rithms solve fact good algorithm problems surely strong evidence np ers case hand fact thatno prove problem belong pcould construed comprise body circumstantial evidence onthe np practical fact atpresent algorithms guaranteed solve np completeproblems efficiently previous chapter techniques devel oped cope situation sort solution variousproblems practice approach change problemand ﬁapproximationﬂ algorithm finds solution buta solution guaranteed close issometimes sufficient fend np completeness approach rely ﬁaverage timeﬂ performance develop algorithm finds solution cases work cases algorithm guaranteed workwell instances problem solve efficientlyvirtually instances practice approach work chapter with ﬁefficientﬂ exponential algorithms backtracking techniquesdescribed previous chapter finally large gap betweenpolynomial exponential time addressed theory whatabout algorithm runs time proportional nlﬂsn m application areas studied book touchedby np completeness np complete problems numerical applica tions sorting searching string processing geometry graphprocessing practical contribution theory np completeness mechanism discover prob lem diverse areas ﬁeasyﬂ ﬁhard ﬂ anefficient algorithm solve problem difficulty proof problem np complete development efficient algorithm stunning achievement suggests approach scores efficient algorithms examined book testimony wehave learned great deal efficient computational methods euclid theory np completeness greatdeal learn exercises1          write program longest simple path givenweighted graph algorithm solves np complete problem inan average time log np explain answer nondeterministic polynomial time algorithm solving parti tion problem polynomial time reduction traveling sales man problem graphs euclidean traveling salesman problem orvice versa significance program solve travelingsalesman problem time proportional logical formula text satisfiable ﬁalgorithm machinesﬂ parallelism tosolve np complete problem polynomial time np explainyour answer problem ﬁcompute exact nﬂ fit np classification scheme prove problem finding hamilton cycle directed graph isnp complete np completeness hamilton cycle problemfor undirected graphs suppose problems np complete thisimply polynomial time reduction ifp np sources advanced topicseach topics covered subject volumes ofreference material introductory treatment reader seeking moreinformation anticipate engaging study toindicate basic references perfect shuffle machine chapter   paperby stone covers applications place moreinformation systolic arrays chapter kung leiserson meadand conway book vlsi good reference applications implemen tation fft book rabiner gold ondynamic programming topics chapters thebook treatment linear programming chapter  based onthe excellent treatment book papadimitriou steiglitz allthe intuitive arguments backed mathematical proofs furtherinformation exhaustive search techniques books bywells reingold nievergelt deo finally reader interestedin np completeness consult survey article bylewis papadimitriou book garey johnson afull description types np completeness categorized listingof hundreds np complete problems garey johnson computers intractability guide thetheory np completeness freeman san francisco  combinatorial algorithms addison wesley reading  lewis papadimitriou ﬁthe efficiency algorithms ﬂ scientificamerican    mead conway introduction vlsi design addison wesley reading  papadimitriou steiglitz combinatorial optimization algorithmsand complexity prentice hall englewood cliffs  reingold nievergelt deo combinatorial algorithms theoryand practice prentice hall englewood cliffs  rabiner gold digital signal processing prentice hall englewoodcliffs  stone ﬁparallel processing perfect shuffle ﬂ ieee transactionson computing   february  wells elements combinatorial computing pergaman press oxford  indexabacus  abstract data structures     adapt integration adaptivequadrature  additive congruential generator randomint   add polynomials representedwith linked lists  add sparse polynomials  adjacency lists        adjacency matrix         adjacency structure jacency lists adjlist graph input adjacencylists  adjmatrix graph input jacency matrix  adleman   aho  algorithm machines  nearest neighbors  pairs shortest paths  analysis algorithms    approximation algorithms    arbitrary numbers  arithmetic   arrays  articulation points    artificial slack variables   attributes  average case   avl trees  trees    backtracking   backward substitution   substitute  balanced multiway merging  balanced trees     basis variables  batcher  bayer  bentley  biconnectivity     binary search    binarysearch  binary search trees           array representation  indirect representation    optimal   standard representation   weighted internal path length  binary trees   binomial queues  bipartite graphs   bitonic merge   bits        bland  bland method cycleavoidance simplex  borodin  parsing   boyer   boyer moore string searching   branch bound   breadth search     brown  brutesearch brute force stringsearching  delete binary search tree dele tion   bstinsert binary search tree sertion    range dimensional rangesearch   bubblesort  caesar cipher  catalan numbers  chi square test square   ciphers   caesar  vernam  vigenere  product  ciphertext  clancy  closest pair problem    closest point problems    closure   clustering  comer  compare exchange    compilers      complete binary tree  complete graphs  complex numbers   complex roots unity   computational accuracy     concatenation   connected components  connected graph  connectivity    conquer divide  constant running time  constraints  context free grammars   contextrsensitive grammars  convex hull  convex hull algorithms     indexdivide conquer  floyd eddy method   graham scan    grahamscan  hull selection   package wrapping    wrap  convex polygons  convexity  conway  cook   cook theorem satisfiability isnp complete   cooper  counting  cross edges   cryptanalysis   cryptography   cryptology    cryptosystem  cryptovariables  cubic running time  curve fitting   cycle   cycling simplex method    dags directed acyclic graphs   data fitting   data structures abstract    adjacency lists   adjacency matrix   adjacency structure  array  btree    binary search tree   deque   heap   indirect binary search tree   indirect heap   linked list      priority queue   queue   red black tree   sorted list  stack       string     tree   unordered list  database    decryption   deletion binary search trees   deletion hash tables  dense graphs         densepfs priority graph traver sal    deo  depth search              depth search forest      derivation  deterministic algorithm  dfs recursive depth search   dictionaries  diffie  digital search trees   digitalinsert  digitalsearch  dijkstra algorithm findingthe shortest path  dijkstra    directed acyclic graphs dags   directed cycle  directed graphs     directed path  directory  discrete mathematics  disk searching   distribution counting      divide conquer           divide conquer recurrence      dot product  double buffering  double hashing   double rotation  edges  downheap heaprepair  drawing lines  draw  dual voronoi diagram   dummy node duplicate keys equal keys dynamic programming    eddy   edges  backward  capacities  cross    forward  negative weight    edmonds   eliminate forward elimination  encryption   eof  equal keys         escape sequence  euclid algorithm findingthe gcd     euclidean minimum spanningtree  euclidean shortest path problem  euclidean traveling salesmanproblem   eval fast fourier transform  eval spline evaluation   exception dictionary  exhaustive graph traversal visit  exhaustive search    exponential running time      exponentiation    expression compiler  expression parser  extendible hashing    external nodes     external searching   external sorting   indexfactor compiler  factor parser  fagin   fastfind union pression balancing   fast fourier transform     eval  feasible basis   file compression   huffman encoding   length encoding   variable length encoding    union quick union  findinit fastfind initialization   finite state machine deterministic   nondeterministic   flow  floyd  ford  forecasting  forest  forsythe  forward elimination     eliminate  cnode  fourier transform   fredkin  friedman  fringe vertices   fulkerson  garey  gauss jordan method    gaussian elimination    gauss     gcd greatest common divisor euclid algorithm   general regular expression pat tern matching  match  geometric algorithms   closest pair   convex hull    elementary   grid method   inside polygon test   intersection   drawing   range searching   simple closed path   d trees   gerrymandering  gold  gosper  graham   graham scan    grahamscan grammars   graph algorithms   pairs shortest paths   biconnectivity   bipartite matching   breadth search  connected components  cycle testing  depth search   elementary   exhaustive search cycles   maximum tlow network   minimum spanning tree   priority traversal   shortest path   stable marriage   connected ponents   topological sorting   transitive closure   union   graph input adjacency lists  adjlist graph input adjacency matrix  adjmatrix graph isomorphism  graph traversal   graphs   adjacency list  adjacency matrix  bipartite   complete  connected  connectivity   dense  directed      directed acyclic   representation      sparse  traversal   undirected  weighted  greatest common divisor gcd   greatest increment method  grid method   g7ngegrid  gridrange guibas  hamilton cycle problem     hash functions  hashing    double hashing   initialization open address ing  ha initialize linear probing   hashinsert open addressing   separate chaining   head node           heaps       heap algorithms   change  construct   downheap   insert   join   pqconstruct  pqdownheap    pqinsert    pqremove   pqreplace   remove   replace  upheap  heap condition  heapsort    heapsort hellman  hoare   hoey   holt  horner rule    huffman  indexhuffman algorithm filecompression     hume  hybrid searching  increment sequence  indexed sequential access   convert teger     indirect binary search trees   indirect heaps       infeasible linear program  loop     insertion sort    insertion    inside point inside test  insiderect point inside rectangletest  integer linear programming  integration   adaptive quadrature    adapt rectangle method    intrect  romberg  simpson method    intsimp   spline quadrature  symbolic   trapezoid method    trap  internal nodes     interpolation search   interpolation polynomial  spline   intersection    manhattan geometry   circles  horizontal vertical lines    lines   rectangles  lines    intersect interval  inverse     jarvis  jensen  johnson  kahn  karp    key generation  keys binary representation  cryptology  searching  strings  knapsack problem    knuth          knuth morris pratt string search ing   kruskal   kruskal algorithm minimumspanning tree    kruskal  kung  lagrange interpolation formula   leading term   leaf  squares data fitting   lewis  ign  lin   drawing   intersection     pair   initialization buildytree  manhattan scan  linear congruential generator    random linear feedback shift registers  linear probing    linear programming    linear running time  linked lists   create add node  listadd input construction  readlist merging  listmerge output  writelist sequential search  listin sert listsearch    sorting    sort  mergesort inn  logarithm  logarithmic running time  longest path  lookahead  macsyma  malcomb  master  matching    match general regular expres sion pattern matching  mathematical algorithms   mathematical programming  matrices addition   matradd band  chain product   inverse  multiplication     multiplication vector   representation   sparse   strassen multiplication thod     transposition  tridiagonal   maxflow mincut theorem  maximum flow   maximum matching  mazes     mccreight  mead  merging       mergesort recursive    mergesort  mergesort recursive    sort  multiway   polyphase  microprocessors   minimum cut  minimum spanning trees        indexmischarsearch boyer moorestring searching  mod       moler  moore   morris   morrison  multidimensional range search ing   multiplication large integers  mult matrices     polynomials divide quer   mult polynomials fast fouriertransform   multiprocessor scheduling  multiway merging   multiway radix searching   munro  log running time  convert integer toname    nearest neighbor problem  network flow        networks   nievergelt    node transformations   basis variables  nondeterminism    nonterminal symbol  np  np complete problems    numerical analysis  objective function  odd merge   dimensional range search bstrange  branching  open addressing   operations   optimal binary search trees     ordered hashing   package wrapping     papadimitriou   parallel computation   parse tree  parser generator  parsing      recursive descent   shift reduce    partition  partitioning   partition   pascal     path compression  paths graphs   patricia    patriciainsert  patriciasearch  pattern matching     perfect shuffle        permutation generation   pippenger   pivoting   pivot plaintext  planarity  point  polygon  convex  simple closed   standard representation  test point inside   voronoi  polynomials   addition   evaluation        interpolation       multiplication         representation   polyphase merging  pop   pqchange change priority inpriority queue  pqconstruct heap construction indirect    pqdownheap heaprepair indirect    pqinsert  pqreznove remove largest itemfrom priority queue     pratt   preprocessing  prim   prim algorithm minimumspanning tree    print binary search tree treeprint  priority graph traversal priority search breadth search   densepfs  depth search   euclidean shortest path  minimum spanning tree    network flow   shortest path   sparsepfs   priority queues         probe  projection  pruning   pseudo angle calculation theta  public key cryptosystems    push  pushdown stack    quadrature integration queue   quicksort            rabin  rabin karp string searching rksearch   rabiner  radixexchange radix exchangesort  radix searching   digital search trees   multiway   patricia   indextries     radix sorting     radix exchange   straight radix   random integer fixed range randomint   random number generation    random numbers    additive congruential generator    linear congruential generator    pseudo  quasi  uniform  range searching grid method    trees   multidimensional   dimensional   projection  sequential search  d trees   rbtreeinsert red black tree inser tion  readlist linked list input andconstruction   readln  records database  searching   sorting   records database  records searching  recursion                removal            two dimensional     red black trees   reduction    regular expression  regular expression patternmatching    reingold  remove delete largest element inheap  replacement selection   replace replace largest elementin heap  representation binary search trees     finite state machines    functions  graphs   lines  matrices   points  polygons   polynomials   trees father link         rivest    rksearch rabin karp stringsearching  root node   roots unity   rotation   length encoding   rsa public key cryptosystem   test points thesame  satisfiability    scan conversion   scan intersection manhat tan  scheduling  searching   binary search   binary tree search   digital search trees   disk searching   elementary methods   extendible hashing   external searching   hashing   indexed dequential access   patricia   radix search   radix searching   sequential  sequential list  varying length keys  sedgewick   selection   select selection nonrecursive  select selection recursive  selection sort  selection   organizing search  seminumerical algorithms  sentinel          separate chaining    sequential searching    sets   shamir   shamos   shellsort shellsort    shortest path       simple closed path   simplex method   simultaneous equations     single rotation   sink  slack artificial variables  sort merge  sort3 sorting elements    sorting   bubble  disk     distribution counting   elementary methods   external  heapsort   insertion   internal  linear   mergesort recursive   mergesort recursive   quicksort   radix exchange   relationship convex hull  selection   shellsort   stability     straight radix   tape   elements sort3  source  spanning trees    sparse graphs        indexsparsepfs priority graph traver sal       spline interpolation   makespline  eval spline quadrature  splitting      stable marriage problem    stack    standard form linear pro grams  standish  steepest descent method  steiglitz   stone  straightradix straight radixsort   strassen method      string processing   string searching   boyer moore  brute force  knuth morris pratt   mismatched character   multiple searches  rabin karp   strings     strong    connected components   substitute backward substitu tion  supercomputer    symbol tables  systolic arrays   tail node       tarjan     terminal symbol  term compiler  term parser  theta pseudo angle calculation    thompson   node     trees   compiler expression term factor   parsing   expression term factor   topological sorting    transitive closure    traveling salesman problem      tree vertices  treeinitialize binary search treeinitialization  treeinsert binary search tree sertion  treeprint binary search treesorted output    trees avl  balanced   binary   binary search  breadth search  depth search      exhaustive search   father link representation     ooc404   parse  red black   spanning                union   treesearch binary tree search       d dimensional trees   twodinsert insertion dtrees  twodrange range searching with2d trees   node    trees     tree  ullman   undirected graphs  union  union  union algorithms   analysis  fastfind   halving  height balancing  path compression  quick union  splitting  weight balancing  unseen vertices   edges   upheap insert heap insertion atbottom  van leeuwan  variable length encoding   vernam cipher  vertex cover  vertex visit adjacency lists visit  vertex visit adjacency matrix visit  vertices  fringe  tree  unseen  large scale integrated cir cuits  vigenere cipher  virtual memory   visited vertices  visit vertex visit graph search ing adjacency lists  vertex visit graph search ing adjacency matrix  graph search test biconnec tivity  graph traversal strongcomponents  exhaustive graph traversal  permutation generation  von neumann  von neumann model computa tion  voronoi diagram   voronoi dual  warshall  warshall algorithm computingtransitive closure    wegner  index551weight balancing  weighted graphs     weighted internal path length  weighted matching  wells  wirth  worst case  wrap convex hull packagewrapping  writelist linked list output   writeln                    designscoverpage  backinsertion sort color represents key ith column fromright left result ith insertion prime numbers mark positions thegreatest common divisor  random points mark position generated bya linear congruential random number generator heap horizontal coordinate position heap vertical coordinateis binary search tree laid manner tree huffman algorithm initial thetext file chapter  intersecting pair set random horizontal verticallines depth search grid graph node adjacent itsimmediate neighbors adjacency lists random order counting  cyclic rotations random permutation color represents key ith column left result exchanging ith item onehaving random greater heap design inspired movie ﬁsorting sorting ﬂ baecker uni versity toronto pictures printed tom freeman programs text