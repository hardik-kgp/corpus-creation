1  started classes types objects building data structures algorithms requires communicate detailed instructions computer excelle perform communication high level computer language chapter overview programming language assuming reader familiar existing high level langua book provide complete description language major aspects language directly relevant data structure design included threads sockets reader interested learning notes chap ter program prints universe screen dissected form figure   figure   universe program  main actors program objects objects store data provide methods accessing modifying ta object instance class defines type object kinds operations performs critical members class classes class definitions defer discussing concept ł data objects stored instance variables called fields object class store data class instance variables objects instan variables base types integers floating point numbe booleans refer objects classes ł operations data expr essing messages objects respond called methods consist constructors procedures functions define behavior objects class classes declared short object specific combin ation data methods process communicate data classes define types objects objects referred instances defining class class type definition class code fragment   code fragment   counter class simple counter accessed incremented decremented  notice class finition delimited braces ends set statements braces define program block universe class counter ass public class create counter object counter instance variableš integer called count variable initialized  constructor method counter called create counter object method class belongs class accessor method getcount returns current counter finally class update methodsša method incrementcount increments counter method decrementc ount decrements counter admittedly pretty boring class syntax structure class class main method ass class method variable called identifier string characters long letter consists letters numbers underscore characters letter number written language defined unicode character set list exceptions general rule identifiers table   table   listing reserved names method variable names reserved abstract  interface switch boolean extends long synchronized break false native byte final throw case finally null throws catch float package transient char  private true class goto protected const public void continue implements return volatile default import short instanceof static double int super class modifiers  class modifiers optional keywords precede class keyword examples public keyword general class modifiers meaning ł abstract class modifier describes ass abstract methods abstract methods declared abstract keyword block defining body code method class abstract methods instan variables properly called interface   abstract class mixture abstract methods actual methods scuss abstract classes   ł final class modifier describes cla subclasses discuss concept chapter ł public class modifier describes clas instantiated extended package imports class explained   public classes declared separate file called classname classname class ł public class modifier class considered friendly instantiated classes package default class modifier    base types types objects determined class sake efficiency simplicity base types called primitive types objects boolean boolean true false char  bit unicode character byte  bit signed complement integer short  bit signed complement integer  int  bit signed complement integer long  bit signed complement integer float  bit floating point number ieee   double  bit floating point number ieee   variable declared types simply stores type reference object inte ger constants   type int case type long floating point constants    e5 type double case type float simple class code fragment   defines number base types local variables main method code fragment   base class showing base types  comments note comments examples comments annotations provided huma readers processed compiler kinds commen block comments inline comments define text compiler block comment close note comment comments special format program called javadoc read comments automatically generate documentation programs discuss syntax interpretation javadoc comments    addition block comments inline comments ignores comments book colored blue confused executable code block comment  inline comment output base class output execution base class main method figure   figure   output base class refe objects base type variables context objects stance variables fields inside object counter class code fragment   single instance variable type int nice feature base types base type instance variables initial object created ze false null character depending type    objects object created defined class operator operator creates object class returns reference object order create object type follow operator constructor type object constructor included class definition including default constructor arguments parentheses figure   number dissected operator simply create objects assign ference objects variable figure   operator  calling operator class type events occur ł object dynamically allocated memory instance variables initialized standard default values default values null object variables  base types boolean variables false default ł constructor object called parameters constructor fills meaningful values instance vari ables performs additional computations create object ł constructor returns operator returns reference memory address wly created object expression form assignment statement address stored object variable object variable refers newly created object number objects store numbers objects base type numbers objects obstacle defines wrapper class numeric base type classes number classes table   numeric base ypes number class examples numbe objects created accessed   creation operation performed automatically time pass base number method expecting object likewise  access method performed automatically time assign numb object base number type table   number classes class base type expressions creating accessing objects row assume variable declared class base type class creation access byte byte byte byte  bytevalue short short short short  shortvalue int integer integer  intvalue long long long l  longvalue float float float  f floatvalue double double double   doublevalue string objects string sequence characters alphabet set characters character string referenced string equal number characters character ndex  alphabet define strings unicode international character set  bit character encoding covers writte languages programming languages tend smaller ascii character set proper subset unicode alphabet based  bit encoding addition defines special built class objects called string objects string hogs dogs length  web case character  aracter  alternately string cgtaatagttaatccg length  scientific applicat ion dna sequencing alphabet concatenation string processing involves dealing strings primary operation combining strings called concatenation takes string string combines string denoted consists characters characters operation  works acting tw strings legal write assignment statement strings kilo meters statement defines variable references objects string class assigns string kilometers discuss assignment statements expressions chapter object assumed built method tostring returns string obj ect description string class sufficient discuss string class relative stringbuffer class   object references mentioned creating object involves operator allocate object memory space object construc tor initialize space location address space typically assigned reference variable reference variab viewed pointer object variable holder remote control control newly created object device variable pointing object things access data illustrate concept figure   figure   illustrating relationship objects object reference variables assign object reference memory address reference variable storing object remote control variable  dot operator object reference variable refer object null case points remote control analogy null reference remote control holder pty initially assign object variable point null fact references object reference specific object methods object situation correspond remote contro work device remotes change device changing channel television note remote control change device single object pointed remotes likewise object reference variable change state object state references behavior fact references point object primary object refe rence variable access members class object instance class object reference variable accessing methods instance variables object access performed dot operator method object reference variable dot operator method parameters calls method object referred object reference optionally passed multiple parameters methods defined object runtime matches number parameters closely matches respective types method combined number types parameters called method signature takes  parts determine actual method perfor method examples oven cookdinner oven cookdinner food oven cookdinner food seasoning method calls referring method defined class ove belongs note signature method incl ude type method returns methods signature return types instance variables classes define instance variables called fields variables represent data objects class instance variables type base type int float double reference type remote control analogy class string interface   array   base type instance variable stores base type instance variable declared class stores reference object class continuing analogy visualizing object references remote controls instance variables device paramete read set remote control volume channel controls television remote control reference variable points object access instance variables access rules public instance variables accessible dot operator instance variable arithmetic expression likewise set instance variable writing left hand assignment operator figure   gnome refers gnome object public instance variables age statements allowed gnome professor smythe gnome age  object reference reference variable expression returns object reference figure   illustrating object reference set instance variables  object assuming allowed access variables variable modifiers cases allowed directly access instance variables object instance variable declared private class accessible met hods defined inside class instance variables devi parameters accessed directly remote control devices internal parameters read assi gned factory technician user allowed change parameters violating device warranty declare instance variable optionally define variable modifier follow variable type identifier variable additionally optionally assign initial variable assignment operator rules variable identifier variable type parameter base type indicating variable stores values type class indicating variable reference object class finally optional initial assign instance variable match variable type define gnome class definitions instance variables code fragment    scope visibility instance variables controlled variable modifiers ł public access public instance variables ł protected methods ackage subclasses access protected instance variables ł private methods class methods subclass access private instance variables ł modifiers instance variable considered friendly friendly instance variables accessed class package packages discussed   addition scope variable modifier usage modifiers ł static static keyword declare variable class ndividual instances class static variables store global class static variable maintain total nu mber gnome object created static variables exist instan class created ł final final instance variable assigned initial assigned base type constant max_height constant gnome class object variable final refer object object internal state code fragment   gnome class  note instance variables gnome variables age magical height base types vari reference instance built class string variable gnomebuddy reference object class defining declaration instance variable max_height gnome class taki advantage modifiers  define variable fixed constant constant values class ways declared static final    enum types   supports enumerated types called enums types allowed values set names declared inside class modifier enum value_name0 value_name1 value_namen1 modifier blank public protected private enum legal identifier identifiers valuenamei variables enum type values legal identifier convention capitalized enumerated type defi nition program deal dates public enum day mon tue thu fri sat sun defined enum type define variables class ja names enumerated type enum ype string expression automatically enum types built methods including method valueof returns enum lue string enum type code fragment   code fragment   enum type    methods methods conceptually functions procedures highlevel languages general chunks code called object class met hods accept parameters arguments behavior depends object belong values parameters passed method body class method definition parts signature defines parameters method body defines method method programmer send messa object method signature specifies message method body specifies object receives message declaring methods syntax defining method modifiers type type0 parameter  type n1 parameter n1 method body  pieces declaration modifiers includes kinds scope modifiers variables public protected static meanings type declarati defines return type method method valid identifier list parameters types declares local variables correspond values passed argumen method type declaration typei type parameteri identifier list parameters types empt signifies values passed method invoked parameter variables instance variables class inside body method likewise methods class called inside body method method class called invoked specific instance class change state object static method class invoking method gnome public void renamegnome string reassign instance variable gnome method modifiers instance variables method modifier restrict scope method ł public public methods ł protected methods pack age subclasses protected method ł private methods class methods subclass private method ł modifiers method friendly friendly methods called obj ects classes package modifiers preceded additional modifiers ł abstract method declared abstract code signature method semicolon method body public abstract void setheight double newheight  abstract methods abstract class discuss construct   ł final method overridden subclass ł static method class instance class static methods change state static variables class provi ded variables declared final return types method definition type method return method return keyword void return type void method called procedure called function return method return keyword type returned match return type method method inside gnome clas function public booleanismagical returnmagical return performed function method ends functions return return multiple values combine valu return compound object instance variables include values return return reference compound object additi change internal state object passed method nother returning multiple parameters method parameters defined comma separated list enclosed parentheses method parameter consists parts parameter type parameter method parameters pair parentheses parameters passed time pass parameter method copy parameter method body pass int variable method riable integer copied method change copy original pass object reference parameter method referen copied remember variables refer object changing  internal reference inside method change reference passed pass gnome reference method calls parameter method change referen point object refer object fore method reference change internal state object change object referring object constructors constructor special kind method initialize newly created objects special declare constructor special invoke constructor syntax declaring constructor modifiers type  parameter0 typen1 parametern1 constructor body syntax essentially method differences constructor class constr ucts class called fish constructor called fish addition return type constructoršits return type implicitly class constructor modifiers modifiers follow rules normal methods abstract static final constructor allowed publicfish intw string weight constructor definition invocation body constructor normal method body couple minor exceptions difference involves concept constructor chaining topic discussed    critical point difference constructor body regular method return statements allowed constructor body constructor body  intended initialize data objects class stable initial state created constructors invoked unique called operator invocation instance class automatically created constructor called initial ize instance variables perform setup tasks constructor invocation declaration fish variable fish myfish fish  wally class constructors signature distinguished type number parameters takes main method classes meant classes meant stand programs classe define stand programs special kind method cla ssšthe main method execute stand program reference class defines program issuing command windows linux unix shell aquarium case time compiled version aquarium class invokes special main method class method declared public static voidmain string args main method body arguments passed parameter args main method commandline arguments program called args variable array string objects collection indexed strings string args  args  arrays   calling program command programs called command command class main method  optional arguments defined aquarium program optional argument specifies number fish aquarium invoke ogram typing shell window aquarium  aquarium  fish case args  refer string  nice feature main method class definition class define stand program method test methods class main method effective tool bugging collections classes statement blocks local variables body method statement block sequence statements declarations performed braces method bodies statement blocks statement blocks nested inside addition statements perform action calling method object statement blocks declarations local variables variables declared inside statement body usua lly braces local variables instance variables exist statement block ecuted control flow exits block local variables inside longer referenced local variable base type int float double reference instance class single statements declarations terminated semicolon ways declaring local variables type type initial_value declaration simply defines identifier type declaration defines identifier type initializes variable examples local variable declarations double point point   point point    int  double     expressions variables constants expressions define values modify variables ction discuss expressions work expressions involve literals variables operators discussed variables focus literals discuss operators    literals literal constant assignment expression kinds literals ł null object reference object literal defined general object class ł boolean true false ł integer default integer lik   type int  bit integer long integer literal l l defines  bit integer ł floating point default floating numbers     double literal float floating point literals exponential notation allowed  e2 e10 base assumed  ł character character constant assumed unicode alphabet typically character defined individual symbol enclosed single quotes character constants addition defines special character constants newline tab backspace return  formfeed backslash single quote double quote ł string lieral string literal sequence characters enclosed double quotes string literal dogs climb trees    operators expressions involve composing liter als variables operators survey operators assignment operator standard assignment operator assign instance variable local variab syntax variable expression variable refers variable allowed referenced statement block expressi assignment operation expression assigned declared type int correct assignment statement  works operators evaluated left arithmetic operators binary arit hmetic operators addition subtraction multiplication division  modulo operator operator modulo remainder operator remainder left integer division mod denote modulo operator define formally mod mq integer  unary minus arithm etic expression invert sign parentheses expression define order evaluation fairly intuitive operator precedence rule determine order evaluati parentheses operator overloading increment decrement operators incremen decrement operators increment decrement operators operator variable reference  subtracted variable read expression variable reference read variable incremented decremented  code fragment int  int int int int  assigns     leaves  logical operators standard comparison operators numbers  equal equal equal greater equal greater operators object references type result comparison boolean operators operate boolean values prefix conditional conditional boolean operators evaluate operand expression needed determine expression feature constructing boolean expressions test cer tain condition holds reference null test condition generated error condition prior test succeeded bitwise operators bitwise operators integers booleans bitwise complement prefix unary operator bitwise bitwise bitwise exclusive shift bits left filling zeros shift bits filling sign bit  shift bits righ filling zeros operational assignment operators standard assignment operator number assignment operators opera tional effects kinds operators form variable expression binary operator expression equivalent variable variable expression variable expression array expression evaluated code fragment     leaves    string concatenation strings composed concatenation operator code string rug carpet string dog spot string mess rug dog string answer mess cost  dollars making answer refer string carpetspot cost  dollars conve rts nonstring constants strings involved string concatenation operation  operator precedence operators preferences precedence determine order operations performed absence parentheses brings evaluation ambiguities eed deciding expression       precedence operators incidentally table   table   precedence rules operators evaluated ordering parentheses determine order evaluation operators evaluated left order excep assignment prefix operations evalua ted left subject conditional evaluation rule boolean operations operations listed highest lowest precedence exp denote atomic parenthesized expression parenthesization higher precedence operators performed lower precedence operators operator precedence type symbols  postfix ops prefix ops cast exp exp exp exp exp exp exp exp type exp  mult div   add subt  shift  comparison instanceof  equality  bitwise  bitwise xor  bitwise     conditional boolean_expression value_if_true value_if_false  assignment discussed operators listed table   notable exception conditional operator involves evaluating boolean expression depending boolean expression true false discuss instanceof operator chapter    casting autoboxing unboxing expressions casting operation change type variable essence variable type cast equivalent variable type casting numerical input output operations syntax casting expression desired type type exp type type expression exp fundamental types casting cast respect base numerical types cast respect objects discuss perform casting numerical string types discuss object casting    instance helpful cast int double order perform operations division ordinary casting casting double int lose precision double rounded cast int double worry  double d1   double   int i1 int d1 i1  int int  double d3 double d3   casting operators binary operators division depending variable types care operations perform computations values intended type integers division track fractional doubles division illustrated int i1  int  dresult double i1 double dresult   dresult i1 dresult   notice i1 cast doubles regular division real numbers performed i1 cast operator performed integer division result i1 int  javajava implicit cast assign int double result discuss implicit casting implicit casting autoboxing unboxing cases perform implicit cast type assignment variable provided loss precision int iresult  double dresult   dresult dresult   cast double  iresult loss precision compilation error iresult int iresult  fractional lost note perform implicit casts precision lost explicit cast required   kind implicit cast number objects integer float base types int float time number object expected parameter method base type passed case perform implicit cast called autoboxing convert base type number object likewise time base ty expected expression involving number reference number object changed base type operation called unboxing caveats autoboxing unboxing number reference null unbox generate error called nullpointerexception operator test equality base type values number references pointing object testi equality avoid implicit casts autoboxing unboxing finally implicit casts kind time minimize liance performance issue incidentally situation ja implicit casting allowed string concatenation time string concatenated object base type object base type automa tically converted string explicit casting object base type string allowed assignments incorrect string string   wrong string string  wrong string  wrong perform conversion string tostring method perform implicit cast concatenation operation statements correct  string   correct poor style string  good string integer tostring  good   control flow control flow high level languages review basic structure syntax control flow including method returns statements switch statements loops restricted forms jumps break continue statements    switch statements conditionals work work languages provide decision execute statement blocks based outcome decision statement syntax simple statement boolean_exp true_statement false_statement boolean_exp boolean expression true_statement false_statement single statment block statements enclosed braces note languages tested statement bool ean expression integer expression languages statement statement optional group numbe boolean tests first_boolean_exp true_statement  second_boolean_exp second_true_statement false_statement boolean expression false boolean expression tested statement arbitrary number parts correct statement snowlevel  gotoclass comehome snowlevel  gosledding havesnowballfight stayathome switch statements multiple control flow switch statement enum types indicative based variable day enum type    switch case mon  println tough break case tue println break case println half break case thu println light break case fri println talking break default println day break switch statement evaluates intege enum expression control flow jump code location labeled expression matching bel control flow jumps location labeled default explicit jump performed switch statement flow control alls cases code case ended break statement control flow jump switch statement    loops  control flow mechanis programming language looping types loops loops simplest kind loop loop loop tests condition satisfied perfor body loop time condition evaluated true syntax conditional test loop body executed boolean_exp loop_statement iterati loop tests expression boolean exp executes loop body loop_statement boolean expression evaluates true loop body statement block statements gnome ying water carrots carrot patch long watering wr ite code perform task public void watercarrots carrot current garden findnextcarrot watercan isempty water current watercan current garden findnextcarrot recall operator loops kind loop thefor loop simplest form loops provide repeated code based integer functionality loop flexible usage loop split secti ons initialization condition increment body  defining loop syntax loop initialization condition increment loop_statement sections initialization condition increment initialization declare variable exist scope loop loop indexes counter counter variable loop declaring int counter  condition increment loop_statement declare variable counter scope loop body condition repeat condition loop boolean expression body loop executed time condition true evaluated potential iteration condition evaluates false loop body executed program execu tes statement loop increment declare incrementing statement loop incrementing statement legal statement allowing flexibility coding syntax loop equivalent initialization condition loop_statement increment loop boolean condition loop simple loop  public void eatapples apples apples numapples apples getnumapples int  numapples eatapple apples getapple spitoutcore loop variable declared int  iteration loop tests condition numapples executes loop body true finally iteration loop statement increment loop variable testing condition incidentally   includes loop discuss    loops kind loop loop standard loopšthe loop loops tests condition performing iteration loop body loop tests condition loop body syntax loop loop_statement boolean_exp loop body statement loop_statement single statement block statements conditional boolean_exp boolean expression loop repeat loop body long condition true time evaluated prompt user input input discuss input output   condition case exiting loop user enters string case handle  input inform user quit illustrates case public void getuserinput string input input getinputstring handleinput input input length  notice exit condition written consistent rule loops exit condition true repeat construct languages    explicit control flow statements statements explicit change flow control program returning method method declared return type void flow control returns reaches ode method encounters return statement argument met hod declared return type method function exit returning function argument return statement correct illustrates returning function check specific birthday public boolean checkbday int birthdays mikes_bday return true return false  return statement statement executed function rest code reached note differen statement code executed method code method return true code written function li executed condition involving true statement explicitly interrupts flow control method explicit control flow statements conjunc tion loops switch statements break statement typical break statement simple syntax break break innermost switch statement body executed break statement flow control jump loop switch body break break statement labeled form jump outernested loop switch statement case syntax break label label identifier label loop switch statement label declaration loop kinds statements illustrate label break statement simple public static boolean haszeroentry int boolean foundflag false zerosearch int  length int  length   foundflag true break zerosearch return foundflag arrays covered   continue statement statement explicitly change flow control program continue statement syntax continue label label optional identifier label loop mentioned explicit statements likewise continue statement inside loops continue statement execution skip remaining steps loop body rrent iteration continue loop condition satisfied   arrays common programming task ack numbered group objects video game track scores game variable task prefer single group numbe refer high scores group medical info rmation track patients assigned beds hospital introduce  variables program hospital  beds cases save programming effort array numbered collection riables type variable cell array uniquely refers stored cell cells  array numbered    illustrate array high scores video game figure   figure   illustration array int high scores video game organization interesting computations thod adds numbers array integers adds numbers integer array public static int sum int int total  int  length note length variable total return total takes advantage nice feature number cells arra stores length array special kind object length stored instance variable length guess length array length array accessed array_name length array_name array cells array numbered    length  array elements capacities object stored array called element array element number   element number   element number   length array determines maximum nu mber things stored  array refer length array capacity simple array code fragment counts number times number appears array counts number times integer appears array public static int findcount int int int count  int note foreach loop check current element equals count return count bounds errors dangerous mistake tempt array number range  length minus  reference bounds bounds references exploited numerous times hackers method called buffer overflow attack compromise security computer systems written languages safety feature array indices checked bounds array bounds time environment signals error condition condition arrayindexoutofboundsexception check helps avoid number secu rity problems including buffer overflow attacks languages cope avoid bounds errors maki alway array integer  length shorthand carefully early termination feature boolean operations statement generate bounds error  length   comparison   performed comparisons succeed    declaring arrays declare initialize array element_type array_name init_val_0 init_val_1 init_val_n  element_type base type class array_name identifier initial values type array declarat ion array initialized prime numbers int primes           addition creating array defining initial values declare declare array variable initializing form declaration element_type array_name array created initialized zeros array type number type arrays objects initialized null references declared array create collection cells array syntax element_type length length positive integer denoting ngth array created typically expression appears assignment statement array left hand assignment operator statement defines array variable named assigns array  cells type double initializes double steps double  int  length    cells array indexed integer set     recall arrays start indexing  array cells array typeš double    arrays objects arrays special kinds objects fact reason operator create instance array array general object special syntax square brackets refer members arra general object array object array reference ace memory array stored special dot operator instance variable length refer length array length case reference pointer underlying array object fact arrays objects implication array names assignment statem ents write program refer array write   setting number   illustrate crucial point figure   figure   illustration assignment array objects result setting   setting  cloning array wanted crea exact copy array assign array array variable write clone copies cells array assigns point array fact clone method built method object exact copy obj ect case write   copied array cell  assigned   remain unchanged illustrate point figure   figure   illustration cloning array objects result setting   setting clone stress cells array copied clone cells base type int values copied cells object references references copied  ways reference object expl ore consequences fact exercise     simple input output rich set classes methods performing input output program classes ja graphical user interface design complete pop windows pull menus methods display input text numbers methods dealing graphical objects images sounds web mouse events clicks mouse overs dragging input output methods stand programs applets details methods work constructing sophisticated graphical user interfaces scope book sake completeness simp input output simple input output occurs console window depending environment window special pop window displaying inputting text window issue commands operating ndows referred shell windows dos windows terminal windows simple output methods built static object called performs output standard output device operating shells users redirect standard output files input programs default output console window object instance printstream class class defines methods buffered output stream meaning characters temporary location called buffer emptied console window ready print characters printstream class methods performing simple output base_type refer base types print object print object tostring method print string print string print base_type print base type println string print string newline character  output code fragment print values print   print print  println double char int executed fragment output console window values    double char int simple input util scanner class special object performing output console window special object called performing input console window technically input coming standard input device default computer keyboard echoing characters console object object asso ciated standard input device simple reading input ith object create scanner object expression scanner scanner class number convenient included methods read input stream exampl program scanner object process input import import util scanner public class inputexample public static void main string args throws ioexception scanner scanner print enter height centimeters  float height nextfloat print enter weight kilograms float weight nextfloat float bmi weight height height  println body mass bmi executed program produ console enter height centimeters  enter weight kilograms   body mass   util scanner methods scanner class reads input ream divides tokens contiguous strings characters separated delimiters special separating characters default delimite whitespace tokens separated strings spaces tabs wlines default tokens read strings scanner object convert token base type token syntax scanner class includes methods dealing tokens hasnext return true token input stream return token string input stream generate error tokens left hasnexttype return true token input stream interprete correspon ding base type type type boolean byte double float int long short nexttype return token stream returned base type type generate error tokens left token interpreted base type type  additionally scanner objects process input ignoring delimiters patterns lines methods processing input include hasnextline returns true input stream text nextline advances input current returns input skipped findinline string attempts string matching regular expression pattern current pattern returned scanner advances character match pattern scanner returns null advance methods scanner input scanner print enter integer input hasnextint input nextline print integer enter integer int input nextint   program simple exam ple program illustrates constructs defined consists classes creditcard defines credit card objects test tests functionality creditcard class credit card objects defined creditcard class simplified versions aditional credit cards identifying numbers identifying informati owners issuing bank current lance credit limit charge late payments restrict charge card balance spending limit creditcard class  creditcard class code fragment   note creditcard class defines instance variable private class simple constructor initializes instance variables defines accessor methods provide access current values instance variables ould alternatively defined instance variables public accessor methods moot disadvantage direct approach users modify object instance variables directly cases prefer restrict modification instance variables special update methods include update methods chargeit makepayment code fragment   addition convenient include action methods define specific actions object behavior dem onstrate defined action method printcard method static method wh ich included code fragment   test class test creditcard class test class note array wallet creditcard objects iteration charges payments complete code test class code fragment   simplicity sake test class fancy graphical output simply sends output console output code fragment   note difference utilize nonstatic chargeit payment methods static printcard method code fragment   creditcard class  code fragment   test class  code fragment   output test class    nested classes packages language takes general approach organization classes programs stand public class defined separate file file class extension class public class smartboard defined file smartboard ways lows multiple classes organized meaningful ways nested classes class definitions inside nested inside definitions classes construct exploit times book implementation data ructures main nested classes define class strongl affiliated class  text editor class define cursor class defining cursor class nested class inside definiti text editor class highly classes file access nonpublic methods technical point nested classes nested class declared static declaration implies nested class outer class instance outer class specific object packages set classes defined common subdirectory package file package starts package package_name subdirectory package named package define package single ile seve ral class definitions compiled classes compiled separate files subdirectory classes defi ned packages prefixing class names dots aracter correspond packages directory structures public boolean temperature ta measures thermometer thermometer int temperature function temperature takes class thermometer parameter thermometer defined ta package subpackage called measures dots ta measures thermometer correspond directly directory structure ta package extra typing needed refer class current package tiring import keyword include external classes entire packages current file import individual class specific package type file import packagename classnames type  package project import ta measures thermometer import ta measures scale project package importing classes named ta measures thermometer ta measures scale time environment search classes match identifiers classes methods instance variab program import entire packag syntax import packagename package student import ta measures public boolean temperature thermometer thermometer int temperature case packages classes reference package class suppose package gnomes package cooking class named mushroom provide import statement packages class gnomes mushroom shroom gnomes mushroom purple cooking mushroom topping cooking mushroom package previous variable type mushroom compiler ambiguous class error sum structure progr instance variables methods inside class classes inside package   writing program  process writing program involves fundamental steps  design  coding  testing debugging discuss steps    design design step step process writing program desi gn step decide divide workings program classes decide ese classes interact data store actions perform main challenges programmers face ciding classes define work program general prescr iptions hard general rules thumb apply determining define classes ł responsibilities divide work actors responsibility responsibilities action verbs actors form classes program ł independence define work class independent classes subdivide responsibilities classes class autonomy aspect program data instance variables class jurisdic tion actions require access data ł behaviors consequences action performed class understood classes interact define behaviors class carefully precisely ese behaviors define methods class performs set beha viors class referred protocol expect behaviors class hold cohesive unit defining classes instance variables methods determines design program good ogrammer naturally develop greater skill performing tasks time experience teaches notice patterns requirements program match patterns    pseudo code  programmers asked gorithms intended human eyes prior writing actual code descriptions called pseudo code pseudo code computer program structured usual prose pseudo code mixture natu ral language high level programming constructs main ideas generic implementation data structure algorithm real ly precise definition ofthe pseudo code language reliance natural language time achieve clarity pseudo code mixes natural language standard programming language constructs programming language constructs choose consistent modern gh level languages constructs include ł expressions standard mathematical symbols express numeric boolean expressions left arrow sign assignment operator assignment statements equivalent operator equal sign equality rela tion boolean expressions equivalent relation ł method declarations algorithm param1 am2 declares method parameters ł decision structures condition true actions false actions indentation actions included true actions false actions ł loops condition actions indentation actions included loop actions ł repeat loops repeat actions condition indentation actions included loop actions ł loops variable increment definition actions indentation actions included loop actions ł array indexing represents ith cell array cells celled array indexed   consistent ł method calls object method args object optional understood ł method returns return operation returns method called ł comments comment enclose comments braces write pseudo code mind writing human reader computer stri communicate high level ideas  low level implementation details time gloss steps forms human communicati finding balance skill refined practice    coding mentioned key steps coding object oriented program coding descriptions classes respective data methods order accelerate development skill discuss design patterns designing object oriented programs    points text patterns provide templates defining classes interactions classes programmers initial coding computer crc cards component responsibility collaborator crc cards simple cards subdivide work required program main idea tool card represent component ultimately class program write compone card left hand card writing responsibilities component hand list collaborators component components component interact perform duties design process iterates action actor cycle identify action responsibility determine actor component suited perfor action design complete assigned actions actors cards coding assuming component small set res ponsibilities collaborators assumption accident helps programs manageable alternative crc cards uml unified modeling language diagrams express organization program pseudo code algorithms uml diagrams standard visual notation express object oriented software designs computer aided tools build uml diagrams describing algorithms pseudo code hand technique utilize book decided classes program responsibilities ready actual coding computer create actual code classes program independent text editor emacs wordpad vi editor embedded integrated development environment ide eclipse borland jbuilder completed coding class package compile file working code invoking compiler ide compile program calling program javac file  ide compile program clicking compilation button fortunate program syntax errors compilation process create files class extension program syntax errors identified editor offending lines code eliminated syntax errors created compiled code program invoking command ide clicking button ide program time environment locates directories named class classes ferenced class special operating environment variable variable named classpath ordering directories search list directories separated colons unix linux semicolons dos windows classpath assignment dos windows operating set classpath program files classpath assignment unix linux operating setenv classpath usr local lib usr netscape classes cases dot refers current directory time environment invoked javadoc order encourage good block comments automatic production documentation progra mming environment documentation production program called javadoc program takes collection source files commented keywords called tags produces series html documents classes methods variables constants containe files space reasons javadocstyle comments programs included book include javadoc code fragment   examples web site accompanies book javadoc comment block comment starts ends gin single asterisk block comment assumed start descriptive sentence blank special lines javadoc tags block comment class definition instance  variable declaration method defin ition processed javadoc comment class variable method code fragment   class definition javadoc style comments note class includes instance variables constructor accessor methods  primary javadoc tags ł author text identifies author class  ł exception exception description identifies error condition signaled method   ł param parameter description identifies parameter accepted method ł return description describes return type range values method tags intere sted reader referred documentation javadoc discussion readability style programs easy read understand good programmers mindful thei coding style develop style communicates aspects program design humans computers written good coding style main principles ł meaningful names identifiers choose names read aloud choose names reflect action responsibility data identifier naming tradition circles capitalize letter word identifier word identifier variable method tradition vector devicemanager identify classes isfull insertitem studentname studentheight identify methods variables ł named constants enum type literals readability robustness modifiability enhanced include series definitions named constant values class finition class refer special values class tradition fully capitalize constants public class student public static final int mincredits  min credits term public static final int maxcredits  max credits term public static final int freshman  code freshman  public static final int sophomore  code sophomore public static final int junior  code junior public static final int senior  code senior instance variables constructors method definitions ł indent statement blocks typically programmers indent statement block  spaces book typically  spaces avoid code overrun book margins ł organize class order  constants  instance variables  constructors  methods note programmers pref instance variable definitions earlier read class sequentially understand data method working ł comments add meaning program explain ambiguous confusing constructs comments good quick explanations sentences block comments good explaining purpose method complex code sections    testing debugging testing process experimentally checking correctn ess program debugging process tracking execution program discovering errors testing debugging time consuming activity development program testing  careful testing plan essential writing program verifying correctness progra inputs infeasible aim executing program repr esentative subset inputs minimum method program tested method coverage code statement program executed statement coverage programs tend fail special cases input cases carefully identified tested testing method sorts puts order array integers inputs ł array length elements ł array element ł elements array ł array sorted ł array reverse sorted addition special inputs program special conditions structures program array store data su boundary cases inserting removing subarray holding data properly handled essential hand crafted test suites advantageous program large collection randomly generated inputs random class util package methods generate random numbers hierarchy classes methods program induced caller callee relationship method method hierarchy calls main testing strategies differ order methods tested testing proceeds lower evel methods higher level methods level methods invoke methods tested methods level methods strategy ensures errors method caused lower level methods nested testing proceeds method hierarchy typically conjunction stubbing boot strapping technique replaces lower level method stub replacement method simulates output original method method calls  method file testing replace stub returns fixed string debugging simplest debugging techni consists print statements method println string track values variables execution program problem ith approach print statements eventually removed commented software finally released approach program debugger specialized environment controlling monitori execution program basic functionality provided debugger insertion breakpoints code program executed ithin debugger stops breakpoint program stopped current variables inspected addition fixed breakpoints advanced debuggers specification conditional breakpoints triggered expression satisfied standard tools include basic debugger called jdb commandline oriented ides programming provide advanced debugging environments graphical user interfaces   exercises source code exercises visit datastructures net reinforcement   suppose create array gameentry objects integer scores field clone store result array set  score equal  score gameentry object referenced     modify creditcard class code fragment   charge payment   modify creditcard class code fragment   charge late fee payment   modify creditcard class code fragment   include modifier methods user modi internal variables creditcard class controlled manner   modify declaration loop test class code fragment   charges eventually credit cards credit limit credit card   write short function inputallbasetypes inputs base type standard input device prints standard output device   write class flower instance variables type string int float represent flower number pedals price cla include constructor method initializes variable class include methods setting ype type   write short function ismultiple takes long values returns true multiple mi integer   write short function isodd takes int returns true odd function multiplication modulus division operators    write short function takes integer returns sum integers smaller   write short function takes integer returns sum odd integers smaller creativity   write short function takes array int values determines pair numbers array product odd   write method takes array int values determines numbers othe distinct   write method takes array ontaining set integers range   shuffles random order method output order equal probability   write short program outputs strings formed characters   write short program takes lines input standard input writes standard output reverse der output correct order ordering lines reversed   write short program takes arrays length storing int values returns dot product returns array length   projects    common punishment school children write sentence multiple times write stand program write sentence times spam friends program number senten ces random typos   graphical user interface methods define graphicaltest class tests functionality creditcard class code fragment   text fields buttons   birthday paradox probability people room birthday half long number people room  proper ty paradox people surprising design program test paradox series experiments randomly genera ted birthdays test paradox      chapter notes detailed programming language refer reader fine books including books arnold gosling  cam pione walrath  cornell horstmann  flanagan  horstmann  sun web site sun  chapter  object oriented design contents   goals principles patterns     object oriented design goals      object oriented design principles     design patterns    inheritance polymorphism     inheritance     polymorphism     inheritance    exceptions     throwing exceptions     catching exceptions     interfaces abstract classes     implementing interfaces     multiple inheritance interfaces     abstract classes strong typing    casting generics     casting     generics    exercises   datastructures net   goals principles patterns implies main actors object oriented design paradigm called objects object class specification data fields called instance variables object methods operations object execute class presents concise consistent view objects instances class unnecessary givi access workings objects view computing intended fulfill goals incorporate design principles discuss chapter    object oriented design goals software implementations achieve robustness adaptability reusability figure   figure   goals object oriented design robustness good programmer develop ftware correct program produces output anticipated inputs program application additi software robust capable handling unexpected inputs explicitly defined application program expec ting positive integer representing price item inst ead negative integer program recover gracefully error importantly life critical applications software error lead injury loss life software robust deadly point driven late s accidents involving therac  radiation therapy machine  severely overdosed patients   died complications radi ation overdose accidents traced software errors adaptability modern software applications browsers internet search engines typically involve large programs years software evolve time response changing conditions environment importa goal quality software achieves adaptability called evolvability concept portability ability software minimal change hardware operating platforms advantage writing software portability provided language reusability hand hand adaptability desire software reusable code usable component systems applications developing quality software expensive enterprise cost offset soft ware designed easily reusable future applications reuse care major sources software errors therac  inappropriate reuse software therac  object oriented designed hardware platform therac     object oriented design principles chief principles object oriented approach intended facilitate goals outlined figure   ł abstraction ł encapsulation ł modularity figure   principles object oriented design  abstraction notion abstraction distill complicated fundamental parts parts simple precise language typically describing parts involves naming explaining functionality applying abstraction paradigm design data structures rise abstract data types adts adt mathematical model data structure specifies type data stored operations supported types pa rameters operations adt specifies operation adt expressed interface simply list method declarations method body interfaces   adt realized concrete data structure modeled class class defines data stored operations supported objects instances class interfaces classes operations performed body method class implement interface methods include methods declared interface providing body class methods interface encapsulation principle object oriented design concept encapsulation states mponents software reveal internal details respective implementations main advantages encapsulation programmer freedom implementing details constraint programmer maintain abstract interface outsiders  modularity addition abstraction encapsulation fundame ntal principle object oriented design modularity modern software systems typically consist components teract correctly order entire work properly keeping teractions straight requires components organized object oriented design code structuring approach centers concept modularity modularity refers organizing principle code components software divided separate functional units hierarchical organization structure imposed modularity helps enable software reusability software modules written abstra solve general problems modules reused instances general problems contexts structural definition wall house house typically defined terms   inch studs spaced distance organized architect reuse wall definitions house reusing definition parts require redefinition wall mmercial building house electrical stud material natural organize structural components software package hierarchical fashion groups ract definitions level level manner specifi general traverses hierarchy common hier archies organizational chart link read ranch house building kind hierarchy eful software design groups common functionality general leve views specialized behavior extension general figure   hierarchy involving architectural buildings     design patterns advantages object oriented desi gn facilitates reusable robust adaptable software designing good code takes simply understanding object oriented methodologies requires effective object oriented design techniques computing researchers practitioners ha developed variety organizational concepts methodologies designing qua lity object oriented software concise correct reusable special levance book concept design pattern describes solution typical software design problem pattern general template solution applied situations describes main elements solution abstract specialized specific probl hand consists identifies pattern context describes scenarios pattern applied template describes pattern applied result describes analyzes pattern produces design patterns book consistently applied implementations data structures algorithms design patterns fall groupsšpatterns solving algorithm design problems patterns solving software engineering problems algorithm design patterns scuss include ł recursion   ł amortization     ł divide conquer    ł prune search decrease conquer    ł brute force    ł greedy method    ł dynamic programming    likewise software engineer ing design patterns discuss include ł position    ł adapter    ł iterator   ł template method sections         ł composition    ł comparator    ł decorator    explain cepts introduce text pattern algorithm engineering software engineering explain general illustrate concrete   inheritance polymorphism advantage hierarchical rela tionships common software projects object oriented design approach ways reusing code    inheritance object oriented paradigm modular hierarchical organizing structure reusing code technique called inheritance technique design general classes specialized classes specialized classes reusing code general class general class base class superclass define standard instance variables methods apply multitude situations class specializes extends inherits superclass implementations general methods inherits define methods specialized subclass    class defines objects field methods suppose define classt extendss includes additional field methods ande classt theninherit instance variablex methodsa andc froms illustrate relationships classs classt aclass inheritance diagram figure   box diagram denotes class fields instance variables methods included subrectangles figure   class inheritance diagram box denotes class fields methods arrow boxes denotes inheritance relation object creation referencing object created memory allocated data fields fields initialized specific values typically associates object variable serves link object reference access object purpose fields executing methods request execution methods defined class belongs fields primary object interacts object  send message invokes methods print description convert string return data fields secondary interact access fields directly objects permission instance class integer stores instance variable integer operations accessing data including methods convert ing number types converting string digits converting strings digits number direct access instance vari details hidden dynamic dispatch program wishes invoke method object sends message denoted ing dot operator syntax    compiled version program code invocation directs time environment examine class determine class supports method execute time nvironment examines class defines method method executed define method time environment examines superclass defines method executed define hand time environment repeats search superclass search continues hierarchy classes finds method executed reaches topmost class object class method generates time error algorithm processes message specific method invoke called dynamic dispatch dynamic binding algorithm effective mechanism locati reused software powerful technique object oriented programmingš polymorphism    polymorphism literally polymorphism form context object oriented design refers ability object variable forms object oriented languages address objects reference variables reference variable define class obj ects allowed refer terms class implies refer object belonging class extends defines method defines method dynamic dispatch algorithm method invocation starts search restrictive class applies refers object class method asked case override method alternatively refers object class object execute  method asked polymorphism caller object refers instance order method execute correctly object variable polymorphic forms depending specific class objects referri kind functionality specialized class extend class inherit standard methods redefine methods account specific properties objects object oriented language provide technique polymorphism called method overloading overloading occurs single class multiple methods provided signature signature method combination type number arguments passed multiple methods class distinguished compiler provided signatu res actuality languages method ove rloading time environment determines actual method invoke specific method searching class hierarchy method gnature matching method invoked suppose class defines method extends class defines method object class receives message version method invoked parameters true polymorphism applies methods signature defined classes inheritance polymorphism method overloading support development reusable software define classes inherit standard instance variables methods define specific instance variables methods deal special aspects objects class    inheritance primary ways usi inheritance classes specialization extension specialization specialization specializing general class pa rticular subclasses subclasses typically possess relationship superclass subclass inherits methods superclass inherited method method operates correctly independent operating specialization additional work needed hand general method superclass work correctly subclass override method corr ect functionality subclass general class dog method drink method sniff specializing class bloodhound class  require override drink method dogs drink pretty require override sniff method bloodhound sensitive sense smell standard dog bloodhound class specializes thods superclass dog extension extension hand utilize inheritance reuse code written methods superclass add methods superclass exte functionality returning dog class create subclass bordercollie inherits standard methods dog class adds method herd border collies herding instinct standard dogs adding method exte nding functionality standard dog class extend class class definition explicit extends clause inheri class case class lang object property single inheritance classes types method overriding inside declaration class kinds method overriding refinement replacement replacement type overriding method completely replaces method uperclass overriding sniff method bloodhound mentioned regular methods class utilize type overriding behavior refinement type overridi method replace method superclass adds additional code superclass constructors utilize refinement type overriding scheme called constructor chaining constructor begi execution calling constructor superclass explicitly implicitly constructor superclass explicitly keyword super refer superclass super calls constructor superclass arguments explicit body constructor compiler automatically inserts constructor super exception general rule discussed summarizing constructors refinement type method overriding regular methods replacement keyword  class convenie reference current instance class keyword called reference reference pass current object parameter metho application reference field inside current object clash variable defined current block program code fragment   code fragment   sample program illustrating reference disambiguate field current object local variable program executed prints dog local variable   dog field  illustration inheritance notions bout inheritance polymorphism concrete simple examples series classes stepping printing numeric prog ressions numeric prog ression sequence numbers number depends previous numbers arithmetic progression determines number addition geometric progression determines number multiplication  case progression requires defining identifying current defining class progression code fragment   defines standard fields methods numeric progression defines long integer fields ł progression ł cur current progression methods firstvalue reset progression return nextvalue step progression return printprogression reset progression print values progression method printprogression output sense return methods firstvalue nextvalue return long integer values firstvalue nextvalue functions printprogression procedure progression class includes method progression constructor recall constructors set instance variables time object class created progression class meant general superclass specialized classes inherit constructor code included constr uctors class extends progression class code fragment   general numeric progression class   arithmetic progression class class arithprogression code fragment   class defines arithmetic progression determined adding fixed increment previous arithprogression inherits fields cur methods firstvalue printprogression progression class adds field store increment constructors setting increment finally overrides nextvalue method conform arithmetic progression polymorphism work progression reference pointing arith progression object arithprogression methods firstvalue nextvalue polymorphism true inside inherited version printprogression calls firstvalue nextvalue methods implicit current object called case arith progression class constructors keyword definition arith progression class constructors default takes parameters parametric takes integer parameter increment progression default constructor calls pa rametric keyword passing  incremen parameter constructors illustrate method overloading method multiple versions inside class method class object calls types arguments passed itšits signature case overloading constructors default constructor parametric constructor  parametric constructor statement default constructor triggers exception general constructor chaining rule discussed    statement constructor calls constructor class reference superclass constructor implicitly called note superclass constructor eventually called chai explicitly implicitly arithprogression class default constructor superclass progression implicitly called statement parametric constructor arith progression discuss constructors    code fragment   class arithmetic progressions inherits general progression class code fragment   geometric progression class define class geomprogression code fragment   steps prints geometric progression determined multiplying previous fixed base base  geometric progression genera progression determine geom progression declared subclass progression class arith progression class geomprogression class inherits fields cur methods firstvalue printprogression progression code fragment   class geometric progressions  fibonacci progression class define fibonacciprogression class represents kind progression fibonacci progression defined sum curre previous values class fibonacciprogression code fragment   note  parameterized constructor fibonacciprogression class provide starting progression code fragment   class fibonacci progression order visualize diff erent progression classes derived general progression class inheritance diagram figure    figure   inheritance diagram class progression subclasses complete define class testprogression code fragment   performs simple test classes class variable prog polymorphic execution main method references objects class arithprogression geomprogression fibonacciprogression turn main method testprogression class invoked time output code fragment   produced presented admittedly small simple illustration inheritance progression class subclasses tester program number hortcomings apparent problem geometric fibonacci progressions grow provision handling inevitable overflow long integers involved   geometric progression base  overflow long integer  iterations likewise th fibonacci number greater   fibonacci progression overflow long integer ter  iterations problem arbitrary starting values fibonacci progression fibonacci progression starting   dealing input errors error conditions occur running program requires echanism handling discuss topic  code fragment   program testing progression classes code fragment   output testprogression program code fragment      exceptions exceptions unexpected events occu execution program exception result error condition simply unanticipated input case object oriented language exceptions thought objects    throwing exceptions exceptions objects thrown code encounters sort unexpected condition thrown time environment encounter unexpected cond ition running object memory thrown exception caught code handles exception program terminated unexpected ly catching exceptions shortly exceptions originate piece code finds sort problem execution throws exception object convenient descriptive class exception object instance delete tenth element sequence elements code throw boundaryviolationexception action code fragment insertindex length throw boundaryviolationexception element insertindex  convenient instantiate ception object time exception thrown throw statement typically written throw exception_type param0 param1 paramn1 exception_type type exception parami form list parameters constructor exception exceptions thrown time environment counterpart arrayindexoutofboundsexception element array ninth element excep tion thrown time throws clause method declared appropria exceptions throw convention functional courteous purpose users expect compiler exceptions prepare method definition public void goshopping throws shoppinglisttoosmallexception outofmoneyexception method body exceptions thrown method prepare handle exceptional cases method benefit declaring exceptions catch exceptions method case code responsible causing circumstances leading exception illustrates exception passed public void getreadyforclass throws shoppinglisttoosmallexception outofmoneyexception  goshopping catch exceptions goshopping throw getreadyforclass pass makecookiesforta function declare throws exceptions likes listing simplified excepti ons thrown subclasses exception case ha declare method throws superclass kinds throwables defines classes exception error subclasses throwable denotes object thrown caught defines class runtimeexception subclass exception error class abnormal conditions occurring time environment running memory errors caught signal problems handled gracefully error message sudden program termination grace expect exception class root exception hierarchy specialized exceptions boundaryviolationexception defined subclassing exception runtimeexception note exceptions subclasses runtimeexception declared throws clause method throw    catching exceptions exception thrown caught program terminate method exception method passed calling method caught method exception caught analyzed dealt general methodology dealing exceptions execute fragment code throw exception throw exception exception caught flow control jump predefined catch block code dealing exception general syntax catch block  main_block_of_statements catch exception_type  variable1 block_of_statements1 catch exception_type  variable2 block_of_statements2 finally block_of_statementsn catch finally optional exception_type type exception variablei valid variable time environment performing catch block executing block statements main_block_of_statements execution generates exceptions flow control continues statement entire catch block includes optional finally finally exists executed exceptions thrown caught case exception thrown execution progresses catch block jumps finally continues statement catch block hand block main_block_of_statements generates exception execution catch block terminates point execution jumps catch block exception_type closely matches exception thrown variable catch statement references exception object block matching catch statement execution catch block completes control flow passed optional finally block exists statement entire catch block finally block catch block matching exception thro wn control passed optional finally block exists exception thrown calling method code fragment int integer max_value   billion  code problem string tobuy shoppinglist catch arrayindexoutofboundsexception aioobx println array code catch thrown exception flow control exit method return code called method time environment catch block catch block code called method flow control jump code called eventually code catches exception time origin program flow control catch exception point error message stack trace printed screen program terminated actual time error message lang nullpointerexception returned null locator awt component handleevent component  awt component postevent component  awt component postevent component  sun awt motif mbuttonpeer action mbuttonpeer  lang thread thread exception caught seve ral things programmer possibility print error message terminate program interesting cases handle exception ignore catch block  ignoring exception programmer care exception legitimate handling exceptions create throw exception specifies exceptional condition precisely approach catch arrayindexoutofboundsexception aioobx throw shoppinglisttoosmallexception product shopping list handle exception problem continue execution   interfaces abstract classes order objects interact messages accept methods object supports enforce knowledge object oriented design paradigm asks classes application programming interface api simply interface objects objects adt based approach    data structures book interface defining adt type definition collection methods type arguments method types ecification turn enforced compiler time requires types parameters passed methods rigidly conform type interface requirement strong typing define interfaces definitions enforced strong typing admittedly places burden programmer burden offset rewards enforces encapsulation principle cat ches programming errors unnoticed    implementing interfaces main structural element enforces api interface interface collection method declarations data bodies methods interface simply method signatures class implements interface implement methods declared interface interfaces enforce requirements implementing class methods ith signatures suppose create inventory antiques categorized objects types properties  instance identify objects sellable case implement sellable interface code fragment   define concrete class photograph code fragment   implements sellable interface indicating sell photograph objects class defines object implements methods sellable interface required addition adds method iscolor specialized photograph objects kind object collection mi ght transport objects define interface code fragment   code fragment   interface sellable code fragment   class photograph implementing sellable interface  code fragment   interface transportable define class boxeditem code fragment   miscellaneous antiques sell pack ship class boxeditem implements methods sellable interface transportable interface adding specialized methods set insured boxed shipment set dimensions box shipment code fragment   class boxeditem  class boxeditem feature cla sses interfaces wellša class implement multiple interfacesšwhich great deal flexibility defining classes hould conform multiple apis class extend class implement interfaces    multiple inheritance interfaces  ability extending class multiple inheritance multiple inheritance allowed interfaces classes reason rule methods interface bodies methods class hus multiple inheritance classes conf usion class extend classes contained methods signatures confusion exist interfaces methods confusion involved times multip inheritance terfaces interfaces multiple inheritance multiple inheritance terfaces approximate multiple inheritance technique called mixin object oriented languages smalltalk llow multiple inheritance concrete classes interfaces languages common define classes called mixin classes intended created stand objects meant provide additional func tionality existing classes inheritance allowed programmers approximate interfaces multiple inheritance interfaces mechanism mixing methods unrelated interfaces define interface combines functionality adding methods returning antique objects define interface insurable items public interface insurableitem extends transportable sellable returns insured cents public int insuredvalue interface mixes methods transportable interface methods sellable interface adds extra method insuredvalue interface define boxeditem alternately public class boxeditem2 implements insurableitem code class boxeditem case note method insuredvalue optional optional declaration boxeditem interfaces approximate mixin include lang cloneable adds copy feature class lang comparable adds  comparability feature class imposi natural order instances util observer adds update feature class wishes notified observable objects change state    abstract classes strong typing abstract class class thod declarations declarations methods bodies concrete definitions methods instance variables abstract class lies interface complete concrete class interface abstract class instantiated object created abstract class subclass abstract class provide implementation abstract methods superclass abstract concrete class abstract class extend abstract class abstract concrete classes extend ultimately define class abstract extends subclasses abstract superclass class code abstract methods abstract class specification style inheritance specialization extension styles    lang number class turns abstract class number classes table   specialize ract class called lang number concrete number class lang integer lang double extends lang number class fills details abstract methods superclass methods intvalue floatvalue doublevalue longvalue abstract lang number concrete number class ecify details methods strong typing object viewed types primary type object class time instantiated addition type superclass type interface implemented byc variable declared ing type class interface determines vari methods method unique return type general expression unique type enforcing variables typed methods declare types expect return technique strong typing prevent bugs rigid requirements types change  convert type type conversions explicit cast operator discussed    conversions casting work base types discuss work reference variables   casting generics discuss casting reference variables technique called generics avoid explicit casting cases    casting discussion methods type conversions objects widening conversions widening conversion occurs type converted wider type common cases widening conversions ł class types superclass ł interface types superinterface ł class implements interface widening conversions automatically rformed store result expression variable explicit cast directly assign result expression type variable type conversion widening conversion code fragment expression type integer newly constructed integer object assigned variable type number integer integer  number widening conversion integer number correctness widening conversion checked compiler validity require testing time environment program execution narrowing conversions narrowing conversion occurs type converted narrower type common cases narrowing conversions  ł class types subclass ł interface types subinterface ł interface implemented class general narrowing conversion ference types requires explicit cast correctness narrowing conversion verifiable compiler validity tested time environment program execution code fragment hows cast perform narrowing conversion type number type integer number integer  widening conversion integer number integer integer narrowing conversion number integer statement object class integer created assigned variable type number widening conversion occurs assignment cast required statement assign variable type integer cast assignment refers object type integer variable type number narrowing conversion occurs cast casting exceptions cast object reference type type provided object referring type hand object type attempting cast type throw exception called classcastexception illustrate rule code fragment number integer integer  integer legal double   integer illegal  avoid problems avoid peppering code catch blocks time perform cast object cast correct operator instanceof test object variable referring object class implementing interface syntax operator object referenceinstanceof reference_type object_reference expression evaluates object reference reference_type existing class interface enum    object_reference instance reference_type expression returns true returns false avoid classcastexception thrown code fragme modifying number integer integer  instanceof integer integer legal double   instanceof integer integer attempted casting interfaces interfaces enforce objects implement methods interface variables concrete objects requires casting suppose declare person interface code fragment   note method equalto person interface parameter type person pass object class implementing person interface method code fragment   interface person  code fragment   class student implements person method equalto assumes argument declared type person type student performs narrowing conversion type person interface type student class cast conversion allowed case narrowing conversion class interface object extends implements code fragment   class student implementing interface person assumption implementation method equalto application objects class student attempt comparison student objects types objects cast method equalto fail application manages directory student objects types person objects assumption satisfied  ability performing narrowing conve rsions interface types class types write general kinds data structures minimal assumptions elements store code fragment   sketch build directory storing pairs objects implementing person interface remove method performs search directory contents removes person pair exists findother method equalto method code fragment   sketch class personpairdirectory suppose filled directory mydirectory pairs student objects represent roommate pairs order roommate student object smart_one wrong student cute_one mydirectory findother smart_one wrong statement explici cast required comp ilation error problem perform narro wing conversion explicit cast returned method findother type person variable cute_one assigned narrower type student class implementing interface person cast convert type person type student student cute_one student mydirectory findother smart_one casting type person returned method findother type student works fine long mydirectory findother student object general interfaces valuable tool design general data structures specialized programmers casting    generics  starting   includes generics framework abstract types avoids explicit casts generic type type defined compilation time fully time generics framework define class terms set formal type parameters abstract types internal variables class angle brackets enclose list formal type parameters valid identifier formal type parameter single letter uppercase names conventionally ass defined parameterized types instantiate object class actual type parameters concrete types code fragment   class pair storing key pairs types key parameters main method creates instances class string integer pair store dimension student double pair store grade student code fragment   student class code fragment    output execution method height  student a5976 sue age    previous actual type parameter arbitrary type restrict type actual parameter extends clause class personpairdirectorygeneric defined terms generic type parameter partially stating extends class person public class personpairdirectorygeneric extends person instance variables public personpairdirectorygeneric default constructor  public void insert person insert code public findother person return null stub public void remove person remove code class compared class personpairdirectory code fragment   class declare variable referring instance personpairdirectorygeneric stores pairs objects type student personpairdirectorygeneric student mystudentdirectory instance method findother returns type student statement cast correct student cute_one mystudentdirectory findother smart_one generics framework defi generic versions methods case include generic definition method modifiers definition method compare keys pair objects provided keys implement comparable interface public static extends comparable int comparepairs pair pair return getkey compareto getkey key implements compare caveat generic types elements stored array type variable parameterized type array defined parameterized type parameterized type create array fortunately array defined parameterized type initialized newly created nonparametric array mechanism cau ses compiler issue warning  type safe illustrate point  public static void main string args pair string integer pair  warning pair string integer pair string integer  wrong  pair string integer completely  set dog  statement println pair  getkey  getvalue   exercises source code exercises visit datastructures net reinforcement   interfaces extend   examples life ritical software applications   software application adaptability difference prolonged sales lifetime bankruptcy   component text editor gui edit menu methods encapsulates   draw class inheritance diagram set classes  ł class goat extends object adds instance variable tail methods milk jump ł class pig extends object adds instance variable nose methods eat wallow ł class horse extends object adds instance variables height color methods jump ł class racer extends horse adds method race ł class equestrian extends horse adds instance variable weight methods trot trained   short fragment code progression classes    th fibonacci progression starts   values   choose  calls nextvalue method arithprogression class    long integer overflow   suppose instance variable declared type progression classes    suppose refers instance class geom progression created default constructor cast type progression firstvalue returned    inherita nce classes exercise   object variable type horse refers actual object type equestrian cast class racer   code fragment performs array reference bounds bounds program catches exception prints error message buffer overflow attacks   code fragment package public class maryland extends state maryland null constructor public void printme println read public static void main string args region mid state state md maryland object obj place place usa region md printme mid printme place obj printme obj md maryland obj printme obj usa place obj printme usa md  place usa printme class state extends region state null constructor public void printme println ship class region extends place region null constructor public void printme println box class place extends object place null constructor public void printme println buy output calling main method maryland class   write short method counts number vowels character string   write short method remo ves punctuation string storing sentence operation transform string mike mike    write short program ta kes input integers console determines correct arithmetic formula order   write short program creates pair class store objects declared generic types demonstrat program creating printing pair objects kinds pairs integer string float long   generic parameters included signature method declaration methods class generic parameters names types number parameters change signatures conflicting methods restriction creativity   explain dynamic dispatch algorithm method invoke infinite loop   write class extends progression class progression absolute difference previ ous values include default constructor starts   values parametric constructor starts pair numbers values   write class extends progression class progression square root previous note longer represent integer include default constructor   parametric constructor starts double number   rewrite classes progression hierarchy values biginteger class order avoid overflows    write program consists classes extends extends class define instance variable named variable named method access set version changing version   write set classes simu late internet application party alice periodically creating set packets send bob internet process continually checking alice packets send delivers bob computer bob periodically checking computer packet alice reads deletes projects   write program inputs docume outputs bar chart plot frequencies alphabet character appears document   write program simulates handheld calculator program process input gui console forthe buttons pushed output contents screen operation performed minimally calcu lator process basic arithmetic operations reset clear operation   code personpairdirectory class code fragment   assuming person pairs stored array capacity   directory track rson pairs   write program positive integer greater  input write number times repeatedly divide number      write program ange program numbers input monetary charged monetary return number kind coin change difference charged values assigne bills coins based monetary current government design program returns fewest number bills coins chapter notes broad overview developments mputer science engineering refer reader computer science engineering handbook  therac  incident paper leveson turner  reader interested studying object oriented programming referred books booch  budd  liskov guttag  liskov guttag  provide nice discussion abstract data types survey paper cardelli wegner  book chapter demurjian  computer science engineering handbook  design patterns book gamma  class inheritance agram notation derived book gamma  chapter  arrays linked lists recursion contents   arrays     storing game entries array     sorting array     util methods arrays random numbers     simple cryptography strings character arrays      dimensional arrays positional games    singly linked lists     insertion singly linked list     removing element singly linked list    doubly linked lists     insertion middle doubly linked list     removal middle doubly linked list     implementation doubly linked list     circularly linked lists linked list sorting     circularly linked lists duck duck goose     sorting linked list    recursion     linear recursion     binary recursion     multiple recursion    exercises  datastructures net    arrays explore applications arrays introduced      storing game entries array application study storing entries arrayšin high score entries video game storing entr ies arrays common arrays easily chosen store records patients hospital names students data structures class decided store high score entries simple application presents data structuring concepts implementations book include high score entry component include integer representing score score nice feature include person earning score simply adding fields representing score earned game statistics led score simple fields score class gameentry representing game entry code fragment   code fragment   code simple gameentry class note include methods returning score game entry object method return string representation entry  class high scores suppose high scores store array named entries number scores store    symbolic maxentries represents number scores store set variable specific variable code easy change define array entries array length maxentries initially array stores nullentries users play video game entries array entries users play video game entries array references gameentry objects eventually define methods updating gameentry references entries array entries array organized simplešwe store set gameentry objects ordered integer score values highest lowest number gameentry objects maxentries entries array store null references approach prevents cells holes continuous series cells array entries store game entries  onward illustrate instance data structure figure   code data structure code fragment   exercise   explore game entry addition simplified case preserve relative orders  figure   illustration array length storing references gameentry objects cells   rest null references code fragment   class maintaining set scores gameentry objects  note include method tostring produces string representation high scores entries array method debugging purposes case string comma separated listing gameentry objects entries array produce listing simple loop adds comma entry string repr esentation print state entries array debugging testing things updates insertion common updates entries array high scores add game suppose insert gameentry object perform update operation instance scores class add insert game entry collection high scores collection score higher lowest score set case replaces entry lowest score main challenge implementing operation figuring entries array making room  visualizing game entry insertion visualize insertion process imagine store array entries remote controls representi references nonnull gameentry objects listed left ghest score lowest game entry figure belongs start search entries array reference array null score bigger score case high scorešit belong entries array belongs array thing entries array longer belongs reference array reference null points gameentry object score thane reference moved cell entries array reference repeat comparis provided reached entries array continue comparing shifting references game entries reach entries array compare score game entr higher score case identified place belongs figure   figure   preparing add gameentry object entries array order room reference shift references game entries smaller scores cell  identified place entries array game entry belongs add reference position continuing visualization object references remote controls add remote control designed location entries array figure   figure   adding reference gameentry object entries array reference inserted  shifted references gameentry objects scores  details algorithm adding game entry entries array informal scription code fragment   note loop ove references number times perform loop pends number references room reference game entry   references add method pretty fast lot method fairly slow note array perform add remove reference current game entry fail add reference game entry code fragment   code inserting gameentry object  object removal suppose hot shot plays video game high score list case method remove game entry list high scores erefore remove reference gameentry object entries array implement operation remove remove return game entry entries array bounds entries array method throws exception entries array updated remove object objects stored indices higher moved removed object implementation remove performing algorithm object addition reverse visualize entries array array remote controls pointing gameentry objects remove reference object start references indices higher cell left figure   figure   illustration removal  array storing references gameentry objects  subtle points entry removal details remove operation ntain subtle points order remove retu game entry array save temporary variable variable return removing cond subtle point moving references higher cell left arrayšwe reference reference reference reference place entries array reference entries array simply null conclude returning reference removed entry longer reference pointing entries array code fragment   code fragment   code performing remove operation  methods adding removing objec array high scores simple form basis techniques repeatedly build sophisticated data structures structures general array structure lot operations perform add remove studying concrete array data structure great starting point understanding structures data structure implemented concrete fact book study collections class arraylist general arra structure studying arraylist methods lot things array eliminating error occurs adding object array arraylist eliminates error tomatically copying objects larger array discuss process discuss arraylist    sorting array previous worked hard add remove objects array keeping evious order objects intact study starting array objects order putting der sorting problem simple insertion sort algorithm study sorting algorithms book chapter  warm ection nice simple sorting algorithm called insertionœsort case specific version algorithm input array comparab elements general kinds sorting algorithms book  simple insertionœsort algorithm goe start character array aracter sorted character array smaller swap character arra swap leftward proper order characters fourth character swap leftward proper order continue manner integer sixth array sorted mixing informal descripti programming constructs express insertion sort algorithm code fragment   code fragment   high level description insertion sort algorithm nice high level description insertion sort demonstrates algorithm called insertion sort šbecause iteration main inserts element sorted array code description work details insertion task diving details bit rewrite description nested loops outer loop element array turn loop element proper location sorted subarray characters left refining details insertion sort refining details algorithm code fragment   code fragment   intermediate level description insertion sort algorithm  description closer actual code explanation insert element subarray informal description moving elements order terribly difficult thing description insertion sort ready code simple version insertion sort algorithm description code fragment   special case array characters code fragment   code performing insertion sort array characters illustrate insertion sort algorithm figure   figure   execution insertion sort algorithm array characters  completed sorted array white color element inserted sorted array light blue highlight character left stored cur variable row corresponds iteration outer loop copy array row corresponds iteration loop comparison arc addition comparison interesting thing insert ion sort algorithm array sorted case loop comparison determines  swap needed returns outer loop perform iteration loop iteration outer loop case perform minimum number comparisons lot work input array extremely order fact work input array decreasing order    util methods arrays random numbers arrays number built methods performing common tasks arrays met hods static methods util arrays class class util arrays instance class describing methods wait book discuss concept methods based simple methods util arrays list simple methods class util arrays explanation equals returns true array array equal arrays considered qual number elements pair ements arrays equal elements order stores element cell array sort sorts array natural ordering elements tostring returns string representation array string returned method tostring called array integers               note list bui sorting algorithm insertion sort algorithm presented algorithm called quick sort runs fast insertionšsort discuss quick sort algorithm   pseudo random numbers  code fragment   short complete program methods code fragment   test program arraytest built methods arrays class program arraytest feature javašthe ability generate pseudorandomnumbers numbers statistically random random util random object pseudo random number generator object computes generates sequence numbers statistically random generator place start seed sequence numbers generated seed program set seed current time millisecond january   method currenttimemillis time program set seed repeatedly random number   calling nextint method argument  sample output program arrays equal sort true arrays equal sort false            num           slight chance num arrays remain equal num sorted num sorted cloned odds occurring    simple cryptography strings character arrays primary applications arrays representation strings characters string objects stored internally array characters strings represen ted natural relationship strings character arraysšboth indices refer characters relationship ja easy create string objects character arrays vice versa create object class string character array simply expression string constructors string class takes character array argument returns string characters order array string construct array acat likewise string create character array representation expression tochararray string class method tochararray returns array type char characters tochararray string adog array caesar cipher area switch string character array cryptography science secret messa ges applications field studies ways performing encryption takes message called plaintext converts scrambled message called ciphertext likewise cryptography studies ways performing decryption takes ciphertext turns original plaintext arguably earliest encryption scheme caesar cipher named julius caesar scheme protect military messages caesar messages written latin unreadable caesar cipher simple obscure message written language forms alphabet  caesar cipher involves replacing tter message ith letter letters alphabet language english message replace continue approach replaced substitution pattern wrap replace characters array indices number letters rray indices    write caesar cipher simple formula replace letter letter  mod  mod modulus operator returns remainder performing integer division operator denoted operator easily perform wr alphabet  mod    mod    mod   decryption algorithm caesar cipher oppositešwe replace letter places wrap capture replacement rule arrays encryption decryption character stored numberšits unicode valueš letters array indices uppercase character array unicode subtracting works uppercase letters require secret messages uppercase array encrypt represents encryption replacement rule encrypt letter replaces letter number š uppercase character unicode usage illustrated figure   likewise array decrypt represent decryption replacement rule decrypt letter replaces letter number figure   illustrating uppercase characters array indices case perform replacement rule caesar cipher encryption  code fragment   simple complete class performing caesar cipher approach conversions strings character arrays wh program perform simple test output encryption order defghijklmnopqrstuvwxyzabc decryption order xyzabcdefghijklmnopqrstuvw wkh hdjoh lv lq sodb phhw dw mrh eagle play meet joe code fragment   simple complete class caesar cipher     dimensional arrays positional games  computer games strategy mes simulation games person conflict games dimensional board programs deal positional games representing objects dimensional space natural dimensional array indices refer cells array refers row number column numb array maintain dimensional game boards perform kinds computations involving data stored rows columns arrays dimensional single access cell array define dimensional arrays javaš create dimensional array array arrays define twošdimensional array array cells array twošdimensional array called matrix declare twošdimensional array int int   statement creates mensional array arrays    rows  columns array length  element array length  integers figure   valid array int variables   length  length dimensional arrays applicati ons numerical anal ysis details applications explore application dimensional arrays implementing simple positional game figure   illustration dimensional integer array  rows  columns        tic tac toe school children tic tac toe game played board playersšx ošalternate placing respective marks cells board starting player player succeeds marks row column diagonal player wins admittedly sophisticated pos itional game fun play good player force tie tic tac toe saving grace nice simple exampl showing dimensional arrays positional games software sophisticated positional games checkers chess popular simulation games based approach illustrate dimensional array ticštacš toe exercise   basic idea dimensional array board maintain game board cells array store values cell stores board matrix middle row consists cells board   board   board   case choose cells board array intege  indicating cell  indicating  indicating encoding simple testing board configuration win values row column diagonal add   illustrate approach figure   figure   illustration tic tac toe board dimensional integer array board representing  complete class intaining tic tac toe board players code fragments     sample output figure   note code mainta ining tic tac toe boa registering moves perform strategy play tic tac toe computer program good project class artificial intelligence code fragment   simple complete class playing tic tac toe players continues code fragment     code fragment   simple complete class playing tic tac toe players continued code fragment    figure   sample output tic tac toe game   singly linked lists previous sections presented array data structure discussed applications arrays nice simple storing thi ngs order drawback adaptable size array advance ways store sequence elements drawback explore alternate implementation singly linked list linked list simplest form collection nodes form linear ordering ordering determined children game follow leader node object stores reference element reference called node figure   figure   singly linked list elements strings indicating airport codes pointers node arrows null object denoted strange node refe rence node scheme easily works reference inside node viewed link pointer node likewise moving node reference link hopping pointer hopping node linked list called head tail list link hop list starting head tail identify tail node null reference list linked list defined singly linked list  array singly linked list elements der order determined chain links node successor list array singly linked list predetermined fixed size space proportional number elements likewise track numbers nodes linked list examining node fth twentieth node list implementing singly linked list implement singly linked list define node class code fragment   specifies type objects stored nodes list assume elements character strings chapter  define nodes store arbitrary types elements node class define class slinkedlist code fragment   defining actual linked list class refe rence head node variable counting total number nodes code fragment   implementation node singly linked list code fragment   partial implementation class singly linked list     insertion singly linked list singly linked list easily insert element head list figure   code fragment   main idea create node set link refer object head set head point node figure   insertion element head singly linked list insertion creation node insertion  code fragment   inserting node singly linked list note method works list note set pointer node variable head point inserting element tail singly linked list easily insert element tail list provided reference tail node figure   case create node assign reference point null object set reference tail point object assign tail reference node details code fragment    figure   insertion tail singly linked list insertion creation node insertion note set link tail assign tail variable point node code fragment   inserting node singly linked list method works list note set pointer tail node variable tail point node    removing element singly linked list  reverse operation inserting element head linked list remove element head operation illustrated figure   code fragment   figure   removal element head singly linked list removal linking node removal code fragment   removing node singly linked list easily delete tail node singly linked list tail reference directly node list access node node order remove node cannoreach node tail links tail  access node start head list search list sequence link hopping operations long time  doubly linked lists g element tail singly linked list easy time consum ing remove node head directionsšforward reversešin linked list doubly linked list lists great node doubly linked list code fragment previous removin singly linked list quick accessing node remove applications quick access predecessor node applications nice directions linked list type linked list bothvariety quick update operations including insertion removal ends middle node doubly linked list stores referencesša linkwhich points node list prev link points previous node list implementation   assume elements character strings chapter  discuss define nodes arbitrary element types code fragment   class dnode representinga node doubly linked list stores character string  header trailer sentinels simplify programming convenient add special nodes ends doubly linked list header node head list trailer node tail list dummy sentinel nodes store elements header valid reference null prev reference trailer valid prev reference null reference doubly linked list sentinels figure   note linked list object simply store references sentinels size counter track number elements counting sentinels list figure   doubly linked list sentinels header trailer marking ends list list sentinels pointing null prev pointer  header null pointer trailer inserting removing elements doubly linked list straight forward prev links eliminate traverse list node tail removal tail doubly linked list figure   details operation code fragment   figure   removing node doubly linked list header trailer sentinels deleting tail deleting tail deletion code fragment   removing node doubly linked list variable size track current number elements list note method works list size  likewise easily perform inserti element doubly linked list figure   code fragment   figure   adding element code fragment   inserting node doubly linked list variable size track current number elements list note method works list     insertion middl doubly linked list doubly linked lists inserting removing elements head tail list convenient maintaining list elements allowing insertion removal middle list node doubly linked list header trailer easily insert node node execute steps  prev link refer  link refer  prev link refer  link refer method code fragment   illustrated figure   recalling header traile sentinels note algorithm works tail node node trailer code fragment   inserting node node doubly linked list  figure   adding node node storing jfk creating node element bwi linking insertion    removal middle doubly linked list likewise easy remove node middle doubly linked list access nodes getprev getnext methods nodes exist sentinels remove node simply point refer operation linking null prev pointers retain references list algorithm code fragment   illustrated figure   code fragment   removing node doubly linked list method works nonsentinel node  figure   removing node storing pvd removal linking node removal garbage collection    implementation doubly linked list code fragments   œ3  implementation doubly linked list nodes store character string elements code fragment   class dlist doubly linked list nodes objects class dnode code fragment   storing character strings continues code fragment    code fragment   class dlist doubly linked list continues code fragment    code fragment   doubly linked list class continued code fragment    observations class dlist ł object class dnode store string elements nodes list including header trailer sentinels ł class dlist doubly linked list string objects build linked list types objects generic declaration discuss chapter  ł methods getfirst getlast provide direct access nodes list ł methods getprev getnext traverse list ł methods hasprev hasnext detect boundaries list ł methods addfirst addlast add node list ł methods add add add node existing node  ł single removal method remove restriction remove doubly linked list executing remove getfirst remove getlast ł method tostring converting entire list string testing debugging purposes   circularly linked lists linked list sorting study applica tions extensions linked lists    circularly linked lists duck duck goose children game duck duck goose played cultures children minnesota play version called duck duck grey duck indiana game called mosh pot children czech republic ghana play sing song versions pesek antoakyire variation singly linked list called circularly linked list number applications involving circle games duck duck goose discuss type list circle game application circularly linked list kind nodes singly linked list node circularly linked list pointer reference element head tail circularly linked list node pointer null circularly linked list points node node traverse nodes circularly linked list node pointers cycle nodes circularly linked list node marked special node cursor cursor node place start traverse circularly linked list remember starti point traversal circularly linked list return node cursor node started define simple update methods circularly linked list add insert node cursor list cursor pointer points remove remove return node cursor cursor node list cursor set null  advance advance cursor node list code fragment   implementation circularly linked list node class code fragment   includes tostring method producing string representation list code fragment   circularly linked list class simple nodes   observations circlelist class observations circlelist class simple program provide unctionality simulate circle games duck duck goose robust program rcle list calling advance remove list exception exercise   deals exception generating behavior ways handling list condition duck duck goose children game duck duck goose group children sit circle elected person walks circle person pats child head duck time reaching child person identif ies goose point mad scramble goose person race circle returns goose place firs remain circle loser race person round play game continues children bored adult tells snack time point game ends figure   figure   duck duck goose game choosing goose race goose place goose person simulating game ideal application circular ly linked list children represent nodes list person identified person sitting cursor removed circle simulate marching advance cursor duck person identifies simulate random decision goose  identified remove node list random choice simulate goose person win race insert winner list advance cursor insert person repeat process time play game circularly linked list simulate duck duck goose code simulation duck duck goose code fragment   code fragment   main method program circularly linked list simulate duck duck goose children game  sample output  output duck duck goose program figure   figure   sample output duck duck goose program note iteration particul execution program produces outcome initial configurations random choices identify ducks geese likewise duck goose wins race depending random choices execution situation child person identified goose situation person walks group children identifying goose situations illustrate circularly linked list simulate circular games duck duck goose    sorting linked list  code fragment   theinsertion sort algorithm    doubly linked list implementation code fragment   code fragment   high level pseudo code description insertion sort doubly linked list code fragment   implementation insertion sort algorithm doubly linked list represented class dlist code fragments  œ3     recursion repetition achieved writing loops loops loops achieve repetition recursion occurs function calls examples methods calling methods surprise modern programming languages including method capability elegant powerful alternative performing repetitive tasks factorial function illustrate recursion simple computing factorial function factorial positive integer denoted defined product integers   defined  convention formally integer         connection methods clearer notation factorial denote  factorial function defined manner suggests recursive formulation observe factorial        factorial  define factorial  terms factorial  general positive integer define factorial factorial  leads recursive definition definition typical recursiv definitions base cases defined nonrecursively terms fixed quantities case  base case recursive cases defined appealing definition function defined observe circularity finition time function invoked argument smaller recursive implementation factorial function implementati factorial function code fragment   recursivefactorial notice looping needed repeated recursive invocations function takes place looping code fragment   recursive implementation factorial function illustrate execution recursive function definition recursion trace entry trace corresponds recursive recursive function arrow newly called function function returns arrow showing return drawn return arrow trace figure   advantage recursion recu rsive implementation factorial function simple iterative version case compelling reason prefe rring recursion iteration  problems recursive implementa tion simpler easier understand iterative implementation figure   recursion trace recursivefactorial  drawing english ruler complex recursion draw markings typical englis ruler ruler broken  inch intervals interval consists set ticks intervals   inch   inch size interval decreases half tick length decreases figure   figure   sample outputs ruler drawing function  inch ruler major tick length   inch ruler major tick length   inch ruler major tick length   multiple  inch numeric label longest tick length called major tick length worry actual distances print tick recursive approach ruler drawing approach drawing ruler consists functions main function drawruler draws entire ruler argumen total number inches ruler ninches major tick length majorlength utility function drawonetick draws single tick length optional integer label printed nonnegative interesting work recursive function drawticks draws sequence ticks interval argument tick length interval cent ral tick  inch ruler major tick length  figure   ignoring lines   draw sequence ticks ly ing lines central tick   inch length  observe patterns ticks central tick identical central tick length  general interval central tick length  composed ł interval central tick length   ł single tick length ł interval central tick length  recursive length ecreases length drops simply return result recursive process terminate suggests recursive process steps performed calling drawticks  recursively middle step performed calling function drawonetick recursive formulation code fragment   factorial code base case  instance tw recursive calls function code fragment   recursive implementation function draws ruler illustrating ruler drawing recursion trace recursive execution recursive drawticks function defined visualized recursion trace  trace drawticks complicated factorial instance recursive calls illustrate recursion trace form reminiscent outline document figure   figure   partial recursion trace drawticks  pattern calls drawticks  identical book examples recursion design data structures algorithms  illustrations recursion discussed recursion concept defining method method calls refer recursive method recursive calls method ultimately leads main benefit recursive approach algorithm design advantage repetitive structure problems making algorithm description exploit repetitiv structure recursive avoid complex case analyses nest loops approach lead readable algorithm descriptions efficient addition recursion defining objects repeated structural form examples   modern operating systems define file directories called folders recursive file consists level directory contents directory consists files directories turn files directories base directories file files recursive definition operating directories nested arbitrarily deep long space memory   syntax modern programming languages defined recursive define argument list notation argument list argument argument list argument argument list consists argument argument list comma argument argument list consists comma separated list arguments arithmetic expressions defined recursively terms primitives variables constants arithmetic expressions   examples recursion art nature classic examples recursion art russian matryoshka dolls doll solid wood hollow matryoshka doll inside    linear recursion  simplest form recursion linear recursion method defined recursive time invoked type recursion view algorithmic problem terms element remaining set structure original set summing elements array recursively suppose array integers sum solve summati problem linear recursion observing sum integers equal   sum  integers element solve summation problem recursive algorithm code fragment   code fragment   summing elements array linear recursion illustrates importan property recursive method possessšthe method terminates ensure writing nonrecursive statement case  addition perform recursive smaller parameter  point ecursion perform nonrecursive computation returning  general algorithm linear recursion typically form ł test base cases testing set base cases base ses defined chain recursive calls eventually reach base case handling base case recursion ł recur testing base cases perform single recursive recursive step involve test decides recursive calls ultimately choose calls time perform step define recursive progress base case  analyzing recursive algorithms recursion traces analyze recursive algorithm visual tool recursion trace recursion traces analyze visualize recursive fibonacci function   recursion traces recursiv sorting algorithms sections     draw recursion trace create box instance method label parameters met hod visualize recursive drawing arrow box calling method box called method illustra recursion trace linearsum algorithm code fragment   figure   label box trace parameters time recursive draw box representing recursive diagram visualize stepping algorithm proceeds    final finishes returns  adds retu rns partial sum   returns partial sum figure   recursion trace execution linearsum input parameters       figure   clear input array size algorithm linearsum calls time roughly proportional spends constant time performing  nonrecursive memory space algorithm addition array roughly proportional constant memory space boxes trace time final recursive  reversing array recursion problem reversing elements array element element solve oblem linear recursion observing reversal array achieved swapping elements recursively reversing remaining elements array details algorithm code fragment   convention time algorithm reversearray   code fragment   reversing elements array linear recursion note algorithm actua lly base cases case simply terminate algorithm sequence elements elem ent trivially equal reversal note recursive step guaranteed progress base cases odd eventually reach case eventually reach case argument implies recursive algorithm code fragment   guaranteed terminate defining problems ways facilitate recursion design recursive algorithm problem ways subdivide problem defi problems general structure original problem process redefine original problem facilitate simila subproblems reversearray algorithm parameters recursive reverse array structure syntax reverse  initially calling algorithm reversearray initially reversearray  n1 general difficulty finding repetitive structure needed design recursive gorithm work problem concrete exam ples subproblems defined tail recursion recursion tool designing algorithms elegant short definitions modest cost recursive algorithm solve problem memory locations computer track state active recursive computer memory premium cases derive nonrecursive algorithms recursive stack data structure discussed   convert recursive algorithm nonrecursive algorithm instances conversion easily efficiently easily convert algorithms tail recursion algorithm tail recursion linear recursion algorithm recursive operation algorithm code fragment   tail recursion reverse elements array statement method definition include recursive order method tail recursion recursive absolutely thing method base case algorithm code fragment   tail recursion statement cludes recursive recursive thing method receives returned recursive adds  returns sum ing algorithm add recursive algorithm tail recursion convert recursive algorithm nonrecursive iterating recursive calls calling explicitly illustrate type conversion revisiting problem reversing elements array code fragment   nonrecursive algorithm performs task iterating recursive calls algorithm code fragment   initially algorithm iterativereversearray   code fragment   reversing elements array iteration     binary recursion algorithm recursive calls binary recursion calls solve halves problem   drawing english ruler application binary recursion revisit problem summing elements integer array case sum elements recursively summing elements half recursively summing elements half iii adding values togeth details algorithm code fragment   initially binarysum  code fragment   summing elements array binary recursion analyze algorithm binarysum simplicity case power general case arbitrary considered exercise   figure   recursion trace execution method binarysum   label box values parameters represent starting length sequence elements reversed notice arrows trace box labeled box labeled    parameter halved recursive depth recursion maximum number method instances active time  log n algorithm binarysum additional space roughly proportional big improvement ace needed linearsum method code fragment   running time algorithm binarysum roughly  proportional box visited constant time stepping algorithm   boxes figure   recursion trace execution binarysum   computing fibonacci numbers binary recursion problem computing kth fibonacci number recall    fibonacci numbers cursively defined f0  f1  fi1 fi2  directly applying definition algorithm binaryfib code fragment   computes sequence fibonacci numbers binary recursion code fragment   computing kth fibonacci number binary recursion  spite fibonacci definition binary recursion technique inefficient case fact takes exponential number calls compute kth fibonacci number nk denote number calls rformed execution binaryfib values nk n0  n1  n1 n0      n3 n1      n4 n3      n5 n4 n3      n6 n5 n4      n7 n6 n5      n8 n7 n6      follow pattern forward number calls doubles consecutive indices n4 n5 n3 n6 n4 nk k  binaryfib number calls exponential binary recursion compute fibonacci numbers inefficient computing fibonacci numbers linear recursion main problem approach based binary recursion computation fibonacci numbers linearly recursive problem good candidate binary recursion simply tempted binary recursion kth fibonacci number fk depends previous values fk1 fk2 compute fk efficiently linear recursion order linear recursion redefine problem accomplish convers ion define recursive function computes pair consecutive fibonacci numbers fk fk1 convention f1  linearl recursive algorithm code fragment    code fragment   computing kth fibonacci number linear recursion algorithm code fragment   linear recursion compute fibonacci numbers efficient binary recursion recursive linearfibonacci decreases argument  original linearfibonacci series  additional calls computing kth fibonacci number linear recursion requires method calls performance signifi cantly faster exponential time needed algorithm based binary recursion code fragment   binary recursion fully partition problem summing elements array overlap ping recursive calls eliminate overlapping ecursive calls memory track previous values fact approach central technique called dynamic programming recu rsion discussed       multiple recursion generalizing binary recursion multiple recursion method multiple recursive calls number common applications type recursion enumerate configurations order solve combinatorial puzzle instances summation puzzles pot pan bib dog cat pig boy girl baby  solve puzzle assign unique digit    letter equation order equation true typically solve puzzle human observations puzzle solve eliminate configurations partial assignments digits letters work feasib configurations left testing correctness number configurations large computer simply enumerate possibilities test employing human observations additi algorithm multiple recursion work configurations systematic pseudocode algorithm code fragment   description general puzzles algorithm enumerates tests length sequences repetitions elements set build sequences elements steps  recursively generating sequences  elements  appending sequence ement contained execution algorithm set track elements contained current sequence element algorithm code fragment   enumerates size ordered subset tests subset solution puzzle summation puzzles           position sequence corresponds letter position stand code fragment   solving combinatorial puzzle enumerating testing configurations  figure   recursion trace puzzlesolve  execution permutations characters generated tested note initial recursive calls turn executed puzzlesolve  set consisting elements initial ecursive calls trace figure   figure   recursion trace execution puzzlesolve  execution generates tests permutations permutations generated directly respective boxes    exercises source code exercises visit datastructures net reinforcement   add remove methods code fragments     track number null entries array unused cells point null object change methods track actual size instance variable   recursion add elements dimensional array integers   explain modify caesar cipher program code fragment   performs rot  encryption decrypt ion  alphabet shift simplify code body decrypt method single   explain program code fragment   perform caesar pher messages written alphabet based language englis greek russian hebrew   exception thrown advance remove called list code fragment   explain modify methods instructive exception condition   recursive definiti singly linked list   method inserting elem ent singly linked list assume list sentinel header node variable head reference node list    algorithm finding penultimate node singly linked list element null reference   nonrecursive method finding link hopping middle node doubly linked list header trailer sentinels note method link hopping counter wh running time method   recursive algorithm finding maximum element array elements running time space usage   draw recursion trace execution method reversearray   code fragment   array        draw recursion trace execution method puzzlesolve  code fragment     write short method repeated ly selects removes random entry array array holds entries   write short method count number nodes circularly linked list creativity   code performing add remove methods game entries stored array code fragments     maintain game entries order assume entries stored indices   implement add remove methods loops number steps perform depend    array size  integers   inclusive repeated fast algorithm finding integer repeated   array size  integers   inclusive repeated good algorithm finding integers repeated   suppose designing multi player game  players numbered  interacting enchanted forest winner game player meet players ties allowed assuming method meet called time player meets player track pairs meeting players winner   recursive algorithm compute product positive integers addition subtraction   fast recursive algorith reversing singly linked list ordering nodes opposite list position list reversed remove   good algorithm concatenating singly linked lists header sentinels single list nodes nodes   fast algorithm catenating doubly linked lists header trailer sentinel nodes single list   swap nodes singly linked list references repeat exercise case doubly linked list algorithm takes time    algorithm reversing singly linked list constant additional space recursion   towers hanoi puzzle platform pegs sticking peg stack disks larger smallest largest puzzle disks peg peg moving disk time place larger disk smaller figure   case  recursive algorithm solving towers hanoi puzzle arbitrary hint subproblem moving nth disk peg peg temporary storage figure   illustration towers hanoi puzzle   recursive method converting string digits integer represents  represents integer     recursive algorithm ounts number nodes singly linked list    write recursive program output subsets set elements repe ating subsets   write short recursive method finds minimum maximum values array int values loops   recursive algorithm check array integers integer sum integers earlier   write short recursive method rearrange array int values values odd values   write short recursive met hod takes character string outputs reverse reverse pots pans snap   write short recursive method determines string palindrome equal reverse racecar gohangasalamiimalasagnahog palindromes   recursion write thod determining string vowels consonants   suppose circularly linked lists lists nodes node nonnull node fast algorithm telling list node cursor starting points   circularly linked list numb nodes split circularly linked lists half size  projects   write program matrix class add multiply arbitrary dimensional arrays integers   perform previous project generi types matrices involved arbitrary number types   write class maintains  scores game application implementing add remove methods    singly linked list array   perform previous project doubly linked list implementation remove fewest number pointer hops game entry   perform previous project li nked list circularly linked doubly linked   write program solving summation puzzles enumerating testing configurations program solve puzzles      write program perform encryp tion decryption arbitrary substitution cipher case encryption array random shuffling letters alphabet program generate random encryption array decryption array encode decode message   write program perform aesar cipher english messages include upper lowercase characters  chapter notes fundamental data structures arrays linked lists recursion discussed chapter belong folklore computer science chronicled computer science li terature knuth seminal book fundamental algorithms  chapter  analysis tools contents   functions book     constant function     logarithm function     linear function      log function     quadratic function     cubic function polynomials     exponential function     comparing growth rates    analysis algorithms     experimental studies      primitive operations     asymptotic notation     asymptotic analysis     big notation     recursive algorithm computing powers    simple justification techniques         contra attack      induction loop invariants    exercises  datastructures net   functions book discuss ven functions analysis algorithms simple functions analysis book fact function marked star optional addition fundamental functions appendix list mathematical facts apply contex data structure algorithm analysis    constant function simplest function constant function function fixed constant    argument constant function assigns matter equal constant interested integer functions fundamental constant function  typical constant function book note constant function written constant times case simple constant function algorithm analysis characterizes number steps needed basic operation computer adding numbers assigning variable comparing numbers     logarithm function interesting su rprising aspects analysis data structures algorithms ubiquitous presence logarithm function logbn constant  function defined logb definition log   base logarithm computing logarithm function integer involves calculus approxima tion good purposes calculus easily compute smallest integer greater equal log number equal number times divide number equal  evaluation log327       likewise evaluation log464        approximation log           base approximation arises algorithm analysis common operation algorithms repeatedly divide input half computers store integers binary common base logarithm function computer science  fact base common typically leave  logn log2n note handheld calc ulators button marked log typically calculating logarithm base  base rules loga rithms exponent rules proposition   logarithm rules real numbers      logbac logba logbc  logba log logbc  logbac clog  logba logda logdb  log log db notational shorthand logcn denote function logn derive identities follow definition logarithms exponents illustrate identities examples    demonstrate teresting applic ations logarithm rules proposition   usual convention base logarithm  ł log n log2 log  logn rule  ł log  log log2 logn  rule  ł logn3 logn rule  ł log2n nlog2  rule  ł log4n log log4 logn  rule  ł logn nlog2 n1 rule  practical matter note rule  compute base logarithm calculator base  logarithm button log log2n logn log2    linear function simple impo rtant function linear function input linear function assigns function arises algorithm analysis time single basic operation elements comparing number element array size require comparisons linear function represents running time hope achieve algorithm processes collection objects computer memory reading objects requires operations    log function function discuss log function nlogn function assigns input times logarithm base function grows faster linear function lot slower quadratic function veral occasions improve running time solvi problem quadratic log algorithm runs faster general     quadratic function function appears algorithm analysis quadratic function input function assigns product squared main reason quadratic function pears analysis algo rithms algorithms nested loops loop performs linear number operations outer loop performed linear number times cases algorithm performs operations nested loops quadratic function quadratic function context nested loops iteration loop operation operations operations number operations      total number operations performed nested loop number operations performed inside loop increases iteration outer loop quantity interesting history  german schoolteacher decided   year pupils occupied adding integers   children claimed answer teacher suspicious student answer slate answer correctš5 š student carl gauss grew greatest mathematicians time suspected young gauss identity proposition   integer         visual justifications proposition   figure   figure   visual justifications proposition   illustrations visualize identity terms total area covered unit width rectangles heights   rectangles  cover big triangle area  base height small triangles area   base  height  applies rectangles cover big rectangle base  height  lesson learned proposition   perform algorithm nested loops operations loop increase time total number operations quadratic number times perform outer loop icular number operations   case constant factor   times quadratic function algorithm algorithm operations time ner loop performed observation nonintuitive true figure      cubic function polynomials continuing discussion functions powers input cubic function n3  assigns input product times function appears frequently context algorithm analysis constant linear quadratic functions mentioned time time polynomials interestingly functions listed viewed larger class functions polynomials polynomial function function form a0 a1n a2n2 a3n3 adnd a0 constants called coefficients polynomial  integer highest power polynomial called degree polynomial func tions polynomials ł  n ł  n3 ł  ł ł argue book presents functions algorithm analysis ick constant linear quadratic functions lumped polynomials running times polynomials degree generally polynomial running times large degree summations notation appears analysis data structures algorithms summation defined  integers summations data structure algorithm analysis running tim loops naturally rise summations summation rewrite formula proposition   likewise write polynomial degree coefficients a0 summation notation shorthand expressing sums increasing terms regular structure    exponential function function analysis algorithms exponential function positive constant called base argument exponent function assigns input argument multiplying base times algorithm analysis common base exponential function  instance loop starts performing operation doubles number operations performed iteration number operations performed nth iteration n addition integer word bits represent nonnegative integers  exponential function base  common exponential function referred exponent function exponents handy rules working exponents exponent rules helpful proposition   exponent rules positive integers  bac  babc   ł          exponent rule  ł          exponent rule  ł          exponent rule  extend exponential function exponents fractions real numbers negative exponents positive integer define kth root number rk      likewise       approach define power exponent expressed fraction  exponent rule           cth root integral exponent extend exponential function define real number computing series numbers form fractions progressively closer closer real number approximated arbitrarily close fraction fraction exponent arbitrarily close number  defined finally negative exponent define  corresponds applying exponent rule   geometric sums suppose loop iteration takes multiplicative factor longer previous loop analyzed proposition proposition   integer  real number   summation remembering a0   summation equal    summations proposition   called geometric summations term geometrically larger previous  working computing     n1 n  largest integer represented binary notation bits     comparing growth rates sum table   comm functions algorithm analysis order table   classes functions assume  constant constant logarithm linear log quadratic cubic exponent  log nlogn n3 ideally data structure operations times proportional constant logarithm functi algorithms linear log time algorithms quadratic cubic running times practical algorithms exponentia running times infeasible smallest sized inputs plots functions figure   figure   growth rates fundamental functions algorithm analysis base  exponential function functions plotted log log chart compare growth rates  slopes exponential function grows fast display values chart scientific notation numbers denotes a10b ceiling floor functions additional comment func tions order logarithm typically integer running time algorithm expressed inte ger quantity number operations performed analysis algorithm involve thefloor function ceiling function defined ł largest integer equal ł smallest integer greater equal   analysis algorithms classic story famous mathematicia archimedes asked determine golden crown commissioned king ndeed pure gold silver informant claimed archimedes disc overed perform analysis stepping greek bath water spilled bath proportion realizing implications fact bath naked city shouting eureka eureka discovered analysis tool displacement combined simple scale termine king crown good archimedes dip equal weight gold  bowl water displaced discovery unfortunate goldsmith archimedes analysis crown displaced water equal weight lump pure gold indicating crown fact pure gold book interested design good data structures algorithms simply data structure systematic organizing accessing data algorithm step step procedure performing task finite time concepts central computing classify data structures algorithms good precise ways analyzing primary analysis tool book involves characterizing running times algorithms data structure ope rations space usage running time natural measure goodness time precious resourcešcomputer solutions shou ld fast general running time algorith data structure method increases input size vary inputs size running time hardware environment reflected processor clock rate memory disk software environment reflected operating programming language comp iler interpreter algorithm implemented compiled execu ted factors equal running time algorithm input data smaller computer faster processor implementation program compiled native machine code interpreted implementation virtual machine ite variations environmental factors focus relationship running time algorithm size input interested characterizing algorithm running time function input size proper measuring    experimental studies algorithm implemented study running time executing test inputs recording actual time spent execution fortunately measurements accurate manner calls built langua operating current time millis method calling time environment profiling enabled tests assign specific running time specific input size interested determining general dependence running time size input order determine dependence perform experiments test inputs sizes visualize su experiments plotting performance algorithm point coordinate equal input size  coordinate equal running time figure   visualization data supports perform statistical analysis seeks fit function input size experimental data meaningful analysis requires choose good sample inputs test sound statistical claims algorithm running time figure   experimental study running time algorithm dot coordinates input size running time algorithm milliseconds experimental studies running tim major limitations ł experiments limite set test inputs leave running times inputs included experiment inputs  ł difficulty comparing experimental running times algorithms experiments performed hardware software environments ł fully implement execute algorithm order study running time experimentally requirement obvious time consuming aspect performing experimental analysis algorithm limitations impose hurdles hus ideally analysis tool avoid performing experiments rest chapter develop general analyzing running times algorithms ł takes account inputs ł evaluate relative efficiency algorithms independent hardware software environment ł performed studying high evel description algorithm implementing running experiments methodology aims associating algorithm function characterizes running time algorithm function input size typical functions encountered include functions mentioned earlier chapter    primitive operations experimental analysis valuable limitations analyze algorithm performing experiments running time perform analysis directly high level pseudo code define set primitive operations ł assigning variable ł calling method ł performing arithmetic operation adding numbers ł comparing numbers ł indexing array ł object reference ł returning method  counting primitive operations primitive operation corresponds low level instruction execution time constant instea determine specific execution time primitiv operation simply count primitive operations executed number measure running time algorithm operation count correlate actual running time specific computer primitive operation corresponds constant time instruction fixed number primitive operations implicit assumption approach running times primitive operations fairly number primitive operations algorithm performs proportional actual running time algorithm algorithm faster nputs size express running time algorithm function input size average inputs size average case analysis typically challenging requires define probability distribution set inputs difficult task figure   schematically depending input distribution running time algor ithm worst case time case time inputs types figure   difference case worst case time bar represents running time algorithm input  focusing worst case average case analysis requires calculate expected running times based input distribution involves sophisticated probability theory remainder book characterize running times terms worst case function input size algorithm worst case analysis easier average case analysis requires ability identify worst case input simple approach typically leads algor ithms making standard success algorithm perform worst case requires input designing worst case leads stronger algorithmic muscles track star practices running incline    asymptotic notation general basic step pseudo code description high level language implementation corresponds small number primitive operations method calls perf orm simple analysis algorithm written pseudo code estimates number primitive operations executed constant factor pseudo code steps car eful single pseudo code denote number steps cases  simplifying analysis algorithm analysis focus owth rate running time function input size big picture approach bogged small details running time algorithm arraymax    grows proportionally true running time times constant factor depends specific computer analyze data structures algorithms mathematical notation functions disregards constant factors characterize running times algorithms functions map size input values correspond main actor determines growth rate terms formally define refer chosen measure input size allowed defined differently algorithm analyzing appr oach focus attention primary big pictu aspects running time function addition approach characterize space usag data structures algorithms define space usage total number memory cells big notation functions mapping nonnegative integers real numbers real constant  integer constant n0  n0 definition referred big notation pronounced big alternatively order definition illustrated figure   figure   illustrating big notation function nn0    function n  justification big definition real constant  integer constant n0  n  integer n0 easy choice  n0  oinfinitely choices real number greater equal  work integer greater equal  work nf  big notation function equal function constant factor asymptotic sense grows infinity ability fact definition compare times constant asymptotic cases nn0 characterizing running times big notation big notation characterize running times space bounds terms parameter varies problem problem defined chosen measure size problem interested finding largest ement array integers arraymax algorithm denote number elements array big notation write mathematically precise statement unning time algorithm arraymax computer  proposition   algorithmarraymax computing maximum element array ofn integers runs time justification number primitive operations executed algorithm arraymax iteration constant nce primitive operation runs constant time running time algorithm arraymax input size constant times conclude running time algorithm arraymax properties big notation big notation ignore constant factors lower order terms focus main components function affect growth   n4 n3 n2 n  n4 justification note n4 n3 n2 n       n4 cn4  n0  fact characterize growth rate polynomial function proposition   polynomial degree a0 a1n adnd  justification note   a0 a1n a2n2 adnd a0 defining a0 n0  highest degree term polynomial term determines asymptotic growth rate polyn omial additional properties big notation ercises examples focusing combinations fundamental functions algorithm design   n2 nlog n   justification n2 nlogn n       n0  note log    n3 n log  n3 justification n3 n log  n3    log  log justification  log   log  note log  n0  case   n  n justification n  n22  n  n0  case   n  log justification n  log  n0   case characterizing functions simplest terms general big notation characterize function closely true function n3 n2 n5 n4 accurate n3 analogy scenario hungry traveler driving long country road local farmer walking market traveler asks farmer longer drive food truthful farmer longer  hours accurate helpful market minutes drive road big notation strive truth considered poor taste include constant factors lower order terms big notation fashionable function n2  n2 n log completely rrect strive function big simplest terms functions listed   common functions conjunction big notation characterize running times space usage algorithms typically names functions refer running times algorithms characterize algorithm runs worst case time  log quadratic time algorithm runs time likewise algorithm running time   log  called linear time algorithm big omega big notation asymptotic function equal function notations provide asymptotic function grow rate greater equal functions mapping nonnegative integers real numbers pronounced big omega real constant  integer constant n0  n0 definition asymptoti cally function greater equal constant factor   nlog n log justification n log n n log  big theta addition notation functions grow rate constant factors pronounced big theta real constants   integer constant n0  n0    log n log log justification n log nlog n log    nlog      asymptotic analysis suppose algorithms solving problem algorithm running time algorithm running time algorithm implies algorithm asymptotically algorithm small lower running time big notation order classes functions asymptotic growth rate functions ordered increasing growth rate sequence function precedes function sequence  log nlog n3 n illustrate growth rates functions figure   table   selected values fundamental functions algorithm analysis logn nlogn n3 n                                                                                illustrate importan asymptotic viewpoint table   table explores maximum size allowed input instance processed algorithm   minute  hour good algorithm design asymptotically slow algorithm beaten long asymptotically faster algorithm constant factor asymptotically faster algorithm worse table   maximum size problem solved   minute  hour running times measured microseconds  running maximum problem size time   minute  hour n        n2      n    good algorithm design solved effectively computer table   achieve dramatic speed hardware overcome handicap asymptotically slow algorithm table maximum problem size achievable fixed time assuming algorithms running times computer  times faster previous table   increase maximum size problem solved fixed time computer  times faster previous  entry function previous maximum problem size running time maximum problem size n m n2 m n     big notation case big notation analyzing algorithms discuss issues considered poor taste general big denotes equal concept likewise common fully correct usual understanding relation sense statement addition completely wrong big expresses upper bound mathematically inclin correct big notation technically speaking denoting collection functions book stick presenting big statements interpretation considerable freedom arithmetic operations big notation freedom responsibility caution caution asymptotic notation orde point note big notations misleading  constant factors hide large true function n runni time algorithm compared running time  nlogn prefer nlogn time algorithm linear time algorithm asymptotically faster preference constant factor  called googol believed astronomers upper bound number atoms observable universe real problem number input size big notation mindful constant factors lower order terms hiding observation raises issue constitutes fast algorithm generally speaking algorithm running nlogn time reasonable constant factor considered efficient time method fast contexts small algorithm running n time considered efficient exponential running times famous story inventor game chess asked king pay  grain rice square board  grains  grains  fourth interesting test programming skills write program compute number grains rice king pay fact program written compute number single integer lue teger overflow occur time machine complain represent number integer quires biginteger class draw efficient inefficient algorithms natural distinction algorithms running polynomial time running xponential time distinction algorithms running time constant  running time constant  notions discussed grain salt algorithm running n100 time considered efficient distinction polynomial time exponential time algorith considered robust measure tractability summarize asymptotic notations big big omega big theta provide convenient language analyze data structures algorithms mentioned earlier notations provide convenience concentrate big picture low level details examples asymptotic algorithm analysis  conclude analyzing algorithms solve problem diffe rent running times problem interested computing called prefix averages sequence numbers array storing numbers compute array average elements    computing prefix averages applic ations economics statistics year year return mutual fund investor typically fund average annual returns year years years years likewise stream daily web usage logs web site manager track average usage trends time periods quadratic time algorithm algorithm prefix averages problem called prefixaverages1 code fragment   computes element separately definition code fragment   algorithm prefixaverages1 analyze prefixaverages1 algorithm ł initializing returning array constant number primitive operations element takes time  ł nested loops controlled counters body outer loop controlled counter executed times   statements   executed times implies tw statements incrementing testing counter contribute number primitive operations proportional time ł body loop controlled counter executed  times depending current outer loop counter statement loop executed    times recalling proposition        implies statement loop contributes time argument primitive operations incrementing testing counter time running time algorithm prefixaverages1 sum terms term term simple application proposition   running time prefixaverages1 linear time algorithm order compute prefix averages efficiently observe consecutive averages          denote prefix sum   compute prefix averages  easy track current prefix sum scanning array loop ready algorithm prefixaverages2 code fragment   code fragment   algorithm prefix averages2  analysis running time algorithm prefixaverages2 ł initializing returning array constant number primitive operations element takes time ł initializing variable takes  time ł single loop controlled counter body loop executed times   statements  executed times implies statements incrementing testing counter contribute number primitive operations proportional time running time algorithm prefixaverages2 sum terms term term  simple application proposition   running time prefixaverages2 quadratic time algorithm prefixaverages1    recursive algorithm computing powers interesting algorithm analysis problem raising number arbitrary nonnegative integer compute power function defined function recursive definiti based linear recursion  definition leads recursive algorithm method calls compute compute power function faster alternative definition based linear recursion employs squaring technique illustrate definition works examples                                                       definition suggests algorithm code fragment   code fragment   computing power function linear recursion analyze running time algorithm observe recursive method power divides exponent log recursive calls linear recursion squaring  technique reduce running time computation power function logn big improvement   simple justification techniques claims bout algorithm showing correct runs fast order rigorously claims mathematical language order ack claims justify prove statements fortunately simple ways    claims generic form element set property justify claim produce property likewise hard claims generic form element set property justify claim false produce property instance called counterexample   professor amongus claims number form   prime integer greater  professor amongus wrong justification prove professor amongus wrong counter fortunately          contra attack set justification techniques involves negative primary methods contrapositive contradiction contrapositive method negative mirror justify statement true true establish true true logically statements called contrapositive easier   integers justification justify cxlaim contrapositive odd odd odd suppose i  j  integers ij i j   ij  odd  showing contrapositive justification technique previous application demorgan law law helps deal negations states negation statement form likewise states gation statement form contradiction negative justification technique justification contradiction involves demorgan applying justification contradicti technique establish statement true supposing false showing assumption leads contradiction     reaching contradiction consistent situation exists false true order reach conclusion situ ation consistent assume false   integers odd odd odd justification odd odd odd hope leading contradiction assume opposite suppose fact loss generality assume case symmetric i integer i  contradiction simultaneously odd odd odd    induction loop invariants claims running time space bound involve integer parameter denoting intuitive notion size problem claims equivalent statement true  making aim infinite set numbers justify exhaustively direct fashion induction justify claims true technique induction technique amounts showing  finite sequence implications starts true ultimately leads showing true justification induction showing true  values   constant  justify inductive step true true true combination pieces completes justification induction proposition   fibonacci function define           claim thatf n justification claim induction base cases           induction step  suppose claim true      apply inductive assumption called nductive hypothesis imply n  n  n  n2 n1 n1  n1 n inductive argument time fact proposition   proposition   justification justify equality induction base case  trivial     induction step  assume claim true induction hypothesis simplify   n      feel overwhelmed task justifying true n1 remember concreteness inductive technique finite step step sequence implications starts thing true leads truth short inductive argument formula building sequence direct justifications loop invariants final justification technique discuss loop invariant prove statement loop correct define terms series smaller statements s0 s1 sk  initial claim s0 true loop  si1 true iteration true iteration  final statement sk implies statement true fact loop invariant argument    correctness algorithm arraymax loop invariant justify correctness arrayfind code fragment   finding element array code fragment   algorithm arrayfind finding element array arrayfind correct inductively define series statements lead correctness algorithm claim true iteration loop equal elements  claim true iteration loop elements  kind trivially true claim hold vacuously iteration compare element element return elements equal wh ich correct completes algorithm case elements equal element equal increment claim true true iteration loop terminates returning truešthere elements equal algorithm correctly returns š1   exercises source code exercises visit datastructures net reinforcement   pseudo code description time algorithm computing power function draw recursion trace algorithm computation     description algorithm power computing power function code fragment     draw recursion trace power algorithm code fragment   computes power function computing     analyze running time algorithm binarysum code fragment   arbitrary values input parameter   graph functions n nlogn n2 n3 n logarithmic scale axes function plot point coordinate log coordinate log    number operations executed algorithms aand nlogn n2 determine n0 n0   number operations executed algorithms  n3 determine n0 n0   function plotted log log scale standard scale   explain plot function straight slope log log scale   sum numbers   positive integer   statements equivalent running time algorithm worst case running time algorithm   order functions asymptotic growth rate n log n  logn n  log n n n n3 log   constant     product   big characterization terms running time ex1 method code fragment     big characterization terms running time ex2 method code fragment     big characterization terms running time ex3 method code fragment     big characterization terms running time ex4 method code fragment     big characterization terms running time ex5 method code fragment     algorithm find2d element array algorithm find2d iterates rows calls algorithm array code fragment   row searched rows worst case running time find2d terms worst case running time find2d terms total size corre find2d linear time algorithm   function time table determine largest size problem solved time algorithm solving takes microseconds entry completed          max     polynomial log logn     n5 code fragment   algorithms     n  n   nlogn   log   nlogn   positive nondecreasing function greater    algorithm executes logn time computation entry element array worst case running time algorithm   element array algorithm chooses logn elements random executes time calculation worst case running time algorithm   element array integers algorithm executes time computation number logn time computation odd number case worst case running times algorithm   element array algorithm calls algorithm element algorithm runs time called element worst case running time algorithm   bob arguing algorithms claims nlogn time method faster bob time method settle issue  perform set experiments dismay  time algorithm runs faster  log time explain creativity   recursive algorithm pute integer base logarithm addition integer division   implement queue adt stacks running time enqueue dequeue methods case   suppose element array distinct integers listed increasing order number recursive algorithm integers sum pair exists running time algorithm   element unsorted array integers integer recursive algorithm rearranging elements elements equal elements larger running time algorithm   n3   hint bound sum term term geometric progression   logb logf  constant    method finding bot minimum maximum numbers fewer n  comparisons hint construct group candidate minimums group candidate maximums   bob built web site friends numbered  told friend number visit web site times bob counter keeping track total number visits site identitie visits minimum bob friends visited maximum allowed number times   justificatio fibonacci function proposition   base case      induction step  assume claim true   induction       identity presented exercise   wrong justification   polynomial degree simple time method computing rewriting a0 an1 xan horner method big notation characterize number arithmetic opera tions method executes   fibonacci function proposition   induction      set integers pseudo code efficient method computi partial sums sk   running method   draw visual justification proposition   analogous figure   case odd   array  unique integers range   number range design time algorithm finding number allowed  additional space array   set lines plane parallel meet point induction lines determine intersection points   summation nlogn   evil king bottles wine spy poisoned poison deadly drop diluted billion ill kill takes month poison design scheme determining wine bottles poisoned month time expending logn taste testers   suppose row array consists   row   row assuming memory method running time time finding row     pseudo code method multiplying matrix matrix recall product defined running time method   suppose row array consists   row   suppose number  row number row     assuming memory method running time counting number    recursive met hod computing nth harmonic number projects   implement prefixaverages1 prefixaverages2    perform experimental analysis running times visualize running times function input size log log chart   perform careful experimental analysis compares relative running times methods code fragments   chapter notes big notation prompted seve ral comments proper    knuth   defines notation equality chos standard view equality view big notation set brassard  reader interested studying average case analysis referred book chapter vitter flajolet  story archimedes  additional mathematical tools refer appendix  chapter  stacks queues contents    stacks     stack abstract data type     simple array based stack implementation     implementing stack generic linked list     reversing array stack     matching parentheses html tags    queues     queue abstract data type     asimple array based queue implementation      implementing queue generic linked list     round robin schedulers    double ended queues     deque abstract data type     implementing deque    exercises  datastructures net   stacks stack collection objects inserted removed lifo principle objects inserted stack time inserted las object removed time stack derived metaphor stack plates spring loaded cafeteria plate dispenser case fundamental operations involve pushing popping plates stack plate dispenser pop plate stack add plate push  stack plate amusing metaphor pez candy dispenser stores mint candies spring loaded container pops candy stack dispenser lifted figure   stacks fundamental data structure applications including figure   schematic drawing pez dispenser physical implementation stack adt pez registered trademark pez candy   internet web browsers store addresses visited sites stack time user visits site site address pushed stack addresses browser user pop visited sites button   text editors provide undo mechanism cancels editing operations reverts rmer states document undo operation accomplished keeping text stack    stack abstract data type stacks simplest data stru ctures host applications include sophisticated data structures formall stack abstract data type adt supports methods  push insert element stack pop remove stack return element stack error occurs stack additionally define methods size return number elements stack isempty return boolean indicating stack return element stack removing error occurs stack   table series stack operations effects initially stack integers operation output stack contents push   push    pop   push    pop      pop  pop error isempty true push   push    push     push       size      pop     push      pop     pop    stack interface stack data ructure included built class util package class util stack data structure stores generic objects includes methods push pop peek equivalent size equivalent isempty methods pop peek throw exception emptystackexception called stack convenient built class util stack instructive learn design impleme stack scratch implementing abstract data type involves steps step definition application programming interface api simply interface describes names methods adt supports declared  addition define exceptions error conditions instance error condition occurs calling method pop stack signaled throwing exception type emptystackexception defined code fragment   code fragment   exception thrown methods pop stack interface called stack complete interface stack adt code fragment   note interface general specifies elements class subclasses inserted stack achieves generality concept generics    adt provide concrete class implements methods interface adt simple implementation stack interface subsection code fragment   interface stack documented comments javadoc style    note generic parameterized type implies stack elements class      simple array based stack implementation implement stack storing elem ents array stack implementation consists element array integer variable element array figure   figure   implementing stack array element stack stored cell recalling arrays start  initialize  identify ack likewise determine number elements  introduce exception called fullstackexception signal error arises insert element array exception fullstackexception specific implementation defined stack adt details array based stack implementation code fragment   code fragment   implementing stack array size  analyzing array based stack implementation correctness methods array based implementation definition methods mildly interesting point involving implementation pop method note avoided resetting null correct method trade avoid assignment thinking implementi algorithms trade involves garbage collection mechanism searches memory objects longer refe renced active objects reclaims space future details    element pop method called making null reference  stack longer hold reference object active references memory space reclaimed garbage collector table   running times methods realization stack array stack methods array realization executes constant number statements involving arithmetic operations comparisons assignments addition pop calls isempty runs constant time implementation stack adt method runs constant time  time table   performance stack realized array space usage size array determined time stack instantiated note space usage independent number elements stack method time size    push  pop  concrete implementa tion pseudo code code fragment   class arraystack implementing stack interface code fragments     space considerations omit  javadoc comments code fragments presented remainder book note symbolic capacity capacity array llows capacity array place code reflected code fragment   array based implementation stack interface continues code fragment     code fragment   array based stack continued code fragment     output output arraystack program note generic types create arraystack storing integers arraystack stores character strings arraystack integer returns null result size  isempty true stack push  returns null result size  isempty false stack  pop returns  result size  isempty true stack push  returns null result size  isempty false stack  pop returns  result size  isempty true stack arraystack string returns null result size  isempty true stack push bob returns null result size  isempty false stack bob push alice returns null result size  isempty false stack bob alice pop returns alice result size  isempty false stack bob push eve returns null result size  isempty false stack bob eve drawback array based stack implementation  array implementation stack mple efficient implementation negative aspect šit assume fixed upper bound capacity ultimate size stack code fragment   chose capacity   arbitraril application space waste memory alternatively application space stack implementation generate exception client program push  st object stack simplicity efficiency array based stack implementation ideal fortunately implementati discuss size limitation space proportional actual number elements stored stack cases good estimate number items needing stack arra based implementation hard beat stacks serve vital role number computing applications helpful fast stack adt implementation simple array based implementation    implementing stack generic linked list explore singly linked list implement stack adt designing implementation decide stack head tail list choice insert delete elements consta time head efficient stack head list order perform operation size constant time track current number elements instance variable linked list store objects type   case implement generic stack generic linked list generic kind node implement linked list node class code fragment   code fragment   class node implements generic node singly linked list  generic nodestack class implementation stack generic singly linked list code fragment   methods stack interface executed constant time addition ing time efficient linked list implementation space requirement current number elements stack implementation require exception created handle size overflow problems instance variable refer head list points null object list push element stack simply create node reference insert head list likewise pop element stack simply remove node head  list return element perform insertions removals elements head list code fragment   class nodestack implements stack interface singly linked list nodes objects class node code fragment      reversing array stack stack reverse elements array producing nonrecursive algorithm array reversal problem introduced    basic idea simply push elem ents array order stack  array popping elements stack code fragment   implementation algorithm incidentally method illustrates generic types simple application generic stack elements popped stack automati cally returned elements type returned input array method code fragment   code fragment   generic method reverses elements array type objects stack declared stack interface code fragment   test reverse method arrays     matching parentheses html tags subsection explore applications stacks matching parentheses grouping symbols arithmetic expressions arithmetic expressions pairs grouping symbols ł parentheses ł braces ł brackets ł floor function symbols ł ceiling function symbols opening symbol match closing symbol left bracket match bracket expression   examples illustrate concept ł correct ł correct ł incorrect ł incorrect ł incorrect leave precise definition matching grouping symbols exercise   algorithm parentheses matching problem pro cessing arithmetic expressions grouping symbols match corre ctly stack perform matching grouping symbols arithmetic expression single left scan algorithm tests left symbols match left symbols type suppose sequence x0x1x2 xn1 token thatcan grouping symbol variable arithmetic operator number basic idea checking grouping symbols match correctly process tokens order time encounter opening symbol push symbol time encounter closing symbol pop symbol stack assuming check symbols type stack processed sequence symbols match assuming push pop operations implemented constant time algorithm runs linear time pseudo code description algorithm code fragment   code fragment   algorithm matching grouping symbols arithmetic expression  matching tags html document application matching validation html documents html standard format hyperlinked documents internet html document portions text delimited html tags simple opening html tag form closing tag form mmonly html tags include ł body document body ł h1 header ł center center justify ł paragraph ł numbered ordered list ł li list item ideally html document matching tags browsers tolerate number mismatching tags sample html document rendering figure    figure   illustrating html tags html document rendering fortunately algorithm code fragment   match tags html document code fragments     program matching tags html document read standard input simplicity assume tags simple opening closing tags defined tags formed incorrectly code fragment   complete program testing html document fully matching tags continues code fragment    code fragment   program testing matching tags html document continued   method ishtmlmatched stack store names opening tags stack code fragment   method parsehtml scanner extract tags html document pattern denotes string starts characters    queues  fundamental data structure queue close cous stack queue collection objects inserted removed fifo principle elements inserted time element queue longest removed time elemen enter queue rear removed metaphor terminology people waiting amusement park ride people waiting ride enter rear ride    queue abstract data type formally queue abstract data type fines collection objects sequence element access deletion restricted element sequence called queue element insertion restricted sequence called rear queue restriction enforces rule items inserted deleted queue fifo principle queue abstract data type adt supports fundamental methods enqueue insert element rear queue dequeue remove return queue object error occurs queue additionally case stack adt queue adt includes supporting methods size return number objects queue isempty return boolean queue return remove object queue error occurs queue   table series queue operations effects initially queue integer objects simplicity integers integer objects arguments operations operation output rear  enqueue   enqueue    dequeue   enqueue    dequeue     dequeue  dequeue error isempty  true enqueue   enqueue    size    enqueue     enqueue      dequeue     applications applications queues stores theaters reservation centers services typical ly process customer requests fifo principle queue logical choice data structure handle transac tion processing applications natural choice handling calls reservation center airline box office theater  queue interface interface queue adt code fragment   generic interface specifies object arbitrary object types inserted queue explicit casting removing elements note size isempty methods meaning counterparts stack adt methods method accessor methods return change contents data structure code fragment   interface queue documented comments javadoc style     simple array based queue implementation simple realization queue array fixed capacity storing elements main rule queue adt insert delete objects fifo principle decide track rear queue  possibility adapt approach stack implementation letting  queue letting queue grow efficient solution requires elements forward array cell time perform dequeue operation implementation time perform dequeue method current number objects queue achieve constant time queue method approach array circular avoid moving objects define variables meanings ł cell storing element queue candidate removed dequeue operation queue case ł array cell initially assign  queue remove element queue increment cell likewise add element store cell increment cell scheme implement methods enqueue dequeue constant time  time problem approach repeatedly enqueue dequeue single element times insert element tim array bounds error valid locations   plenty room queue case avoid problem utilize array indices wrap view circular array    figure   figure   array circular fashion normal configuration wrapped configuration cells storing queue elements highlighted  modulo operator implement circular array implementing circular view pretty easy time increment compute increment  mod  mod recall operator mod modulo operator computed remainder integral division  divided   remainder   mod   integers   mod mod nonnegative integer qy denote modulo operator modulo operator view circular array implement queue method onstant time  time approach implement queue code fragment   code fragment   implementation queue circular array implementation modulo operator wrap indices array includes instance variables queue cell rear queue  implementation impor tant missed situation occurs enqueue objects dequeuing condition occurs queue difference queue empt case fortunately big problem number ways dealing exist solution insist hold  objects simple rule handling queue takes care final problem implementation leads pseudo coded descriptions queue methods code fragment   note introduction implementation specific exception called fullqueueexception signal elements inserted queue note compute size queue expression mod  correct result normal configuration wrapped configuration implementation queue array stack left exercise   table   running times methods realization queue array array based stack implementation queue methods array realization executes constant number statements involving arithmetic operations comparisons assignments method implementation runs  time table   performance queue realized array space usage size array determined time queue created note space usage independent number elements queue method time size  isempty   enqueue  dequeue  array based stack implemen tation real disadvantage array based queue implementation artificially set capacity queue fixed real application ually  queue capacity good capacity estimate array based implementation efficient    implementing queue generic linked list efficiently implement queue adt generic singly linked list efficiency reasons choose queue head list rear queue tail list remove head insert tail bad insert head remove tail note maintain references head tail nodes list implementation simply implementation undamental queue methods code fragment   code fragment   methods enqueue dequeue implementation queue adt singly linked list nodes class node code fragment    methods singly linked list implementation queue adt runs  time avoid maximum size queue array based queue impleme ntation benefit expense increasing space element methods singly linked list queue implementati complicated extra care deal special cases queue enqueue queue dequeue    round robin schedulers popular queue data structure implement round robin scheduler iterate collection elements circ ular fashion service element performing action schedule fairly allocate resource shared collection clients  instance round robin scheduler allocate slice cpu time applications running concurrently computer implement round robin scheduler queue repeatedly performing steps figure    dequeue  service element  enqueue figure   iterative steps queue implement round robin scheduler josephus problem children game hot potato group children sit circle passing object called potato circle potato starting child circle children continue passing potato leader rings bell point child holdin potato leave game handing potato child circle sel ected child leaves children close circle process continued child remaining declared winner leader strategy ringing bell potato passed times fixed determining winner list children josephus problem solving josephus problem queue solve josephus problem collection elements queue associating potato element queue storing elements queue order circle passing  potato equivalent dequeuing element enqueuing process performed times remove element dequeuing queue discarding complete program solving josephus problem approach code fragment   describes solution runs nk time solve problem faster techniques scope book code fragment   complete program solving josephus problem queue class nodequeue code fragment      double ended queues queue data structure supports insertion deletion rear queue extension queue called double ended queue deque pronounced deck avoid confusion dequeue method regular eue adt pronounced abbreviation    deque abstract data type deque abstract data type richer stack queue adts fundamental methods deque adt addfirst insert element deque addlast insert element deque removefirst remove return element deque error occurs deque removelast remove return element deque error occurs deque additionally deque adt include support methods getfirst return element deque error occurs deque getlast return element deque error occurs deque size return number elements deque isempty determine deque   table series operations effects initially deque integer objects simplicity integers integer objects arguments operations operation output addfirst    addfirst    removefirst   addlast    removefirst   removelast  removefirst error isempty true    implementing deque  deque requires insertion remova ends list singly linked list implement deque inefficient doubly linked list implement deque efficiently discussed   inserting removing elements doubly linked list straightforward  time sentinel nodes header trailer insertion element access node place node place insert element nodes sentinels create node prev links refer link refer prev link refer likewise remove element stored node access nodes nodes exist sentinels remove node nodes simply point change fields reclaimed garbage collector pointing table   running times methods deque implemented doubly linked list note method runs  time table   performance deque realized doubly linked list method time size isempty  getfirst getlast  add addlast  removefirst removelast   doubly linked list implement method deque adt constant time leave details implementing deque adt efficiently exercise   incidentally methods adt included util linkedlist class deque implement ratch simply built util linkedlist class case deque interface code fragment   implementation interface code fragment   code fragment   interface deque documented comments javadoc style    note generic parameterized type implies deque elements class   code fragment   class nodedeque implementing deque interface class dlnode generic doubly linked list node methods getlast addlast removefirst     exercises source code exercises visit datastructures net reinforcement   suppose initially stack performed total  push operations  operations  pop operations  generated stackemptyexceptions caught current size   implemented stack previous problem array chapter current instance variable   output series stack operations push  push  pop push  push  pop pop push  push  pop push  push  pop pop push  pop pop   recursive method removing elements stack   precise complete definition concept matching grouping symbols arithmetic expression   output sequence queue operations enqueue  enqueue  dequeue enqueue  enqueue  dequeue dequeue enqueue  enqueue  dequeue enqueue  enqueue  dequeue dequeue enqueue  dequeue dequeue    suppose initially queue performed total  enqueue operations  operations  dequeue operations  generated queueemptyexceptions caught current size   queue previous problem implemented array capacity  chapter generated fullqueueexception current values   output sequence deque adt operations addfirst  addlast  addlast  addfirst  removefirst remove addlast  removefirst removelast   suppose deque numbers         order suppose initially queue pseudo code description method variables objects storing elements         order   repeat previous problem deque initially stack creativity   suppose stack elements queue initially scan ontains element additional constraint algorithm return elements original order array linked listšonly constant number reference variables   pseudo code description array based implementation double ended queue adt running time operation    suppose alice picked distinct integers stack random order write short straigh tline piece pseudo code loops recursion comparison variable guarantees probability   code variable store largest alice inte gers argue method correct   implement stack adt queues running time push pop methods case   stack queue generate subsets element set nonrecursively   suppose dimensional array store integers spend work initialize  advance cells algorithm runs time counting time initialize array based stack storing integer triples array initializing implement algorithm time initial values cells total garbage   nonrecursive algorithm numerating permutations numbers     postfix notation unambiguous wr iting arithmetic expression parentheses defined exp1 exp2 normal fully parenthesized expression operation postfix version pexp1 pexp2 pexp1 postfix version exp1 pexp2 postfix version exp  postfix version single number variable number variable postfix version           nonrecursive evaluatingexpression postfix notation   suppose nonempty stacks deque stores elements original elements sets elements ill original order    alice array based stacks capacity  capacity  capacity  initially person programmed class stacks push pop methods private method alice static method transfer transfers itera tively applying private pop push methods elements stack stack star ting initial configuration performing transfer holding  elements holding  sequence transfer operations starts initial configuration holding  elements   alice queues store integers bob alice  odd integers  integers insists ores  integers play game bob picks random applies round robin scheduler chapter chosen queue random number times number left queue game odd bob wins alice wins alice allocate integers queues optimize chances nning chance winning   suppose bob cows bridge yoke hold cows tied yoke yoke heavy carry bridge tie untie cows time cows azie cross bridge  minutes daisy cross  minutes crazy cross  minutes lazy cross  minutes cows tied yoke speed slower cow bob cows bridge  minutes projects   implement stack adt doubly linked list   implement stack adt arraylist class built stack class    implement program input expression postfix notation exercise   output   implement queue adt array   implement entire queue adt singly linked list   design adt color double stack adt consists stacksš red blue šand operations color coded versions regular stack adt operations exampl adt red push operation blue push operation efficient implementation adt single array capacity set assumed larger zes red blue stacks combined   implement deque adt doubly linked list   implement deque adt array circular fashion   implement stack queue interfaces unique class extends class nodedeque code fragment     share common stock company sold capital gain loss difference share selling price price originally paid buy rule easy understand single share sell multiple shares stock bought long period time identify shares sold standard accounting principle identifying shares stock sold case fifo protocolšthe shares sold held longest default method built personal finance software packages suppose buy  shares  day   shares  day   shares  day  sell  shares day   applying fifo protocol  shares sold  bought day   bought day   bought day  capital gain case         write program takes input sequence transactions form buy share sell share assuming transactions occur consecutive days values integers input sequence output total capital gain loss entire sequence fifo protocol identify shares chapter notes introduced approach defining data structures terms adts terms concrete plementations classic books aho hopcroft ullman   incidentally aproblem exercise   exercises       interview questions software company study abstract data types liskov guttag  cardelli wegner  demurjian  chapter  lists iterators contents   array lists     array list abstract data type     adapter pattern      simple array based implementation     simple interface util arraylist class     implementing array list extendable arrays    node lists     node based operations     positions     node list abstract data type     doubly linked list implementation     iterators     iterator iterable abstract data types     loop     implementing iterators     list iterators    list adts collections framework     collections framework     util linkedlist class      sequences    case study heuristic     sorted list nested class     list heuristic     favorites list    exercises  datastructures net   array lists suppose collection elements stored linear order refer elements collection generically referred list sequence uniquely refer element integer range   equal number elements precede element number elements element  element  element previous element exists  element exists  concept  rank element list defined element rank  rank  sequence supports access elem ents indices called array list vector older term definition consistent arrays indexed programming languages referring place element stored array list rank denote letter loop counter concept simple powerfu notion insert element list remove element    array list abstract data type adt array list methods standard size isempty methods return element error condition occurs  size  set replace return element error condition occurs  size  add insert element error condition occurs  size remove remove element error condition occurs  size  insist array implement array list element  stored  array natural possibility definition ffers refer place element stored sequen worry exact implementation sequence inde element change sequence updated illustrate   operations initially array list operation output add     add         add       error    remove     add      add       add                set            adapter pattern classes written provide functional ity classes adapter design pattern applies context modify existing class methods match class interface general applying adapter pattern define class instance class hidden field implement method class methods hidden instance variable result applying adapter pattern class performs functions previous class convenient created respect discussion rray list adt note adt sufficient define adapter ass deque adt table   exercise   table   realization deque array list deque method realization array list methods size isempty size isempty getfirst  getlast  size  addfirst add  addlast add size removefirst remove  removelast remove size     simple array based implementation obvious choice implementing array list adt array stores reference element choose size array large maintain number elements instance variable details implementation array list adt simple implement operation return implementations methods add remove code fragment   time consuming implementation invol ves shifting elements occupi cells array contiguous shifting operations required maintain rule storing element list array figure   exercise   code fragment   methods add remove array implementation array list adt denote instance variable storing number elements array list  figure   array based implementation array list storing elements shifting insertion shifting removal performance simple array based implementation table   worst case running times methods array list elements realized array methods isempty size set  time insertion removal methods longer add runs time worst case operation occurs  existing elements  shifted forward argument applies method remove runs time shift backward  elements worst case  fact assuming equally passed argument opera tions average running time shift  elements average table   performance array list elements realized array space usage size array method time size  isempty   set  add remove closely add remove note time  elements higher shifted inserting removi item array list methods add remove   time observation interesting consequence adaptation array list adt deque adt    array list adt case implemen ted array methods addlast removelast deque   time methods addfirst removefirst deque time effort oduce array based implementation array list adt achieves  time insertions removals  insertions removals array list achieving requires rule element stored array circular array approach   implement queue leave details implementation exercise      simple interface util arraylist class prepare constructing implem entation array list adt code fragment   interface indexlist captures main methods array list adt case indexoutofboundsexception signal invalid argument code fragment   indexlist interface array list adt util arraylist class class util arraylist implements methods arra list adt includes methods included code fragment   indexlist interface  util arraylist class features addition simplified array list adt class util arraylist includes method clear removes elements array list method toarray returns array elements ray list order addition class util arraylist methods searching list including method indexof returns occurrence element equal array list method lastindexof returns occurrence element equal array list methods turn invalid  element equal    implementing array list extendable arrays addition implementing methods indexlist interface methods class util arraylist interesting feature overcomes wea kness simple array implementation major weakness simple array implementation array list adt    requires advance specification fixed capacity total number elements stored array list actual number elements array list smaller implementation waste space worse increases implementation crash util arraylist interesting extendable array technique worry array overflows class util arraylist class provide grow array stores elements array list programming languages nnot grow array capacity fixed number observed overflow occurs method add perform additional steps  allocate array capacity      array supporting  insert element  array replacement strategy extendable array viewed extending underlying array room elements figure   intuitively strategy hermit crab moves larger shell outgrows previous figure   illustration steps growing extendable array create array copy elements reassign reference array future garbage collection array implementing indexlist interface extendable array portions implementa tion array list adt extendable array code fragment   class array grow exercise   explores implementation shrink code fragment   portions class arrayindexlist realizing array list adt extendable array method checkindex checks range    amortized analysis extendable arrays array replacement strategy slow performing single array replacement required element insertion time  notice perform array repl acement array add elements array list array replaced simple fact perfo rming series operations initially array list efficient shorthand notation refer insertion element element array list push operation figure   figure   running times series push operations util arraylist initial size  algorithmic design pattern called amortization performing sequence push operations array list implemented extendable array efficient perform amortized analysis accounting technique view computer coin operated appliance requires payment cyber dollar constant computing time operation executed cyber dollars current bank account pay operation running time total cyber dollars spent computation proportional total time spent computation beauty analysis method overcharg operations order save cyber dollars pay  proposition   array list implemented extendable array initial length total time perform series push operations starting justification assume cybe dollar pay execution push operation excluding time spent growing array assume growing array size size k requires cyber dollars time spent copying elements charge push operation cyber dollars overcharge push operation overflow cyber dollars cyber dollars profited insertion grow array stored element inserted overflow occurs array list i elements integer  size array array list representing i doubling size array require  cyber dollars fortunately cyber dollars elements stored cells  i1 i  figure   note previous overflo occurred number elements larger  i1 time cyber dollars stored cells i1 i  spent valid amortization scheme operation charged cyber dollars computing time paid pay execution push operations n cyber dollars amortized running time push operation  total running time push operations figure   illustration series push operations array list  cell array cyber dollars stored cells   push operation overflow doubling capacity copying elements array paid cyber dollars stored table inserting element paid cyber dollars charged push operation cyber dollars profited stored cell     node lists referring place element appears sequence sequence implemented singly doubly linked list natural efficient node iden tifying access update define node list adt abstracts concrete linked list data structure sections     position adt abstracts notion place node list    node based operations singly doubly linked list define methods nodes parameters provide nodes return types methods provide speedups based methods finding element linked lis requires searching list incrementally counting elements instance define hypothetical method remove removes element stored node list node parameter remove element  time simply directly place node stored linking node update prev links neighbors insert  time element operation addafter specifies node node element inserted case simply link node defining methods list adt adding node based operations raises issue exposing implementation list desirable singly doubly  linked list revealing user likewise user modify internal structure list knowledge modification provided reference node list form allowed user access internal data node prev field abstract unify ways storing elements implementations list introduce concept position formalizes intuitive notion ace element relative list    positions safely expand set operations lists stract notion position enjoy efficiency doubly singly linked list implementations violating object oriented design principles framework view list collection elements stores element position positions arranged linear order position abstract data type supports simple method element return element stor position position defined terms neighbors list position position position position position element list change explicitly remove destroy position position change replace swap element stored element facts positions define set position based list methods position objects para meters provide position objects return values    node list abstract data type concept position encapsulate idea node list define type sequence adt called node list adt adt supports methods list return position element error occurs return position element error occurs prev  return position element preceding position error occurs position return position element position error occurs position methods refer relative positions list starting incrementally list positions intuitively thought nodes list note specific references node objects provide position argument list method position repr esent valid position list node list update methods addition methods generic methods size isempty include update met hods node list adt position objects parameters provi position objects return values set replace element position returning element position addfirst insert element element addlast insert element element addbefore insert element position addafter insert element position remove remove return element position invalidating position  node list adt view ordered collection objects terms places worrying exact places represented figure   figure   node list positions current order redundancy repertory operations node list adt perform operation addfirst addbefore operation addlast addafter getlast substitutions nonempty list note error condition occurs position passed argument list operations invalid reasons position invalid include ł null ł deleted list ł position list ł position list prev ł position list illustrate operations node list adt   series operations initially list node variables denote positions object stored position parentheses operation output addfirst      addafter       addbefore     prev     addfirst           remove      set      addafter      node list adt built notion position number settings program simulates game cards model person hand node list people cards suit inserting removing cards person hand implemented methods node list adt positions determined natural ordering suits likewise simple text editor embeds notion positional insertion removal editors typically perform updates relative cursor represents current position list characters text edited interface representing position adt code fragment   code fragment   interface position adt interface node list adt called position list code fragment   interface exceptions error conditions boundaryviolationexception thrown attempt accessing element position outsi range positions list calling method position sequence invalid position exception thrown position provided argument valid null reference list  code fragment   interface node list adt deque adapter respect discussion node list adt note adt sufficient define adapter ass deque adt table   table   realization deque node list  deque method realization node list methods size isempty size isempty getfirst element getlast element addfirst addfirst addlast addlast removefirst remove removelast remove    doubly linked list implementation suppose implement node list adt doubly linked list   simply nodes linked list implement position adt node implement position interface define method element returns element stored node nodes pos itions viewed internally linked list nodes viewed positions internal view node instance variables prev refer predecessor successor nodes fact header trailer sentinel nodes rking list variables prev directly define methods getprev setprev getnext setnext node access modify variables  code fragment   class dnode nodes doubly linked list implementing position adt class class dnode code fragment   nodes store generic element character string note prev instance variables dnode class private references dnode objects code fragment   class dnode realizing node doubly linked list implementing position interface adt position unwrap reveal underlying node accomplished casting position node node implement method prev getprev node returned getprev header case signal error positions doubly linked list implementation supported object oriented additional time space overhead implement addafter method inserting element position discussion    create  node hold element link place li update prev references neighbors method code fragment   illustrated figure   recalling sentinels   note algorithm works real position code fragment   inserting element position linked list figure   adding anew node position jfk insertion creating node element bwi linking insertion algorithms methods addbefore addfirst addlast method addafter leave details exercise    remove method removes element stored position discussion    perform operation link neighbors refer neighborsšlinking note linked nodes pointing garbage collector reclaim space algorithm code fragment   illustrated figure   recalling header trailer sentinels note algorithm works real position list code fragment   removing element stored position linked list figure   removing object stored position pvd removal linking node removal garbage collection  conclusion doubly linked list perform methods list adt  time doubly linked list efficient implementation list adt node list implementation portions class nodepositionlist implements node list adt doubly linked list code fragments   œ6  code fragment   nodeposition list instance variables constructor method checkposition performs safety checks unwraps position casting dnode code fragment   additional accessor update methods code fragment   additional update methods code fragment   portions nodepositionlist class implementing node list adt doubly linked list continues code fragments      code fragment   portions nodepositionlist class implementing node list adt doubly linked list continued code fragment   continues code fragment    code fragment   portions nodepositionlist class implementing node list adt doubly linked list continued code fragments     note mechanism invalidate position remove method  consistent checks performed checkposition convenience function   iterators typical computation array list list sequence march elements order time specific element    iterator iterable abstract data types  iterator software design pattern abstracts process scanning collection elements elemen time itera tor consists sequence current element stepping element making current element iterator extends concept position adt introduced   fact position thought iterator iterator encapsulates concepts place collection objects define iterator adt supporting methods hasnext test elements left iterator return element iterator note iterator adt notion current element traversal sequence element iterator returned method assuming iterator element iterator unified scheme access elements collection objects independent specific organization collection iterator array list list seque nce return elements linear ordering simple iterators iterator util iterator interface note util scanner class   implements interface interface supports add itional optional method remove returned element collection functionality removing elements iterator controversial object oriented viewpoint surprising implementation classes optional incidentally util enumeration interface historically older iterator interface names hasmoreelements nextelement iterable abstract data type order provide unified generic mechanism scanning data structure adts storing collections objects support method iterator return iterator elements collection method supported util arraylist class fact method interface  lang iterable method method simple putations loop elements list guarantee node list supports methods add method position list interface code fragment   case state position list extends iterable assume array lists node lists lists support iterator method code fragment   adding iterator method position list interface position list definition iterator returned iterator method create string representation node list code fragment   code fragment   iterator convert node list string    loop  looping elements retu rned iterator common construct shorthand notation loops called loop syntax loop type expression loop statement expression evaluates collection implements lang iterable interface type type object returned iterator class variable values elements iterator loop_statement notation shorthand iterator type expression iterator hasnext type loop_statement list values integer objects values implements lang iterable add integers values list integer values statements create values list integers int sum  integer values sum unboxing read loop integer values loop body case add sum addition form loop loop defined case expression array type type case base type object type total integers array stores positive integers int            int total  int total    implementing iterators implement iterator collection elements snapshot iterate approach involve storing collection separate data structure supports sequential access elements insert elem ents collection queue case method hasnext correspond isempty correspond enqueue approach method iterator takes time collection size copying overhead costly prefer cases ite rators operate collection copy implementing direct approach track collection iterator cursor points hus creating iterator case simply involves creating itera tor object represents cursor element colle ction likewise performing method involves returning element ists moving curs element position pproach creating iterator takes  time iterator methods class implementing iterator code fragment   code fragment   iterator implement iterator method nodepositionlist class code fragment   element iterator class position list  code fragment   iterator method class nodepositionlist position iterators adts support notion positi list sequence adts provide method positions return iterable object array list node list positions collection elements iterator returned method loop positions list guarantee node list supports met hod add positionlist interface code fragment   add implementation method nodepositionlist code fragment   method nodepositionlist class create list positions original list elements returning list positions iterable object  iterator object iterator positions original list code fragment   adding iterator methods position list interface code fragment   positions method class nodepositionlist iterator method returned iterable objects defines restricted type iterator pass elements powerful iterators defined forward backward ordering elements    list iterators util linked list class expose position concept users api eferred access update linkedlist object indices listiterator generated linked list listiterator method iterator forward backward traversal methods local update methods views current position element elements  element list cursor screen rsor viewed located characters screen util listiterator interface includes methods add add element curr ent position iterator hasnext true element current position iterator hasprevious true element current position iterator previous return element current position sets current position return element current position sets rrent position nextindex return element previousindex return previous element set replace element returned prev ious previous operation remove remove element returned evious previous operation risky multiple iterators list modifying contents insertions deletions replacements requi red multiple places list safer positions locations util linkedlist class expose position objects user  avoid risks modifying list created multiple iterators calls iterator method util iterator objects fail fast feature invalidates iterator underlying collection modified unexpectedly util linkedlist object returned iterators modifies invalid list iterators traversing linked list time modifies add set remove method iterators invalid likewise modified update methods existing iterators invalid util list interface implementations functionality array list node lists adt util list interface implem ented array util arraylist linked list util linkedlist trade offs implementations explore iterators achieve functionality node list adt derives positions table   methods array node list adts util interfaces list listiterator interfaces notes implementations util classes arraylist linkedlist table   correspondences methods array list node list adts util interfaces list listiterator abbreviations util arraylist util linked list running times list adt method util list method listiterator method notes size size  time  isempty isempty  time  min listiterator element listiterator size element previous prev previous  time  time set set  time set set  min add  add time remove remove  min addfirst add   addfirst addfirst exists  addlast add  time addlast addlast exists  addafter add insertion cursor  addbefore add insertion cursor  remove remove  deletion cursor    list adts collections framework discuss general list adts combine methods deque array list node list adts describing adts mention larger context exist    collections framework package data structur interfaces classes define collections framework package util includes versions data structures discussed book discussed discuss remainder book util package includes interfaces collection general interface data struct ure collection elements extends lang iterable includes iterator method returns iterat elements collection iterator interface simple iterator adt list interface extending collection clude array list adt includes method listiterator returning listiterator object list listiterator iterator interface forward backward traversal list cursor based update methods map interface mapping keys lues concept interface discussed   queue  interface queue adt method names methods include peek offer enqueue poll dequeue set interface extending collection sets collections framework includes concrete classes implementing combinations bove interfaces list classes discuss places book topic stress class implementing util collection interface implements lang iterable interface includes iterator method loop addition class implementing util list interface includes listiterator method observed interfaces looping elements collection list    util linkedlist class util linked list class lot methods including methods deque adt   methods array list adt   addition mentio ned functionality node list adt list iterator performance util linkedlist class documentation util linkedlist class clear class implemented doubly linked list update methods list iterator  time likewise methods deque adt  time involve updating querying list ends methods array list adt included util linkedlist general suited implementa tion doubly linked list linke list indexed access elements performing operation return element requires perform link hopping ends list counting locate node stor ing element slight optimization observe star hopping closer list achieving running time min   number elements list worst case kind search occurs  running time operations add remove perform link hopping locate node storing element insert delete node running times implementations add remove likewise min   advantage approach   case adaptation array list adt deque adt    add remove  time general array list methods util linkedlist object inefficient    sequences sequence adt supports methods deque adt   array list adt   node list adt   explicit access elements list indices positions dual access capability include sequence adt bridging methods provide connections indices positions atindex return position element error condition occurs  size  indexof return element position multiple inheritance sequence adt definition sequence adt including methods adts multiple inheritance    sequence adt inherits methods super abstract data types methods include union methods super adts code fragment   specification sequence adt interface code fragment   sequence interface defined multiple inheritance includes methods deque indexlist  positionlist interfaces defined generic type adds methods implementing sequence array implement sequence adt doubly linked list performance util linkedlist class suppose implement sequence storing element cell array define position object hold reference array instance variables case implement method element simply returning major drawback approach cells reference positions performing add operation informing existing positions indices  remember positions sequence defined relative neighboring positions indices implement general sequence array approach alternate solution storing elements array store kind position object cell store elements positions position object holds element data structure illustrated figure   easily scan array update variable position insertion deletion figure   array based implementation sequence adt  efficiency trade offs array based sequence array implementation sequence addfirst addbefore addafter remove methods time shift position objects room pos ition hole created removal position insert remove methods based position based methods  time   case study heuristic suppose maintain collec tion elements keeping track number times element accesse keeping access counts elements popular instance examples scenarios include browser track popular web addresses urls user visits photo album program maintains list popular images user views addition favorites list graphical user interf ace gui track popular buttons pull menu user condensed pull downs popular options implement favorite list adt supports size isempty methods access access element incrementing access count adding favorites list remove remove element favorites list provided  return iterable collection accessed elements    sorted list nested class implementation favor ite list code fragments  œ6  build class favoritelist storing references accessed objects linked list ordered nonincre asing access counts class feature define class nested inside enclosing class definition nested class declared static definition enclosing class specific instance class nested classes define helper support classes protected case nested class entry stores element list pair access count reference element time element accessed linked list adding increment acce count removing element amounts finding linked list returning accessed elements simply involves copying values output list order internal linked list code fragment   class favoriteslist continues code fragment     code fragment   class favoritelist including nested class entry representing elements access count continued code fragment      list heuristic  previous implementation favorite list performs access method time proportional favorite list kth popular element favorite list accessing takes time real life access sequences including formed visits users web common elemen accessed accessed future scenarios possess locality reference heuristic rule thumb attempts advantage locality reference access sequence heuristic apply heuristic time access element list hope element accessed future scenario elements series accesses ł element  accessed times ł element  accessed times ł ł element accessed times store elements sorted thei access counts inser ting element time accessed ł access element  runs  time ł access element  runs  time ł ł access element runs time total time performing series accesses proportional n n      n3 hand ont heuristic inserting element time accessed ł access element  takes  time ł access element  takes  time ł ł access element runs  time  running time performing accesses case implementation faster acces times scenario benefit cost implementing heuristic code fragment   implementation favorite list heuristic implement approach case defining class favoritelistmtf extends favoritelist class overrides definitions moveup methods moveup method case simply removes accessed element position linked list serts element list method hand complicated trade offs heuristic longer maintaining favorite list list entries ordered access counts asked accessed elements search implement method  copy entries vorite list list create list  scan list times scan entry largest access count remove entry insert  return list implementation method takes kn time constant method runs time occurs list proportional runs time occurs  list approach heuristic rule thumb access sequences ont approach slower simply keeping favorite list orde red access counts addition trades potential speed performing accesses possess locality reference slower reporting elements    favorites list code fragment   application favorite list implementations solve problem maintaining popular urls simulated sequence web accesses program accesses set urls  decreasing order pops window showing popular web accessed simulation code fragment   class favoritelistmtf implementing heuristic class extends favoritelist code fragments  œ6  overrides methods moveup  code fragment   illustrating favoriteslist favoritelistmtf classes counting web access counts simulation randomly  accesses web displays popular     exercises source code exercises visit datastructures net reinforcement   draw representation initially array list performing sequence operations add   add   add   add   add   add   add   add     justification running times table   methods array list implemented nonexpanding array   adapter class support stack interface methods array list adt   redo justification proposition   assuming cost growing array size size  k cyber dollars push operation charged amortization work   pseudo code descriptions algorithms performing methods addbefore addfirst addlast node list adt assuming list implemen ted doubly linked list   draw pictures illustrating jor steps algorithms previous exercise   provide details array implementation node list adt including perform methods add addafter    provide code fragments methods positionlist interface code fragment   included code fragments       nonrecursive method reve rsing node list represented doubly linked list single pass list internal node pointers   set element stored list final state list assuming heuristic access elements sequence   suppose keeping track access counts list elements suppose kn total accesses elements integer  minimum maximum number elements accessed fewer times   pseudo code describing impl ement operations array list adt array circular fashion running time methods   sequence interface methods recursive method determining sequence integers integer method loops space method addition space   perform sequence method makefirst moves element sequence position element keeping relative ordering remaining elements unchanged makefirst performs method  time implemented doubly linked list   array list int field implement iterator include pseudo code fragments describing hasnext    create iterator node list returns element list   suppose maintaining collection elements time add element collec tion copy contents array list size running time adding elements initially collection case   implementation methods addlast add realized methods set isempty checkposition prev addafter addfirst   maintained list items ordered decreasing access count series accesses reverse   list items maintained heuristic series accesses reverse creativity   pseudo code methods class shrinkingarraylist extends class arrayindexlist code fragment   adds method shrinktofit replaces underlying array array capacity equal number elements array list   extendable array implementation code fragment   order shrink half size array time number elements array list     extendable array grows shrinks previous exercise series n operations takes time push operations array list initial capacity  pop removal element operations   improve implementation method add code fragment   case overflow elements copied final place array shifting case   implementation array list adt extendable array copying elements ray list array double size n capacity reached copy elements array  additional cells capacity  performing sequence push operations insertions runs time case   nodepositionlist implementation code fragments     error checks test position member list position list addafter list add element change nodepositionlist implementation efficient manner disallow misuses   suppose extend sequence abstract data type methods indexofelement positionofelement return position occurrence element sequence implement methods expressing terms methods sequence interface   adaptation array list adt deque adt table     structure pseudo code array based implementation array list adt achieves  time insertions removals  insertions removals array list implementation provide constant time method hint  extend circular array implementation queue adt previous chapter   efficient putting array list representing deck cards random order function randominteger returns random number   inclusive method guarantee ordering equally running time method   method maintaining favorites list element accessed accesses size scheme add  additional amortized time operation   suppose element list maintained heuristic sequence accesses guaranteed n3 time perform   design circular node list adt racts circularly linked list node list adt abstracts doubly linked list   implement iterator circularly linked list hasnext return true case perform hasnewnext returns true node list element returned iterator   scheme creating list iterators fail fast invalid underlying list   array sparse entries null list implement array efficiently nonnull cell store entry element stored approach represent storage number nonnull entries analyze effici ent ways performing  methods array list adt representation store entries increasing indices   simple inefficient algorithm called bubble sort sorting sequence comparable elements algorithm scans sequence n1 times scan algorithm compares current element swaps order pseudo code description bubble sort efficient assuming implemented doubly linked list running time algorithm   answer exercise   assuming implemented array list   operation databases natural join view database list ordered pairs objects natural join databases list ordered triples pair pair analyze efficient algorithm computing natural join list pairs list pairs   bob send alice message internet breaks data packets numbers packets consecutively injects network packets arrive alice computer order alice assemble sequence packets order entire message efficient scheme alice running time algorithm   list positive integers represented logn  bits time method finding bit integer   argue solution previous problem time   list arbitrary integers design time method finding integer formed sum integers    isabel interesting summing values array integers power creates array half size sets i i      size  outputs  replaces repeats process running time algorithm projects   implement array list adt extendable array circular fashion insertions deletions array list constant time   implement array list adt doubl linked list experimentally implementation worse array based approach   write simple text editor stores displays string characters list adt cursor object highlights position string editor support operations ł left cursor left character text ł cursor character text ł cut delete character cursor text ł paste insert character cursor   implement phased favorites list phase consists accesses list parameter phase list maintain elements ordered decreasing access counts phase  phase clear access counts start phase experimentally determine values list sizes   write complete adapter class implements sequence adt util arraylist object   implement favorites list application ing array list stead list compare experimentally list based implementation chapter notes concept viewing data structures collections principles object oriented design object oriented design books booch  budd  golberg robson  liskov guttag  lists iterators pervasive concepts collections framework node list adt derived position abstraction intr oduced aho hopcroft ullman  list adt wood  implementations lists vi arrays linked lists discussed knuth   chapter  trees contents   general trees     tree definitions properties     tree abstract data type      implementing tree    tree traversal algorithms     depth height     preorder traversal     postorder traversal    binary trees     binary tree adt     binary tree interface      properties binary trees     linked structure binary trees     array list representation binary tree     traversals binary trees     template method pattern    exercises  datastructures net   general trees productivity experts breakthroughs thinking nonlinearly chapter discuss portant nonlinear data structures computingš trees tree structures breakthrough data organization implement host algor ithms faster linear data structures list trees provide natural organization data ubiquitous structures file systems graphical user interfaces databases web sites computer systems  clear productivity experts nonlinear thinking trees nonlinear referring organizational relationship richer simple relationships objects sequences relationships tree hierarchical objects actu ally main terminology tree data structures family trees terms parent child ancestor descendent common relationships family tree figure   figure   family tree showing descendents abraham recorded genesis chapters œ36    tree definitions properties tree abstract data type stores elements hierarchically exception element element tree parent element children elements tree visua lized placing elements inside ovals rectangles drawing connections parents children straight lines figure   typically element root tree drawn highest element elements connected opposite botanical tree figure   tree  nodes representing organization fictitious corporation root stores  electronics children root store sales purchasing manufacturing internal nodes store sales international overseas electronics manufacturing formal tree definition formally define tree set nodes storing elements nodes parent child relationship satisfies properties ł nonempty special node called root parent ł node root unique parent node node parent child note definition tree meaning nodes convention define tree recursively tree consists node called root set trees roots children node relationships  nodes children parent siblings node external children node internal children external nodes leaves   operating systems files organized hierarchically nested directories called folders presented user form tree figure   internal nodes tree directories external nodes regular files unix linux operating systems root tree appropriately called root directory represented symbol figure   tree representing portion file node ancestor node ancestor parent conversely node descendent node ancestor figure   cs252 ancestor papers pr3 descendent cs016 subtree rooted node tree consisting descendents including figure   subtree rooted cs016 consists nodes cs016 grades homeworks programs hw1 hw2 hw3 pr1 pr2 pr3  edges paths trees edge tree pair nodes parent vice versa path sequence nodes consecutive nodes sequence form edge tree figure   path cs252 projects demos market   inheritance relation classes program forms tree root lang object ancestor classes class descendent root root subtree classes extend path root lang object inheritance tree ordered trees tree ordered linear ordering defined children node identify children node ordering visualized arranging siblings left ordering ordered trees typically linear order siblings listing correct order   components structured document book hierarchically organized tree internal nodes parts chapters sections external nodes paragraphs tables figures figure   root tree corresponds book fact expanding tree paragraphs consisting sentences sentences consisting consisting characters tree ordered tree defined ordering children node figure   ordered tree book     tree abstract data type tree adt stores elements positions positions list defined relative neighboring positions positions tree nodes neighboring positions satisfy parent child relationships define valid tree terms position node interchangeably trees list position position obje tree supports method element return object stored position real power node positions tree accessor methods tree adt return accept positions root return tree root error occurs tree parent return parent error occurs root children return iterable collection children node tree ordered iterable collection children stores children order external node children addition fundamental accessor methods include query methods isinternal test node internal isexternal test node external isroot test node root methods programming trees easier readable conditionals statements loops nonintuitive conditional  number generic methods tree support tree structure including size return number nodes tree isempty test tree nodes iterator return iterator elements stored nodes tree positions return iterable collection nodes tree replace replace return element stored node method takes position gument generate error condition position invalid define specia lized update methods trees prefer tree update methods conjunction specific applications trees subsequent chapters fact imagine kinds tree update operations book    implementing tree interface code fragment   represents tree adt error conditions handled method position argument throw invalidpositionexception position invalid method parent throws boundaryviolationexception called root method root throws emptytreeexception called tree code fragment   interface tree representing tree adt additional update methods depending application include methods interface  linked structure general trees natural realize tree linked structure represent node position object figure  a fields reference element stored link parent kind collection list array store links children root parent field null store reference root number nodes internal variables structure schematically illustrated figure  b  figure   linked structure general tree position object node portion data structure node children table   summarizes performance implementation general tree linked structure analysis left exercise   note collection store children node implement children simply returning reference collection table   running times methods node general tree implemented linked structure denote number children node space usage operation time size isempty  iterator positions  replace  root parent  children isinternal isexternal isroot    tree traversal algorithms algorithms performing traversal computations tree accessing tree adt methods    depth height node tree depth number ancestors excluding tree figure   node storing international depth  note definition implies depth root  depth node recursively defined ł root depth  ł depth depth parent based definition simple recursive algorithm depth code fragment   computing depth node method calls recursively parent adds  returned simple implementation algorithm code fragment   code fragment   algorithm computing depth node tree  code fragment   method depth written running time algorithm depth dv dv denotes depth node tree algorithm performs constant time recursive step ancestor algorithm depth runs worst case time total number nodes node depth  worst case running time function input size accurate characterize running time terms parameter dv parameter smaller height height node tree defined recursively ł external node height  ł height maximum height child height nonempty tree height root tree figure   height  addition height viewed proposition   height nonempty tree equal maximum depth external node leave justification fact exercise   algorithm height1 code fragment   implemented code fragment   computing height nonempty tree based proposition algorithm depth code fragment    code fragment   algorithm height1 computing height nonempty tree note algorithm calls algorithm depth code fragment   code fragment   method height1 written note max method class lang math algorithm height1 efficient height1 calls algorithm depth external node running time height1  dv number nodes dv depth node set external nodes worst case sum  proportional exercise   algorithm height1 runs time algorithm height2 code fragment   implemented code fragment   computes height tree efficient manner recursive definition height  code fragment   algorithm height2 computing height subtree tree rooted node code fragment   method height2 written algorithm height2 efficient height1 code fragment   algorithm recursive initially called root eventually called node determine running time method summing nodes time spent node nonrecursive processing node children takes time denotes number children node loop iterations iteration loop takes  time time recursive child algorithm height2 spends  time node running time  order complete analysis property proposition   tree nodes denote number children node summing vertices vcv   justification node exception root child node contributes unit sum proposition   running time algorithm height2 called root number nodes    preorder traversal traversal tree systematic accessi visiting nodes basic traversal scheme trees called preorder traversal study basic traversal scheme called postorder traversal preorder traversal tree root visited subtrees rooted children traversed recu rsively tree ordered subtrees traversed order children specific action visit node depe nds application traversal involve increm enting counter performing complex computation pseudo code preorder traversal subtree rooted node code fragment   initially algorithm preorder root code fragment   algorithm preorder performing preorder traversal subtree tree rooted node preorder traversal algorithm producing linear ordering nodes tree parents children ordering orderings applications explore simple instance applica tion figure   preorder traversal ordered tree children node ordered left    preorder traversal tree document   examines entire document sequentially external nodes removed traversal traversal examines table contents document figure   preorder traversal effici ent access nodes tree justify running time eorder traversal tree nodes assumption visiting node takes  time analysis preorder traversal algorithm algorithm height2 code fragment      node nonrecursive preorder traversal algorithm requires time  number children proposition   running time preorder traversal algorithm tostringpreorder implemented code fragment   performs preorder printi subtree node performs preorder traversa subtree rooted prints element stored node node visited recall ordered tree method children returns iterable collectio accesses children order code fragment   method tostringpreorder performs preorder printing elements subtree node  interesting application preorder trav ersal algorithm produces string representation entire tree assume element stored tree calling tostring returns string parenthetic string representation tree recursively defined consists single node element tostring element tostring tk root tk subtrees rooted children order ordered tree note definition recursive denote string concatenation parenthetic representation tree figure   figure   figure   parenthetic representation tree figure   indentation breaks spaces clarity note technically speaking computa tions occur recursive calls node children algorithm algorithm preorder traversal primary action printing node contents occurs prior recursive calls method parentheticrepresentation code fragment   variation method tostringpreorder code fragment   implements definition output parenthetic string representation tree method tostringpreorder method parentheticrepresentation tostring method defined object fact view method kind tostring method tree objects  code fragment   algorithm parentheticrepresentation note operator concatenate strings explore modification code fragment   exercise   display tree fashion closely matching figure      postorder traversal tree traversal algorithm postorder traversal algorithm viewed opposite preorder traversal recursively traverses subtrees rooted children root visits root simila preorder traversal solve problem specializing action visit node preorder traversal tree ordered recursive calls children node order pseudo code postorder traversal code fragment   code fragment   algorithm postorder performing postorder traversal subtree tree rooted node  postorder aversal fact traversal method visit node visited nodes subtree rooted figure   figure   postorder traversal ordered tree figure   analysis running time postorder traversal analogous preorder traversal    total time spent nonrecursive portions algorithm proportional time spent visiting children node tree postorder traversal tree nodes takes time assuming visiting node takes  time postorder traversal runs linear time postorder traversal method tostringpostorder code fragment   performs postorder traversal tree method prints element stored node visited code fragment   method tostringpostorder performs postorder printing elements subtree node method implicitly calls tostring elements involved string concatenation operation  postorder traversal met hod solving problems compute property node tree computing property requires computed property children application illustrated   file tree external nodes represent files internal nodes represent directories   suppose compute disk space directory recursively sum ł size directory ł sizes files directory ł space children directories figure   computation ith apostorder traversal tree subtrees internal node traversed compute space adding sizes directory files contained space internal child computed recursive postorder traversals children recursive method computing disk space motivated   method diskspace code fragment   performs postorder traver sal file tree printing disk space directory associ ated internal node called root tree diskspace runs time number nodes provided auxiliary met hods size  time figure   tree figure   representing file showing size file directory inside node disk space directory internal node  code fragment   method diskspace prints disk space directory internal node file tree method calls auxiliary methods size defined turn size file directory node kinds traversals  preorder postorder traversals common ways visiting nodes tree imagine traversals traverse tree visit nodes depth visit nodes depth  consecutively numbering nodes tree visit traversal called level numbering nodes      binary trees binary tree ordered tree properties  node children  child node labeled left child child  left child precedes child ordering children node subtree rooted left child internal node called left subtree subtree binary tree proper node children people refer trees binary trees proper binary tree internal node children binary tree proper improper   class binary trees arises contexts represent number outcomes result answering series questions internal node question starting root left child current node depending answer question decision follow edge parent child eventually tracing path tree root external node binary trees decision trees external node tree represents decision questions ancestors answered leads decision tree proper binary tree figure   illustrates decision tree recommendations prospective investor figure   decision tree providing investment advice    arithmetic expression represented binary tree external nodes variables constants internal nodes operators figure   node tree ł node external variable constant ł node internal defined applying operation values children arithmetic expression tree prop binary tree operator takes operands unary operators negation improper binary tree figure   binary tree representing arithmetic expression tree represents expression           internal node labeled   recursive binary tree definition incidentally define binary tree recursive binary tree consists ł node called root storing element ł binary tree called left subtree ł binary tree called subtree discuss specialized topics binary trees    binary tree adt abstract data type binary tree specialization tree supports additional accessor methods left return left child error condition occurs left child return child error condition occurs child hasleft test left child  hasright test child    tree adt define specialized update methods binary trees update methods specific impleme ntations applications binary trees    binary tree interface model binary tree abstract data type extends tree adt adds specialized methods binary tree code fragment   simple interface define approach binary trees ordered trees iterable collection returned method children inherited tree interface stores left child child code fragment   interface binary tree binary tree adt interface binary tree extends interface tree code fragment      properties binary trees binary trees interesting properties dealing relationships heights number nodes denote set nodes tree  depth level dof binary tree level  node root level  nodes ildren root level  nodes figure   general level  nodes figure   maximum number nodes levels binary tree maximum number nodes levels binary tree grows exponentially tree simple observation derive properties relati height binary number nodes detailed justification properties left exercise   proposition   nonempty binary tree denote number nodes number external nodes number internal nodes height properties       ne2h  hni2h1  log   hn1 proper properties   h  n2h   ne2h  hni2h1  log     relating internal nodes external nodes proper binary tree addition binary tree properties relationship number inte rnal nodes external nodes proper binary tree proposition   nonempty proper binary tree external nodes internal nodes  justification justify proposition removing nodes dividing piles internal node pile external node pile pile initially external node pile node internal node pile cases case  node remove place external node pile external node pile node internal node pile case  node remove arbitrary external node parent internal node place external node pile internal node pile parent reconnect sibling figure   operation removes internal node external node leaves tree proper binary tree repeating operation eventually left final tree consisting single node note number external internal nodes removed respective piles sequence operations leading final tree rem ove node final tree place external node pile external node pile node internal node pile  figure   operation removes external node parent node justification proposition   note relationship hold general improper binary trees nonbinary trees interesting relationships hold explore exercise      linked structure binary trees general tree natural realize binary tree linked structure represent node position object figure  a fields providing references element stored position objects children parent root parent field null left child left field null child field null store number nodes variable called size linked structure representation binary tree figure  b figure   node linked structure representing binary tree  implementation binary tree node  interface btposition represent node binary tree interfaces extends position inheriting method element additional methods settin element stored node setelement setting returning left child setleft getleft child setright getright parent setparent getparent node class btnode code fragment   implements interface btposition object fields element left parent node reference element left child child parent code fragment   auxiliary class btnode implementing binary tree nodes  implementation linked binary tree structure code fragments   œ7  portions class linked binary tree implements binary tree interface code fragment   linked data structure class stores size tree reference btnode object root tree internal variables  addition binary tree interface methods linkedbinarytree methods including accessor method sibling returns sibling node update methods addroot create return node storing element root tree error occurs tree insertleft create return node storing element add left child return error occurs left child insertright create return node storing element add child return error occurs child remove remove node replace child return element stored error occurs children attach attach left subtrees external node error condition occurs external class linkedbinarytree constructor arguments returns binary tree starting pty tree build binary tree creating node method addroot repeatedly applying insertleft insertright methods attach method likewise dismantle binary tree remove operation ultimately reducing tree binary tree position passed argument methods class linkedbinarytree validity checked calling auxiliary helper method checkposition list nodes visited preorder traversal tree constructed recursive method preorderpositions error conditions throwing exceptions invalid position exception boundaryviolation exception emptytreeexception nonemptytreeexception code fragment   portions linked binary tree class implements binary tree interface continues code fragment     code fragment   portions linked binary tree class implements binary tree interface continues code fragment     code fragment   portions linked binary tree class implements binary tree interface continues code fragment    code fragment   portions linkedbinarytree class implements  binary tree interface continues code fragment   code fragment   portions linked binary tree class implements binary tree interface continued code fragment    performance linked binary tree implementation analyze running times methods class linked binary tree linked structure representation  ł methods size isempty instance variable storing number nodes  time ł accessor methods root left sibling parent  time ł method replace takes  time ł methods iterator positions implemented performing pre order traversal tree auxiliary method preorderpositions nodes visited traversal stored position list implemented class nodepositionlist    output iterator generated method iterator class nodepositionlist methods iterator positions time methods hasnext returned iterators  time ł method children appro ach construct returned iterable collection runs  time children node binary tree ł update methods insertleft insertright attach remove  time involve nstant time manipulation constant number nodes space required data structure tree nodes note object class btnode code fragment   node tree space requirement table   summarizes performance linked structure implementation binary tree table   running times methods node binary tree implemented linked structure methods hasnext iterators returned iterator positions iterator children iterator  time space usage operation time size isempty  iterator positions  replace  root parent children left sibling  hasleft hasright isinternal isexternal isroot  insertleft insertright attach remove     array list representation binary tree alternative representation binary tree based numbering nodes node integer defined ł root  ł left child node p ł child node p  numbering function level numbering nodes binary tree numbers nodes level increasing order left skip numbers figure   figure   binary tree level numbering general scheme  level numbering function suggests representa tion binary tree array list node element mentioned previous chapte realize array list extendable array    implementation simple efficient easily perform methods root parent left hasleft hasright isinternal isexternal isroot simple arithmetic operations numbers node involved operation leave details implementation exercise   array list presentation binary tree figure   figure   representation binary tree array list  number nodes maximum nodes array list size  element  node general number elements refer existing nodes fact worst case n justification left exercise     class binary ees called heaps  spite worst case space usage applications array list representation binary tree space efficient general binary trees exponential worst case space requirement representation prohibitive table   summarizes running times meth ods binary tree implemented array list incl ude tree update methods table   running times binary tree implemented array list denote number nodes denotes size space usage n worst case operation  time size isempty  iterator positions replace  root parent children left  hasleft hasright isinternal isexternal isroot     traversals binary trees general trees binary tree computations involve traversals building expression tree problem constructin expression tree fully parenthesized arithme tic expression size recall   code fragment   code fragment   algorithm buildexpression building expression tree assuming arithmetic operations binary variables parenthesized parenthesized subexpression operator middle algorithm stack scanning input expression variables operators parentheses ł variable operator create single node binary tree root stores push stack ł parenthesis pop trees stack represent subexpression e1 attach trees e1 push tree repeat expression processed time element stack expression tree total running time  code fragment   algorithm buildexpression preorder traversal binary tree binary tree viewed general tree preorder traversal general trees code fragment   applied binary tree simplify algorithm case binary tree traversal howe ver code fragment   code fragment   algorithm binarypreorder performing preorder traversal subtree binary tree rooted node  case general trees applications preorder traversal binary trees postorder traversal binary tree analogously postorder traversal general trees code fragment   specialized binary trees code fragment   code fragment   algorithm binarypostorder performing postorder traversal subtree binary tree rooted node expression tree evaluation postorder traversal binary tree solve expression tree evaluation problem problem arithmetic expression tree binary tree external node internal node arithmetic operation   compute arithmetic expression represented tree algorithm evaluateexpression code fragment   evaluates expression subtree rooted node arithmetic expression tree performing postorder traversal starting  case visit action cons ists performing single arithmetic operation note fact arithmetic expression tree proper binary tree code fragment   algorithm evaluateexpression evaluating expression represented subtree arithmetic expression tree rooted node expression tree evaluation application postorder traversal time algorithm evaluating arit hmetic expression represented binary tree nodes general postorder traversal postorder traversal binary trees applied evaluation problems size computation   inorder traversal binary tree additional traversal method binary tree inorder traversal traversal visit node recursive traversals left subtrees inorder traversal subtree rooted node binary tree code fragment   code fragment   algorithm inorder performing inorder traversal subtree binary tree rooted node  inorder traversal binary tree informally viewed visiting nodes left node inorder traversal visits nodes left subtree nodes subtree figure   figure   inorder traversal binary tree binary search trees set elements order relation set integers binary search tree proper binary tree ł internal node stores element denoted ł internal node elements stored left subtree equal elements stored subtree greater equal ł external nodes store element inorder traversal internal nodes binary search tree visits elements nondecreasing order figure    figure   binary search tree storing integers blue solid path traversed searching  blue dashed path traversed searching unsuccessfully  binary search tree set search traversing path tree starting root figure   internal node encountered comp search element stored search continue left subtree search terminates search continues subtree finally reach external node search terminates unsuccessfully othe binary search tree viewed binary decision tree recall   question asked internal node element node equal larger element searched correspondence binary decision tree motivates restricting binary search trees proper binary trees place holder external nodes note running time sear ching binary search tree proportional height recall proposition   height proper binary tree nodes small log   large   binary search trees efficient small height illustrate search operation binary search tree figure   study binary search trees   inorder traversal tree drawing  inorder traversal applie problem computing drawing binary tree draw binary tree algorithm assigns coordinates node rules figure   ł number nodes visited inorder traversal ł depth application convention common computer graphics coordinates increase left coordinates increase origin upper left corner computer screen figure   inorder drawing binary tree euler tour traversa binary tree tree traversal algorithms discussed forms iterators traversal visits nodes tree order guaranteed visit node uni tree traversal algorithms single framework relaxing requirement node visited traversal method called euler tour traversal study advantage traversal general kinds algorithms expressed easily euler tour traver sal binary tree informally defined walk start root left child viewing edges walls left figure   node encountered times euler tour ł left euler tour left subtree ł euler tours subtrees ł euler tour subtree  external visits happen time euler tour subtree rooted code fragment   figure   euler tour traversal binary tree code fragment   euler tour subtree binary tree rooted running time eule tour traversal node tree easy analyze assuming visit action takes  time spend constant time node tree traversal running time preorder traversal binary tree equivalent euler tour traversal node visit action occur encountered left likewise inorder postorder traversals binary tree equivalent euler tour node visit action occur encountered euler tour traversal extends preorder inorder postorder traversals perform kinds traversals suppose compute number descendents node node binary tree  start euler tour initializing counter  increment counter time visit node left determine number descendents node compute difference values counter visited left visited add  simple rule number descendents node subtree rooted counted visit left visit time method computing number descendents node application euler tour traversal print fully parenthesized arithmetic expression expression tree   algorithm printex pression code fragment   accomplishes task performing actions euler tour ł left action node internal print ł action print lue operator stored node ł action node internal print code fragment   algorithm printing arithmetic expression subtree arithmetic expression tree rooted    template method pattern  tree traversal methods examples interesting object oriented software design pattern template method pattern template method pattern describes generic computa tion mechanism specialized application redefining steps template method pattern design algorithm implements generic euler tour traversal binary tree algorithm called templateeulertour code fragment   code fragment   euler tour traversal subtree binary tree rooted node template method pattern called node method templateeulertour calls auxiliary methods phases traversal ł creates local variable type tourresult store intermediate computati fields left ł calls auxiliary method visitleft performs computations countering node left ł left child recursively cal left child stores returned left ł calls auxiliary method visitbelow performs computations countering node ł child recursively calls child stores returned  ł calls auxiliary method visitright performs computations countering node ł returns method templateeulertour viewed template skeleton euler tour code fragment   implementation class eulertour code fragment   implements euler tour traversal template method patter recursive traversal performed method eulertour auxiliary methods called eulertour place holders body return null class eulertour abstract instantiated abstract method called execute concrete subclass eulertour class tourresult fields left code fragment   class eulertour defining generic euler tour binary tree class realizes template method pattern specialized order interesting computation  class eulertour perform computation extend override auxiliary methods tasks illustrate concep arithmetic expression trees   assume arithmetic expression tree objects type  expressionterm node class expressionterm subclasses expressionvariable variables expressionoperator operators turn class expressionoperator subclasses arithmetic operators additionoperator multiplicationoperator method expressionterm overridden subclasses variable returns variable operator returns result applying operator operands operands operator set method setoperands expressionoperator code fragment   classes expressionterm expressionvariable expressionoperator additionoperator code fragment   classes variable generic operator addition operator arithmetic expression  code fragments     classes evaluateexpressiontour printexpressiontour specializing eulertour evaluate print arithme tic expression stored binary tree class evaluateexpressiontour overrides auxiliary method visitright computation ł external node set equal variable stored ł internal node combine left operator stored set equal result operation class printexpressiontour overrides methods visitleft visitbelow visitright approach pseudo code version code fragment    code fragment   class evaluateexpressiontour specializes eulertour evaluate expression arithmetic expression tree code fragment   class printexpressiontour specializes eulertour print expression arithmetic expression tree   exercises  source code exercises visit datastructures net reinforcement   questions refer tree figure   node root internal nodes descendents node cs016 ancestors node cs016 siblings node homeworks nodes subtree rooted node projects depth node papers height tree   arithmetic expression subtree binary tree figure      node binary tree impr oper represent proper binary tree nodes   minimum ximum number internal external nodes improper binary tree nodes   tree achieving worst case running time algorithm depth   justification proposition     running time algorithm height2 code fragment   called node distinct root   tree figure   refer code fragments     output tostringpostorder root output parentheticrepresentation root   modification parentheticrepresentation code fragment   length method string objects output parenthetic representation tree breaks spaces display tree text window  characters wide   draw arithmetic expression tree external nodes storing numbers     number stor distinct external node order internal nodes storing operator set root  operators return fractions operator    ordered tree node preorder traversal visits nodes orde postorder traversal argue occur likewise preorder traversal visits nodes reverse order postorder traversal argue occur   answer previous question case proper binary tree node   running time parentheticrepresentation root code fragment   tree nodes   draw single binary tree ł internal node stores single character ł preorder traversal yields examfun ł inorder traversal yields mafxuen   answer questions justify proposition   minimum number external nodes proper binary tree height justify answer maximum number exte rnal nodes proper binary tree height justify answer  proper binary tree height nodes log     values lower upper bounds attained equality   generalization euler traversal trees internal node children traversal compute height node tree   compute output algorithm tostringpostorder root code fragment   tree figure     illustrate execution algorithm diskspace root code fragment   tree figure     binary tree figure   output tostringpostorder root code fragment   output parentheticrepresentation root code fragment     binary tree figure   output tostringpostorder root code fragment    output printexpression root code fragment     pseudo code algorithm computing number descendents node binary tree algorithm based euler tour traversal   improper binary tree nodes sum depths external nodes minimum number external nodes maximum number external nodes log   binary tree nodes level numbering nodes    node n  binary tree nodes attains upper bound node   euler tour traversal compute level number defined    node binary tree   draw binary tree representation arithmetic expression             binary tree nodes realized array list level numbering nodes    pseudo code descriptions methods root parent left hasleft hasright isinternal isexternal isroot  creativity   node tree pre rank preorder traversal post rank postorder traversal depth depth desc number descendents counting derive formula defining post terms desc depth pre node   tree nodes store strings efficient algorithm computes prints node string stored height subtree rooted   design algorithms operations binary tree ł preordernext return node visited node preorder traversal ł inordernext return node visited node inorder traversal ł postordernext return node visited node postorder traversal worst case running times algorithms   time algorithm computing depth nodes tree number nodes   indented parenthetic representation tree variation parenthetic representation figure   indentation breaks illustrated figure   algorithm prints representation tree  figure   tree indented parenthetic representation   improper binary tree nodes sum depths external nodes configuration tree worst case asymptotic running time algorithm height1 code fragment     tree denote number internal nodes denote number external nodes internal node  children ni    clone proper binary tree attach method methods insertleft insertright   balance factor internal node proper binary tree difference heights left subtrees specialize euler tour traversal    print balanc factors internal nodes proper binary tree    ordered trees isomorphic holds ł ł consist single node ł number  subtrees ith subtree isomorphic ith subtree  design algorithm tests tw ordered trees isomorphic running time algorithm   extend concept euler tour ordered tree binary tree   define binary tree representation ordered general tree figure   ł node internal node ł external node sibling children external nodes ł internal node child left child ł node sibling child representation general ordered tree answer questions preorder traversal equivalent preorder traversal postorder traversal equivalent postorder traversal inorder traversal equivalent standard traversals  figure   representation tree binary tree tree binary tree dashed edges connect nodes siblings   mentioned exercise   postfix notation unambiguous writing arithmetic expression pare ntheses defined exp1 exp2 normal infix fully parenthesized expression operation postfix equivalent pexp  pexp2 pexp1 postfix version exp1 pexp2 postfix version exp2 postfix version single number variables number variable postfix version infix expression           efficient algorithm converting infix arithmetic expression equivalent postfix notation hint convert infix expression equivalent binary tree representation algorithm code fragment     proper binary tree define reflection binary tree node left child child child left child preorder traversal proper binary tree postorder traversal reflection reverse order   algorithm preorderdraw draws binary tree assigning coordinates node number nodes preceding preorder traversal depth algorithm  postorderdraw preorderdraw assigns coordinates postorder traversal drawing produced preorderdraw pairs crossing edges redraw binary tree figure   preorderdraw drawing produced postorderdraw pairs crossing edges redraw binary tree figure   postorderdraw   design algorithm drawing general trees generalizes inorder traversal approach drawing binary trees   visit action euler tour traversal denoted pair visited node left design analyze algorithm performing operation tournext returns visit action   variation linked data structure binary trees node object references node objects children node object parent implem entation methods binary tree data structure analyze time complexity methods   design alternative implementation linked data structure proper binary trees class nodes specializes subclasses internal node external node root node   linked data structure bina trees explore alternative design implementing iterator returned methods iterator positions iterator children iterator methods takes  time achieve constant time implementations methods hasnext iterators returned    tree nodes define lowest common ancestor lca nodes lowest node descendents node descendent nodes efficient algorithm finding lca running time algorithm   binary tree nodes node dv denote depth distance nodes dv dw du lowest common ancestor lca diameter maximum distance nodes efficient algorithm finding diameter running time algorithm   suppose node binary tree labeled level numbering design fast method determining lowest common ancestor lca nodes node compute level numbering label   justify bounds table   providing detailed analysis running times methods binary tree implemented array list realized array   justify table   summarizing running time methods tree represented linked structure providing method description implementation analysis running time   nonrecursive method eval uating binary tree representing arithmetic expression   binary tree nodes define roman node node number descendents left subtree differ number descendents subtree  linear time method finding node roman node descendents roman nodes    nonrecursive method perf orming euler tour traversal binary tree runs linear time stack   pseudo code nonrecursive method performing order traversal binary tree linear time   binary tree nodes realized array list linked structure linear time algor ithm methods binary tree interface traverse nodes increasing values level numbering function    traversal level order traversal   path length tree sum depths nodes linear time method mputing path length tree binary   define internal path length tree sum depths internal nodes likewise define external path length tree sum depths external nodes proper binary tree nodes  projects   implement binary tree adt array list   implement tree adt linked structure   write program draws binary tree   write program draws general tree    write program input display person family tree   implement tree adt bina tree representation exercise   reuse linkedbinarytree implementation binary tree   slicing floorplan divides rectangle horizontal vertical sides horizontal vertical cuts figure  a slicing floorplan represented proper binary tree called slicing tree internal nodes represent cuts external nodes represent basic rectangles floorplan decomposed cuts figure  b compaction problem slicing floorplan defined assume basic rectangle slicing floor plan assigned minimum width minimum height compaction problem smallest height width rectangle slicing floorplan compatible minimum dimensions sic rectangles problem requires assignment values node slicing tree design data structure slicing floorplans supports operations ł create floorplan consisting single basic rectangle ł decompose basic rectangle horizontal cut ł decompose basic rectangle vertical cut ł assign minimum height dth basic rectangle ł draw slicing tree floorplan ł compact draw floorplan figure   slicing floorplan slicing tree floorplan    write program play tic tac toe effectively    create game tree tree node corresponds game configuration case representation tic tac toe board root node corresponds initial configuration internal node children correspond game states reach game state single legal player player player nodes depths correspond moves nodes odd depths correspond moves external nodes final game states depth explore score external node ith good state player large games chess heuristic scoring function small games tic tac toe construct entire game tree score external nodes    indicating player win draw lose configuration good algorithm choosing moves minimax algorith assign score internal node represents turn compute score maximum scores children corresponds optimal play internal node represents turn compute score minimum scores children corresponds optimal play   write program takes input fully parenthesized arithmetic expression converts binary expression tree program display tree print asso ciated root additional challenge leaves store variables form initially  updated interactively program update printed root expression tree    write program visualizes euler tour traversal proper binary tree including movements node node actions visits left illustrate program compute display preorder labels inorder labels postorder labels ancestor counts descendent counts node tree time   arithmetic expression code code fragments   œ7  work integer expressions additi operator write program evaluation arbitrary expressions number type object chapter notes discussions classic preorder inorder postorder tree traversal methods knuth fundamental algorithms book  euler tour traversal technique parallel algorithms communit introduced tarjan vishkin  discussed  karp ramachandran  algorithm drawing tree generally considered folklore graph drawing algorithms eader interested graph drawing referred works tamassia  battista  puzzler exercise   communicated micha sharir  chapter  priority queues contents   priority queue abstract data type     keys priorities total order relations      entries comparators     priority queue adt     sorting priority queue    implementing priority queue list     implementation unsorted list     implementation sorted list     selection sort insertion sort    heaps      heap data structure     complete binary trees representation     implementing priority queue heap     heap implementation     heap sort     heap construction    adaptable priority queues     methods adaptable priority queue adt      location aware entries     implementing adaptable priority queue    exercises  datastructures net   priority queue abstract data type priority queue abstract data type storing collection prioritized elements supports arbitrary element inse rtion supports removal elements order priority element priority removed time adt fundamentally position based data structures discussed previous chapters stacks queues deques lists trees data structures store elemen specific positions positions linear arrangement elements determined insertion deletion operations performed priority queue adt stores elements priorities exposes notion position user    keys priorities total order relations applications commonly require mpare objects parameters properties called keys assigned object collection formally define key object assigned element specific attribute element identify weigh element note key assigned element typically user application key represent property elem ent originally possess key application assigns ement unique application change ement key compare companies earnings number employ ees parameters key company depending extract likewise compare restaurants critic food quality rating average entrée price achieve generality key type application  examples airpor key comparisons single numerical price length weight speed key complex operty quantified single number prior ity standby passengers determined account host factors including frequent flyer status fare paid check time applications key object object instance variable storing list price book weight car applications key object object assigned key application quality rating stoc financial analyst priority assigned standby passenger gate agent comparing keys total orders priority queue comparison rule contradict order comparison rule denote robust define total order relation comparison rule defined pair keys satisfy properties ł reflexive property ł antisymmetric property k1 k2 k2 k1 k1 k2 ł transitive property k1 k2 k2 k3 k1 k3 comparison rule satisfies operties lead comparison contradiction fact su rule defines linear ordering relationship set keys finite collection elements total order defined notion smallest key kmin defined key kmin key collection priority queue collection elements called values key ovided time element inserted key pair inserted priority queue called entry priority queue priority queue fact keys determine priority pick entries removed fundamental methods priority queue ł insert insert key ł removemin return remove entry smallest key entry key equal entry people refer removemin method extractmin method stress method simultaneously removes returns entry applications insert  removemin operations play role application   suppose flight fully booked hour prior departure possibility cancellations airline maintains priority queue standby passengers hoping seat priority standby passenger determined airline account fare paid frequent flyer status time passenger inserted priority queue standby passenger reference inserted priority queue insert operation requests fly standby shortly flight departure seats minute cancellations airline removes standby passenger priority priority queue aremovemin operation person board process repeated seats filled priority queue    entries comparators issues left undetermined point ł track asso ciations keys values ł compare keys determine smallest key answering questions involves interesting design patterns definition priority queue implicitly special kinds objects answer questions entry comparator discuss subsection entries entry association key entry simply key pair entries priority queue track associating keys values entry general object oriented design pattern composition pattern defines single object composed objects pattern priority queue define entries stored priority queue pairs consisting key pair simplest composition combin objects single pair object implement concept define ass stores objects instance variables methods access update variables code fragment   implementation composition pattern entries storing pairs priority queue realize composition interface called entry util  package includes entry interface kinds compositions include triples stor objects quadruples store objects code fragment   interface entry storing key pairs priority queue comparators issue priority adt define total order relation comparing keys number design choices compare keys point possibility concrete implement priority queue key type comparing keys types problem approach general requires create lot code alternative strategy require keys compare solution write general priority queue class store instances key class implements kind comparable interface encapsulates usual mparison methods solution improvement speciali zed approach write single priority queue class handle lots types keys contexts solution keys keys compared examples follow   keys     keys integer objects compared usual manner   keys string objects compared lexicographically   geometric algorithm compare points plane coordinate ifx sort left algorithm compare coordinate ify sort principle pertaining concept point points compared  coordinate ways comparing points defined compare distances origin general reusable priority queue rely keys provide comparison rules special comparator objects external keys supply comparison rules comparator object compares tw keys assume priority queue comparator constructed imagine ability priority queue comparator compare keys comparator perform comparison programmer write general priority queue implementation works rrectly wide variety contexts comparator adt formally comparator adt streamlined comparison mechanism based single method takes compares reports error keys incomparable compare returns integer    error occurs compared standard interface util comparator corresponds comparator adt offers general dynamic reusable compare objects includes equals method comparing comparator comparators code fragment   provide comparator tw dimensional points code fragment   composition pattern code fragment   comparator dimensional points based lexicographic order  code fragment   class representing points plane integer coordinates    priority queue adt composition comparator patterns define priority queue adt support method priority queue size return number entries isempty test min return remove entry smallest key error condition occurs insert insert key return entry storing error condition occurs invalid compared keys removemin remove return entry smallest key error condition occurs  mentioned primary methods priority queue adt insert removemin operations methods query operation min generic collection operations size isempty note priority queue multiple entries key priority queue interface interface called priorityqueue priority queue adt code fragment   code fragment   interface priority queue adt obvious priority queue adt simpler sequence adt simplicity fact elements priority queue inserted removed based keys elements inserted removed sequence based positions indices   table series operations effects initially prio rity queue denote entry object returned method insert priority queue column deceiving entries sorted key required apriority queue operation output priority queue  insert  e1   insert     insert      insert  e4      min     removemin    size    removemin e1   removemin  e4  removemin util priorityqueue class priority queue interface built include class util priorityqueue implements util queue interface adding removing elements fifo policy standard queue policy util priorityqueue class processes entries priority priority defined comparator object passed queue constructor defined natural ordering elements stored queue util priorityqueue based util queue interface define simple correspondence methods class priority queue adt table   assuming class pqentry implements entry interface table   methods priority queue adt methods class util priorityqueue assume comparator pqentry objects essentially comparator keys priority queue note util priorityqueue pair methods main operation methods functionality minor differences deal boundary conditions remove priority queue priority queue adt classjava util priorityqueue  size size isempty isempty insert offer pqentry add pqentry min peek element removemin poll remove    sorting priority queue application priority queue sorting collection elements compared total order relation rearrange incr easing order nondecreasing order ties algorithm sorting priority queue called priorityqueuesort simple consists phases  phase elements initially priority queue series insert operations element  phase extract elements nondecreasing order series nremovemin operations putting order pseudo code algorithm code fragment   assuming sequence pseudo code type collection array list node list algorith works correctly priority queue matter implemented running time algorithm determined running times operations insert removemin depend implemented priorityqueuesort considered sorting scheme sorting algorithm priority queue implemented priorityqueuesort scheme paradigm popul sorting algorithms including selection sort insertion sort heap sort discuss chapter  code fragment   algorithm priorityqueuesort note elements input sequence serve keys priority queue   implementing priority queue list implement priority queue storing entries list chapter   provide realizations depending entries sorted key anal yzing running time methods priority queue implemented list assume comparison keys takes  time    implementation unsorted list implementation priority queue storing entries list implemented doubly linked list elements entries key fast insertions slow removals simple performing operation insert create entry object add list executing method addlast implementation method insert takes  time insertion algorithm implies unsorted inserting entries account ordering keys consequence perform operation min removemin inspect elements list entry minimum methods min removemin time number entries  time method executed methods time proportional case require searching entire list minimum key entry notation    methods time finally implement methods size isempty simply returning output methods executed list unsorted list implement priority queue achieve constant time insertion linear time search removal    implementation sorted list alternative implementation priority queue list time store entries sorted key represent priority queue list entries sorted nondecreasing keys element entry smallest key fast removals slow insertions implement method min case simply accessing element list method likewise implement removemin method remove assuming implemented doubly linked list operations min removemin  time sorted lis simple fast implementations priority access removal methods benefit cost method insert requires scan list position insert entry implementing insert method takes time number entries time method executed summary sorted list implement priority queue insertion runs linear time finding removing mini mum constant time comparing list based implementations table   compares running times thods priority queue realized sorted unsorted list spectively interesting trade list implement priority queue adt unsorted list fast insertions slow queries deletions sorted list fast queries deletions slow insertions table   worst case running times methods priority queue size realized  unsorted sorted list assume list implemented doubly linked list space requirement method unsorted list sorted list size isempty   insert  min removemin  implementation code fragments     implementation priority queue based sorted node list impl ementation nested class called myentry implement entry interface    auxiliary method checkkey throws invalidkeyexception key compared comparator priority queue class defaultcomparator realizes comparator natural ordering code fragment   code fragment   portions class sortedlistpriorityqueue implements priorityqueue interface nested class myentry implements entry interface continues code fragment    code fragment   class defaultcomparator implements comparator natural ordering default comparator class sortedlistpriorityqueue  code fragment   portions class sortedlistpriorityqueue implements priorityqueue interface continued code fragment        selection sort insertion sort recall priorityqueuesort scheme introduced    unsorted sequence elements sort priority queue phases phase  insert elements phase  repeatedly remove elements removemin method selection sort implement unsorted list phase  priorityqueuesort takes time insert element  time phase  running time removemin operation proportional size bottleneck computation repeated election minimum element phase  reason algorithm selection sort figure   bottleneck phase  repeatedly remove entry smallest key priority queue size starts incrementally decreases removemin  removemin operation takes time takes time  nth operation takes time  total time needed phase proposition   phase  takes time entire selection sort algorithm figure   execution selection sort sequence         insertion sort implement priority queue sorted list improve running time phase  operation removemin takes  time phase  bottleneck running time worst case sert operation takes time proportional size sorting algorithm insertion sort figure   bottleneck sorting algorithm involves repeated insertion element position sorted list figure   execution insertion sort sequence        phase  repeatedly remove element insert scanning list implementing correct place element phase  repeatedly perform removemin operations returns element list implementing add element analyzing running time phase  insertion sort note  analyzing running time phase  insertion sort note recalling proposition   phase  runs time entire insert ion sort algorithm alternatively change definition insertion sort insert elements starting prio rity queue list ase  case performing insertion sort sequence sorted time running time insertion sort case number inversions sequence number pairs elements start input sequence wrong relative order   heaps implementations priorityqueuesort scheme presented previous improving running time priority queue sorting algorithm selection sort achieves fast running time phase  slow phase  algorithm insertion sort slow phase  achieves fast running time phase  balance running times phases speed running time sorting fact achieve priority queue implemen tation discussed  efficient realization priority queue data structure called heap data structure perform sertions removals logarithmic time improvement list based implementations discussed   fundamental heap achie ves improvement abandon idea storing entries list approach storing entries binary tree    heap data structure heap figure   binary tree stores collection entries nodes satisfies additional prope rties relational property defined terms keys stored structural property defined terms nodes assume tal order relation keys comparator relational property defined terms keys stored heap order property heap node root key stored greater equal key stored parent consequence heap order property keys encountered path root external node nondecreasing order minimum key stored root key informally heap heap data structure heap data structure defined memory heap    time enviro nment supporting programming language define comparator opposite standard total order relation keys compare    root heap stores largest key versati lity essentially free comparator pattern defining minimum key terms comparator minimum key rever comparator fact largest figure   heap storing  entries integer keys node storing entry   loss generality assume interested minimum key root heap sake efficiency clear heap small height enforce requirement insisting heap satisfy additional structural property complete define structural property definitions recall    level binary tree set nodes tthat depth nodes level left encountered inorder traversal node left subtree subtree binary tree figure   node storing entry  left node storing entry  standard drawing binary tree left relation visualized relative horizontal placement nodes complete binary tree property heap height complete binary tree levels     maximum number nodes level i nodes   level  internal nodes left external nodes node child left child insisting heap complete identify node heap root node define deepest external node figure   height heap denote height defining node node level nodes level left insisting complete consequence proposition    proposition   heap storing entries height logn justification fact complete number nodes    h1  h   h lower bound achieved node level addition complete number nodes    h h   upper bound achieved level h nodes number nodes equal number entries h h   logarithms sides inequalities log log   integer inequalities imply logn proposition   consequence implies perform update operations heap tim proportional height operations logarithmic time turn problem efficiently perform priority queue methods heap    complete binary trees representation discuss complete bina trees represented  complete binary tree adt abstract data type complete binary supports methods binary tree adt    methods add add return external node storing element tree complete binary tree node remove remove node return element update operations guaran tees complete binary tree figure   cases add remove add remove ł level add inserts node level mos node level node height remains ł level add inserts node left child left node level height increases figure   examples operations add remove complete binary tree denotes node inserted add deleted remove trees performing add operations trees likewise trees performing remove operations trees  array list representation complete binary tree array list binary tree representation    suitable complete binary tree recall implementation nodes stored array list node element equal level number defined ł root  ł left child node p ł child node p  implementation nodes contiguous indices range  node number nodes figure   examples illustrating property node figure   examples showing node heap nodes level number heap node level heap node level array list representation array list representation  simplifications representing complete binary tree array list aid implementation thods add remove assuming array expansion methods add remove performed  time simply involve adding moving element array list array list  elements element  place holder extenda ble array grows shrinks implementation array list    exercise   space array list representation complete binary tree nodes operations add remove  amortized time implementation complete binary tree represent complete binary tree adt interface completebinarytree code fragment   provide class arraylistcompletebinarytree implements completebinarytree interface array list supports methods add remove  time code fragments   œ8  code fragment   interface completebinarytree complete binary tree code fragment   class arraylistcompletebinarytree implementing interface completebinarytree  util arraylist continues code fragment   code fragment   class arraylistcompletebinarytree implementing complete binary tree adt continues code fragment     code fragment   class arraylistcompletebinarytree implementing complete binary tree adt methods children positions continued code fragment        implementing priority queue heap discuss implement prior ity queue heap heap based representation priority queue consists figure   ł heap complete binary tree internal nodes store entries heap order property satisfied assume implemented array list    internal node denote key entry stored ł comp comparator defines total order relation keys data structure methods size isempty  time usual addition method min easily performed  time accessing entry stored root heap hich  array list insertion perform insert priority queue implemented heap store entry add node operation add node node stores entry action tree complete violate heap order property node root priority queue insertion compare key key stored parent heap order property satisfied algorithm terminates restore heap order property locally achieved swapping entries stored figure  c swap entry level heap order property vi olated continue swapping violation heap order property occurs figure  e figure   illustration heap based implementation priority queue  figure   insertion entry key  heap figure   initial heap performing operation add swap locally restore partial order operty swap final swap  upward movement newly serted entry swaps conventionally called heap bubbling swap resolves violation heap order property propagates level heap worst case heap bubbling entry root heap figure   worst case number swaps performed execution method insert equal height logn proposition   removal  turn method removemin priority queue adt algorithm performing method removemin heap illustrated figure   entry sma llest key stored root entry smallest key internal node simply delete node action disrupt binary tree structure access node copy entry root delete node performing operation remove complete binary tree adt figure  a heap bubbling removal complete violate heap order property node root heap order property trivially satisfied algorithm terminates distinguish cases denotes root ł child left child ł children child smallest key heap order property satisfied algorithm terminates restore heap order property locally achieved swapping entries stored figure  c note swap sibling swap perform restores heap order property node children violate property continue swapping violation heap order property occurs figure  e downward swapping process called heap bubbling swap resolves violation heap order property propagates level heap worst case entr moves level figure   number swaps performed execution method removemin worst case equa height heap logn proposition   figure   removal entry smallest key heap deletion node entry stored root swap locally restore heap order property swap final swap  analysis table   running time priori ty queue adt methods heap implementation priority queue assuming keys compared  time heap implemented array list linked structure  table   performance priority queue realized heap turn implemented array list linked structure denote number entries priority queue time method executed space requirement running time operations insert removemin worst case array list implementation heap amortized linked representation operation time size isempty  min  insert logn removemin logn short priority queue adt methods performed  logn time number entries time method executed analysis running time methods based ł heap nodes storing reference entry ł operations add remove  amortized time array list representation log worst case time ł worst case heap dow heap bubbling perform number swaps equal height ł height heap logn complete proposition    conclude heap data structure efficient realization priority queue adt independent heap implemented linked structure array list heap based implementation achieves fast running times insertion removal list based priority queue implementations cons equence efficiency heap based implementation speed priority queue sorting faster list based insertion sort selection sort algorithms    heap implementation implementation heap based prio rity queue code frag ments     aid modularity delegate maintenance structure heap complete binary tree code fragment   class heappriorityqueue implements priority queue heap nested class myentry entries priority queue form elements heap tree continues code fragment    code fragment   methods min insert removemin auxiliary methods class heappriorityqueue continues code fragment    code fragment   remaining auxiliary methods class heappriorityqueue continued code fragment       heap sort  observed realizing priority queue heap advantage methods prior ity queue adt logarithmic time realization suitable applications fast running times sought priority queue methods priorityqueuesort sorting scheme    priority queue sort sequence elements phase  insert operation  takes  logi time heap entries operation perf ormed likewise phase  removemin operation  runs time  log  heap  entries time operati performed phase takes nlogn time entire priority queue sorting algorithm runs nlogn time heap implement prio rity queue rting algorithm heap sort performance summarized proposition proposition   heap sort algorithm sorts sequence elements nlogn time assuming elem ents ofs compared  time stress nlogn running time heap sort considerably running time selection insertion sort    implementing heap sort place sequence sorted implem ented array speed heap sort reduce space requirement constant factor portion sequence store heap avoiding external heap data structure accomplished modifying algorithm  reverse comparator corresponds heap entry largest key time execution algorithm left portion  store entries heap portion  store elements sequence elements indices   provide array list representation heap ith modified level numbers starting   element greater equal children indices   k   phase algorithm start heap boundary heap sequence left step time step  expand heap adding element   phase algorithm start sequence boundary heap sequence left step time step  remove maximum element heap store  variation heap sort place small space addition sequence transferring elements sequence ack simply rearrange lustrate place heap sort figure   general sorting algorithm place sma memory addition sequence storing objects sorted figure   steps phase  place heap sort heap portion sequence highlighted blue draw sequence binary tree view heap tree constructed place algorithm     heap construction analysis heap sort algorithm construct heap storing entries nlogn time successive insert operations heap extract entries order nondecreasing key key pairs stored heap advance ternative construction method runs time method observing included constructors class implementing heap based priority queue simplicity exposition heap construction assuming number keys integer type h   heap complete binary tree level heap height log   viewed nonre  cursively heap construction consists  log  steps  step figure  a construct   elementary heaps storing entry  step figure  b form   heaps stor ing entries joini pairs elementary heaps adding entry entry root swapped entry stored child preserve heap order property  step figure  d form   heaps storing  entries joining pairs  entry heaps constructed previous step adding entry entry initially root heap bubbling preserve heap order property generic ith step  form  i heaps storing i  entries joining pairs heaps storing i1  entries constructed previous step adding entry entry initially root heap bubbling preserve heap order property  step figure  f form final heap storing entries joining heaps storing   entries constructed previous step adding entry entry initially root heap bubbli preserve heap order property illustrate heap construction figure    figure   construction heap  entries constructing  entry heaps level combine heaps  entry heaps  entry heaps create final heap paths heap bubblings highlighted blue simplicity key node entire entry  recursive heap construction heap cons truction recursive algorithm code fragment   passing list storing key pairs build heap code fragment   recursive heap construction  heap construction asymptotically faster incrementally insert ing keys initially heap proposition proposition   construction heap entries takes time assuming keys compared  time justification analyze heap cons truction visual proach illustrated figure   final heap node denote subtree rooted worst case time forming recursively formed subtrees rooted children proportional height worst case occurs heap bubbling traverses path node path node inorder successor external node path starts child leftward reaches external node path node note path heap bubbling forming size number nodes equal height forming takes time proportional size ofp worst case total running time heap construction proportional sum sizes paths nodes observe node distinct root belongs paths path path parent figure   root belongs path sum sizes paths internal nodes n  conclude construction heap takes time  figure   visual justification linear running time heap struction paths internal nodes highlighted alternating colors path root consists nodes storing keys     path child root consists internal nodes storing keys    summarize proposition   states running time phase heap sort reduced running time phase heap sort asymptotically nlogn nlogn worst case justify lower bound chapter  conclude chapter discussing design pattern extend priority queue adt additional functionality   adaptable priority queues methods priority queue adt    sufficient basic applications priority queues sorting situations additional methods scenarios refer standby airline passenger application ł standby passenger pessimistic titude tired waiting decide leave ahead boarding time requesting removed  waiting list remove priority queue entry passenger operation removemin suitable purpose passenger leaving priority operation remove removes arbitrary entry ł standby passenger finds gold equent flyer card agent priority modifi achieve change priority operation replacekey replaces key entry priority queue ł finally standby passenger notices misspelled ticket asks corrected perform ange passenger record operation replacevalue replaces entry priority queue    methods adaptable priority queue adt scenarios motivate definition adt extends prior ity queue adt methods remove replacekey replacevalue adaptable priority queue supports methods addition priority queue adt remove remove return entry replacekey replace return key entry error conditi occurs invalid compared keys replacevalue replace return entry   table series operations effects initially adaptable priority queue operation output insert  e1   insert    insert     min    getkey      remove  e1   replacekey     replace   remove      location aware entries order implement methods remove replacekey replacevalue adapt priority queue mechanism finding position entry entry passed argument methods position storing data structure imple menting doubly linked list heap position called location entry searching location entry augment entry object instance variable type position storing location plementation entry track position called location aware entry summary description location aware entries sorted list heap implementations adapta ble priority queue provided denote number entries priori ty queue time operation formed ł sorted list implementation implementation afte entry inserted set location entry refer position list entry update location entry position list operations remove replacevalue  time position entry  time location reference stored entry operation replacekey runs time modification key entry require moving entry position list preserve ordering keys location aware entries increases running time standard priority queue operations constant factor ł heap implementation implementation entry inserted set location entry refer node heap entry update location entry node heap swaps wn heap heap bubbling operation replacevalue takes  time position entry  time location reference stored entry operations remove replacekey logn details explored exercise   location aware entr ies increases running time operations insert removemin constant factor overhead location aware entries uns orted list implementation explored exercise   performance adaptable priority queue implementations  performance adaptable priority queue implemented data structures location aware entries summarized table   table   running times methods adaptable priority queue size realized unsorted list sorted list heap space requirement method unsorted list sorted list heap size isempty    insert  logn min   removemin  logn  remove   logn replacekey  logn replacevalue       implementing adaptable priority queue code fragment     implementation adaptable priority queue based sorted list implementa tion extending class sortedlistpriorityqueue code fragment   code fragment   realize loca tion aware entry extending regular entry code fragment   implementation adaptable priority queue sorted list storing location aware entries class sortedlistadaptablepriori tyqueue extends class sortedlistpriorityqueue code fragment   imple ments interface adaptablepriorityqueue continues code fragment    code fragment   adaptable priority queue implemented sorted list storing location aware entries continued code fragment    nested class locationawareentry realizes location aware entry extends nested class myentry sortedlistpriorityqueue code fragment       exercises source code exercises visit datastructures net reinforcement   suppose label node binary tree key equal preorder rank circumstances heap   output followi sequence priority queue adt methods insert  insert  insert  insert  removemin insert  insert  removemin removemin insert  remove min insert  removemin removemin   airport developing computer simula tion air traffic control handles events landings takeoffs event time stamp denotes time event occurs mulation program efficiently perform undamental operations ł insert event time stamp add future event ł extract event smallest time stamp determine event process data structure operations   correct reverse comparator priority queue adt retrieve remove entry maximum key time confusing entry maximum key returned method named removemin write short adapter class priority queue comparator implement priority queue concentrates element maximum key methods names removemax    illustrate execution selection sort algorithm input sequence             illustrate execution insertion sort algorithm input quence previous problem   worst case sequence elements insertion sort insertion sort runs time sequence   nodes heap entry largest key stored   defining relation left nodes binary tree tion    preorder traversal inorder traversal postorder traversal   illustrate execution heap sort algorithm input sequence             complete binary tree node stores entry  level number tree heap   explain case node child left child considered description heap bubbling   heap storing entries distinct keys pre order traversal yields entries increasing decreasing order key inorder traversal postorder traversal   heap storing  entries array list representation complete binary tree sequen indices array list  visited preorder traversal inorder traversal postorder traversal   sum appears analysis heap sort nlogn   claims preorder traversal heap list keys nonde creasing order draw heap proves wrong   hillary claims postorder traversa heap list keys increasing order draw heap proves wrong   steps algorithm removing key  heap figure     steps algorithm placing key   heap figure     draw heap keys odd numbers   repeats insertion entry key  heap bubbling proceed child root replacing child key    complete figure   showing steps place heap sort algorithm array asso ciated heap step   pseudo code description nonr ecursive place heap sort algorithm    group children play game called unmonopoly turn player money half money player money data struct ure play game efficiently creativity   online computer trading stoc process orders form buy  shares sell  shares buy order processed existing sell order price likewise sell order processed existing buy order price buy sell order entered processed wait future order processed scheme buy sell orders entered logn time independent processed   extend solution previous problem users allowed update prices buy sell orders processed   write comparator nonnegative intege determines order based number  integer binary expansion number  binary representation number  binary representation   implement stack adt priority queue additional integer instance variable   implement standard queue adt priority queue additional integer instance variable   implementation priority queue based sorted array implementation achieves  time operations min removemin time operation insert    place version lection sort algorithm  space instance variables addi tion input array   assuming input sorting problem array implement insertion sort algorithm array additional base type variables   implement heap sor algorithm integer variables addition input array   sequence insertions heap requires nlogn time process   alternative method finding node insertion heap store node external node reference external node wrapping node lower level external node maintain references  time operation priority queue adt assuming implemented linked structure   implementation complete binary tree linked structure reference node update reference node operations add remove logn time current number nodes handle cases illustrated figure   figure   updating node complete binary tree operation add remove node node operation add operation remove node node operation add operation remove    represent path root node binary tree binary string  left child  child path root node storing  heap figure  a represented  design log time algorithm finding node complete binary tree nodes based representation algorithm implementation complete binary linked structure reference node   heap key algorithm compute entries key equal heap figure  a query  algorithm report entries keys      order algorithm time proportional number entries returned   provide justification time bounds table     tamarindo airlines firs class upgrade coupon log frequent flyers based number miles accumulated total number airlines frequent flyers algorithm runs nlogn time sorts flyers nu mber miles flown scans sorted list pick log flyers algorithm identifies log flyers time   develop algorithm computes kth smallest element set distinct integers klogn time    suppose binary trees hold entries satisfying heap order property method combining tree internal nodes hold union entries andt2 satisfy heap order property algorithm time h1 h1 respective heights   alternative analysis heap construction showing summation  positive integer   alternate description place heap sort algorithm standard comparator reverse   efficient algorith performing operations remove replacekey adaptable priority queue realized unsorted list location aware entries   efficient algorith performing operations remove replacekey adaptable priority queue realized heap location aware entries   set points plane distinct integer coordinates complete binary tree storing points external nodes points ordered left creasing coordinates node denote subset consisting points stored subtree rooted root define point maximum coordinate node define point highest coordinate highest coordinate parent point exists labeling turns priority search tree linear time algorithm turning priority search tree projects    implementation prior ity queue based unsorted list   write applet stand graphical program animates insertion sort selection sort algorithms animation visu alize movement elements correct locations   write applet stand graphical program animates heap program support priority queue operations visualize swaps heap heap bubblings extra vi sualize heap construction   implement heap sort algorithm heap construction   implement place heap sort algor ithm experimentally compare running time standard heap sort place   implement heap based priority queue supports addi tional operation linear time replacecomparator replace current comparator hint utilize heap construction algorithm   develop implementation adap table priority queue based unsorted list supports location aware entries   develop implementation adap table priority queue based heap supports location aware entries   write program process quence stock buy sell orders exercise      main applications priority queues operating systems scheduling jobs cpu project build program schedules simulated cpu jobs program loop iteration corresponds time slice cpu job assigned priority integer betwee  highest priority  lowest priority inclusive jobs waiting pro cessed time slice cpu work job highes priority simulation job length integer   inclusive indicating numb time slices needed process job simplicity assume obs interruptedšonce scheduled cpu job runs number time slices equal length simulator output job running cpu time slice process sequence commands time slice form add job length priority job slice chapter notes knuth book sorting searching  describes motivation history selection sort insertion sort heap sort algorithms heap sort algorithm williams  linear time heap construction algorithm floyd  additional algorithms analyses heaps heap sort variations papers bentley  carlsson  gonnet munro  mcdiarmid reed  schaffer sedgewick  design pattern location aware entries  appears  chapter  maps dictionaries contents   map abstract data type     simple list based map implementation    hash tables     bucket arrays     hash functions     hash codes      compression functions     collision handling schemes     hash table implementation     load factors rehashing     application counting word frequencies    dictionary abstract data type     list based dictionaries audit trails     hash table dictionary implementation      ordered search tables binary search    skip lists     search update operations skip list     probabilistic analysis skip lists    extensions applications dictionaries     supporting location aware dictionary entries     ordered dictionary adt     flight databases maxima sets     exercises  datastructures net   map abstract data type map store elements located keys motivation searches element typically stor additional search key ly search key map stores key pairs entries key addition map adt requires key unique ssociation keys values defines mapping order achieve highest vel generality keys values stored map object type figure   map storing student records student address grades key student number applications key map storing prime numbers number key figure   conceptual illustration map adt keys labels assigned values diskettes user entries lab eled diskettes inserted map file cabinet keys retrieve remove values  case key unique identifier assigned appli cation user object map situations key viewed kind unique address object serves kind location exam ple store student records student objects keys disallow students student key object viewed address object maps referred associative stores key object determines location data structure map adt map stores collection objects viewed collection key pairs adt map supports methods size return number entries isempty test mcontains entry key equal return return null entry key equal add entry return null replace existing entry key equal return  remove remove entry key equal return entry return null keys return iterable collection cont aining keys stored keys iterator returns iterator keys values return iterable collection values sociated keys stored values iterator turns iterator values entries return iterable collection key entries entries iterator returns iterator entries operations remove performed map entry key equal convention returning null special sentinel   disadvantage null sentinel choice create ambiguity entry null null map choice throw exception requests key map exception normal map throwing catching excepti typically slower test sentinel sentinel efficien case conceptually null sentinel missing key   series operations initially map storing entries integer keys single character values operation output map isempty true  null    null    null     null                null          size      remove      remove     null   isempty false   maps util package package util includes interface map adt called util map interface defined implementing class enforces unique keys includes methods map adt method names couple cases correspondences map adt util map interface table   table   correspondences methods map adt methods util map interface supports methods map adt methods util map methods size size isempty isempty  remove remove keys keyset values values entries entryset    simple list based map implementation simple implementing map store entries list implemented doubly linked list performing fundamental methods remove involves simple scans entry key pseudo code performing methods map code fragment   list based map implementation simple efficient small maps fundamental methods takes time map entries method involves searching entire list worst case faster code fragment   algorithms fundamental map methods list    hash tables keys values map typically thought addresses values examples su applications include mpiler symbol table registry environment variables structures consis collection symbolic names serves address properties variable type efficient ways implement map circumstances hash table worst case running  time map operations entry hash table hash table perform operations  expected time general hash table consists major components bucket array hash function    bucket arrays bucket array hash table array size cell thought bucket collection key pairs integer defines capacity array keys integers distributed range   bucket array needed entry key simply inserted bucket figure   save space bucket replaced null object figure   bucket array size  entries       q keys unique integers range   bucket holds entry searches insertions removals bucket array  time sounds great achievemen drawbacks space proportional larger number entries map waste space draw keys required integers range   case drawbacks bucket array conjunction good mapping keys integers range      hash functions hash table structure function called hash function maps key map integer range   capacity bucket array table equipped hash function apply bucket array method arbitrary keys main idea approach hash function bucket array key inappropr iate bucket array store entry bucket  keys hash entries mapped bucket case collision occurred bucket store single entry associate entry single bucket problem case collisions ways dealing collisions discuss strategy avoid place hash func tion good maps keys map minimize collisions practical reasons hash function fast easy compute convention view evaluation hash function consisting actionsšmapping key integer called hash code mapping hash code integer range indices   bucket array called compression function figure   figure   parts hash function hash code compression func tion    hash codes action hash function performs arbitrary key map assign integer integer assigned key called hash code integer range   negative desire set hash codes assigned keys avoid collisions hash codes keys collisions hope compression function avoid addition consistent keys hash code key hash ode key equal  hash codes generic object class defined default hashcode method mapping object instance integer representation ject hashcode method returns  bit integer type int overridden method inherited object program sh ould careful default object version hashcode integer interpretation object location memory case implementations type hash code works character strings string jects memory mi ght equal case hash code string class overrides hashcode method object class character strings wise intend objects keys map override built hashcode method objects replacing mappi assigns spread consistent integers types objects common data types methods assigning hash codes objects types casting integer note data type represented bits integer hash codes simply hash code integer interpretation base types byte short int char achieve good hash code simply casting type int likewise variable base type float convert integer float floattointbits integer hash code summing components base types long double bit representation double hash code scheme applicable hash code implementations simply cast long inte ger representation type integer size hash code hash code ignores half original keys map differ bits collide simple hash code alternative hash code takes original bits consideration sum integer representation high order bits integer representation low order bits hash code written  static inthashcode longi return int  int approach summing components extended object binary representation viewed tuple x0 xk1 integers form hash code floating point number sum mantissa exponent long integers apply hash code long integers result polynomial hash codes summation hash code good choice character strings variable length objects viewed tuples form x0 xk1 order hash code character string sums ascii unicode values characters hash code produces lots unwanted collisions common groups strings partic ular temp01 temp10 collide function tops pots spot hash code consid eration positions alternative hash code choose nonzero constant hash code x0ak1 x1ak2 xk2a xk1 mathematically speaking simply polynomial takes compo nents x0 xk1 object coefficients hash code called polynomial hash code horner rule exercise   poly nomial written xk1 xk2 xk3 ax0 intuitively polynomial hash code multiplication constant making room component tuple values preserv ing characterization previous components typical computer evalua ting polynomial finite bit representation hash code periodically flow bits integer interested good spread object respect keys simp ly ignore overflows mindful overflows occurring choose constant nonzero low order bits serve preserve content overflow situation experimental studies     good choices working character strings english fact list   english formed union  word lists provided variants unix     produced  collisions case surprise learn implementations choose polynomial hash function constants default hash code strings sake speed implementations apply polynomial hash function fracti characters long strings cyclic shift hash codes variant polynomial hash code replaces multiplication cyclic shift partial sum number bits function applied character strings static int hashcode string int  int  length    bit cyclic shift running sum int charat add character return traditional polynomial hash code cyclic shift hash code quires fine tuning case wisely choose shift character table   experiments list   english compare number col lisions shift amounts previous experime nts choose constant shift wisely polynomial hash code cyclic shift variant suitable object written tuple x0  order tuples matters table   comparison collision behavior cyclic shift variant poly nomial hash code applied list   english total column records total number collisions max column records maximum number  collisions hash code note cyclic shift  hash code reverts simply sums characters collisions shift total max                                                         compression functions hash code key typically suitable bucket array range hash codes keys typically exceed range legal ndices bucket array incorrectly hash code bucket array result array bounds exception thrown negative exceeds pacity determined integer hash code key object issue mapping integer range   map ping action hash function performs good compression function minimizes number collisions set hash codes division method simple compression function division method maps integer mod size bucket array fixed positive integer additionally prime number compression function helps spread distribution hashed values prime higher likelihood patterns distribution hash codes repeated distribution hash values causing collisions insert keys hash codes       bucket array size  hash code collide bucket array size  collisions hash function chosen ensure probability keys hashed bucket  choosing prime number  repeated pattern hash codes form collisions mad method sophisticated compression functi helps eliminate repeated pat terns set integer keys multiply add divide mad method method maps integer ai mod prime number  called scaling factor  called shift integer constants randomly chosen time compression function determined mod  compression function chosen order eliminate repeated patterns set hash codes closer good hash function probability keys collide  good behavior keys thrown uniformly random compression function spreads integers fairly evenly range   hash code transforms keys map integers effective hash function hash function bucket array define main ingredients hash table implementation map adt details perform operations remove resolve issue handling collisions    collision handling schemes main idea hash tabl bucket array hash function implement map storing entry bucket simple idea challenged distinct keys k1 k2 k1 k2 existence collisions prevents simply inserting anew entry directly bucket complicate procedure performing remove operations separate chaining simple efficient dealing ith collisions bucket store small map mi implemented li    holding entries separate mi chains entries hash linked list collision resolution rule separate chaining assuming initialize bucket  list based map easily separate chaining rule perform fundamental map operations code fragment   code fragment   fundamental methods map adt implemented hash table separate chaining resolve collisions entries fundamental map operation involving key separate chaining approach delegates handling operation miniature list based map stored scan list entry key equal finds replaces puts list likewise search list reaches finds entry key equal remove perform search additionally remove entry simple list based appr oach spreading properties hash function bucket list small good hash function minimize collisions imply buckets store single entry observation slight change implementation bucket stores null stores single entry simply point directly entry list based map holding  entry leave details final space optimization exercise   figure   illustration hash table separate chaining assuming good hash function entries map bucket array capacity expect bucket size called load factor hash table denoted bounded small constant preferably  good hash function expected running time operations remove map implemented hash table function implement operations  expected time provided figure   hash table size  storing  entries integer keys colli sions resolved separate chaining compression function mod  simplicity values keys open addressing separate chaining rule nice operties allowing simple implementations map operations slight disadvan tage requires auxiliary ta structureša listšto hold entries colliding keys handl collisions ways separate  chaining rule space prem ium writing program small handheld device alternative approach storing entry directly bucket entry bucket approach saves space auxiliary structures employed requires bit complex ity deal collisions vari ants approach collectively referred open addressing schemes discuss open addr essing requires load factor  stored directly cells bucket array linear probing simple open addressing thod collision handling linear probing method insert entry bucket occupied  mod  mod occupied  mod bucket accept entry bucket located simply insert entry collis ion resolution strate requires change implementation operation perform search replacement insertion examine consecutive buck ets starting entry key equal bucket figure   linear probing fact acce ssing cell bucket array viewed probe figure   insertion hash table integer keys linear probing hash function mod  values keys implement remove shifting entries entry key inserted complicated typical difficulty replace deleted entry special marker object special marker ccupying buckets hash table modify search algorithm remove search  key skip cells ailable marker continue probing reach ing desired entry pty bucket returning started additionally algorithm remember cell encountered search valid place entry linear probing saves space complicates removals marker object linear probing suffers additional disadvantage cluster entries map contiguous runs overlap half cells hash table occupied contiguous runs occupied hash cells searches slow considerably quadratic probing open addressing strategy quadratic probing involves iteratively buckets mod    j2 finding bucket linear probing quadratic probing strategy complicates removal opera tion avoid kinds clustering patterns occur linear probing creates kind clustering called secondary clustering set filled array cells bounces array fixed pattern chosen prime quadratic probing strategy bucket exists fact prime strategy slot bucket array half explore type clustering exercise   double hashing open addressing strategy clustering kind pro duced linear probing kind produced quadratic probing double hashing strategy approach choose secondary hash function maps key bucket occupied iteratively buckets mod    scheme secondary hash function allowed eval uate common choice mod prime number prime choose secondary hash function attempt minimize clustering open addressing schemes save space separate chaining method faster experimental theoretical anal yses chaining method compe titive faster methods depending load factor buck array mory space major issue collision handling method choice separate chain ing memory space short supply open addressing methods worth implementing ovided probing strategy minimizes clustering occur open addressing     hash table implementation code fragments   œ9  class hashtablemap implements map adt hash table linea probing resolve collisions code fragments include entire implementation map adt methods values entries leave exercise   main design elements class hashtablemap ł maintain instance variables size map bucket array capacity ł method hash compute hash function key built hashcode method multiply add divide mad compression function ł define sentinel marker deactivated entries ł provide optional constructor initial capac ity bucket array ł current bucket array insert entry rehash entire contents array size version ł protected auxiliary methods checkkey checks key valid method checks null class extends hashtablemap override method elaborate test rehash computes mad hash function random pa rameters rehashes entries array double capacity findentry entry key equal starting array circular fashion method finds cell entr returns cell returns  empt cell encountered code fragment   class hashtablemap implementing map adt hash table linear probing continues code fragment     code fragment   class hashtablemap implementing map adt hash table linear probing continues code fragment     code fragment   class hashtablemap implementing map adt hash table linear probing continued code fragment   values entries methods listing keys     load factors rehashing hash table schemes desire load factor  experiments erage case analyses  maintain   open addressing schemes maintain   separate chaining built class util hashmap imple ments map adt threshold   default maximum load factor rehashes time load fact exceeds optional user set load factor choice   fine separate chaining implementation util hashmap explore exercise   open addressing schemes start fail   details average case analysis hashing scope book probabilistic basis intuitive hash function good expect entries uniformly distributed cells bucket array store entries expected number keys bucket  separate chaining close  probability collision approaches  adds overhead operations revert linear time list based methods buckets collisions worst case poor hash function map entry bucket result linear time performance map operations open addressing hand load factor grows   starts approaching  clusters entries bucket array star grow clusters probing strategies bounce bucket array considerable time finish keeping load factor certa threshold vital open dressing schemes concern parate chaining method load factor hash table threshold common require table resized regain load factor objects inserted table rehashing table good requirement array size double previous size allocated bucket array define hash function computing parameters reinsert entry array array hash function plementation hash table linear probing code fragments   œ9  rehashing load factor equal   periodic rehashing hash table efficient implementing map double ze table rehashing operation amortize cost rehashing entries table time insert place    rehashing generally scatter bucket array    application counting word frequencies miniature case study hash table problem counting number occurrences document arises  pundits study political speech themes hash table ideal data structure keys word counts values application code fragment   code fragment   program counting word frequencies document print ing frequent word document parsed scanner class change delimiter separating tokens whitespace letter convert lowercase    dictionary abstract data type map dictionary stores key pairs entries key dictionary keys values object type map sists entries unique keys dictionary multiple entries key english dictionary multiple definitions word distinguish types dictionaries unordered dictionaries ordered dictionaries ordered dictionary assume total order relation fined  keys provide additional thods refer ordering    unordered dictionary order relation assumed keys equality testing keys adt unordered dictionary supports methods size return number entries isempty test entry key equal return entry return null findall return iterable collection entries key equal insert insert entry key returning entry created remove remove entry returning removed entry null entries return iterable collection key entries notice dictionary operations entries key pairs stored dictionary assume entry equipped getkey getvalue methods access key components method unsuccessful entry key equal convention returning sentinel null choice throw exception unsuccessful exception normal key dictionary throwing catching exception typically slower test sentine sentinel efficient note defined dictionary entries equal keys case operation returns arbitrary entry key equal mention passing dictionary adt confused abstract class util dictionary corresponds map adt considered obsolete   series operations initially dictionary storing entries integer keys character values operation output  dictionary insert   a insert     insert      insert       insert                null              findall         size       remove        null        list based dictionaries audit trails simple realizing dictionary unordered list store key entries implementation called log file audit trail primary applications audit trails situations archive structured data operating systems store files login requests process typical scenario insertions dictionary searches searching operating log file typically occurs wrong list based dictionary supports simple fast insertions expense search time storing entries dictionary arbitrary order figure   figure   realization dictionary log file keys dictionary highlight unordered list implementation  implementing dictionary unordered list assume list list based dicti onary implemented doubly linked list descriptions main dictionary methods list based implementation code fragment   simple implementation assume entry stores reference location code fragment   main methods dictionary implemented unordered list sh  analysis list based dictionary  analyze performance dictionary implemented ordered list memory usage note space required list based dictionary entries linked list data structure memory usage proportional size addition implementation dictionary adt realize operation insert easily efficiently single add method simply adds entry list achieve  time insert operation dictionary implementation efficient execution method operation requires worst case scanning entire list examining entries iterator positions stopping encounter entry key equal reach list worst case running time method occurs search unsuccessful reach list examined entries method runs time time proportional needed worst case perform remove operation assume entrie track positions running time performing operation remove alternatively location aware entries store position perform operation remove  time    operation requires scanning entire list running time precisely big theta notation    operation runs time takes time proportional worst case conclusion implementing dictionary unordered list fast insertions expense slow searches removals implementation expect dictionary small expect number inserti ons large relative number searches removals arch iving database operating transactions precisely situations scenario number insertions dictionary roughly proportional number searches removals cases list implementati inappropriate unordered dictionary implementation discuss achieve fast insertions removals searches cases    hash table dictionary implementation hash table implement dictionary adt map adt main difference dictionary  entries duplicate keys assuming load factor hash table  hash function spreads entries fairly uniformly separate chaining resolve collisions achieve  time performance remove insert methods  time performance findall method number entries returned addition simplify algorithms implementing dictionary assume list based dictionary oring entries cell bucket array assumption ing separate chaining cell list approach implement main dictionary methods code fragment   code fragment   main methods dictionary implemented hash table bucket array unordered list cell denote number entries denote capacity denote maximum load factor hash table     ordered search tables binary search keys dictionary total order store entries array list nondecreasing order keys figure   array list node list ordering keys array list faster searching implemented linked list admittedly hash table good expected running time searching worst case time searchi linked list applications real time processing guarantee worst case searching bound fast algorithm searching ordered array list discuss subsection good worst case guarantee running time preferred hash ta ble applications refer ordered array list implementation dictionary ordered search table  figure   realization dictionary ordered search table keys dictionary highlight ordering space requirement ordered search table list based dictionary implementation    assuming grow shrink array supporting array list size array proportional number entries unordered list performing updates search table takes considerable time performing insert operation search table requires time shift entries array list key greater room entry observation applies operation remove takes time shift entries array list key greater close hole left removed entry entries search table implementation inferior log file terms worst case running times dictionary update operations perform method faster search table binary search advantage ordered array list implement dictionary entries accessing element takes  time recall   element array list number elements preceding element  element  elements stored entries dictionary ordered entry key smaller entries indices   larger keys entries indices   observation search key variant children game high low entry candidate current stage search rule entry key equal algorithm maintains parameters low high candidate entries low high initially low  high  compare key median candidate entry mid low high  cases  ł getkey entry search terminates returning ł getkey recur half array list range indices low mid  ł getkey recur range indices mid  high search method called binary search pseudo code code fragment   operation entry dictionary implemented ordered array list consists calling binarysearch   code fragment   binary search ordered array list illustrate binary search algorithm figure   figure   binary search perform operation  dictio nary integer keys implemented ordered array list simplicity keys stored dictionary entries  running time binary earch observe constant num ber primitive operations execute recursive method binary search running time proportional number recursive calls performed crucial fact recursive number candidate entries searched array list high low  number remaining candidates reduced half recursive specifi cally definition mid number remain ing candidates initially number candidate entries binarysearch   general ith binarysearch number candidate entries remaining i worst case unsuccessful search recursive calls candidate entries maximum number recursive calls performed smallest integer m   recalling omit logarithm base  logn logn  implies binary search runs logn time simple variation binary search performs findall time logn number entries iterator returned details left exercise   ordered search table perform fast dic tionary searches table lots dictionary updates considerable time reason primary applica tions search tables situations expect updates dictionary searches situation ordered list english order entries encyclopedia file comparing dictionary implementations table   compares running times thods dictionary realized unordered list hash table ordered search table note unordered list fast insertions slow searches removals search table fast search slow insertions removals incidentally explicitly discuss note sorted list implemented doubly linked list woul slow performing dictionary operations exercise   table   comparison running times methods dictionary realized unordered list hash table ordered search table denote number entries dictionary denote capacity bucket array hash table implementations denote size collection returned operation findall space requirement implementations assuming arrays supporting hash table search table implementations maintained capacity proportional number entries dictionary  method list hash table search table size isempty    entries  exp worst case logn findall  exp worst case logn insert   remove   exp worst case   skip lists interesting data structure efficiently realizing dictionary adt skip list data structure random choices arranging entries search update times logn average number entries dictionary interesti ngly notion average time complexity depend probability distribution keys input depends random number generator implementation insertions decide place entry running time averaged outcomes random numb ers inserting entries extensively mputer games cryptography computer simulations methods generate number viewed random numbers built modern mputers methods called pseudorandom number generators generate random numbers determ inistically starting initial number called seed methods hardware devices extract true random numbers nature case assume computer access numbers random analysis main advantage randomization data structure algorithm design structures methods result simple efficient devise simple randomized data structure called skip list logarithmic time bounds searching achieved binary searching algorithm bounds expected skip list worst case bounds binary searching table hand skip lists faster tables dictionary updates skip list dictionary consists series lists s0 s1 sh list stores subset entries sorted nondecreasing key entries special keys denoted smaller key inserted larger key inserted addition lists satisfy ł list s0 entry dictionary special entries keys ł   list addition randomly generated subset entries list si1 ł list sh  skip list figure   customary visualize skip list list s0 lists s1 sh refer height skip list figure   skip list storing  entries simplicity keys entries intuitively lists set  entry details insertion method entries  chosenat random entries picking entry  wiprobability   essence flip coin entry place entry  coin heads expect s1  entries  entries general i entries expect height logn halving number entries list enforced xplicit property skip lists randomization position abstraction lists trees view skip list dimensional collection positions arranged horizontally levels vertically towers level list tower positions storing entry consecutive lists positions skip list traversed operations return position level prev return position preceding level return position tower return position tower conventionally assume operations return null position position requested exist details note easily implement skip list linked structure traversal methods  time skip list position linked  structure essentially collection doubly linked lists aligned towers doubly linked lists    search update operations skip list skip list structure simple dictionary search update algorithms fact skip list search update algorithms based elegant skipsearch method takes key finds position entry list s0 largest key equal searching skip list suppose search key skipsearch method setting position variable left position skip list called start position start position position sh storing special entry key perform steps figure   key denotes key entry position  null search terminatesšwe located largest entry key equal search key drop lower level tower setting  starting position forward position level key scan forward step note position ists level keys fact perform scan forward level remain started case repeat previous step figure   search skip list positions visited searching key  highlighted blue  pseudo code description skip list search algorithm skipsearch code fragment   method easy implement operation simply perform skipsearch test key keys equal return return null code fragment   search skip list variable holds start position turns expected running time algorithm skipsearch skip list entries logn postpone justification fact discuss implementation update methods skip lists insertion skip list insertion algorithm skip lists randomization decide height tower entry begi insertion entry performing skipsearch operation position level entry largest key equal note hold special entry key insert position inserting entry level flip coin flip tails flip heads backtrack previous higher level insert level position flip coin heads higher level repeat continue insert entry lists finally flip tail link references entry created process create tower entry coin flip simulated built pseudo random number generator util random calling nextint  returns   probability   insertion algorithm skip list code fragment   illustrate figure   algorithm method insertafterabove  inserts position storing entry position level position returning position entry setting internal references prev methods work correctly expected running time insertion algorithm skip list entries logn    code fragment   insertion skip list method coinflip returns heads tails probability   variables hold number entries height start node skip list figure   insertion entry key  skip list figure   assume random coin flips entry heads times row tails positions visited highlighted blue positions inserted hold  entry drawn thick lines positions preceding flagged removal skip list search insertion algorithms removal algorithm skip list simple fact easier insertion algorithm perform remove operation executing method skipsearch position stores entry key return null remove positions easily accessed operations climb tower entry starting position removal algorithm illustrated figure   detailed description left exercise   subsection operation remove skip list entries logn expected running time analysis minor improvements skip list data structure scuss store references entries levels skip list level needed leve references keys method fact prev method perform entry insertion rem oval strictly scan forward fashion saving space prev references explore details optimization exercise   optimizations improve asymptotic performance skip lists constant factor improvements meaningf ul practice fact experimental evidence suggests optimized skip lists faster practice avl trees balanced search trees discussed chapter  expected running time removal algorithm logn    figure   removal entry key  skip list figure   positions visited  search position s0 holding entry highlighted blue positions removed drawn dashed lines maintaining level skip list maintain reference start position left position instance variable policy insertion wishes continue inserting entry level courses action merits possibility restrict level fixed function number entries dictionary analysis max   log reasonable choice picking  logn safer implementing choice modify insertion algorithm inserting position reach level log log  case level bound height increasing possibility inse rtion continue inserting position long heads returned random number generator approach algorithm skipinsert code fragment   analysis skip lists obability insertion level logn low sign choice work choice result expected logn time perform search insertion removal whic    probabilistic analysis skip lists skip lists provide simple implementation ordered dictionary terms worst case perfo rmance skip lists superior data structure fact officially prevent insertion continuing current highest level insertion algorithm  infinite loop infinite loop probability fair coin repeatedly heads forever  infi nitely add positions list eventually running memory cas terminate position insertion highest level worst case running time performing insert remove operations skip list entries height worst case performance occurs tower entry reaches level h1 height event low probability judging worst case onclude skip list structure strictly inferior dictionary implementations discussed earlier chapter fair analysis worst case behavior gross overestimate bounding height skip list insertion step involves randomization accurate analysis skip lists involves bit probability major undertaking complete probabilistic analysis require deep mathematics deep analyses appeared data structures literature fortuna tely analysis understand expected asymptotic behavior skip lists informal intuitive probabilistic anal ysis basic concepts probability theory determining expected height skip list entries assuming terminate insertions early probability entry tower height  equal probability consecutive heads flipping coin probability  i probability ppi level position i probability events occurs sum probabilities occurs probability height larger equal probability level position larger  log probability log  log n3   probability long shot generally constant  larger log probability  nc1 probability smaller log   nc1 high probability height logn  analyzing search time skip list running time search skip list recall search involves nested loops loop performs scan forward level long key greater search key outer loop drops level repeats scan forward iteration height logn high probability number drop steps log high probability bound number scan forward steps number keys examined scanning forward level observe key starting position additi onal key examined scan forward level belong level  keys previous level encountered previous scan forward step probability key counted   expected equal xpected number times flip fair coin heads expected  expected time spent scanning forward level  logn levels high probability search takes expected time logn analysis expected running time insertion removal logn space usage skip list finally turn ace requirement skip list entries observed expected number positions level i expected total number positions proposition   geometric summations  expected space requirement table   summarizes performance ctionary realized skip list table   performance dictionary implemented skip list denote number  entries dictionary time operation performed size collection returned operation findall expected space requirement operation time size isempty  entries insert remove logn expected findall logn expected   extensions applications dictionaries explore extensions applications dictionaries    supporting location aware dictionary entries priority queues    location aware entries speed running time operations dictionary location aware entry greatly speed entry removal dictionary removing location aware entry simply directly place data structure storing remove implement location aware entry augmenting entry class private location variable protected methods location setlocation return set variable require location variable entry refer position data structure implementing dictiona update variable time moved entry sense entry class closel class implementing dictionary location aware entry class nested inside dictionary  class set location aware entries data structures presented chapter ł unordered list unordered list implementing dictionary maintain location variable entry point position underlying linked list choice perform remove remove location  time ł hash table separate chaining hash table bucket array hash function separate chaining handling collisions location variable entry point position list implementing mini map choice perform main work remove remove location constant expected time ł ordered search table ordered table implementing dictionary maintain location variable entry choice perform remove remove location recall location returns integer approach fast entry stored ł skip list skip list implementing dictionary maintain location variable entry point position level choice skip search step algorithm performing remove skip list summarize performance entry removal dictionary location aware entries table   table   performance remove method dictionaries implemented location aware entries denote number entries dictionary list hash table search table skip list   expected  logn expected    ordered dictionary adt ordered dictionary perform usual dictionary operations maintain order relation keys dictionary comparator provide order relati keys ordered search table skip list dictionary implementations scribed dictionary implementations discussed chapter  comparator store dictionary nondecreasing key order entries dictionary stor order provide efficient implementations additional methods dictionary adt adding methods dictionary adt define ordered dictionary adt return entry smallest key return entry largest key successors return iterator entries keys greater equal nondecreasing order predecessors return iterator entries keys equal nonincreasing order implementing ordered dictionary ordered nature operations unordered list hash table inappropriate implementing dictionary data structures maintains ordering formation keys dictionary hash tables achieve search speeds keys distributed random hould ordered search table skip list data structure chapter  dealing ordered dictionaries skip list implement ordered dictionary implement methods  time accessing positions list methods successors predecessors implemented logn expected time iterators returned successors predecessors methods implemented reference current  position level skip list hasnext methods iterators constant time approach util sorted map interface ordered version util map interface interface called util sortedmap interface extends util map interface methods order account parent interface sortedmap duplicate keys ignoring fact dic tionaries multiple entries key correspondences methods ordered dictionary adt methods interface util sortedmap table   table   loose correspondences methods ordered dictionary adt methods util sortedmap interface supports methods util sortedmap expression predecessors exact correspondence iterator returned increasing keys include entry key equal appears efficient true correspondence predecessors util sortedmap methods ordered dictionary methods util sortedmap methods getkey firstkey getvalue firstkey getkey  lastkey getvalue lastkey successors tailmap entryset iterator predecessors headmap entryset iterator    flight databases maxima sets mentioned pre ceding sections unordered ordered dictionaries applications explore specifi applications ordered dictionaries flight databases web sites internet users perform queries flight databases flights cities typically intent buy ticket query user speci fies origin destination cities departure departure time support queries model flight database dictionary keys flight objects fields parameters key tuple origin destination time additional flight flight number number seats coach class flight duration fare stored object finding requested flight simply matter finding key dictionary matching requested query main difficulty user typically match origin destination cities departure content departure time close requested departure time handle query ordering keys lexicographically user query key successors return iteration flights desired cities desired departure times strictly increasing order requested departure time predecessors flights times requested time efficient  implementation ordered dictionary skip list good satisfy queries calling successors query key pvd may   result iterator entries pvd may   aa  f5 y15    pvd may   aa  y0    pvd may   aa  f3 y9    pvd may   aa  f9 y25    maxima sets life trade offs trade desired performance measure cost suppose sake interested maintaining database rating automobiles maximum speeds cost spend query database fastest car afford model trade problem key pair model parameters trading case pair cost speed car notice car strictly cars measure car cost speed pair    strictly car cost speed pair    time cars strictly domi nated car car cost speed pair   worse car cost speed pair   depending money spend figure   figure   illustrating cost performance trade key pairs represented points plane notice point strictly points worse points depending price pay add set remove points  formally price performance pair dominates pair pair called maximum pair dominated pairs interested mainta ining set maxima collection price performance pairs add pairs collection car introduced query collection dollar fastest car costs dollars store set maxima pairs ordered dictionary ordered cost cost key field performance speed field implement operations add adds cost performance pair returns pair cost code fragment   code fragment   methods maintaining set maxima implemented ordered dictionary  implement skip list perform queries logn expected time add updates  log expected time number points removed hus achieve good running times methods maintain set maxima   exercises source code exercises visit datastructures net reinforcement    worst case running time inserting key entries initially map implemented list   map implement dictionary adt assuming user attempt insert entries key   ordered list implemente doubly linked list implement map adt   good hash code vehicle identification number string numbers letters form x9xx99x9xx999999  represents digit represents letter   draw  entry hash table hash function i  mod  hash keys            assuming collisions handled chaining   result previous exercise assuming collisions handled linear probing   result exercise   assuming collisions handled quadratic probing point method fails   result exercise   collisions handled double hashing secondary hash function  mod    pseudo code description insertion hash table quadratic probing resolve collisions assuming trick replacing deleted entries ecial deactivated entry object    description values entries methods included hash table implementation code fragments  œ9    explain modify class hashtablemap code fragments   œ9  implements dic tionary adt map adt   result rehashing hash table figure   table size  hash function k mod    argue hash table suited implement ordered dictionary   worst case time putting entries initially hash table collisions resolved chai ning case   draw skip list performing series operations skip list figure   remove  insert  insert  remove  record coin flips   pseudo code description remove operation skip list   expected running time methods maintaining maxima set insert pairs pair lower cost performance contained ordered dictionary series operations pair lowe cost higher performance   argue location aware entries needed dictionary implemented good hash table creativity    map implement dictionary adt assuming user attempt insert entries key   suppose ordered search tables entries implemented arrays log2 time algorithm finding kth smallest key union keys assuming duplicates   logn time solution previous problem   design variation binary search performing operation findall dictionary implemented ordered arch table runs time logn number elements dictionary size iterator returned   pseudo code descriptions fundamental dictionary methods implement dictionary hash table collisions handled separate chaining add space optimization bucket stores single entry simply bucket reference entry directly   hash table dictionary implementati requires prime number number number  implement method finding prime sieve algorithm algorithm allocate  cell boolean array cell integer initialize array cells true mark cells multiples     process reaches number larger hint bootstrapping method finding primes   perform removal hash table linear probing resolve collisions special marker represent deleted elements rearrange contents appears removed entry inserted place    collection cost performance pairs algorithm finding maxima pairs logn time   quadratic probing strategy clustering problem open slots collision occurs bucket checks buckets j2 mod    j2 mod assume   distinct values prime ranges   justification note j2 mod  mod strategy choose prime mod   check buckets j2 mod ranges    alternating minus alternate version guaranteed check bucket   methods prev needed efficiently implement dict ionary skip list implement entry insertion removal skip list strictly scan forward approach prev methods hint insertion algorithm repeatedly flip coin determine level start inserting entry   implement successors ordered dictionary realized ordered search table running time   repeat previous exercise skip list expected running time case   suppose row array consists   row   row assuming  memory method running logn time time counting number    efficient dictionary structure storing entries set keys total der set keys smaller number entries structure perform operation logr expected time number entries returned operation entries time remaining operations dictionary adt logr expected time   efficient dictionary structure storing entries keys distinct hash codes structure perform operation findall  expected time number entr ies returned operation entries time remaining operations dictionary adt  expected time   efficient data structure implementing bag adt supports method add adding element bag method remove removes arbitrary element bag methods  time   modify skip lis data structure support method atindex returns position element list s0   implementation method runs logn expected time projects   implement class implements dictionary adt adapting util hashmap class   implement map adt hash ta ble separate chaining collision handling adapt util classes    implement ordered dictionary adt ordered list   implement methods ordered dictionary adt skip list   extend previous project providing graphical animation skip list operations visualize entries skip list insertions linked skip list removals search operation visualize scan forward drop actions   implement dictionary supports cation aware entries ordered list   perform comparative analysis studi collision rates hash codes character strings vari ous polynomial hash codes values parameter hash table determine collisions count collisions strings hash code map location hash table test hash codes text files internet   perform comparative analysis previous exercise  digit telephone numbers character strings   design class implements skip list data structure class create implementations map dictionary adts including location aware methods dictionary chapter notes hashing studied technique reader interested study encouraged explore book knuth  book vitter chen  interestingly binary search published  published fully correct form  discussions lessons learned papers bentley  levisse  skip lists introduced pugh  analysis skip lists simplification presentation motwani raghavan  depth analysis skip lists  papers skip lists appeared data structures literature    exercise   contributed james lee star sections ontaining material advanced material rest chapter terial considered optional reading chapter  search trees contents   binary search trees     searching      update operations     implementation    avl trees     update operations     implementation    splay trees     splaying     splay      amortized analysis splaying      trees     multi search trees     update operations   trees    red black trees     update operations     implementation    exercises  datastructures net    binary search trees structures discuss chapter search trees tree data structures implemen dictionary reviewing fundamental methods dictionary adt ł return entry key exists ł findall return iterable collection entries keys equal ł insert insert entry key ł remove remove entry return ł removeall remove entries key returning iterator values method returns null ordered dictionary adt includes additional methods searching predecessors successors key entry performan focusing primary search operation chapter binary trees excellent data structur storing entries dictionary assuming order relation define keys mentioned    binary search tree binary tree internal node stores entry ł keys stored nodes left subtree equal ł keys stored nodes subtree greater equal keys stored nodes provide performing search making comparison internal node continue left child view binary search trees nonempty proper binary trees store entries internal nodes binary search tree external nodes serve placeholders approach simplifies search update algorithms incidentally allowed improper binary search trees space usage expense comp licated search update methods independent view binary search trees proper property binary search tree realization ordered dictionary map binary search tree hierarchically represent ordering keys relationships parent ildren inorder traversal    nodes binary search tree visit keys nondecreasing order     searching perform operation dictionary represented binary search tree view tree decision tree recall figure   case question asked internal node search key equal greater key stored node denoted key answer smaller search continue left subtree answer equal search terminates successfu lly answer greater search continues subtree finall reach external node search terminates unsuccessfully figure   figure   binary search tree representing dictionary integer keys nodes visited executing operations  successful  unsuccessful simplicity keys entry values approach code fragment   search key node method treesearch returns node position subtree rooted occurs ł internal node entry key equal ł external node representing proper place inorder traversal key contained method performed calling treesearch root node returned internal node return entry return null code fragment   recursive search binary search tree  analysis binary tree searching analysis worst case running time searching binary search tree simple algorithm treesearch recursive executes constant number primitive operations recurs ive recursive treesearch child previous node treesearch called nodes path starts root level time number nodes bounded  height spend  time node encountered search method dictionary runs time height binary search tree implement figure   figure   illustrating running time searching binary search tree figure standard visualization shortcuts viewing binary search tree big triangle path root zig zag  variation algorithm performs operation findall time number entries returned method mplicated details left exercise   admittedly height large expect smaller maintain upper bound logn height search tree   scheme implem entations dictionary update methods    update operations binary search trees implementations insert remove operations algorithms fairly straightforward trivial insertion assume proper binary tree supports update operation insertatexternal insert element external node expand internal external node children  error occurs internal node method perform insert dictionary implemented binary search tree calling treeinsert root code fragment   code fragment   recursive algorithm insertion binary search tree algorithm traces path root external node expanded internal node accommodating entry insertion binary search tree figure   figure   insertion entry key  search tree figure   finding position insert tree removal  implementation remove operation dictionary implemented binary search tree bit complex create holes tree assume case proper binary tree supports additional update operation removeexternal remove external node parent replacing parent sibling error occurs external operation implementation operation remove dictionary adt calling treesearch root node storing entry key equal treesearch returns external node entry key dictionary return null treesearch returns internal node stores entry remove distinguish cases increasing difficulty ł children node external node node simply remove operation removeexternal operation restructures replacing sibling removing figure   ł children node internal nodes simply remove node create hole proceed figure   internal node inorder traversal node left internal node subtree child left children left child external node node inorder traversal save entry stored temporary variable entry action removing entry stored remove nodes calling removeexternal action replaces sibling removes return entry stored saved temporary variable searching insertion removal algorithm traverses path root external node movi entry nodes path performs removeexternal operation external node  figure   removal binary search tree figure  entry remove key  stored node external child removal removal figure   removal binary search tree figure  entry remove key  stored node children internal removal removal performance binary search tree analysis search insertion removal algorithms spend  time node visited worst case number nodes visited proportional height dictionary implemented binary search tree insert remove methods  time height binary search tree efficient implementation dictionary entries height small case height log  yields logarithmic time performance dictionary erations worst case height case feel ordered list implementation dictionary worst case configuration arises insert series entries keys increasing decreasing order figure   figure   binary search tree linear height inserting entries keys increasing order performance dictionary implem ented binary search tree summarized proposition table   proposition   binary search tree height key entries space executes dictionary adt operations running times operationssize andisempty  time operationsfind insert andremove time operationfindall takes time size collection returned table   running times main methods dictionary realized binary search tree denote current height tree size collection returned findall space usage number entries stored dictionary  method time size isempty  insert remove findall note running time search update operations binary search tree varies dramatically depending height comfort average binary search tree keys generated random series insertions removals keys expected height log statement requires careful mathema tical language precisely define random series insert ions removals sophisticated probability theory prove justification scope book mind poor worst case performance care standard binary search trees applications updates random plications essential dictionary fast worst case search update times data structures presented sections address    implementation code fragments     binary search tree class binarysearchtree stores objects class bstentry implementing entry interface nodes class binarysearchtree extends class linked binarytree code fragments     advantage code reuse class auxiliary methods heavy lifting auxiliary method treesearch based treesearch algorithm code fragment   invoked findall insert methods recursive addall method main engine findall method performs inorde traversal entries keys equal fast algorithm performs faile search entry finds additional update methods insertatexternal inserts entry external node removeexternal removes external node parent  class binarysearchtree location aware entries    update methods inform moved bstentry objects positions simple auxiliary methods accessing testing data checkkey checks key valid albeit fairly simple rule case instance variable actionpos stores position search insertion removal ended instance variable implementation bina search tree classes extend binarysearchtree code fragments         identify position previous search insertion removal place position action pos intended meaning provided executing method insert remove code fragment   class binarysearchtree continues code fragment     code fragment   class binarysearchtree continues code fragment     code fragment   class binarysearchtree continued code fragment       avl trees previous discussed efficient dictionary data structure worst case performance achieves operations linear time performance list array based dictionary implementations unordered lists search tables discussed chapter  simple correcting problem achieve logarithmic time funda mental dictionary operations definition avl tree simple correction add rule binary search tree definition maintain logarithmic height tree rule height balance property characterizes structure binary search tree terms heights internal nodes recall    height node tree length longest path external node height balance property internal node heights children differ  binary search tree satisfies height balance property avl tree named initials inve ntors adel son vel skii landis avl tree figure   figure   avl tree keys entries inside nodes heights nodes nodes  consequence height bal ance property subtree avl tree avl tree height balance property consequence keeping height small proposition proposition   height avl tree storing entries logn justification upper bound height avl tree directly turns easier work inverse problem finding lower bound minimum number internal nodes avl tree height grows exponentially easy step derive height avl tree storing entries logn start notice     avl tree height  internal node avl tree height  internal nodes  avl tree height minimum number nodes subtrees avl trees minimum number nodes height  height  root account formula relates     h1   point reader familiar properties fibonacci progressions    exercise   function exponential rest readers proceed reasoning formula   implies strictly creasing function   replacing   formula   dropping       formula   doubles time increases  intuitively grows exponentially fact formal apply formula   repeatedly yielding series inequalities        i i   i i integer i  values   pick i equal   pick substituting formula      logarithms sides formula   log   logn    implies avl tree storing entries height log  proposition   analysis binary search trees   operations findall dictionary implemented avl tree time logn logn number entries dictionary size collection retu rned maintain height balan property insertion removal    update operations  insertion removal operations avl trees binary search trees avl trees perform additional computations insertion insertion avl tree insert operation    simple binary search tree recall operation inserts entry node external node internal node operation insertatexternal adds external node children action violate height balance property nodes increase heights node ance stors increase heights restructure restore height balance binary search tree internal node balanced absolute difference heights children  unbalanced height balance property characterizing avl trees equivalent internal node balanced suppose satisfies height balance property avl tree prior inserting entry mentioned performing operation insertatexternal heights nodes including increase nod path root nodes unbalanced figure  a longer avl tree mechanism unbala nce caused figure   insertion entry key  avl tree figure   adding node key  nodes storing keys   unbalanced trinode restructuring restores height balance property heights nodes identify nodes participating trinode restructuring  restore balance nodes binary search tree simple search repair strategy node encounter root unbalanced figure  a denote child higher height note node ancestor finally child higher height tie node ancestor node grandchild equal unbalanced insertion subtree rooted child height  greater sibling rebalance subtree rooted calling trinode restructuring method restructure code fragment   illustrated figures     trinode restructuring tempor arily renames nodes precedes precedes inorder traversal mapping figure   unified case relabeling trinode restructuring replaces node called kes children node children previous children andy maintaining inorder relationships nodes code fragment   trinode restructuring operation binary search tree  modification tree caused trinode restructuring operation called rotation geometric visualize trinode restructuring method called single rotation visualized rotating figure  a trinode restructuring operation called double rotation visualized rotating figure  c figure   computer researchers treat kinds rotations separate methods symmetric types chosen unify types rotations single trinode restructuring operation matter view trinode restructuring method modifies parent child relationships  nodes preserving inorder traversal ordering nodes addition order preserving property trinode restructuring heights nodes restore balance recall execute method restructure grandparent unbalanced unbalance children large height relative height child result rotation tall child pushing short child performing restructure nodes subtree rooted node called balanced figure   restore height balance property locally nodes addition performing entry inser tion subtree rooted replaces rooted taller unit ancestors unbalanced balanced figure   justification fact left exercise   restructuring restores height balance property globally  figure   schematic illustration trinode restructuring operation code fragment   single rotation double rotation  removal case insert dictionary operation implementation remove dictionary operation avl tree algorithm performing operati regular binary search tree difficulty approach avl tree violate height balance property removing internal node operation remove external elevating children place unbalanced node path parent removed node root figure  a fact unbalanced node justification fact left exercise   figure   removal entry key  avl tree figure   removing node storing key  root unbalanced single rotation restores height balance property insertion trinode restructuring restore balance tree unbalanced node encountered root child larger height note node child ancestor child defined children taller taller child children height child left child left child child case perform restructure operation restores height balance property locally subtree rooted rooted node temporarily called figure  b trinode restructuring reduce height subtree rooted  ancestor unbalanced rebalancing continue walking unbalanced nodes  perform restructure operation restore balance continue marching root height logn number entries proposition   logn trinode restructurings sufficient restore height balance property performance avl trees summarize analysis performance avl tree operations insert remove visit nodes root leaf path siblings spend  time node height logn proposition   operations takes logn time leave implementation analysis efficient version operation findall interesting exercise table   summarize performance dictionary implemented avl tree illustrate performance figure   table   performance entry dictionary realized avl tree denotes size collection returned findall space usage operation time size isempty  insert remove logn findall logn figure   illustrating running time searches updates avl tree time performance  level broken phase typically involves searching phase  typically involves updating height values performing local trinode restructurings rotations    implementation turn implementation tails analysis avl tree internal nodes implement ordered dictionary entries insertion removal algorithms require perform trinode restructurings determine differe nce heights sibling nodes restructurings underlying implementation binary sear tree includes method restructure performs tri node restructuring operation code fragment   easy restructure operation performed  time implemented linked structure    case assume binarysearchtree class includes method height explicitly store height internal node node alternatively store balance factor defined height left child minus height child balance factor equal    insertion removal temporarily equal   execution inserti removal height balance factors logn nodes maintained log time  code fragments     complete class avltree implementing dictionary avl tree assuming parent class includes implementation restructure method class extends binarysearchtree code fragments   œ10  includes nested class avlnode extends btnode class represent nodes binary tree avlnode class defines additional instance variable height representing height node binary tree node class btnode class simply overriding createnode method exclusively create binary tree nodes class avltree inherits methods size isempty findall superclass binarysearchtree overrides methods insert remove search tree balanced method insert code fragment   calling superclass insert method inserts entry assi gns insertion position node storing key  figure   instance variable actionpos auxiliary method rebalance traverse path insertion position root traversal updates heights nodes visited performs trinode restructuri method remove code fragment   calling superclass remove method performs removal entry assigns position replacing deleted instance variable actionpos auxiliary method rebalance traverse path removed pos ition root performing needed restructurings code fragment   constructor auxiliary methods class avltree   code fragment   auxiliary methods tallerchild rebalance dictionary methods insert remove class avltree     splay trees implement fundamental dictionary operations balanced search tree data structure splay tree structure conceptually balanced search trees discuss chapter splay tree explicit rules enforce balance applies root operation called splaying access order search tree balanced amortized sense splaying operation performed node reached insertion deletion search surprising thing splaying guarantee amortized running time insertions deleti ons searches logarithmic structure splay tree simply binary search tree fact additional height balance color labels associate nodes tree    splaying internal node binary search tree splay moving root sequence restructurings restructurings perform sufficient root sequence restructurings speci fic operation perform depends relative positions parent exists grandparent cases zig zig node parent left children children figure   replace making child child maintaining inorder rela tionships nodes figure   zig zig symmetric configuration left children  zig zag left child child figure   case replace children maintaining inorder rela tionships nodes figure   zig zag symmetric configuration child left child zig grandparent grandparent reason figure   case rotate making children node children maintain relative inorder relations hips nodes figure   zig ter symmetric configuration left children  perform zig zig zig zag grandparent perform zig parent grandparent splaying step consists repeating restructurings root note sequence simple rotations brings root splaying node figures     figure   splaying node splaying node storing  starts zig zag zig zag step zig zig continues figure     figure   splaying node zig zig step zig zig zig zig continued figure        splay rules dictate splayi performed ł searching key node splay splay parent external node search terminates unsuccessfully splaying figures     performed searching key  unsuccessfully key   ł inserting key splay newly created internal node inserted splaying figures     performed  newly inserted sequence insertions splay tree figure   figure   sequence insertions splay tree initial tree inserting  splaying inserting  splaying inserting  splaying  ł deleting key splay parent node removed node storing descendents recall removal algorithm binary search trees splaying deletion figure   figure   deletion splay tree deletion  node performed moving key internal node left subtree deleting splaying parent splaying starts zig zig zig zig step zig zig     amortized analysis splaying  zig zig zig zag depth decreases zig depth decreases depth splaying consists sequence  zig zigs zig zags final zig odd single zig zig zig zag zig constant number nodes  time splaying node binary search tree takes time depth time performing splaying step node asymptotically time eeded reach node search root worst case time worst case running time search insertion deletion splay tree height node splay deepest node tree large figure   worst case point view splay tree attractive data structure spite poor worst case performan splay tree performs amortized sense sequence intermixed search insertions deletions operation takes average logarithmic time perform amortized analysis splay trees accounting method amortized performance splay trees analysis note time performing search insertion deletion proportional time splaying splaying time splay tree keys node define size number nodes subtree rooted note definition implies size internal node sum sizes children define rank node logarithm base  size log root maximum size n  maximum rank log   external node size  rank  cyber dollars pay work perform splaying node assume cyber dollar pays zig cyber dollars pay zig zig zig zag cost splaying node depth cyber dollars virtual acc ount storing cyber dollars internal node note account exists purpose amortized analysis included data structure implementing splay tree accounting analysis splaying  perform splaying pay number cyber dollars exact payment determined analysis distinguish cases ł payment equal splaying work pay splaying ł payment greater splaying work deposit excess accounts nodes ł payment splaying work withdrawals accounts nodes cover deficiency rest payment logn cyber dollars operation sufficient working ensure node nonnegative account balance cyber dollar invariant splaying scheme transfers accounts nodes ensure cyber dollars withdraw paying splaying work needed order accounting method perform analysis splaying maintain invariant splaying node cyber dollars account note invariant financially sound require preliminary deposit endow tree keys sum nks nodes preserve invariant splaying payment equal splaying work total change refer single zig zig zig zag operation splaying splaying substep denote rank node splaying substep proposition upper bound change caused single splaying substep repeatedly lemma analysis splaying node root proposition   variation ofr aused single splaying substep zig zig zig zig zag node ł   substep zig zig zig zag ł  substep zig  justification fact proposition  appendix   loga logb logc2   change caused type splaying substep zig zig recall figure   size node size children note ranks change zig zig operation parent parent note   r  r  inequality   imply r  r   zig zag recall figure   definition size rank ranks change denotes parent denotes parent r   note   r  r r   zig recall figure   case ranks change denotes parent   proposition   splay tree root total variation caused laying node depth   justification splaying node consists  splaying substeps zig zig zig zag cept zig odd r0 initial rank  rank ith substep variation caused ith substep lemma   total variation caused splaying  rp r0 p    proposition   payment   cyber dollars splaying node cyber dollars maintain invariant keeping cyber dollars node pay entire splaying work costs dollars size root n  rank log n  addition payment splaying logn cyber dollars complete analysis compute cost maintaining invari ant node inserted deleted inserting node splay tree keys ranks ancestors increased v0 vi ancestors v0 vi parent vi1 root  vi vi size vi insertion vi vi rank vi insertion vi vi   vi  vi     range vi log vi log vi  log vi  vi  total variation caused insertion v0 log n  payment logn cyber dollars sufficient maintain invariant node inserted deleting node splay tree keys ranks ancestors decreased total variation caused deletion negative payment maintain invariant node deleted summarize amortized analysis proposition called balance proposition splay trees proposition   sequence ofm operations splay tree search insertion deletion starting splay tree keys number keys tree operation total number insertions total running time performing sequence operations log amortized running tim performing search insertion deletion splay tree logn size splay tree time splay tree achieve logar ithmic time amortized performance implementing ordered dictionary adt amortized performance matches worst case performance avl trees   trees red black trees simple binary tree extra balance stored nodes addition splay trees number interesting properties shared balanced search trees explore additional property proposition called static optimality proposition splay trees  proposition   sequence ofm operations splay tree search insertion deletion starting splay tree keys denote number tim entry accessed splay tree frequency denote total number entries assuming entry accessed total running time performing sequence operations omit proof proposition hard justify imagine remarkable thing proposition states amortized running time accessing entry log     trees data structures discuss chapter including   trees multi search trees trees internal nodes children define   trees discuss multi search trees    multi search trees recall multi trees defined internal node children discuss multi trees search trees recall entries store search tree pairs form key key discuss perform update multi search trees details update methods depend addi tional properties maintain multi trees discuss    definition multi search tree node ordered tree node children define multi search tree ordered tree properties illustrated figure  a ł internal node children internal node node  ł internal node children v1 stores ordered set  key entries k1 kd  xd  k1 kd  ł conventionally define k0 kd entry stored node subtree rooted  ki  ki  set keys stored including special fictitious keys k0 kd key stored subtree rooted child node vi keys stored simple viewpoint rise rule node stores  regular keys forms basis algorithm searching multi search tree definition external node multi search store entries serve placeholders convention binary search trees   binary search tree viewed special case multi search tree internal node stores entry children addition external nodes null simplifying assumption actual nodes store figure   multi search tree search path key  unsuccessful search search path key  successful search   internal nodes multi children interesting relationship number entries number external nodes proposition   entry multi search tree  external nodes leave justification proposition exercise   searching multi tree multi search tree note searching entry key simple perform earch tracing path starting root figure  b node search compare key keys k1 kd  stored ki search completed continue search child vi ki  ki recall conventionally define k0 kd reach external node entry key search terminates unsuccessfully data structures representing multi search trees    discuss linked data structure representing general tree representation multi search tree fact general tree implement multi search tree additional store node set entries including keys node store reference collection stores entries recall binary search tree represent ordered dictionary simply store reference single internal node multi search tree represent store reference ordered set entries internal node reasoning circular argument representation ordered dictionary represent ordered dictionary avoid circular arguments bootstrapping technique previous advanced solution problem create advanced solution case bootstrapping consists representing ordered set internal node dictionary data structure constructed earch table based sorted array    assuming implementing ordered dictionaries realize multi search tree tree storing dictionary node  dictionary store node secondary data structure support bigger primary data structure denote dictionary stored node entries store child node search operation node children v1 entries k1 d1 xd1 store dictionary entries k1 v1 k2 v2 kd  xd   entry ki vi dictionary key ki vi note entry stores special key realization multi search tree processing node searching entry key performing search operation entry ki vi smallest key greater equal distinguish cases ł ki continue search processing child vi note special key kd returned greater keys stored node continue search processing child ł ki search terminates space requirement bove realization multi search tree storing entries proposition   common realizations ordered dictionaries chapter  secondary structures nodes space requirement time spen answering search time spent node search depends realize secondary data structure realized sorted array ordered search table process logd time realized unsorted list processing takes time dmax denote maximum number children node denote height search time multi search tree hdmax hlogdmax depending specific implementation condary structures nodes dictionaries dmax constant running time performing search irrespective implementa tion secondary structures primary efficiency goal multi search tree height small logarithmic function total number entries stored dictionar search tree logarithmic height called balanced search tree discuss balanced search tree caps dmax  definition   tree  multi search tree econdary data structures stored node small primary multi tree balanced   tree called œ4 tree œ3œ4 tree data structure achieves goals maintaining simple properties figure   size property internal node children depth property external nodes depth figure     tree assume external nodes sake simplicity search update methods assuming external nodes real nodes requirement strictly needed enforcing size property   trees nodes multi search tree simple rise ternative œ3œ4 tree implies internal node tree    children implication rule represent dictionary stored internal node unordered list ordered array achieve  time performance operations dmax  depth property hand enforces bound height   tree proposition   height   tree storing entries log justification height   tree storing entries justify proposition showing claims  log     hlog    true justify claims note size property  nodes depth    nodes depth  number external nodes h likewise depth property definition   tree  nodes depth   nodes depth  number external nodes  addition proposition   number external nodes  hn  h logarithm  terms hlog  log  h justifies claims     proposition   states size depth properties sufficient keeping multi tree balanced    proposition implies performing search   tree takes log time specific realization secondary structures nodes crucial design choice maximum number children dmax constant  simple ordered dictionary implementation array list search table secondary structure    update operations   trees maintaining size depth properties requires effort performing insertions removals   tree discuss operations insertion insert entry key   tree perform search assuming entry key search terminates  unsuccessfully external node parent insert entry node add child external node left add entry dictionary insertion method preser ves depth property add external node level existing extern nodes violate size property node  node  node insertion tree longer   tree type violation size property called overflow node resolved order restore properties   tree v1 v5 children k1 k4 keys stored remedy overflow node perform split operation figure   ł replace nodes  node children v1 v2 v3 storing keys k1 k2  node children v4 v5 storing key k4 ł root create root node parent ł insert key k3 children child children  sequence insertions   tree figure   figure   node split overflow  node key inserted parent node replaced  node  node figure   sequence insertions   tree initial tree entry insertion  insertion  insertion  overflow split creation root node split insertion   insertion  overflow split split insertion  insertion   analysis insertion   tree  split operation constant number nodes tree  entries stored nodes implemented  time consequence split operation node overflow occur parent overflow occurs triggers turn split node figure   split operation eliminates overflow propagates parent current node hen number split operations bounded height tree log proposition   total time perfor insertion   tree logn figure   insertion   tree cascading split insertion insertion  causing overflow split split overflow occurs split creating root node final tree removal  removal entry key   tree operation performing search entry key removing entry   tree reduced case entry removed stored node children external nodes suppose instance entry key remove stored ith entry ki node internal node children case swap entry ki entry stored node wexternal node children ith figure  d  internal node subtree rooted ith child noting children node external nodes  swap entry ki entry ensure entry remove stored node externalnode children swapped simply remove entry dictionary remove ith external node removing entry child node preserves depth property remove external node child node external node children removing external node violate size property  node  node entries removal figure  d allowed   tree type violation size property called underflow node remedy underflow check sibling  node  node sibling perform transfer operation child key parent key figure  b sibling siblings  nodes perform fusion operation merge sibling creating node key parent figure  e fusion operation node underflow occur parent turn triggers transfer fusion figure   number fusion operations bounded height tree logn proposition   underflow propagates root root simply deleted figure  c sequence removals   tree figures     figure   sequence removals   tree removal  causing underflow transfer operation transfer operation removal  causing underflow fusion  operation fusion operation removal  removing   figure   propagating sequence fusions   tree removal  underflow fusion underflow fusion operation root removed final tree performance   trees table   summarizes running times main operations dictionary realized   tree time comple xity analysis based ł height   tree storing entries log proposition   ł split transfer fusion operation takes  time ł search insertion moval entry visits logn nodes table   performance entry dictionary realized   tree denotes size  collection returned findall space usage operation time size isempty  insert remove logn findall logn   trees provide fast dictionary search update operations   trees interesting relationshi data struct ure discuss   red black trees avl trees   trees number nice properties dictionary applications suited instance avl trees require restructure operations rotations performed removal   trees require fusing split operations performed insertion removal data structure discuss red black tree drawbacks requires  structural update order stay balanced red black tree binary search tree   nodes colored red black satisfies properties root property root black external property external node black internal property children red node black depth property external nodes black depth defined number black ancestors minus recall node ancestor red black tree figure    figure   red black tree   tree figure   external node red black tree  black ancestors including black depth  color blue red convention edge tree color child node previous types search trees assume entries stored internal nodes red black tree external nodes placeholders assume external nodes actual nodes note expense complicated methods external nodes null red black tree definiti intuitive noting interesting correspondence red black trees   trees illustrated figure   red black tree construct   tree merging red node parent storing entry parent conversely transform   red black tree coloring node black performing transformation internal node ł  node black children ł  node create red node black children child children ł  node create red nodes black children black children children  figure   correspondence   tree red black tree  node  node  node correspondence   trees red black trees intuition discussi perform updates red black trees fact update algorithms red ack trees mysteriously complex intuition proposition   height red black tree storing entries logn justification red black tree storing entries height justify proposition establishing fact log  log  common black depth external nodes   tree height correspondence red black trees   trees proposition   log  internal node property d  log  inequality log  proposition   fact internal nodes assume red black realized linke structure binary trees    store dictionary entry color indicator node space requirement storing keys algorithm searching red black tree standard binary search tree   searching red black tree takes log time    update operations performing update operations red ack tree binary search tree add itionally restore color properties insertion inserti entry key red black tree keeping mind correspondence   tree insertion algorithm algorithm initially proceeds binary search tree    search reach external node replace node internal node storing external node children root color black color red color children black action corresponds inserting node   tree external children addition action preserves root external depth properties violate internal property root parent red parent child red note root property root internal property satisfied parent black parent red grandparent black vi olation internal property double red node remedy double red cases case  sibling black figure   case double red denotes fact created red black tree malformed replacement  node   tree children black children malformed replacement red node parent red node red nodes siblings problem perform trinode restructuring trinode restructuring operation restructure consists steps figure   operation discussed    ł node parent grandparent temporarily relabel left order visited order inorder tree traversal ł replace grandparent node labeled nodes children keeping inorder relationships unchanged performing restructure operation color black color red restructuring eliminates double red problem figure   restructuring red black tree remedy double red configurations restructuring restructuring case  sibling red figure   case double red denotes overflow   tree problem  perform equivalent split operation recoloring color black parent red root case colored black recoloring double red problem reappears albeit higher tree red parent double red problem reappears repeat consideration cases recoloring elimin ates double red problem node propagates grandparent continue performing recolorings finally resolve double red problem final recoloring trinode restructuring number recolorings caused insertion half height tree log  proposition   figure   recoloring remedy double red problem recoloring  node   tree split recoloring nodes   tree split  figures     sequence insertion operations red black tree figure   sequence insertions red black tree initial tree insertion  insertion  double red restructuring insertion  double red recoloring root remains black insertion  insertion  insertion  double red restructuring insertion  double red recoloring continues figure    figure   sequence insertions red black tree insertion  double red restructuring insertion  double red recoloring double red handled restructuring restructuring continued figure    cases insertion imply interesti property red black trees case  action eliminates double red problem single trinode restructuring case  action performs restructuring operations restructuring needed red black tree insertion analysis fact restruct uring recoloring takes  time proposition   insertion key entry red black tree storing entries logn time requires logn recolorings trinode restructuring restructure operation  removal suppose asked remove entry key red black tree removing entry initially proceeds binary search tree    search node storing entry node external child internal node inorder traversal entry perform removal removal entry key stored node external child insertions mind correspondence red black tree   tree removal algorithm remove entry key node external child proceed sibling parent remove nodes child red black red black color black black black preserve depth property fictitious double black color color violatio called double black problem double black denotes underflow   tree recall parent double black node remedy double black problem cases case  sibling black red child figure   resolving case corresponds transfer operation   tree perform trinode restructuring operation restructure recall operation restructure takes node parent grandparent labels temporarily left replaces node labeled making parent description restructure   color black color color black trinode restructuring eliminates double black problem restructuring performed removal operation case figure   restructuring red black tree remedy double black problem configurations restructuring child nodes   tree befo transfer symmetric configurations left child configuration restructuring nodes   tree transfer grey color node parts  node denotes fact node colored red black   case  sibling black children black figures     resolving case corresponds fusion operation   tree recoloring color black color red red color black figure   color double black figure   recoloring double black problem reappear parent figure   recoloring eliminates double black problem propa gates parent current node repeat consideration cases parent case  performs trinode restruct uring operation stops case  number recolorings caused removal log  figure   recoloring red black tree fixes double black problem recoloring nodes   tree fusion configurations recoloring nodes   tree fusion  figure   recoloring red black tree propagates double black problem configuration recoloring nodes   tree fusion configurations configuration recoloring nodes   tree fusion  case  sibling red figure   case perform adjustment operation child child left child execute trinode restructuring operation restructure parent color black red adjustment corresponds choosing representation  node   tree adjustment operation sibling black case  case  applies meaning note case  applies double black problem reappear complete case  application case  case  adjustme performed removal operation figure   adjustment red black tree presence double black problem  configuration adjustment nodes   tree symmetric configuration configuration adjustment nodes   tree algorithm description tree updating needed removal involves upward march tree performing  constant work restructuring recoloring adjustment node node upward march takes  time constant num ber nodes proposition   algorithm removing entry red black tree entries takes logn time performs logn recolorings adjustment additional trinode restructuring performs restructure operations figures     sequence removal operations red black tree illustrate case  restructurings figure  c illustrate case  recolorings places figures     finally figure  i case  adjustment figure   sequence removals red black tree initial tree removal  removal  causing double black handled restructuring restructuring continues figure   figure   sequence removals red black tree continued removal  removal   causing double black handled recoloring recoloring removal  removal  causing double black handled adjustment adjustment double black handled recoloring recoloring continued figure    performance red black trees table   summarizes running times main operations dictionary realized red black tree illustrate justification bounds figure    table   performance entry dictionary realized red black tree denotes size collection returned space usage operation time size isempty  insert remove logn findall logn figure   illustrating running time searches updates red black tree time performance  level broken phase typically involves searching phase typically involves recolorings performing local trinode restructurings rotations  red black tree achieves logarithmic worst case running times searching updating dictionary red black tree data structure complicated   tree red black tree conceptual advantage constant number trinode restructurings needed restore balance red black tree update    implementation code fragments     major portions implementation dictionary realized red black tree main class includes nested class rbnode code fragment   extends btnode class represent key entry binary search tree defines additional instance variable isred representing color node methods set return code fragment   instance variables nested class constructor rbtree  class rbtree code fragments     extends binarysearchtree code fragments     assume parent class supports method restructur performing trinode restructurings rotations implementation left exercise   class rbtree inherits methods size findall binarysearchtree overrides methods insert remove implements operations calling method parent class remedying color violations update ha caused auxiliary methods class rbtree names uggest meanings implementations straightforward code fragment   dictionary adt method insert auxiliary methods createnode remedydoublered class rbtree  methods insert code fragment   remove code fragment   methods superclass rst rebalance tree calling  auxiliary methods perform rotations path update position actionpos variable inherited superclass root code fragment   method remove auxiliary method remedydoubleblack class rbtree     exercises source code exercises visit datastructures net reinforcement   defined binary search tree keys equal node key left subtree node suppose change definition restrict equal keys subtree subtree binary search tree equal keys case   binary search trees store keys      binary search trees store keys       insert binary search tree entries keys         order draw tree insertion   suppose methods binarysearchtree code fragments   œ10  perform updates figures       node referenced action pos update   amongus claims order fixed set entries inserted binary search tree matteršthe tree time small proves wrong   amongus claims order fixed set entries inserted avl tree matteršthe avl tree time small proves wrong    rotations figures     single double rotations   draw avl tree inser tion entry key  avl tree figure  b   draw avl tree removal entry key  avl tree figure  b   explain performing rotation node binary tree represented array list takes time   search tree figure  a   tree   alternative performing split node   tree partition  node  node keys k1 k2 k3 k4 store parent case   amongus claims   tree stori set entries structure order entries inserted wrong   draw red black trees correspond   tree   set keys                draw   tree storing keys fewest number nodes draw   tree storing keys maximum number nodes    sequence keys            draw result inserting entries keys order initially   tree initially red black tree   statements red black trees provide justification true statement counterexample false subtree red black tree red black tree sibling external node external red unique   tree red black tree unique red black tree   tree   draw red black tree avl tree   tree storing   entries worst case height cases avl tree    tree red black tree splay tree binary search tree   perform sequence operati ons initially splay tree draw tree set operations insert keys           order search keys           order delete keys           order   splay tree entries accessed increasing order keys   explain avl tree black tree sort comparable elements nlogn time worst case   splay tree sort comparable elements nlogn time worst case creativity    design variation algorithm treesearch performing operation findal ordered dictionary implem ented binary search tree runs time height size collection returned   perform operation removeall removes entries keys equal ordered dictionary implemented binary search tree method runs time height size iterator returned   draw schematic avl tree single remove operation require log trinode restructurings rotations leaf root order restore height balance property   perform operation removeall removes entries keys equal dictionary implemente avl tree time slogn number entrie dictionary size iterator returned   maintain reference position left internal node avl tree operation    performed  time implementation dictionary methods modified maintain reference left position   node binary tree converted node binary tree rotations   ordered dictionary entries implemented avl tree implement operation time logn size iterator returned findallinrange k1 k2 return iterator entries key k1 k2    ordered dictionary entries modify avl tree implement method time logn countallinrange k1 k2 compute return number entries key k1 k2   nodes unbal anced avl tree operation insert atexternal performed execution insert operation nonconsecutive path newly inserted node root   node avl tree unbalanced operation remove external performed execution remove dictionary operation   trinode restruct uring operation needed restore balance insertion avl tree     trees storing entries entries keys keys entries logn log time method joining tand single tree stores entries   repeat previous problem red black trees   justify proposition     boolean indicator mark nodes red black tree red black strictly needed ha distinct keys scheme implementing red black tree addi extra space standard binary search tree nodes scheme affect search update times    red black tree storing entries key entry construct log time red black trees keys keys greater operation destroys   nodes avl tree colored red black red black tree   mergeable heap adt consists operations insert removemin unionwith min unionwith operation performs union mergeable heap destroying versions concrete implementation mergeable heap adt achieves logn performance operations   variation splay trees called half splay trees splaying node depth stops node reaches depth  perform amortized analysis half splay trees   standard splaying step requires passes downward pass node splay upward pass splay node method splaying searching downward pass substep requires nodes path zig substep performed perform zig zig zig zag zig steps   sequence accesses node splay tree odd consisting single chain internal nodes external node children internal node path alternates left children children   explain implement array list elements methods add logn time worst case expandable array  projects   body simulations odeling tool physics astronomy chemistry project write program performs simple body simulation called jumping leprech auns simulation involves leprechauns numbered  maintains gold leprechaun leprechaun starti dollars worth gold  eachi   addition simulation maintains leprechaun place horizon represented double precision floating point number iteration simulation simulation processes leprechauns order processing leprechaun iteration comp uting place horizon determined assignment xixi rgi random floating point number   leprechaun steals half gold nearest lepr echauns adds gold gold write program perform series iterations simulation number leprechauns include visualization leprechauns simulation including gold values horizon positions maintain set horizon positions ordered dictionary data structure chapter   extend class binarysearchtree code fragments   œ10  support methods ordered dictionary adt      implement class restructurablenodebinarytree supports methods binary tree adt method restructure performing rotation operation class component implementation avl tree      write class implements methods ordered dictionary adt    avl tree   write class implements methods ordered dictionary adt      tree    write class implements methods ordered dictionary adt    red black tree   form programmer team member implement previous projects perform extensive experimental studies compare speed implementations design sets experiments favoring implementation   write class red black tree convert   tree   tree convert red black tree   perform experimental study compare performance red black tree skip list   prepare implementation splay trees splaying chapter splaying exercise   perform extensive experimental studies implementation practice chapter notes data structures discussed chapter extensively covered knuth sorting searching book  mehlhorn  avl trees adel son vel skii landis  invented class balanced search trees  binary search trees avl trees hashing knuth sorting searching  book average height analyses binary search trees books aho hopcroft ullman  cormen leiserson rivest  handbook gonnet baeza yates  number theoretical experime ntal comparisons dictionary implementations aho hopcroft ullman  discuss   trees   trees red black trees defined bayer  variations interesting properties red black trees presented paper guibas sedgewick  reader interested learning balanc tree data structures referred books mehlhorn  tarjan  book chapter mehlhorn tsakalidis  knuth  excellent additional reading includes  early approaches balancing trees splay trees invented sleator tarjan   chapter  sorting sets selection contents   merge sort     divide conquer     merging arrays lists     running time merge sort     implementations merge sort      merge sort recurrence equations    quick sort     randomized quick sort     place quick sort    lower bound sorting    bucket sort radix sort     bucket sort     radix sort     comparison sorting algorithms    set adt union structures     simple set implementation     partitions union operations     tree based partition implementation    selection     prune search     randomized quick select      analyzing randomized quick select    exercises  datastructures net   merge sort sorting technique called merge sort simple mpact recursion    divide conquer merge sort based algorithmic design pattern called divide conquer divide conquer pattern consists steps  divide input size smaller threshold elements solve problem directly ing straightforward method return solution divide input data disjoint subsets  recur recursively solve subproblems subsets  conquer solutions subproblems merge solution original problem divide conquer sorting recall sorting problem sequence objects stored linked list array comparator defining total order objects asked oduce ordered representation objects sorting presentation sorting algorithm high level sequences explain details needed implement linked lists arrays sort sequence elements divide conquer steps merge sort algorithm proceeds  divide element return sorted elements remove elements sequences s1 half  elements s1  elements remaining  elements  recur recursively sort sequences s1  conquer elements merging sorted sequences s1 sorted sequence reference divide step recall notation ceiling smallest integer notation floor largest integer visualize execution rge sort algorithm binary tree called merge sort tree node represents recursive invocation merge sort algorithm associate node sequence processed invocation children node recu rsive calls process subsequences s1 external nodes individual elements instances algorithm recursive calls figure   summarizes execution merge sort algorithm showing input output sequences processed node merge sort tree step step evolution merge sort tree figures     algorithm visualization terms merge sort tree helps analyze running time merge sort algorithm size input sequence roughly halves recursive merge sort height merge sort tree log recall base log  figure   merge sort tree execution merge sort algorithm sequence  elements input sequences processed node output sequences generated node  figure   visualization execution merge sort node tree represents recursive merge sort nodes drawn dashed lines represent calls node drawn thick lines represents current nodes drawn lines represent completed calls remaining nodes drawn lines represent calls waiting  child invocation return continues figure   figure   visualization execution merge sort continues figure    figure   visualization execution merge sort invocations note conquer step performed step continued figure    proposition   merge sort tree execution merge sort sequence size height log leave justification proposition   simple exercise   proposition analyze unning time merge sort algorithm overview merge sort illustration works steps divide conquer algorithm divide recur steps merge sort algorithm simple dividing sequence size involves separating element  recursive calls simply invol passing smaller quences parameters difficult step conquer step merges sorted sequences single sorted sequence analysis merge sort    merging arrays lists merge sorted sequences ful implemented arrays lists detailed pseudo code describing merge sorted sequences represented arrays linked lists merging sorted arrays  array implementation code fragment   illustrate step merge sorted arrays figure   code fragment   algorithm merging sorted array based sequences figure   step merge sorted arrays arrays copy step merging sorted lists code fragment   list based version algorithm merge merging sorted sequences s1 implemented linked lists main  idea iteratively remove smallest element lists add output sequence input lists point copy remainder list execution version algorithm merge figure   code fragment   algorithm merge merging sorted sequences implemented linked lists running time merging analyze running time merge algorithm making simple observations n1 number elements s1 algorithm merge loops independent analyzing array based version list based version operations performed inside loop  time key observation iteration loops element copied moved  element considered insertions performed s1 observation implies overa number iterati ons loops n1 running time algorithm merge  n1 figure   execution algorithm merge code fragment       running time merge sort details merge sort algorithm arraybased list based versions analyzed running time ofthe crucial merge algorithm conquer step analyze running time entire merge sort algorithm assu ming input sequence elements simplicity restrict attention case power  leave exercise   result analysis holds power  analysis merge algorithm assume input sequence auxiliary sequences s1 created recursive  merge sort implemented rays linked lists merging sorted sequences linear time mentioned earlier analyze merge sort algorithm referring merge sort tree recall figures     time spent node running time recu rsive excluding time waiting recursive calls children terminate time spent node includes running times divide conquer steps excludes running time ecur step observed details divide step straightforw ard step runs time proportional size sequence addition discussed conquer step consists merging sorted subsequences takes linear time independent dealing arrays linked lists letting denote depth node time spent node i size sequence handled recursive equal i tree globally figure   definition time spent node unning time merge equal sum times spent nodes observe i nodes depth simple observation consequence implies time spent nodes depth i ł  proposition   height logn time spent logn  levels result proposition   algorithm merge sort sorts sequence size nlogn time assuming elements compared  time merge sort algorith asymptotically matches fast running time heap sort algorithm figure   visual time analysis merge sort tree node labeled size subproblem     implementations merge sort imple mentations merge sort algorithm lists arrays recursive list based implementation merge sort code fragment   complete implementation list based merge sort algorithm static recursive method mergesort comparator    decide relative order elements implementation input list auxiliary lists l1 processed recursive calls list modified insertions deletions head tail list update takes  time assuming lists implemented doubly linked lists table   code class nodelist code fragments   œ6  auxiliary lists list size method mergesort runs time nlogn provided list implemented doubly linked list comparator compare elements  time  code fragment   methods mergesort merge implementing recursive merge sort algorithm   nonrecursive array based implementation merge sort nonrecursive version ray based merge sort runs log time bit faster recursive list based merge sort practice avoids extra overheads recursive calls node creation main idea perform merge sort perfor ming merges level level merge sort tree input arra elements merging odd pair elements sorted runs length merge runs runs length merge uns runs length array sorted ace usage reasonable deploy output array stores merged runs swa pping input output arrays iteration implementation code fragment   built method arraycopy copy range cells arrays code fragment   implementation nonrecursive merge sort algorithm     merge sort recurrence equations justify running time merg sort algorithm log proposition   deal directly recursive nature merge sort algorithm analysis running time merge sort introduce mathematical concept recurrence equation recurrence relation function denote worst case running time merge sort input sequence size merge sort recursiv characterize function equation function recursively expr essed terms order simplify characterization restrict attention  case power  leave problem showing asymptotic characterization holds general case exercise case definition expression called recurrence equation function appears left hand sides equal sign characterization correct accura desire big type characterization involve function closed form characterization closed form solution pplying definition recurrence equation assuming large application equation write recurrence  t   t    t  cn apply equation t  cn point pattern emerging applying equation times it i icn issue remains determine process recall switch closed form  occur i occur log making substitution yields lognt logn log  cnlogn nb cnlogn alternative justification fact nlogn   quick sort sorting algorithm discuss called quick sort merge sort algorithm based divide conquer paradigm technique opposite manne hard work recursive calls high level description quick sort  quick sort algorithm sorts sequence simple recursive approach main idea apply divide conquer technique divide subsequences recur sort subsequence combine sorted subsequences simple concatenation quick sort algorithm consists steps figure    divide elements element select specific element called pivot common practice choose pivot element remove elements sequences ł storing elements ł storing elements equal ł storing elements greater elements distinct holds elementšthe pivot  recur recursively sort sequences  conquer elements order inserting elements finally figure   visual schematic quick sort algorithm merge sort execution quick sort visualized binary recursion tree called quick sort tree figure   summarizes execution quick sort algorithm showing nput output sequences processed  node quick sort tree step step evolution quick sort tree figures       merge sort height quick sort tree execution quick sort linear worst case sequence consists distinct elements alrea sorted case standard choice pivot largest element yields subsequence size  subsequence size  subsequence size  invocation quick sort subsequence size decreases  height quick sort tree  figure   quick sort tree execution quick sort algorithm sequence  elements input sequences processed node output sequences generated node pivot level recursion bold  figure   visualization quick sort node tree represents recursive nodes drawn dashed lines represent calls node drawn thick lines represents running invocation nodes drawn lines represent terminated calls remaining nodes represent suspended calls active invocations waiting child invocation  return note divide steps performed continues figure   figure   visualization execution quick sort note conquer step performed continues figure    figure   visualization execution quick sort invocations note conquer steps performed continued figure    performing quick sort arrays lists code fragment   pseudo code description quick sort algorithm efficient sequences plemented arrays linked lists algorithm template quick sort adding scanning input sequence backwards divide lists elements equal greater pivot perform scan backwards removing element sequence constant time operation independent sequence implemented array linked list recur lists copy sorted lists perform set copies forward direction  inserting elements sequence constant time operation independent sequence implemented array linked list code fragment   quick sort input sequence implemented linked list array running time quick sort analyze running time quick sort technique merge sort    identify time spent node quick sort tree sum running times nodes examining code fragment   divide step conquer step quick sort implemented linear time time spent node proportional input size defined size sequence handled invocation quick sort node subsequence  element pivot sum input sizes children atmost  quick sort tree denote sum input sizes nodes depth s0 root entire sequence s1  pivot propagated children children nonzero input size  child root size size    continuing reasoning observed   height  worst case worst case running time quick sort proposition   quick sort runs worst case time expect quick sort quadratic bound quick sort slow worst case paradoxically worst case behavior occurs problem instances sorting easyšif sequence sorted analysis note case quick sort sequence distinct elements occurs subsequences happen roughly size case s0 s1         i1 i  case height logn quick sort runs nlogn time leave justificatio fact exercise   informal intuition expected behavior quick sort invocation pivot divide input sequence equally expect average running time quick sor case running time nlogn introducing randomization quick sort behave    randomized quick sort common method analyzing quick sor assume pivot divide sequence equa lly feel assumption presuppose knowledge input distribution typically assume rarely sorted sequences sort common applications fortunately assumption needed order match intuition quick sort behavior general desire close case running time quick sort close case running time pivot divide input sequence equally outcome occur result running time asymptotically case running time pivots close middle set elements leads nlogn running time quick sort picking pivots random goal partition step quick sort method divide sequence equally introduce ndomization algorithm pick pivot random element input sequence picking pivot element pick element random pivot keeping rest algorithm unchanged variation quick sort called randomized quick sort proposition expected running time randomized quick sort sequence elements nlogn expectation random choices algorithm independent assumptions distribution input sequences algorithm proposition   expected running time randomized quick sort sequence size nlogn justification assume elements compared  time single recursive randomized quick sort denote  size input good pivot chosen subsequences size  n  bad implications choosing pivot uniformly random note  good choices pivot size randomized quick sort algorithm probability good   note good partition list size lists size n   bad bad producing single size  recursion trace random ized quick sort trace defines binary tree node corresponds recursive subproblem sorting portion original list node size group size subproblem greater   n   analyze expected time spent working subproblems nodes size group linearity expectation proposition  expected time working subproblems sum expected times nodes correspond good calls correspond bad calls note good occurs probability   expected number consecutive calls good  notice good node size group children size groups higher element input list expected number nodes size group subproblems  expected total size subproblems size group  nonrecursive work perform subproblem proportiona size implies total expected time spent processing subproblems nodes size group number size groups log  n repeatedly multiplying   repeatedly dividing   number size groups logn total expected running time randomized quick sort nlogn figure   figure   visual time analysis quick sort tree node labeled size subproblem  running time randomized quick sort nlogn high probability exercise      place quick sort recall    sorting algorithm place small memory addition needed objects sorted merge sort algorithm place making place requires complicated merging method discuss    place sorting inherently difficult heap sort quick sort adapted place performing quick sort algorithm place requires bit ingenuity input sequence store subsequences recursive calls algorithm placequicksort performs place quick sort code fragment   algorithm placequicksort assumes input sequence array distinct elements reason restriction explored exercise   extension general case discussed exercise   code fragment   place quick sort input array  place quick sort modifies input sequence element swapping explicitly create subsequences subsequence input sequence implicitly represented range positions left divide step performed scanning array simultaneously forward backward swapping pairs elements reverse order figure   indices meet subarrays opposite sides meeting point algorithm completes recurring subarrays place quick sort reduces running time caused creation sequences movement elements constant factor version place quick sort code fragment   figure   divide step place quick sort scans sequence left scans sequence left swap performed element larger pivot  element smaller pivot final swap pivot completes divide step code fragment   coding place quick sort assuming distinct elements  implementation guaranteed place recalling    note space stack proportional depth recursion tree case large  admittedly expected stack depth logn small compared simple trick guarantee stack size logn main idea design nonrecursive version ace quick sort explic stack iteratively process subproblems represented pair indices marking subarray boundaries itera tion involves popping subproblem splitting big pushing subproblems trick pushing subproblems push larger subproblem smaller sizes subproblems double stack stack depth logn leave details implementation exercise      lower bound sorting recapping discussions sorting point methods worst cas expected running time nlogn input sequence size methods include merge sort quick sort chapter heap sort    natural question sort faster nlogn time computational primitive sorting algorithm comparison elemen došcomparison based sorting nlogn worst case lower bound running time recall notation    focus main cost comparison based sorting count comparisons sorting algorithm performs derive lower bound sufficient suppose sequence x0 xn1 sort assume elements distinct restriction deriving lower bound care implemented array linked list sake lower bound counting comparisons time sorting algorithm compares elements asks ﬁis ﬂ outcomes based result comparison sorting algorithm perform ternal calculations counting eventually perform comparison elements outcomes represent comparison based sorting algor ithm decision tree recall   internal node corresponds comparison edges node children correspond computations answer figure   note hypothetical sorting algorithm question explicit knowledge tree simply represent sequences comparisons sorting gorithm arting comparison root nding comparison parent external node algorithm terminates execution initial ordering permutation elements hypothetical sorting algorithm execute ries comparisons traversing path root external node associate external node set permutations sorting algorithm observation lower bound argument external node represent sequence comparis ons permutation justification claim simple permutations external node objects time output specific reordering appearing sorting  algorithm output elements order implies trick algorithm outputting result wrong order allowed correct sorting algorithm external node permutation property decision tree sorting algorith prove proposition   running time comparison based algorithm sorting element sequence nlogn worst case justification running time comparison based sorting algorithm greater equal height decision tree algorithm figure   argument external node permutation permutation result diffe rent external node number permutations objects     external nodes proposition   height log justifies propositi  terms greater equal  product nlogn figure   visualizing lower bound comparison based sorting    bucket sort radix sort previous nlogn time worst case sort element sequence comparison based sorting algorithm natural question kinds sorting algorithms designed asympt otically faster nlogn time interestingly algorithms exist require special assumptions input sequence sorted scenarios practice discussing worthwhile problem sorting sequence entries key pair    bucket sort sequence entries keys integers range   integer  suppose sorted keys entries case sort time surprising implies sort time crucial point restri ctive assumption format elements avoid comparisons main idea algorithm called bucket sort based comparisons keys indices bucket array cells indexed   entry key bucket  sequence entries key inserting entry input sequence bucket entries sorted order enumerating contents buckets    order bucket sort algorithm code fragment   code fragment   bucket sort easy bucket sort runs time space bucket sort efficient range values keys small compared sequence size nlogn performance deteriorates grows compared property bucket sort algor ithm works correctly elements key anticipates occurrences stable sorting sortting key pairs issue equal keys handled k0 x0 kn1 xn1 sequence entries sortingalgorithm stable entries ki kjand ki precedes sorting entry ki precedes entry sorting stability sorting algorithm applications preserve initial ordering elements key informal description bucket sort code fragment   guarantee stability inherent bucket sort method easily modify description bucke sort stable preserving running time stable bucket ort algorithm removing element sequence sequences execution algorithm     radix sort reasons stable sorting bucket sort approach applied general contexts sort integers suppose sort keys pairs integers range   integer  context natural define ordering keys lexicographical dictionary convention k1 l1 k2 k1 k2 k1 k2 l1    pair wise version lexicographic comparison function applied equal length character strings easily generalizes tuples numbers  radix sort algorithm sorts sequence entries keys pairs applying stable bucket sort sequence component pair ordering key component order correct sort component component shoul answer question   sequence keys                 sort stably component sequence s1                 stably sort sequence s1 component sequence s1                  sorted sequence hand stably sort component sequence                 stably sort sequence  component sequence                  sequence lexicographically ordered led lieve sort component component intuition stably sorting component  component guarantee equal sort component relative order starting sequence sorted component preserved sequence guaranteed sorted lexicographically time leave simple exercise   determination approach extended triples tuples numbers summari ze proposition   sequence key pairs key k1 k2 kd ki integer range   integer  sort lexicographically time radix sort sorting interesting problem dealing total order relation set elements applications require ordered listing entire set ordering set study problem called selection step compare sorting algorithms studied   comparison sorting algorithms point breath algorithms studied book sort element array list node list general sequence running time factors studied methods insertion sort selection sort time behavior average worst case studied methods nlogn time behavior including heap sort merge sort quick sort finally studied ecial class sorting algorithms bucket sort radix sort methods linear time types keys selection sort algorithm poor choice application runs time case remaining sorting algorithms things life clear sorting algorithm remaining candidates sorting algorithm suited application depends properties application offer guidance observations based properties good sorting algorithms insertion sort implemented running time insertion sort number inversions number pairs elements order  insertion sort excellent algorithm sorting small sequences  elements insertion sort simple program small sequences inversions insertion sort effective sorting sequences sorte number inversions small time performance sertion sort poor choice special contexts merge sort merge sort hand runs nlogn time worst case optimal comparison based sorting met hods experimental studies difficult merge sort place overheads needed implement merge sort attractive place implementations heap sort quick sort sequences fit computer main memory area merge sort excellent algorithm situations input fit main memory stored blocks external memory device disk contexts merge sort processes runs data long merge str eams data brought main memory block disk external memory sorting merge sort algorithm mini mize total number disk reads writes needed merge sort algorithm superior contexts quick sort experimental studies input sequence fit main memory place versions quick sort heap sort faster merge sort extra overh ead needed copying nodes entries puts mergesort disadvantage quick sort heap sort applica tions fact quick sort average beat heap sort tests quick sort excellent choice general purpose memory sorting algorithm included qs ort sorting utility provided language libraries time worst case performance quick sort poor choice real time applications guarantees time needed complete sorting operation heap sort real time scenarios fixed time perform sorting operation input data fit main memory heap sort algorithm choice runs nlogn worst case time easily execute place  bucket sort radix sort finally application involves sorting entries sma integer keys tuples small integer keys bucket sort radix sort excellent choice runs time   range integer keys  bucket sort nlogn function sorting method faster quick sort heap sort study sorting algorithms versatile collection sorting methods algorithm engineering toolbox   set adt union structures introduce set adt set collection distinct objects duplicate elements set explicit notion keys order include discussion sets chapter sorting sorting play role efficient implementations operations set adt sets recall mathematical definitions union intersection subtraction sets xis   internet search engines store word dictionary database set web web identified unique internet address presented query word search engine return web set sorted proprietary priority ranking presented word query search engine compute intersection return web set sorted priority search engines set intersection algorithm computation fundamental methods set adt fundamental methods set adt acting set union replace union execute aa  intersect replace intersection execute aa subtract replace difference execute aa    simple set implementation simplest ways implementing store elements ordered sequence implementation included software libraries generic data structures implementing set adt ordered sequence implementations exercises consistent total order relation elements set provided order sets implement fundamental set operations generic version merge algorithm takes nput sorted sequences representing input sets constructs sequence representing output set union intersection subtraction input sets incidental ly defined operations modify contents set involved alternatively defined methods modify return set generic merge algorithm iteratively examines compares current elements input sequence finds based outcome comparison determines copy elements output sequence determination base operation performing union tersection subtraction union operation proceed ł copy advance element ł copy advance elements ł copy advance element performance generic merging analyze running time neric merging iteration compare elements input sequences copy element output sequence advance current element assuming comparing copying elements takes  time total running time nb size nb size  generic merging takes time proportional number elements proposition   set adt implemented ordered sequence generic merge scheme supports operationsunion intersect andsubtract time denotes sum sizes sets involved generic merging template method pattern generic merge algorithm based template method pattern    template method pattern software engineering design pattern describing generic computation mechanism specialized redefining steps case method merges sequences specialized behavior abstract methods code fragment   class merge provid ing implementation generic merge algorithm code fragment   class merge generic merging  convert generic merge class classes extend classes redefine auxiliary methods aisless bothareequal bisless union intersection subtraction easily terms methods code fragment   auxiliary methods redefined template method merge performs  ł class union merge merge copies element duplicate element ł class intersectmerge merge copies element throws elements set ł class subtractmerge merge copies element code fragment   classes extending merge class specializing auxiliary methods perform set union intersection subtraction     partitions union operations partition collection disjoint sets define methods partition adt position objects    stores element parition adt supports methods makeset create singleton set element return position storing set union return set destroying return set element position simple implementation partition total elements collection sequences set sequence set stores set positions elements position object stores variable element references element execution element method  time addition store variable set position references sequence storing sequence representing set element figure   perform operation  time set reference likewise makeset takes  time operation union requires join sequences update set references positions choose implement operation rem oving positions sequence smaller size inserting sequence larger size time position smaller set insert larger set update set reference point operation union takes time min worst case  amortized analysis implementation appears worst case analysis figure   sequence based implementation partition consisting sets              performance sequence implementation sequence implementation simp efficient theorem proposition   performing series nmakeset union andfind operations sequence based implementation starting initially partition takes nlogn time justification accounting method assume cyber dollar pay time perform operation makeset operation movement position object sequence union operation case makeset operation charge operation  cyber dollar case union operation charge  cyber dollar position set note charge union operations total charges makeset operations sum number charges positions behalf union operations observation time position set size set doubles position moved set log times position charged logn times assume partition initially elements referenced series operations implies tota time union operations nlogn amortized running time operation series makeset union operations total time series divided number operations conclude oposition partition implemented sequences amor tized running time operation  logn summarize perfor mance simple sequence based partition implementation proposition   sequence based implementation partition series nmakeset union andfind operations starting initially partition amortized running time operation logn note sequence based implementation partition operation takes worst case  time running time union operations computational bottleneck tree based implementation partition guarantee constant time ope rations amortized time logn union operation    tree based partition implementation alternative data structure collection trees store elements sets tree set figure   implement tree linked data structure nodes set position objects till view position node variable element referring element variable set referring set view position set data type set reference position point position implement appr oach positions respective set references define collection trees associate tree set position set reference points root tree set position names set names case set reference points parent tree ther case set root tree figure   tree based implementation partition consisting disjoint sets              partition data structure operation union called position arguments represent sets perform operation making trees subtree figure  b  time setting set reference root tree point root tree operation position performed walking root tree position figure  a takes time worst case note representation tree specialized data structure implement partition meant realization tree abstract data type   representation upward links provide access children node figure   tree based implementation partition operation union operation denotes position object element   implementation sequence based data structure add simple heuristics faster union size store position node size subtree rooted union operation tree smaller set subtree tree update size field root tree path compression operation node visits reset parent pointer point root figure   heuristics increase running time operation constant factor discuss improve amortized running time figure   path compression heuristic path traversed operation element  restructured tree  log star inverse ackermann functions surprising property tree based partition data structure implemented union size path compression heuristics performing series nunion operations takes  nlog time log log star function inverse tower twos function intuitively log number times eratively ogarithm base  number number smaller  table   sample values table   values log critical values inverse demonstrated table   practical purposes log  amazingly slow growing function growing fact running time series partition operations implemented inverse ackermann function grows asymptotically slower log prove fact define ackermann function grows slowly inverse grows define indexed ackermann function ai a0 n n0  ai  ai1  i1 ai ai1 ai    ackermann functions define progression functions ł a0 n multiply function ł n power function ł math  tower twos function ł define ackermann function incredibly fast growing function likewise inverse ackermann function min incredibly slow growing function grows slower log function inverse log slow growing function   selection number applica tions interested identifying single element terms rank relative dering entire set examples include identifying minimum maximum elemen interested identifying median element element half elements smaller remaining half larger general queries element rank called order statistics defining selection problem discuss general order statistic problem selecting kth smallest element unsorted collection comparable elements selection problem solve problem sorting collection indexing sorted sequence k1 comparison based sorting algorit hms approach nlog time overkill cases      easily solve selection problem values time natural question achieve running time values including interesting case finding median floorln  floorr    prune search  small surprise solve selection problem time technique achieve result involves intere sting algorithmic design patte design pattern prune search decrease conquer applying design pattern solve problem defined collection objects pruning fraction objects recursively solving smaller problem finally reduced problem defined constant sized collection objects solve problem brute force method returning recurs ive calls completes construction cases avoid recursion case simply iterate prune search reduction step apply brute force method incidentally binary search method    prune andsearch design pattern    randomized quick select code fragment   randomized quick select algorithm applying prune search pattern selection problem design simple practical method called randomized quick select finding kth smallest element unordered sequence elements total order relation defined randomized quick select runs expected time random choices algo rithm expectation depend whatsoever randomness assu mptions input distribution note randomi zed quick select runs time worst case justification left exercise   provide  exercise    modifying randomized quick select deterministic selection algorithm runs worst case time existence deterministic algorithm theoretical constant factor hidden big notation large case suppose unsorted sequence comparable elements integer  high level quick select algorithm finding kth smallest element structure random ized quicksort algorithm    pick element random pivot subdivide subsequences storing elements equal greater prune step based determine ese sets recur randomized quick select code fragment   algorithm quickselect input sequence comparable elements integer  output kth smallest element  return element pick random pivot element divide sequences ł storing elements łe storing elements equal łg storing elements greater quickselect return element equal quickselect š note selection parameter    analyzing randomized quick select showing randomized quick select runs time requires simple probabilistic argument argument based linearity expectation states random variables number denote expected expression running time randomized quick select sequence size algorithm depends ndom events running time random variable bound expected recursive invocation algorithm good partitions size   recursive good probability   denote number consecutive recursive calls including good characterize recurrence equation n   constant applying linearity expectation  n  n  recursive good probability   recursive good independent parent good expected  expected number times flip fair coin heads  shorthand write case  n  bn convert relation closed form itera tively apply inequality assuming large applications   n b   bn point general case expected running time  times geometric sum base positive number  proposition   proposition   expected running time randomized quick select sequence size assuming elements compared  time   exercises source code exercises visit datastructures net reinforcement   suppose list bits   long sort merge sort algorith quick sort   suppose list bits   long sort stably bucket sort algorithm   complete justification proposition      merge sort tree figures     edges drawn arrows meaning downward arrow upward arrow   complete pseudo code description recursive rge sort algorithm takes array input output   running time merge sort algorithm element sequence nlogn power    suppose element sorted sequences viewed sets duplicate entries time method computing sequence representing set duplicates   sets   suppose modify deterministic vers ion quick sort algorithm selecting element element sequence pivot choose element  running time version quick sort sequence sorted   modification deterministic versi quicksort algorithm selecting element element sequence pivot choose element  kind sequence version quick sort time   case running time quick sor sequence size distinct elements nlogn   randomized version place quick sort pseudo code    probability input element belongs logn subproblems size group randomized quick sort    suppose algorithm inplacequicksort code fragment   executed sequence duplicate elements algorithm correctly sorts input sequence result divide step differ high level description   result inefficiencies partition step elements equal pivot sequence storing elements equa pivot computed algorithm recur subsequences subsequences running time algorith input elements equal   inputs comparis based sorting algorithm absolute maximum number inputs sorted comparisons   jonathan comparison based sor ting algorithm sorts elements sequence size time big characterization biggest   merge sort algorithm   stable   algorithm sorts key entries key straggling time entries equal keys appears input algorithm places output change merge sort algorithm   straggling   radix sort method xicographically sorting sequence triplets integers range   scheme extended sequences tuples k1 k2 kd ki integer range     bucket sort algorithm place    input list requires merge sort heap sort nlogn time sort insertion sort runs time reverse list   pseudo code perform path compression path length time tree based partit ion union structure   george claims fast path compression partition structure starting node puts list starts parent pointers time encounters node adds updates parent pointer node point parent george algorithm runs time path length   place version ick select algorithm pseudo code   worst case running time quick select element sequence creativity   linda claims algorithm takes input sequence produces output sequence sorting elements algorithm issorted testing time sorted explain algorithm issorted sufficient prove output linda algorithm sorting  additional linda algorithm output algorithm correctness coul established time   sets represented sorted sequences efficient algorithm computing set elements   suppose represent sets balanced search trees analyze algorithms methods set adt assuming sets smaller   analyze efficient met hod removing duplicates collection elements   sets elements integers range   popular scheme representing set type boolean array true cell represented single bit referred bit vector analyze efficient algorithms performing methods set adt assuming representation   version deterministic quic sort pick pivot median elements input sequence elements fixed constant odd number  argue informally good choice pivot asymptotic worst case running time quick sort case terms   analyze randomi zed quick sort recurrence equation case denote expected running time randomized quick sort observe worst case partitions good bad splits write   n     time needed partition list pivot concatenate result sublists recursive calls return induction nlogn   modify inplacequicksort code fragment   handle general case efficiently input sequence duplicate keys   nonrecursive place versi quick sort algorithm algorithm based divide conquer approach explicit stack process subproblems algorithm guarantee stack depth logn   randomized quick sort runs nlogn time probability   high probability answering ach input element define   random variable  element  subproblems belong size group argue define   random variable  probability  j independent events log4  argue expected probability  chernoff bound states sum finite number independent   random variab expected       argue previous claim prove randomized quick sort runs nlogn time probability     array entries keys equal   place method ordering     suppose element sequence element represents vote president vote integer representing candidate design nlogn time algorithm wins election represents assuming candi votes wins candidates   voting problem exercise   suppose number candidates running nlogk time algorithm determining wins election   voting problem exercise   suppose candidate wins majority votes cast design analyze fast algorithm determ ining winner   comparison based sorting algorithm stable asymptotic running time   suppose sequences elements duplicates total order relati defined efficient algorithm determining set elements running time method   array integers range   simple method sorting time   s1 sk sequences elements integer keys range   parameter  algorithm running  time sorting seque nces union denotes total size sequences   sequence elements total order relation defined efficient method dete rmining equal elements running time method   sequence elements total order relation defined recall inversion pair elements appears algorithm running nlogn time determining number inversions   sequence integers met hod printing pairs inversions time number inversions   random permutation distinct integers gue expected running time insertion sort hint note half elements ranked half sorted version expected half   sequences integers integer log time algorithm determining integer integer   set integers analyze fast method finding logn integers closest median   bob set nuts set bolts nut unique matching bolt nuts bolts ly kind comparison bob nut bolt pair test threads larger smaller perfect match  threads analyze efficient algorithm bob match nuts bolts   deterministic time selection algorithm sort sequence elements log worst case time   unsorted sequence comparable elements integer nlogk expected time algorithm finding elements rank     sequence insert removemin operations keys involved integers range   algorithm running nlog determining answer removemin   space aliens program aliensplit sequence integers partition time sequences  sk size elements equal element     fixed number aliensplit sort nlogn log time   karen path compression tree based union partition data structure starting node puts nodes path root set scans sets parent pointer node parent parent pointer ecall pa rent pointer root points pass changed node parent pointer repeats process repeating process scan change node parent karen algorithm correct analyze running time path length   problem deals modification quick select algorithm deterministic time element sequence idea modify choose pivot chosen deterministically randomly  partition set  groups size  group sort set identify median element set set  baby medians apply selection algorithm recursively median baby medians element pivot proceed quick select algorithm deterministic method runs time answering questions ignore floor ceiling functions simplifies mathematics asymptotics baby medians equal chosen pivot greater equal pivot baby median equal pivot elements equal pivot true greater equal pivot argue method finding deterministic pivot partition takes time based estimates write currence equation bound worst case running time selection algorithm note worst case recursive callsšone median baby medians recur larger recurrence equation induction projects   experimentally compare performance place quick sort version quick sort place    design implement stable version bucket sort algorithm sorting sequence elements integer keys range    algorithm time   implement merge sort deterministic quick sort perform series benchmarking tests faster tests include sequences random sorted   implement deterministic randomized versions quick sort algorithm perform series benchmarking tests faster tests include sequences random sorted   implement place version insert ion sort place version quick sort perform benchmarking tests determine rang values quick sort average insertion sort   design implement animation sorting algorithms chapter animation illustrate key properties algorithm intuitive manner   implement randomized quick sort quick select algorithms design series experiments test relative speeds   implement extended set adt includes methods union intersect subtract size isempty methods equals insert remove obvious meaning   implement tree based union pa rtition data structure union size path compression heuristics chapter notes  knuth classic text sorting searching  extensive history sorting problem algorithms solving huang langston  merge sorted lists place li time set adt derived set adt aho hopcroft ullman  standard quick sort algorithm hoare  random ization including chernoff bounds appendix book motwani raghavan  quick sort analysis chapter combination analysis previous edition book analysis kleinberg tardos  quick sort analysis exercise   littman gonnet baeza yates  provide experimental comparisons theoretical analyses number sorting algorithms term une search originally computational geometry literature uch work clarkson  megiddo   term decrease conquer levitin  chapter  text processing  contents   string operations     string class     stringbuffer class    patternmatching algorithms     brute force     boyer moore algorithm      knuth morris pratt algorithm        standard     compressed     suffix     search engines    text compression     huffman coding algorithm     greedy method     text similarity testing     longest common subsequence problem     dynamic programming     applying dynamic programming lcs problem      exercises  datastructures net   string operations document processing pidly dominant functions computers computers edit docum ents search documents transport documents internet disp lay documents prin ters computer screens internet document formats html xml text formats tags multimedia content making sense terabytes internet requires considerable text processing addition interesting applications text processing algorithms highlight algorithmic desi gn patterns pattern matching problem rise brute force method inefficient wide applicability text compression apply greedy method  approximate solutions hard problems problems text compression ves rise optimal algorithms finally discussing text similarity introduce dynamic programming design pattern applied special inst ances solve problem polynomial time appears require exponential time solve text processing heart algorithms processing methods dealing character strings character strings wide variety sources including scientific linguistic internet applications examples strings cgtaaactgctttaatcaaacgc datastructures net string dna applications string internet address site accompanies book typical string processing operations involve breaking large strings smaller strings order speak pieces result operations term substring character string refer string form     string formed characters inclusive technically string actua lly substring   rule possibility restrict definition proper substrings require   simplify notation referring substrings denote substring inclusive  convention equal null string length  addition order distinguish special kinds substrings refer substring form    prefix substring form    suffix string dna cgtaa prefix cgc suffix ttaatc proper substring note null string prefix suffix string fairly general notions character string typically restrict characters explicitly character set unicode character set typically symbol denote character set alphabet characters document processing algorithms applicati ons underlying character set  finite assume size alphabet denoted fixed constant string operations flavors thos modify string simply return string modifying distinction precise defining string class represent immutable strings modified stringbuffer class represent mutable strings modified    string class main operations string class listed length return length charat return character startswith determine prefix endswith determine suffix substring return substring concat return concatenation equals determine equal indexof substring return occurrence return  collection forms typical operations immutable strings    set operations performed string abcdefghijklmnop operation output length  charat  concat qrs abcdefghijklmnopqrs endswith javapop false indexof ghi  startswith abcd true substring   efghij exception indexof method discuss   methods easily implemen ted simply representing string array characters standard string implementation    stringbuffer class main methods stri ngbuffer class listed append return replacing insert  return update string inserting inside starting reverse reverse return string setcharat set character charat return character error conditions occur bounds indices string exception charat method methods string class stringbuffer object fortunately stringbuffer class tostring method returns string version access string methods   sequence operations performed mutable string initially abcdefghijklmnop operation append qrs abcdefghijklmnopqrs insert  xyz abcxyzdefghijklmnopqrs reverse srqponmlkjihgfedzyxcba setcharat  srqponmwkjihgfedzyxcba   pattern matching algorithms  classic pattern matching problem strings text string length apattern string length substring notion match substring starting matches character character       output pattern matching algorithm indication pattern exist integer indicating starting substring matching computation performed indexof method string interface alternatively indices substring matching pattern matching algorithms increasing levels difficulty    brute force brute force algorithmic design patte powerful technique algorithm design search optimize function applying technique general situation typically enumerate configurations inputs involved pick enumerated configurations applying technique design brute force pattern matching algorithm derive algorith solving pattern matching problemšwe simply placements relative algorithm code fragment   simple algorithm bruteforcematch input strings text characters pattern characters output starting substring matching indication substring  candidate   return return substring matching code fragment   brute force pattern matching  performance brute force pattern matching algorithm ould simpler consists nested loops outer loop indexing starting indices pattern text loop indexing character pattern comparing character text correctness brute force pattern matching algorithm exhaustive search approach running time brute force pattern matching wors case good candidate perform character comparisons discover match current referring code fragment   outer loop executed  times loop executed times running time brute force method  simplified nm note  algorithm quadratic running time   suppose text string abacaabaccabacabaabb pattern string abacab figure   illustrate execution brute force pattern matching algorithm figure   brute force pattern matching algorithm algorithm performs  character comparisons numerical labels     boyer moore algorithm feel examine character order locate pattern substring case boyer moore bm pattern matching algorithm study avoid comparisons sizable fraction characters caveat brut force algorithm work unbounded alphabet bm algorithm assumes alphabet fixed finite size works fastest phabet moderately sized pattern long bm algorithm ideal searching documents simplified version original algorithm boyer moore main idea bm algorithm improve running time brute force algorithm adding time saving heuristics roughly stated heuristics glass heuristic testing placement comparisons backward character jump heuristic testing placement mismatch text character pattern character handled contained shift completely match character shift occurrence character aligned  formalize heuristics shortly intuitive level work integrated team glass heuristic sets heuristic avoid comparisons groups characters case destination faster backwards encounter mismatch consideration location avoid lots needless comp arisons shifting relative character jump heuristic character ump heuristic pays big applied early testing potential placement busine defining character jump heuristics integrated string pattern matchi algorithm implement heuristic define function takes character alphabet characterizes shift pattern character equal text matc pattern define ł occurrence conventionally define  characters indices arrays function easily implemented table leave method computing table time simple exercise   function perform character jump heuristic code fragment   bm pattern matching algorithm code fragment   boyer moore pattern matching algorithm  jump step illustrated figure   figure   illustration jump step algorithm code fragment   distinguish cases  shift pattern units  shift pattern unit  figure   illustrate execution boyer moore pattern matching algorithm input string   figure   illustration bm pattern matching algorithm algorithm performs  character comparisons numerical labels  correctness bm pattern matching algorithm fact time method shift gu aranteed skip matches location occurrence worst case running time bm algorithm nm computation function takes time actual search pattern takes nm time worst case brute force algorithm text pattern pair achieves worst case worst case performance achieved english text case bm algorithm skip large portions text figure   experimental evidence english text average number comparisons character   character pattern string figure   boyer moore execution english text  implementation bm patte matching algorithm code fragment   code fragment   implementation bm pattern matching algorithm algorithm expressed static methods method bmmatch performs matching calls auxiliary method build lastfunction compute function expressed array indexed ascii code character method bmmatch absence match returning conventional   presented simplif ied version boyer moore bm algorithm original bm algorithm achieves running time  alternative shift heuristic partially tched text string shifts pattern character jump heuristic alternative shift heuristic based applying main idea knuth morris pratt pattern matching algorithm discuss    knuth morris pratt algorithm studying worst case performance brute force bm pattern matching algorithms specific instances problem   notice major inefficienc perform comparisons testing potential placemen pattern text discover pattern character match text throw gained compar isons start scratch incremental placement pattern knuth morris pratt kmp algorithm discussed sect ion avoids waste achieves running time optimal worst case worst case pattern matching algorithm examine characters text characters pattern failure function main idea kmp algorithm preprocess pattern string compute failure function proper shift largest extent reus performed comparisons failure function defined length longest prefix suffix  note  convention   discuss compute failure function efficiently failure function encodes repeated substrings inside pattern   pattern string abacab   knuth morris pratt kmp failure function string table kmp pattern matching algorithm code fragment   incrementally processes text string comparing pattern string time match increment current indices hand mismatch progress consult failure function determine continue checking mismatch  simply increment variable repeat process match reaches length indicating pattern pint code fragment   kmp pattern matching algorithm main kmp algorithm loop performs comparison character character iteration depending outcome comparison algorithm moves characters consults failure function candidate character starts correctness algorithm definition failure function comparisons skipped unnecessary failure function guarantees comparisons redunda ntšthey involve comparing matching characters figure   illustration kmp pattern matching algorithm failure function pattern   algorithm performs  character comparisons numerical labels  figure   illustrate execution kmp pattern matching algorithm input strings   note failure function avoid redoing comparisons character pattern character text note algorithm performs fewer comparisons brute force gorithm strings figure   performance excluding computation failure function running time kmp algorithm proportional number iterations loop sake analysis define intuitively total pattern shifted respect text note execution algorithm cases occurs iteration loop ł increases  change increases  ł  change increases  case  addition  positive  ł  increases  increases  change iteration loop increases  total number iterations loop kmp pattern matching algorithm  achieving bound assumes computed failure function  constructing kmp failure function construct failure function method code fragment   bootstrapping process kmpmatch algorithm compare pattern itsel kmp algorithm time characters match set  note execution algorithm  defined code fragment   computation failure function kmp pattern matching algorithm note algorithm previous values failure function efficiently compute values algorithm kmpfailurefunction runs time analysis analogous algorithm kmpmatch proposition   knuth morris pratt algorithm performs pattern matching text string length pattern string length time  implementation kmp pattern matching algorithm code fragment   code fragment   implementation kmp pattern matching algorithm algorithm expressed static methods method kmpmatch performs matching calls auxiliary method computefailfunction compute failure function expressed array method kmpmatch absence match returning conventional      pattern matching algorithms presented previous speed search text preprocessing pattern compute failure function kmp algorithm functi bm algorithm complementary approach esent string searching algorithms preprocess text approach suitable applications series queries performed fixed text initial cost preprocessing text compensated speedup subsequent query web site offers pattern matching shakespeare hamlet search engine offers web hamlet topic trie pronounced tree based data structure storing strings order support fast pattern matching main pplication retrieval rie word trie val retrieval application search dna sequence genomic database collection strings defined alphabet primary query operations ies support pattern matching prefix matching operation nvolves string strings prefix    standard set strings alphabet string prefix string standard trie ordered tree properties figure   ł node root labeled character ł ordering childr internal node determined canonical ordering alphabet ł external nodes string concatenation labels nodes path root external node yields string trie represents strings paths root external nodes note assuming string prefix string ensures string uniquely external node satisfy assumption adding special character original alphabet string internal node standard trie  children size alphabet ther edge root children character string collection addition path root internal node depth corresponds  figure   standard trie strings bear bell bid bull buy sell stock character prefix   string fact character follow prefix   string set child labeled character trie concisely stores common prefixes exist set strings characters alphabe trie essentially binary tree internal nodes havi child improper binary tree general characters alphabet trie multi tree internal node  children addition internal nodes standard trie fewer children trie figure   internal nodes child implement trie tree storing characters nodes proposition portant structural properties standard trie proposition   standard trie storing collection strings total length alphabet size properties ł internal node children ł external nodes ł height equal length longest string ł number nodes  worst case number nodes trie occurs strings share common nonempty prefix root internal nodes child trie set strings impl ement dictionary keys strings perform search string tracing root path characters path traced terminates external node dictionary trie figure   tracing path bull ends external node path traced path traced terminates internal node dictiona figure   path bet traced path ends internal node word dictionary note impleme ntation dictionary single characters compared entire string easy running time search string size dm size alphabet visit  nodes spend time node alphabets imp rove time spent node  logd dictionary characters implemented hash table search table constant appli cations stick simple approach takes time node visited discussion trie perform special type pattern matching called word matching determine pattern matches text figure   word matching differs standa pattern matching pattern match arbitrary substring text trie word matching pattern length takes dm time size alphabet independent size text alphabet constant size case text natural languages dna strings query takes time proportional size pattern simple extension scheme supports prefix matching queries arbitrary occurrences pattern text pattern proper suffix word spans efficiently performed construct standard trie set strings incremental algorithm inserts strings time recall assumption string prefix string insert string current trie trace path string prefix string tracing path internal node reaching create chain node descendents store remaining characters time insert dm length size alphabet constructing entire trie set takes dn time total length strings figure   word matching prefix matching standard trie text searched standard  trie text articles prepositions excluded external nodes augmented indications word positions potential space inefficiency standard trie prompted development compressed trie historical reasons patricia trie lot nodes standard trie child existence nodes waste discuss compressed trie    compressed  compressed trie standard trie ensures internal node trie children forces rule compressing chains single child nodes individual edges figure   standard trie internal node redundant child root trie figure   redundant nodes chain  edges v0 v1 v1 v2 vk1 vk ith redundant ł vi redundant  k1  ł v0 vk redundant transform compressed trie replacing redundant chain v0 v1 vk1 vk  edges single edge v0 vk relabeling vk wconcatenation labels nodes v1 vk figure   compressed trie strings bear bell bid bull buy sell stock compare standard trie figure   nodes compressed trie labeled strings substrings strings collection rath individual characters advantage compressed trie standard trie number nodes compressed trie proportional nu mber strings eir total length proposition compare proposition   proposition   compressed trie storing collection strings alphabet size properties ł internal node children children  ł external nodes ł number nodes attentive reader compression paths advantage offset expansion node labels compressed trie advantageous auxiliary structure collection strings stored primary structure required store characters strings collection suppose collection strings array strings    storing label node explicitly represent implicitly triplet integers substring consisting characters jth kth included figure   compare standard trie figure   figure   collection strings stored array compact represen tation compressed trie additional compression scheme reduce total space trie standard trie compressed trie total length strings number strings store strings reduce space  trie application collection strings stored compactly    suffix primary applications case strings collection suffixes string trie called suffix trie suffix tree position tree string figure  a suffix trie suffixes string minimize suffix trie compact representation presented evious simplified label vertex pair indicating string figure  b satisfy rule suffix prefix suffix add special character denoted original alphabet suffix string length build trie set strings    saving space suffix trie save space standard trie space compression techniques including compressed trie advantage compact representation apparent suffix total leng suffixes string length storing suffixes explicitly space suffix trie represents strings implicitly space forma lly stated proposition proposition   compact representation suffix trie string length space construction construct suffix trie string length incremental algorithm    construction takes dn2 time total length suffixes quadratic compact suffix trie string length constructed time specialized algorithm general linear time construction algorithm fairly complex reported advantage existence fast construction algorithm suffix trie solve problems  figure   suffix trie string minimize compact representation pair denotes suffix trie suffix trie string efficiently perform pattern matching queries text determine pattern substring trace path substring  path traced details pattern matching algorithm code fragment   assumes additional property labels nodes compact representation suffix trie node label string length path root included  property ensures easily compute start pattern text match occurs code fragment   pattern matching suffix trie denote label node start pair indices substring text  correctness algorithm suffixtriematch fact search trie matching characters pattern time events occurs ł completely match pattern ł mismatch caught termination loop break ł left characters matched processing external node  size pattern size alphabet order determine running time algorithm suffixtriematch observations ł process  nodes trie ł node processed children ł node processed perform character comparison child determine child processed improved usi fast dictionary children ł perform character comparisons processed nodes ł spend  time character comparison performance conclude algorithm suffixtriematch performs pattern matching queries dm time ster dictionary children nodes suffix trie note running time depend size text running time linear size pattern constant size alphabet suffix suited repetitive pattern matching app lications ries pattern matching queries performed fixed text summarize proposition proposition   text string characters alphabet size perform pattern matching queries dm time length pattern suffix trie space constructed dn time explore application subsection    search engines wide web huge coll ection text documents web gathered program called web crawler stores special dictionary database web search engine users retrieve relevant formation database identifying relevant web cont aining keywords simplified model search engine  inverted files core stored search engine dictionary called inverted inverted file storing key pairs word collection word keys dictionary called terms set vocabulary entries proper nouns large elements dictionary called occurrence lists cover web efficiently implement inverted data structure consisting  array storing occurrence lists terms order  compressed trie set terms external node stores occurren list term reason storing occurrence lists outsi trie size trie data structure small fit internal memory large total size occurrence lists stored disk data structure query single keyword word matching query    keyword trie return occurrence list multiple keywords desired output keywords retrieve occurrence list keyword trie return intersection facilitate intersection computation occurrence list implemented sequence sorted address dictionary generic merge computation discussed   addition basic task returning list keywords search engines provide additional service ranking returned relevance devising fast accurate ranking algorithms search engines major challenge computer researchers electronic commerce companies   text compression text processing task text compression problem string defined alphabet ascii unicode character sets efficiently encode small binary string characters   text compression situation communicating low bandwidth channel modem infrared connection minimize time needed  transmit text likewise compression storing collections large documents efficiently fixed capacity storage device documents method text compression expl ored huffman code standard encoding schemes ascii unicode systems fixed length binary strings encode characters  bits ascii  unicode huffman code hand variablelength encoding optimized string optimization base character frequencies character count number times appears string huffman code saves space fixed length encoding short code word strings encode high frequency characters long code word strings encode low frequency characters encode string convert character fixed length code word variable length code word concatenate code order produce encoding order avoid ambigui ties insist code word encoding prefix code word encoding code called prefix code simplifies decoding order figure   restriction savings produced variable length prefix code wide variance character frequencies case tural language text spoken language huffman algorithm producing optim variable length prefix code based construction binary tree represents code node root represents bit code word left child representing  child representing  external node specific character code word character defined sequence bits nodes path root figure   external node frequency simply frequency character addition internal node frequency sum frequencie external nodes subtree rooted figure   illustration huffman code input string fast runner afraid dark frequency character huffman tree string code character tracing path root external node stored associating left child  child   code  code     huffman coding algorithm huffman coding algorithm distinct characters string encode root node single node binary tree algorithm proceeds series rounds round algorithm takes binary trees smallest frequencies merg single binary tree repeats process tree left code fragment   iteration loop huffman algorithm implemented logd time priority queue represented heap addition iteration takes nodes adds process repeated  times node left algorithm runs dlogd time justif ication algorithm correctness scope note intuition simple ideašany optimal code converted optimal ode code lowest frequency characters differ bit repeating argument string replaced character proposition   huffman algorithm constructs optimal prefix code string length distinct characters dlogd time code fragment   huffman coding algorithm     greedy method huffman algorithm building optimal encoding application algorithmic design pattern called greedy method design pattern applied optimization problems construct structure minimizing maximizing property structure general formula greedy method patt ern simple brute force method order solv optimization problem greedy method proceed sequence choices sequence starts understood starting condition computes cost initial condition pattern asks iteratively additional choices identifying decision achieves cost improvement choices approach lead optimal solution problems work problems possess greedy choice property property global optimal condition reached series loca lly optimal choices choices current possibilities time starting defined starting condition problem computing optimal variable length prefix code problem possesses greedy choice property    text similarity testing common text processing problem arises genetics software engineering test similarity text strings genetics application strings correspond strands dna individuals genetically long subsequence common respective dna sequences likewise software engineering application strings versions source code program determine version ndeed determining similarity strings considered common operation unix linux operating systems program called diff comparing text files    longest common subsequence problem ways define similarity strings abstract simple ye common version problem character strings subsequences string x0x1x2 xn1 asubsequence string form i1 xi2 xik  sequence characters contiguous order string aaag subsequence string cgataattgaga note concept subsequence string substring string defined   problem definition specific text similarity oblem address longest common subsequence lcs problem problem character strings x0x1x2 xn1 y0y1y2 ym1 alphabet alphabet common computational genetics asked longest string subsequence solve longest common ubsequence problem enumerate subsequences largest subsequence character subsequence  subsequences requires time determine subsequence brute force approach yields exponential time algorithm runs nm time inefficient discuss algorithmic sign pattern called dynamic programming solve longest common ubsequence problem faster    dynamic programming  algorithmic techniques problems require exponential time produce polynomial tim algorithms solve dynamic programming technique ddition algorithms result applications dynamic programming technique simpleš needing lines code nested loops filling table components dynamic programming solution dynamic programming technique optimization problems number ways exponential brute force search computationa lly infeasible smallest problem sizes apply dynamic programming technique situations problem structure exploit structure involves components simple subproblems repeatedly breaking global optimization problem subpr oblems simple defining subproblems indices subproblem optimization optimal solution global problem composition optimal subproblem soluti ons globally optimal solution suboptimal subproblems subproblem overlap optimal solutions unrelated subproblems subproblems common general components dynamic programming algorithm apply longest common subsequence problem    applying dynamic programming lcs problem solve longest common subsequence problem faster exponential time dynamic programmi technique mentioned key components dynamic programming technique definition simple subproblems satisfy subproblem optimization subproblem overlap properties recall lcs problem character strings length asked longest string subsequence character strings natural set indices define subproblemsšindices strings define subproblem computing  denote length longest string subsequence  x0x1x2  y0y1y2 definition torewrite terms optimal subproblem solutions definition depends cases figure   ł case matc character  character  claim char acter belongs longest common subsequence   justify claim suppose true longest common subsequence xi1xi2 xik yj1yj2 set set yjk xik yjk sequence setting ik jk alternately xjk longer common subsequence adding longest common subsequence   ends i1   ł case common subsequence includes common subsequence ends max  j1 order equations sense boundary cases   assign            m1 definition satisfies subproblem optimization longest common subsequence longest common subsequences subproblems subproblem overlap subproblem solution problems problems     figure   cases longest common subsequence algorithm note algorithm stores values matches lcs algorithm  turning definition algorithm straightforward initialize   array boundary cases   initialize             slight abuse notation reality rows columns starting  iteratively build values   length longest common subsequence pseudo code description approach dynami programming solution longest common subsequence lcs problem code fragment   code fragment   dynamic programming algorithm lcs problem performance running time algorithm code fragment   easy analyze dominated nested loops outer iterating times iterating times statement assignment inside loop requires  primitive operations algorithm runs nm time dynamic programming technique applied longest common subsequence problem improve signifi cantly exponential time brute force solution lcs problem algorithm lcs code fragment   computes length longest common subsequence stored   subsequence proposition simple postprocessing step extract longest common subsequence array returned algorithm  proposition   string ofn characters string characters longest common subsequence nm time justification algorithm lcs computes   length longest common subsequence nm time table values constructing longest common subsequence straightforward method start work table reconstructing longest common subsequence position determine true character subsequence noting previous character moving   larger   figure   reach boundary cell   method constructs longest common subsequence additional time figure   illustration algorithm constructing longest common subsequence array   exercises source code exercises visit datastructures net  reinforcement   list prefixes string aaabbaaa suffixes   draw figure illustrating comparis ons brute force pattern matching text aaabaadaabaaa pattern aabaaa   repeat previous problem bm pattern matching algorithm counting comparisons compute function   repeat previous problem kmp pattern matching algorithm counting comparisons compute failure function   compute table representing unction bm pattern matching algorithm pattern string quick brown fox jumped lazy cat assuming alphabet starts space character   assuming characters alphabet enumerated arrays time method constructing function length pattern string   compute table representing kmp ilure function pattern string cgtacgttcgt   draw standard trie set strings abab baba ccccc bbaaaa caa bbaacc cbcc cbca   draw compressed trie set strings exercise      draw compact representation suffix trie string minimize minime   longest prefix string cgtacgttcgtacg suffix string   draw frequency array huffman tree string dogs spot hot pots cats   longest common subsequence array strings skullandbones lullabybabies longest common subsequence strings creativity   text length pattern length force brute force pattern matching algor ithm running time nm   justification kmpfailurefunction method code fragment   runs time pattern length   modify kmp string pa ttern matching algorithm occurrence pattern string appears substring running time catch matches overlap   text length pattern length time method finding longest prefix substring oft    pattern length circular substring text length     normal substring equal concatenation suffix prefix time algorithm determining circular substring   kmp pattern matching algorithm modified faster binary strings redefining failure function denotes complement kth bit modify kmp algorithm advantage failure function method computing failure function method comparisons text pattern opposed n comparisons needed standard kmp algorithm      modify simplified bm algorithm presen ted chapter ideas kmp algorithm runs time   string length string length time algorithm finding longest prefix suffix   efficient algorithm deleting string standard trie analyze running time   efficient algorithm deleti string compressed trie analyze running time   algorithm constructing compact representation suffix trie noncompact representa tion analyze running time   text string length time method finding longest prefix substring reversal    efficient algorithm longest palindrome suffix string length recall palindrome string equal reversal running time method   sequence x0 xn1 numbers time algorithm finding longest subsequence i0 xi1 xi2 xik1 numbers  xij xij  longest decreasing subsequence   define edit distance strings length number edits takes change edit consists character insertion character deletion character replacement strings algorithm rhythm edit distance  design nm time algorithm computing edit distance   design greedy algorithm making change buys candy costing cents customer clerk  algorithm minimize number coins returned greedy algorithm return minimum number coins coins denominations         set denominations wh ich algorithm return minimum number coins include algorithm fails   efficient algorithm determining pattern subsequence substring text running time algorithm   strings length define length longest common substring suffix length  suffix length design nm time algorithm computing values     anna contest pieces candy candy store free anna realize candy expensive costing dollars piece candy cheap costing pennies piece jars candy numbered    jar pieces price piece design time algorithm anna maximize pieces candy takes winnings algorithm produces maximum anna   integer arrays size arbitrary integer design log time algorithm determine exist numbers   time algorithm previous problem projects   perform experimental analysis usi documents internet efficiency number character comparisons performed brute force kmp pattern matching algorithms varying length patterns   perform experimental analysis usi documents internet efficiency number character comparisons performed brute force bm pattern matching algorithms varying length patterns   perform experimental comparison relative speeds bruteforce kmp bm pattern matching algorithms document time coding algorithms relative running times documents internet searched varying length patterns    implement compression decompression scheme based huffman coding   create class implements standard trie set ascii strings class constructor takes argument list strings class method tests whet string stored trie   create class implements compresse trie set ascii strings class constructor takes argument list strings class method tests whet string stored trie   create class implements prefix ascii string class constructor takes argument string method pattern matching string   implement simplified search engine    small web site rds site terms excluding articles prepositions pronouns   implement search engine small web site adding ranking feature simplified search engine    ranking feature return relevant site ndex terms excluding articles prepositions pronouns   write program takes character strings representations dna strands computes edit distance showing pieces exercise   chapter notes kmp algorithm knuth morr pratt journal article  boyer moore algorithm journal article published year  article knuth  prove bm algorithm runs linear time cole  bm algorithm  character comparisons wors case bound tight algorithms discussed discussed book chapter aho  albeit theoretical framework including methods regular expression  pattern matching reader interested study string pattern matching algorithms referred book stephen  book chapters aho  crochemore lecroq  trie invented morrison  discussed extensively classic sorting searching book knuth  patricia short practical algorithm retrieve coded alphanumeric  mccreight  construct suffix linear time introduction field retrieval includes disc ussion search engines web provided book baeza yates ribeiro neto  chapter  graphs contents   graph abstract data type     graph adt    data structures graphs      edge list structure     adjacency list structure     adjacency matrix structure    graph traversals     depth search     implementing depth search     breadth search    directed graphs      depth search traversing digraph     transitive closure     directed acyclic graphs    weighted graphs    shortest paths     dijkstra algorithm    minimum spanning trees     kruskal algorithm     prim jarník algorithm     exercises  datastructures net   graph abstract data type graph representing relationships exist pairs objects graph set objects called vertices collection pairwise connections notion graph confused bar charts function plots kinds graphs unrelated topic chapter gra phs applications host domains including mapping transportation electrical engineering computer networks viewed abstractly graph simply set vertices collection pairs vertices called edges graph representing connections relationships pairs objects set incidentally books terminology graphs refer vertices nodes edges arcs terms vertices edges edges graph directed undirected edge directed pair ordered preceding edge undirected pair ordered undirected edges denoted set notation simplicity pair notation noting undirected case graphs typically visualized drawing vertices ovals rectangles edges segments curves connecting pairs ovals rectangles examples directed undirected graphs   visualize collaborati ons researchers discipline constructing graph vertices researchers edges conne pairs vertices researchers coauthored paper book figure   edges undirected coauthorship symmetric relation coauthored coauthored figure   graph coauthorship authors    associate obj ect oriented program graph vertices represent classes defined program edges inheritance classes edge vert vertex class extends class edges directed inheritance relation direction asymmetric edges graph undirected graph undirected graph likewise directed graph called digraph graph edges directed graph directed undirected edges called mixed graph note undirected mixed aph converted directed graph replacing undirected edge pair directed edges undirected mixed graphs represented graphs applications   city map modeled graph vertices intersections dead ends edges stretches streets intersections graph undirected edges correspond stretches twoway streets directed edges correspond stretches streets graph modeli city map mixed graph   physical examples graphs electrical wiring plumbing networks building networks modeled graphs connector fixture outlet viewed vertex uninterrupted stretch wire pipe viewed edge graphs components larger graphs local power water distribution networks depending specific aspects aphs interested edges undirected directed principle water flow pipe current flow wire direction  vertices joined edge called vertices endpoints edge edge directed endpoint origin destination edge vertices adjacent edge vertices edge incident vertex vertex edge endpoints outgoing edges vertex directed edges origin vertex incoming edges vertex directed edges destination vertex degree vertex denoted deg number incident edges degree degree vertex number incoming outgoing edge denoted indeg outdeg   study air transportation constructing graph called flight network vertices airports edges flights figure   graph edges directed flight specific travel direction origin airport destination airport endpoints edge correspond origin destination flight airports adjacent flight flies edge incident vertex flight flies airport outgoing edges vertex correspond outbound flights airport incoming edges correspond inbound flights air port finally degree vertex vofg corresponds number inbound fli ghts airport degree vertex corresponds number outbound flights definition graph refers group edges collection set allowing undirected edges vertices directed edges origin destination edges called parallel edges multiple edges parallel edges flight network   case multiple edges pair vertices flights operating rout times day special type edge connects vertex edge undirected directed loop endpoints coincide loop occur graph city map   correspond circle curving street returns starting point exceptions graphs para llel edges loops graphs simple edges simple graph set vertex pairs collection chapter assume graph simple figure   directed graph representing flight network endpoints edge ua  lax lax adjacent degree dfw  degree dfw   propositions follow explore properties graphs proposition   graph edges justification edge counted summation endpoint endpoint total contribution edges degrees vertices number edges proposition   directed graph edges justification directed graph edge contributes unit degree origin unit degree destination total contribution edges degrees vertices equal number edges degrees simple graph vertices edges proposition   simple graph vertices edges undirected   directed   justification suppose undirected edges endpoints loops maximum degree vertex  case proposition   m  suppose directed edges origin destination loops maximum degree vertex  case proposition    path sequence alternating vertices edges starts vertex ends vertex edge incide predecessor successor vertex cycle path edge start vertices path simple vertex path distinct cycle simple vertex cycle distinct directed path path edges directed traversed direction directed cycle defined figure   bos nw  jfk aa  dfw directed simple path lax ua  ua  dfw aa  lax directed simple cycle path cycle simple graph omit edges defined case list adjacent vertices cycle adjacent vertices   graph representing city map   model couple driving dinner ecommended restaurant traversing path accidentally intersection traverse simple path likewise model entire trip couple takes restaurant cycle restaurant comp letely intersection tw ice entire round trip simple cycle finally travel streets entire trip model night directed cycle subgraph graph graph rtices edges subsets vertices edges flight network figure   vertices bos jfk mia edges aa   form subgraph spanning subgraph subgraph vertices graph graph connected vertices path graph connected maxi mal connected subgraphs called connected components forest graph cycles tree connected forest connected graph cycles note definition tree chapter  context graphs tree root ambiguity trees chapter  referred rooted trees trees chapter referred free trees connected components forest free trees spanning tree graph spanning subgraph free tree   talked aph today internet viewed graph vertices computers undirected edges  communication connections pa irs computers internet computers connections single domain wiley form subgraph internet subgraph connected users computers domain send packets leave domai suppose edges subgraph form spanning tree implies single connection pulls comm unication cable computer domain subgraph longer connected number simple properties trees forests connected graphs proposition   undirected graph vertices edges ł connected  ł tree  ł forest  leave justification proposition exercise      graph adt abstract data type graph collection elements stored graph positionsšits vertices edges store elements graph edges vertices define vertex edge interfaces extend position interface introduce simplified graph adt suitable vertex edge positions undirected graphs graphs edges undirected additional methods ealing directed edges discussed   vertices return iterable collection vertices graph edges return iterable collection edges graph incidentedges return iterable collection edges incident vertex opposite return endvertex edge distinct vertex error occurs incident  endvertices return array storing vertices edge areadjacent test vertices adjacent replace replace element stored vertex replace replace element stored edge insertvertex insert return vertex storing element insertedge insert return undirected edge vertices storing element removevertex remove vertex incident dges return element stored removeedge remove edge return element stored ways realize graph adt explore ways   data structures graphs discuss popular ways representing graphs referred edge list structure adjacency list structure adjacency matrix representations collection store vertices graph edges fundamental difference structures edge list structure adjacency list structure store edges graph adjacency matrix stores placeholder pair vertices edge explain fference implies graph  vertices edges edge list adjacency list representation space adjacency matrix representation  space    edge list structure edge list structure simple efficient representation graph representation vertex storing element explicitly represented vertex object vertex objects stored collection array list node list array list naturally vertices numbered vertex objects vertex object vertex stori element instance variables ł reference ł reference position entry vertex object collection distinguishing feature edge list structure represents vertices represents edges structure edge storing element exp licitly represented edge object edge objects stored collection typically array list node list edge objects edge object dge storing element instance variables ł reference ł references vertex objects associ ated endpoint vertices ł reference position entry edge object collection visualizing edge list structure illustrate edge list structure graph figure   figure   graph schematic representation edge list structure visualize elements stored vertex edge  objects element names actual references element objects reason structure called edge list structure simplest common implementation edge llection list order conveniently search specific objects edges implement dicti onary entries store element key edge spite calling edge list implement collecti dictionary reason keeping tradition structure edge list structure  main feature edge list structur direct access edges vertices incident define simple algorithms methods endvertices opposite performance edge list structure method inefficient edge list structure accessing edges incident vertex determining set vertices requires exhaustive inspection edge objects collection order determine dges incident vertex examine edges edge list check incident method incidentedges runs time proportional number edges graph proportional degree vertex fact check rtices adjacent areadjacent method requires search entire edge collection edge vertices removing vertex involves removing incident edges method removevertex requires complete search edge collection table   summarizes performance edge list structure implementation graph assumption colle ctions realized doubly linked lists    table   running times methods graph implemented edge list structure space number vertices number edges operation time vertices edges endvertices opposite  incidentedges areadjacent  replace  insertvertex insert edge removeedge  removevertex details selected methods graph adt ł methods vertices edges implemented calling iterator iterator ł methods incidentedges areadjacent time determine dges incident vertex inspect edges ł collections li sts implemented doubly linked list insert vertices insert remove edges  time ł update method removevertex takes time requires inspect edges remove incident edge list representation simple limitations    adjacency list structure adjacency list structure graph adds extra edge list structure supports direct access incident edges adjacent vertices vertex approach allo ws adjacency list structure implement methods graph adt faster edge list structure representations space proportional number vertices edges graph adjacency list structure includes structural components edge list structure ł vertex object holds referen collection called incidence collection elements store refe rences edges incident  ł edge object edge vertices holds references positions entries edge incidence collections traditionally incidence collection vertex li representing graph adjacency list structure adjacency list structure direct access edges vertices vertices incident edges illustra adjacency list structure graph figure   figure   graph schematic representation adjacency list structure figure   visualize elements collections names performance adjacency list structure  methods graph adt implemented edge list structure  time impl emented  time adjacency list structure essentially algorithms addition provide access vertices edges directions speed performance number graph methods adjacency list structure edge list structure table   summarizes performance adjacency list structure implementation graph assuming collections incidence collections vertices implemented doubly linked lists vertex space incidence collection proportional degree deg proposition   space requirement adjacency list structure table   running times methods graph implemented adjacency list structure space number vertices number edges operation time vertices edges endvertices opposite  incidentedges deg areadjacent min deg deg replace   insertvertex insertedge removeedge  removevertex deg contrast edge list things adjacency list structure improved running times methods ł method incidentedges takes time proportional number incident vertices deg time ł method areadjacent performed inspecting incidence collection choosing smaller min deg deg running time ł method removevertex takes deg time    adjacency matrix structure adjacency list structure adjacency matrix structure graph extends edge list structure additional component case augment edge list matrix tw dimensional array determine adjacencies pairs vertices constant time adjacency matrix representation vert ices integers set    edges pairs integers store references edges cells dimensional array adjacency matrix representation extends edge list structure figure   ł vertex object stores distin integer range    called ł dimensional arra cell holds reference edge exists rtex vertex edge null figure   graph parallel edges schematic representation simplified adjacency matrix structure  performance adjacency matrix structure graphs parallel edges adjacency matrix representation extended storing pointer edge store pointer inci dence collection stores edges graphs simple complication simple adjacency matrix perform method areadjacent  time achieve running time accessing vertices determine respective indices testing null  optimal performance method areadjacent counteracted increase space usage  running time methods method incidentedges requires examine entire row column array runs time vertex insertions deletions quire creating array larger smaller size takes  time table   summarizes performance adjacency matrix structure implementation graph tabl observe adjacency list structure superior adjacency matr space superior time methods areadjacent method table   running time graph implemented adjacency matrix operation time vertices edges endvertices opposite areadjacent  incidentedges deg replace insertedge removeedge  insert vertex remove vertex historically boolean adjacency matrices representations graphs true edge fact surprising acency matrix natural appeal mathematical structure undirected graph symmetric  adjacency matrix adjacency list struct ure natural appeal computing faster methods algorithms algorithms method areadjacent space efficiency graph algorithms exam ine efficiently acting graph stored adjacency list representation cases trade occurs graphs edges efficiently processed adjacency list structure graphs edges efficiently processed adjacency matrix structure   graph traversals greek mythology tells elaborate labyrin built house monstrous minotaur bull labyrinth complex beast human escape human greek hero theseus king daughter ariadne decided implement graph traversal algorithm theseus fastened ball read door labyrinth unwound traversed twisting passages search monster theseus knew good algorithm design finding defeating beast theseus easily string labyrinth loving arms ariadne formally traversal systematic procedure exploring graph examining vertices edges    depth search traversal algorithm depth search dfs undirected graph depth search testing number properties graphs including path vertex graph connected depth search undirected graph analogous wandering labyrinth string paint lost specific starting vertex initialize fixing string painting visited vertex current vertexšcall current vertex traverse arbitrary edge incident current vertex edge leads visited painted vertex return vertex hand leads unvisited vertex unroll string paint visited current vertex repeating mputation aboce eventually dead current vertex edges incident lead vertices visited edge incident return impasse roll string backtracking edge brought visited vertex current vertex rep eat computation edges incident looked incident edges lead visited vertices roll string backtrack vertex  repeat proced ure vertex continue backtrack path traced vertex unexplored edges edge continue traversal process terminates backtracking leads ack start vertex unexplored edges incident simple process traverse edges figure   figure   depth search traversal graph starting vertex discovery edges solid lines edges dashed lines input graph path discovery edges traced edge hit reaching dead backtracking resuming edge hitting dead backtracking backtracking  discovery edges edges  visualize dfs traversal orie nting edges direction explored traversal distinguishing edges discover vertices called discovery edges tree edges lead visited vertices called edges figure  f analogy discovery edges edges unroll string traverse edges edges return unrolling string scovery edges form spanning tree connected component starting vertex edges tree edges assuming rooted start vertex edge leads vertex tree ancestors tree pseudo code dfs traversal starting vertex analogy string paint recursion implement string analogy assume mechanism pa int analogy determine vertex edge explored label edges discovery edges edges mechanism require dditional space affect running time algorithm pseudo code desc ription recursive dfs algorithm code fragment   code fragment   dfs algorithm number observations depth search algorithm derive dfs algorithm partitions edges undirected graph groups discovery edges edges edges connect vertex visited vertex edge implies cycle consisting discovery edges edge proposition   undirected graph dfs traversal starting vertex performed traversal visits  vertices connected component discovery edges form spanning tree connected component justification suppose vertex connected component visited unvisited vertex path unvisited vertex path neighbor visited visited ha considered edge correct unvisited unvisited vertices connected component mark edges unvisited vertices form cycle discovery edges discovery edges form tree spanning tree depth search visits vertex connected component terms running time depth firs search efficient method traversing graph note dfs called vertex edge examined vertices vertices edges connected component vertex dfs starting runs time provided conditions satisfied ł graph represented data structure creating iterating incidentedges iterable collection takes degree time opposite method takes  time adjacency list structure stru cture adjacency matrix structure ł mark vertex edge explored test vertex edge explored  time discuss ways implementing dfs achieve goal assumptions solv number interesting problems proposition   graph vertices edges represented adjacency list dfs traversal performed time solve problems time ł testing connected ł computing spanning tree connected ł computing connected components ł computing path vertices exists  ł computing cycle reporting cycles justification proposition   based algorithms modified versions dfs algorithm subroutines    implementing depth search mentioned data stru cture represent graph impacts performance dfs gorithm adjacency list yield running time aversing graph vertices edges adjacency matrix hand result running time calls incidentedges method time graph dense close edges difference choices minor  time graph sparse close edges adjacency matrix approach slower adjacency list approach implementation als vertices edges represented marking vertices edges visited simple solutions drawbacks ł build vertex edge objects explored field dfs algorithm marking approach simple supports constant time mark ing unmarking assumes designing graph dfs mind valid approach needlessly stricts dfs graphs vertices explored field generic dfs algorithm graph input approach limitations ł auxiliary hash table store explored vertices edges dfs algorithm scheme general require special fields positions graph approach achieve worst case constant time marking unmarking vertices edges hash table supports mark insert test operations constant expected time   fortunately middle ound extremes decorator pattern marking explored vertices dfs traversal decorator software engineering design pattern pattern add decorations called attributes existing objects decoration identified key identifying decoration key decorations motivated algorithms data structures add extra variables temporary scratch data objects  variables decora tion key pair dynamically attached object dfs decorable vertices edges explored decoration boolean making graph vertices decorable realize decorator pattern position allowing decorated add labels vertices edges requiring advance kinds labels simply require vertices edges implement decorable position adt inherits position adt map adt   methods decorable pos ition adt union methods position adt map adt addition size isempty methods decorable position support element return element stor position map decoration key returning null decoration assigned null mapping remove remove decoration mapping returning null entries return key decoration pairs position map methods decorable positi provide simple mechanism accessing setting decorations decora tion key set decoration key key object including special explored object dfs algorithm create interface defining adt code fragment   implement decorable position object stores element map principle running times methods decorable position  depend implementation underl ying map algorithms small constant number decorations decorable position methods  worst case time tter implement embedded map code fragment   interface defining adt decorable positions note generic parameterized types inherited map methods advance types decorations objects types decorations decorable positions complete dfs traversal algorithm code fragment   code fragment   dfs graph decorable edges vertices generic dfs implementation  code fragments     implementation generic depth search traversa general class dfs method execute takes input graph start vertex auxiliary needed initializes graph calls recursive method dfstraversal activates dfs traversal implementation assumes vertices edges decorable positions decorations vertices ges visited dfs class methods special tasks dfs traversal ł setup called prior dfs traversal dfstraversal ł initresult called execution dfstraversal ł startvisit called star visit ł traversediscovery called discovery edge traversed ł traverseback called edge traversed ł isdone called determine traversal early ł finishvisit called finished exploring ł result called return output dfstraversal ł finalresult called return output execute method output dfstraversal code fragment   instance variables support methods class dfs performs generic dfs traversal methods visit unvisit isvisited implemented decorable positions parameterized wildcard symbol match parameter decorable positions continues code fragment    code fragment   main template method dfstraversal class dfs performs generic dfs traversal graph continued code fragment     template method pattern dfs dfs class based template method pattern    describes generic computation mechanis specialized redefining steps identify vert ices edges visited traversal calls methods isvisited visit unvisit interesting extend dfs redefine auxiliary methods appr oach conforms template method pattern code fragments     illustrate applications dfs traversal class connectivitydfs code fragment   tests graph connected counts vertices reachable dfs traversal starting vertex compares number tota number vertices graph code fragment   specialization class dfs test graph connected class componentsdfs code fragment   finds connected components graph labels vertex connected component number decorator pattern returns number connected components code fragment   specialization dfs compute connected components  class findpathdfs code fragment   finds path pair start target vertices performs pth search traversal start vertex maintain path disc overy edges start vertex current vertex encounter une xplored vertex add path finish processing vertex remove path traversal terminated target vertex encountered path returned iterable colle ction vertices edges kinds positions graph note path class consists discovery edges code fragment   specialization class dfs path start target vertices  class findcycledfs code fragment   finds cycle connected component vertex performi depth search traversal terminates edge ound returns iterable collection vertices edges cycle formed edge code fragment   specialization class dfs cycle connected component start vertex     breadth search breadth search bfs traversal algorithm dfs bfs traverses connected component graph defines spanning tree bfs adventurous dfs wandering graph bfs proceeds rounds subdivides vertices  levels bfs thought traversal string paint bfs unrolling string conservative manner bfs starts vertex level  defines anchor string round string length edge visit vertices reach unrolling string farther case visit paint visited vertices adjacen start vertex sšthese vertices level  round unroll string length edges visit vertices reach unrolling string farther vertices adjacent level  vertices assigned level level  bfs traversal terminates vertex visited pseudo code bfs starting vertex code fragment   auxiliary space label edges mark visited vertices store collections levels collections  l1 store vertices level  level  level  collections implemented queues bfs nonrecursive code fragment   bfs algorithm illustrate bfs traversal figure    figure   brea dth search traversal edges incident vertex explored alphabetical order adjacent vertices discovery edges solid lines cross edges dashed lines graph traversal discovery level  discovery level  discovery level  discovery level  discovery level    nice properties bfs approach performing bfs traversal label vertex length shortest path terms number edges start vertex vertex level bfs starting vertex length shortest path dfs visualize bfs traversal orienting edges direction explored traversal distinguishing edges discover vertices called discovery edges lead visited vertices called cross edges figure  f dfs discovery edges form spanning tree whic case bfs tree nontree edges edges case connects vertex ancestors nontree edge connects vertex vertex ancestor descendent bfs traversal algorithm number interesting properties explore proposition proposition   undirected graph bfs traversal starting vertex performed ł traversal visits vertices connected component ł discovery edges form spanning tree bfs tree connected component ł vertex level path bfs tree edges path edges ł edge bfs tree level numbers differ  leave justification proposition exercise   analysis running time bfs dfs implies proposition   graph vertices edges represented adjacency list struct ure bfs traversal takes time exist time algorithms based bfs problems ł testing connected ł computing spanning tree connected ł computing connected components  ł start vertex computi vertex path minimum number edges reporting path exists ł computing cycle reporting cycles   directed graphs issues specific directed graphs recall directed graph digraph graph edges directed methods dealing directed edges edges graph directed add methods graph adt order deal edge directions isdirected test edge directed insertdirectededge insert return directed edge origin destinati storing element edge directed method endvertices return array  origin  destination running time method isdirected  running time method insertdirectededge match undirected edge insertion reachability fundamental issues ith directed graphs notion reachability deals determining directed graph traversal directed graph goe directed paths paths edges traversed accordi respective directions vertices digraph reaches reachable directed path vertex reaches edge reaches origin vertex edge digraph connected vertices reaches reaches directed cycle cycle edges traversed respective directions note cycle consisting edges opposite direction pair vertices  digraph acyclic directed cycles figure   examples transitive closure digraph digraph vertices vertices edge directed path define starting digraph adding extra edge reachable edge figure   examples reachability digraph directed path bos lax drawn blue directed cycle mia dfw lax blue vertices induce connected subgraph subgraph vertices edges reachable blue removing dashed blue edges acyclic digraph  interesting problems deal reachability digraph include ł vertices determine reaches ł vertices reachable vertex ł determine connected ł determine acyclic ł compute transitive closure remainder expl ore efficient algorithms solving problems    traversing digraph  undirected graphs explore digraph systematic methods akin depth search dfs breadth search bfs algorithms defined undirected graphs sections       explorations answer reachability questions directed depth search breadth search methods develop performing explorations undirected counterparts fact real differen directed depth search breadth search methods traverse edges respective directions directed version dfs starting vertex recursive algorithm code fragment   figure   code fragment   directed dfs algorithm figure   dfs digraph intermediate step time visited vertex dfw reached completed dfs tree edges solid blue lines edges dashed blue lines forward cross edges dashed black lines order vertices visited label vertex edge dfw edge dfw forward edge edge bos sfo forward edge sfo lax cross edge  dfs digraph partitions edges reachable starting vertex tree edges discovery edges lead discover vertex nontree edges visited vertex tree edges form tree rooted starting vertex called depth search tree kinds nontree edges ł edges connect vertex ancestor dfs tree ł forward edges connect vertex descendent dfs tree ł cross edges connect vertex vertex ancestor descendent refer figure  b type nontree edge proposition   digraph depth search starting vertex visits vertices reachable dfs tree directed paths vertex reachable justification subset vertices visited dfs starting vertex vertex reachable belongs suppose sake contradiction vertex reachable directed path edge path dfs reaches explores outgoing edges reach vertex edge contradiction vertex reachable analyzing running time directed dfs method analogous undirected counterpart recursive vertex  edge traversed origin henc vertices edges reachable vertex directed dfs starting runs time provided digraph represente data structure supports constant time vertex edge methods adjacency list structure satisfies requirement proposition   dfs vertices reachable vertex transitive closure perform dfs starting vertex vertices reachable adding edge transitive closure likewise repeatedly traversing digraph dfs starting turn vertex easily test connected connected dfs visits vertices derive proposition proposition   digraph vertices edges problems solved algorithm traverses times dfs runs time auxiliary space ł computing vertex subgraph reachable ł testing connected ł computing transitive closure testing strong connectivity determine directed graph connected faster depth searches performing dfs directed graph starting arbitrary vertex vertex visited dfs reachable graph connected dfs visits vertex reverse edges reverse direction method perform dfs starting reverse graph vertex visited dfs graph str ongly connected vertices visited dfs reach algorithm dfs traversals runs time  directed breadth search dfs extend breadth search bfs work directed graphs algorithm visits vertices level level partitions set edges tree edges discovery edges form directed breadth search tree rooted start vertex nontree edges directed dfs method directed bfs method leaves kinds nontree edges edges connect vertex ancestors cross edges connect vertex vertex ancestor descendent forward edges fact explore exercise      transitive closure explore alternat ive technique computing transitive closure digraph digraph vertices edges compute transitive closure series rounds initialize arbitrarily number vertices v1 v2 vn computation rounds round  generic round truct digraph cons starting adding directedge ved igraph edges vi vk vk thiway enforce simple rule embodied proposition hat proposition    digraph edge vi digraph directed path vi intermediate vertices set v1 vk equal transitive closure proposition   suggests simple algorithm computing transitive closure based series rounds algorithm floyd warshall algorithm pseudo code code fragment   pseudo code sily analyze running time floyd warshall algorithm assuming data structure representing supports methods areadjacent insertdirectededge  time main loop executed times inne loop considers  pairs vertices performing constant time computation total running time floyd warshall algorithm  code fragment   pseudo code floyd warshall algorithm algorithm computes  transitive closure incrementally computing series digraphs  description algorithmic desi gn pattern dynamic programming discussed    description analysis derive proposition proposition   digraph vertices represented data structure supports lookup update adjacency  time floyd warshall algorithm computes transitive closure n3 time illustrate floyd warshall algorithm figure   figure   sequence digraphs computed floyd warshall algorithm initial digraph numbering vertices digraph note digraph edges vi vk vk edge vi drawing digraph  edges vi vk vk dashed blue lines edge vi thick blue performance floyd warshall algorithm  running time floyd warshall algor ithm slower performing dfs directed graph vertices depends representation graph graph represented adjacency matrix running dfs thod directed graphtakes time explore reason exercise   running dfs times takes n3 time single execution floyd warshall algorithm floyd warshall algorithm simpler implement graph represented adjacency list structure running dfs algorithm times time compute transitive closure graph dense edges approach runs n3 time complicated single instance floyd warshall algorithm case repeatedly calling dfs method graph dense represented adjacency list structure    directed acyclic graphs directed graphs directed cycles encountered applications digraph referred directed acyclic graph dag short applications graphs include ł inheritance cla sses program ł prerequisites ourses degree program ł scheduling constraints betw een tasks project   order manage large project convenient break collection smaller tasks tasks rarely independent scheduling constraints exist house building project task ordering nails precedes task nailing shingles roof deck scheduling constraints circularities project impossible order job work experience order work experience job scheduling constraints impos restrictions order tasks executed constraint task completed task started precede order execution tasks model feasible set tasks vertices directed graph place directed edge tow task executed task define directed acyclic graph motivates definition digraph vertices topological ordering ordering v1 vn vertices edge vi topological ordering  ordering directed path traverses vertices creasing order figure   note digraph topological ordering figure   topologi cal orderings acyclic digraph proposition   topological ordering acyclic justification necessity statement easy demonstrate suppose topologically ordered assume sake contradiction cycle consisting edges vi0 vi1 vi1 vi2 vik  vi0 topological ordering i0 i1 ik1 i0 impossible acyclic argue sufficiency condition suppose acyclic algorithmic desc ription build topological ordering acyclic vertex incoming edges degree   vertex v1 exist tracing directed path arb itrary start vertex eventually encounter visited vertex contradicting acyclicity remove  outgoing edges digraph sti acyclic digraph vertex incoming edges vll  vertex repeating process digraph  ordering  vn vertices construction edge vi vi deleted deleted v1 vn topological ordering proposition   justification suggests algorithm code fragment   called topological sorting computi topological ordering digraph code fragment   pseudo code topological sorting algorithm application algorithm figure   proposition   digraph vertices andm edges topological sorting algorithm runs time auxiliary space computes topol ogical ordering fails number vertices directed cycle  justification initial computation degrees setup incounter variables simple traversal graph takes time decorator pattern associate counter attributes vertices vertex visited topological sorting algorithm removed stack vertex visited incounter  implies predecessors ver tices outgoing edges visited consequence vertex directed cycle visited vertex ill visited algorithm traverses outgoing edge visited vertex running time proportional number outgoing edges visited vertices algorithm runs time space usage observe stack incounter variables attached vertices space topological sorting algorithm code fragment   tests input digraph acyclic algorithm terminates ordering vertices subgraph vertices ordered directed cycle figure   algorithm topologicalsort code fragment   initial configuration loop iteration vertex labels rtex number current incounter edges traversed dashed blue arrows thick lines denote vertex edges examined current iteration    weighted graphs    breadth search strategy shortest path arting vertex vertex connected graph approach sense cases edge good situations appro ach graph represent comput network internet interested finding fastest route data packet  computers case edges equal connections computer network typically faster edges mi ght represent slow phone connections represen high speed fiber optic connections likewise graph represent roads cities interested finding fastest travel cross country case edges equal intercity distances larger natural graphs edges weighted equally weighted graph graph numeric integer label edge called weight edge weighted graph figure   figure   weighted graph vertices represent major airports edge weights represent distances miles graph path jfk lax total weight   dfw minimum weight path graph jfk lax remaining sections chapter study weighted graphs   shortest paths weighted graph length weight path sum weights edges v0 v1 v1 v2 vk1 vk length denoted defined  distance vertex vertex denoted length minimum length path called shortest path path exists people convention path path distance defined cycle total weight negative suppose vertices represent cities weights edges represent money costs city pay jfk cost edge jfk negative illing pay jfk negative weight cycl distances longer defined build path cycles city city jfk cycles times likes jfk fore existence paths build arbitrarily low negative cost paths case fortune process distances arbitrarily low negative numbers time edge weights represent distan ces careful introduce negative weight cycles suppose weighted graph asked shortest path vertex vertex viewing weights edges distances sect ion explore efficient ways finding shortest paths exist algorithm discuss simple common case edge weights nonnegative  edge advance negative weight cycles recall special case computing shortest pa weights equal solved bfs traversal algorithm presented    interesting approach solving single source problem based greedy method design pattern    recall pattern solve problem hand repeatedly selecting choice iteration paradigm situations optimize cost function collecti objects add objects collection time picking optimizes function chosen    dijkstra algorithm main idea applying greedy met hod pattern single source shortest path problem perform weighted breadth search starting greedy method develop algorithm iteratively grows cloud vertices vertices entering cloud order  distances iterati vertex chosen vertex cloud closest algorithm terminates vertices cloud point shortest path vertex approach simple powerful greedy method design pattern greedy method finding shortest paths applying greedy method single ource shortest path problem algorithm dijkstra algorithm applied graph problems greedy method solution called traveling salesman problem shortest path visits vert ices graph number situations whic greedy method compute solution chapter discuss situations computing shortest paths constructing minimum spanning tree order simplify scription dijkstra gorithm assume input graph undirected edges undirected simple loops parallel edges denote edges unordered vertex pairs dijkstra algorithm finding shortest paths cost function optimize application eedy method function computešthe shortest path distance circular reasoning realize actu ally implement approach bootstrapping trick consisting approximation distance function compute equal true distance edge relaxation define label vertex approximate distance meaning labels store length path initially  define set cloud vertices initially pty set iteration algorithm select vertex smallest label pull iteration pull vertex pulled update label vertex adjacent refl ect fact update operation relaxation procedure takes estimate checks improved closer true metaphor relaxation spring stretched relaxed true resting shape case dijkstra algorithm relaxa tion performed edge  computed edge specific edge relaxation operation edge relaxation pseudo code dijkstra algorithm code fragment   note priority queue store vertices cloud code fragment   dijkstra algorithm single source shortest path problem illustrate iterations dijkstra algorithm figures     figure   execution dijkstra algorithm weighted graph start vertex bwi box vertex stores label symbol ł edges shortest path tree drawn thick blue arrows vertex cloud current  edge pulling solid blue continues figure   figure   execution dijkstra algorithm continued figure    works interesting surprising aspect dijkstra algorithm moment vertex pulled label stores correct length shortest path algorithm terminates computed shortest path distance vertex solved single source shortest path problem immediat ely clear dijkstra gorithm correctly finds shortest path start vertex vertex graph distance equal label time vertex pulled cloud time removed priority queue swer question depends negative weight edges graph greedy method work correctly proposition  proposition   dijkstra algorithm vertex pulled cloud label equal length shortest path justification suppose vertex vertex algorithm pulled cloud removed shortest path moment pulled vertex moment predecessor pa note figure   choice point incorrect vertex pulled tested updated point vertex shortest path implies moment picking join clear subpath shortest path shortest path shortest path  negati weight edges contradicts definition vertex figure   schematic illustration justification proposition    running time dijkstra algorithm analyze time comp lexity dijkstra algorithm denote number vertices edges input graph assume edge weights compared constant time high level descripti dijkstra algorithm code fragment   analyzing running time requires details implementation data structures implemented assume repres enting graph adjacency list structure data structure step vertices adjacent relaxation step time proportio nal number settle details algorithm implement principle data ructure algorithmšthe priority queue efficient implementation priority queue heap   extract vertex ith smallest label removemin method logn time pseudo code time update label update key priority queue heap implementation adaptable priority queue   adaptable priority queue implemented heap key update replacekey entry storing key vertex location aware easily implement key updates logn time location aware entry vertex access storing heap    assuming implementation dijkst algorithm runs logn time  referring code fragment   details running time analysis ł inserting vertices initial key logn time repeated insertions time heap construction    ł iteration loop spend logn time remove vertex degree log time perform relaxation procedure edges incident ł running time loop log proposition   note express nning time function log worst case alternative implementation dijkstra algorithm alternative implementation adaptable priority queue unsorted sequence requires spend time extract minimum element fast key updates provided supports location aware entries    implement key update rela xation step  timešwe simply change key locate entry update implementation running time simplified simple comparing implementations choices implementing adaptable priority queue location aware entries dijkstra algorithm heap implementation yields running time log unsorted sequence implementation yields running time  implementations fairly simple code equal terms programming sophisti cation needed implementations equal terms constant actors worst case running times worst case times prefer heap implementation number edges graph small  log prefer sequence implementation number edges large  log  proposition   simple undirected weighted graph vertices edges weight edge nonnegative vertex dijkstra algorithm putes distance vertices log worst case time alternatively worst case time exercise   explore modify ijkstra algorithm output tree rooted path vertex shortest path programming dijkstra algorithm pseudo code description dijkstra algorithm code performing dijkstra algorithm assuming undirected graph positive integer weights express algorithm class dijkstra code fragments  œ13  weight decoration edge extract ight class dijkstra assumes edge weight decoration code fragment   class dijkstra implementing dijkstra algorithm continues code fragment    main computation dijkstra algor ithm performed method dijkstra visit adaptable priority queue supporting location aware entries    insert vertex method insert returns location aware entry ttach entry method setentry retrieve method getentry note associating entries verti ces instance decorator design pattern    additional data structure labels exploit fact key vertex retrieved entry changing label vertex relaxation procedure corresponds calling method replacekey location aware entry  code fragment   method dijkstravisit class dijkstra continued code fragment      minimum spanning trees suppose connect computers office building cable model oblem weighted graph vertices represent comput ers edges represent pairs computers weight edge equal cable needed connect computer puter computing shortest path tree vertex interested finding free tree vertices minimum total weight trees methods finding tree focus problem definition weighted undirected graph interested finding tree vertices minimizes sum tree vert connected graph spanning tree problem computing anning tree smallest total weight minimum spanning tree mst problem development efficient algorithm minimum spanning tree problem predates modern notion computer ience discuss classic algorithms solving mst problem algorithms applications greedy method discussed previous based choosing objects join growing collection iteratively picking object minimizes function algorithm discuss kruskal algorithm grows clusters edges order weights gorithm discuss prim jarník algorithm grows mst singl root vertex dijkstra shortest path algorithm    order simplify desc ription algorithms assume input aph undirected edges undirected simple ha loops parallel edges denote edges unordered vertex pairs discuss details algorithms crucial fact minimum spanning trees rms basis algorithms crucial fact minimum spanning trees  mst algorithms discuss based greedy method case depends crucially fact figure   figure   illustration crucial fact minimum spanning trees proposition   weighted connected graph v1 v2 partition vertices disjoint nonempty sets lete edge minimum weight endpoint  v2 minimum spanning tree edges justification minimum spanning tree edge addition create cycle edge cycle endpoint v1 v2 choice remove spanning tree total weight minimum spanning tree tree minimum spanning tree fact weights distinct minimum spanning tree unique leave justification crucial fact exercise   addition note proposition   remains valid graph negative weight edges negative wei ght cycles algorithms presented shortest paths     kruskal algorithm reason proposition   basis building minimum spanning tree kruska algorithm build minimum spanning tree clusters initially vertex cluster algorithm considers dge turn ordered increasing weight edge connects clusters set edges minimum spanning tree clusters connected merged single cluster hand connects vertices cluster discarded algorithm edges form spanning tree terminates outputs tree minimum spanning tree pseudo code kruskal mst algorithm code fragment   working algorithm figures       code fragment   kruskal algorithm mst problem mentioned correctness kruskal algorithm crucial fact minimum spanning trees proposition   time kruskal algorithm adds edge minimum spanning tree define partitioning set vertices proposition letting  cluster letting v2 rest vertices defines disjoint partitioning vertices importantly extracting edges order weights minimum weight edge vertex v1 v2 kruskal algorithm adds valid minimu spanning tree edge  figure   execution kruskal mst algorithm graph integer weights clusters shaded regions highlight edge considered iteration continues figure    figure   execution kruskal mst algorithm rejected edges dashed continues figure    figure   execution kruskal mst algorithm continued edge considered merges clusters concludes  execution kruskal algorithm continued figure   running time kruskal algorithm denote number vertices edges input graph high level description kruskal algorithm code fragment   analyzing running time requires details implementation ecifically data structures implemented implement priority queue usi heap initialize log time repeated insertions time heap construction    addition iteration loop remove minimum weight edge log time log simple tota time spent performing priority queue operations log represent cluster union partition data structures discussed    recall sequence based union structure perform series union operations log time tree based version plement series operations log time perform  calls method union calls total time spent merging clusters determining clusters vertices belong mlogn sequence based approach mlog tree based approach arguments hose dijkstra algorithm conclude running time kruska algorithm log simplified mlog simple connected     prim jarník algorithm prim jarník algorithm grow minimum spanning tree single cluster starting root vertex main idea dijkstra algorithm vertex defining initial cloud vertices iteration choose minimum weight edge connecting vertex cloud vertex vertex brought cloud process repeated spanning tree formed crucial fact minimum spa nning trees play choosing smallest weight edge joining vertex inside assured adding valid edge mst efficiently implement approach cue dijkstra algorithm maintain labe vertex cloud stores weight current edge joining cloud labels reduce number dges deciding vertex join cloud pseudo code code fragment   code fragment   prim jarník algorithm mst problem  analyzing prim jarn õk algorithm denote number vertices edges input graph implementation issues prim jarník algorithm dijkstra algorithm implement adaptable priority queue heap supports location aware entries    extract vertex iteration log time addition update log time wh ich computation considered edge steps iteration implemented constant time total running time log log illustrating prim jarn õk algorithm illustrate prim jarn õk algorithm figures     figure   illustration prim jarník mst algorithm continues figure    figure   illustration prim jarník mst algorithm continued figure      exercises source code exercises visit datastructures net  reinforcement   draw simple undirected graph  vertices  edges  connected components impossible draw  connected components  edges   simple connected graph vertices edges explain log log   draw adjacency list adjacency matrix representation undirected graph figure     draw simple connected directed graph ith  vertices  edges degree degree vertex  single nonsimple cycle incl udes edges graph trace edges respective directions lifting pencil cycle called euler tour   repeat previous problem remove edge graph single nonsimple path cludes edges graph path called euler path   bob loves foreign languages plan schedule years interested language courses la15 la16 la22 la31 la32 la126 la127 la141 la169 prerequisites ł  ł la16 la15 ł  la22 ł la31 la15 ł la32 la16 la31 ł la126 la22 la32 ł la127 la16 ł la141 la22 la16 ł la169 la32 sequence courses bob satisfy prerequisites   suppose represent graph vertices edge edge list structure case insert vertex method  time remove vertex method runs time   graph vertices integers   adjacent vertices vertex table vertex adjacent vertices                                  assume traversal adjacent vertices vertex returned order listed table draw sequence vertices visited dfs traversal starting vertex  sequence vertices visited bfs traversal starting vertex    adjacency list structure adjacency matrix structure cases justify choice  graph   vertices   edges space graph   vertices    edges space answer query areadjacent fast matter space   explain dfs traversal runs time vertex simple graph represented adjacency matrix structure   draw transitive closure directed graph figure     compute topological ordering dire cted graph drawn solid edges figure  d   queue stack auxiliary data structure topological sorting algorithm code fragment     draw simple connected weighted gra  vertices  edges unique edge weights identify vertex start vert illustrate running dijkstra algorithm graph   modify pseudo code dijkstra algorithm case graph parall edges loops   modify pseudo code dijkstra algorithm case graph directed compute shortest directed paths source vertex vertices    modify dijkstra algorith output distance vertex output tree rooted path vertex shor test path   small islands lake state build bridges connect land reached bridges cost onstructing bridge proportional length distances pairs islands table                                _ _ _                _ _ _  _ _ _ _ bridges build mi nimize total construction cost   draw simple connected undirected ighted graph  vertices  edges unique edge weights illustrate execution kruskal algorithm graph note ther minimum spanning tree graph   repeat previous problem prim jarník algorithm   unsorted sequence implementation priority queue dijkstra algorithm case wh case running time dijkstra algorithm  vertex graph   meaning graphical conventions figure   illustrating dfs traversal colors blue black refer arrows signify thick lines dashed lines   repeat exercise   figure   illustrating bfs traversal   repeat exercise   figure   illustrating directed dfs traversal   repeat exercise   figure   illustrating floyd warshall algorithm    repeat exercise   figure   illustrating topological sorting algorithm   repeat exercise   figures     illustrating dijkstra algorithm   repeat exercise   figures     illustrating kruskal algorithm   repeat exercise   figures     illustrating prim jarník algorithm   edges transitive closur graph consists simple directed path vertices   complete binary tree nodes directed graph nodes vertices parent child pair create directed edge parent child sh transitive closure log edges   simple undirected graph complete edge pair distinct vertices depth rst search tree complete graph   recalling definition complete graph exercise   breadth search tree complete graph   maze constructed correctly path start finish entire maze reachable start loops portions maze maze drawn grid  determine constructed correctly running time algorithm creativity   vertex directed acyclic graph compact numbering vertices integers   edge   time algorithm detecting compact   justify proposition     pseudo code time algorithm computing connected components undirected aph vertices edges   spanning tree rooted start vertex produced depth search connected undirected graph argue edge vertex ancestors edge   suppose represent vertex graph edge list structure assuming identify vertices integers set    implement llection support log time performance areadjacent method implementing method case   tamarindo university schools worldwide joint project multimedia computer network built connect schools communication links form tree schools decide install file server schools share data schools transmission time link dominated link setup synchronization cost data transfer proportional number links desirable choose central location file server free tree node eccentricity length longest path  node node minimum eccentricity called center design efficient algorithm node free tree computes center center unique stinct centers free tree   bfs tree produced connected graph vertex level path edges path edges   time delay long distance determined multiplying small fixed constant number communication links telephone network caller callee suppose telephone network company named free tree engin eers compute maximum time delay experienced long distance free tree diameter length longest path nodes efficient algorithm computing diameter   company named network switching stations connected high speed communication links cust omer phone directly connected station area engineers developed prototype video phone customers phone order ha acceptable image quality number links transmit video signals parties exceed  suppose network represented graph design efficient algorithm computes station set stations reach  links   explain forward nontree edges respect bfs tree constructed directed graph    euler tour directed graph vertices edges cycle traverses edge direction tour exists connected degree equals degree vertex time algorithm finding euler tour digraph   independent set undirected graph subset vertices adjacent maximal independent set inde pendent set add additional vertex independent graph maximal independent question exercise worth thinking efficient algorithm computes maximal independe set graph method running time   undirected graph vertices edges time algorithm traversing edge direction   justify proposition     vertex simple graph dijkstra algorithm log time implemented heap   weighted directed graph negative weight edges negative weight cycle dijkstra algorithm incorrectly computes shortest path distan ces start vertex   greedy strategy finding shortest path vertex start vertex goal connected graph  initialize path start   initialize visitedvertices start  start goal return path exit continue  edge start minimum weight adjacent start visitedvertices  add path  add visitedvertices  set start equal step  greedy strategy shortest path start goal explain intuitively works counter   weights connect weighted graph distinct minimum spanning tree   design efficient algorithm finding longest directed path vertex vertex acyclic weighted digraph graph representation auxiliary data structures analyze time complexity algorithm   diagram telephone network graph vertices represent switching centers edges represent communication lines joining pairs centers edges marked bandwidth bandwidth path bandwidth lowest bandwidth edge algorithm diagram switching centers outputs maximum bandwidth path    computer networks avoid single points failure network nodes disconnect network fail connected graph biconnected vertex removal divide connected components time algorithm adding edges connected graph  vertices  edges guarantee biconnected   nasa link stations spread country communication channels pair stations bandwidth priori nasa select  channels minimum stations linked channels total bandwidth defined sum ndividual bandwidths channels maximum efficient algorithm problem determine worst case time complexity wei ghted graph set stations set annels stations define weight edge bandwidth channel   suppose timetable consists ł set airports ai rport minimum connecting time ł set flights flight û origin airport  û destination airport  û departure time  û arrival time   efficient algorithm flight scheduling problem problem airpor time compute sequence flights arrive earliest time departing time minimum connecting times intermediate airports observed running time algorithm function   inside castle asymptopia maze corridor maze bag gold coins gold bag varies noble knight named sir paul opportunity walk maze picking bags gold enter maze door marked enter exit anothe door marked exit maze retrace steps corridor maze arrow painted wall sir paul corridor direction arrow traverse loop maze map maze including gold direction corridor algorithm sir paul pick gold   weighted digraph vertices design variation floyd warshall algorithm computing lengt shortest paths vertex vertex n3 time   suppose directed graph vertices adjacency matrix product defined   boolean operator boolean definition  imply vert ices  suppose m4 product entries m4 signify entries m5 m4 general contained matrix mp  suppose weighted assume      weight   defined  min   conclude relationship vertices   graph bipartite vertices partitioned sets edge vertex design analyze efficient algorithm termining undirected graph bipartite knowing sets advance   mst method called baruvka algorithm works graph vertices edges distinct weights tbe subgraph initially vertices fewer  edges connected component lowest weight edge add return argue algorithm correct runs mlogn time    graph vertices edges edge weights integers range  algorithm finding minimum spanning tree mlog time projects   write class implementing simplified graph adt methods relevant undirected graphs include update methods adjacency matrix structure class include constructor method takes collections sequences ša collect ion vertex elements collection pairs vertex elementsšand produces graph collections represent   implement simplified graph adt project   adjacency list structure   implement simplified graph adt project   edge list structure   extend class project   support update methods   extend class project   support methods graph adt including methods directed edges   implement generic bfs traversal template method pattern   implement topological sorting algorithm   implement floyd warshall transitive closure algorithm    design experimental comparison repeated dfs traversals versus floyd warshall algorithm computing transitive closure digraph   implement kruskal algorithm assuming edge weights integers   implement prim jarník algorithm assuming edge weights integers   perform experimental comparison minimum spanning tree algorithms discussed chapter ruskal prim jarník develop extensive set experiments test running times algorithms randomly generated graphs   construct maze starts grid grid cell bounded unit length walls remove boundary unit length walls represent start finis remaining unit length wall boundary assign random create graph called dual grid cell vertex edge joining vertices cells cells share common wall weight edge weight wall construct maze finding minimum spanning tree removing walls edges write program algorithm generate mazes solves minimally program draw maze ideally visualize solution   write program builds routing tables nodes computer network based shortest path routing path distance measured hop count number edges path input problem connectivity node network                 network nodes connected     nodes hop routing table node address set pairs route message  node send shortest path program output routing table node network input list node connectivity lists input syntax chapter notes depth search method folklore computer science hopcroft tarjan   algorithm solving graph problems knuth  discusses topological sorting problem simple linear time algorithm determining directed graph connected kosaraju floyd warshall algorithm appears paper floyd  based theorem warshall  mark sweep garbage collection method algorithms performing garb age collection encourage reader interested study garbage collection examine book jones  learn algorithms awing graphs book chapter tamassia  annotated bibliography battista  book battista  minimum spanni tree algorithm baruvka  published  prim jarník algorithm published czech jarník   english  prim  kruskal published minimum spanning tree algorithm   reader interested study history minimum spanning tree problem referred paper graham hell  current asymptotically fastest minimum spanning tree algorithm ndomized method karger klein tarjan  runs expected time dijkstra  published single source shortest path algorithm  reader interested study graph algorithms referred books ahuja magnanti orlin  cormen leiserson rivest   gibbons  mehlhorn  tarjan  book chapter van leeuwen  incidentally running time jarník algorithm dijkstra algorithm impr oved log implementing queue sophi sticated data structures fibonacci heap  relaxed heap   chapter  memory contents   memory management     stacks virtual machine     allocating space memory heap     garbage collection     external memory caching     memory hierarchy     caching strategies    external searching trees     trees     trees    external memory sorting      multi merging    exercises  datastructures net   memory management order implement data structure actual computer computer memory computer memory simply sequence memory consists    bytes depending computer memory numbered   number memory computer number memory word address memory computer viewed basically giant array memory memory constr uct data structures programs requires manage computer memory provide space needed datašincluding variables nodes pointers arrays character stringsšand programs computer discuss basics memory management    stacks virtual machine program typically compiled sequence byte codes defined machine instructions defined modelšthe virtual machine jvm definition jvm heart definition language compiling code jvm byte codes machine language specific cpu program computer personal computer server program emulate jvm interestingly stack data structure plays central role definition jvm method stack stacks application time environment programs running program ecisely running thread private stack called method stack stack short track local variables methods invoked execution figure    execution program virtual machine jvm maintains stack elem ents descriptors active nonterminated invocati ons methods descriptors called frames frame invocation method fool stores current values local variables parameters method fool method cool called fool returned method cool figure   method stack method fool called method cool called method main note values program counter parameters local variables stored stack frames invocation method fool terminates invocation method cool resume execution instruction  incrementing program counter stored stack frame  keeping track program counter jvm special variable called program counter maintain address statement jvm curre ntly executing program method cool invokes method fool current program counter recorded frame current invocation cool jvm return method fool stack frame running method method control execution remaining elements stack frames suspended methods methods invoked method waiting return control termination order elements stack corresponds chain invocations active methods method invoked frame method pushed stack terminates frame  popped stack jvm resumes processing suspended method understanding parameter passing jvm stack perform parameter passing methods parameter passing protocol current variable expression passed argument called method case variable primitive type int float current simply number passed called method ssigned local variable called method frame simple assignment illustrated figure   note called method lue local variable change variable calling method case variable refers object current memory address object address    object passed parameter method address passed address assigned local variable called method refer object refers called method internal state object refers simultaneously changing internal state object refers object nevert heless called program refer object remain unchangedšit refer object referencing method stack jvm implement method calls parameter passing incidentally method stack specific feature time environment modern programming languages including operand stack interestingly anot place jvm stack arithmetic expressions evaluated jvm operand stack simple binary operation computed pushing stack pushing stack calling instruction pops items stack perf orms binary operation pushes result stack li kewise instructions writing reading elements memory involve pop push methods operand stack jvm stack evaluate arithmetic expressions     evaluate arithmetic expression postorder traversal algorithm jvm algorithm recursive explicitly operand stack recursive description equivalent nonrecursive version based operand stack implementing recursion benefits stack implement method invocation programs recursion method discussed   interestingly early programming languages cobol fortran originally time stacks implement method procedure calls elegance efficiency recursion modern programming languages including modern versions classic languages cobol fortran utilize time stack method procedure calls execution recursive method box recursion trace corresponds frame met hod stack content method stack corresponds chain boxes initial method invocation current illustrate time stack recursive methods implementation clas sic recursive definition factorial function    code fragment   code fragment   recursive method factorial time method factorial stack frame includes local variable storing method factorial recursively calls compute  pushes frame time stack turn recursive invocation calls compute  chain  recursive invocations time stack grows size calling factorial  returns  invoking recursively time stack method factorial exist simultaneously active frames point frame stores parameter returned eventually recursive terminates returns  multiplied compute original factorial method    allocating space memory heap discussed    virtual machine allocates method local variables method frame time stack stack kind memory avai lable program data dynamic memory allocation memory object located dynamically method execution method utilize special operator built statement creates array integers size variable int items int size array runtime array continue exist met hod created terminates memory array allocated stack memory heap stack object memory memory area storagešthe memory heap confused heap data structure presented chapter  illustrate memory area memory eas virtual machine figure   storage mory heap divided blocks contiguous array chunks memory variable fixed sizes simplify discussion assume blocks memory heap fixed size   bytes block big object create efficiently handli general case interesting problem figure   schematic view layout memory addresses virtual machine  memory allocation algorithms virtual machine definition requires memory heap allocate memory objects data structure popular method contiguous holes free memory doubly linked list called free list links joining holes stored inside holes memory memory allocated deallocated collection holes free lists unused memo separated disjoint holes divided blocks memory separation unused memory separate holes fragmentation minimize fragmentation kinds fragmentation occur internal fragmentation occurs portion allocated memory block program request arra size   cells array time environment reduce internal fragmentation external fragmentation hand occurs unus memory contiguous blocks allocated memory time environment control allocate memory requested keyword time environment allocate memory reduce external fragme ntation heuristics suggested allocating memory heap minimize external fragmentation fit algorithm searches entire free list hole size closest memory requested fit algorithm searches free list hole large fit algorithm searches free list hole large search left viewing free list circularly linked list    worst fit algorithm searches free list largest hole memory faster search entire free list list main tained priority queue chapter  algorithm requested memo subtracted chosen memory hole leftover hole returned free list sound good fit algorithm produce worst external fragmentation ftover parts chosen holes tend small fit algorithm fast produce lot external  fragmentation free lis slows future searches fit algorithm spreads fragmentation evenly memory heap keeping search times low spreading difficult allocate large blocks worst fit algorithm attempts avoid problem keeping contiguous sections free memory large    garbage collection languages memory space objects explicitly deallocated programmer duty overlooked programmers source frustrating programming errors experienced programmers signers burden memory management time environment mentioned memory objects allocated memory heap space instance variables running program method stacks running thread simple programs discussed book typically running thread instance variables method stack refer objects mory heap variables objects method stacks running threads called root objects objects reached object references start root object called live objects live objects active objects running program objects deallocated running program store variable reference sequence implemented doubly linked li reference variable root object object live object node objects referenced object elements referenced node objects time time virtual machine jvm notice space memory heap scarce times jvm elect reclaim space objec longer live return reclaimed memory free list reclamation process garbage collection algorith garbage collection mark sweep algorithm mark sweep garbage collection algor ithm associate mark bit object identifies object live determine point garbage collection needed suspend running threads clear mark bits objects rrently allocated memory heap trace stacks rrently running threads mark root objects stacks live determine live objectsšthe reachable root objects efficiently directed graph version depth search traversal    case object memo heap viewed vertex directed graph reference object viewed directed edge performing directed dfs root object correctly  identify mark live object process mark phase process completed scan memory heap reclaim space object marked time optionally coalesce allocated space memory heap single block eliminating ternal fragmentation time scanning reclamation process sweep phase completes resume running suspended threads mark sweep garbage collection algorithm reclaim unused space time proportional number live objects referen ces size memory heap performing dfs place mark sweep algorithm rrectly reclaims unused space memory heap issue face mark phase reclaiming memory space time ailable memory scarce care extra space garbage collection trouble dfs algorithm recu rsive    space proportional number vertices graph case garbage collection vertices graph objects memory heap memory alternative perform dfs place recursively perform dfs onstant additional storage main idea performing dfs place simulate recursion stack edges graph case garbage collection correspond object references traverse edge visited vertex vertex change edge stored adjacency list point parent dfs tree return simulating return recursive switch edge modified point identifying edge change possibility number references   store addition mark bit visited tag dfs count identifier tells edges modified count identifier requires extra word storage object extra word avoided implem entations implementations virtual mach ine represent object composition reference type identifier object integer type reference objects data fields object type reference supposed element composition implementations reference mark edge changed leaving object object simply swap reference refers type reference refers return identify edge changed reference composition  position reference type place edge belongs adjacency list edge swapping trick count identifier implement dfs place asymptotic running time   external memory caching computer app lications deal large data examples include analysis scientif data sets ocessing financial transactions organization main tenance databases telephone directories fact data dealt large fit internal memory computer    memory hierarchy order accommodate large data sets computers hierarchy kinds memories vary terms size distance cpu closest cpu internal register cpu access locations fast locations level hierarchy cache memory memory considerably larger register set cpu accessing takes longer multiple caches progressively slower access times level hierarchy internal memory main memory core memory internal memory considerably larger cache memory requires time access finally highest level hierarchy external memory consists disks drives dvd drives tapes memory large slow memory hierarchy computers viewed consisting levels larger slower previous level figure   applications vels matteršthe hold data items level bringing data items higher memory hold items typically computational bottleneck case figure   memory hierarchy  caches disks levels matter depend size problem solve problem fit main memory levels cache mory internal memory access times internal memory   times longer cache memory desirable perform memory accesses cache memory problem fit main memory hand levels internal memory external memory differences dramatic access times disks usual gene ral purpose external memory device typically   times longer internal memory figure perspective imagine student baltimore send request money messa parents chicago student sends parents mail message arrive computer seconds mode communication internal memory access cpu mode communication external memory access  times slower student walk chicago deliver message person month average  mile day accesses external memory    caching strategies algorithms desi gned memory hierarchy mind spite great variance access times levels algorithm analyses book assumed memory accesses equal assumption great oversightšand  addressing final chapteršbut good reasons reasonable assumption justification assumption assume memory accesses time specific device dependent memory sizes ha fact memory size impossible ample program designed computer platforms defined terms specific computer architecture confi guration architecture specific exploit chapter optimized software architecture configuration software longer device independent fortunately optimizations prim arily justification equal time memory access assumption caching blocking justification memory acce equality assumption operating designers developed general mechanisms memory accesses fast mechanisms based locality reference properties software possesses ł temporal locality program accesses memory location access location future common counter variable expressions including increment counter fact common adage computer architects program ends percent time percent code ł spatial locality program accesses memory location access locations program array access locations array sequential sequential manner computer scientists ngineers performed tensive software profiling experiments justify claim software possesses kinds locality reference loop scan array exhibit kinds locality temporal spatial localities tu rise fundamental design choices level computer memory syst ems presen interface cache memory internal memo interface internal memory external memory design choice called virtual memory concept consists providing address space large capacity secondary level memory transferring data located secondary vel primary level  addressed virtual memory lim programmer constraint internal memory size concept bringing data primary memory called caching motivated temporal locality bringing data primary memory hoping accessed respond requests data future design choice motivated spatial locality data stored secondary level memory location accessed bring primary level memory large block contiguous locations include location figure   concept blocking motivated expectation secondary level memory locations close accessed interface cach memory internal memory blocks called cache lines interface internal memory external memory blocks called figure   blocks external memory implemented caching blocking virtual memory perceive secondary level memory ster problem primary level memory smaller secondarylevel memory memory systems blocking program substance reach point requests data secondary level memory primary memory blocks order fulfill request maintain caching blocking remove block primary memory room block secondary memory case deciding eviction brings number interesting data structure algorithm design issues caching algorithms web applications deal revisiting presented web revisits exhibit localities reference time space xploit localities reference advantageous store copies web cache memory  retrieved requested suppose cache memory slots web assume web slot cache fully associative cache browser executes requests web time browser requests web browser determines quick test unchanged contained cache contained cache browser satisfies request cached copy cache requested internet transferred cache slots cache browser assigns slots cells cache occupied computer determine viewed web evict bringing place policies determine evict replacement algorithms replacem ent policies include figure   ł fifo evict cache longest transf erred cache furthest ł lru evict request occurred furthest addition simple purely random strategy ł random choose random evict cache figure   random fifo lru replacement policies  random strategy easiest policies implement requires random pseudo random number nerator overhead involved implementing policy  additional work replacement additional overhead request determine request cache policy attempt advantage mporal spatial localities user browsing exhibits fifo strategy simple implement requires queue store references cache enqueued referenced browser cache evicted computer simply performs dequeue operation determine evict policy requires  additional work replacement fifo policy incurs additional overhead requests advantage temporal locality lru strategy step fifo strategy lru strategy explicitly takes advantage temporal locality evicting policy point view excellent approach costly implementation point view optimizing temporal spat ial locality fairly costly implementing  lru strategy requires priority queue supports searching existing special pointers locators implemented sorted sequence base linked list overhead request replacement  insert update key assigned highest key list  time lru strategy constanttime overhead implementation constant factors involved terms additional time overhead extra space priority queue policy attractive practical point view replacement policies trade6offs implementation difficulty degree advantage localities natural kind comparative analysis methods worst case point view lru strategies fairly unattractive competitive behavior suppose cache fifo lru methods performing replacement program loop repeatedly requests  cyclic order fifo lru policies perform badly sequence requests perform pa replacement request worst case point view ese policies worst imaginešthey require repl acement request worst case analysis pessimistic focuses protocol behavior bad sequence requests ideal analysis compare methods ssible request sequences impossible exhaustively great number experimental simulations quest sequences derived real programs based experimental comparisons lru strategy superior fifo strategy random strategy   external searching trees problem implementing dicti onary large collection items fit main memory main large dictionaries databases refer secondary memory blocks disk blocks likewise refer transfer block secondary memory primary memory disk transfer recalling great time difference exists main memory accesses disk accesses main goal maintaining dictionary external memory minimize number disk transfers needed perform query update fact difference speed disk internal memory great perform considerable number internalmemory accesses avoid disk transfers analyze performance dictionary implementations counting number disk transfers  require perform standard dictionary search update operations refer count complexity algorithms involved inefficient external memory dictionaries simple dictionary implementations list store entries list implemented unsorted doubl linked list insert remove performed  transfers removals searching require transfers worst case link hop perform access block search time improved transfers exercise   denotes number nodes list fit block poor performance alternately implement sequence sorted array case search performs log2n transfers binary search nice improvement solution requires transfers implement insert remove operation worst case access blocks elements list based dictionary implementations efficient external memory simple implementations inefficient logarithmic time internal memory strategies balanced binary trees avl trees red black trees search structures logarithmic average case query update times exam ple skip lists splay trees methods store dictionary items nodes binary tree graph typically node accessed query update structures block methods require log n transfers worst case perform query update operation performance good perform dictionary queri updates logbn logn logb transfers    trees reduce performa nce difference internal memory accesses external memory accesses searching represent dictionary multi search tree    approach rise generalization   tree data structure tree tree multi search tree node children stores   entries algorithms searching inserting removi entries tree straightforward generalizations   trees advantage generalizing   trees trees generalized class trees flexible search structure size nodes running time dictionary operations depends parameters setting parameters appropriately respect size disk blocks derive data structure achieves good external memory performance  definition tree tree integers    multiway search tree dditional restrictions size property internal node children root children depth property external node depth proposition   height tree storing entries log log log log justification tree storing entries height justify proposition establishing bounds size depth properties number external nodes ah  bh proposition    ah   bh logarithm base  term  loga  log  hlogb search update operations recall multi search tree node holds secondary structure dictionary    tree stores entries denote time performing search dictionary search algorithm tree multi search trees    searching tree entries takes log alogn time note constant search time logn main application trees dictionaries stored external memory minimize disk accesses select parameters tree node occupies single disk block  simply count block transfers providing values context rise data structure tree shortly  structure discuss insertions removals handled trees insertion algorithm tree   tree overflow occurs entry inserted node illegal  node recall node multi tree node children remedy overflow split node moving median entry parent replacing  node   node reason requiring   definition tree note consequence split build secondary structures removing entry tree   trees underflow occurs key removed node distinct root illegal  node remedy underflow perform transfer sibling node perform fusion sibling node node fusion a  node reason requiring   table   performance dict ionary realized tree table   time bounds entry dictionary realized tree assume secondary structure nodes support search time split fusion operations time functions  counting disk transfers    trees version tree data structure method maintaining dictionary external memory called tree figure   tree order tree   discussed standard dictionary query update methods trees restrict discussion complexity trees figure   tree order  property ees choose children references  keys stored node fit single disk block implying proportional choice assume proportional analysis sear update operations trees  time access node perform search update operati perform single disk transfer observed search update requires examine  nodes level tree dictionary search update operation tree requires log  logn logb disk transfers insert operation proceeds tree locate node insert entry node overflow  children addition node split nodes    children respect ively process repeated level continue logbn levels likewise remove operation node underflow  š  children references sibling node   children perform fusion operation node sibling repeat computation parent insert operation continue tree logbn levels requirement internal node  children implies disk block support tree half proposition   tree entries complexity logb search update operation blocks size block   external memory sorting addition data structures dictionaries implemented external memory algorithms operate input sets  large fit internal mory case objective solve algorithmic problem block transfers classic domain external memory algorithms sorting problem multi merge sort efficient sort set objects external memory amounts simple external memory variation familiar merge sort algorithm main idea variation merge recu rsively sorted lists time reducing number levels recursion high level description multi merge sort method divide subsets s1 roughly equal size recursively sort subset simultaneously merge sorted lists rted representation perform merge process disk transfers large values total number transfers performed algorithm satisfies recurrence constant  recursion perform single block transfer point objects internal memory sort set efficient internal memory algorithm stopping criterion  implies closed form solution log log logd choose worst case number block transfers performed multi merge sort algorithm low choose   aspect algorithm left perform merge block transfers    multi merging perform merge running tournament tbe complete binary tree external nodes internal memory associate external node sorted list initialize reading external node object reading internal memory block sorted list internal node  parent external nodes compare objects stored children associate smaller repeat comparison test level reach root associate smallest object lists completes initialization merge figure   figure   merge merge  general step merge object root array building merged list trace path external node read object list element block object internal memory othe rwise read block access object associate node pseudo object key repeat minimum putations internal nodes root complete tree repeat process moving object root merged list rebuilding objects step merge takes log time internal time merge nlogd number transfers performed merge scan list order write merged list proposition   array based sequence elements stored external memory sort log log transfers log internal cpu time size internal memory size block   exercises source code exercises visit datastructures net  reinforcement   inserti removal algorithms tree   suppose multi tree ternal node children values valid tree   values tree previous exercise order tree   level recursion rforming external memory merge sort sequence previous exercise   initially memory ache consisting misses lru algorithm incur request sequence                initially memory ache consisting misses fifo algorithm incur request sequence                initially memory ache consisting misses random algorithm incur request sequence              random hoices algorithm case   draw result inserting initially order  tree entries keys                   order   level recursion performing merge sort sequence previous exercise  creativity   implement dictionary external memory unordered sequence insertions require  transfers searches require transfers worst case number elements number list nodes fit disk block   change rules define red black trees red black tree   tree vice versa   modified version tree insertion algorithm time create overflow split node redistribute keys siblings sibling holds roughly number keys cascading split parent minimum fraction block ways filled scheme   external memory dictiona implementation skip list collect consecutive groups nodes individual blocks level skip list define order skip list representation skip list struct ure block  list nodes list nodes choose case maximum number list nodes level skip list fit block modify skip list insertion removal algorithms skip list expected height structure logn logb   external memory data stru cture implement queue adt total number disk transf ers needed process sequence enqueue dequeue operations   solve previous problem deque adt    tree implem ent partition union adt    union operations logn logb disk transfers   suppose sequence elements integer keys elements colored blue elements colored red addition red element pairs blue element key efficien externalmemory algorithm finding red blue pairs disk transfers algorithm perform   caching problem memory cache hold sequence requests pool  optimal strategy offline algorithm misses total starting cache   caching strategy based frequently lfu rule cache accessed evicted requested ties lfu evicts frequently cache longest sequence requests lfu times cache optimal algorithm times   suppose node search function  order tree logd asymptotic running time performing search   external memory algorithm determines transfers list integers occurring  times projects   write class implements methods ordered dictionary adt tree integer constants passed parameters constructor    implement tree data structure assuming block size   integer keys test number disk transfer needed process sequence dictionary operations   implement external memory sorting algorithm compare experimentally internal emory sorting algorithms book chapter notes knuth  nice discussions external memory sorting searching ullman  discusses external memory structures database systems reader interested study architecture hierarchical memory systems referred book chapter burger  book hennessy patterson  handbook gonnet baeza yates  compares performance number sorti algorithms external memory algorithms trees invented bayer mccreight  comer  nice overview data structure books mehlhorn  samet  nice discussions trees variants aggarwal vitter  study complexity sorti problems establishing upper lower bounds including lower bound sorting chapter goodrich  study complexity computational geometry problems reader interested furt study efficient algorithms encouraged examine survey paper vitter   appendix mathematical facts appendix mathematical facts combinatorial definitions facts logarithms exponents logarithm function defined logba identities hold logarithms exponents  logbac logba logbc  logba log logbc  logbac clog  logba logca logcb  blogca alogcb  bac  babc  bac addition proposition    loga logb logc   justification  write ab ab        natural logarithm function lnx logex   progression        addition        x4  number inequalities relating thes functions derive definitions proposition     proposition  for0x     proposition  positive real numbers integer functions relations floor ceiling functions defined  largest integer equal  smallest integer greater equal modulo operator defined integers    factorial function defined     binomial coefficient equal number combinations define choosing items collection items order matter binomial coefficient derives binomial expansion relationships proposition   proposition  stirling approximation  fibonacci progression numeric progression f0  f1  fn1   proposition  defined fibonacci progression gn   called golden ratio  summations number usef ul facts summations proposition  factoring summations provided depend proposition  reversing order special form summation telescoping sum arises amortized analys data structure algorithm facts summ ations analysis data structures algorithms proposition  proposition  proposition   integer constant common summation geometric sum fixed real number   proposition   real number   proposition  real number   combination common forms called linear exponential summation expansion proposition     nth harmonic number hn defined proposition  hn nth harmonic number hn  basic probability review basic facts probabil ity theory basic statement probability defined sample space defined set outcomes experiment leave terms outcomes experiment undefined formal sense  experiment consists outcome flipping coin times sample space   outcomes ordering flips occur sample spaces infinite illustrates  experiment consists flipping coin heads sample space infinite outcome sequence tails single flip heads    probability space sample space probability function maps subsets real numbers interval   captures thematically notion probability events occurring formally subset  called event probability function assumed possess basic properties respect events defined  ø        ø events independent collection events mutually independent ai1 aik ai1 ai2 aik subset ai1 ai2 aik conditional probability event occurs event denoted defined ratio assuming  elegant dealing events terms random variables intuitively random variables variables values depend outcome experiment formally random variable function maps outcomes sample space real numbers indicator random variable random variable maps outcomes set   data structure algorithm analysis random variable characterize running time randomized algorithm case sample space defined outcomes random sources algorithm interested typical aver age expected random variable expected random variable defined summation defined range case assumed discrete proposition  linearity expectation random variables number   random variable assigns outcome roll fair dice sum number dots showing  justification justify claim  random variables number dots die instances function outcome roll fair die occurs probability                    random variables independent real numbers proposition  random variables independent xy  random variable assigns outcome roll fair dice product number dots showing   justification random variables denoting number dots die variables independent x1x2      bound corollaries follow chernoff bounds proposition  sum finite number independent   random variables  expected  mathematical techniques  compare growth rates functions helpful apply rule proposition  hôpital rule limnf limng limnf limn denote derivatives deriving upper lower bound summation split summation technique bound sum integral nonde creasing function assuming terms defined general form recurrence relation arises alysis divide conquer algorithms constants   proposition  defined  nlogba constant  nlogba  nlogbalogkn fixed nonnegative integer  nlogba logk n  nlogba constant  proposition master method characterizing divide conquer recurrence relations asymptotically  bibliography  adelson velskii landis algorithm organization doklady akademii nauk sssr  œ266  english translation soviet math dokl  œ1262  aggarwal vitter input output complexity sorting problems commun acm  œ1127   aho algorithms finding patterns strings handbook theoretical computer science van leeuwen algorithms complexity œ300 amsterdam elsevier   aho hopcroft ullman design analysis computer algorithms reading addison wesley   aho hopcroft ullman data structures algorithms reading addison wesley   ahuja magnanti orlin network flows theory algorithms applications englewood cliffs prentice hall    arnold gosling programming language series reading mass addison wesley   baeza yates ribeiro neto modern retrieval reading mass addison wesley   baruvka jistem problemu minimalnim praca moravske prirodovedecke spolecnosti  œ58  czech  bayer symmetric binary ees data structure maintenance acta informatica   œ306   bayer mccreight orga nization large ordered indexes acta inform  œ189   bentley programming pearls writing correct programs communications acm  œ1045   bentley programming pearls heaps communications acm  œ250   booch object oriented analysis design applications redwood city benjamin cummings   boyer moore fast string searching algorithm communications acm   œ772   brassard crusade notation sigact news   œ64   budd introduction object oriented programming reading mass addison wesley   burger goodman sohi memory systems computer science engineering handbook tucker  œ461 crc press   campione walrath tutorial programming internet reading mass addison wesley   cardelli wegner understanding types data abstraction polymorphism acm computing surveys   œ522   carlsson average case heapsort bit  œ17   clarkson linear programming n3 time inform process lett  œ24   cole tight bounds mplexity boyer moore pattern matching algorithm siam journal computing   œ1091   comer ubiquitous tree acm comput surv  œ137   cormen leiserson rivest introduction algorithms cambridge mit press   cornell horstmann core mountain view sunsoft press   crochemore lecroq pattern matching text compression algorithms computer science engineering handbook tucker  œ202 crc press    demurjian software design computer science engineering handbook tucker  œ2351 crc press   battista eades tama ssia tollis algorithms drawing graphs annotated bibliography comput geom theory appl  œ282   battista eades tamassia tollis graphdrawing upper saddle river prentice hall   dijkstra note tw problems connexion graphs numerische mathematik  œ271   driscoll gabow shrairaman tarjan relaxed heaps alternative fibonacci heaps applications parallel computation commun acm  œ1354   graph algorithms potomac maryland computer science press   flanagan nutshell oreilly th   floyd algor ithm  shortest path communications acm      floyd algorithm  treesort  communications acm      fredman tarjan fibonacci heaps improved network optimization algorithms acm  œ615   gamma helm johnson vlissides design patterns elements reusable object oriented software reading mass addison wesley   gibbons algorithmic graph theory cambridge cambridge university press   goldberg robson smalltalk  language reading mass addison wesley   gonnet baeza yates handbook algorithms data structures pascal reading mass addison wesley   gonnet munro heaps heaps siam journal computing   œ971   goodrich handy hudson tamassia accessing internal organization data structures jdsl library proc workshop algo rithm engineering experimentation goodrich mcgeoch eds  lecture notes comput sci œ139 springer verlag   goodrich tsay vengroff vitter external memory computational geometry proc th annu ieee sympos comput sci œ723   graham hell history minimum spanning tree problem annals history computing   œ57   guibas sedgewick dichromatic framework balanced trees proc th annu ieee sympos comput sci lecture notes comput sci œ21 springer verlag    gurevich sigact news   œ63   hennessy patterson computer architecture quantitative approach san francisco morgan kaufmann nd   hoare quicksort computer journal  œ15   hopcroft ta rjan efficient algorithms graph manipulation communications acm   œ378   horstmann computing concepts york john wiley sons   huang langston practical place merging communications acm   œ352   jájá introduction parallel algorithms reading mass addison wesley   jarnik jistem problemu minimalnim praca moravske prirodovedecke spolecnosti  œ63  czech  jones garbage collection algorithms automatic dynamic memory management john wiley sons   karger klein tarjan randomized linear time algorithm minimum spanning trees journal acm  œ328   karp ramachandran parallel algorithms shared memory machines handbook theoretical computer science van leeuwen œ941 amsterdam elsevier mit press   kirschenhofer prodinger path length random skip lists acta informatica  œ792   kleinberg é tardos algorithm design reading addison wesley   knuth sorting searching of art computer programming reading addison wesley   knuth big omicron big omega big theta sigact news  œ24   knuth fundamentalalgorithms of art computer programming reading addison wesley rd   knuth sorting searching of art computer programming reading addison wesley nd   knuth morris pratt fast pattern matching strings siam journal computing   œ350   kruskal shorte spanning subtree graph traveling salesman problem proc amer math soc  œ50   leveson turner investigation therac  accidents ieee computer   œ41   levisse lessons drawn history binary search algorithm computer journal  œ163   levitin teach algorithm design techniques th acm sigcse symp computer science education œ183    liskov guttag abstraction specification program development cambridge mass york mit press mcgraw hill   mccreight space economi cal suffix tree construction algorithm journal algorithms   œ272   mcdiarmid reed building heaps fast journal algorithms   œ365   megiddo linear time algorithms linear programming  problems siam comput  œ776   megiddo linear programming linear time dimension fixed acm  œ127   mehlhorn data structures algorithms  sorting searching  eatcs monographs theoretical computer science heidelberg germany springer verlag   mehlhorn data structures algorithms  graph algorithms np completeness of eatcs monographs theoretical computer science heidelberg germany springer verlag   mehlhorn tsak alidis data structures handbook theoretical computer science van leeuwen algorithms complexity œ341 amsterdam elsevier   morgan vitruvius books architecture york dover publications   morrison patricia practic algorithm retrieve coded alphanumeric journal acm   œ534   motwani raghavan randomized algorithms york cambridge university press   papadakis munro poblete average search update costs skip lists bit  œ332   poblete munro papadakis binomial transform application analysis skip lists proceedings european symposium algorithms esa œ569   prim shortest connecti networks generalizations bell syst tech  œ1401   pugh skip lists probabilist alternative balanced trees commun acm   œ676   samet design analysis spatial data structures reading addison wesley   schaffer sedgewi ck analysis heapsort journal algorithms   œ100   sleator tarja adjusting binary search trees acm   œ686   stephen string searching algorithms scientific press   tamassia graph drawing handbook discrete computational geometry goodman orourke eds  œ832 boca raton crc press llc   tarjan vishkin fficient parallel biconnectivity algorithm siam comput  œ874     tarjan depth earch linear graph algorithms siam journal computing   œ160   tarjan data structures network algorithms  cbms nsf regional conference series applied mathematics philadelphia pa society industrial applied mathematics   tucker computer science engineering handbook crc press   ullman principles database systems potomac md computer science press   van leeuwen graph algorithms handbook theoretical computer science van leeuwen algorithms complexity œ632 amsterdam elsevier   vitter efficient memory access large scale computation proc th sympos theoret aspects comput sci lecture notes comput sci springer verlag   vitter chen design analysis coalesced hashing york oxford university press   vitter flajolet averag case analysis algorithms data structures algorithms complexity van leeuwen handbook theoretical computer science œ524 amsterdam elsevier   warshall theorem boolean matrices journal acm   œ12   williams algorithm  heapsort communications acm   œ348   wood data structures algorithms performance reading mass addison wesley 