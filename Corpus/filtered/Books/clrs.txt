chapter introduces probabilistic analysis randomized algorithms typically probabilistic analysis determine running time gorithm cases presence inherent probability distribution running time differ inputs size cases assume inputs conform probability distribution averaging running inputs cases probability distribution inputs random choices algorithm gorithm behavior determined input values produced random number generator randomized algorithm randomized algorithms enforce probability distribution inputs ensuring input poor performance bound error rate algorithms allowed produce incorrect limited basis appendices mathematical material helpful read book material appendix chapters read book specific notational conventions differ cases appendices reference material hand obably material chapters appendices written tutorial flavor chapter role algorithms computing algorithms study gorithms worthwhile wh role algorithms relative technologies computers chapter answer questions algorithms informally algorithm defined computational procedure takes set values input produces set values output algorithm sequence computational steps transform input output view algorithm tool solving computational problem statement problem specifies gene ral terms desired input output relationship algorithm describes specific computationa procedure achieving input output relationship sort seque nce numbers nondecreasing order problem arises frequently practice fertile ground introducing standard design techniques analysis tools formally define sorting problem input sequence numbers output permutation reordering input sequence input sequence sorting algorithm returns output sequence input sequence called instance sorting problem general instance problem consists input satisfying constraints imposed problem statement needed compute solution problem sorting fundamental operation puter science programs intermediate step result large number good rting algorithms developed algorithm application depends factors number items sorted extent items sorted restrictions item values kind storage device main memory disks tapes algorithm correct input instance halts correct output correct algorithm solves computational problem incorrect algorithm halt input inst ances halt answer desired contrary mi ght expect incorrect algorithms error rate controlled chapter study algorithms finding large prime numbers ordinarily concerned correct algorithms algorithm english computer program hardware design requirement specification provide precise description computational procedure kinds problems solved algorithms sorting computationa problem algorithms developed suspected wh size book practical applications algorithms ubiquit ous include examples human genome project goals identifying genes human dna determining sequences billion chemical base pairs human dna storing databases developing tools data analysis steps requires sophisticated algorithms solutions problems involved scope book ideas chapters book solution biological problems enabling scientists accomplish tasks resources efficiently savings time human machine money extracted laboratory techniques internet enables people access retrieve large amounts order clever algorithms employed manage manipulate large volume data amples problems solved include finding good routes data travel techniques solving problems chapter search engine sides techniques chapters electronic commerce enables goods serv ices negotiated exchanged electronically ability informa tion credit card numbers passwords bank statements private essential electronic commerce public key cryptography digital signatures covered chapter core technologies based numerical algorithms number theory manufacturing comm ercial settings portant allocate scarce resources bene ficial oil company place wells order maximize expect profit candidate presidency united states determine spend money buying campaign advertising order maximize chan ces winning election airline assign crews flights leas expensive making flight covered government regulations garding crew scheduling met internet service provider determine place additional resources order serve customers effectively examples problems solved lin ear programming study chapter details examples scope book underlying techniques apply problems problem areas solve concrete problems book including road map distance pair adjacent intersections marked goal determine shortest route intersection number routes huge disallow routes cross themselv choose routes shortest model road map model actual roads graph meet chapter appendix shortest path rtex graph solve problem efficiently chapter sequence matrices determine product matrix multiplication associative legal multiplication orders perform matrix multiplications product parenthesized orders a3a4 a2a3 a1a2 a3a4 a2a3 a1a2 matrices square size multiplication order affect long matrix multiplications matrices differing sizes sizes compa tible matrix multiplication multiplication order big difference number multiplication orders exponential orders long time chapter general technique dynamic programming solve problem efficiently equation mod integers integers modulo satisfy equation solution simply order chapter efficient method points plane convex hull points convex hull smallest convex polygon points intuitively point ing represented nail sticking board convex hull represented tight rubber band surrounds nails nail rubber band turn vertex convex hull figure subsets points vertices convex hull knowing points vertices convex hull order choices erefore vertices convex hull chapter good methods finding convex hull lists exhaustive surmised book heft exhibit characteristics common interesting algorithms candidate solutions finding challenge practical applications oblems list shortest paths easiest examples transportation firm trucking railroad company financial findi shortest paths road rail network shorter paths lower labor fuel costs routing node internet shor test path network order route message data structures book data structures data structure store organize data order facilitate access modifications single data structure works purposes kn strengths limitations technique book cookbook algorithms someday encounter problem pub lished algorithm exercises problems book book teach techniques algorithm design analysis develop algorithms correct answer understand efficiency hard problems book efficient algorithms usual measure efficiency speed long algorithm takes produce resu problems efficient solution chapter studies interesting subset problems np complete np complete problems interesting firs efficient algorithm np complete problem proven efficient algorithm exist unknown efficient algorithms exist np complete problems set np plete problems remarkable property efficient algorithm exists efficient algorithms exist relationship np compl ete problems lack efficient solutions tantalizing seve ral np complete problems identical problems efficient algorithms small change problem statement big change efficiency algorithm valuable np complete problems surprisingly real applications called produce efficient algorithm np complete problem spend lot time fruitless search problem np compl ete spend time developing efficient algorithm good solution concrete trucking mpany central warehouse day loads truck warehouse sends locations deliveries day truck warehouse ready loaded day reduce costs company select order delivery stops yields west distance traveled truck problem traveling salesman problem np complete efficient algorithm assumptions ere efficient algorithms distance smallest chapter discusses approximation algorithms exercises real computational problems appears sorting determining order multip lying matrices finding convex hull exercises speed measures efficiency real setting exercises select data structure discuss strengths limitations exercises shortest path traveling salesman problems exercises real problem solution solution good algorithms technology suppose computers infinitely fast computer memory free reason study algorithms swer reason demonstrate solution method rminates ith correct answer computers infinitely fast correct method solving problem implementation bounds good software engineering practice designed documented whichever method easiest implement computers fast infinitely fast memory cheap free computing time bounded resource space memory resources wisely algorithms efficient terms time space efficiency algorithms devised solve problem differ dramatically efficiency differences signifi differences hardware software chapter algorithms sorting insertion sort takes time roughly equal c1n2 sort items constant depend takes time roughly proportional merge sort takes time roughly equal c2n lg lg stands log2 constant depend insertion sort sma ller constant factor merge sort constant factors running time dependence input size merge sort factor lg running time insertio sort factor larger insertion sort faster merge sort small input sizes input size large merge sort advantage lg compensate difference constant factors matter smaller crossover point merge sort faster concrete pit faster computer computer running insertion sort slower computer computer running merge sort sort array numbers suppose computer executes billion instructions computer executes instru ctions computer times faster computer raw compu ting power difference dramatic suppose craftiest programmer codes insertion sort machine language computer code requires instructions sort numbers merge sort hand programmed computer average programmer high level language inefficient compiler code lg instructions sort numbers computer takes computer takes algorithm running time grow slowly poor compiler computer runs times faster computer advantage merge sort pronounced sort numbers insertion sort takes days merge sort takes minutes genera problem size increases relative advantage merge sort algorithms technologies algor ithms computer hardware technology total performance depends choosing efficien algorithms choosing fast hardware rapid advances computer technologies algorithms algorithms contemporary computers light advanced technologies hardware high clock rates pipelining superscalar architectures easy intuitive graphi cal user interfaces guis object oriented systems local area wide area networking answer applications explicitly require algorithmic content appli cation level simple web based applications require degree algorithmic content web based service determines travel location everal services existed time writing plementation rely fast hardware graphical user interface wide area networ king object orientation require algorithms operatio finding routes shortest path algorithm rendering maps interpolating addresses application require algorithmic conten application level relies heavily algorithms application rely fast hardware hardware design algorithms appli cation rely graphical user interfaces design gui relies algorithms application rely networking routing networks relies heavily algorithms application wri tten language machine code processed compiler interpreter assembler extensive algorithms algorithms core technologies contemporary computers increasing capacities computers solve larger problems comparison insertion sort merge sort larger problem sizes differences efficiencies algorithms prominent solid base algorithmic knowledge technique characteristic separates skilled programmers novices modern computing technology accomplish tasks wit hout knowing algorithms good background algorithms exercises application requires algorithmic ontent application level discuss function algorithms involved exercises suppose comparing implementations insertion sort merge sort machine inputs size insertion sort runs steps merge sort runs lg steps values insertion sort beat merge sort exercises smallest algorithm running time runs faster algorithm running time machine problems comparison running times function time table determine largest size problem solved time assuming algorithm solve problem takes microseconds minute1 hour day month1 year1 centurylg lg n3n chapter notes excellent texts genera topic algorithms including aho hopcroft ullman baase van gelder brassard bratley goodrich tamassia horowitz sahni rajasekaran kingston knuth kozen manber mehlhorn purdom brown reingold nievergelt deo sedgewick skiena wilf practical aspect algorithm design discussed bentley gonnet surveys field algorithms handbook theoretical computer science volume crc handbook algorithms theory computation overviews algorithms computational biology textbooks gusfield pevzner setubal medinas waterman chapter started chapter familiarize framework book design analysis algorithms contained include references material introduced chapters summations appendix solve examining insertion sort algorith solve sorting problem introduced chapter define pseudocode familiar readers computer programming algorithms algorithm argue rrectly sorts analyze running time analysis introduces notation focuses time increases number items sorted discussion insertion sort introduce divide conquer approach design algorithms develop algorithm called merge sort analysis merge sort running time insertion sort algorithm insertion sort solves sorting problem introduced chapter input sequence numbers output permutation reordering input sequence numbers sort keys book typically algorithms programs written pseudocode respects pascal ja introduced languages trouble reading algorithms separates pseudocode real code eudocode employ expressive method clear concise algorithm clearest method english surprised english phr ase sentence embedded real code difference pseudocode real code pseudocode typically concerned issues software engineering issues data abstraction modularity error handling order convey essence algorithm concisely start insertion sort efficient algorithm sorting small number elements insertion sort works ople sort hand playing cards start left hand cards face table remove card time table insert correct position left hand correct position card compare cards hand left illustrated figure times cards held left hand sorted cards originally cards pile table figure sorting hand cards insertion sort pseudocode insertion sort presented procedure called insertion sort takes parameter array sequence length sorted code number elements denoted length input numbers sorted place numbers rearranged array constant number stored array time input array sorted output sequence insertion sort finished insertion sort length key insert sorted sequence key key loop invariants correctness insertion sort figure algorithm works current card inserted hand iteration outer loop indexed subarray consisting elements constitute sorted hand elements correspond pile cards table fact elements elements originally positions sorted order state properties formally loop invariant start iteration loop lines subarray consists elements originally sorted order figure operation insertion sort array array indices rectangles values stored array positions rectangles iterations loop lines iteration black rectangle holds key compared values shaded rectangles left test sh aded arrows array values moved position black arrows indi cate key moved final sorted array loop invariants understand algorithm correct things loop invariant initialization true prior iteration loop maintenance true iteration loop remains true iteration termination loop terminates invari ant property helps algorithm correct properties hold loop invariant true prior iteration loop note similarity mathematical induc tion prove property holds prove base case inductive step showing invariant holds iteration base case showing invariant holds iteration iteration inductive step property loop invariant correctness differs usual mathematical induction inductive step infinitely induction loop terminates properties hold insertion sort initialization start showing loop invariant holds loop iteration subarray consists single element fact original element subarray sorted trivially loop invariant holds prior iteration loop maintenance tackle prope rty showing iteration maintains loop invariant formally body outer loop works moving position proper position lines point inserted formal treatment econd property require state loop invariant loop point prefer bogged formalism rely informal analysis property holds outer loop termination finally examine loop terminates insertion sort outer loop ends exceeds substituting wording loop invariant subarray consists elements originally sorted order subarray entire array entire array sorted algorithm correct method loop invariants correctness chapter chapters pseudocode conventions conventions pseudocode indentation block structure body loop consists lines body loop lines indentation style applies statements indentation stead conventional indicators block structure statements greatly reduces clutter preserving enhancing clarity looping constructs repeat conditional constructs interpretations pascal subtle difference respect loops pascal loop counter variable undefined exiting loop book loop counter retains exiting loop loop loop counter exceeded loop bound property correctness argument insertion sort loop header length loop terminates length equivalently length symbol remainde comment multiple assignment form assigns variables expression treated equivalent assignment assignment variables key local procedure global variables explicit indication array elements accessed array square brackets ith element array notation range values array subarray consisting elements compound data typically organized objects composed attributes fields field accessed field object square brackets treat array object attribute length indicating ements number elements array write length square brackets array indexing object attributes ill clear context interpretation intended variable representing array object treated pointer data representing array object fields object setting set afterward point object assignment pointer refer object case special nil parameters passed procedure called procedure receives copy parameters assigns parameter change calling procedure objects passed pointer data representing object copied object fields parameter called procedure assignment called procedure visible calling procedure assignment visible boolean operators short circuiting evaluate expression evaluate evaluates false entire expression evaluate true evaluate hand evaluates true evaluate determine entire expression expression evaluate expression evaluates false short circuiting operators write boolean expressions nil worrying evaluate nil exercises figure model illustrate operat ion insertion sort array exercises rewrite insertion sort procedure sort nonincreasing nondecreasing order exercises searching problem input sequence numbers output special nil write pseudocode linear search scans sequence loop invariant prove gorithm correct loop invariant fulfills properties exercises problem adding bit binary integers stored element arrays sum integers stored binary form element array state problem formally write pseudocode adding integers loop loop moment chec loop invariant prior iteration initi assignment loop counter variable test loop header case insertion sort time assigning variable test length real programming languages generally advisable indentation block structure levels indentation hard determine code split block structured languages equivalent constructs exact syntax differ pascal analyzing algorithms analyzing algorithm pred icting resources algorithm requires occasionally resources memory communica tion bandwidth computer hardware primary concern ofte computational time measure generally analyzing candidate algorithms problem efficient easily identified analysis viable candidate inferior algorithms ually discarded process analyze algorithm model implementation technology including model res ources technology costs book assume generic processor random access machine ram model computation implementation technology understand algorithms implemented computer programs ram model instructions executed concurrent operations chapters occasion investigate models digital hardware strictly speaking precisely define instructions ram model costs tedious yield insight algorithm design analysis careful abuse ram model ram instruction sorts sort instruction ram unrealistic real computers su instructions guide real puters designed ram del instructions commonly real computers arithmetic add subtract multiply divide remainder floor ceiling data movement load store copy control conditional unconditional branch subroutine return instruction takes constant time data types ram model integer floating point typically concern precision book applicati ons precision crucial assume limit size word data working inputs size typically assume integers represented lg bits constant require word hold enabling individual input elements restrict constant word size grow arbitrarily word size grow arbitrarily store huge amounts data word operate constant time unrealistic scenario real computers instruc tions listed instructions represent gray area ram model expone ntiation constant time instruction general case takes instructions compute xy real numbers restricted situations exponentiation constant time operation computers shift left instruction constant time shifts bits integer positions left computers shiftin bits integer position left equivalent multiplication shifting bits positions left equivalent multiplication computers compute constant time instruction shifting integer positions left long number bits computer word endeavor avoi gray areas ram model treat computation constant time operation small positive integer ram model attempt model memory hierarchy common contemporary computers mode caches virtual memory implemented demand paging computational models attempt account memory hierarchy effects times real programs real machines handful problems book amine memory hierarchy effects analyses book models include memory hierarchy bit complex ram model difficult work ram model analyses excellent predic tors performance actual machines analyzing simple algorithm ram model challenge mathematical tools required include combinatorics proba bility theory algebraic dexterity ability identify gnificant terms formula behavior algorithm nput summarizing behavior simple easily understood formulas typically select mach ine model analyze algorithm face choices deciding expres analysis simple write manipulate impor tant characteristics algorithm resource requirements suppresses tedious details analysis insertion sort time insertion sort procedur depends input sorting numbers takes longer sorting num bers insertion sort amounts time sort input sequences size depending sorted general time algorithm grows size input traditional running time program function size input define terms running time size input carefully notion input size depends problem studied problems sorting computing discrete fourie transforms natural measure number items input array size sorting problems multiplying integers measure input size total number bits needed represent input ordinary binary notation size input numbers ther instance input algorithm graph input ze numbers vertices edges graph input size measure problem study running time algorithm input number primitive operations steps executed convenient define notion step machine independent moment adopt view constant time required execute pseudocode time assume execution ith takes time constant view point keeping ram model reflects pseudocode implemented actual computers discussion expression running time insertion sort evolve messy formula statement costs simpler notation concise easily manipulate simpler notation easy determine algorithm efficient start presenting insertion sort procedure time cost statement number times statement executed length number times loop test executed loop exits usual test loop header test executed time loop body assume comments executable statements time insertion sort cost times length key insert sorted sequence c4 key c5 c6 c7 key c8 running time algorithm sum running times statement executed statement takes steps execute executed times contribute cin total running time compute running time sertion sort sum products cost times columns obtaining inputs size algorithm running time depend input size insertion sort case occurs array sorted key initial case running time c1n c4 c5 c8 c4 c5 c8 c4 c5 c8 running time expressed constants depend statement costs linear function array reverse sorted order decreasing order worst case compare element element entire sorted subarray noting appendix review solve summations worst case running time insertion sort worst case running time expressed an2 constants depend statement costs quadratic function typically insertion sort running time algorithm fixed input chapters interesting randomized algorithms behavior vary fixed input worst case average case analysis analysis insertion sort looked case input array sorted worst case input array reverse sorted remainder book concentrate finding worst case running time longest running time input size reasons orientation worst case running time algorith upper bound running time input knowing guarantee algorithm longer educated guess running time hope worse algorithms worst case occurs fairly searching database piece inform ation searching algorithm worst case occur database searching applications searches absent frequent average case roughly bad worst case suppose randomly choose numbers apply insertion sort long determine subarray insert element average half elements half elements greater average check half subarray work average case running time turns quadratic function input size worst case running time cases interested average case expected running time algorithm chapter technique probabilistic analysis determine expected running times problem performing average case analysis appare constitutes average input problem assume inputs size equally practice assumption vi olated randomized algorithm random choices probabilistic analysis order growth simplifying abstractions ease analysis insertion sort procedure actual cost statement constants represent costs observed constants worst case running time an2 constants depend statement costs ual statement costs abstract costs mplifying abstraction rate growth order growth running time interests leading term formula an2 lower order terms insignificant large ignore leading constant coefficient nce constant factors rate growth determin ing computational efficiency large inputs write insertion sort worst case running time pronounced theta squared notation informally chapter defined precisely chapter algorithm ficient worst case running time lower order growth cons tant factors lower order terms evaluation error small inputs large inputs algorithm worst case n3 algorithm exercises express function n3 terms notation exercises sorting numbers stored array finding smallest element exchanging element smallest element exchange continue manner elements write pseudocode algorithm selection sort loop invariant algorithm maintain elements elements case worst case running times selection sort notation exercises linear search exercise elements input sequence checked average assuming element searched equally element array worst case average case worst case running times linear search notation justify answers exercises modify algorith good case running time subtleties computational steps english variants procedure requires constant time book sort points coordinate takes constant time note statement calls subroutine takes constant time subroutine invoke separate process calling subroutine passing parameters process executing subroutine characteristic hold resource memory statement references memory executed times consume memory total designing algorithms ways design algorithms insertion sort incremental approach sorted subarray insert single element proper place yielding sorted subarray examine alternative sign approach divide conquer divide conquer design sorting algorithm worst case running time insertion sort advantage divide conquer algorithms running times easily determin techniques introduced chapter divide conquer approach algorithms recursive structure solve problem recursively times deal closely rela ted subproblems algorithms typically follow divide conquer approach break problem subproblems milar original problem smaller size solve subproblems recursively combine solutions create solution original problem divide conquer paradigm involves thr steps level recursion divide problem number subproblems conquer subproblems solving recursively subproblem sizes small solve subpr oblems straightforward manner combine solutions subproblems solution original problem merge sort algorithm closely divide conquer paradigm intuitively operates divide divide element sequence sorted subsequences elements conquer sort subsequences recursively merge sort combine merge sorted subsequences produce sorted answer recursion bottoms sequence sorted length case work sequence length sorted order key operation merge sort algorithm merging sorted sequences combine step perform merging auxiliary procedure merge array indices numbering elements array procedure assumes subarrays sorted order merges form single sorted subarr replaces current subarray merge procedure takes time number elements merged works returning card playing motif suppose piles cards face table pile sorted smallest cards merge piles single sorted pile face table basic step consists choosing smaller cards face piles removing pile exposes card placing card face output pile repeat step input pile time remaining input pile place ace output pile computationally basic step takes constant time checking cards perform basic steps merging takes time pseudocode implements idea additional twist avoids check pile basic step idea pile sentinel card special valu simplify code sentinel card exposed smaller card piles sentinel cards exposed nonsentinel cards output pile advance cards output pile performed basic steps merge n1 create arrays n1 n1 n1 merge procedure works computes length n1 subarray computes length subarray create arrays left lengths n1 loop lines copies subarray n1 loop lines copies subarray lines sentinels ends arrays lines illustrated figure perform basic steps maintaining loop invariant start iteration loop lines subarray smallest elements n1 sorted order smallest elements arrays copied figure operation lines merge subarray sequence copying inserting sentinels array array lightly shaded positions final values lightly shaded positions values copied lightly shaded positions comprise values originally sentinels heavily shaded positions values pied heavily shaded positions values copied arrays respective indices prior iteration loop lines arrays indices termina tion point subarray sorted sentinels elements arrays copied loop invariant holds prior iteration loop lines iteration loop maintains invariant invariant property correctness loop terminates initialization prior iteration loop subarray subarray smallest elements smallest elements arrays copied maintenance iteration maintain loop invariant suppose smallest element copied smallest elements copies subarray smallest elements incrementing loop update reestablishes loop invariant iteration lines perform action maintain loop invariant termination termination loop invariant subarray smallest elements n1 sorted order arrays n1 elements larg copied largest elements sentinels merge procedure runs time observe lines takes constant time loops lines n1 time iterations loop lines takes constant time merge procedure su broutine merge sort algorithm procedure merge sort sorts elements subarray subarray element therefor sorted divide step simply computes partitions subarrays elements elements merge sort merge sort merge sort merge sort entire sequence initial merge sort length length figure illustrates operation procedure power algorithm consists merging pairs item sequences form sorted sequences length merging pairs sequences length form sorted sequences length sequences length merged form final sorted sequence length figure operation merge sort array lengths sorted sequences merged increase algorithm progresses analyzing divide conquer algorithms algorithm recursive running time recurrence equation recurrence describes running time problem size terms running time smaller inputs mathematical tools solve recurrence provide bounds performance algorithm recurrence running time divi conquer algorithm based steps basic paradigm running time problem size problem size small constant straightforward solution takes constant time write suppose division problem yields subproblems size original merge sort divide conquer algorithms time divide problem subproblems time combine solutions subproblems solution original problem recurrence chapter solve common recurrences form analysis merge sort pseudocode merge sort works correctly number elements recurrence based analysis simplified assume original problem size power divide step yields subsequences size chapter assu mption affect orde growth solution recurrence reason set recurrence worst case running time merge sort numbers merge sort elemen takes constant time elements break running time divide divide step computes middle subarray takes constant time conquer recursively solve subproblems size contributes running time combine merge procedure element subarray takes time add functions merge sort analysis adding function function sum linear function adding term conquer step recurrence worst case running time merge sort chapter master theorem lg lg stands log2 logarithm function grows slowly linear function large inputs merge sort lg running time outperforms insertion running time worst case master theorem tuitively understand solution recurrence lg rewrite recurrence constant represents time required solve problems size time array element divide combine steps figure solve recurrence convenience assume exact power figure expanded equivalent tree representing recurrence term root cost level recursion subtrees root smaller recurrences process carried step expanding cost subnodes level recursion continue expanding node tree breaking constituent pa rts determined recurrence problem sizes cost tree figure construction recursion tree recurrence progressively expanded form recursion tree fully expanded tree lg levels height lg level contributes total cost total cost lg lg add costs level tree level total cost level total cost level total cost general level nodes contributing costi ith level total costi level nodes contributing cost total cost total number levels recursion tree figure lg fact easily informal inductive argument base case occurs case level lg lg correct number levels assume inductive hypothesis numb levels recursion tree nodes lg lg assuming original input size power input size tree nodes level tree nodes total number levels lg compute total cost presented recurrence simply add costs levels lg levels costing total cost lg lg ignoring low order term constant desired result lg exercises figure model illustrate oper ation merge sort array exercises rewrite merge procedure sentinels stopping array elements copied copying remainder array exercises mathematical inducti exact power solution recurrence exercises insertion sort expressed recursive procedure order sort recursively sort insert sorted array write recurrence running time recursive version insertion sort exercises referring searching problem exercise observe sequence sorted check midpoi sequence eliminate half sequence consideration binary search algorithm repeats procedure halving size remaini portion sequence time write pseudocode iterative recursive binary search argue worst case running time binary search lg exercises observe loop lines insertion sort procedure linear search scan backward sorted subarray binary search exercise improve overal worst case running time insertion sort lg exercises lg time algorithm set integers integer determines exist elements sum problems insertion sort small arrays merge sort merge sort runs lg worst case time insertion sort runs worst case time constant factors inse rtion sort faster small sense insertion sort merge sort subproblems small modification merge sort sublists length sorted insertion sort merged sta ndard merging mechanism determined sublists length sorted insertion sort nk worst case time sublists merged lg worst case time modified algorithm runs nk lg worst case time largest asymptotic notation function modified algorithm asymptotic running time standard merge sort chosen practice problems correctness bubblesort bubblesort popular sorting gorithm works repeatedly swapping adjacent elements order bubblesort length length downto exchange denote output bubblesort prove bubblesort correct prove terminates length proved bubblesort sorts parts prove inequality state precisely loop invariant loop lines prove loop invariant holds proof structure loop invariant proof presented chapter termination condition loop nvariant proved state loop invariant loop lines prove inequality proof structure loop invariant proof presented chapter worst case running time bubblesort compare running time insertion sort problems correctness horner rule code fragment implements horner rule evaluating polynomial coefficients a0 ai asymptotic running time code fragment horner rule write pseudocode implement naive polynomial evaluation algorithm computes term polynomial scratch running time algorithm compare horner rule prove loop invariant loop lines start iteration loop lines interpret summation terms equaling proof follow structure loop invariant proof presented chapter termination conclude arguing code fragment correctly evaluates polynomial characterized coefficients a0 problems inversions array distinct numbers pair called inversion list inversions array array elements set inversions relationship running time insertion sort number inversions input array justify answer algorithm determines nu mber inversions permutation elements lg worst case time hint modify merge sort chapter formally interpret equations notation expression denotes integer greater equal denotes greatest integer equal notations defined chapter easiest verify setting yields subarrays sizes examine cases depending odd constant represents time solve problems size time array element divi combine steps problem letting larger times understanding recurrence upper bound running time letting lesser times understanding recurrence lower bound running time bounds order lg lg running time chapter notes knuth published volumes general title art computer programming volume ushered modern study computer algorithms focus analysis running time series remains engaging worthwhile reference topics presented knuth word algorithm derived khowârizmî ninth century persian mathematician aho hopcroft ullman advocated asymptotic analysis algorithms comparing relative performance popularized recurrence relations running times recursive algorithms knuth encyclopedic treatment sorting algorithms comparison sorting algorithms includes step counting analyses performed insertion sort knuth disc ussion insertion sort encompasses variations algorithm sh ell sort introduced shell insertion sort periodic subsequences input produce faster sorting algorithm merge sort knuth men tions mechanical collator capable merging decks punched cards sing pass invented von neumann pioneers computer science wrote program merge sort edvac computer early history proving programs correct gries credits naur article field gries attributes loop invariants floyd textbook mitchell describes progre proving programs correct chapter growth functions overview order growth running time algorithm defined chapter simple characterization algorithm efficiency compare relative performance alternative gorithms input size large merge sort lg worst case running time beats insert ion sort worst case running time determine exact running time algorithm insertion sort chapter extra precision worth effort computing large inputs multip licative constants lower order terms exact running time dominated effects input size input sizes large order growth running time relevant studying asymptotic efficiency algorithms concerned running time gorithm increases size input limit size input increases bound algorithm asymptotically efficient choice small inputs chapter standard methods simplifying asym ptotic analysis algorithms defining types asymptotic notation notation notational conventions book presented finally review behavior functions commonly analysis algorithms asymptotic notation notations asympto tic running time algorithm defined terms functions domains set natural numbers notations convenient describing worst case running time function defined integer input sizes convenient abuse asymptotic notation variety ways ample notation easily extended domain real numbers alternatively restrict subset natural numbers understa precise meaning notation abused misused defines basic asymptotic notations introduces common abuses notation chapter worst case running time insertion sort define notation function denote set functions exist positive constants n0 c1g c2g n0 function belongs set exist positive constants sandwiched c1g c2g large set write member write express notion abuse equality denote set membership confusing advantages figure intuitive picture functions values n0 lies c1g c2g n0 function equal constant factor asymptotically tight bound figure graphic examples notations n0 minimum greater work notation bounds function constant factors write exist positive constants n0 n0 lies c1g c2g inclusive notation upper bound function constant factor write positive constants n0 n0 lies notation lower bound function cons tant factor write positive constants n0 n0 lies definition requires member asymptotically nonnegative nonnegative large asymptotically positive function pos itive large function asymptotica lly nonnegative set assume function notation asymptotically nonnegative assumption holds asymptotic notations defined chapter chapter introduced informal notion notation amounted throwing lower order terms ignoring leading coefficient highest order term justify intuition formal definition determine positive constants n0 c1n2 c2n2 n0 dividing yields hand inequality hold choosing likewise left hand inequality hold choosing choosing n0 verifyn2 choices constants exist thing choice exists note cons tants depend functionn2 function belonging require constants formal definition verify n3 suppose purpose contradiction n0 exist n3 c2n2 n0 hold arbitrarily large constant intuitively lower order term asymptotically positiv function determining asymptotically tight bounds ecause insignificant large tiny fraction highest order term dominate lower order terms setting smaller coefficient highest order term setting larger perm inequalities definition notation satisfied coefficient highest order term likewise constant factor equal coefficient quadratic function an2 constants throwing lower order terms ignoring constant yields formally thing constants reader verify c1n2 an2 c2n2 n0 general polynomial ai constants problem constant degree polynomial express constant function n0 notation minor abuse howe ver clear variable tending infinity notation constant constant function respect variable notation notation asymptotically bounds function asymptotic upper bound notation function denote pronounced big set functions exist positive constants n0 n0 notation upper bound function constant factor figure intuition notation values n0 function write function member set note implies notation stronger notion notation written set theoretically proof quadratic function an2 quadratic function surprising linear function easily verified n0 readers notation strange write literature notation informally asymptotically tight bounds defined notation book write claiming constant multiple asymptotic upper bound claim tight upper bound distinguishing asymptotic upper bounds asymptotically tight bounds standard algorithms literature notation running time algorithm inspecting algorithm structure doubly nested loop structure insertion sort algorithm chapter yields upper bound worst case running time cost itera tion loop bounded constant indices loop executed pairs values notation describes upper bound bound worst case running time algorithm bound running time algorithm input bound worst case running time insertion sort applies running time input bound worst case running time insertion sort imply bound running time insertion sort input chapter input sorted insertion sort runs time technically abuse running time insertion sort actual running time varies dependi input size running time function matter input size chosen running time input bounded equivalently worst case running time notation notation asymptotic upper bound function notation asymptotic lower bound function denote pronounced big omega omega set functions exist positive constants n0 n0 intuition notation figure values n0 definitions asymptotic notations easy prove theorem exercise theorem functions application theorem proof an2 constants implies an2 an2 practice theorem asymptotic upper lower bounds asymptotically tight bounds prove asymptotically tight bounds asymptotic upper lower bounds notation describes lower bound bound case running time algorithm implication bound running time algorithm arbitrary inputs case running time insertion sort implies running time insertion sort running time insertion sort falls falls linear function quadratic function bounds asymptotically tight instance running time insertion sort exists input insertion sort runs time input sorted contradictory worst case running time insertion sort exists input algorithm time running time modifier algorithm matter input size chosen running time input constant times large asymptotic notation equations inequalities asymptotic notation mathematical formulas introducing notation wrote write interpret formulas asymptotic notation stands hand equation inequality defined equal sign set membership general asymptotic notation appears formula interpret standing anonym ous function care formula function set case asymptotic notation manner eliminate inessential clutter equation chapter expressed worst case running time merge sort recurrence interested asymptotic behavior point lower order terms understood included anonymous function denoted term number anonymous functions expres sion understood equal number times asymptotic notation expression single anonym ous function function expression ha clean interpretation cases asymptotic notation appears left hand equation interpret equations rule matter anonymous functions chosen left equal sign choose anonymous functions equal sign equation valid meaning function function hand equation coarser level left hand number relationships chained interpret equation separately rule equation function equation function mentioned function note interpretation implies chaining equations intuitively notation asymptotic upper bound provided notation asymptotically tight bound asymptotically tight bound notation denote upper bound asymptotically tight formally define set positive constant exists constant n0 n0 definitions notation notation difference bound holds constant bound holds constants intuitively notation function insignificant relative approaches infinity authors limit definition notation definition book restricts anonymous functions asymptotically nonnegative notation analogy notation notation notation notation notation denote lower bound asymptotically tight define formally define omega set positive constant exists constant n0 n0 relation implies limit exists arbitrarily large relative approaches infinity comparison functions relational properties real numbers apply asym ptotic comparisons assume asymptotically positive transitivity imply imply imply imply imply reflexivity symmetry transpose symmetry properties hold asymptotic ations draw analogy asymptotic comparison functions comparison real numbers asymptotically smaller asymptotically larger property real numbers carry asymptotic notation trichotomy real numbers hold real numbers compar functions asymptotically comparable functions case holds functions n1 sin compared asymptotic notation exponent n1 sin oscillates values exercises asymptotically nonnegative functions basic definition notation prove max exercises real constants exercises explain statement running time algorithm meaningless exercisesnnn exercises prove theorem exercises prove running time algorithm worst case running time case running time exercises prove set exercises extend notation case parameters infinity independently rates function denote set functions exist positive constants n0 m0 n0 m0 definitions set notation colon shoul read real problem ordinary notati functions distinguish functions values calculus parameters func tion function written adopting rigorous notation complicate algebraic manipulations choose tolerate abuse standard notations common functions reviews standard mathemati cal functions notations explores relationships illustrat asymptotic notations monotonicity function monotonically increasing implies monotonically decreasing implies function strictly increasing implies strictly decreasing implies floors ceilings real number denote greatest integer equal read floor integer greater equal read ceiling real integer real number integers floor function monotonically increasing ceiling function modular arithmetic integer positive integer mod remainder residue quotient defined notion remainder integer divided convenient provide special notation equality remainders mod mod write mod equivalent modulo mod remainder divided equivalently mod divisor write mod equivalent modulo polynomials nonnegative integer polynomial degree function form constants a0 coefficients polynomial polynomial asymptotically positive asymptotically positive polynomial degree real constant function monotonically increasing real constant function monotonically decreasing function polynomially bounded nk constant exponentials real identities a0 amn function monotonically increasing convenient assume rates growth polynomials exponen tials fact real constants conclude nb exponential function base strictly greater grows faster polynomial function denote base natural logarithm function real denotes factorial function defined real inequality equality holds approximation approximation good equation asymptotic notation limiting behavior logarithms notations lg log2 binary logarithm loge natural logarithm lgk lg exponentiation lg lg lg lg composition notational conven tion adopt logarithm functions apply term formula lg lg lg hold constant function logb strictly increasing real equation logarithm bases equation changing base logarithm constant logarithm constant factor notation lg care cons tant factors notation computer scientists natural base logarithms algorithms data structures involve splitting problem parts simple series expansion inequalities equality holds function polylogarithmically bounded lg constant relate growth polynomials polylogarithms substituting lg equation yielding limit conclude lgb constant positive polynomial function grows faster polylogarithmic function factorials notation read factorial fined integers weak upper bound factorial function terms factorial product stirling approximation base natural logarithm tig hter upper bound lower bound prove exercise stirling approximation helpful proving equation equation holds functional iteration notation denote function iteratively applied times initial formally function reals nonnegative integers recursively define iterated logarithm function notation lg read log star denote iterated logarithm defined lg defined lg logarithm nonpositive number undefined lg defined lg distinguish lg logarithm function applied times succession starting argument lg logarithm raised ith power iterated logari thm function defined lg min lg iterated logarithm slowly growing function lg lg lg lg lg number atoms observable universe estimated rarely encounter input size lg fibonacci numbers fibonacci numbers defined recurrence fibonacci number sum previous yielding sequence fibonacci numbers golden ratio conjugate formulas proved induction exercise ith fibonacci number equal rounded nearest integer fibonacci numbers grow exponentially exercises monotonically increasing functi ons functions addition nonnegative monotonically increasing exercises prove equation exercises prove equation proven exercises function lg polynomially bounded function lg lg polynomially bounded exercises asymptotically larger lg lg lg lg exercises prove induction ith fibonacci number satisfies equality golden ratio conjugate exercises prove fibonacci number satisfies problems asymptotic behavior polynomials degree polynomial constant definitions asymptotic notations prove properties nk nk nk nk nk problems relative asymptotic growths pair expressions table assume constants answer form table written box lgk nk nsin nlg clg lg lg problems ordering ymptotic growth rates rank functions order growth arrangement g1 g2 g30 functions satisfying g1 g2 g2 g3 g29 g30 partition list equivalence classes class single nonnegative function functions problems asymptotic notation properties asymptotically positive functions prove disprove conjectures implies min implies lg lg lg large impliesg implies problems variations authors define read omega infinity alternative definition exists positive constant infinitely integers functions asympto tically nonnegative true place potential advantages disadvantages characterize running times programs authors define manner alternative definition direction theorem substitute authors define õ read soft logarithmic factors õ exist positive constants n0 lgk n0 define manner prove analog theorem problems iterated functions iteration operator lg function applied monotonically increasing function reals constant define iterated function defined cases quantity number iterated applications function required reduce argument functions constants tight bound lg n1 lg chapter notes knuth traces origin notation number theory text bachmann notation invented landau discussion distribution prime numbers notations advocated knuth correct popular technically sloppy practice literature notation upper lower bounds people continue notation notation technically precise discussion history development asymptotic notations knuth brassard bratley authors define asymptotic notations definitions agree common situations alternative definitions encompass functions asympt otically nonnegative long absolute values appropriately bounded equation robbins properties elementary mathematical functions good thematical reference abramowitz stegun zwillinger calculus book apostol thomas finney knuth graham knuth patashnik wealth material discrete mathematics computer science technicalities practice neglect technical details state solve recurrences good glossed assumption integer arguments functions running time algorithm defined integer algorithms size input integer recurrence describing worst case running time merge sort boundary conditions represent anot class details typically ignore running time algorithm constant sized nput constant recurrences running times algorithms generally small convenience genera lly omit statements boundary conditions recurrences assume constant small state recurrence explicitly values small reason changing solution recurrence solution typically change constant factor order growth unchanged state solve recurrences omit floors ceilings boundary conditions forge ahead details determine matter wh experience helps theorems stating tails affect asympt otic bounds recurrences encountered analysis algorithms theorem chapter address details fine points recurrence solution methods substitution method substitution method solving recurrences entails steps guess form solution mathematical induction cons tants solution works substitution guessed answer function inductive hypothesis applied smaller values method powerful applied cases easy guess form answer substitution method tablish upper lower bounds recurrence determine upper bound recurrence recurrences guess solution lg method prove lg choice constant start assuming bound holds lg substituting recurrence yieldslg lg lg lg lg lg step holds long mathematical induction requi res solution holds boundary conditions typically showing boundary conditions suitable base cases inductive proof recurrence choose constant large bound lg works boundary conditions requirement lead problems assume sake argument sole boundary cond ition recurrence bound lg yields lg odds base case inductive proof fails hold difficulty proving inductive hypothesis specific boundary condition easily overcome recurrence advantage asymptotic notation requiring prove lg n0 n0 constant choosing idea remove difficult boundary condition consideration inductive proof observe recurrence depend directly replace base cases inductive proof letting n0 note distinction base case recurrence base cases inductive proof derive recurrence inductive proof lg constant completed choosing large lg lg turns choice suffices base cases hold recurrences examine straightforward extend boundary conditions inductive assumption work small making good guess general guess correct solutions recurrences guessing solution takes experience occasionally creativity fortunately heuristics good guesser recursion trees generate good guesses recurrence guessing solution reasonable recurrence difficult argument hand intuitively additional term affect solution recurrence large difference large cut evenly half guess lg verify correct substitution method exercise good guess prove loose upper lower bounds recurrence reduce nge uncertainty start lower bound recurrence term recurrence prove initial upper bound gradually lower upper bound raise lower bound converg correct asymptotically tight solution lg subtleties times correctly guess asymptotic bound solution recurrence math work induction problem inductive assumption strong prove detailed bound hit snag revising guess subtracting lower order term permits math recurrence guess solution choice constant substituting guess recurrence imply choice tempting larger guess work fact guess solution correct order stronger inductive hypothesis intuitively guess constant lower order term mathematical induction work prove exact form inductive hypothesis overcome difficulty subtracting lower order term previous guess guess constant long constant chosen large handle boundary conditions people idea subtracting lower order term counterintuitive math work increas ing guess key understanding step remember math ematical induction prove stronger assuming mething stronger smaller values avoiding pitfalls easy err asymptotic notation recurrence falsely prove guessing arguing wrong constant error proved exact form inductive hypothesis changing variables algebraic manipulation unknown recurrence recurrence difficult simplify recurre nce change variables convenience worry rounding values integers renaming lg yieldsmm renamem produce recurrence recurrence recurrence solution lg changingm lg lg lg lg exercises solution lg exercises solution lg solution recurrence lg conclude solution lg exercises making inductive hypo thesis overcome difficulty boundary condition recurrence adjusting boundary conditions inductive proof exercises lg solution exact recurrence merge sort exercises solution lg exercises solve recurrence making change variables solution asymptotically tight worry values integral recursion tree method substitution method provide succinct proof solution recurrence correct difficult good guess drawing recursion tree analysis merge sort recurrence straightforward devise good guess recursion tree node represents cost single subproblem set recursive function invocations sum costs level set level costs sum level costs determine total cost levels recursion recursion trees recurrence describes running time divide conquer algorithm recursion tree generate good guess verified substitution method recursion tree generate good guess tolerate small oppiness veri fying guess careful drawing recursion tree summing costs recursion tree direct proof solution recurren recursion trees generate good guesses recursion trees directly prove theorem forms basis master method recursion provide good guess recurrence start focusing findi upper bound solution floors ceilings insubstantial solving recurrences sloppiness tolerate create recursion tree recurrence cn2 written imp lied constant coefficient figure derivation recursion tree cn2 convenience assume exact power tolerable sloppiness figure expanded equivalent tree representing recurrence cn2 term root represents cost level recursion subtrees root represent costs incurred subproblems size process carried step expanding node cost cost children root continue expanding node tree breaking constituent parts determined recurrence figure construction recursion tree recurrence cn2 progressively expanded form recursion tree fully expanded tree height log4 log4 levels subproblem sizes decrease furt root eventually reach boundary condition root reach subproblem size node depthi subproblem size hitsi equivalently log4 tree log levels log4 determine cost level tree level times nodes level number nodes depth subproblem sizes reduce factor level root node depth log4 costi multiplying total cost nodes depth log4i cn2 level depth log4 nodes contributing cost total cost add costs levels determine cost entire tree formula messy realize advantage small amounts sloppiness infinite decreasing geometric series upper bound backing step applying equation derived guess original recurrence coefficients cn2 form decreasing geometric series equation sum coefficients bounded constant root contribution total cost cn2 root contributes constant fraction total cost total cost tree dominated cost root fact upper bound recurrence verify moment tight bound rst recursive contributes cost lower bound recurrence substitution method verify guess correct upper bound recurrence dn2 constant constant cn2 dn cn2 cn2 dn2 cn2 dn2 step holds long intricate figure recursion treen figure recursion tree recurrencen omit floor ceiling functions simplicity represent constant factor term add values acr oss levels recursion tree level longest path root leafn kn log3 height tree log3 intuitively expect solution recurr ence number levels times cost level log3 lg total cost evenly distributed levels recursion tree complic ation cost leaves recursion tree complete binary tree height log3 leaves cost leaf constant total cost leaves lg recursion tree complete binary tree fewer leaves root internal node absent levels contribute cost levels cont ribute work accurate accounting cost remember guess substitution method tole rate sloppiness attempt guess lg upper bound correct substitution method verify lg upper bound solution recurre nce dn lg suitable positive constantn lgn lgn lg lgn lgn lg dn lg lg lg dn lg lg lg lg dn lg dn lg dn lg long lg perform accurate accounting costs recursion tree exercises recursion tree determine good asymptotic upper bound recurrence substitution method verify answer exercises argue solution recurrencen constant lg appealing recursion tree exercises draw recursion tree constant provide tight asymptotic bound solution verify bound substitution method exercises recursion tree asymptot ically tight soluti recurrence constants exercises recursion tree asymptot ically tight soluti recurrence constant range constant master method master method cookbook meth solving recurrences form constants asymptotically positive function master method requires memorization thr cases solution recurrences determined easily pencil paper recurrence describes running time algor ithm divides problem size subproblems size positive constants subproblems solved recu rsively time cost dividing problem combining subproblems function notation recurrence arising merge sort procedure matter technical corre ctness recurrence defined integer replacing terms affect asymptotic behavior recurrence prove convenient ther efore omit floor ceiling functions writing divide conquer recurrences form master theorem master method depends theorem theorem master theorem constants function defined nonnegative integers recurrence interpret bounded asymptotically constant constant constant large applying master theorem examples spend moment understand ree cases comparing function function intuitively solution recurr ence determined larger functions case function larger solution case function larger solution case functions size multiply logarithmic factor solution intuition technicalities understood case smaller polynomially smaller asymptotically smaller factor constant case larger polynomially larg addition satisfy regularity condition condition satisfied polynomially bounded functions encounter realize cases cover possibilities gap cases smaller polynomially smaller gap tween cases larger polynomially larger function falls gaps regularity condition case fails hold master thod solve recurrence master method master method simply determin case master theorem applies write answer recurrence apply case master theorem conclude solutionn case applies solution recurrence lg recurrence lg lg case applies regularity condition holds large lg lg case solution recurrence nlg master method apply recurrence lg proper form lg case apply lg asymptotically larger problem polynomially larger ratio asymptotically positive constant recurrence falls gap case case exercise solution exercises master method tight asympt otic bounds recurrences n3 exercises recurrence describes running time algorithm competing algorithm running time largest integer asymptotically faster exercises master method solution binary search recurrence lg exercise description binary search exercises master method applied recurrence lg asymptotic uppe bound recurrence exercises regularity condition constant case master theorem constants function satisfies conditions case master theorem regularity condition proof master theorem proof master theorem theorem proof understood order apply theorem proof parts analyzes master recurrence simplifying assumption defined exact powers intuition needed understand master theorem true analysis extended positive integers mathematical technique applied problem handling floors ceilings abuse asymptotic notation behavior functions defined exact powers recall definitions asymptotic notations require bounds proved large numbers thos powers asymptotic notations apply set nonnegative integers abuse minor guard wh asymptotic notation limited domain draw impr oper conclusions proving exact power guarantee function defined case upper bound proved sort drastic consequence asymptotic notation limited domain making absolutely clear context proof exact powers proof ster theorem analyzes recurrence master method assumption exact power integer analysis broken lemmas reduces problem solving master recurrence problem evaluating expres sion summation determines bounds summation lemma puts prove version master theorem case exact power lemma constants nonnegative function defined exact powers define exact powers recurrence positive integer proof recursion tree figure root tree cost children cost convenient integer visualizing recursion tree thematics require children children cost nodes distance root general nodes distance root cost cost leaf leaf depth log leaves tree figure recursion tree generated tree complete ary tree leaves height logb cost level sum equation equation summing costs level tree figure cost level internal nodes total internal node levels underlying divide conquer algorithm sum represents costs dividing problems subproblems recombining subproblems cost leaves cost subproblems size terms recursion tree cases master theorem correspond cases total cost tree domi nated costs leaves evenly distributed levels tree dominated cost root summation equation describes cost dividing combining steps underlying divide conquer algorithm lemma asymptotic bounds summation growth lemma constants nonnegative function defined exact powers function defined exact powers bounded asymptotically exact powers constant constant proof case implies substituting equation yields bound summation notation factoring terms simplifying leaves increasing geometric series constants rewrite expression substituting expression summation equation yields case proved assumption case substituting equation yields bound summation case time geometric series discover term summation substituting expression summation equation yields case proved case proved appears definition terms nonnegative conclude exact powers assumption constant iterating times equivalently substituting equation simplifying yields geometri series series case decreasing terms constant conclude exact powers case proved completes proof lemma prove version master theorem case exact power lemma constants nonnegative function defined exact powers define exact powers recurrence positive integer bounded asymptotically exact powers constant constant constant large proof bounds lemma evaluate summation lemma case case case floors ceilings complete proof master theore extend analysis situation floors ceilings master recu rrence recurrence defined integers exact powers obtaining lower bound upper bound routine bound pushed case yield desired result bound pushed case lower bounding recurrence requires technique upper bounding recurrence bound modify recursion tree figure produce recursion tree figure recursion tree sequence recursive invocations arguments figure recursion tree generated recursive argument equation denote jth element sequence goal determine depth nk constant inequality general letting logb depth logb problem size constant figure equation arbitrary integer restricted exact power evaluate summation manner analogous proof lemma case constant ajf cjf sum equation evaluated lemma case proof case lemma observe logb implies bound implies exists constant large constant case proved proof case identical key prove bound proof case algebra intricate proved upper bounds master theorem integers proof lower bounds exercises simple exact expression equation case positive integer arbitrary real number exercises master recurrence solution simplicity confine alysis exact powers exercises case master theorem ove rstated sense regularity condition constant implies exists constant problems recurrence examples asymptotic upper lower bounds recurrences assume constant bounds tight justify answers n3n problems finding missing integer array integers easy determine missing integer time auxiliary array record numbers problem access entire integer single operation elements represented binary operation access fetch jth bit takes constant time operation determine missing integer time problems parameter passing costs book assume parame ter passing procedure calls takes constant time element array passed assumption valid systems pointer array passe array problem examines implications pa rameter passing strategies array passed pointer time array passed copying time size array array passed copying subrange accessed called procedure time subarray passed recursive binary search algor ithm finding number sorted array exercise recurrences wors case running times binary search arrays passed methods good upper bounds solutions recurrences size original problem size subproblem redo merge sort algorithm problems recurrence examples asymptotic upper lower bounds recurrences assume constant small bounds tight justify answers lg lg lg lg lg problems fibonacci numbers problem develops properties bonacci numbers defined recurrence technique generating functions lve fibonacci recurrence define generating function formal power series ith fibonacci number z2f prove rounded nearest integer hint observe prove problems vlsi chip testing professor diogenes supposedly identical vlsi chips principle capable testing professo test jig accommodates chip time jig loaded chip tests reports good bad good chip reports accurately chip good bad answer bad chip trusted tcomes test chip chip conclusion good good good bad good bad bad bad good bad bad bad bad chips bad professo determine chips good strategy based kind pairwise test assume bad chips conspi fool professor problem finding single good chip chips assuming chips good pairwise tests sufficient reduce problem half size good chips identified pairwise tests assuming chips good solve recurrence describes number tests problems monge arrays array real numbers monge array pick rows columns monge array elements inters ections rows columns sum upper left lower elements equal sum lowe left upper elements array monge prove array monge note induction separately rows columns array monge change element order monge hint column containi leftmost minimum element row prove monge array description divide conquer algorithm computes left minimum element row monge array construct submatrix consisting numbered rows recursively determine leftmost minimum row compute leftmost minimum odd numbered rows explain compute leftmost minimum odd numbered rows leftmost minimum numbered rows time write recurrence describing running time algorithm solution log vlsi stands large scale integrati integrated circuit chip technology fabricate microprocessors today chapter notes recurrences studied early fibonacci fibonacci numbers named moivre introduced method generating functions problem solving recurrences master method adapted bentley haken saxe extended method justified exercise knuth liu solve linear recurrences method generating functions purdom brown graham knuth patashnik extended discussions recurrence solving researchers including akra bazzi roura verma methods solving general divi conquer recurrences solved master method result akra bazzi works recurrences form coefficients ai positive sum bounded positive nondecreasing constants exist constants n0 n0 method work recurrencen master method apply solve recurrence exists unique positive solution recurrence large constant akra bazzi method difficult serves solving recurrences mode division problem unequally sized subproblems master method simpler applies subproblem sizes equal chapter probabilistic analysis randomized algorithms chapter introduces probabilistic analysis randomized algorithms unfamiliar basi probability theory read appendix reviews material probabilistic analysis random ized algorithms revisited times book hiring problem suppose hire office assistant previous attempts hiring unsuccessful decide employment agency employment agency send candidate day inte rview person decide hire person pay employment agency small fee interview applicant hire applicant costly current office assistant pay large hiri fee employment agency committed times possi ble person job decide interviewing applicant applicant qualified current office assistant current office assistant hire applicant pay price strategy estimate price procedure hire assistant expresses strategy hiring pseudocode assumes candidates office assistant job numbered procedure assumes interviewing candidate determine candidate candidate initialize procedure creates dummy candidate numbered qualif ied candidates hire assistant candidate qualified dummy candidate interview candidate candidate candidate hire candidate cost model problem ffers model chapter concerned running time hire assist ant cost incurred interviewing hiring surface analyzin cost algorithm analyzing running time merge sort anal ytical techniques identical analyzing cost running time case counting number times certa basic operations executed interviewing low cost hiring expensive costing number people hired total algorithm nci mch matter people hire interview candidates incur cost nci interviewing concentrate analyzing mch hiring cost quantity varies ith algorithm scenario serves model common computational paradigm case maximum mini mum sequence examining element sequence maintaining curr ent winner hiring problem models update notion element winning worst case analysis worst case hire candidate interview situation occurs candidates increasing orde quality case hire times total hiring cost nch reasonable expect candidates increasing order quality fact idea order arrive control order natural expect happen typical average case probabilistic analysis probabilistic analysis probability alysis problems commonly probabilistic analysis analyze running time algorithm analyze quantities hiring cost procedure hire assistant order perform probabilistic analysis knowledge assumptions distribution inputs analyze algorithm computing expected running time expectation distribution inputs averaging running time inputs careful deciding stribution inputs problems reasonable assume inputs probabilistic analysis technique designing efficient algorithm gaining insight problem prob lems descri reasonable input distribution cases probabilistic analysis hiring problem assume applicants random order problem assume compare candidates decide qualified total order candidates appendix definition total order rank candidate unique number rank denote rank applicant adopt convention higher rank corresponds qualified applicant ordered list rank rank rank permutation list applicants random order equivalent list ranks equally permutations numbers alternatively ranks form uniform random permutation permutations appears equal probability probabilistic analysis hiring problem randomized algorithms order probabilistic analysis someth ing distribution inputs cases input distribution distribution model knowledge computationally probabi lity randomness tool algorithm design analysis making behavi algorithm random hiring problem ndidates presented random order knowing order develop randomized algorithm hiring probl greater control order interview candidates change model employment agency candidates send list candidates advance day choos randomly candidate interview candidates names change relying guess candidates random order gained control process enforced random order generally algorithm randomized behavior determined input values produced random number generator assume disposal random number generator random random returns integer inclusive integer equally random produces probab ility produces probability random returns probability integer returned random independent integers returned previous calls imagine random rolling sided die output practice programming environments offer pseudorandom number generator deterministic algorithm returning numbers statistically random exercises assumption determine candidate procedure hire assistant implies total order ranks candidates exercises implementation procedure random calls random expected running time procedur function exercises suppose output probabi lity probability disposal procedure biased random outputs outputs probability probability algorithm biased random subroutine returns unbiased answer returning probability probability expected running time algorithm function indicator random variables order analyze algorithms includi hiring problem indicator random variables indicator random variables provide convenient method converting probabilities expectations suppose sample space event indicator random variable event defined simple determine xpected number heads flipping fair coin sample space define random variable takes values probability define indicator random variable xh coin coming heads express event variable counts number heads flip coin heads write expected number heads flip coin simply expected indicator variable xh xh expected number heads flip fair coin lemma expected indica tor random variable event equal probability occurs lemma sample space event sample space xa xa proof definition indicator random variable equation definition expected xa denotes complement indicator random variables cumbersome application counting expected number heads flip single coin analyzing situations perform repeated random trials indicator random variables simple arrive result equation equation compute number heads coin flips separately obability obtaining heads heads heads simpler method proposed equation implicitly indicator random variables making argument explicit indicator random variable asso ciated event ith flip heads letting yi random variable noting outcome ith flip yi random variable denoting total number heads coin flips compute expected number eads expectation sides equation left equation expectation sum random variables lemma easily compute expectation random variables equation linearity expectation easy compute expectation sum equals sum expectations random variables linearity expectation indicator random riables powerful analytical technique applies dependence random variable easily compute expected number heads compared method equation indicator random variables greatly simplify calculation indicato random variables thr oughout book analysis hiring problem indicator random variables returning hiring problem compute expected number times hire office assistant order probabilistic analysis assume candidates arrive random order discussed previous remove assumption random variable equals number times hire office assist ant apply definition expected equation calculation cumbersome sh indicator random variables greatly simplify calculation indicator random variab computing defining variable number times hire office assistant define variables candidate hired indicator random variable associat event ith candidate hired lemma candidate hired comput probability lines hire assistant executed candidate hired candidate candidates assumed ndidates arrive random order candidates appeared random order candidates equally qualified candidate probability qualified candidates probability hired lemma conclude compute interview people hire average summarize result lemma lemma assuming candidates presented random order algorithm hire assistant total hiring cost proof bound definition hiring cost equation expected interview cost improvement worst case hiring cost nch exercises hire assistant assuming candidates presented random order probability hire time probability hire times exercises hire assistant assuming candidates presented random order probability ill hire exercises indicator random variab compute expected sum dice exercises indicator random variable solve problem hat check problem customers hat hat eck person restaurant hat check person hats customers random order expected number customers hat exercises array distinct numbers pair called inversion problem inversions suppose element chosen randomly independently uniformly range indicator random variable compute expected number inversions randomized algorithms previous knowing distribution inputs analyze average case behavior gorithm times knowledge average case analysis mentioned randomized algorithm problem hiring problem helpful assume permutations input equally probabilistic analysis guide development randomized algorithm assuming distribution inputs impose distribution particul running algorithm randomly permute candidates order enforce property permutation equally modification change expectation hiring office assistant roughly times input expect case inputs drawn distribution explore distinction probabilistic analysis randomized algorithms claimed assuming candidates presented random order expected number times hire office assistant note algorithm deterministic input number times office assistant hired number times hire office assistant differs inputs depends ranks candidates number depends ranks candidates represent input listing order ranks candidates rank rank rank rank list office assistant hired times successive candidate previous lines executed iteration algorithm list ranks office assistant hired iteration list ranks office assistant hired times interviewing candidates ranks recalling cost algorithm dependent times hire office assistant expensive inputs inexpensive inputs moderately expensive inputs hand randomized algorithm firs permutes candidates determines candidate randomization algorithm input distribution input times maximum updated quantity differs algorithm time algorithm produce permutation perform updates time algorithm produce permutation perform update time perform number updates time algorithm execution depends random choices differ previous execution algorithm algorithm randomized algorithms input elicits worst case behavior worst enemy produce bad input ray random permutation input order irrelevant randomized algorithm performs badly random number generator produces unlucky permutation hiring problem change needed code randomly permute array randomized hire assistant randomly permute list candidates candidate qualified dummy candidate interview candidate candidate candidate hire candidate simple change created randomized algor ithm performance matches assuming ndidates presented random order lemma expected hiring cost procedure randomized hire assistant proof permuting input array achi eved situation identical probabilistic analysis hire assistant comparison lemmas captures difference probabilistic analysis randomized algorithms lemma assumption input lemma assumption alth ough randomizing input takes additional time remainder secti discuss issu involved randomly permuting inputs randomly permuting arrays randomized algorithms randomize input permuting input array ways randomization discuss methods assume array loss generality elements goal produce random permutation array common method assign element array random priority sort elements priorities initial array choose random priorities produce array priority smallest fourth finally procedure permute sorting permute sorting length random n3 sort sort keys return chooses random number n3 range n3 priorities unique exercise asks prove probability entries unique exercise asks implement algorithm priorities identi cal assume priorities unique time consuming step procedure sorting chapter comparison sort sorting takes lg time achieve lower bound merge sort takes lg time comparison sorts lg time sorting jth smallest priority position output manner obtai permutation remains prove procedure produces uniform random permutation permutation numbers equally produced lemma procedure permute sorting produces uniform random permutation input assuming priorities distinct proof start particul permutation element receives ith smallest priority permutation occurs probability event element receives ith smallest priority compute probability event occurs exercise probability equal x4 probability priority chosen randomly set smallest observe element smallest priority remaining elements equal chance smalle priority general elements smallest priorities order remaining elements equal chance ith smallest priority probability obtaining identity permutation extend proof work rmutation priorities fixed permutation set denote rank priority assigned element element jth smallest priority rank define event element receives smallest priority proof applies calculate probability obtaining permutation calcula tion identical probability obtaining permutation prove permutation uniform random permutation suffices element probability winds position exercise weaker condition fact insufficient method generating random permutation permute array place procedure randomize place time iteration element chosen randomly elements subsequent iteration altered randomize place length swap random loop invariant procedure randomize place produces uniform random permutation set elements permutation sequence elements appendix permutations lemma procedure randomize place putes uniform random permutation proof loop invariant prior ith iteration loop lines permutation subarray permutation probability invariant true prior loop iteration iteration loop maintains invariant invariant property correctness loop terminates initialization situation loop iteration loop invariant permutation array permutation probability subarray subarray permutation elements permutation probability loop invariant holds prior iteration maintenance assume iteration permutation appears subarray probability ith iteration permutation appears subarray probability incrementing iteration maintain loop invariant examine ith iteration permutation denote elements permutation consists permutation algorithm places e1 denote event iterations created permutation loop invariant e1 event ith iteration puts position permutation formed precisely e1 occur compute e1 equation e1 e1 e1 probability e1 equals algorithm chooses randomly values positions termination termination subarray permutation probability randomize place produces uniform random permutation randomized algorithm simplest efficient solve problem randomized algorithms occasionally book exercises professor marceau objects loop invariant proof lemma questions true prior iteration reasoning easily declare subarray rmutations probability subarray permutation shoul invalidating loop invariant prior iteration rewrite procedure randomize place loop invariant applies nonempty subarray prio iteration modify proof lemma procedure exercises professor kelp decides write procedure produce random permutation identity permutation proposes procedure permute identity length swap random code professor kelp intends exercises suppose swapping element random element subarray swapped random element array permute length swap random code produce uniform random permutation exercises professor armstrong suggests procedure generating uniform random permutation permute cyclic length offset random dest offset dest dest dest dest return element probability winding position professor armstrong mistak showing permutation uniformly random exercises prove array procedure permute sorting probability elements unique exercises explain implement algorithm rmute sorting handle case priorities identical algorithm produce uniform random permutation priorities identical probabilistic analysis indicator random variables advanced illustrates probabilistic analysis examples determines probability room people pair shares birthday examines random tossing balls bins investigates streaks consecutive heads coin flipping final exam ple analyzes variant hiring problem ecisions interviewing candidates birthday paradox birthday paradox people room chance bor day year answer surprisingly paradox fact fewer number days year half number days year answer question people room integers number people room ignore issue leap years assume years days day year person birthday falls assume birthda uniformly distributed days year probability people matching birthdays depends random selection birthdays independent assume birthdays independent probability birthday birthday fall day probability fall day intuitively chosen probability chosen day probability birthday probability birthday falls day notice coincidence depends assumption birthdays independent analyze probability people matching birthdays complementary event probability birthdays match minus probability rthdays event people distinct birthdays ai event person birthday person write ak equation recurrence initial condition probability distinct birthdays probability distinct birthdays times probability distinct distinct conditional probability ak days iteratively apply recurrence inequalityn probability birthdays distinct solving quadratic equation people room probability people birthday mars year martian days long takes martians analysis indicator random variables indicator random variables prov ide simpler approximate analysis birthday paradox pair people room define indicator random variable xij equation probability people matching birthdays lemma xij person person birthday letting random variable counts number pair individuals birthday expectations sides applying linearity expectation expected number pa irs people birthday individuals room expect birthday expected number pairs birthday people expect matching pair birth days mars year martian days long martians analysis probabilities determined number people required probability exceed matc hing pair birthdays exists analysis indicator random variables determined number expected number matching birthdays exact numbers people differ situations asymptotically balls bins process randomly tossing identical balls bins numbered tosses independent toss ball equally bin probability tossed ball lands bin ball tossing process sequence bernoulli trials appendix probability success success ball falls bin model analyzing hashing chapter answer variety interesting questions ball tossing process problem asks additional questions balls bins balls fall bin number balls fall bin binomial distribution balls tossed equation tells expected number balls fall bin balls toss average bin ball number tosses bin receives ball geometri distribution probability equation expected number tosses success balls toss bin ball toss ball falls bin hit expected number tosses required hits hits partition tosses stages ith stage consists tosses hit ith hit stage consists toss guaranteed hit bins toss ith stage bins balls bins toss ith stage probability obtaining hit denote number tosses ith stage number tosses required hits random variable geometric distribu tion probability success equation linearity expectation bound harmonic series takes tosses expect bin ball problem coupon collector problem person ying collect coupons acquire randomly coupons order succeed streaks suppose flip fair coin times longest stre ak consecutive heads expect answer lg analysis prove expected length longest streak heads lg probability coin flip head aik event streak heads length ith coin flip precisely event consecutive coin flips yield heads coin flips mutually independent event aik probability flips heads probability str eak heads length lg position small lg positions streak probability streak heads length lg boole inequality probability union events sum probabilities dividual events note boole inequality holds events independent inequality bound length longest streak event longest reak heads length length longest streak definition expected evaluate sum upper bounds computed inequality method yield weak bounds intuition gained analysis good bound informally observe individual term summation equation factors large lg small lgn fairly small formally note events disjoint probability streak heads length lg inequality noting chances streak heads exceeds lg flips diminish probability streak lg heads starts position ai lgr lg probability longest streak lg equivalently probability longest streak length lg coin flips probability streak lg heads chances streak longer lg heads prove complementary lower bound expected length longest streak heads coin flips lg prove bound streaks length partitioning flips groups flips choose lg groups heads longest streak length lg longest streak expected length lg partition coin flips lg groups lg consecutive flips bound probability group heads equation probability group starting position heads ai lg lgn probability streak heads length lg position lg groups formed mutually exclusive independent coin flips probability groups fails streak length lg argument inequality fact verify large probability longest streak exceeds lg calculate lower bound expected length longest streak equation proceeding manner analysis upper bound birthday paradox simpler approximate analysis indicator random variables xik aik indicator random variable streak head length ith coin flip count total number streaks define expectations linearity expectation plugging values calculate expected number streaks length number large greater streaks length expected occur probability occurs high number small streaks length expected occur probability occurs low lg positive constant large expected number streaks length lg small conclude ccur hand n1 n1 expect larg number streaks length lg streak length occur rough estimates conclude length longest streak lg hiring problem final variant hiring problem suppose interview candidates order hire applicants settle candidate close exchange hiring obey company requirement interview ither offer position applicant receive job trade minimizing interviewing maxi mizing quality candidate hired model problem meeting applicant score score denote score ith applicant assume applicants receive score applicants highest score remaining applicants higher score decide adopt strategy selecting positive integer interviewing rejecting applicants hiring applicant higher score preceding applicants turns qualified applicant interviewed hire nth applicant strategy formalized procedure maximum appears procedure maximum returns candidate hire maximum bestscore score bestscore bestscore score score bestscore return return determine probability hire qualified applicant choose implement strategy moment assume fixed max score denote maximum score applicants event succeed choosing qualified applicant event succeed qualified applicant ith interviewed disjoint noting succeed qualified applicant compute order succeed qualified applicant ith things happen qualified applicant position event denote algorithm sele applicants positions score bestscore scores unique ignore possibility score bestscore case values score score greater return greater denote event applicants position chosen fortunately events independent event depends relative ordering values positions depends position greater values ordering positions affect greater affect ordering positions apply equation probability maximum equally positions event occur maximum positions positions equally positions equation approximate integrals bound summation inequalities evaluating definite integrals bounds provide tight bound maximize probability success focus choosing maximizes lower bound lower bound expression easier maximize upper bound expression differentiating expression respect setting derivative equal lower bound probability maximized equivalently implement strategy succeed hiring qua lified applicant probability exercises people room probability birthday people probability people birthday july greater exercises suppose balls tossed bins toss independent ball equally bin expected number ball tosses fore bins balls exercises analysis birthday paradox birthdays mutually independent pairwise independence sufficient justify answer exercises people invi ted party order people birthday exercises probability string set size permutation question relate birthday paradox exercises suppose balls tossed bins toss ndependent ball equally bin expected number bins expected number bins ball exercises sharpen lower bound streak length showing flips fair coin probability streak longer lg lg lg consecutive heads occurs problems probabilistic counting bit counter ordinarily count morris probabilistic counting count larger expense loss precision counter represent count form increasing sequence nonnegative values assume initial counter representing count n0 increment operation works counter probabilistic manner overflow error reported counter increased probability remains unchanged probability select counter ordinary interesting situations select ith fibonacci number problem assume large probability overflow error negligible expected represented counter increment operations performed analysis variance count represented counter depends sequence simple case estimate variance represented register increment operations performed problems searching unsorted array problem examines algor ithms searching unsorted array consisting elements randomized strategy pick random terminate continue search picking random continue picking random indices checked element note pick set indices time examine element write pseudocode procedure rand search implement strategy algorithm terminates indices picked suppose expected number indices picked random search terminates generalizing solution suppose indices expected number indices picked random search terminates yo answer function suppose indices expected number indices picked elements checked random search terminates deterministic linear earch algorithm refer deterministic search specifi cally algorithm searches order array reached assume permutati ons input array equally suppose expected running time deterministic search wh worst case running time deterministic search generalizing solution suppose indices expected running time deterministic search worst case running time determin istic search answer function suppose indices expected running time deterministic search worst case running time deterministic search finally randomized algorith scramble search works randomly permuting input array unning deterministic linear search permuted array letting number indices worst case expected running times scramble search cases generalize solution handle case searching algorithms explain answer chapter notes bollobás hofri spencer wealth advanced probabilistic techniques advantages randomized algorithms discussed surveyed karp rabin textbook motwani raghavan extensive treatment randomized algorithms variants hiring problem studied problems commonly referred secretary problems work area paper ajtai meggido waarts sorting order statistics chapter list chapter heapsort chapter quicksort chapter sorting linear time chapter medians order statistics introduction presents algorithms solve sorting problem input sequence numbers output permutation reordering input sequence input sequence element array represented fashion linked list structure data practice numbers sorted rarely isolated values collection data called record record key sorted remainder record consists satellite data carried key practice sorting algorithm permutes permute satellite data record includes large satellite data permute array pointers records records order minimize data movement sense implementation details distinguish algorithm blown program sort indi vidual numbers large record numbers irrelevant method sorting procedure determin sorted order focusing problem sorting typically assume input consists numbers translation algorithm sorting number program sorting records conceptually straightforward engineering situation subtleties actual programming task challenge sorting computer scientists sorting fundamental problem study algorithms reasons sort nherent application order prepare customer statements banks sort checks check number algorithms sorting key subrou tine program renders graphical objects layered sort objects relation draw objects numerous algorithms text sorting subroutine wide variety rting algorithms rich set techniques fact techniques thr oughout algorithm design represented body sorting algorithms een developed years sorting problem historical sorting problem ove nontrivial lower bound chapter upper bounds match lower bound asymptotically sorting algorithms asym ptotically optimal lower bound sorting prove lower bounds problems engineering issues fore implementing sorting algorithms fastest sorting program situation depe factors prior knowledge keys satellite data memory hierarchy caches virtual memory host computer software environment issues dealt algorithmic level tweaking code sorting algorithms introduced algorithms sort real numbers chapter insertion sort takes time worst case loops tight fast place sorting algorithm small input sizes reca sorting algorithm sorts place constant number elements input array stored array merge sort asymptotic running time lg merge procedure operate place introduce algorit hms sort arbitrary real numbers heapsort presented chapter sorts numbers place lg time data structure called heap implement priority queue quicksort chapter sorts numbers place worst case running time average case running time lg generally outperforms heapsort practice inser tion sort quicksort tight code hidden constant factor running time small popul algorithm sorting large input arrays insertion sort merge sort heapsort quicksort comparison sorts determine sorted order input array comparing elements chapter introducing decision tree model order study perf ormance limitations comparison sorts model prove lower bound lg worst case running time comparison sort inputs showing heapsort merge sort asymptotically optimal comparison sorts chapter beat lower bound lg gather sorted order input comparing elements counting sort algorithm exampl assumes input numbers set array indexing tool determining relative order counting sort sort numbers time counting sort runs time linear size input array algorithm radi sort extend range counting sort integers sort integer digits digit set radix sort sort numbers time constant radix sort runs linear time algorith bucket sort requires knowledge probabilistic stribution numbers input array sort real numbers uniformly distributed half open interval average case time order statistics ith order statistic set numbers ith smallest number set select ith order statistic sorting input indexing ith element output assumptions nput distribution method runs lg time lower bound proved chapter chapter ith smallest element time elements arbitrary real numbers presen algorithm tight pseudocode runs time worst case linear time erage complicated algorithm runs worst case time background rely difficult mathematics sections require mathematical sophistication average case analyses quicksort bucket sort order statistic algorithm probability reviewed appendix material probabilistic analysis randomized algorithms chapter analysis worst case linear time algorithm order stat istics involves sophisticated mathematics worst case analyses chapter heapsort overview chapter introduce sorting algorithm merge insertion sort heapsort running time lg insertion sort merge sort heapsort sorts place constant number array elements stor input array time heapsort combines ttributes sorting algorithms discussed heapsort introduces algorithm design technique data structure case heap manage formation execution algorithm heap data structure heapsort efficient priority queue heap data structure reappear algorithms chapters note term heap originally coin context heapsort refer garbage collected storage programming languages lisp provide heap data structure garbage collected storage refer heaps book structure defined chapter heaps binary heap data structure array object viewed complete binary tree figure node tree corresponds element array stores node tree completely filled levels lowest lled left point array represents heap ject attributes length number elements array heap size number elements heap stored array length valid numbers element heap size heap size length element heap root tree node indices parent parent left child left child computed simply parent return left return return figure max heap viewed binary tree array number circle node tree stored node number node array array lines showing parent child relationships parents left children tree height node height computers left procedure compute instruction simply shifting binary representation left bit position sim ilarly procedure compute shifting binary representation left bit position adding low order bit parent procedure compute shifting bit position good implementation heapsort procedures implemented macros procedures kinds binary heaps max heap min heaps bot kinds values nodes satisfy heap property specifics depend kind heap max heap max heap property node root parent node lue parent largest element max heap stored root subtree rooted node values larger contained node min heap organized opposite min heap property node root parent smallest element min heap root heapsort algorithm max heaps min heaps commonly priority queues discuss precise max heap min heap pplication prope rties apply max heaps min heaps term heap viewing heap tree define height node heap number edges longest simple downward path node leaf define height heap height root heap elements based complete binary tree height lg exercise basic operations heaps time proportional height tree lg time remainder chapter presents basic procedur sorting algorithm priority queue data structure max heapify procedure runs lg time key maintaining max heap property build max heap procedure runs linear time produces max heap unordered input array heapsort procedure runs lg time sorts array place max heap insert heap extract max heap increase key heap maximum procedures lg time heap data structure priority queue exercises minimum ximum numbers elements heap height exercises element heap height lg exercises subtree max heap root subt ree largest occurring subtree exercises max heap smallest elem ent reside assuming elements distinct exercises array sorted order min heap exercises sequence max heap exercises array representation storing element heap leaves nodes indexed maintaining heap property max heapify subroutine manipulating max heaps inputs array array max heapify called assumed binary trees rooted left max heaps smaller children violating max heap property unction max heapify float max heap subtree rooted max heap max heapify left heap size largest largest heap size largest largest largest exchange largest max heapify largest figure illustrates action max heapify step largest elements left determined stored largest largest subt ree rooted node max heap procedure terminates children largest element swapped largest node children satisfy max heap property node indexed largest original subtree rooted largest violate max heap property cons equently max heapify called recursively subtree figure action max heapify heap size initial configuration node violating max heap operty larger children max heap prope rty restored node exchanging destroys max heap property node recursive max heapify swapping node fixed recursive max heapify yields change data structure running time max heapify subtree size rooted node time relationships elements left time max heapify subtree rooted children node children subtrees size worst case occurs row tree half running time max heapify recurrencen solution recurrence case master theorem theorem lg alternatively characterize running time max heapify node height exercises figure model illustrate operation max heapify array exercises starting procedure max heapify write pseudocode procedure min heapify performs manipulation min heap running time min heapify compare max heapify exercises calling max heapify element larger children exercises calling max heapify heap size exercises code max heapify efficient terms constant factors recursive compilers produce inefficient code write efficient max heapify iterative contro construct loop recursion exercises worst case running time max heapify heap size lg hint heap nodes node values max heapify called recursively node path root leaf building heap procedure max heapify manner convert array length max heap exercise elements subarray leaves tree element heap procedure build max heap remaining nodes tree runs max heapify build max heap heap size length length downto max heapify figure action build max heap figure operation build max heap showing data structure max heapify build max heap element input array binary tree represents figure loop refers node max heapify data structure loop iteration refers node subsequent iterations loop build max heap observe max heapify called node subtrees node max heaps max heap buil max heap finishes build max heap works correctly loop invariant start iteration loop lines node root max heap invariant true prior loop iteration iteration loop maintains invariant invariant property correctness loop terminates initialization prior iteration loop node leaf root trivial max heap maintenance iteration maintains loop invariant observe children node numbered higher loop invariant roots max heaps preci sely condition required max heapify node max heap root max heapify preserves property nodes roots max heaps decrementing loop update reestablishes loop invariant iteration termination termination loop invariant node root max heap node compute simple upper bound running time build max heap max heapify costs lg time calls running time lg upper bound correct asymptotically tight derive tighter bound observing time heapify node varies height node tree heights nodes small tighter analysis relies properties element heap height lg exerciseh nodes height exercise time required max heapify called node height express total cost build max heap summation evaluated substituting formula yields running time build max heap bounded build max heap unordered array linear time build min heap procedure build min heap build max heap heapify replaced min heapify exercise build min heap produces min heap unordered linear array linear time exercises figure model illustrate operat ion build max heap array exercises loop build max heap decrease length increase length exercisesh nodes height element heap heapsort algorithm heapsort algorithm starts build max heap build max heap input array length maximum element array stored root correct final position exchanging discard node heap decrementing heap size observe easily max heap chil dren root remain max heaps root element violate max heap prop erty needed restore max heap property max heapify leaves max heap heapsort algorithm repeat process max heap size heap size exercise precise loop invariant heapsort build max heap length downto exchange heap size heap size max heapify figure operation heapsort max heap initially built max heap iteration loop lines figure operation heapsort max heap data structure built build max heap max heap max heapify time lightly shaded nodes remain heap sorted array heapsort procedure takes time lg build max heap takes time calls max heapify takes time lg exercises figure model illustrate eration heapsort array exercises argue correctness heapsort loop invariant start iteration loop lines subarray max heap smallest elements subarray largest elements sorted exercises running time heapsort array length sorted increasing order decreasing order exercises worst case running time heapsort lg exercises elements distinct case running time heapsort lg priority queues heapsort excellent algorithm good implementation quicksort presented chapter beats practice neverthele heap data structure enormous utility popular applications heap efficient priority queue heaps kinds priority queues max priority queues min priori ty queues focus implement max priority queues turn based max heaps exercise asks write procedures min priority queues priority queue data structure maintaining set elements called key max priority queue supports operations insert inserts element set operation written maximum returns element largest key extract max removes returns element largest key increase key increases element key assumed large current key application max priority queues schedule jobs shared computer max priority queue track jobs performed relative priorities job finished interrupted highest priority job selected pending extract max job queue time insert alternatively min priority queue supports operations insert minimum extract min decrease key min prio rity queue event driven simulator items queue ents simulated time occurrence serves key ents simulated order time occurrence simulation events simulated future simulation program extr min step choose event simulate events produced inserted min priority queue insert min priority queue highlighting decrease key operation chapters surprisingly heap implemen priority queue application job scheduling event driven simulation elements priority queue correspond objects application determine application object corresponds priority queue element vice versa heap implement priority queue theref ore store handle application object heap element exact makeup handle pointer integer depends application sim ilarly store handle heap element application object handle typically array heap elements change loca tions array heap operations actual implementation relo cating heap element update array applicati object details accessing application objects depend heavily application implementation pursue noting actice handles correctly maintained discuss implement operatio max priority queue procedure heap maximum implements maximum operation time heap maximum return procedure heap extract max implemen extract max operation loop body lines heapsort procedure heap extract max heap size error heap underflow max heap size heap size heap size max heapify return max running time heap extract max lg performs constant work lg time max heapify procedure heap increase key implem ents increase key operation priority queue element key increased identified array procedure updates key element increasing key violate max heap property ocedure manner reminiscent insertion loop lines insertion sort traverses path node root proper place newly increased key traversal repeatedly compares elemen parent exchanging keys continuing element key larger terminating element key smaller max heap property holds exercise precise loop invariant heap increase key key key error key smaller current key key parent exchange parent parent figure heap increase key operation running time heap increase key element heap lg path traced node updated root length lg figure operation heap increase key max heap figure node heavily shaded node key increased iteration loop lines node parent exchanged keys moves parent max heap iteration loop point parent max heap property holds procedure terminates procedure max heap insert implements insert operation takes input key element inserted max heap procedure expands max heap adding tree leaf key calls heap increase key set key node correct maintain max heap property max heap insert key heap size heap size heap size heap increase key heap size key running time max heap insert element heap lg summary heap support prio rity queue operation set size lg time exercises illustrate operation heap extract max heap exercises illustrate operation max heap insert heap heap figure model increase key exercises write pseudocode procedures minimum heap extract min heap decrease key min heap insert implement min priority queue min heap exercises bother setting key inserted node max heap insert thing increase key desired exercises argue correctness heap increase key loop invariant start iteration loop lines array heap size satisfies max heap property excep violation larger parent exercises implement queue priority queue implement stack priority queues stacks defined exercises operation heap delete deletes item node heap implementation heap delete runs lg time element max heap exercises lg time algorithm merge sorted lists sorted list total number elements input lists hint min heap merging problems building heap insertion procedure build max heap implemented repeatedly max heap insert insert elements heap implementation build max heap heap size length max heap insert procedures build max heap build max heap create heap input array prove provide counterexample worst case build max heap requires lg time build element heap problems analysis ary heaps ary heap binary heap exception leaf nodes children children represent ary heap array height ary heap elements terms efficient implemen tation extract max ary max heap analyze running time terms efficient implementation insert ary max heap analyze running time terms efficient implem entation increase key sets max updates ary max heap structure appropriately analyze running time terms problems young tableaus young tableau matrix entries row sorted order left entries column sorted order entries young tableau treat nonexistent elements young tableau hold finite numbers draw young tableau elements argue young tableau argue elements algorithm implement extract min nonempty young tableau runs time algorithm recursive subroutine solves problem recursively solving subproblem hint max heapify define maximum running time extract min young tableau solve recurrence yields time bound insert element nonfull young tableau time sorting method subroutine young tableau sort numbers n3 time time algorithm determine whethe number stored young tableau chapter notes heapsort algorithm invented williams implement priority queue heap build max heap procedure suggested floyd min heaps implem ent min priority queues chapters implementation improved tim bounds operations chapters faster implementations priority queues integer data data structure invented van emde boas supports operations minimum maximum insert delete search extract min extract max predecessor successor worst case time lg lg subject restric tion universe keys set data bit integers computer memory consists addressable bit fredman willard implement minimum time insert extract min time thorup improved bound lg lg time bound space unbounded implemented linear space randomized hashing special case priority queue occurs sequence extract min operations monotone values returned successive extract min operations monotonically increasing time case arises applications dijkstra single source shortest aths algorithm discussed chapter discrete event simulation dijkstra algorithm pa rticularly decrease key operation implemented effici ently monotone case data integers range ahuja melhorn orlin tarjan implement extract min insert lg amortized time chapter amortized analysis decrease key time data structure called radix heap lg bound improved fibonacci heaps chapter conjunction radix heaps bound improved lg1 expected time cherkassky goldberg silverstein combine multilevel bucketing structure denardo fox heap thorup mentioned raman improved bound min lg lg1 fixed detailed discussions papers raman thorup chapter quicksort quicksort sorting algorithm worst case running time input array numbers spite slow worst case running time quicksort practical choice sorting remarkably effi cient average expected running time lg constant factors hidden lg notation small advantage sorting place works virtual memory environments describes algorithm import ant subroutine quicksort partitioning behavior quicksort complex start intuitive discussion performance postpone precise analysis chapter presents version quicksort random sampling algorithm good average case running time input elicits worst case behavior randomized algorithm analyzed time worst case lg time average description quicksort quicksort merge sort based divide conquer paradigm introduced step divide conquer process sorting typical subarray divide partition rearrange array subarrays element equal turn equal element compute partitioning procedure conquer sort subarrays recursive calls quicksort combine subarrays sorted place work needed combine entire array sorted procedure implements quicksort quicksort partition quicksort quicksort sort entire array initial quicksort length partitioning array key algorithm partition procedure rearranges subarray place partition exchange exchange return figure operation partition element array partition selects element pivot element partition subarray procedure runs array partitioned regions start iteration loop lines region satisfies properties state loop invariant figure operation partition sample array lightly shaded array elements partition values greater heavily shaded elements partition values greater unshaded elements partitions final white element pivot initial array variable settings elements partitions swapped partition smaller values values partition larger values values swapped smaller partition grows values swapped smaller partition grows larger partition grows include loop terminates lines pivot element swapped lies partitions iteration loop lines array figure summarizes structure indices covered cases values entrie relationship pivot figure regions maintained procedure partition subarray values equal values greater values values loop invariant true prior iteration iteration loop maintains invariant invariant property correctness loop terminates initialization prior iteration loop values values conditions loop invariant trivially satisfied assignment satisfies condition maintenance figure cases depending outcome test figure action loop increment incremented condition holds entries remain unchanged figure incremented swapped incremented swap condition satisfied item swapped loop invariant greater figure cases iteration procedure partition action increment maintains loop invariant incremented swapped incremented loop invariant maintained termination termination entry array sets invariant partitioned values array sets equal greater singleton set final lines partition pivot element place middle array swapping leftmost element greater output partition satisfies specifications divide step running time partition subarray exercise exercises figure model illustrate eration partition array exercises partition return elements array modify partition elements array exercises argument running time partition subarray size exercises modify quicksort sort nonincreasing order performance quicksort running time quicksort depends whethe partitioning balanced unbalanced turn depends elements partitioning partitioning balanced algorithm runs asymptotically fast merge sort partitioning unbalanced asymptotically slowly insertion sort informally investigate quicksort performs assumptions balanced versus unbalanced partitioning worst case partitioning worst case behavior quicksort occurs partitioning routine produces subproblem elements elements claim proved assume unbalanced titioning arises recursive partitioning costs time recursive array size returns recurrence running time intuitively sum costs incurred level recursion arithmetic series equation evaluates straightforward substitution method prove recurrence solution exercise partitioning maximally unbalanced recursive level algorithm running time worst case running time quicksort insertion sort running time occurs input array completely sorted common situation insertion sort runs time case partitioning split partition produces subproblems size size size case quicksort runs faster recurrence running time case master theorem theorem solution lg equal balancing sides partition level recursion produces asymptotically faster algorithm balanced partitioning average case running time quicksort closer case worst case analyses key understanding understand balance partitioning reflected recurrence describes running time suppose partitioning gorithm produces proportional split blush unbalanced recurrencen running time quicksort explicitly cluded constant hidden term figure recursion tree recurrence notice level tree cost boundary condition reached depth logn lgn levels cost recursion terminates depth logn lg total cost quicksort lg proportional split level recursion intuitively unbalanced quicksort runs lg time asymptotically split ght middle fact split yields lg running time reason split constant proportionality yields recursion tree depth lg cost level running time lg split constant proportionality figure recursion tree quicksort partition produces split yielding running time lg nodes subproblem sizes level costs level costs include constant implicit term intuition average case develop clear notion average case quicksort assumption frequently expect encounter inputs behavior quicksort determined relative ordering values array elements input values array probabilistic analysis hiring problem assume permut ations input numbers equally quicksort random input arra partitioning level informal analysis assumed expect splits bala nced fairly unbalanced exercise asks percent time partition produces split balanced percent time produces split balanced average case partition produces mi good bad splits recursion tree average case execution partition good bad splits distributed randomly tree suppose intuition good bad splits alternate levels tree good splits case splits bad splits worst case splits figure splits consecutive levels recursion tree root tree cost partitioning subarrays produced sizes worst case level subarray size case partitioned subarrays size assume boundary condition cost subarray size figure levels recursion tree quicksort partitioning root costs produces bad split subarrays sizes partitioning subarray size costs produces good split subarrays size single level recursion tree balanced parts partitioning cost subproblems hown elliptical shading subproblems remaining solved square shading larger subproblems remaining solved combination bad split good split produces subarrays sizes combined partitioning cost situation worse figure single level partitioning produces subarrays size cost situation balanced intuitively cost bad split absorbed cost good split split good running time quicksort levels alternate good bad splits running time good splits lg larger constant hidden notation rigorous analysis average case exercises substitution method prove recurrence solution claimed exercises running time quicksort elements array exercises running time quicksort array distinct elements sorted decreasing order exercises banks record transactions account order times transactions people receive bank statements checks listed order check number people write checks order check number merchants cash reasonable dispatch problem converting time transaction ordering check number ordering problem sorting sorted input argue procedure insertion sort tend beat procedure quicksort problem exercises suppose splits level quicksort proportion constant minimum depth leaf recursion tree lg lg maximum depth lg lg worry integer round exercises argue constant probability random input array partition produces split balanced randomized version quicksort exploring average case behavior quicksort assumption permutations input numbers equally engineering situation expect hold exercise add randomization algorithm order good average case performance inputs people rega randomized version quicksort sorting algorithm choice large inputs randomized algorithm explicitly permuting input quicksort randomization technique called random sampling yields simpler analysis pivot randomly chosen element subarray exchanging element element chosen random modification randomly sample range ensures pivot element equally elements subarray pivot ement randomly chosen expect split input array balanced average partition quicksort partition procedure simply implement swap partitioning randomized partition random exchange return partition quicksort calls randomized partition place partition randomized quicksort randomized partition randomized quicksort randomized quicksort analyze algorithm exercises analyze average case performance random ized algorithm worst case performance exercises running procedure randomized quicksort calls random number generator random worst case case answer terms notation analysis quicksort intuition worst case behavior quicksort expect analyze behavior quicksort rigorously worst case analysis applies quicksort randomized quicksort conclude average case analysis randomized quicksort worst case analysis worst case split vel recursion quicksort produces running time intuitively worst case running time algorithm prove assertion substitution method running time quicksort worst case time procedure quicksort input size recurrence parameter ranges procedure partition produces subproblems total size guess cn2 constant substituting guess recurrence expression q2 achieves maximum parameter range endpoint derivative expression respect positive exercise observation bound max qn q2 continuing bounding cn2n cn2 pick constant largen term dominates term specific case quicksort takes time partitioning unbalanced alternatively exercise asks recurrence solution worst case running time quicksort expected running time intuitive argument average case running time randomized quicksort lg level ecursion split induced randomized partition puts constant fraction elements partition recursion tree depth lg work performed level add levels unba lanced split levels total time remains lg analyze expect running time randomized quicksort precisely understanding partitioning procedure operates understanding derive lg bound expected running time upper bound expected running time combined lg case bound yields lg expected running time running time comparisons running time quicksort dominat time spent partition procedure time partition procedure called pivot element selected element included ture recursive calls quick sort partition calls partition entire execution quicksort algorithm partition takes time time proportional number iterations loop lines iteration loop performs comparison inline compari pivot element element array count total nu mber times executed bound total time spent loop entire execution quicksort lemma number compar isons performed partition entire execution quicksort element array running time quicksort proof discussion calls partition constant work executes loop number times iteration loop executes goal compute total number comparisons performed calls partition attempt anal yze comparisons partition derive bound total number comparisons understand algorithm comp ares elements array ease analysis rename elements array z1 z2 zn ith smallest element define set zij zj set elements zj inclusive algorithm compare zj answer question observe pair elements compared elements compared pivot element partic ular partition finishes pivot element comp ared elements analysis indicator random variables define xij compared zj comp arison takes place time execution algorithm iteration partition pair compared easily characterize total number comparisons performed algorithm expectations sides linearity expectation lemma remains compute compared zj items compared input quicksort numbers order assume pivot element partition separates numbers sets pivot element compared elements number set compar number set general pivot chosen zj zj compared subsequent time hand chosen pivot item zij compared item zij zj chosen pivot item zij zj compared item zij values compared item z7 chosen pivot contrast compared pivot element chosen z2 zj compared element chosen pivot zij zj compute probability event occurs prior point element zij chosen pivot set zij partition element zij equally chosen pivot set zij elements probability element chosen pivot events mutually exclusive combining equations evaluate sum change variables bound harmonic series equation conclude randomized partition expected running time quicksort lg exercises recurrence exercises quicksort case running time lg exercises q2 achieves maximum exercises randomized quicksort expected running time lg exercises running time quicksort improved practice advantage fast running time insertion sort input sorted quicksort called subarray fewer elements simply return thout sorting subarray level quicksort returns insertio sort entire array finish sorting process argue sorting algorithm runs nk lg expected time picked theory practice exercises modifying partition procedure randomly picking elements array partitioning median middle elements approximate probability worst split function range problems hoare partition correctness version partition chapter original partitioning algorithm original partition algorithm hoare hoare partition true repeat repeat exchange return demonstrate operation hoare partition array showing values array auxiliary values iteration loop lines questions careful argument procedure hoare partition correct prove indices access element subarray hoare partition terminates returns element equal element hoare partition terminates partition procedure separates pivot originally partitions forms hoare partition procedure hand places pivot originally partitions split nontrivial rewrite quicksort proce dure hoare partition problems alternative quicksort analysis alternative analysis running time randomized quicksort focuses expected running time individual recursive quicksort number comparisons performed argue array size probability element chosen pivot define indicator random variables ith smallest element chosen pivot random variable denoting runn ing time quicksort array size argue equation simplifies hint split summation parts bound equation recurrence equation solution lg hint substitution log positive constants problems stooge sort professors howard fine howard proposed elegant sorting algorithm stooge sort exchange return round stooge sort thirds stooge sort thirds stooge sort thirds argue length stooge sort length correctly sorts input array recurrence worst case running time stooge sort tight asymptotic notation bound worst case running time compare worst case running time ooge sort insertion sort merge sort heapsort quicksort professors deserve tenure problems stack depth quicksort quicksort algorithm recursive calls partition left subarray recurs ively sorted subarray recursively sorted recursive quicksort real ly avoided iterative control structure technique called tail recursion provided automatically good compilers cons ider version quicksort simulates tail recursion quicksort partition sort left subarray partition quicksort argue quicksort length correctly sorts array compilers execute recu rsive procedures stack pertinent including parameter values recursive stack initial procedure invoked pushed stack terminates popped assume array parameters represented pointers procedure stack requires stack space stack depth maximum stack space time computation scenario stack depth quicksort element input array modify code quicksort worst case stack depth lg maintain lg expected running time algorithm problems median partition improve randomized quick sort procedure partition pivot chosen car efully picking random element subarray common approach median method choose pivot median middle element set elements ndomly selected subarray exercise problem assume elements input array distinct denote sorted output array median method choose pivot element define exact formula function note increased likelihood choosing pivot median compared ordinary implementation assume limiting rati probabilities define good split choosing pivot increased lihood good split compared ordinary implementation hint approximate sum integral argue lg running time quicksort median method constant factor problems fuzzy sorting intervals sorting problem num bers number interval real belongs closed intervals form ai ai goal fuzzy sort intervals produce permutation i1 intervals su exist satisfying design algorithm fuzzy sorting intervals algorithm general structure algorithm quicksorts left endpoints ai advantage overlapping intervals improve running time intervals overlap problem fuzzy sorting intervals easier easier algorithm hould advantage overlapping extent exists argue algorithm runs expected time lg general runs expected time intervals overla exists ai algorithm checking case explicitly performance naturally improve overlap increases chapter notes quicksort procedure invented hoare hoare version appears problem partition procedure lomuto analysis avrim blum sedgewick bentley provide good reference details implementation matter mcilroy engineer killer adversary produces array virtually implementation quicksort takes time implementation randomized adversary produces array afte random choi ces quicksort algorithm chapter sorting linear time overview introduced algorithms sort numbers lg time merge sort heapsort achieve upper bound worst case quicksort achieves average algori thms produce sequence input numbers algorithm lg time algorithms share interesting property sorted order determine based comparisons input elements sorting algorithms comparison sorts sorting algorithms introdu ced comparison sorts prove comparison sort lg comparisons worst case sort elements merge sort apsort asymptotically optimal comparison sort exists faster constant factor sections examine sorting algorithms counting sort radix sort bucket sort linear time needless algorithms operations comparisons determine rted order lg lower bound apply lower bounds sorting comparison sort comparisons elements gain order input sequence elements ai perform tests ai ai ai ai ai determine relative order inspect values elements gain order assume loss generality input elements distinct assumption comparisons form ai useless assume comparisons form note comparisons ai ai ai ai equivalent yield identical informati relative order ai assume comparisons form ai decision tree model comparison sorts viewed abstractly terms decision trees decision tree binary tree represents comparisons elements performed sorting algorithm ope rating input size control data movement aspects algorithm figure decision tree insertion sort algorithm operating input sequence elements figure decision tree insertion sort operating elements internal node annotated comparison ai leaf annotated permutation ordering shaded path decisions sorting input sequence permutation leaf sorted ordering permutations inpu elements decision tree leaves decision tree ternal node annotated range number elements inpu sequence leaf annotated permutation background permutations execution sorting algorithm corresponds tracing path root decision tree leaf internal node comparison ai left ubtree dictates subsequent comparisons ai subtree dictates subsequent comparisons ai leaf sorti algorithm established ordering correct sorting algorithm produce permutation input condition comparison sort correct permutations elements leaves decision tree leaves reachable root path actual execution comparison sort refe leaves reachable decision trees permutation appears reachable leaf lower bound worst case length longest path root decision tree reachable leaves represents worst case number comparisons sorting algorithm performs worst case number comparisons comparison sort algorithm equals height decision tree lower bound heights decision trees permutation appears reachable leaf lower bound running time comparison sort algorithm theorem establishes lower bound theorem comparison sort algorithm requires lg comparisons worst case proof preceding discussion suffices determine height decision tree permutation appears reachable leaf decision tree height reachable leaves comparison sort elements permutations input appears leaf binary tree height leaves logarithms implies lg lg func tion monotonically increasing lg equation corollary heapsort merge sort asympt otically optimal comparison sorts proof lg upper bounds running times heapsort merge sort match lg worst case lower bound theorem exercises smallest depth eaf decision tree comparison sort exercises asymptotically tight bounds lg stirling approximation evaluate summation techniques exercises comparis sort running time lin ear half inputs length fraction inputs length fractionn exercises sequence elements sort input sequence consists subsequences elements elements subsequence smaller elements succeeding subs equence larger elements preceding subsequence eded sort sequence length sort elements subsequences lg lower bound number comparisons needed solve variant sorting problem hint rigorous simply combine lower bounds individual subsequences counting sort counting sort assumes input elements teger range integer sort runs time basic idea counting sort determine input element number elements place element directly position output array elements belongs output position scheme modified sli ghtly handle situation elements position code counting sort assume input array length require othe arrays array holds sorted output array temporary working storage counting sort length number elements equal number elements equal length downto figure illustrates counting sort initialization loop lines inspect input element loop lines input element increment holds number input elements equal integer lines determine input elements equal keeping running sum array figure operation counting sort input array element nonnegative integer larger array auxiliary array array output array auxiliary array iterations loop lines lightly shaded elements array filled final sorted output array finally loop lines place element correct sorted position output array elements distinct enter correct final position output array elements equal elements distinct decrement time place array decrementing input element equal exists position output array time counting sort require loop lines takes time loop lines takes time loop lines takes time loop lines takes time time practice counting sort case running time counting sort beats lower bound lg proved comparison sort fact comparisons input elements occur code counting sort actual values elements array lg lower bound sorting apply depart comparison sort model property ounting sort stable numbers output array order input array ties numbers broken rule whichever number appears rst input array appears output array norma lly property stability satellite data carried element sort counting sort stab ility reason counting sort subroutine radix sort counting sort stability cruc ial radix sort correctness exercises figure model illustrate oper ation counting sort array exercises prove counting sort stable exercises suppose loop header counting sort procedure rewritten length algorithm works prope rly modified algorithm stable exercises algorithm integers range preprocesses input answers query integers fall range time algorithm preprocessing time radix sort radix sort algorithm card sorti machines computer museums cards organized lumns column hole punched places sorter mechanically programmed examine column card deck distribute card bins depending place punched operator gather cards bin bin cards place punched car place punched digits places column places encoding nonnumeric characters digit number occupy field columns card sorter column time problem sorting cards digit number requires sorting algorithm intuitively sort numbers digit sort bins recursively combine decks order cards bins sort bins procedure generates intermediate piles cards track exercise radix sort solves problem card rting counterintuitiv ely sorting digit cards combined single deck cards bin preceding cards bin preceding cards bin entire deck sorted digit recombined manner process continues cards sorted digits remarkably point cards fully sorted digit number passes deck required sort figure radix sort operates deck digit numbers figure operation radix sort list digit numbers leftmost column input remaining column list successive sorts increasingly digit positions shading digit position sorted produce list previous essential digit sorts algorithm stable sort performed card sorter stable operator wary changing order cards bin cards bin digit chosen column typical computer sequential ndom access machine radix sort sort records keyed multiple fields sort dates keys year month day coul sorting algorithm comparison function dates compar years tie compares months tie occurs compares days alternatively sort times stable sort day month finally year code radix sort straightforward procedure assumes element element array digits digit lowest order digit digit highest order digit radix sort stable sort sort array digit lemma digit numbers digit values radix sort correctly sorts numbers time proof correctness radix sort induction column sorted exercise analysis running time depe nds stable sort intermediate sorting algorithm digit range values large counting sort obvious choice pass digit numbers takes time passes total time radix sort constant radix sort runs linear time generally flexibility break key digits lemma bit numbers positive integer radix sort correctly sorts numbers time proof view key digits bits digit integer range counting sort view bit word bit digits pass counting sort takes time passes total running time values choose minimizes expression lg choosing yields running time asymptotically optimal lg choosing lg time ithin constant factor choosing lg yields running time lg increase lg term numerator increases faster term denominator increasing lg yields running time lg decrease lg term increases term remains radix sort preferable comparison base sorting algorithm quick sort lg case choose lg radix sort running time appears quicksort average case time lg constant factors hidden notation differ radix sort fewer passes quicksort keys pass radix sort longer sorting algorithm preferable depends characteristics implementations underlying machine quicksort hard ware caches effectively radix sort input data version radix sort counting sort intermediate stable sort sort place lg time comparison sorts primary memory storage premium place algorithm quicksort preferable exercises figure model illustrate operation radix sort list english cow dog sea rug row mob box tab bar ear tar dig big tea fox exercises sorting algorithms stable insertion sort merge sort heapsort quicksort simple scheme sorting algorithm stable additional time space scheme entail exercises induction prove radix sort works proof assumption intermediate sort stable exercises sort integers range time exercises card sorting algorithm ction sorting passes needed sort digit numbers worst case piles cards operator track worst case bucket sort bucket sort runs linear time input drawn uniform distribution counting sort bucket sort fast assumes input counting sort assumes input consists integers small range bucket sort assumes input generated random process distributes elements uniformly interval definition uniform distribution idea bucket sort divide interval equal sized subintervals buckets distribute input numbers buckets inputs uniformly distributed expect numbers fall bucket produce output simply sort numbers bucket buckets order listing elements code bucket sort assumes input element array element array satisfies code requires auxiliary array linked lists buckets assumes mechanism maintaining lists describes implement sic operations linked lists bucket sort length insert list sort list insertion sort concatenate lists order figure operation bucket sort input array numbers figure operation bucket sort input array array sorted lists buckets algorithm bucket holds values half open interval sorted output consists concatenation order lists algorithm works elements assume loss generality element bucket bucket lower bucket loop lines puts proper order buckets puts proper order bucket sort works correctly analyze running time observe lines time worst case remains balance total time calls insertion sort analyze cost calls insertion sort random variable denoting number elements bucket insertion sort runs quadratic time running time bucket sort expectations sides linearity expectation claim surprise bucket input array equally fall bucket prove equation define indicator random variables xij falls bucket compute expand square regroup terms linearity expectation evaluate summations separately indicator random variable xij probability variables xij xik independent substituting expected values equation proves equation expected equation conclude expected time bucket sort entire bucket sort algorithm runs linear expected time input drawn uniform distribution bucket sort linear time long input property sum squares bucket sizes linear total number elements equation tells bucket sort linear time exercises figure model illustrate oper ation bucket sort array exercises worst case running time bucke sort algorithm simple change algorithm preserves linear expected runni time worst case running time lg exercises random variable equal number heads flips fair coin exercises points unit circle yi suppose points uniformly distributed probability finding point region circle proportional area region design expected time algorithm sort points distances origin hint design bucket sizes bucket sort reflect uniform distribution points unit circle exercises probability distribution function random variable defined suppose list random variables drawn continuous probability distribution function computable time sort numbers linear expected time problems average case lower bounds comparison sorting problem prove lg lower bound expected running time deterministic randomized comparison sort distinct input elements examining deterministic comparison sort decision tree ta assume permutation inputs equally suppose leaf ta labeled probabil ity reached random input prove leaves labeled labeled denote external path length decision tree sum depths leaves decision tree leaves left subtrees minimum decision trees leaves min ik hint decision tree leaves achieves minimum i0 number leaves i0 number leaves prove range function lg lg minimized conclude lg prove ta lg conclude expected time sort elements lg randomized comparison sort extend decision tree model handle randomization incorporating ki nds nodes ordinary comparison nodes randomization nodes randomization node models random choice form random algorithm node children equally chosen execution algorithm randomized comparison sort exists deterministic comparison sort comparisons average problems sorting place linear time suppose array data records sort key record algorithm sorting set records possess subset desirable characteristics algorithm runs time algorithm stable algorithm sorts place constant storage space addition original array algorithm satis fies criteria algorithm satis fies criteria algorithm satis fies criteria sorting algorithms fro parts sort records bit keys radix sort time explain suppose records keys range modify counting sort reco rds sorted place time storage input array algorithm stable hint problems sorting variable length items array integers integers numbers digits tal number digits integers array sort array time array strings fferent strings numbers characters total number characters strings sort strings time note desired order standard alphabetical order problems water jugs suppose red blue water jugs shapes sizes red jugs hold amounts water blue red jug blue jug holds water vice versa task grouping jugs pairs red blue jugs hold water perform operation pick pair jugs red blue red jug water pour water blue jug operation red blue jug hold water volume assume comparison takes time unit goal algorithm minimum number comparisons determine grouping remember directly compare red jugs blue jugs deterministic algorithm comparisons group jugs pairs prove lower bound lg number comparisons algorithm solving problem randomized algorithm xpected number comparisons lg prove bound correct worst case number comparisons algorithm problems average sorting suppose sorting array require elements increase average precisely element array sorted holds array sorted permutation numbers sorted sorted prove element array sorted algorithm sorts element array lg time lower bound time produce sorted array constant sorted array length sorted lg time hint solution exercise constant requires lg time sort element array hint solution previous lower bound comparison sorts problems lower bound merging sorted lists problem merging sort lists arises frequently subroutine merge sort procedure merge tw sorted lists merge problem lower bound worst case number comparisons quired merge sorted lists items lower bound comparisons decision tree numbers ways divide sorted lists numbers decision tree algorithm correctly merges sorted lists comparisons tighter bound elements consecutive sorted order opposite lists compared answer previous lower bound comparisons merging sorted lists chapter notes decision tree model studying comparison sorts introduced ford johnson knuth comprehensive treatise sorting covers variations sorting problem including theoretic wer bound complexity sorting lower bounds sorting generalizations decision tree model studied comprehensively ben knuth credits seward inventing counting sort idea combining counting sort radi sort radix sorting starting digit appears folk algorithm operators mechanical card sorting machines knuth published reference method document comrie describing punched card equipment buck sorting basic idea proposed isaac singleton munro raman stable sorting algorithm performs n1 comparisons worst case fixed constant lg time algorithms fewer comparisons algo rithm munro raman moves data times operates place case sorting bit integers lg time considered researchers positive assumptions model computation restrictions algorithm assume computer memory divided addressable bit fredman willard introduced fusion tree data structure sort integers lg lg lg time bound improved time andersson algorithms require multiplication precomputed constants andersson hagerup nilsson raman sort integers lg lg time multiplication method requires storage unbounded terms multiplicative hashing reduce storage needed lg lg worst case bound running time expected time bound generalizing exponential search trees andersson thorup lg lg time sorting algorithm multiplication rand omization linear space combining techniques ideas han improved bound sorting lg lg lg lg lg time algorithms impor tant theoretical breakthroughs fairly complicated time compete existing sorting algorithms practice chapter medians order statistics overview ith order statistic set elements ith smallest element minimum set elements order statistic maximum nth order statistic median informally halfway point set odd median unique occurring medians occurring parity medians occur lower median upper median simplicity text consistently phrase median refer lower median chapter addresses problem selecting ith order statistic set distinct numbers assume convenience set distinct numbers virtually extends situation set repeated values selection problem formally input set distinct numbers number output element larger elements selection problem solved lg time sort numbers heapsort merge sort simply ith element output array faster algorithms examine problem selecting minimum maximum set elements interesting general selection problem investigated subsequent sections analyzes practical algorithm achieves bound running time average case algorithm theoretical achieves running time worst case minimum maximum comparisons determine minimum set elements easily upper bound comparisons examine element set turn track smallest element procedure assume set resides array length minimum min length min min return min finding maximum accomplished comparisons lower bound comparisons problem determining minimum ink algorithm determines minimum tournament elements comparison match tournament smaller elements key observation element winner lose match comparisons determine minimum algorithm mini mum optimal spect number comparisons performed simultaneous minimum maximum applications minimum maximum set elements graphics ogram scale set data fit rectangular display screen graphical output device program determine minimum maximum coordinate difficult devise algorithm minimum maximum elements comparisons asymptotically optimal simply minimum maximum independently comparisons total comparisons fact comparisons sufficient minimum maximum strategy maintain mi nimum maximum elements processing element input comparing current minimum maximum cost compar isons element process elements pairs compare pairs elements input compare smaller current minimum larger current maximum cost comparisons elements setting initial values current minimum maximum depends odd odd set minimum maximu element process rest elements pairs perform comparison elements determine initial values minimum maximum process rest elements pairs case odd analyze total nu mber comparisons odd perform comparisons perform initial comparison comparisons total case total number comparisons exercises smallest elements lg comparisons worst case hint smallest element exercises comparisons worst case maximum minimum numbers hint numbers maximum minimum investigate comparison counts selection expected linear time general selection problem appears fficult simple problem finding minimum surprisingly asymptotic running time problems divide conquer algorithm selection problem algorithm randomized select modeled quicksort algorithm chapter quicksort idea partition input array recursively quicksort recursively processes sides partition randomized select works partition difference analysis quicksort expected running time lg expected time randomized select randomized select procedure randomized partition introduced randomized quicksort randomized algorithm behavior determined pa output random num ber generator code randomized select returns ith smallest element array randomized select return randomized partition pivot answer return elseif return randomized select return randomized select randomized partition executed algorithm array partitioned subarrays element equal turn element quicksort refer pivot element randomized select computes number elements subarray number elements low partition pivot element checks ith smallest element returned algorithm determines subarrays ith smallest element lies desired element li low partition recursively selected subarray desired element lies high partition values smaller ith smallest element šnamely elements šthe desired element smallest element recursively code appears recursive calls subarrays elements exercise asks situati happen worst case running time randomized select minimum extremely unl ucky partition largest remaining element partitioning takes time algorithm rks average case randomized partic ular input elicits worst case behavior time required randomized select input array elements random variable denote upper bound procedure randomized partition equally return element pivot subarray elements equal pivot probability define indicator random variables subarray elements randomized select choose pivot element priori terminate immediat ely correct answer recurse subarray recurse subarray decision depends ith smallest element falls relative assuming monotonically increasing bound time needed recursive time needed recursive largest input assume upper bound ith element partition greater number elements randomized select indicator random variable subarrays recurse sizes recurrence expected values order apply equation rely max independent random variables exercise asks justify assertion expression max term appears summation odd terms appears solve recurrence substitution assume constant satisfies initial conditions recurrence assume constant pick cons tant pick constant function term describes recursive component running time algorithm bounded inductive hypothesis order complete proof large expression equivalently add sides factor long choose constant divide sides assumea conclude order statistic media determined average linear time exercises randomized select recursiv length array exercises argue indicator random variable max independent exercises write iterative version randomized select exercises suppose randomized select select minimum element array sequence partitions worst case performance randomized select selection worst case linear time examine selection algorithm running time worst case randomized select algorithm select finds desired element recursively partitioning input array idea algorithm guarantee good split array partitioned select deterministic partitioning algorithm partition quicksort modified element partition input parameter select algorithm determines ith smallest input array elements executing steps select returns input ith smallest divide elements input array groups elements group remaining mod elements median groups insertion sorting elements group picking median sorted list group elements select recursively median medians step number medians convention lower median partition input array median medians modified version partition number elements low partition kth smallest element elements high partition return select recursively ith smallest element low smallest element high analyze running time select determine lower bound number elements greater partitioning element figure helpful visualizing bookkeeping half dians step greater median medians half groups contribute elements greater group fewer elements divide group discounting groups number elements greater figure analysis algorithm select elements represented small circles group occupies column medians groups whitened median medians labeled finding median number elements lower median arrows drawn larger elements smaller group elements greater group elements left elements greater shaded background number elements worst case select called recursively elements step develop recurrence worst case running time algorithm select steps time step consists calls insertion sort sets size step takes time step takes timen assuming monotonically increasing assumption unmotivated input fewer elements requires time origin magic constant clear shortl recurrence running time linear subs titution suitably large constant assuming suitably large constant assumption holds large pick constant func tion term describes recursive component runni time algorithm bounded substituting inductive hypothesis hand recurrence yieldsn inequality equivalent inequality assume choosing satisfy inequality note special constant replace integer strictly greater choose worst case running time select linear comparison sort select randomized select determine relative order elements comparing elements recall chapter sorting requires lg time comparison model average problem linear time sorting algorithms chapter assumptions input contrast linear time selection algorithms chapter require assumptions input subject lg lower bound manage solve selection problem sorting running time linear algo rithms sort linear time behavior result assumptions input case sorting algorithms chapter sorting requires lg time comparison model average problem method sorting ndexing presented introduction chapter asymptotically inefficient exercises algorithm select input elements divided groups algorithm work linear time divided oups argue select linear time groups exercises analyze select elements greater median medians elements exercises quicksort lg time worst case exercises suppose algorithm comparisons ith smallest element set elements smaller elements larger elements performing additional comparisons exercises suppose black box worst case linear time median subroutine simple linear time algorithm solves sele ction problem arbitrary order statistic exercises kth quantiles element set order statistics divide sorted set equal sized sets lg time algorithm list kth quantiles set exercises time algorithm set distinct numbers positive integer determines numbers closest median exercises arrays numbers sorted order lg time algorithm median elements arrays exercises professor olay consulting oil comp planning large pipeline running east west oil field wells spur pipeline connected directly main pipeline shortest path north south figure coordinates wells shoul professor pick optimal location main pipeline mini mizes total length spurs optimal location termined linear time figure professor olay determine position east west oil pipeline minimizes total length north south spurs problems largest nu mbers sorted order set numbers largest sorted order comparison based algorithm algorithm implem ents methods asymptotic worst case running time analyze running times algorithms terms sort numbers list largest build max priority queue numbers extract max times order statistic algorithm ith largest number partition number sort largest numbers problems weighted median distinct elements positive weights w1 w2 wn weighted lower median element satisfying argue median weighted median weights compute weighted median elements lg worst case time sorting compute weighted median worst case time linear time median algorithm select post office location problem defined points weights w1 w2 wn point input points minimizes sum distance points argue weighted median solution dimensional post office location problem points simply real numbers distance points solution dimensiona post office location problem points coordinate pairs distance points y1 manhattan distance y1 problems small order statistics worst case number comparisons select select ith order statistic numbers satisfy constant hidden notation large small relative implement procedure select subroutine fewer comparisons worst case algorithm comparisons ith smallest elements hint disjoint pairwise compar isons recurse set smaller element pairi lg constant lgn lg assumption numbers distinct greater concerned equality chapter notes worst case linear time medi finding algorithm devised blum floyd pratt rivest tarjan fast average time version hoare floyd rivest developed improved average time version partitions element recursively selected small sample elements unknown comparisons needed determine median lower bound comparisons median finding bent john upper bound schonhage paterson pippenger dor zwick improved bounds eir upper boundn lower bound paterson describes work iii data structures chapter list chapter elementary data structures chapter hash tables chapter binary search trees chapter red black trees chapter augmenting data structures introduction sets fundamental computer scie nce mathematics mathematical sets unchanging sets manipulated algorithms grow shrink change time sets dynamic chapters basic techniques representing finite dynami sets manipulating computer algorithms require types operations performed sets algorithms ability insert elements delete elements test membership set dynamic supports operations called dictionary algorithms require complicated operations min priority queues introduced chapter context heap data structure support operations inserting element extracting smallest element set implement dynamic set depends operations supported elements dynamic set typical implementation dynamic set element represen ted object fields examined manipulated pointer object discusses implementation objects inters programming environments basic data types kinds dynamic sets assume object fields identifying key field keys dynamic set set key values object satellite data carried object fields unused set implementation fields manipulated set operations fields data pointers objects set dynamic sets presuppose keys awn totally ordered set real numbers set ual alphabetic ordering totally ordered set satisfies trichotomy property defined total ordering define minimum element set eak element larger element set operations dynamic sets operations dynamic set grouped categories queries simply return set modifying operations change set list typical operations specific application require implemented search query set key returns pointer element key nil element belongs insert modifying operation augments set element pointed assume fields element needed set implementation initialized delete modifying operation pointer element set removes note operation pointer element key minimum query totally ordered set returns pointer element smallest key maximum query totally ordered set returns pointer element largest key successor query element key totally ordered set returns pointer larger element nil maximum element predecessor query element key totally ordered set returns pointer smaller element nil minimum element queries successor predecessor extended sets distinct keys set keys normal presumption minimum calls successor enumerates elements set sorted order time execute set operation usua lly measured terms size set arguments chapter describes data structure support operations listed set size time lg overview iii chapters œ14 data structures implement dynamic sets construct efficient algorithms variety problems data structurešthe heapšhas introduced chapter chapter presents essentials working simple data structures stacks queues linked lists rooted trees objects pointers implemented programming environments support primitives material familiar introductory programming chapter introduces hash tables support dictionary operations insert delete search worst case hashing requires time perform search operation expected time hash table operations analysis hashing relies probability chapter requires background subject binary search trees covered chapter support dynamic set operations listed worst case operation takes time tree elements randomly built binary search tree expected time operation lg binary search trees serve basis data structures red black trees variant binary search trees introduced chapter ordinary binary search trees red black trees guaranteed perform operations lg time worst case red black tree balanced search tree chapter presents kind balanced search tree called tree mechanics red black trees intricate glean properties chapter studying mechanics neverthele walking code instructive chapter augment red black ees support operations basic listed augment dynamically maintain order statistics set keys augment maintain intervals real numbers chapter elementary data structures chapter examine representation dynamic sets simple data structures pointers complex data struct ures fashioned pointers redimentary stacks ues linked lists rooted trees discuss method objects point ers synthesized arrays stacks queues stacks queues dynamic sets whic element removed set delete operation prespecified stack element deleted set inserted stack implements lifo policy queue element deleted set longest time queue implements fifo policy efficient ways implement stacks queues computer simple array implement stacks insert operation stack called push delete operation element argument cal led pop names allusions physical stacks spring loaded stacks plates cafeterias order plates popped stack reverse order pushed stack plate accessible figure implement stack elements array array attribute indexes recen tly inserted element stack consists elements element stack element figure array implementation stack stack elements lightly shaded positions stack elements element stack calls push push stack pop returned element pushed ement appears array longer stack element stack elements stack tested emptiness query operation stack stack popped stack underflows error exceeds stack overflows pseudocode implementation worry stack overflow stack operations implemented lines code stack return true return false push pop stack error underflow return figure effects modifying operations push pop stack operations takes time queues insert operation queue enqueue delete operation dequeue stack operation pop dequ eue takes element argument fifo property queue operate people registrar office queue head tail element enqueued ta kes place tail queue newly arriving student takes place element dequeued head queue student head waited longest fortunately worry computational elements cutting figure implement queue elements array queue attribute head indexes points head attribute tail indexes location newly arriving element inserted queue elements queue locations head head tail wrap sense location location circular order head tail queue initially head tail queue attempt dequeue element queue underflow head tail queue attempt enqueue element queue overflow figure queue implemented array queue elements lightly shaded positions queue elements locations configuration queue calls enqueue enqueue enqueue configuration queue dequeue returns key head queue head key procedures enqueue dequeue error checking underflow overflow exercise asks supply code checks error conditions enqueue tail tail length tail tail tail dequeue head head length head head head return figure effects enqueue dequeue operations operation takes time exercises figure model illustrate result operation sequence push push push pop push pop initially stack stored array exercises explain implement stacks array stack overflows total number ements stacks push pop operations time exercises figure model illustrate result operation sequence enqueue enqueue enqueue dequeue enqueue dequeue initially queue stored array exercises rewrite enqueue dequeue detect underflow overflow queue exercises stack insertion deletion elements queue insertion deletion deque double ended queue insertion deletion ends write time procedures insert elements delete elements ends deque constructed array exercises implement queue acks analyze running time queue operations exercises implement stack ues analyze running time stack operations linked lists linked list data structure objects arranged linear order array linear order determined array indi ces order linked list determined pointer ject linked lists provide simple flexible representation dynamic sets supporting hough efficiently operations listed figure element doubly linked list object key field pointer fields prev object cont satellite data element list points successor linked list prev points predecessor prev nil element predecessor element head list nil element successor element tail list attribute head points element list head nil list figure doubly linked list representing dynamic set element list object fields key pointers arrows previous objects field tail prev field head nil diagonal slash attribute head points head execution list insert key linked list object key head object points head key result subsequent list delete points object key list forms singly linked doubly linked sorted circular list singly linked omit prev pointer element list sorted linear order list corresponds linear order keys stored elemen list minimum element head list maximum element tail list unsorted elements order circular list prev pointer head list points tail pointer tail list points head list viewed ring elements remainder assume lists working unsorted doubly linked searching linked list procedure list search finds element key list simple linear search returning pointer element object key appears list nil returned linked list figure list search returns pointer ement list search returns nil list search head nil key return search list objects list search procedure takes time worst case search entire list inserting linked list element key field set list insert procedure splices linked list figure list insert head head nil prev head head prev nil running time list insert list elements deleting linked list procedure list delete removes element linked list pointer splices list updating pointers delete element key list search retrieve pointer element list delete prev nil prev head nil prev prev figure element deleted linked list list delete runs time delete element key time required worst case list search sentinels code list delete simpler ignore boundary conditions head tail list list delet prev prev prev sentinel dummy object simplify boundary conditions suppose provide list object nil represents nil fields list elements ference nil list code replace reference sentinel nil figure turns regular doubly linked list circular doubly linked list sentinel sentinel nil head tail field nil points head list prev nil points tail field tail prev field head point nil nil points head eliminate attribute head altogether replacing referenc references nil lis consists sentinel nil prev nil set nil figure circular doubly linked list sentinel sentinel nil appears head tail attribute head longer needed access head list nil list linked list figure key head key tail list executing list inser key object head list list deleting object key tail object key code list search remains references nil head changed list searc nil nil key return procedure list delet delete element list procedure insert element list list inser nil prev nil nil prev nil figure effects list inser list delet sample list sentinels rarely reduce asymptotic time boun data structure operations reduce constant factors gain sentinels loops matter clarity code speed linked lis code simplified sentinels save time list inser list delet procedures situations sentinels helps tighten code loop reducing coefficient running time sentinels indiscriminately small lists extra storage sentinels represent wasted memory book sentinels simplify code exercises dynamic set operation insert implemented singly linked list time delete exercises implement stack singly linked list operations push pop time exercises implement queue singly linked list operations enqueue dequeue time exercises written loop iteration list searc procedure requires tests nil key eliminate test nil iteration exercises implement dictionary operations insert delete search singly linked circular lists unning times procedures exercises dynamic set operation union takes disjoint sets s1 input returns set s1 consisting elements s1 sets s1 destroyed operation support union time suitable list data structure exercises time nonrecursive procedure reverses singly linked list elements procedure constant storage needed list exercises explain implement doubly linked lists pointer np item usual prev assume pointer values interpreted bit integers define np np xor prev bit exclusive prev nil represented needed access head list impl ement search insert delete operations list reverse list time implementing pointers objects implement pointers objects langua ges fortran provide ways implementing linked data structures explicit pointer data type synthe size objects pointers arrays array indices multiple array representation objects represent collection objects fields array field figure impl ement linked list figure arrays array key holds values keys dynamic set pointers stored arrays prev array key prev represent object linked list interpretation pointer simply common key prev arrays figure linked list figure represented arrays key prev vertical slice arrays represents single object stored pointers correspond array indices arrows interpret lightly shaded object positions list elements variable head figure object key object key linked list figure key appears key key appears key prev constant nil appears field tail prev field head integer represent actual arrays variable holds head list pseudocode square brackets denote indexing array selection field attribute object meanings key prev consistent implementation practice single array representation objects computer memory typi cally addressed integers suitably large integer programming nguages object occupies contiguous set locations computer memory pointer simply address memory location object othe memory locations object indexed adding offset pointer strategy implementi objects programming environments provide explicit pointer data types figure single array store linked list figures object occupies contiguous subarray field object corresponds offset range pointer object figure offsets key prev respectivel read prev pointer add pointer offset reading figure linked list figures represented single array list element object occupies conti guous subarray length array fields key prev correspond offsets pointer object element object objects list elements lightly shaded arrows list ordering single array representation flexible permits object lengths stored array problem mana ging heterogeneous collection objects difficult problem managi homogeneous collection objects fields data structures composed homogeneous elements sufficient purposes multiple array representation objects allocating freeing objects insert key dynamic set represente doubly linked list allocate pointer unused object linked list representation manage storage objects linked list representation allocated systems garbage collector responsible determining objects unused applications simple bear responsibility returning unused object storage manager explore problem allocating freei deallocating homogeneous objects doubly linked list represented multiple arrays suppose arrays multiple array representation length moment dynamic set elements objects represent elements dynamic set remaining mœn objects free free objects represent elements inserted dynamic set future free objects sing ly linked list free list free list array stores pointers list head free list held global variable free dynamic set represented linked list nonempty free list intertwined list figure note object representation list free list figure allocate object free object procedures list figure lightly shaded free list heavily shaded arrows free list structure result calling allocate object returns setting key calling list insert free list head object free list executing list delete free object object free list head object free list free list stack object allocated freed list implementation stack ope rations push pop plement procedures allocating freeing objects assume global variable free procedures points element free list allocate object free nil error space free free return free object free free free list initially unallocated objects free list exhausted allocate object procedure signals error common single free list service linked lists figure linked lists free list intertwined key prev arrays figure linked lists l1 lightly shaded heavily shaded free list darkened intertwined procedures time practical modified work omogeneous collection objects letting fields object field free list exercises draw picture sequence stored doubly linked list multiple array representation single array representation exercises write procedures allocate object free object homogeneous collection objects implemented single array representation exercises set reset prev fields objects implementation allocate object free object procedures exercises desirable elements doubly linked list compact storage locations multiple array representation case paged virtual memory computing environmen explain procedures allocate object free object implemented representation compact assume pointers elements linked list list hint array implementation stack exercises doubly linked list length stored arrays key prev length suppose arrays manage allocate object free object procedures doubly linked free list suppose items list free list write procedure compactify list list free list moves items occupy array positions adjusts free list remains correct occupying array positions running time procedure constant extra space car eful argument correctness procedure representing rooted trees methods representing lists previous extend homogeneous data structure problem representing rooted trees linked data structures nary trees method rooted trees nodes arbitrary number children represent node tree object linked lists assume node key field remaining fields pointers nodes vary type tree binary trees figure fields left store pointers parent left child child node binary tree nil root node left child left nil child root entire tree pointed attribute root root nil tree figure representation binary tree node fields left lower left lower key fields rooted trees unbounded branching scheme representing binary tree extended class trees number children node constant replace left fields child1 child2 childk scheme longer works number children node unbounded fields arrays multiple array representation allocate advance number children bounded large constant nodes sma number children waste lot memory fortunately clever scheme binary trees represent trees arbitrary numbers children advantage space node rooted tree left child sibling representation figure node parent pointer root points root tree pointer children node pointers figure left child sibling representation tree node fields left child lower left sibling lower keys left child points leftmost child node sibling points sibling node children left child nil node rightmost child parent sibling nil tree representations represent rooted trees ways chapter represented heap based complete binary tree single array trees chapter traversed root parent pointers pointers children schemes scheme depends application exercises draw binary tree rooted represented fields key left nil nil nil nil nil nil nil nil nil nil exercises write time recursive procedure node binary tree prints key node tree exercises write time nonrecursive proce dure node binary tree prints key node tree stack auxiliary data structure exercises write time procedure prints arbitrary rooted tree nodes tree stored left child sibling representation exercises write time nonrecursive proce dure node binary tree prints key node constant extr space tree modify tree tempor arily procedure exercises left child sibling representation arbitrary rooted tree pointers node left child sibling parent node parent reached identified constant time children reached identified time linear number children onl pointers boolean node parent node children reached identified time linear number children problems comparisons lists types lists followi table asymptotic worst case running time dyna mic set operation listed unsorted singly linked sorted singly linked unsorted doubly linked sorted doubly linked search insert delete successor predecessor minimum maximum problems mergeable eaps linked lists mergeable heap supports operations heap creates mergeable heap insert minimum extract min union implement mergeable heaps linked lists cases operation efficient analyze running time operation terms size dynamic set operated lists sorted lists unsorted lists unsorted dynamic sets merged disjoint problems searching sorted compact list exercise asked maintain element list compactly positions array assume keys distinct compact list sorted key key nil assumptions randomized algorithm search list expected time compact list search head nil key random key key key key return nil key return nil return ignore lines œ7 procedure ordinary algorithm searching sorted linked list points position list turn search terminates falls list key case key key key key terminating search thing lines œ7 attempt skip ahead randomly chosen position skip beneficial key larger key larger case marks position list reach ordinary list search list compact choice indexes object list slot free list analyzing performance compact list search directly analyze algorithm compact list searc executes separate loops algorithm takes additional parameter determines upper bound number iterations loop compact list searc head random key key key key return nil key nil key return nil return compare execution algorithms compact list search compact list searc assume sequence integers returned calls random algorithms suppose compact list search takes iterations loop lines œ8 argue compact list searc returns answer total number iterations loops compact list searc compact list searc random variable describes distance linked list chain pointers position desired key iterations loop lines œ7 occurred argue expected running time compact list searc hint equation prove compact list searc runs expected time conclude compact list search runs expected time assume keys stinct compact list search argue random skips asymptotically list repeated key values defined mergeable eap support minimum extract min refer mergeable min heap alternatively supported maximum extract max mergeable max heap chapter notes aho hopcroft ullman knuth excellent references elementary data structures texts cover basic data structures implementation programming language examples types textbooks include goodrich tamassia main shaffer weiss gonnet experimental data performanc data structure operations origin stacks queues data structures computer science unclear notions existed mathematics pa based business practices introduction digital computers knuth cites turing development stacks subroutine linkage pointer based data structures folk knuth pointers early computers drum memories language developed hopper represented algebraic formulas binary trees knuth credits ipl language developed newell shaw simon recognizing promoting pointers ipl iii language developed included explicit stack operations chapter hash tables overview applications require dynamic set supports dictionary operations insert search delete compiler computer language maintains symbol table keys elements arbitrary character strings correspond identifiers language hash table effective data structure implementing dictionaries searching element hash table long searching element linked listš time worst casešin practice hashing performs extremely reasonable assu mptions expected time search element hash table hash table generalization simpler notion ordinary array directly addressing ordinary array effective ability examine arbitrary position array time discusses direct addressing direct addressing applicable afford allocate array position key number keys stored smal relative total number keys hash tables effective alternative directly addressing array hash table typically array size proportional number keys stored key array directly array computed key presents main ideas focusing chaini handle collisions key maps array describes array indices computed keys hash functi ons analyze variations basic theme open addressing deal collisions hashing extremely effective practical technique basic dicti onary operations require time average explains perfect hashing support searches worst case time set keys stored static set keys stored direct address tables direct addressing simple technique works universe keys small suppose application dynamic set element key drawn universe large assume elements key represent dynamic set array direct address table denoted position slot corresponds key universe figure illustrates approach slot points element set key set element key nil figure implementing dynamic set direct address table key universe corresponds table set actual keys determines slots tabl pointers elements slots heavily shaded nil dictionary operations trivial implement direct address search return direct address insert key direct address delete key nil operati ons fast time required applications elements dyna mic set stored direct address table storing elem ent key satellite data object external direct address table pointer slot table object store object slot saving space unnecessary store key field object object table key keys stored slot exercises suppose dynamic set represented direct address table length procedure finds maximum element worst case performance procedure exercises bit vector simply array bits bit vector length takes space array pointers bit vector represent dynamic set distinct elements satellite data dictionary operations time exercises implement direct address table keys stored elements distinct elements satellite data thr dictionary operations insert delete search time forget delete takes argument pointer object deleted key exercises implement dictionary direct addressing huge array start array entries garbage initia lizing entire array impractical size scheme implemen ting direct address dictionary huge array stored object space operations search insert delete time initialization data structure time hint additional stack size number keys stored dictionary determine entry huge arra valid hash tables difficulty direct addressing obvious universe large storing table size impractical impossible memory typical computer set keys stored small relative space allocated wasted set keys stored dictionary smaller universe keys hash table requires storage direct address table storage requirements reduced maintain benefit searching element hash table requires time catch bound average time direct addressing holds worst case time direct addressing element key stored slot hashing element stored slot hash function compute slot key maps universe keys slots hash table element key hashes slot hash key figure illustrates basic idea point hash function reduce range array indices handled values handle values storage requirements correspondingly reduced figure hash function map keys hash table slots keys k2 k5 map slot collide hitch keys hash slot situation collision fortunately effective techniques resolving conflict created collisions ideal solution avoid collisions altogether achieve goal choosing suitable hash function idea random avoiding collisions minimizing number term hash evoking images random mixing chopping captures spirit approach hash function deterministic input produce output tw keys hash avoiding collisions altogether ther efore impossible designed random hash function minimize number collisions method resolving llisions occur remainder presents simplest collision resolution technique called chaining introduces alternative method resolving collisions called open addressing collision resolution chaining chaining elements hash slot linked list figure slot pointer head list stored elements hash elements slot nil figure collision resolution chaining hash table slot linked list keys hash k1 k4 k5 k2 k7 dictionary operations hash table easy implement collisions resolved chaining chained hash insert insert head list key chained hash search search element key list chained hash delete delete list key worst case running time insertion insertion procedure fast assumes element inserted table assumption checked ditional cost perfor ming search insertion searching worst case running time proportiona length list analyze operation osely deletion element accomplished time lists doubly li nked note chained hash delete takes input element key search lists singly linked great input element key list key link predecessor properly set splice case deletion searching essentially running time analysis hashing chaining hashing chaining perform long search element key hash table slots stores elements define load factor average number elements stored chain analysis terms equal greater worst case behavior hashing chaining terrible keys hash slot creating list length worst case time searching time compute hash functionšno linked list elements hash tables worst case performance perfect hashing provide good worst case performance set keys static average performance hashing depends hash function distributes set keys stored slots average discusses issues assume elemen equally hash slots independently element hashed assumption simple uniform hashing denote length list average assume hash computed time time required search element key depends linearly length nh list setting time required compute hash function access slot expected number elements amined search algorithm number elements list checked keys equal cases search unsuccessful element table key search finds element key theorem hash table collisions reso lved chaining unsuccessful search takes expected time assumption simple uniform hashing proof assumption simple uniform hashing key stored table equally hash slots expected time search unsuccessfully key expected time search list expected length nh expected number elements examined unsuccessful search total time required luding time computing situation successful search list equally searched probability list searched proportional number elements expected search time theorem hash table collisions reso lved chaining successful search takes time average assumption simple uniform hashing proof assume element searched equally elements stored table number elements examined successful search element number elements list elements list inserted inserted elements list expected numbe elements examined average elements table expected number elements list list denote ith element inserted table ki key keys ki define indicator random variable xij ki assumption simple uniform hashing ki lemma xij expected number elements examined successful search total time required successful search including time computing hash functionn analysis number hash table slots proportional number elements table searching takes constant time average insertion takes worst case time deletion takes worst case time list doubly linked dictionary operations supported time average exercises suppose hash function hash distinct keys array length assuming simple uniform hashing expected number collisions precisely expected cardinality exercises demonstrate insertion keys hash table collisions resolved chaining table slots hash function mod exercises professor marley hypothesizes substantial performance gains modify chaining scheme list sorted order professor modification affect running time successful searches unsuccessful searches insertions deletions exercises storage elements allocated deallocated hash table linking unused slots free list assume slot store flag element pointer poi nters dictionary free list operations expected time free list doubly linked singly linked free list suffice exercises nm subset size consisting keys hash slot worst case search ing time hashing chaining hash functions discuss issues rega rding design good hash functions schemes creation schemes hashing division hashing multiplication heuristic nature scheme universal hashing randomization provide provably good performance good hash function good hash function satisfies assumption simple uniform hashing key equally hash slots independently key hashed typically check condition rarely probability distribution keys drawn keys drawn independently occasionally distribution exam ple keys random real numbers independently uniformly distributed range hash function satisfies condition simple uniform hashing practice heuristic chniques create hash function performs qualitative distribution keys design process compiler symbol table keys character strings representing identifiers ogram closely symbols pts occur program good hash function woul minimize chance variants hash slot good approach derive hash expected independent patterns exis data division method discussed computes hash remainde key divided prime number method frequently goo assuming prime number chosen unrelated patterns distribution keys finally note applications ha sh functions require stronger properties provided simple uniform hashing keys close sense yield hash values property desirable linear probing defined universal hashing desired properties interpreting keys natural numbers hash functions assume universe keys set natural numbers keys natural numbe interpret natural numbers character string interpreted integer expressed suitable radix notation identifier interpreted pair integers ascii character set expressed radix integer ually straightforward application devise method interpreting key large natural number assume keys natural numbers division method division method creating hash functions map key slots remainder divided hash function mod hash table size key requires single division operation hashing division fast division method avoid values power lowest order bits low order bit patterns equally hash function depend bits key exercise asks choosing character string interpreted radix poor choice permuting characters change hash prime close exact power good choice suppose allocate hash table collisions resolved chaining hold roughly character strings character bits mind examining average elements unsuccessful searc allocate hash table size number chosen prime ear power treating key integer hash function mod multiplication method multiplication method creating hash functions operates steps multiply key constant range extract fractional ka multiply floor result short hash function ka mod mod fractional ka ka ka advantage multiplicati method critical typically choose power integer easily implement function computers uppose word size machine bits fits single word restrict fraction formw integer range referring figure multiply bit integer result bit r12w r0 r1 high order word product r0 low order word product desired bit hash consists bits r0 figure multiplication method hashing bit representati key multiplied bit highest order bits lower bit half product form desired hash method works constant works values optimal choice pends characteristics data hashed knuth suggests work suppose adapting knuth suggestion choose fraction form closest r1 r0 bits r0 yield universal hashing malicious adversary chooses keys hashed fixed hash function choose keys hash slot yielding average retrieval time fixed hash function vulnerable terrible worst case behavior effective improve situation choose hash function randomly independent keys stored approach called universal hashing yield provably good performance aver age matter keys chosen adversary main idea universal hashing select hash function random carefully designed class functions execution case quicksort randomization guarantees sing input evoke worst case behavior randomization algorithm behave differently execution input guarant eeing good average case performance input returning compiler symbol table programmer choice identifiers consistently poor hashing performance poor performance occurs compiler hooses random hash function set identifiers hash probability situation occurring small set identifiers size finite collection hash functions map universe keys range collection universal pair distinct keys number hash functions hash function randomly chosen chance collision distinct keys chance collision randomly independently chosen set theorem universal ass hash functions good average case behavior recall denotes length list theorem suppose hash function chosen universal coll ection hash functions hash keys table size chaining resolve collisions key table expected length nh list key hashes key table expected length nh list key proof note expectations ov choice hash function depend assumptions distribution keys pair distinct keys define indicator random variable xkl definition single pair keys collides probability lemma implies xkl define key random variable yk equals number keys hash slot remainder proof depends key table nh yk nh yk key appears list count yk include key nh yk nh yk corollary universal hashing desired payoff impossible adversary pick sequen operations forces worst case running time cleverly randomizing choice hash function time guarantee sequence operations handled good expected running time corollary universal hashing collision resolution chaining table slots takes expected time handle sequence insert search delete operations insert operations proof number insertions insert delete operations constant time theorem expected time search operation linearity expectation expected time entire sequence operations designing universal class hash functions easy design universal class hash functions littl number theory prove consult chapter unfamilia number theory choosing prime number large key range inclusive zp denote set denote set prime solve equations modulo methods chapter assume size universe keys greater number slots hash table hav define hash function ha zp linear transformation reductions modulo modulo family hash functions hash function ha maps zp zm class hash functions nice property size output range arbitraryšnot primeša feature choices choices hash functions theorem class hash functions defined equations universal proof distinct keys zp hash function ha ak mod mod note observe mod prime nonzero modulo product nonzero modulo theorem computation ha distinct inputs map distinct values modulo collisions mod level choices pair yields pair solve mod mod ak mod mod denotes unique multiplicative inverse modulo pairs correspondence pairs pairs pair inputs pick uniformly random pair equally pair distinct values modulo probability distinct keys collide equal probability mod randomly chosen distinct values modulo remaining values number values mod inequality probability collides reduced modulo pair distinct values zp ha ha universal exercises suppose search linked list length element key hash key long character string advantage hash values searching list element key exercises suppose string characters hashed slots treating radix number division method number easily represented bit computer word string characters treated radix number takes apply division method compute hash character string constant number rds storage string exercises version division method mod character string interpreted radix string derived string permuting characters hash application property undesirable hash function exercises hash table size hash function mod compute locations keys mapped exercises define family hash functions finite set finite set universal pairs distinct elements probability drawing hash function random family universal family hash functions exercises set tuples values drawn zp zp prime define hash function hb zp input tuple a0 hb zp argue universal definition universal exercise hint exercise open addressing open addressing elements stored hash table table entry element dynamic set nil searching element systematically examine table slots desi red element clear element table lists elements stored table chaining open addressing hash table insertions load factor exceed store linked lists chaining inside hash table unused hash table slots exercise advantage open addressing avoids pointers altogether pointers compute sequence slots examined extra memory freed oring pointers hash table larger number slots memory yielding fewer collisions faster retrieval perform insertion open addr essing successively examine probe hash table slot key fixed order requires search time sequence positions probed depends key inserted determine slots probe extend hash function include probe number starting input hash function open addressing require key probe sequence permutation hash table position eventually considered slot key table fills pseudocode assume elements hash table keys satellite key identical element key slot key nil slot hash insert repeat nil return error hash table overflow algorithm searching key probes sequence slots insertion algorithm examined key inserted search terminate unsuccessfully nds slot inserted probe sequence argument assumes keys deleted hash table procedure hash search takes input hash table key returning slot key nil key table hash search repeat return nil return nil deletion open address hash table difficult delete key slot simply mark slot storing nil ing impossible retrieve key insertion probed slot occupied solution mark slot storing special deleted nil modify procedure hash insert treat slot key inserted modification hash search needed pass deleted values searching special deleted search times longer dependent load factor reason chaining commonly selected collis ion resolution technique keys deleted analysis assumption uniform hashing assume key equally permutations probe sequence uniform hashing generalizes notion simp uniform hashing defined earlier situation hash unction produces single number probe sequence true uniform hashing difficult implement practice suitable approximations double hash ing defined techniques commonly compute probe sequences required open addressing linear probing quadratic probing double hashing techniques guarantee permutation key techniques fulfills assumption uniform hashing capable generating probe sequences uniform hashing requires double ha shing greatest number probe sequences expect linear probing ordinary hash function refer auxiliary hash function method linear probing hash function mod key slot probed slot auxiliary hash function probe slot slot wrap slots finally probe slot initial probe determines entire probe sequence distinct probe sequences linear probing easy implement suffers problem primary clustering long runs occupied slots build increasing average search time clusters slot preceded slots filled probability long runs occupied slots tend longer average search time increases quadratic probing quadratic probing hash function form auxiliary hash function auxiliary constants initial position probed positions probed offset amounts depend quadratic manner probe number method works linear probing hash table values constrained problem select parameters keys initial probe position eir probe sequences k1 k2 implies k1 k2 property leads ilder form clustering called secondary clustering linear probing initial probe determines entire sequence distinct probe sequences double hashing double hashing methods open addressing permutations produced charact eristics randomly chosen permutations double hashing hash function form h1 ih2 mod h1 auxiliary hash functions initial probe position h1 successive probe positions offset previous positions modulo case linear quadratic probing probe sequence depends ways key initial probe position offset vary figure insertion double hashing figure insertion double hashing hash table size h1 mod mod mod mod key inserted slot slots examined occupied prime hash table size entire hash table searched exercise convenient ensure condition power design produces odd number prime design returns positive integer choose prime h1 mod mod chosen h1 probe position slot modulo examined key ound slot examined double hashing improves linear quadratic probing probe sequences h1 pair yields distinct probe sequence result performance double hashing app ears close performance ideal scheme uniform hashing analysis open address hashing analysis open addressing analysis chaining expressed terms load factor hash table infinity open addressing element slot implies assume uniform hashing idealized scheme probe sequence insert search key equally permutation key unique fixed probe sequence meant probability distribution space keys operation ha sh function keys probe sequence equally analyze expected number probe hashing open addressing assumption uniform hashing analysis number probes unsuccessful search theorem open address hash table load factor expected number probes unsuccessful search assuming uniform hashing proof unsuccessful search probe accesses occupied slot desired key slot probed define random variable number probes uns uccessful search define event ai event ith probe occupied slot event intersection events ai bound bounding ai exercise ai ai ai elements slots probability jth probe occupied slot probes occupied slots probability finding remaining elements unexamined slots assumption uniform hashing probability ratio quantities observing implies equation bound expected number probes bound intuitive interpretation probe probability probe finds occupied slot probe probability slots occupied probe constant theorem predicts unsu ccessful search runs time hash table half erage number probes unsuccessful search percent average number obes theorem performance hash insert procedure corollary inserting element open dress hash table load factor requires probes average assuming uniform hashing proof element inserted room table inserting key requires unsuccessful search placement key slot expected number probes computing expected number probes successful search requires work theorem open address hash table load factor expected number probes successful search assuming uniform hashing assuming key table equally searched proof search key probe sequence element key inserted corollary key inserted hash table expected number probes search averaging keys hash table average number probes successful search ith harmonic number defined equation technique bounding summation integral bound expected number probes successful search hash table half expected numbe probes successful search hash table percent expected number probes exercises inserting keys hash table length open addressing primary hash function mod illustrate result inserting keys linear probing quadratic probing double hashing mod exercises write pseudocode hash delete outlined text modify hash insert handle special deleted exercises suppose double hashing resolve collisions hash function h1 ih2 mod greatest common divisor key unsuccessful search key examines hash table returning slot h1 prime search examine entire hash table hint chapter exercises open address hash table uniform hashing upper bounds expected number probes unsuccessful search expected number probes successful search load factor exercises open address hash table load factor nonzero expected number probes unsuccessful search equals expected number probes successful search upper bounds theorems expected numbers probes perfect hashing hashing exce llent expected performance hashing excellent worst case performance set keys static keys stored table set keys app lications naturally static sets keys set reserved programming language set file names rom hashing technique perfect hashing worst case number memory accesses required perform search basic idea create perf ect hashing scheme simple level hashing scheme universal hashing level figure illustrates approach figure perfect hashing store set outer hash function ak mod mod key hashes slot table secondary hash table stores keys hashing slot size hash table mj hash function mod mod mj key stored slot secondary hash table collisions seco ndary hash tables searching takes constant time worst case level essentially hashing chaining keys hashed slots hash function carefully selected fami ly universal hash functions making list keys hashing slot small secondary hash table hash function choosing hash functions carefully guarantee collisions secondary level order guarantee collisions secondary level size mj hash table square number keys hashing slot quadratic dependence mj storage requirements excessive choosing level hash function expected total ount space hash functions chosen universal classes hash functions level hash function chosen class prime number greater key lue keys hashing slot hashed secondary hash table size mj hash function chosen class proceed steps sha determine ensure secondary tables collisions expected memory overallšfor primary hash table secondary hash tablesšis theorem store keys hash table size hash function randomly chosen universal class hash functions probability collisions proof pairs keys collide eac pair collides probability chosen random universal family hash functions random variable counts number collisions expected number collisions note analysis analysis birthday paradox applying markov inequality completes proof situation theorem hash function chosen random collisions set keys hashed remember static easy collision free hash function random trials large hash table size excessive adopt level hashing approach approach theorem hash entries slot outer level hash function hash keys slots keys hash slot secondary hash table size provide collision free constant time lookup turn issue ensuring memory size mj jth secondary hash table grows quadratically number keys stored risk storage excessive level table size memory primary hash table storage sizes mj secondary hash tables storage parameters defining secondary hash functions drawn class theorem corollary provide bound expected combined sizes secondary hash tables corollary bounds probability combined size secondary hash tables superlinear theorem store keys hash table size hash function randomly chosen universal class hash functions number keys hashing slot proof start identity holds nonnegative integer evaluate summation observe total number collisions properties universal hashing expected summation corollary store keys hash table size hash function randomly chosen universal class hash functions set size secondary hash table expected storage required secondary hash tables perfect hashing scheme proof theorem completes proof corollary store keys hash table size hash function randomly chosen universal class hash functions set size secondary hash table probability total storage secondary hash tables exceeds proof apply markov inequality time inequality corollary testing randoml chosen hash functions universal family yield reasonable storage exercises suppose insert keys hash table size open addressing uniform hashing probability collisions occur hint equation argue exceeds probability avoiding collisions rapidly problems longest probe bound hashing hash table size store items open addressing collision resolution assuming uniform hashing probability ith insertion requires strictly probes probability ith insertion requires lg probes random variable denote number probes required ith insertion lg random variable maxin denote maximum number probes required insertions lg expected length longest probe sequence lg problems slot size bound chaining suppose hash table slots collisions resolved chaining suppose keys inserted table key equally hashed slot maximum number keys keys inserted mission prove lg lg lg upper bound expected argue probability qk keys hash slot probability probability slot keys keys nqk stirling approximation equation qk ek kk exists constant k0 clg lg lg conclude k0 lg lg lg argue conclude lg lg lg problems quadratic probing suppose key search hash table positions suppose hash function mapping key space set search scheme compute set probe position desired key position terminate search set mod mod return step assume power scheme instance general quadratic probing scheme exhibiting constants equation prove algorithm examines table position worst case problems universal ha shing authentication class hash functions maps universe keys universal fixed sequence distinct keys chosen random sequence equally mk sequences length elements drawn universal universal set tuples values drawn zp zp prime tuple a0 values zp zp define hash function ha input tuple x0 ha argue universal suppose alice bob agree secretly hash function ha universal family hash functions alice sends message bob internet authenticates message bob sending authentication tag ha bob checks pair receives satisfies ha suppose adversary intercepts route fool bob replacing pair pair argue probability adversary succeeds fooling bob accepting matter computing power adversary mj hash function slot choose hash function ha ak mod mod mj slot chapter notes knuth gonnet excellent references analysis hashing algorithms knuth credits luhn inventing hash tables chaining method resolving collisions time amdahl originated idea open addressing carter wegman introduced notion universal classes hash functions fredman komlós szemerédi developed perfect hashing scheme static sets presented extension method dynamic sets handling insertions deletions amortized expected time dietzfelbinger chapter binary search trees overview search trees data structures support dynami set operations including search minimum maximum predecessor successor insert delete search tree dictionary priority queue basic operations binary search tree time proportional height tree complete binary tree nodes operations lg worst case time tree linear chain nodes operations worst case time expected height randomly built binary search tree lg basic dynamic set operations tree lg time average practice gua rantee binary search ees built randomly variations binary search trees worst case perfor mance basic operations guaranteed good chapter presents variation red black trees height lg chapter introduces trees good maintaining databases random access secondary disk storage presenting basic properties binary search trees sections walk binary search tree print values sorted order search binary search tree minimum maximum element predecessor successor element insert delete binary search tree basic mathematical operties trees appendix binary search tree binary search tree organized suggests binary tree figure tree represented linked data structure node object addition key field satellite data node fields left point nodes left child child parent child parent missing field nil root node node tree parent field nil figure binary search trees node keys left subtree key keys subtree key binary search trees represent set values worst case running time search tree operations proportional height tree binary search tree nodes height efficient binary search tree height keys keys binary search tree stored satisfy binary search tree property node binary search tree node left subtree key key node subtree key key figure key root keys left subtree larger keys subtree smaller property holds node tree key figure smaller key left subtree larger key subtree binary search tree prope rty print keys binary search tree sorted order simple recursive algorithm called inorder tree walk algorithm named key root subtree printed values left subtree subtree preorder tree walk prints root values subtree postorder tree walk prints root lues subtrees procedure print elements binary search tree inorder tree walk root inorder tree walk nil inorder tree walk left print key inorder tree walk inorder tree walk prints keys binary search trees figure order correctness algorithm induction directly binary search tree property takes time walk node binary search tree initial procedure called recursively node treešonce left child child theorem formal proof takes linear time perform inorder tree walk theorem root node subtree inorder tree walk takes time proof denote time inorder walk called root node subtree inorder tree walk small constant time subtree test nil positive constant suppose inorder tree walk called node left subtree nodes subtree nodes time perform inorder tree walk positive constant reflects time execute inorder tree walk exclusive time spent recursive calls substitution method proving completes proof exercises set keys draw binary search trees height exercises difference binary searc tree property min heap property min heap property print keys node tree sorted order time explain exercises nonrecursive algorithm performs inorder tree walk hint easy solution stack auxiliary data structure complicated elegant solution stack assumes pointers tested equality exercises recursive algorithms perform preorder postorder tree walks time tree nodes exercises argue sorting elements takes lg time worst case comparison model comparison based algorithm onstructing binary search tree arbitrary list elements takes lg time worst case querying binary search tree common operation performed nary search tree searching key stored tree search operation binary search trees support queries minimum maximum successor predecessor examine operations supported time binary search tree height searching procedure search ode key binary search tree pointer root tree key tree search returns pointer node key exists returns nil tree search nil key return key return tree search left return tree search procedure search root traces path downward tree figure node encounters compares key key keys equal search terminates smaller key search continues left subtree binary search tree property implies stored subtree symmetrically larger key search continues subtree nodes encountered recursion form path downward root tree running time tree search height tree figure queries binary search tree search key tree follow path root minimum tree left pointers root maximum key pointers root successor node key node key minimum key subt ree node key subtree successor lowest ancestor left child ancestor case node key successor procedure written iterati vely unrolling recursion loop computers rsion efficient iterative tree search nil key key left return minimum maximum element binary search tree minimum left child pointers root nil encountered figure procedure returns pointer mini mum element subtree rooted node tree minimum left nil left return binary search tree property guarantees tree minimum correct node left subtree key subtree large key minimum key subtree rooted key node left subtree key subtree smaller key key left subtree larger key minimum key subtree rooted subtree rooted left pseudocode tree maximum symmetric tree maximum nil return procedures time tree height tree search sequence nodes encountered forms path downward root successor predecessor node binary search tree successor sorted order determined inorder tree walk keys distinct successor node node smallest key greater key structure binary search tree determine successor node comparing keys procedure returns successor node binary search tree exists nil largest key tree tree successor nil return tree minimum nil return code tree successor broken cases subtree node nonempty successor leftmost node subtree calling tree minimum successor node key figure node key hand exercise asks subtree node successor lowest ancestor left child ancestor figure successor node key node key simply tree encounter node left child parent accomplished lines œ7 tree successor running time tree successor tree height follow path tree follow path tree procedure tree predecessor symmetric tree succ essor runs time keys distinct define successor predecessor node node returned calls tree successor tree predecessor summary proved theorem theorem dynamic set operations search minimum maximum successor predecessor time binary sear tree height exercises suppose numbers binary search tree search number sequences sequence nodes examined exercises write recursive versions tree minimum tree maximum procedures exercises write tree predecessor procedure exercises professor bunyan thinks discovered remarkable property binary search trees suppose search key binary search tree ends leaf sets keys left search path keys search path keys search path professor bunyan claims keys satisfy smallest counterexample professor claim exercises node binary search tree children successor left child predecessor child exercises binary search tree keys distinct subtree node successor lowest ancestor left child ancestor recall node ancestor exercises inorder tree walk node binary search tree implemented finding minimum element tree tree minimum making calls tree successor prove algorithm runs time exercises prove matter node start height binary search tree successive calls tree successor time exercises binary search tree keys distinct leaf node parent key smallest key larger key largest key smaller key insertion deletion operations insertion deletion dynamic set represented binary search tree change data structure modifi reflect change binary search tree property continues hold modifying tree insert element straight orward handling deletion intricate insertion insert binary search tree procedure tree insert procedure passed node key left nil nil modifies fields inserted position tree tree insert nil root nil key key left nil root tree key key left figure tree insert works procedures tree search iterative tree search tree insert root tree traces path downward pointer traces path pointer maintained parent initialization loop lines œ7 pointers tree left depending comparison key key set nil nil occupies position place input item lines œ13 set pointers inserted figure inserting item key binary search tree lightly shaded nodes path oot position item inserted dashed link tree insert item primitive operations search trees procedure tree insert runs time tree height deletion procedure deleting node binary search tree takes argument pointer procedure considers cases figure children modify parent replace nil child node single child splice making link child parent finally node children splice successor left child exercise replace key satellite data key satellite data figure deleting node binary search tree node removed depends children node lightly shaded children remove child splice children splice successor child replace key satellite data key satellite data code tree delete organizes cases differently tree delete left nil nil tree successor left nil left nil nil root left left key key copy satellite data return lines œ3 algorithm determines node splice node input node child successor children lines œ6 set nil child nil children node spliced lines œ13 modifying pointers splicing complicated proper handling boundary conditions occur nil root finally lines œ16 successor node spliced key satellite data moved overwriting previous key satellite data node returned calling procedure recycle free list procedure runs time tree height summary proved theorem theorem dynamic set operations insert delete time binary search tree height exercises recursive version tree insert procedure exercises suppose binary search tree constructed repeatedly inserting distinct values tree argue number nodes examined searching tree number nodes examined lue inserted tree exercises sort set numbers building binary search tree numbers tree insert repeatedly insert numbers printing numbers inorder tree walk wh worst case case running times sorting algorithm exercises suppose data structure pointer node binary search tree suppose predecessor deleted tree procedure tree delete problem tree delete rewritten solve problem exercises operation deletion commutative sense deleting binary search tree leaves tree deleting argue counterexample exercises node tree delete children coul splice predecessor successor argued fair strategy equal priority predecessor successor yields empirical perf ormance tree delete changed implement fair strategy randomly built binary search trees basic operations binary search tree time height tree height binary search tree varies items inserted deleted items inserted strictly increasing order tree chain height hand exercise lg quicksort behavior average case closer case worst case average height binary search tree insertion deletion create tree created insertion analysis tractable define randomly built binary search tree keys arises inserting keys random order initially tree permutations input keys equally exercise asks notion assuming binary search tree keys equally expected height randomly built binary search tree keys lg assume keys distinct start defining random variables measure height randomly built binary search tree denote height randomly built binary search keys define exponential height build binary search tree keys choose key root denote random variable holds key rank set keys equally element set left subtree root randomly built binary search tree keys subtree randomly built binary search tree keys height binary tree larger heights subtrees root exponential height binary tree larger exponential heights subtrees root yn max yi yn base cases y1 exponential height tree node convenience define y0 define indicator random variables zn zn zn zn equally element lemma zn yn polynomial ultimately imply lg indicator random variable zn independent values yi yn chosen left subtree exponential height yi randomly built keys ranks subtree randomly built binary search tree keys number keys subtree structure choice random variables yi zn independent likewise subtree exponential height yn randomly built keys ranks greater structure independent random variables yn zn independent term y0 y1 yn appears summation yi yn recurrence substitution method positive integers recurrence solution identity exercise asks prove identity base case verify bound holds substitution bounded yn ultimate goal bound exercise asks function convex apply jensen inequality derive logarithms sides lg proven theorem expected height randomly built binary search tree keys lg exercises prove equation exercises binary search tree nodes average depth node tree lg height tree lg asymptotic upper bound height node binary search tree average depth node lg exercises notion randomly chosen binary search tree keys binary search tree keys equally chosen notion randomly built binary search tree hint list possibilities exercises function convex exercises randomized quicksort operating sequence input numbers prove constant nk input permutations yield lg running time problems binary search trees equal keys equal keys pose problem imple mentation binary search trees asymptotic performance tree insert insert items identical keys ini tially binary search tree propose improve tree insert sting key key testing key key equality holds implement strategies strategy asymptotic performance inserting items identical keys initially binary search tree strategies compare keys substitute arrive strategies boolean flag node set left based alternates false true time visited insertion node key list nodes equal keys insert list randomly set left worst case performance informally derive average case performance problems radix trees strings a0a1 b0b1 bq ai ordered set characters string lexicographically string exists integer min ai ai bit strings rule letting rule orde ring english language dictionaries radix tree data structure figure stores bit strings searching key a0a1 left node depth ai ai set distinct binary strings lengths sum radix tree sort lexicographically time figure output sort sequence figure radix tree storing bit strings node key determined traversing path root node store keys nodes keys illustrative purposes nodes heavily shaded keys tree nodes establish path nodes problems average node depth randomly built binary search tree problem prove average pth node randomly built binary search tree nodes lg result weaker theorem technique reveals surprising simila rity buildin binary search tree running randomized quicksort define total path length binary tree sum nodes depth node denote argue average depth node expected lg denote left subtrees tree argue nodes denote average total path length randomly built binary search tree nodes rewritten recalling alternative analysis randomized version quicksort problem conclude lg recursive invocation quicksort oose random pivot element partition set elements sorted node binary search tree partitions set elements fall subtree rooted node implementation quicksort comparisons sort set elements comparis ons insert elements binary search tree order comparisons differ comparisons problems number binary trees denote number binary trees nodes problem formula asymptotic estimate b0 referring problem definition generating function generating function xb express closed form taylor expansion point kth derivative evaluated nth catalan number taylor expansion taylor expansion generalization binomial expansion nonintegral exponents real number integer interpret chapter notes knuth good discussion simple binary search trees variations binary search trees independently discovered number people late radix trees ofte called middle letters word retrieval discussed knuth construct optimal binary search tree search frequencies prior constructing tree frequencies searching key frequencies sear ching values fall keys tree construct binary search tree set searches frequencies examines minimum number nodes proof bounds expected height randomly built binary search tree aslam mart nez roura randomized algorithms insertion deletion binary search trees result eith operation random binary search tree definition random nary search tree differs randomly built binary search chapter chapter red black trees chapter binary search tree height implement basic dynamic set operationsšsuch search predecessor successor minimum maximum insert deletešin time set operations fast height search tree small ight large performance linked list red black trees search tree schemes balanced order guarantee basic dynamic set operations lg time worst case properties red black trees red black tree binary search tree extra bit storage node color red black constraining nodes colored path root leaf red black trees ensure path long tree balanced node tree fields color key left child parent node exist pointer field node nil regard pointers extern nodes leaves binary search tree normal key bearing nodes internal nodes tree binary search tree red black tree satisfies red black properties node red black root black leaf nil black node red children black node paths node scendant leaves number black nodes figure red black tree figure red black tree black nodes darkened red nodes shaded node red black tree red black children red node black simple path node descendant number black nodes leaf nil black nil node marked black height nil black height red black tree nil replaced single sentinel nil black black heights root parent sentinel red black tree leaves root parent drawing styl remainder chapter matter convenience dealing boundary conditions red black tree code single sentinel represent nil red black tree sentinel nil object fields ordinary node tree color field black fieldsšp left keyšcan set arbitrary values figure pointers nil pointers sentinel nil sentinel treat nil child node ordinary node parent add distinct sentinel node nil tree parent nil defined approach waste space sentinel nil represent nil sšall leaves root parent values fields left key sentinel immaterial set procedure convenience generally confine internal nodes red black tree hold key values remainder chapter omit leaves draw red black trees figure number black nodes path including node leaf black height node denoted bh property notion black height defined descending paths node number black nodes define black height red black tree black root lemma red ack trees good search trees lemma red black tree internal nodes height lg proof start showing subtree rooted node bh internal nodes prove aim induction height height leaf nil subtree rooted bh internal nodes inductive step node positive height internal node children ild black height bh bh depending color red black height child height apply inductive hypothesis conclude child bh internal nodes subtree rooted bhbh bh internal nodes proves claim complete proof lemma height tree property half nodes simple path oot leaf including root black black height root moving left hand logarithms sides yields lg lg consequence lemma dynamic set operations search minimum maximum successor predecessor implemented lg time red black trees time search tree height chapter red black tree nodes search tree height lg references nil algorithms chapter replaced nil algorithms tree insert tree delete chapter lg time red black tree input directly support dynamic set operations insert delete guarantee modified binary search tree red black tree sections operations supported lg time exercises style figure draw complete binary search tree height keys add nil leaves color nodes ways black heights red black trees exercises draw red black tree ter tree insert called tree figure key inserted node colored red tree red black tree colored black exercises define relaxed red black tree binary search tree satisfies red black properties root red black relaxed red black tree root red color root black tree red black tree exercises suppose absorb red node red black tree black parent children red node children black parent ignore keys degr ees black node red children absorbed depths leaves tree exercises longest simple path node red black tree descendant leaf length shortest simple path node descendant leaf exercises largest number internal nodes red black tree black height smallest number exercises red black tree keys realizes largest ratio red internal nodes black internal nodes ratio tree smallest ratio ratio rotations search tree operations tree insert tree delete red black tree keys lg time modify tree result violate red black properties enumerated restore properties change colors node tree change pointer structure change pointer structure rotation local operation search tree preserves binary search tree property figure kinds rotations left rotations rotations left rotation node assume child nil node tree child nil left rotation pivots link root subtree left child left child child figure rotation operations binary search tree operation left rotate transforms configuration nodes left configuration changing constant number pointers configuration transformed confi guration left inverse operation rotate letters represent arbitrary subtrees rotation operation preserves binary search tree property keys precede key precedes keys precede key precedes keys pseudocode left rotate assumes nil root parent nil left rotate set left turn left subtree subtree left link parent nil root left left left left figure left rotate operates code rotate symmetric left rotate rotate time pointers changed rotation fields node remain figure procedure left rotate modifies binary search tree inorder tree walks input tree modified tree produce listing key values exercises write pseudocode rotate exercises argue node binary search tree rotations exercises arbitrary nodes subtrees left tree figure depths change left rotation performed node figure exercises arbitrary node binary search tree transformed arbitrary node binary search tree rotations hint rotations suffice transform tree chain exercises binary search tree converted binary search tree series calls rotate trees converted tree converted converted calls rotate insertion insertion node node red black tree accomplished lg time modified version tree insert procedure insert node tree ordinary binary search tree color red guarantee red black properties pre served auxiliary procedure rb insert fixup recolor nodes perform rotations rb insert inserts node key field assumed filled red black tree rb insert nil root nil key key left nil root key key left left nil nil color red rb insert fixup differences proced ures tree insert rb insert instances nil tree insert replaced nil set left nil lines œ15 rb insert order intain proper tree structure color red fourth coloring red violation red black properties rb insert fixup rb insert restore red black properties rb insert fixup color red left color red color black case color black case color red case case case left rotate case color black case color red case rotate case clause left exchanged color root black understand rb insert fixup works break examination code major steps determine violations red black properties introduced rb insert node inserted colored red examine goal loop lines œ15 finally explore cases loop broken accomplish goal figure rb insert fixup operates sample red black tree figure operation rb insert fixup node insertion parent red violation property occurs uncle red case code applied nodes recolored pointer moved tree tree parent red uncle black child case applied left rotation performed tree left child parent case applied rotation yields tree legal red black tree red black properties violated rb insert fixup property continues hold property children newly inserted red node sentinel nil property number black nodes path node satisfied node replaces black sentinel node red sentinel children properties violat property requires root black property red node red child violations colored red property violated root property violated parent red figure violation property node inserted loop lines œ15 intains invariant start iteration loop node red root black violation red black properties violation property property violation property occurs root red violation property occurs red deals violations red black properties central showing rb insert fixup restores black properties understand situations code focusing node nodes tree helpful red node exists reference lines recall loop invariant true prior iteration loop iteration maintains loop invariant loop invariant property loop termination start initialization termination arguments examine body loop works gue loop maintains invariant iteration demons trate outcomes iteration loop pointer moves tree rotations performed loop terminates initialization prior iteration loop started red black tree violations red node invariant holds time rb inse fixup called rb insert fixup called red node root started black change prior rb insert fixup properties hold rb insert fixup called violation property red root newly node internal node tree parent children sentinel black violation property violation property violation red black properties entire tree violation property children node black sentinels tree violations prior violation red violations red black properties termination loop terminates black root sentinel nil black violation property loop termination loop nvariant property fail hold property restores property rb insert fixup terminates red black properties hold maintenance cas loop symmetric depending parent left child child grandparent determined code situation left child node exists loop invariant root black enter loop iteration red root exists case distinguished cases color parent sibling uncle point uncle test red case executed control passes cases cases grandparent black parent red property violated case uncle red figure situation case lines œ8 case executed red black color black fixing problem red color red maintaining property repeat loop node pointer moves levels tree figure case procedure rb insert property violated parent red action child left child subtrees black root black height code case colors node preserving property downward paths node leaf ha number blacks loop continues node grandparent violation property occur red parent red case maintain loop invariant start iteration denote node current iteration denote node test iteration iteration colors red node red start iteration node iteration color node change node root black prior iteration remains black start iteration argued case main tains property introduce violation properties node root start iteration case corrected lone violation property iteration red root property violat violation node root start iteration case created violation property case corrected lone violation property existed start iteration red left black violation property red coloring red created violation property case uncle black child case uncle black left child cases color uncle black cases distinguished left child lines œ11 constitute case figure case case node child parent left rotation transform situation case lines œ14 node left child red rotation black height nodes property enter case directly case uncle black execute case additionally node exists argued node existed time lines executed moving level level identity remains unchanged case execute color anges rotation preserve property longer red nodes row body loop executed time black figure cases procedure rb insert case property violated case case parent red subtrees black root property case black height transformed case left rotation preserves property downward paths node leaf number blacks case color anges rotation preserve property loop terminates property satisfied longer red nodes row cases maintain loop invariant argued black test loop body execute case point red change color occurs cases case black root start iteration black case properties maintained cases node root cases violation property cases introduce violation property node red child black node rotation case cases correct lone violation property intro duce violation iteration loop main tains invariant rb insert fixup correctly restor red black properties analysis running time rb insert height red black tree nodes lg lines œ16 rb insert lg time rb insert fixup loop repeats case executed pointer moves levels tree total number times loop executed lg rb insert takes total lg time interestingly performs rotations loop terminates case case executed exercises rb insert set color newly inserted node red notice chosen set color black property red black tree violated choose set color black exercises red black trees result successively inserting keys initially red black tree exercises suppose black height subtrees figures label node figure black hei ght verify property preserved transformation exercises professor teach concerned rb insert fixup set color nil red case test loop terminate root professor concern unfounded arguing rb insert fixup sets color nil red exercises red black tree formed inserting nodes rb insert argue tree red node exercises implement rb insert efficiently representation red black trees includes storage parent pointers case falls case cases mutually exclusive deletion basic operations node red black tree deletion node takes time lg deleting node red ack tree complicated inserting node procedure rb delete minor modi fication tree delete procedure splicing node calls auxiliary procedure rb delete fixup colors performs rotati ons restore red black properties rb delete left nil nil tree successor left nil left nil root left left key key copy satellite data color black rb delete fixup return differences procedures tree delete rb delete references nil tree delete replaced references sentinel nil rb delete test nil tree delete removed assignment performed unconditionally rb delete sentinel nil parent pointer points parent spliced node rb delete fixup lines œ17 black red red black properties hold spliced reasons black heights tree changed red nodes adjacent root red root remains black node passed rb delete fixup nodes node sole child spliced child sentinel nil children sentinel nil case unconditional assignment guarantees parent node parent key bearing internal node sentinel nil examine procedure rb delete fixup restores red black properties search tree rb delete fixup root color black left color red color black case color red case left rotate case case color left black color black color red case case color black color left black case color red case rotate case case color color case color black case color black case left rotate case root case clause left exchanged color black spliced node rb delete black problems root red child root ha violated property red violated property removal path contained fewer black node property violated ancestor tree correct problem node extra black add count black nodes path interpretation property holds splice black node push blackness child problem node red black violating property node doubly black red black contributes count black nodes paths color attribute red red black black doubly black extra black node reflected pointing node color attribute procedure rb delete fixup restores properties exercises procedure restores properties remainder focu property goal loop lines œ22 extra black tree points red black node case color singly black points root case extra black simply removed suitable rotations reco lorings performed loop points nonroot doubly black node determine left child child parent code situation left child situation childšline šis symmetric maintain pointer sibling node doubly black node nil number blacks path singly black leaf smaller number path cases code illustrated figure examining case generally verify transformation cases preserves property key idea case number black nodes including extra black including root subtree subtrees preserved transformation hus property holds prior transformation continues hol afterward figure illustrates case number black nodes root subtree transformati remember node adds extra black number black node root transformation figure counting involve color attribute root subtree red black define count red count black number black nodes root count transformati case transformation node color attribute node red black red doubly black black cases verified exercise figure cases loop procedure rb delete fixup darkened nodes color attributes black heavily shaded nodes color attributes red lightly shaded nodes color attributes represented red black letters represent arbitrary subtrees case configuration left transformed configurati changing colors performing rotation node pointed extra black doubly black red black case loop repeat case case transformed case exchanging colors nodes performing left rotation case extra black represented pointer moved tree coloring node red setting point node enter case case loop terminates node red black color attribute red case transformed case exchanging colors nodes performing rotation case extra black represented removed changing colors performing left rotation wit hout violating red black properties loop terminates case sibling red case lines œ8 rb delete fixup figure occurs node sibling node red black children switch colors perform left rotation violating red black properties sibling children prior rotation black converted case case cases occur node black distinguished colors children case sibling black children black case lines œ11 rb delete fixup figure children black black black leaving black leaving red compensate removing black add extra black originally red black repeating loop node observe enter case case node red black original red color attribute node red loop terminates tests loop condition node colored singly black case sibling black left child red child black case lines œ16 figure occurs black left child red child black switch colors left child left perform rotation violating red black properties sibling black node red child transformed case case case sibling black child red case lines œ21 figure occurs node sibling black child red making color cha nges performing left rotation remove extra black making singly black violating red black properties setting root loop terminate tests loop condition analysis running time rb delete height red black tree nodes lg total cost procedure rb delete fixup takes lg time rb delete fixup cases terminate performing constant number color ree rotations case case loop repeated pointer moves tree lg times rotations performed procedure rb delete fixup takes lg time performs rotations time rb delete lg exercises argue executing rb delete fixup root tree black exercises argue rb delete red property restored rb delete fixup exercises exercise red black tree resu lts successively inserting keys initially red black trees result successive deletion keys order exercises lines code rb delete fixup examine modify sentinel nil exercises cases figure count black nodes root subtree subtrees verify count remains transformation node color attribute notation count count symbolically count exercises professors skelton baron concerne start case rb delete fixup node black profe ssors correct lines œ6 wrong black start case professors worry exercises suppose node inserted red black tree rb insert deleted rb delete red ack tree initial red black tree justify answer problems persistent dynamic sets algorithm maintain versions dynamic set upda ted set called persistent implement persistent set copy entire set modifi approach slow program consume space persistent set operations insert delete search implement binary earch trees figure maintain separate root version set order insert key set create node key node left child node key modify existing node key node key left child node key child existing node key node key turn child root key left child existing node key copy tree share nodes original tree figure figure binary search tree keys persistent binary search tree insertion version set consists nodes reachable root previous version consists nodes reachable heavily shaded nodes adde key inserted assume tree node fields key left parent field exercise general persistent binary search tree identify nodes changed insert key delete node write procedure persistent tree inse persistent tree key insert returns persistent tree result inserting height persistent binary search tree time space requirements implementation persistent tree insert space requirement proportional number nodes allocated suppose included parent field node case persistent tree insert perform additional copying prove persistent tree insert require time space number nodes tree red black trees guara ntee worst case running time space lg insertion deletion problems join operation red black trees join operation takes dynamic sets s1 element s1 key key key returns set s1 problem investigate implemen join operation red black trees red black tree store black height field bh argue field maintained rb insert rb delete requiring extra storage nodes tree increasing asymptotic running times descending determine black height node visit time node visited implement operation rb join destroys returns red black tree total number nodes assume bh bh lg time algorithm finds black node largest key nodes black height bh ty subtree rooted ty replace ty time destroying binary search tree property color red black properties maintained properties enforced lg time argue generality lost making assumption symmetric situation arises bh bh argue running time rb join lg problems avl trees avl tree binary search tree height balanced node heights left subtrees differ implement avl tree maintain extra field node height node binary search tree assume root points root node prove avl tree nodes height lg hint prove avl tree height fh nodes fh hth fibonacci number insert avl tree node place binary search tree order insertion tree longer height balanced heights left children node differ procedure balance takes subtree rooted left children height balanced heights differ left alters subtree rooted height balanced hint rotations recursive procedure avl insert takes node avl tree newly created node key filled adds subtree rooted maintaining property root avl tree tree insert assume key filled left nil nil assume insert node avl tree avl insert root node avl tree avl insert operation lg rotations performed problems treaps insert set items binary search tree tree horribly unbalanced leading long search times randomly built binary search trees tend balanced strategy average builds balanced tree fixed set items ndomly permute items insert order tree items receive items time randomly build binary search tree examine data structure answ ers question affirmative treap binary search tree modi fied ordering nodes figure usual node tree key key addition assign priority random number chosen independently node assume priorities distinct keys distinct nodes treap ordered keys obey binary search tree property priorities obey min heap order property left child key key child key key child priority priority figure treap node labeled key priority root key priority combination properties tree called treap features binary search tree heap helps treaps suppose insert nodes keys treap treap tree formed nodes inserted normal nary search tree order randomly chosen priorities priority priority inserted set nodes keys priorities distinct unique treap nodes expected height treap lg time search treap lg insert node existing treap thing assign node random priority insertion algorithm treap insert operation illustrated figure figure operation treap insert original treap prior insertion treap inserting node key priority œ intermediate stages inserting node key priority treap insert ion parts treap inserting node key priority explain treap insert works xplain idea english pseudocode hint execute usual binary search tree insertion procedure perform rotations restore min heap order property expected running time treap insert lg treap insert performs search sequence rotations operations expected running time costs practice search reads treap modifying contrast rotation parent child pointers treap computers read operations faster write operations treap insert perform rotations expected number rotations performed bounded constant order definitions illustrated figure left spine binary search tree path root node smallest key left spine path root consists left edges symmetrically spine path root consisting edges length spine number nodes figure spines binary search tree left spine shaded spine shaded treap inserted treap insert length spine left subtree length left spine subtree prove total number rotations performed insertion equal calculate expected values loss generality assume keys comparing nodes key key define indicator random variables spine left subtree priority priority key key key key key priority priority symmetry argument conclude expected number rotations performed inserting node treap rb insert fixup cases rb delete fixup mutually exclusive chapter notes idea balancing search tree adel son vel ski landis introduced class balanced search trees called avl trees problem class search trees called trees introduced hopcroft unpublished balance maintained tree manipula ting degrees nodes tree generalization trees introduced bayer mccreight called trees topic chapter red black trees invented bayer symmetric binary trees guibas sedgewick studied properties length introduced red black color convention andersson simpler code variant red black trees weiss calls variant aa trees aa tree sim ilar red black tree left children red treaps proposed seidel aragon default implementation dictionary leda imple mented collection data structures algorithms variations balanced binary trees including weight balanced trees neighbor trees scapegoat trees intriguing splay trees introduced sleator tarjan adjusting good description splay trees tarjan splay trees maintain balance explicit balance condition color splay operations involve rotations performed tree time access amortized cost chapter operation node tree lg skip lists alternative bala nced binary trees skip li linked list augmented number additional pointers dictionary operation runs expected time lg skip list items chapter augmenting data structures engineering situations requi textbook data structureš doubly linked list hash table binary search treešbut require dash creativity rare situations create type data structure suffice augment text book data structure storing additional program operations data structure support desired application augmenting data structure straightforward updated maintained ordinary operations data structure chapter discusses data structures constructed augmenting red black trees describes data structure supports general order statistic operations dynamic set ith smallest number rank element total ordering set abstracts proc ess augmenting data structure theorem simplify augmentation red black trees theorem design data structure maintaining dynamic set intervals time intervals query interval interval set overlaps dynamic order statistics chapter introduced notion order statistic ith order statistic set elements simply element set ith smallest key order statistic retrieved time unordered set red black trees modified order statistic determined lg time rank elementšits position linear order setšcan likewise determined lg time data structure support fast order statistic operations figure order statistic tree simply red black tree additional stored node usual red black tree fields key color left node field size field numb internal nodes subtree rooted including size subtree define sentinel size set size nil identity size size left size figure order statistic tree augmented red black tree shaded nodes red darkened nodes black addition usual fields node field size number nodes subtree rooted require keys distinct order statistic tree tree figure keys keys presence equal keys notion rank defined remove ambiguity order statistic tree defining rank element position printed inorder walk tree figure key stored black node rank key stored red node rank retrieving element rank maintain size formation insertion deletion examine implementation order statistic queries additional operation retrieves element rank procedure select returns pointer node ith smallest key subtree rooted ith smallest key order statistic tree select root select size left return elseif return select left return select œ idea select selection algorithms chapter size left number nodes inorder tree walk subtree rooted size left rank subtree rooted select compute rank node subtree rooted node ith smallest element return ith smallest element left subtree recurse left ith smallest element subtree elements subtree rooted subtree inorder tree walk ith smallest element subtree rooted œ smallest element subtree rooted element determined recursively select operates search smallest element order statistic tree figure root key size left subtree rank node rank smallest element subtree recursive node key size left subtree rank subtree node rank smallest element left subtree recursive node key rank subtree recurse smallest element subtree rooted node key left subtree size smallest element pointer node key returned procedure recursive level order statistic tree total time select worst proportional height tree tree red black tree height lg number nodes hus running time select lg dynamic set elements determining rank element pointer node order statistic tree procedure rank returns position linear order determined inorder tree walk rank size left root size left return procedure works rank viewed number nodes preceding inorder tree walk rank maintains loop invariant start iteration loop lines œ6 rank key subtree rooted node loop invariant rank works correctly initialization prior iteration sets rank key subtree rooted setting invariant true time test executes maintenance iteration loop set rank key subtree rooted start loop body rank key subtree rooted loop body iteration loop subtree rooted counted number nodes subtree rooted node precede inorder walk add nodes subtree rooted sibling precede inorder walk precedes left child node subtree precedes leave child nodes left subtree precede add size left current termination loop terminates root subtree rooted entire tree rank key entire tree rank order statistic tree figure rank node key sequence values key loop iteration key rank returned iteration loop takes time level tree iteration running time rank worst proportional height tree lg node order statistic tree maintaining subtree sizes size field node select rank compute order statistic fields efficiently maintained basic modifying operations red black trees rk naught subtree sizes maintained insertion deletion asymptotic running time operation insertion red black tree consists phases phase tree root inserti node child existing node phase tree changing colors ultimately performing rotations maintain red black properties maintain subtree sizes phase simply increment size node path traversed root leaves node size lg nodes traversed path additional cost maintaining size fields lg phase structural underlying red black tree caused rotations rotation local operat ion nodes size fields invalidated link rotation performed incident nodes referring code left rotate add lines size size size size left size figure illustrates fields update change rotate symmetric figure updating subtree sizes rotations link rotation performed incident nodes size fields updated updates local requiring size stored roots subtrees triangles rotations performed dur ing insertion red black tree additional time spent updating size fields phase total time insertion node order statistic tree lg asymptotically ordinary red black tree deletion red black tree consists phases operates underlying search tree rotations performs structural phase splices node update subtree sizes simply traverse path node root decrementing size field node path path length lg node red black tree additional time spent maintaining size fields phase lg rotations phase deletion handled manner insertion insertion deletion including maintenance size fields lg time node order statistic tree exercises select operates red black tree figure exercises rank operates red black tree figure node key exercises write nonrecursive version select exercises write recursive procedure key rank takes input order statistic tree key returns rank dynamic set represented assume keys distinct exercises element node order statistic tree natural number ith successor linear order tree determined lg time exercises observe size field node referenced select rank compute rank node subtree rooted node suppose store node rank subtree root maintained insertion deletion remember operations rotations exercises order statistic tree count number inversions problem array size time lg exercises chords circle define endpoints lg time algorithm determining number pairs hords intersect inside circle chords diameters meet center correct answer assume chords share endpoint augment data structure process augmenting basic data struct ure support additional functionality occurs frequently algorithm design design data structure supports operations intervals examine steps involved augmentation ove theorem augment red black trees easily cases augmenting data structure broken steps choosing underlying data structure determining additional main tained underlying data structure verifying additional maintained basic modifying operations underlying data structure developing operations prescriptive design method shoul blindly follow steps order design work element trial rror progress steps proceeds parallel point determining additional developing operations steps maintain additional efficiently nevert heless step method good focus efforts augmenting data struct ure good organize documentation augmented data structure steps design order statistic trees step chose red black trees underlying data structure clue suitability red black trees efficient support dynamic set operations total order minimum maximum successor predecessor step provided size field node stores size subtree rooted generally additional operations efficient implemented select rank keys stored tree lg time additional pointer data exercise step ensured insertion deletion maintain size fields running lg time ideally elements data structure updated order maintain additional inform ation simply stored node rank tree select rank procedures inserting minimum element change node tree store subtree sizes inst ead inserting element change lg nodes step developed operations select rank operations bother augment ta structure place occasionally developing operations additional expedite existing exercise augmenting red black trees red black trees underlie augmented data structure prove kinds additional efficiently maintained insertion deletion making step easy proof follo wing theorem argument size field maintained order statistic trees theorem augmenting red black tree field augments red black tree nodes suppose contents node computed nodes left including left maintain values nodes insertion deletion asymptotically lg performance operations proof main idea proof change field node propagates ancestors tree changing require updated updating require updated tree root updated node depends process terminates height red black tree lg changing field node costs lg time updating nodes dependent change insertion node consists phases phase inserted child existing node computed time supposition depends fields children children sentinel nil computed change propagates tree total time phase insertion lg phase structural tree rotations nodes change rotation total time updating fields lg rotation number rota tions insertion total time insertion lg insertion deletion phases phase tree occur deleted node replaced successor deleted node successor spliced propagating updates caused costs lg modify tree locally fixing red black tree phase requires rotati ons rotation requires lg time propagate updates insertion total time deletion lg cases maintenance size fields order statistic trees cost updating rotation lg derived proof theorem exercise exercises dynamic set queries mi nimum maximum successor predecessor supported worst case time augmented order statistic tree asymptotic performance operations order statistic trees hint add pointers nodes exercises black heights nodes red black tree maintained fields nodes tree asympt otic performance red black tree operations argue exercises depths nodes red black tree efficiently maintained fields nodes tree argue exercises associative nary operator field maintained node red black tree suppose include node additional field xm xm inorder listing nodes subtree rooted fields properly updated time rotation modify argument size fields order statistic trees maintained time rotation exercises augment red black ees operation rb enumerate outputs keys red black tree rooted rb enumerate implemented lg time number keys output number internal nodes tree hint add fields red black tree interval trees augment red black trees support operations dynamic sets intervals closed interval ordered pair real numbers interval represents set open half open intervals omit endpoints set resp ectively assume intervals closed extending open half open intervals conceptually straightforward intervals convenient representing events occupy continuous period time query databa time intervals events occurred interval data structure efficient maintaining interval database represent interval object fields low low endpoint high high endpoint intervals overlap ø low high low high intervals satisfy interval trichotomy properties holds overlap left high low high low figure possibilities figure interval trichotomy closed intervals overlap situations low high low high intervals overlap high low intervals overlap high low interval tree red black tree maintains dynamic set elements element interval int interval trees support operations interval insert adds element int field assumed interval interval tree interval delete removes element interval tree interval search returns pointer element interval tree int overlaps interval sentinel nil element set figure interval tree represents set intervals track step method review design interval tree operations figure interval tree set intervals sorted left endpoint interval tree represents inorder tree walk tree lists nodes sorted order left endpoint step underlying data structure choose red black tree node interval int key low endpoint low int interval inorder tree walk data structure lists intervals sorted order low endpoint step additional addition intervals node max maximum interval endpoint stored subtree rooted step maintaining verify insertion deletion performed lg time interval tree nodes determine max interval int max values node children max max high int max left max theorem insertion deletion lg time fact updating max fields rotation accomplished time exercises step developing operations operation interval search finds node tree interval overlaps interval interval overlaps tree pointer sentinel nil returned interval search root nil overlap int left nil max left low left return search interval overlaps starts root tree proceeds downward terminates overlapping interval points sentinel nil iteration basic loop takes time height node red black tree lg interval search procedure takes lg time interval search correct examine works interval tree figure suppose interval overlaps interval root overlap max left greater low loop continues left child rootšthe node overlap time max left low loop continues child interval stored node overlaps procedure returns node unsuccessful search suppose interval overlaps interval tree figure root root interval overlap max left greater low left node note interval subtree overlaps išwe interval overlap max left low note interval left subtree overlaps interval overlap left child nil loop terminates sentinel nil returned interval search correct understand suffices examine single path root basic idea node int overlap search proceeds safe direction overlapping interv tree theo rem states property precisely theorem execution interval search returns node interval overlaps returns nil tree node interval overlaps proof loop lines œ5 terminates nil overlaps int case correct return focus case loop terminates nil invariant loop lines œ5 tree interval overlaps interval subtree rooted loop invariant initialization prior iteration sets root invariant holds maintenance iteration loop executed loop invariant maintained case executed branch condition left nil max left low left nil subtree rooted left interval overlaps setting maintains invariant suppose left nil max left low figure interval left subtree high max left low figure intervals proof theorem max left case dashed search interval left subtree overlap search left left subtree interval overlaps situation interval left subtree high max left overlap overlap interval subtree low low interval trichotomy overlap left subtree intervals overlap setting maintains invariant hand executed contrapositive loop invariant holds interval overlapping subtree rooted left interval overlapping tree executed branch condition max left low definition max field interval left subtree high max left low figure illustrates situation overlap true high low interval trichotomy high low interval trees keyed low endpoints intervals search tree property implies interval subtree high low low interval trichotomy overlap concl ude interval left subtree overlaps setting left maintains invariant termination loop terminates nil interval overlapping subtree rooted contrapositive loop invariant implies interval overlaps correct return nil interval search procedure works correctly exercises write pseudocode left rotate operate nodes interval tree updates max fields time exercises rewrite code interval search works properly intervals assumed open exercises efficient algor ithm interval returns interval overlapping minimum low endpoint nil interval exists exercises interval tree interval intervals overlap listed min lg time number inte rvals output list optional solution modify tree exercises modifications interval procedures support operation interval search returns pointer node interval tree low int low high int high nil node operations including interval search lg time node tree exercises maintain dynamic set numbers supports operation min gap magnitude diffe rence closest numbers min gap returns closest numbers operations insert delete search min gap efficient alyze running times exercises vlsi databases commonly represen integrated circuit list rectangles assume rectangle rectilinearly iented sides parallel axis representation rectangle consists minimum maximum coordinates lg time algorithm decide set rectangles represented rectangles ove rlap algorithm port intersecting pairs report overlap exists ctangle covers boundary lines intersect hint sweep set rectangles problems point maximum overlap suppose track point maximum overlap set intervalsša point largest number intervals database overlapping point maximum overlap whic endpoint segments design data structure efficiently supports operations interval insert interval delete pom turns point maximum overlap hint red black tree endpoints associate left endpoint associate endpoint augment node tree extra maintain point maximum overlap problems josephus permutation josephus problem defined suppose people arranged circle positive integer designated person proceed circle removing mth person person removed counting continues circle remains process continues people removed order people removed circle defines josephus permutation integers josephus permutation suppose constant time algorithm integer outputs josephus permutation suppose constant lg time algorithm integers outputs josephus permutation chapter notes book preparata shamos interval trees literature citing work edelsbrunner mc creight book details interval tree wh ich static database intervals intervals overlap query interval enumerated lg time advanced design analysis techniques chapter list chapter dynamic programming chapter greedy algorithms chapter amortized analysis introduction covers techniques design analysis efficient algorithms dynamic programming chapter greedy algorithms chapter amortized analysis chapter earlier parts presented applicable techniques divide conquer randomization solution recurrences techniques sophisticated effectively attacking computational problems themes introduced recur book dynamic programming typically plies optimization problems set choices order arri optimal solution choices subproblems form dynamic programmi effective subproblem partial set choices key technique store solution subproblem case reappear chapter simple idea transform exponential time gorithms polynomial time algorithms dynamic programming algorithms greedy gorithms typically apply optimization problems set choices order arrive optimal solution idea greedy algorithm choice locally optimal manner simple coin changing minimize number coins needed change suffices select repeatedly largest denomination coin larger owed problems greedy approach optimal solution dynamic programming approach easy whethe greedy approach effective chapter reviews matroid theory helpful making determination amortized analysis tool analyzing gorithms perform sequence operations bounding cost sequence operations bounding actual cost operation separately amortized analysis provide bound actual cost entire sequence reason idea effective impossible sequence operations individual operations worst case time bounds operati ons expensive cheap amortized analysis analys tool thinking design algorithms design algorithm analysis running time closely intertwined chapter introduces ways perform amortized analysis algorithm chapter dynamic programming overview dynamic programming divide conq uer method solves problems combining solutions subproblems programming context refers tabular method writing computer code chapter divide conquer algorithms partition problem independent subproblems lve subproblems recursively combine solutions solve original problem contrast dynamic programming applicable subproblems ndependent subproblems share subsubproblems context divide conquer algorithm doe work repeatedly solving common subsubproblems dynamic programming algorithm solves subsubproblem saves answer table avoiding work recomputing answer time subsubproblem encountered dynamic programming typically applied optimization problems problems solutions ach solution solution optimal minimum maximum solution optimal solution problem opposed optimal solution solutions achieve optimal development dynamic programming algor ithm broken sequence steps characterize structure optimal solution recursively define optimal solution compute optimal solution fashion construct optimal solution computed steps œ3 form basis dynamic programmi solution problem step optimal solution required perform step maintain additional dur ing computation step ease construction optimal solution sections follow dynamic ogramming method solve optimization problems examines problem scheduling automobile assembly lines station auto construc tion stay asks multiply chain matrices fewest total scalar multiplications performed ven examples dynamic programming discusses key characteristics problem dynamic programming viable solution technique longest common subsequence sequences finally dynamic programming construct binary search trees optimal distribution keys looked assembly scheduling dynamic programming solv manufacturing problem colonel motors corporation produces automobiles factory assembly lines figure automobile chassis enters asse mbly parts number stations finish auto exits assembly stations numbered denote jth station jth station s1 performs function jth station stations built times technol ogies time required station varies stations position lines denote assembly time required station ai figure chassis enters station assembly lines progresses station entry time chassis enter assembly exit time completed auto exit assembly figure manufacturing problem fastest factory assembly lines stations jth station denoted assembly time station ai automobile chassis enters factory time jth station chassis station transfer cost stays takes time transfer station exiting nth station takes time completed auto exit factory problem determine stations choose choose order minimize total time ctory auto chassis enters assembly lin passes time station assembly negligible occasionally special rush order customer automobile manufactured rush orders chassis passes stations order factory manager switch partially completed auto assembly station time tran sfer chassis assembly station nth station assembly complete problem determine stations choose choose order mini mize total time thr ough factory auto figure fastest total time choosing stations stations figure instance assembly problem costs ai heavily shaded path indi cates fastest factory values li instance obvious brute force minimizing time factory infeasible stations list stations easy compute time long takes chassis pass factory ways choose stations viewing set stations subset noting subsets determining fastest rough factory enumerating ways computing long takes requiren time infeasible large step structure fastest factory step dynamic programming paradi gm characterize structure optimal solution assembly scheduling problem perform step fastest chassis starting point station s1 chassis easy determine long ta kes station s1 choices chassis station s1 directly station s1 time station station negligible alternatively chassis coul station transferred station s1 transfer time possibilities separately common suppose fastest station s1 station s1 key observation chassis fastest starting point station s1 fast station s1 substitute faster yield faster station s1 contradiction suppose fastest station s1 station observe chassis ta ken fastest starting point station reasoning faster station substitute faster yield faster station s1 contradiction generally asse mbly scheduling optimal solution problem finding fastest station optimal solution subproblems finding fastest s1 refer property optimal substructure hallmarks pplicability dynamic programming optimal substructure construct optimal solution problem optimal solutions subproblems ssembly scheduling reason fastest station s1 station fastest station s1 fastest station s1 directly station s1 fastest station transfer station s1 symmetric reasoning fastest station fastest station directly station fastest station s1 transfer station solve problem finding fastest station solve subproblems finding fastest ways station lines build optimal solution instance assembly scheduling problem building optimal solutions subproblems step recursive solution step dynamic programming paradi gm define optimal solution recursively terms optimal lutions subproblems assembly scheduling problem pick subproblems problems finding fastest station lines denote fastest time chassis starting point station ultimate goal determine fastest time chassis factory denote chassis station factory exit faster ways fastest entire factory easy reason f1 station chassis directly station compute focusing f1 recall fastest station s1 fastest station s1 directly station s1 fastest station transfer station s1 case f1 f1 case f1 symmetrically combining equations œ recursive equations figure values computed equations values values optimal solutions subproblems track construct optimal solution define li number station fastest station avoid defining li station precedes station define station fastest entire factory li values trace fastest values li figure trace fastest factory starting station s1 l1 station continuing station station s1 l1 station station s1 step computing fastest times point simple matte write recursive algorithm based equation recurrences compute fastest factory problem recursive algorithm running time exponential number references recursive algorithm equation recurrences exercise asks f1 referenced times exercise asks total number references valuesn compute values order recursive observe depends values f1 computing values order increasing station numbers jšleft figure šwe compute fastest factory time takes time fastest procedur takes input values ai number stations assembly fastest f1 e1 f1 f1 f1 l1 f1 l1 f1 f1 f1 f1 fastest works lines œ2 compute f1 equations loop lines œ13 computes li lines œ8 compute f1 l1 equation lines œ13 compute equation finally lines œ18 compute equation lines œ2 œ18 constant time iterations loop lines œ13 takes constant time entire procedure takes time view process computing values li filling table entries referring figure tables values li left column entry values f1 knowing ready computed stored determine values simply table step constructing fastest factory computed values li construct sequence stations fastest factory discussed figure procedure prints stations decreasing order station number exercise asks modify print increasing order station number print stations print station downto li print station figure print stations produce output station station station station station station exercises modify print stations proce dure print stations increasing order station number hint recursion exercises equations substitution method number references recursive gorithm equals exercises result exercise total numbe references values exercises tables li values total entries reduce space requirem ents total entries computing print stations fastest factory exercises professor canty conjectures exist ai values fastest produces li values l1 station number assuming transfer costs nonnegative professor wrong matrix chain multiplication dynamic programming algorithm solves problem matrix chain multiplication sequence chain matrices multiplied compute product evaluate expression standard algorithm multiplying pairs matrices subroutine parenthesized resolve ambiguities matrices multiplied product matrices fully parenthesized single matrix product fully parenthesized matrix products surrounded parentheses matrix multiplication associative parenthesizations yield product chain matrices product fully parenthesized distinct ways parenthesize chain matrices dramatic impact cost evaluating product cost multiplying matrices standard algorithm followi pseudocode attributes rows columns numbers rows columns matrix matrix multiply columns rows error incompatible dimensions rows columns columns return multiply matrices compatible number columns equal number rows matrix matrix matrix matrix time compute dominated number scalar multiplications pqr express costs terms number scalar multiplications illustrate costs incurred parenthesizations matrix product problem chain matrices suppose dimensions matrices multiply parenthesization perform scalar multiplications compute matrix product scalar multiplications multiply matrix total scalar multiplications multiply parenthesization perform scalar multiplications compute matrix product scalar multiplications multiply matrix total scalar multiplications computing product parenthesization times faster matrix chain multiplication problem stated chain matrices matrix ai dimension fully parenthesize product minimizes number scalar multiplications note matrix chain multiplicati problem multiplying matrices goal determine orde multiplying matrices lowest cost typically time invested determining optimal order paid time saved performing matrix multiplications performing scalar multiplications counting number parenthesizations solving matrix chain multipli cation problem dynamic programming convince exhaustively checking parenthesizations yield efficient algorithm denote number alte rnative parenthesizati ons sequence matrices matrix fully parenthesize matrix product fully parenthesized matrix product product fully parenthesized matrix subproducts split subproducts occur kth matrices recurrence problem asked solution recurrence sequence catalan numbers growsn n3 simpler exercise exercise solution recurrencen number solutions exponential brute force method exhaustiv search poor strategy determining optimal pare nthesization matrix chain step structure optimal parenthesization step dynamic programming paradi gm optimal substructure construct optimal solution problem optimal solutions subproblems matrix chain multiplicati problem perform step convenience adopt notation ai matrix evaluating product ai ai observe problem nontrivial parenthesization product ai ai split product ak ak integer range compute matrices ai ak multiply togeth produce final product ai cost parenthesization cost computing matrix ai cost computing ak cost multiplying optimal substructure proble suppose optimal parenthesization ai ai splits product ak ak parenthesization prefix subchain ai ai ak optimal parenthesization ai ai optimal parenthesization ai ai ak costly parenthesize ai ai ak substituting parenthesization optimal parenthesization ai ai produce parenthesization ai ai cost lower optimum contradiction obser vation holds parenthesization subchain ak ak optimal parenthesization ai ai optimal parenthesization ak ak optimal substructure construct optimal solution problem optimal solutions subproblem solution nontrivial instance matrix chain multipli cation problem requires split product optimal solution optimal solutions subproblem instances build optimal solution instance matrix chain multiplication problem splitting problem tw subproblems optimally parenthesizing ai ai ak ak ak finding optimal solutions subprobl instances combining optimal subproblem solutions ensure search correct place split product considered pos sible places examined optimal step recursive solution define cost optimal solution recursively terms optimal solutions subproblems matrix chain multiplicati problem pick subproblems problems determining minimu cost parenthesization ai ai minimum number scalar multip lications needed compute matrix ai problem cost cheapest compute define recursively problem trivial chain consists matrix ai ai scalar multiplications compute product compute advantage structure optimal solution step assume optimal parenthesization splits product ai ai ak ak equal minimum cost computing subproducts ai ak cost multiplying matrices toge ther recalling matrix ai computing matrix product ai ak takes scalar multiplications recursive equation assume values optimal parenthesization values check recursive definition minimum cost parenthesizing product ai ai values costs optimal solutions subproblems track construct optimal solution define split product ai ai optimal parenthesization equals step computing optimal costs point simple matter wr ite recursive algorithm based recurrence compute minimum cost multiplying algorithm exponential time brute force method checking parenthesizing product observation point subproblems problem choice satisfying recursive algorithm encounter subproblem times branches recursion tree property overlapping subproblems hallmark applicability dynamic programming rst hallmark optim substructure computing solution recurrence recursively perform step dynamic programming paradigm pute optimal cost tabular approach eudocode assumes matrix ai dimensions input sequence p0 length procedure auxiliary table storing costs auxiliary table records achieved optimal cost computing table construct optimal solution order correctly implement pproach determine entries table computing equation cost computing matrix chain product matrices depends costs computing matrix chain products fewer matrices matrix ai product matrices matrix ak product matrices algor ithm table manner corresponds solving parenthesization problem matrix chains increasing length matrix chain order length chain length pkpj return algorithm computes minimum costs chains length lines œ3 recurrence compute minimum costs chains length execution loop linesœ12 time loop computes minimum costs chains length step cost computed lines œ12 depends table entries computed figure illustrates procedure chain matrices defined portion table strictly main diagonal figure table rotated main diagonal horizontally matrix chain listed layout minimum cost multiplying subchain ai ai matrices ound intersection lines running northeast ai northwest horizontal row table entries matrix chains length matrix chain order computes rows left row entry computed products entries southwest southeast figure tables computed matrix chain order matrix dimensions matrix dimension a5 a6 tables rotated main diagona runs horizontally main diagonal upper triangle table upper triangle table minimum number scalar multiplications multiply matrices darker entries pairs shading computing simple inspection nested loop structure matrix chain order yields running time n3 algorithm loops nested deep loop takes values exercise asks running time algorithm fact n3 algorithm requires space store tables matrix chain order efficient exponential time method enumerating pa renthesizations checking step constructing optimal solution matrix chain order determines optimal number scalar multiplications needed compute matrix chain product directly multiply matrices difficult onstruct optimal solution computed stored table entry records optimal parenthesization ai ai splits product ak ak final matrix multiplication computing optimally earlier matrix multiplications computed recursively determines matrix multiplication computing determines matrix multiplication computing recursive procedure prints optimal parenthesization ai ai table computed matrix chain order indices initial print optimal parens prints optimal parenthesization print optimal parens print print print optimal parens print optimal parens print figure print optimal parens prints parenthesization a5 a6 exercises optimal parenthesization matrix hain product sequence dimensions exercises recursive algorit hm matrix chain multiply performs optimal matrix chain multiplicati sequence matrices table computed matrix hain order indices initial matrix chain multiply exercises substitution method solution recurrencen exercises number times table entry referenced computing table entries matrix chain order total number references entire table hint equation exercises parenthesization element expression pairs parentheses elements dynamic programming worked examples dynamic programming method wondering method applies engineering perspective dynamic programming solution problem examine key ingredients optimi zation problem order dynamic programming applicable optimal substr ucture overlapping subproblems variant method called memoization advantage overlapping subproblems property optimal substructure step solving optimization probl dynamic programming characterize structure optimal soluti recall problem exhibits optimal substructure optimal solution problem optimal solutions subproblems problem exhibits optimal subs tructure good clue dynamic programming apply greedy strategy applies chapter dynamic programming build optimal solution problem optimal solutions subproblems car ensure range subproblems includes optimal solution discovered optimal substructure problems examined chapter observed fastest station contained fastest station observed optimal parenthesization ai ai splits product ak ak optimal solutions problems parenthesizing ai ai ak ak ak common pattern discovering optimal substructure solution problem cons ists making choice choosing preceding assembly station choosing split matrix chain making choice leaves subproblems solved suppose problem choice leads optimal solution concern determine choice assume choice determine subproblems ensue characterize space subproblems solutions subproblems optimal solution problem optimal ing cut paste technique supposing subproblem solu tions optimal deriving contradiction cutting nonoptimal subproblem solution pasting optimal solution original problem contradicting supposition optimal solution subproblem typically sim ilar cut paste argument modified effort characterize space subproblems good rule thumb space simple expand space subproblems considered assembly schedul ing fastest entry factory stations s1 subproblem space worked general space subproblems conversely suppose constrain subproblem space matrix chain multiplication matrix products form optimal parenthesization split product ak ak guarantee equals subproblems form ak ak ak subproblem form problem subproblems vary ends vary subproblem ai ai optimal substructure varies problem domains ways subproblems optimal solution original problem choices determining subproblem optimal solution assembly scheduling optimal solution subproblem choices order determine optimal solution fastest station fastest s1 fastest whichever represents subproblem optimally solve matrix chain multiplication subchain ai ai serves subproblems choices matrix ak split product subproblemsšparenthesizing ai ai ak parenthesizing ak ak ajšand solve optimally determine optimal solutions subproblems choose candidates informally running time dynamic rogramming algorithm depends product factors number subproblems choices subproblem assembly scheduling subproblems choices examine yielding running time matrix chain multiplication subproblems choices n3 running time dynamic programming optimal substructure fashion optimal solutions subproblems lved subproblems optimal solution problem finding optimal solu tion problem entails making choice subproblems solving problem cost problem solution subproblem costs cost directly attributable choice assembly scheduling exampl solved subproblems finding fastest stations s1 chose stations preceding station cost attributable choice depends switch lines stations cost ai stay ai switch matrix chain ltiplication determined optimal parenthesizations subchains ai ai chose matrix ak split product cost attributable choice term chapter examine greedy algorithms similarities dynamic programming problems greedy algorithms apply optimal substructure salient differ ence greedy algorithms dynamic programming greedy algorithms optimal substructure fashion finding optimal solutions subproblems making choice greedy algorithms choicešthe choice timešand solve subproblem subtleties careful assume timal substructure applies problems directed graph vertices unweighted shortest path path consisting fewest edges path simple removing cycle path produces path fewer edges unweighted longest simple path simple path consisting edges include requirement simplicity traverse cycle times lik create paths arbitrarily large number edges unweighted shortest path problem exhibits optimal substructure suppose problem nontrivial path intermediate vertex note decompose path subpaths number edges equal sum number edges number edges claim optimal shortest path shortest path cut paste argument path fewer edges cut paste produce path fewer edges contradicting optimality symmetrically shortest path shortest path intermediate vertices finding shortest path shortest path choosing intermediate vertex yields shortest path variant observation optimal substructure shortest path tween pair vertices weighted directed graph tempting assume problem finding unweighted longest simple path exhibits optimal substructure decompose longest simple path subpaths longest simple path longest simple path answer figure path longest simple path longest simple path path simple path longer longest simple path path simple path longer figure directed graph showing problem finding longest simple path unweighted directed graph optimal substructure path longest simple path subpath longest simple path subpath longest simple path longest simple pa ths optimal substructure lacking assemble legal solution problem solutions subproblems combine longest simple paths path simple problem finding unweighted longest simple path sort optimal substructure efficient dynamic programming algorithm problem fact problem np complete whichšas chapter šmeans solved polynomial time substructure longest simp path shortest path subproblems solution problem longest shortest paths subproblems finding longest simple path independent shortest paths subproblems independent solution subproblem affect solution subproblem problem figure problem finding longest simple path subproblems finding longest simple paths subproblems choose path vertices longer vertices subproblem combination solutions subproblems yield path simple vertex problem solve required path vertex splicing subproblem solutions vertex vertices subproblem solution prevents subproblem solution solve subprob lem solve optimally subproblems independent looked resources solving subproblem resources vertices rendered unavailable subproblem subproblems independent nding shortest path answer nature subproblems share res ources claim vertex shortest path splice shortest path shortest path produce shortest path assured vertex paths suppose vertex appears decompose optimal substructure problem path edges edges construct path path edges contradicts assumption shortest path assured subproblems shortest path problem independent problems examined sections independent subproblems matrix chain multiplication subproblems multiplying subchains aiai ak akak subchains disjoint matrix included assembly scheduling determ ine fastest station fastest ways stations s1 solution fastest station include subproblem solutions subproblem automatically independent solution overlapping subproblems ingredient optimization problem dynamic programming applicable space subproblems small sense recursive algorithm problem solves ubproblems generating subproblems typically tota number distinct subproblems polynomial input size recursive algorithm revisits problem optimization problem overlapping subproblems contrast problem divide conquer appro ach suitable generates brand problems step recursion dyna mic programming algorith typically advantage overlapping subproblems solving subproblem storing solution table looked needed constant time lookup examined recursive solution assembly scheduling references tabular solution takes exponential time recursive algorithm linear time illustrate overlapping subproblems propert greater reexamine matrix chain multiplication problem referring figure observe matrix chain order repeatedly solution subproblems lower rows solving subproblems higher rows entry referenced times computations recomputed time looked increase running time dramatic inefficient ecursive procedure determines minimum number scalar multiplications needed compute matrix chain product ai aiai procedure based directly recurrence recursive matrix chain return recursive matrix chain recursive matrix chain return figure recursion tree produced recursive matrix chain node labeled values parameters observe pairs values occur times figure recursion tree computation recursive matrix chain node parameters computations performed shaded subtree replaced single table lookup memoized matrix chain fact time compute recursive procedure exponential denote time cursive matrix chain compute optimal parent hesization chain matrices assume execution lines œ2 lines œ7 unit time inspection procedure yields recurrence noting term appears collecting summation rewrite recurrence proven substitution method basis easy inductively completes proof tal work performed recursive matrix chain exponential compare recursive algorith dynamic programming algorithm efficient becau takes advantage overlapping subproblems property subproblems dynamic programming algorithm solves recursive algorithm hand repeatedly resolve subproblem time reappears recursion tree recursion tree natural recu rsive solution problem subproblem repeatedly total number subproblems small good idea dynamic programming work reconstructing optimal solution practical matter store choi subproblem table reconstruct informa tion costs stored assembly scheduling stored li station preceding fastest alternatively filled entire table determine station precedes s1 fastest extra work f1 f1 station s1 precedes s1 fastest s1 case f1 precedes s1 assembly scheduling reconstructing predecessor stations takes time station li table matrix chain multiplication table saves work reconstructing optimal solution suppose maintain table filled table optimal subproblem costs choices determining subproblems optimal solution parenthesizing ai ai constant time reconstruct subproblems chose soluti problem storing matrix split product ai ai reconstruct choice time memoization variation dynami programming offers efficiency usual dynamic programming approach maintaini strategy idea memoize natural inefficient recursiv algorithm ordinary dynamic programming maintain table subprob lem solutions control structure filling table recursive algorithm memoized recursive algorithm maintains entry table solution subproblem table entry initially special entry filled subproblem encountered execution recursive algorithm solution computed stored table subsequent time subproblem encountered valu stored table simply looked returned memoized version recursive trix chain memoized matrix chain length return lookup chain lookup chain return lookup chain lookup chain return memoized matrix chain matrix chain order maintains table computed values minimum number scalar multiplications needed compute matrix ai table entry initially entry filled lookup chain executed procedure simply retu rns computed cost cost computed recursive matrix chain stored returned convenient unfilled table entry initialize recursive matr chain lookup chain returns computes time lookup chain calle parameters figure illustrates memoized matrix chain saves time compared recursive matrix chain shaded subtrees represent values looked computed dynamic programming algorithm matrix chain order procedure memoized matrix chain runs n3 time table entries initialized memoized matrix chain categorize calls lookup chain types calls lines œ9 executed calls lookup chain simply returns calls type table entry calls type recursive calls calls firs type lookup chain recursive calls n3 calls type type takes time type takes time time spent recurs ive calls total time n3 memoization turnsn time algorithm n3 time algorithm summary matrix chain multiplication problem solved memoized algorithm dynamic programming algorithm n3 time methods advantage overla pping subproblems property subproblems total methods computes solution subproblem memoization natu ral recursive algorithm runs exponential time solved subproblems repeatedly solved general practice subproblems solved dynamic programming algorithm outperforms memoi zed algorithm constant factor overhead recursio overhead maintaining table problems regular pattern table accesses dynamic programming algorithm exploited reduce time space requirements alternatively subproblems subproblem space solved memoized solution advantage solv ing subproblems required exercises efficient determine optimal number multiplications matrix chain multiplication problem enumerating ways parenthesizing product computing number multiplications running recursive matrix chain justify answer exercises draw recursion tree merge sort procedure array elements explain memoization effective speeding good divide conquer algorithm merge sort exercises variant matrix chain ltiplication problem goal parenthesize sequence matrices maximize minimize number scalar multiplications problem exhibit optimal substructure exercises assembly schedu ling overlapping subproblems exercises stated dynamic programming solv subproblems choose optimal solution prob lem professor capulet claims solve subproblems order optimal solution suggests optimal solution matr chain multiplication problem choosing matrix ak split subproduct ai ai selecting minimize quantity solving subproblems instance matrix chain multiplication problem greedy approach yields suboptimal solution misspelling word memoization memorization memoization memo technique consists recording term unweighted distinguish problem finding shortest paths weighted edges chapters breadth search technique chapter solve unweighted problem strange dynamic progr amming relies subproblems independent overlapping requirements sound contradictory notions points axis subproblems problem independent share resources subproblems overlapping subprobl occurs subproblem problems approach presupposes set subproblem para meters relation table positions subproblems established approach memoize hashing subproblem parameters keys longest common subsequence biological applications compare dna organisms strand dna consists string molecules called bases bases adenine guanine cytosine thymine representing bases initial letters strand dna expresse string finite set appendix definition string dna organism s1 accggtcgagtgcgcggaagccggccgaa dna organism gtcgttcggaatgccgttgctctgtaaa goal comparing strands dna determine strands measure closely organisms similarity defined ways dna strands su bstring chapter explores algorithms solve problem s1 substring alternatively strands number needed turn small problem notion measure similarity strands s1 finding strand s3 bases s3 s1 bases order consecutively longer strand s3 s1 longest strand s3 gtcgtcggaagccggccgaa formalize notion similarity longest common ubsequence problem subsequence sequence sequence elements left formally sequence xm sequence z1 z2 zk subsequence exists stri ctly increasing sequence i1 ik indices xij zj subsequence sequence sequences sequence common subsequence subsequence sequence common subsequence sequence longest common subsequence lcs length sequence common length sequence lcs sequence common subsequence length greater longest common subsequence problem sequences xm y1 yn maximum length common subsequence lcs problem solved efficiently dynamic programming step characterizing longest common subsequence brute force approach solving lcs problem enumerate subsequences check subsequence subsequence keeping track longest subsequence subsequence corresponds subset indices subsequences approach requires exponential time making impractical long sequences lcs problem optimal substructur property theorem natural classes subproblems correspond pairs prefixes input sequences precise sequence xm define ith prefix x4 x0 sequence theorem optimal subs tructure lcs xm y1 yn sequences z1 z2 zk lcs xm yn zk xm yn zk lcs xm yn xm yn zk xm implies lcs xm xm yn zk yn implies lcs yn proof zk xm append xm yn common subsequence length contradicting supposition longest common subsequence zk xm yn prefix zk length common subsequence xm yn lcs suppose purpose contradiction common subsequence xm yn length greater appending xm yn produces common subsequence length greater contradiction zk xm common subsequence xm common subsequence xm length greater common subsequence xm contradicting assumption lcs proof symmetric characterization theorem lcs sequences lcs prefixes sequences lcs problem optimal substructure property recursive solution overlapping subproblems property moment step recursive solution theorem implies subproblems examine finding lcs xm y1 yn xm yn lcs xm yn appending xm yn lcs yields lcs xm yn solve subproblems finding lcs xm finding lcs yn whichever lcs longer lcs cases exhaust possibilities optimal subproblem solutions lcs overlapping subproblems property lcs problem lcs lcs yn xm subproblems subsubpr oblem finding lcs xm yn subproblems share subsubproblems matrix chain multiplication problem recursive solution lcs problem involves establishing recurrence optimal solution define length lcs sequences sequences length lcs length optimal substructure lcs problem recursive formula observe recursive formulation condition problem restricts subproblems subproblem finding lcs stead subproblems finding lcs previous dynamic programming algorithms examinedšfor asse mbly scheduling matrix chain multiplicationšno subproblems ruled conditions problem finding lcs dynamic programming algor ithm rules subproblems based conditions problem edit distance problem problem characteristic step computing length lcs based equation easily write exponential time recursive algorithm compute length lcs sequences distinct subproblems dynamic ogramming compute solutions procedure lcs length takes sequences xm y1 yn inputs stores values table entries computed row major order row filled left row maintains table simplify construction optimal solution intuitively points table entry optimal subproblem solution chosen computing procedure returns tables length lcs lcs length length length return figure tables produced lcs length sequences running time procedure table entry takes time compute figure tables computed lcs length sequences square row column arrow entry šthe lower hand corner tablešis length lcs entry depends values entries computed reconstruct elements lcs follow arrows lower hand corner path shaded path corresponds entry highlighted member lcs step constructing lcs table returned lcs length construct lcs xm y1 yn simply trace table arrows encounter entry implies element lcs elements encountered reverse order method recursive procedure prints lcs proper forward order initial invocation print lcs length length print lcs return print lcs print elseif print lcs print lcs table figure procedure prints bcba procedure takes time decremented stage recursion improving code developed algorithm improve time space true straightforward dynamic programming algorithms simplify code impr ove constant factors yield asymptotic improvement performance yield substantial asymptotic savings time space eliminate table altogether entry depends table entries determine time values compute inspecting table reconstruct lcs time procedure print lcs exercise asks pseudocode save space method aux iliary space requirement computing lcs asymptotically decrease space table reduce asymptotic ace requirements lcs length rows table time row comput previous row fact space row compute length lcs exercise improvement works eed length lcs reconstruct elements lcs smaller tabl retrace steps time exercises determine lcs exercises reconstruct lcs completed table original sequences xm y1 yn time table exercises memoized version lcs length runs time exercises compute length lcs min entries table additional space min entries additional space exercises time algorithm longest monot onically increasing subsequence sequence numbers exercises lg time algorithm longest monotonically increasing sequence sequence numbers hint observe element candidate subsequence length large elem ent candidate subsequence length maintain candidate subsequences linking input sequence optimal binary search trees suppose designing program tran slate text english french occurrence english word text french equivalent perform lookup operations build binary search tree english keys french equivalents satellite ta search tree individual word text total time spent search ing low ensure lg search time occurrence red black tree balanced binary search tree frequencies case frequently word appears root rarely word mycophagist appears root organization slow translation number nodes vi sited searching key binary search tree depth node key occur frequently text nearer root text french translation binary search tree organize binary sear tree minimize number nodes visited searches word occurs optimal binary search tree formally sequence k1 k2 kn distinct keys sorted order k1 k2 kn build binary search tree keys key ki probability search ki searches values dummy keys d0 d1 dn representing values d0 represents values k1 dn represents lues greater kn dummy key represents values ki ki dummy key probability qi search correspond figure binary search trees set keys key ki internal node dummy key leaf search succe ssful finding key ki unsuccessful finding dummy key figure binary search trees set keys probabilities qi binary search tree expected search cost binary search tree expected search cost tree optimal probabilities searches key dummy key determine expected cost search binary search tree assume actual cost search number node examined depth node search expected cost search deptht denotes node depth tree equality equation figure calculate expected search cost node node node depth probability contribution k1 k2 k3 k4 k5 d0 d1 node depth probability contribution d3 d4 d5 total set probabilities goal construct binary search tree expected search cost smallest tree optimal binary search tree figure optimal binary search tree probabilities figure caption expected cost optimal binary search tree tree height smallest construct optimal binary search tree putting key greatest probability root key k5 greatest search probability key root optimal binary search tree k2 lowest expected cost binary search tree k5 root matrix chain multiplication exhaustive checking possibilities fails yield efficient algorithm label nodes node binary tree keys k1 k2 kn construct binary search tree add dummy keys leaves problem number binary trees nodesn n3 exponential number binary arch trees examine exhaustive search surprisingly solv problem dynamic programming step structure optimal binary search tree characterize optimal substructure optim binary search trees start observation subtrees subtree binary search tree keys contiguous range ki addition subtree keys ki leaves dummy keys state optimal substructure optimal binary search tree subtree keys ki subtree optimal subproblem keys ki dummy keys usual cut paste argument applies subtree expected cost lower cut paste binary search lower expected cost contradicting optimality optimal substructure construct optimal solution problem optimal soluti ons subproblems keys ki keys kr root optimal subtr keys left subtree root kr keys ki kr dummy keys subtree keys kr dummy keys long examine candidate roots kr determine optimal binary search trees ki kr kr guaranteed optimal binary search tree worth noting ubtrees suppose subtree keys ki select ki root argument ki left subtree keys ki ki natural interpret sequence keys bear mind subtrees dummy keys adopt convent ion subtree keys ki ki actual keys single dummy key symmetrically select root subtree keys subtree actual keys dummy key step recursive solution ready define optimal solution recursively pick subproblem domain finding optimal binary search tree ontaining keys ki actual keys dummy key define expected cost searching optimal binary search tree keys ki ultimately compute easy case occurs dummy key expected search cost qi select root kr ki optimal binary search tree keys ki kr left subtree optimal binary search tree keys kr subtree expected search cost subtree subtree node depth node subtree increases equation expected search cost subtree increases sum probabilities subtree subtree keys ki denote sum probabilities kr root optimal subtree keys ki noting rewrite recursive equation assumes node kr root choose root lowest expected search cost final recursive formulation values expected search costs optimal binary search trees track structure optimal binary search trees define root kr root optimal bina search tree keys ki compute values root leave construction optimal binary search tree values exercise step computing expected search cost optimal binary search tree point noticed milarities characterizations optimal binary search trees matrix chain multiplication problem domains subproblems consist contiguous subran ges direct recursive implementation equation inefficient direct recursive matrix chain multiplication algorithm store values table order subtree dummy key dn compute store start order subtree dummy key d0 compute store entries table root recording root subtree keys ki table entries table efficiency compute scratch time computing šwhich additionsšwe store values table base case compute qi compute compute values time pseudocode takes inputs probabilities q0 qn size returns tables root optimal bst qi qi root return root description ity matrix chain order procedure operation procedure fairly straightforward loop lines œ3 initializes values loop lines œ13 recurrences compute iteration loop computes iteration computes innermost loop lines œ13 candidate determine key kr root optimal nary search tree keys ki loop saves current root finds key root figure tables root computed procedure optimal bst key distribution figure matrix chain multiplication tables rotated diagonals horizontally optimal bst computes rows left row figure tables root computed optimal bst key distribution figure tables rotated diagonals horizontally optimal bst procedure takes n3 time matr chain order easy running time n3 loops nested deep loop takes values loop indices optimal bst bounds matrix chain order directions matrix chain optimal bst procedure takes n3 time exercises write pseudocode pro cedure construct optimal bst root table root outputs structure optimal nary search tree figure procedure print structure k2 root k1 left child k2 d0 left child k1 d1 child k1 k5 child k2 k4 left child k5 k3 left child k4 left child k3 d3 child k3 d4 child k4 d5 child k5 optimal nary search tree figure exercises determine cost structure optimal binary search tree set keys probabilities qi exercises suppose maintaining table computed directly equation optimal bst computed change affect ymptotic running time optimal bst exercises knuth roots optimal subtrees root root root fact modify optimal bst procedure time problems bitonic euclidean traveling salesman problem euclidean traveling salesman problem problem determ ining shortest closed tour connects set points plane figure solution point problem general problem np compl ete solution believed require polynomial time chapter figure points plane unit grid shortest closed tour length tour bitonic shortest bitonic tour set points length bentley suggested simplify problem restrict ing attention bitonic tours tours start leftmost point strictly rightmost point strictly left starting point figure shortest bitonic tour points case polynomial time algorithm time algorithm determining timal bitonic tour assume points coordinate hint scan left maintaining optimal possibilities parts tour problems printing neatly problem neatly printing paragraph printer input text sequence lengths l1 measured characters print paragraph neatly number lines hold maximum characters criterion neatness leave space number extra space charac ters nonnegative fit minimize sum lines cubes numbers extra space characters ends lines dynami programming algorithm print paragraph neatly printer analyze running time space requirements algorithm problems edit distance order transform source string text target string perform transformation operations goal produce series transformations change array zšassumed large hold characters needšto hold intermediate initially termination maintain current indices operations allowed alter indices initially required examine character transformation sequence transformation operations transformation operations copy character setting incrementing operation examines replace character character setting incrementing operation examines delete character incrementing leaving operation examines insert character setting incrementing leaving operation examines characters twiddle exchange characters copying opposite order setting setting operation examines kill remainder setting operation examines characters examined operation performed final operation transform source string algorithm ta rget string altruistic sequence operations underlined characters operation operation initial strings algorithm _ copy algorithm a_ copy algorithm al_ replace algo rithm alt_ delete algor ithm alt_ copy algorithm altr_ insert algori thm altru_ insert algori thm altrui_ insert algori thm altruis_ twiddle algorithm altruisti_ insert algorith altruistic_ kill algorithm_ altruistic_ note sequences transformation operat ions transform algorithm altruistic transformation operations cost cost operation depends specific application assume operation cost constant assume indi vidual costs copy replace operations combined costs delete insert operations copy replace operations cost sequence transformation operations sum costs ndividual operations sequence sequence cost transforming algorithm altruistic cost copy cost replace cost delete cost inser cost twiddle cost kill sequences set transformation operation costs edit distance cost xpensive operation sequence transforms dynamic programming gorithm finds edit distance prints optimal operation sequence analyze running time space requirements algorithm edit distance problem generalization problem aligning dna sequences setubal meidanis methods measuring similarity dna sequences aligning method align sequences consists inserting spaces arbitrary locations sequences including sequences length space position position space assign score position position receives score space space space score alignment sum scores individual positions sequences gatcggcat caatgtgaatc alignment atcg gcat caat gtgaatc position scor position score score alignment total scor _ explain cast problem finding optimal alignment edit distance problem subset transformati operations copy replace delete insert twiddle kill problems planning company party professor stewart consulting president corporat ion planning company party company hierarchical structure supervisor relation forms tree rooted president personnel office ranked employee conviviality rating real number order party fun attendees president employee supervisor attend professor stewart tree describes structure corporation left child sibling representation node tree holds addition pointers employee employ conviviality ranking algorithm guest list maximizes sum conviviality ratings guests analyze running time algorithm problems viterbi algorithm dynamic programming directed graph speech recognition edge labeled sound finite set sounds labeled graph formal model person speaking restricted language path graph starting distinguished vertex v0 corresponds sequence sounds produced model label directed pa defined concatenation labels edges path efficient algorithm edge labeled graph distinguished vertex v0 sequence characters returns path v0 label path exists algorithm return path analyze running time algorithm hint concepts chapter suppose edge nonnegative probability traversing edge vertex producing sound sum probabilities edges leaving vertex equals probability path defined oduct probabilities edges view probability path v0 probability random walk v0 follow path choice edge vertex probabilistically probabilities edges leaving extend answer path returned probable path starting v0 label analyze running time algorithm problems moving checkerboard suppose checkerboard checker checker edge board edge board rule step checker squares square square left checker leftmost column square checker rightmost column time square square receive dollars pairs legal assume positive algorithm figures set moves checker edge edge gathering dollars algorithm free pick square edge starting point square edge destination order maximize number dollars gathered runn ing time algorithm problems scheduling maximize profit suppose machine set jobs process machine job processing time profit deadline machine process job time job uninterruptedly consecutive time units job completed deadline receive profit completed deadline receive profit algorithm schedule obtains maximum profit assuming processing times integers running time algorithm subject text edible mushrooms mycophagist root chapter notes bellman began systematic study dynamic programming word programming linear programming refers tabular solution method optimization tech niques incorporating elements dynamic programming earlier bellman provided solid mathematical basis shing lg time algorithm matrix chain multiplication problem time algorithm longest common subs equence problem appears folk algorithm knuth posed question subquadratic algorithms lcs problem exist masek paterson answered question affirmative algorithm runs lg time sequences drawn set bounded size special case element appears input sequence szymanski problem solved lg time extend problem computi string edit distances problem early paper variable length binary encodings gilbert moore applications constructing optimal binary sear trees case probabilities paper n3 time algorithm aho hopcroft ullman algorithm exercise knuth tucker devised algorithm cas probabilities time space subsequently knuth reduced time lg chapter greedy algorithms overview algorithms optimization problems typically sequence steps set choices step optimizati problems dynamic programming determine choices overkill simpler efficient algorithms greedy algorithm choice moment locally optimal choice hope choice lead globally optimal solution chapter explores optimization problems solvable greedy algorithms reading chapter read dynamic programming chapter greedy algorithms yield optimal solutions problems examine simple nontrivial prob lem activity selection problem greedy algorithm efficiently computes solution arrive greedy algorithm dynamic programming solution showing greedy choices arrive optimal solution reviews basic elements greedy approach givi direct approach proving greedy algorithms correct dynami programming based process presents application gree techniques design data compression huffman codes investigate theory underlying combinatorial structures called matroids eedy algorithm produces optimal solution finally illustrates application matroids problem scheduling unit time tasks deadlines penalties greedy method powerful works wide range problems chapters algorithms viewed applications greedy method including minimum spanning tree algorithms chapter dijkstra algorithm shortest paths single source chapter chv atal gree set covering heuristic chapter minimum spanning tree algorithms classic greedy method chapter chapter read independently read activity selection problem problem scheduli competing activities require exclusive common resource goal selecting maximum size set mutually compatible activities suppose set proposed activities resource lecture hall activity time activity ai start time finish time selected activity ai takes place half open time interval activities ai compatible intervals overlap ai compatible activity selection problem select maximum size subset mutually compatible activities set activities sorted monotonically increas ing order finish time shortly advantageous activities rted order subset a9 a11 consists mutually compatible activities maximal subset subset a8 a11 larger fact a8 a11 largest subset mutually compatible activ ities larg subset a9 a11 solve problem steps start formulati dynamic programming solution problem combine optimal solutions subproblems form optimal solution orig inal problem seve ral choices determining subproblems optimal solution observe choicešthe greedy choicešand greedy choice subproblems guaranteed nonempty subproblem remains based observations develop recursive greedy algorithm solve activity scheduling problem complete process developing greedy solution converting recursive algorithm iterative steps involved typical development greedy algorithm illustrate relationship greedy algorithms dynamic programming optimal substructure activity selection problem mentioned start developing dynamic programming solution activity selection problem chapter step optimal substructure construct optimal solution problem timal solutions subproblems chapter define appr opriate space subproblems start defining sets sij ak sk fk sij subset activities start activity ai finishes finish activity starts fact sij consists activities compatible ai compatible activities finish ai finishes activities start earlier starts order represent entire problem add fictitious activities a0 adopt conventions f0 s0 ranges restrict ranges assume activities sorted monotonically increas ing order finish time claim sij ø suppose ther exists activity ak sij ai sorted order sk fk contradicts assumption ai sorted order conclude assuming sorted activities monotonically increasing order finish time space subproblems select maximum size subset mutually compatible activities sij knowing sij substructure activity selection problem subproblem sij suppose solution sij includes activity ak sk fk activity ak generates subproblems sik activities start ai finishes finish ak starts skj activities start ak finishes finish starts consists subset activities sij solution sij union solutions sik skj activity ak number activities solution sij size solution sik size solution skj ak optimal substructure problem suppose optimal solution aij sij includes activity ak solutions aik sik akj skj optimal solution sij optimal usual cut paste argument applies solution sik included activities aik cut aik aij paste producing solution sij activities aij assumed aij optimal solution derive contradiction sim ilarly solution skj activities akj replace akj produce solution sij activities aij optimal substructure construct optimal solution problem optimal solutions subproblem solution nonempty subproblem sij includes activity ak optimal solution optimal solutions subproblem instances sik skj build maximum size subset mutually compatible activities sij splitting problem subproblems finding maximum size subsets mutually compatible activities sik skj finding maximum size subsets aik akj mutually compatible activities subproblems forming maximum size subset aij mutually compatible activities optimal solution entire problem solution s0 recursive solution step developing dynamic progra mming solution recursively define optimal solution activity selection problem number activities maximum size subset mutually compatible activities sij sij ø nonempty subset sij ak maximum size subset mutually compatible activities sij maximum size subsets mutually compatible activities subproblems sik skj equation recurrence recursive equation assume values maximum size subset sij values check recursive definition converting dynamic programming solution greedy solution point straightforward exercise write tabular dynamic programming algorithm based recurrence fact exercise asks key observations simplify solution theorem nonempty subproblem sij activity sij earliest finish time fm min fk ak sij activity maximum size subset mutually compatible activities sij subproblem sim choosing leaves subproblem smj nonempty proof prove bit simpler suppose sim nonempty activity ak sk fk fm ak sij earlier finish time contradicts choice conclude sim prove suppose aij maximum size subset mutually compatible activities sij order activities aij monotonically increasing order finish time ak activity aij ak maximum size subset mutually compatible activities sij ak construct subset activities disjoint activities aij ak activity aij finish fm fk noting number activities aij maximum size subset mutu ally compatible activities sij includes theorem valuable recall optimal structure varies subproblems optimal solution original problem choices determining subproblems dynamic programming solution subproblems optimal solution choices solving subproblem sij theorem reduces quantities subproblem optimal solution subproblem guaranteed solving subproblem sij choice earliest finish time sij fortunately easily determine activity addition reducing number subproblems number choices theorem yields benefit solve subpr oblem fashion manner typically dynamic programming solve subproblem sij choose activity sij earliest finish time add solution set activities optimal solution subproblem sij chosen solution smj optimal solution sij solve smj solving sij solve sij choose activity sij earliest finish time solve smj note pattern subproblems solve original problem s0 suppose choose activity s0 earliest finish time sorted activities monotoni cally increasing finish times f0 m1 subproblem suppose choose activity earliest finish time case subproblem continuing subproblem form activity number mi subproblem consists activitie finish number activities varies subproblem subproblem pattern activities choose choose activity earliest finish time finish times activities chosen subproblems strictly increasing time activity monotonically increasing order finish times activity choose solving subproblem earliest finish time legally scheduled activity picked greedy choice sense intuitively leaves opportunity remaining activities scheduled greedy choice maximizes unscheduled time remaining recursive greedy algorithm streamline dynamic programming solution treat method ready algorithm works purely greedy fashion straightforw ard recursive solution procedure recursive activity selector takes start finish times activities represented arrays starting indices subproblem solve returns maximum size set mutually compatible activities assume input activities ordered monotonical ly increasing finish time equation sort order lg time breaking ties arbitrarily initial recursive activity selector recursive activity selector activity sij return recursive activity selector return ø figure operation algorithm recursive recursive activity selector loop lines œ3 activity sij loop examines ai ai finds activity compatible ai activity loop terminates finds activity procedure returns union maximum size subset smj returned recursive recursive activity selector alternatively loop terminate case examined activities finish times finding compatible ai case sij ø procedure returns ø figure operation recursive activity selector activities earlier activities considered recursive horizontal lines fictitious activity a0 finishes time initial recursive activity selector activity selected recursive activities selected shaded activit white considered starting time activity occurs nish time activity arrow points left reject arrow points directly selected recursive recursive activity selector returns ø set selected activities a8 a11 assuming activities sorted finish times running time recursive activity selector recursive calls tivity examined loop test activity ak examined iterative greedy algorithm easily convert recursive procedure iterative procedure recursive activity selector tail recursive problem ends recursive union operation straightforward task transform tail recursive procedure iter ative form fact compilers programming languages perform task automatically written recursive activity selector works subproblem sij subproblems subproblems consist activities finish procedure greedy activity selector iterative version procedure recursive activity selector assumes input activities ordered monotonically increasing finish time collects selected activities set returns set greedy activity selector length return procedure works variable indexes addition activity ai recursive version activities considered order monotonically creasing finish time maximum finish time activity lines œ3 select activity initialize activity initialize activity loop lines œ7 finds earliest activity finish loop considers activity turn adds compatible selected activities activity earliest finish activity compatible activity suffices equation check start time earlier finish time activity activity compatible lines œ7 add activity set set returned greedy activity selector precisely set returned recursive activity selector recursive version greedy activity selector schedules set activities time assuming activities alr eady sorted initially finish times exercises dynamic programming algorithm activity selection problem based recurrence algorithm compute sizes defined produce maximum size subset activities assume inputs sorted equation compare running time solution running time greedy activity selector exercises suppose selecting activity finish select activity start compatib selected activities approach greedy algorithm prove yields optimal solution exercises suppose set activities schedule large number lecture halls schedule activities lecture halls efficient greedy algorithm determine activ ity lecture hall interval graph coloring problem create interval graph vertices activities edges connect incompatible activities smallest number colors required color ery vertex adjacent vertices color corresponds finding fewe lecture halls needed schedule activities exercises greedy approach activity selection problem produces maximum size set mutually compatible activities exam ple approach selecting activity duration hose compatible selected activities work approaches selecting compatible activity overlaps fewest remaining activ ities selecting compatible remaining activity earliest start time speak sets sij subproblems sets activities clear context referring sij set activities subproblem input set elements greedy strategy greedy algorithm obtains optimal solu tion problem making sequence choices decision point algorithm choice moment chosen heuristic strategy produce optimal solution activity selection problem discusses general properties greedy methods process develop greedy algorithm bit involved typical steps determine optimal substructure problem develop recursive solution prove stage recursion optimal choices greedy choice safe greedy choice subproblems induced greedy choice develop recursive algorithm implements greedy strategy convert recursive algorithm iterative algorithm steps eat dynamic programming underpinnings greedy algorithm practice streamline steps designing greedy algorithm develop su bstructure eye making greedy choice leaves subproblem solve optimally activity selection problem defined subproblems sij varied greedy choice restrict subproblems form alternatively fashioned optimal substructure greedy choice mind dropped ond subscript defined subproblems form ak sk proven greedy choice activity finish combined optimal solution remaining set compatible activities yields optimal solution generally design greedy algorithms sequence steps cast optimization problem whic choice left subproblem solve prove optimal solu tion original problem greedy choice greedy choice safe demonstrate greedy hoice remains subproblem property combine optimal solution subproblem greedy choice arrive timal solution original problem direct process sections chapter beneath greedy algorithm ways cumbersome dynamic programming solution greedy algorithm solv optimization problem general greedy choice property optimal structure key ingredients demonstrate problem properties developing greedy algorithm greedy choice property key ingredient greedy choice property globally optimal solution arrived making locally optimal greedy choice choice choice current problem subproblems greedy algorithms diff dynamic programming dynamic programming choice step choice depends solutions subproblems typically solve dynamic programming problems manner progressing smaller subproblems larger subproblems greedy algorithm choice moment solve subproblem arising choice hoice greedy algorithm depend choices depend future choices solutions subproblems dynamic programming solves subproblems greedy strategy progresses fashion making greedy oice reducing problem instance smaller prove greedy choice step yields globally optimal solution cleverness required typically case theorem proof examines globally optimal solution subproblem solution modified greedy hoice smaller subproblem greedy choice property gains efficiency making choice subproblem activity selec tion problem assuming sorted activities monotonically increasing order finish times needed examine activity frequently cas preprocessing input data structure priority queue greedy choices yielding efficient algorithm optimal substructure problem exhibits optimal substructure optimal solution problem optimal solutions subproblems property key ingredient assessing applicability dynamic programming greedy algorithms optimal substructure recall demonstrated optimal solution subproblem sij includes activity ak contai optimal solutions subproblems sik skj optimal substructure argued knew activity ak construct optimal solution sij selecting ak activities optimal solu tions subproblems sik skj based observation optimal substructure devise recurrence optimal solution direct approach regard ing optimal substructure applying greedy algorithms mentioned luxury assuming arrived subproblem greedy choice original problem argue optimal solution subproblem combined greedy choice yields optimal solution iginal problem scheme implicitly induction subproblems prove maki greedy choice step produces optimal solution greedy versus dynamic programming optimal substructure property exploited greedy dynamic programming strategies tempte generate dynamic programming solution problem greedy solution suffices mistakenly greedy solution works fact dynamic progra mming solution required illustrate subtleties techniques investigate variants classical optimization problem œ1 knapsack problem posed thief robbing store finds items ith item worth vi dollars weighs pounds vi integers valuable load carry pounds knapsack integer items called œ1 knapsack problem item left thief fractional item item fractional knapsack problem setup thief fractions items binaryœ1 choice item item œ1 knapsack problem gold ingot item fractional knapsack problem gold dust knapsack problems exhibit optimal ubstructure property œ1 problem valuable load weighs pounds remove item load remaining load valuable load weighing wj thief original items excluding comparable fractional problem remove weight item optimal load remaining load valuable load weighing thief original items wj pounds item problems fractiona knapsack problem solvable greedy strategy œ1 problem lve fractional problem compute pound vi item obeying greedy strategy thief item greate pound supply item exhausted carry takes item greatest pound carry sorting items pound greedy algorithm runs lg time proof fractional knapsack problem greedy choice property left exercise greedy strategy work œ1 knapsack problem problem instance illustrated figure items knapsack hold pounds item weighs pounds worth dollars item weighs pounds worth dollars item weighs pounds worth dollars pound item dollars pound greater pound item dollars pound item dol lars pound greedy strategy item case analysis figure optimal solution takes items leavi solutions involve item suboptimal figure greedy strategy work œ1 knapsack problem thief select subset items weight exceed pounds optimal subset includes items solution item suboptimal item greatest pound fractional knapsack problem items order greatest valu pound yields optimal solution comparable fractional problem greedy strategy takes item yield optimal solution figure item workœ1 problem thief unable knapsack capacity space lowers effective pound load œ1 problem item inclusion knapsack mpare solution subproblem item included solution subproblem item excluded choice problem formulated rise lapping subproblemsša hallmark dynamic progra mming dynamic programming solve œ1 problem exercise exercises prove fractional knapsack problem greedy choice property exercises dynamic programming solution œ1 knapsack problem runs time number items maximum weight items thief knapsack exercises suppose œ1 knapsack problem der items sorted increasing weight order sorted decreasing efficient algorithm optimal solution variant knapsack problem argue algorithm correct exercises professor midas drives automobile wark reno interstate car gas tank holds gas travel miles map distances gas stations route professor wishes gas stops efficient method professor midas determine gas stations prove strategy yields optimal solution exercises efficient algo rithm set points real determines smallest set unit length closed intervals points argue algorithm correct exercises solve fract ional knapsack problem time assume solution problem exercises suppose sets positive integers choose reorder set reordering ai ith element set ith element set receive payoff algorithm maximize payoff prove gorithm maximizes payoff state running time huffman codes huffman codes ffective technique compressing data savings typical depending characteristics data compressed data sequence charac ters huffman greedy gorithm table frequencies occurrence characters build optimal representing character binary string suppose character data file store compactly observe characters file ccur frequencies figure characters character occurs times frequency thousands fixed length codeword variable length codeword figure character coding problem data file characters characters aœf frequencies character ssigned bit codeword file encoded bits variable length code file encoded bits ways represent file problem designing binary character code code short character represented unique binary string fixed length code bits represent characters method requires bits code entire file variable length code considerably fixed length code frequent characters short codewords infrequent characters long codewords figure code bit string represents bit string represents code requires bits represent file vings fact optimal character code file prefix codes codes codeword prefix codeword codes called prefix codes optimal data compression achievable character code achieved prefix code loss generality restricting attention prefix codes encoding simple binary char acter code concatenate codewords representing character file exam ple variable length prefix code figure code character file abc denote concatenation prefix codes desirable simplif decoding codeword prefix codeword encoded file unambiguous simply identify initial codeword translate original character repeat decoding process remainder encoded file string parses uniquely decodes aabe decoding process convenient representation prefix code initial codeword easily picked binary tree leaves characters representation interpret binary codeword character path root character left child child figure trees codes note binary search trees leaves rted order internal nodes character keys figure trees coding schemes figure leaf labeled character frequency occurrence internal node labeled sum frequencies leaves subtree tree fixed length code tree optimal prefix code optimal code file represented binary tree nonleaf node children exercise fixed length code optimal tree figure binary tree codewords restrict attention binary trees alphabet characters drawn character frequencies positive optimal prefix code leaves letter alphabet internal nodes exercise tree prefix code simple matter compute number bits required encode file character alphabet denote frequency file denote depth leaf tree note length codeword character number bits require encode file define cost tree constructing huffman code huffman invented greedy algorithm cons tructs optimal prefix code called huffman code keeping observations proof correctness relies greedy choice property optimal ubstructure demonstrating properties hold developing pseudocode pseudocode clarify algorithm greedy choices pseudocode assume set characters character object defined frequency algorithm builds tree optimal code botto manner set leaves performs sequence merging operations creat final tree min priority queue keyed identify frequent objects merge result merger objects object frequency sum frequencies objects merged huffman allocate node left extract min extract min insert return extract min return root tree huffman algorithm proceeds figure letters alphabet initial queue size merge steps required build tree final tree represents optimal prefix code codeword letter sequence edge labels path root letter figure steps huffman algorithm frequencies figure contents queue sorted increasing order frequency step trees lowest frequencies merge leaves rectangles character frequency internal nodes circles sum frequencies children edge connecting internal node children labeled edge left child edge child codeword letter sequence labels edges connecting root leaf letter initial set nodes letter œ intermediate stages final tree initializes min priority queue characters loop lines œ8 repeatedly extracts nodes lowest frequency queue replaces queue node representing merger frequency computed sum frequencies node left child child order arbitrary switching left child node yields code cost mergers node left queueš root code treešis returned analysis running time huffman algorithm assumes implemented binary min heap chapter set characters initialization performed time build min heap procedure loop lines œ8 executed times eac heap operation requires time lg loop contributes lg running time total running time huffman set characters lg correctness huffman algorithm prove greedy algorithm huffman correct problem determining optimal prefix code exhibits greedy choice optimal substructure properties lemma greedy choice property holds lemma alphabet character frequency characters lowest frequencies exists optimal prefix code codewords length differ bit proof idea proof tree representing arbitrary optimal prefix code modify tree representing anothe optimal prefix code characters sibling leaves maximum dept tree codewords lengt differ bit characters sibling leaves maximum depth loss generality assume lowest leaf frequencies order arbitrary frequencies order figure exchange positions produce tree exchange positions produce tree equation difference cost figure illustration key step proof lemma optimal tree leaves deepest leaves siblings leaves leaves huffman algorithm merges arbitrary positions leaves swapped tree leaves swapped tree swap increase cost tree optimal tree nonnegative nonnegative minimum frequency leaf nonnegative leaf maximum depth exchanging increase cost nonnegative optimal implies optimal tree sibling leaves maximum pth lemma lemma implies process building optimal tree mergers loss generality greedy choice merging hose characters lowest frequency greedy choice view cost single merger sum frequencies items merged exercise total cost tree constructed su costs mergers mergers step huffman chooses incurs cost lemma problem cons tructing optimal prefix codes optimal substructure property lemma alphabet frequency defined character characters minimum frequency alphabet characters removed character define tree representing optimal prefix code alphabet tree replacing leaf node internal node children represents optimal prefix code alphabet proof cost tree expressed terms cost tree compone costs equation conclude equivalently prove lemma contradiction suppose represent optimal prefix code exists tree loss generality lemma siblings tree common parent replaced leaf frequency yielding contradiction assumption represents optimal prefix code represent optimal prefix code alphabet theorem procedure huffman produces optimal prefix code proof lemmas exercises prove binary tree correspond optimal prefix code exercises optimal huffman code set frequencies based fibonacci numbers generalize answer optimal code frequencies fibonacci numbers exercises prove total cost tree code computed sum internal nodes combined frequencie children node exercises prove order characters alphabet frequencies monotonically decreasing exists optimal code codewo lengths monotonically increasing exercises suppose optimal prefix code set characters transmit code bits represent optimal prefix code lg bits hint bits structure tree discovered walk tree exercises generalize huffman algorithm ternary code codewords symbols prove yields optimal ternary codes exercises suppose data file sequence bit characters characters common maximum character equency minimum character frequency prove huffman coding case efficient ordinary bit fixed length code exercises compression scheme expect compress file randomly chosen bit characters single bit hint compare number files number encoded files prefix free codes term prefix codes standard literature theoretical foundations greedy methods beautiful theory greedy algorithms sk etch theory determining gree method yields optimal solutions involves combinatorial structures matroids theory cover cases greedy method applies exam ple cover activity selection problem huffman coding problem cover cases practical theory rapidly developed extended cover applications notes chapter references matroids matroid ordered pair satisfying conditions finite nonempty set nonempty family subsets called independent subsets hereditary satisfies property note set ø member element satisfies exchange property word matroid hassler whitney studying matric matroids elements rows matrix set rows independent linearly independent usual sense easy structure defines matroid exercise matroids graphic matroid sg defined terms undirected graph set sg defined set edges subset acyclic set edges independent subgraph forms forest graphic matroid closely mini mum spanning tree problem covered chapter theorem undirected graph sg matroid proof sg finite set hereditary subset forest forest putting removing edges acyclic set edges create cycles remains satisfies exchange property suppose gb forests acyclic sets edges edges theorem forest edges trees prove trees consisting single vertex edges edge forest duces number trees forest trees forest gb trees forest gb fewer trees forest forest gb tree vertices trees forest connected edge vertices trees forest edge connects vertices trees forest edge forest creating cycle satisfies exchange operty completing proof matroid matroid element extension preserving independence extension graphic matroid independent set edges edge extension addition create cycle independent subset matroid maximal extensions maximal contained larger inde pendent subset property theorem maximal independent subsets matroid size proof suppose contrary maximal independent subset exists larger maximal independent subset exchange property implies extendible larger independent set contradicting assumption maximal illustration theorem graphic matroid connected undirected graph maximal independent subset free tree edges connects vertices tree called spanning tree matroid weighted weight function assigns strictly positive weight element weight function extends subsets summation denote length edge graphic matroid total length edges edge set greedy algorithms weighted matroid problems greedy approach provide optimal solutions formulated terms finding maximum weight independent subset weighted matroid weighted matroid independent set maximized subset independent maximum weight optimal subset matroid weight element positive optimal subset maxima independent subsetšit helps large minimum spanning tree problem connected undirected graph length function positive length edge term length refer iginal edge weights graph reserving term weight refer weights asso ciated matroid asked subset edges connects vertices minimum total length view problem finding optimal subset matroid weighted matroid weight function w0 w0 larger maximum length edge weighted matroid weights positive optimal subset spanning tree minimum total length iginal graph maximal independent subset corresponds spanning tree w0 maximal independent subset independent subset maximizes quantity minimize algorithm optimal subset arbitrary matroid solve minimum spanning tree problem chapter algorithms minimum spa nning tree problem greedy algorithm works weighted matroid algorithm takes input weighted matroid positive weight function returns optimal subset pseudocode denote components weight function algorithm greedy considers element turn order monotonical ly decreasing weight imme diately adds set accumulated independent greedy ø sort monotonically decreasing order weight monotonically decreasing order weight return elements considered turn order monotonically decreasing weight element considered maintaining independence discarded set independent definition matroid independent subset independent induction greedy returns independent subset moment subset maximum weight optimal subset running time greedy easy analyze denote sorting phase greedy takes time lg executed times element execution requires check set independent check takes time entire algorithm runs time lg nf prove greedy returns optimal subset lemma matroids exhibit greedy choice property suppose weighted matroi weight function sorted monotonically decreasing order weight element independent exists exists exists optimal subset proof exists independent subset set nonempty optimal subset assume element weight greater observe implies independent hereditary choice ensures construct set choice independent exchange property repeatedly element preserving independence optimal optimal lemma proven element opt ion initially option lemma matroid element extension independent subset extension ø proof extension independent hereditary independent extension ø corollary matroid element extension ø extension independent subset proof corollary simply contrapositive lemma corollary element greedy error passing initial elements extension ø lemma matroids exhibit optimal substructure property element chosen greedy weighted matroid remaining problem finding maximum weight independent subset reduces finding maximum weight independent subset weighted matroid andthe weight function weight function restricted contraction element proof maximum weight independent subset independent subset conversely independent subset yields independent subset cases maximum weight solution yields maximum weight solution vice versa theorem correctness greedy algorithm matroids weighted matroid weight function greedy returns optimal subset proof corollary elements passed ove initially extensions ø forgotten element selected lemma implies greedy err adding exists optimal subset finally lemma implies remaining problem finding optimal subset matroid contraction procedure greedy sets remaining steps interpreted acting matroid independent independent sets subsequent operation greedy maximum weight independent subset operation greedy maximum weight independent subset exercises matroid finite set andk set subsets size exercises matrix field reals matroid set columns columns linearly independent exercises matroid matroid maximal maximal independent sets complements maximal independent sets exercises finite set s1 sk partition nonempty disjoint subsets define structure condition matroid set sets member block partition determines independent sets matroid exercises transform weight function weighted matroid problem desired optimal solution minimum weight maximal independent subset standard weighted matroid problem argue carefully transformation correct task scheduling problem interesting problem solved matroids problem optimally scheduling unit time tasks single proces sor task deadline penalty paid deadline missed problem complicated solved surp risingly simple manner greedy algorithm unit time task job program computer requires unit time complete finite set unit time tasks schedule permutation order tasks performed task schedule time finishes time task time finishes time problem scheduling unit time tasks deadlines penalties single processor inputs set unit time tasks set integer deadlines d1 dn satisfies task ai supposed finish time set nonnegative weights penalties w1 w2 wn incur penalty task ai finished time incur penalty task finishes deadline asked schedule minimizes total penalty incurred missed deadlines schedule task late schedule finishes deadline task early schedule arbitrary schedule early form early tasks precede late tasks note early task ai late task switch positions ai ai early late claim arbitrary schedule canonical form early tasks precede late tasks early tasks scheduled order monotonically increasing deadlines schedule early form long early tasks ai finishing respective times schedule swap positions ai early swap ai early swap task moved earlier schedule early swap search optimal schedule reduces finding set tasks early optimal schedule determined create actual schedule listing elements order monotonically increasing deadline listing late tasks order producing canonical ordering optimal schedule set tasks independent exists schedule tasks tasks late early tasks schedule forms independent set tasks denote set independent sets tasks problem determining set tasks independent denote number tasks deadline earlier note n0 set lemma set tasks statements equivalent set independent tasks scheduled order monotonically increasing deadlines task late proof schedule late tasks set tasks finish time implies holds follow stuck scheduling tasks order monotonically increasing deadlines implies ith largest deadline finally trivially implies property lemma easily compute set tasks independent exercise problem minimizing sum penalti late tasks problem maximizing sum penal ties early tasks theorem ensures greedy algorithm independent set tasks maximum total penalty theorem set unit time tasks deadlines set independent sets tasks matroid proof subset independent set tasks independent prove exchange property suppose independent sets tasks largest exists n0 n0 range tasks deadline ai task deadline ai independent property lemma independent independent independent completing proof matroid theorem greedy algorithm maximum weight independent set tasks create optimal schedule tasks early tasks method effi cient algorithm scheduling unit time tasks deadlines penalties single processor running time greedy independence checks algorithm takes time exercise faster implementation problem figure problem scheduling unit time tasks deadlines penalties single processor greedy gorithm selects tasks rejects a5 a6 finally accepts a7 final optimal schedule a7 a5 a6 total penalty incurred w5 w6 task ai figure instance problem scheduling unit time tasks deadlines penalties single processor exercises solve instance scheduling problem figure penalty replaced exercises property lemma determine time set tasks independent problems coin changing problem making change cents fewest number coins assume coin integer greedy algorithm change consisting quarters dimes nickels pennies prove algorithm yields optimal solution suppose coins denominations powers denominations c0 ck integers greedy algorithm yields optimal solution set coin denominations greedy algorithm yield optimal solution set include penny solution nk time algorithm change set coin denominations assuming coins penny problems scheduling minimize average completion time suppose set tasks task ai requires units processing time complete started computer tasks computer task time completion time task ai time task ai completes processing goal minimize average completion time minimize suppose tasks schedule runs average completion time algorithm schedules tasks minimize average completion time task preemptively task ai started continuously units time prove algorithm minimizes average completion time state running time algorithm suppose tasks task release time processed suppose preemption task suspended restarted time task ai processing time start running time preempted time resume time preempted time finally resume time complete time task ai total time units running time divided pieces completion time ai algorithm schedules tasks minimize average completion time scenario prove algorithm minimizes averag completion time state running time algorithm problems acyclic subgraphs undirected graph definition matroid matroid acyclic subset incidence matrix undirected graph matrix mve edge incident vertex mve argue set columns linearly independent field int egers modulo set edges acyclic result exercise provide alternate proof matroid suppose nonnegative weight edge undirected graph efficient algorithm acyclic subset maximum total weight arbitrary directed graph defined directed cycles directed graph matroid defining condition matroid fails hold incidence matrix directed graph matrix mve edge leaves vertex mve edge enters vertex mve argue set columns linearly independent set edges directed cycle exercise tells set linearly independent sets columns matrix forms matroid explain carefully parts ontradictory fail perfect correspondence notion set edges acyclic notion set columns incidence matrix linearly independent problems scheduling variations algorithm problem scheduling unit time tasks deadlines penalties time slots initially time slot unit length slot time finishes time tasks order monotonically decreasing penalty task exists time slot deadline assign latest slot filling slot assign task latest unfilled slots argue algorithm optimal answer fast disjoint forest presented implement algorithm efficiently assume set input tasks sorted monotonically decreasing order penalty analyze running time implementation chapter notes material greedy algorithms matroids lawler papadimitriou steiglitz greedy algorithm appeared combinatorial optimization literature article edmonds theory matroids dates article whitney proof correctness greedy gorithm activity selection problem based gavril task scheduling problem studied lawler horowitz sahni brassard bratley huffman codes invented lelewer hirschberg surveys data compression techniques extension matroid theory greedoid theory pioneered korte lov ász greatly generalize theory presented chapter amortized analysis overview amortized analysis time required perform seque nce data structure operations averaged operations performed ortized analysis average cost operation small averages sequence operations single operation sequence expensive amortized analysis differs average case analysis probabil ity involved amortized analysis guarantees average performance operation worst case sections chapter common techniques amortized analysis starts aggregate analysis determine upper bound total cost sequence operations average cost operation average cost amortized cost operation operations amortized cost covers accounting method determine amortized cost operation type operation type operation amortized cost accounting method overcharges operations early sequence storing overcharge prepaid credit specific objects data structure credit sequence pa operations charged cost discusses potential method accounting method determine amortized cost operati overcharge operations early compensate undercharges potential method maintains credit potential energy data structure associating credit individual objects data structure examples examine ree methods stack additional operation multipop pops objects binary counter counts single operation increment reading chapter bear mind charges assigned amortized analysis analysis purposes code credit assigned object accounting method assign attribute credit code insight data structure gained performing amortized analysis optimizing design potential method analyze dynamically expa nding contracting table aggregate analysis aggregate analysis sequence operations takes worst case time total worst case average cost amortized cost operation note amortized cost applies operation types operations sequence methods study chapter accounting method poten tial method assign amortized costs types operations stack operations aggregate analysis analyze stacks augmented operation presented fundamental stack operations takes time push pushes object stack pop pops stack returns popped object operations runs time cost total cost sequence push pop operations actual running time operations add stack operation multipop removes objects stack pops entire stack fewer objects pseudocode operation stack returns true ther objects stack false multipop stack pop figure multipop figure action multipop stack initially objects popped multipop result operation multipop empties stackšshown šsince fewer objects remaining running time multipop stack objects actual running time linear number pop operations actual ly executed suffices analyze multipop terms ract costs push pop number iterations loop number min objects popped stack iteration loop pop total cost multipop min actual running time linear function cost analyze sequence push pop multipop operations initially stack worst case cost ltipop operation sequence stack size worst case time stack operation sequence operations costs multipop operations costing analysis correct result worst case cost operation individually tight aggregate analysis upper bound considers entire sequence operations fact single multipop operation expensive sequence push pop multipop operations initially stack cost object popped time pushed number times pop called nonempty stack including calls multipop number push operations sequence push pop multipop ope rations takes total time average cost operation aggregate analysis assign amortized cost operation averag cost stack operations amortized cost emphasize average cost running time stack operation probabilistic reasoning involved worst case bound sequence operations dividing total cost yielded average cost operation amortized cost incrementing binary counter aggregate analysis problem implementing bit binary counter counts upward array bits length counter binary number stored counter lowest order bit highest order bit initially add modulo counter procedure increment length length figure binary counter incremented times starting initial lue start iteration loop lines œ4 add position adding flips bit position yields carry position iteration loop loop ends adding position flipping care cost increment operation linear number bits flipped figure bit binary counter sequence increment operations bits flip achieve shaded running cost flipping bits notice total cost total number increment operations stack cursory analysis yields bound correct tight single execution increment takes time worst case array sequence increment operations initially counter takes time nk worst case tighten analysis yield worst case cost sequence increment observing bits flip time increment called figure flip time increment called highest order bit flips time sequence increment operations initially counter flip times bit flips fourth time times sequence increment general lg bit flipsi times sequence increment operations initially counter lg bit flips total number flips sequence equation worst case time sequence increment operations initially counter average cost operation amortized cost operation exercises set stack operations included multipush operation pushes items stack bound amortized cost stack operations continue hold exercises decrement operation included bit counter operations cost nk time exercises sequence operations performed data structure ith operation costs exact power aggregate analysis determine amortized cost operation accounting method accounting method amortized analysis assi gn differing charges operations operations charged cost charge operation called amortized cost operation amortized cost exceeds actual cost difference assigned specific objects data structure credit credit pay operations amortized actual cost view amortized cost operation split actual cost credit deposited method aggregate analysis operations amortized cost choose amortized costs opera tions carefully analysis amortized costs worst case average cost operation small total amortized cost sequence operations upper bound total actual cost sequence aggregate analysis relationship hold sequences operations denote actual cost ith operation amortized cost ith operation require sequences operations total credit stored data structure difference total amortized cost total actual cost inequality total credit data structure nonnegative times total credit allowed negative result undercharging early operations promise repaying acc ount total amortized costs incurred time tal actual costs incurred sequence operations time total amorti zed cost upper bound total actual cost care total credit data structure negative stack operations illustrate accounting method amortized analysis return stack recall actual costs operations push pop multipop min argument supplied multipop stack size called assign amortized costs push pop multipop note amortized cost multipop constant actual cost variable amortized costs general amortized costs operations consideration differ asymptotically pay sequence stack operations charging amortized costs suppose dollar represent unit cost start stack recall analogy stack data structure stack plates cafeteria push plate stack dollar pay actual cost push left credit dollar dollars charged plate point time plate stack dollar credit dollar stored plate prepayment cost popping stack execute pop operation charge operation pay actual cost credit stored stack pop plate dollar credit plate pay actual cost operation charging sh operation bit charge pop operation charge multipop operati ons pop plate dollar credit plate pay actual cost pop operation pop plate dollar credit plate pay pop operation charged pay multipop operations plate stack dollar credit stack nonnegative number plates ensured credit nonnegative sequence push pop multipop operations total amortized cost upper bound total actual cost total amortized cost total actual cost incrementing binary counter illustration accounting thod analyze increment operation binary counter starts observed earlier running time operation proportional number bits flipped cost dollar represent unit cost flipping bit amortized analysis charge amorti zed cost dollars set bit bit set dollar dollars charged pay actual setting bit place dollar bit credit flip bit point time counter dollar credit charge reset bit pay reset dollar bit amortized cost increment determined cost resetting bits loop paid dollars bits reset bit set increment amortized cost increment operation dollars number ounter negative credit nonnegative increment operations total amortized cost bounds total actual cost exercises sequence stack operations performed stack size exceeds operations copy entire stack backup purposes cost stack operations including copying stack assigning suitable amortized costs stack operations exercises redo exercise accounting method analysis exercises suppose increment counter reset bits implement counter array bits sequence increment reset operations takes time initially counter hint pointer high order potential method representing prepaid work credit stored specific objects data structure potential method amortized analysis represents prepaid work potential energy potential released pay future operations potential data structure ther specific objects data structure potential method works start initial data structure d0 operations performed actual cost ith operation data structure applying ith operation data structure potential function maps data structure real number potential data structure amortized cost ith operation respect potential function defined amortized cost operation actual cost increase potential operation equation total amortized cost operations equality equation terms telescope define potential function dn d0 total amortized cost upper bound total actual cost practice operations performed require d0 guarantee accounting method pay advance convenient define d0 exercise easy handle cases d0 intuitively potential difference ith operation positive amortized cost represents overcharge ith operation potential data structure increases potential difference negative amortized cost represents undercharge ith operation actual cost operation paid decrease potential amortized costs defined equations depend choice potential function potential functions yield amortized costs upper bounds actual costs trade offs choosing potential function potential function depends desired time bounds stack operations illustrate potential method return stack operations push pop multipop define potential function stack number objects stack stack d0 start d0 number objects stack negative stack ith operation nonnegative potential d0 total amortized cost operations respect represents upper bound actual cost compute amortized costs stack operations ith operation stack objects push operation potential difference equation amortized cost push operation suppose ith operation stack multipop min objects popped stack actual cost operation potential difference amortized cost multipop operation amortized cost ordinary pop operation amortized cost operations total amortized cost sequence operations argued d0 total amortized cost operations upper bound total actual cost worst case cost operations incrementing binary counter poten tial method agai incrementi binary counter time define potential counter ith increment operation number counter ith operation compute amortized cost increment operation suppose ith increment operation resets bits actual cost operation addition resetting bits sets bit ith operation resets bits case potential difference amortized cost counter starts d0 total amortized cost sequence increment operations upper bound total actual cost worst case cost increment operations potential method easy alyze counter start initially b0 increment operations b0 recall number bits counter rewrite equation d0 b0 dn total actual cost increment operations note b0 long total actual cost execute increment operations total actual cost matter initial counter exercises suppose potential function d0 d0 exists potential function d0 amortized costs theamortized costs exercises redo exercise potential method analysis exercises ordinary binary min heap data structure elements supports instructions insert extract min lg worst case time potential function amortized cost insert lg amortized cost extract min works exercises total cost executing stack operations push pop multipop assuming stack s0 objects finishes objects exercises suppose counter number binary representation cost performing increment operations assume constant exercises implement queue ordinary stacks exercise amortized cost enqueue dequeue operation exercises design data structure support operations set integers insert inserts set delete larger half deletes largest elements explain implement data structure sequence operations runs time dynamic tables applications advance objects stored table allocate space table table reallocated larger size objects stored iginal table copied larger table simila rly objects deleted table worthwhile allocate table smaller size study problem dynamically expanding contr acting table amortized analysis amortized cost insertion deletion actual cost operation large triggers expansion contraction guarantee unused space dynamic table exceeds constant fraction total space assume dynamic table supports operations table insert table delete table insert inserts table item occupies single slot space item likewise table delete thought removing item table freeing slot details data structuring method organize table unimportant stack heap chapter hash table chapter array coll ection arrays implement object storage convenient concept introduced analysis hashing chapter define load factor nonempty table number items stored table divided size number slots table assign table items size define load factor load factor dynamic table bounded constant unused space table constant fraction total space start analyzing dynamic table whic insertions performed general case insertions deletions allowed table expansion assume storage table allocated array slots table fills slots equivalently load factor software environments attempt insert item table alternative abort error assume software environment modern memory managemen allocate free blocks storage request item inserted table expand table allocating table slots table table reside contiguous mory allocate array larger table copy items table table common heuristic allocate table slots insertions performed load factor table wasted space exceeds half total space table pseudocode assume object representing table field table pointer block storage representing table field num number items table field size total number slots table initially table num size table insert size allocate table slot size num size allocate table size slots insert items table table free table table table size size insert table num num notice insertion procedures table insert procedure elementary insertion table lines analyze running time table insert terms number elementary inse rtions assigning cost elementary insertion assume actual running time table insert linear time insert individual items overhead allocating initial table constant overhead allocating freeing storage lines dominated cost transferring items event clause lines œ9 executed expansion analyze sequence table insert operations initially table cost ith operation room current table operation perform elementary insert ion current table expansion occurs cost elementary insertion items copied table table operations performed wors case cost operation leads upper bound total running time operations bound tight cost xpanding table borne table insert operations ith operation expansion exact power amorti zed cost operation fact aggregate analysis cost ith operation total cost table insert operations operations cost costs remaining operations form geometric series total cost table insert operations amortized cost single operation accounting method gain feeling amortized cost table insert operation intuiti vely item pays elementary insertions inserting current tabl moving table expanded moving item moved table expanded suppose size table expansion number items table table credit charge dollars insertion elementary insertion occurs immedi ately costs dollar dollar credit item inserted dollar credit items table filling table requires additional insertions time table items item dollar pay reinsertion expansion potential method analyze sequence table insert operations design table delete operation amortized cost start defining potential function expansion builds ta ble size time table expansion paid potential function possibility expansion num size desired befo expansion num size num desired initial potential table half num size implies nonnegative sum amortized costs table insert operations upper bound sum actual costs analyze amortized cost ith table insert operation numi denote number items stored table ith operation sizei denote total size table ith operation denote potential ith operation initially num0 size0 ith table insert operation trigger expansion sizei sizei amortized cost operation numi sizei numi sizei numi sizei numi sizei ith operation trigger expansion sizei sizei sizei numi numi implies size numi amortized cost operation numi numi sizei numi sizei numi numi numi numi numi numi numi figure plots values numi sizei notice potential builds pay expansion table figure sequence table insert operations number numi items table number sizei slots table potential numi size measured ith operation numi dashed sizei thick notice expansion potential built number items tabl pay moving items table potential drops increased item caused expansion inserted table expansion contraction implement table delete operation simple remove item table desirable contract table load factor table small wasted space exorbitant table contraction analogous table expansion number items table drops low allocate smaller table copy items table storage table freed returning memory management ideally preserve properties load factor dynamic tabl bounded constant amortized cost table ope ration bounded constant assume cost measured rms elementary insertions deletions natural strategy expansion contraction double table size item inserted table halve size wh deletion caus table half strategy guarantees load factor table drops amortized cost operation large scenario perform operations table exact power operations insertions previous analysis cost total sequence insertions num size operations perform sequence stands insertion stands deletion insertion expansion table size deletions contraction table size insertions expansion cost expansion contraction total cost operations amortized cost operation difficulty strategy obvious expansion perform deletions pay contraction likewise contraction perform insertions pay expansion improve strategy allowing load factor table drop continue double table size item inserted table halve table size deletion table load factor table bounded constant idea expansion load factor table half items table deleted contraction occur contraction occur load factor fall likewise contraction load factor table number items table doubled insertions expansion occur expansion occurs load factor exceed omit code table delete analogous table insert convenient assume analysis number items table drops storage table freed num size potential method analyze cost sequence table insert table delete operations art defining potential function expansion contraction builds load factor increases decreases denote load factor nonempty table num size table num size num size table potential function observe potential table tential negative total amortized cost seque nce operations respect upper bound actual cost sequence proceeding precise analysis pause observe properties potential function notice load factor potential load factor size num implies num potential pay expansion item insert load factor size num implies num potential pay contraction item deleted figure illustrates potential behaves sequence operations figure sequence table insert table delete operations number numi items table number sizei slots table potential measured ith operation numi dashed sizei thick notice expansion potential built number items table pay moving items table likewise contracti potential built number items table analyze sequence table insert tab delete operations denote actual cost ith operation denote amortized respect numi denote number items stored table ith operation sizei denote total size table ith operation denote load factor table ith operation denote potential ith operation initially num0 size0 start case ith operation table insert analysis identical table expansion table expands amortized cost operation table expand result operation expansion occurs amortized cost ith operation sizei numi sizei numi sizei numi sizei numi numi sizei sizei numi numi sizei size numi numi sizei sizei sizei sizei sizei amortized cost table insert operation turn case ith operation table delete case numi numi ai operation contraction sizei size amortized cost operation sizei numi size numi sizei numi size numi ith operation trigger contraction actual cost operation numi delete item numi items sizei sizei numi numi amortized cost operation numi sizei numi sizei numi numi numi numi numi numi ith operation table delete amortized cost bounded constant analysis left exercise summary amortized cost operation bounded constant actual time sequence operations dynamic table exercises suppose implement dynamic open address hash table table load factor reaches strictly insertion dynamic open ddress hash table expected amortized cost insertion expected actual cost insertion insertions exercises ith operation dynamic table table delete amortized cost operation respect potential function bounded constant exercises suppose contracting table halving size load factor drops contract multiplying size load factor drops potential function num size amortized cost table delete strategy bounded constant problems bit revers binary counter chapter examines algorithm called fast fourier transform fft step fft algorithm performs bit reversal permutation input array length nonnegative integer permutation swaps elements indices binary representations reve rse express bit sequence ak ak a0 define revk ak ak a0 a0 ak equivalently revk bit representation reversed bit representation function revk runs time write algorithm perform bit reversal permutation array length nk time algorithm based amortized analysis improve running time bit reversal permutation maintain bit reversed counter procedure bit reversed increment ven bit reversed counter produces revk rev bit reversed counter starts successive calls bit reversed increment produce sequence assume computer store bit values unit time computer manipulate binary values operations shifting left arbitrary amounts bitwise bitwise implementation bit reversed incre ment procedure bit reversal permutation element array performed total time suppose shift word left bit unit time implement time bit reversal permutation problems making binary search dynamic binary search sorted array takes logarithmic search time time insert element linear size array improve time insertion keeping sorted arrays suppose support search insert set elements lg binary representation nk nk n0 sorted arrays a0 ak length array ai array pty depending total number elements held arrays individual array sorted relationship elements arrays perform search operation data structure analyze worst case running time insert element data structure analyze worst case amortized running times discuss implement delete problems amortized weight balanced trees ordinary binary search tree augmented adding node field size number keys stor subtree rooted constant range node balanced size left size size size tree balanced node tree balanced amortized approach maintaining weight alanced trees suggested varghese balanced tree sense balanced node arbitrary binary search tree rebuild subtree rooted balanced algorithm time size size auxiliary storage performing search node balanced binary search tree takes lg worst case time remainder probl assume constant strictly greater suppose insert delete implemented usual node binary search tree operation node tree longer balanced subtree rooted highest node tree rebuilt balanced analyze rebuilding scheme potential method node binary search tree define size left size define potential large constant depends argue binary search tree nonnegative potential balanced tree potential suppose units potential pay rebuilding node subtree large terms order amortized time rebuild subtree balanced inserting node deleting node node balanced tree costs lg amortized time problems cost structuring red black trees basic operations red black trees perform structural modifications node insertions node deletions rotations color modifications rb insert rb delete rotations node insertions node deletions maintain red black properties color modifications legal red black tree nodes calling rb insert add node lg color modifications legal red black tree nodes calling rb delete node lg color modifications worst case number color modifica tions operation logarithmic prove sequence rb insert rb delete operations initially red black tree structural modifications worst case cases handled main oop code rb insert fixup rb delete fixup terminating encountered loop terminate constant number add itional operations cases rb insert fixup rb delete fixup terminating hint figures analyze structural modificat ions insertions performed red black tree define number red nodes assume unit potential pay structural modifications performed cases rb insert fixup result applying case rb insert fixup argue node insertion red black tree rb insert broken parts list structural odifications potential lines œ16 rb insert nonterminating cas rb insert fixup terminating cases rb insert fixup argue amortized num ber structural modifications performed rb insert prove structural modifications insertions deletions define node redefine potential red black tree tree applying nonterminating case rb insert fixup rb delete fixup nonterminating cases rb insert fixup argue amortized numb structural modifications performed rb insert fixup nonterminating cases rb delete fixup argue amortized numb structural modifications performed rb delete fixup complete proof worst case sequence rb insert rb delete operations performs structural modifications situations open address hash table table load factor equals constant strictly exercise chapter notes aggregate analysis aho hopcroft ullman tarjan surveys accounting potential methods amortized anal ysis presents applications attributes accounting method author including brown tarjan huddleston mehlhorn attributes potential method sleator term amortized sleator tarjan potential functions proving lower bounds types problems configuration problem define potential function maps configuration real number determine potential init initial configuration potential final final configuration maximum change potential max step number steps final init max examples potential functions proving lower bounds complexity works cormen floyd aggarwal vitter krumme cybenko venkataraman applied potential functions prove lower bounds gossiping communicating unique item vert graph vertex advanced data structures chapter list chapter trees chapter binomial heaps chapter fibonacci heaps chapter data structures disjoint sets introduction returns examination data structures support operations dynamic sets advanced level iii chapters extensive amortized analysis techniques chapter chapter presents trees balanced earch trees designed stored magnetic disks magnetic sks operate slowly random access memory measure performance trees computing time dynamic set operations consume disk accesses performed tree operation number disk acce sses increases height tree low tree operations chapters implementations mergeable heaps support operations insert minimum extract min union union operation unites merges heaps data structures chapters support operations delete decrease key binomial heaps chapter support operations lg worst case time total number elements input heap input heaps case union union operation supported binomial heaps superior binary heaps introduced chapter takes time unite binary heaps worst case fibonacci heaps chapter improve binomial heaps theoretical sense amortized time bounds measure performance fibonacci heaps operations insert minimum union actual amortized time fibonacci heaps operati ons extract min delete lg amortized time advantage fibon acci heaps decrease key takes amortized time low amortized time decrease key operation fibonacci heaps key components asymptotically fastest algorithms graph problems finally chapter presents data structures disjoint sets universe elements grouped dynamic sets initially element belongs singleton set operation union unites sets query set identifies set element moment representing set simple rooted tree surprisingly fast operations sequence operations runs time incredibly slowly growing functionš onceivable application amortized analysis proves time bound complex data structure simple topics covered examples advanced data structures advanced data structures include dynamic trees introduced sleator tarjan discussed tarjan maintain forest disjoint rooted trees edge tree real valued cost dynamic trees support queries parent roots edge costs minimum edge cost path node root trees manipulated cutting edges updating edge costs path node root linking root tree making node root tree appears implementation dynamic trees lg amortized time bound operation complicated implementation yields lg worst case time bounds dynamic trees asymptotically fastest network flow algorithms splay trees developed sleator tarjan discussed tarjan form binary search tree standard search tre operations lg amortized time application splay trees simplifies dynamic trees persistent data structures queries updates versions data structure driscoll sarnak slea tor tarjan techniques making linked data structures persistent small time space cost problem simple persistent dynamic set data structures faster implementation dictionary operations insert delete search restricted universe keys advantage restrictions achieve worst case asymptotic running times comparison based data structures data structure invented van emde boas supports operations minimum maximum insert delete search extract min tract max predecessor successor worst case time lg lg subject restriction universe keys set fredman willard introduced fusion trees data structure allo faster dictionary operations universe restricted integers implement operations lg lg lg time subsequent data structures including exponential search trees improved bounds dictionary operations mentioned chapter notes book dynamic graph data structures support queries allowing structure graph change operations insert delete vertices edges examples queries upported include vertex connectivity edge connectivity minimum spanning trees biconnectivity transitive closure chapter notes book mention additional data structures problem defined mergeable heap support minimum extract min refer mergeable min heap alternatively supported maximum extract max mergeable max heap mergeable heaps default mergeable min heaps chapter trees overview trees balanced search trees designed work magnetic disks direct access secondary storage devices trees red black trees chapter minimizing disk operations database systems trees variants trees store trees differ red black trees tree nodes children handful thousands branching factor tree large determined characteristics disk unit trees red black trees node tree height lg height tree considerably red black tree ecause branching factor larger trees implement dynamic set operations time lg trees generalize binary search trees natural manner figure simple tree internal tree node keys children keys node dividing points separating range keys handled subranges handled child searching key tree decision based comparisons keys stored node structure leaf nodes differs ternal nodes examine differences figure tree keys consonants english internal node keys children leaves depth tree lightly shaded nodes examined search letter precise definition trees proves height tree grows logarithmically number nodes describes search key insert key tree discusses deletion proceeding data ructures designed work magnetic disk evaluated differently data structures designed work main random access memory data structures secondary storage technologies providing memory capacity computer primary memory main memory computer consists silicon memory chips technology typi cally orders magnitude expensive bit stored magnetic storage technol ogy tapes disks computer systems secondary storage based magnetic disks secondary storage exceeds primary memory leas orders magnitude figure typical disk drive drive consists platters rotate constant speed common spindle surface pla tter covered magnetizable material pla tter read written head arm arms physically attached ganged toge ther heads spindle head stationary surface passes underneath called track read write heads vertically igned times set tracks underneath accessed simultaneously figure set tracks cylinder figure typical disk drive composed platters rotate spindle platter read written head arm arms ganged heads unison arms rotate common pivot axis track surface passes ben eath read write head stationary cylinder consists set covertical tracks disks cheaper higher capacity main memory slower moving parts components mechanical motion platter rotation arm movement writin commodity disks rotate speeds œ15 revolutions minute rpm rpm common rpm fast rotation takes milliseconds orders magnitude longer nanosecond access times commonly silicon memory wait rotation item read write head access main memory times span average wait half rotation difference access times silicon memory disks enormous moving arms takes time writing average access times commodity disks range milliseconds order amortize time spent waiting mechanical movements disks access item time divided number equal sized bits consecutively cylinders disk read wr ite entire typical disk bytes length read write head positioned correctly disk rotated desired reading writing magnetic disk electronic rotation disk large amounts data read written takes time access inform ation read disk takes computer examine read eason chapter separately princi pal components running time number disk accesses cpu computing time number disk accesses measured term number read written disk note disk access time constantšit depends distance current track desired track initial rotational state disk number read written order approximation tal time spent accessing disk typical tree application data handled large data fit main memory tree algor ithms copy selected disk main memory needed write disk changed tree algorithms designed constant number memory time size main memory limit size trees handled model disk operations pseudocode pointer object object computer main memor refer fields object usual key object referred resides disk perform operation disk read read object main memory refer fields assume main memory disk read requires disk accesses operation disk write save fields object typical pattern working object pointer object disk read operations access modify fields disk write fields changed operations access modify fields limited number main memory time assume longer flushed main memory tree algorithms ignore issue systems running time tree algorithm determined number disk read disk write operations performs operations efficiently read write tree node large sk number children tree node limited size disk large tree stored disk branching factors depending size key relative size large branching factor dramatically reduces height tree numbe disk accesses required key figure tree branching factor height store billion keys root node permanently main memory disk accesses requir key tree figure tree height billion keys internal node leaf keys nodes pth leaves depth inside node number keys definition trees things simple assume binary search trees red black trees satellite stored node key practice store key pointer disk satellite key pseudoc ode chapter implicitly assumes satellite key pointer satellite travels key key moved node node common variant tree tree stores satellite leaves stores keys child pointers internal nodes maximizing bran ching factor internal nodes tree rooted tree root root properties node fields number keys stored node keys stored nondecreasing order key1 key2 keyn leaf boolean true leaf false internal node internal node pointers children leaf nodes children fields undefined keys keyi separate ranges keys stored subtree ki key stored subtree root k1 key1 k2 key2 keyn kn leaves depth tree height lower upper bounds number keys node bounds expressed terms fixed integer called minimum degree tree node root keys internal node root children tree nonempty root key node keys internal node children node keys simplest tree occurs internal node children tree practice larger values typically height tree number disk accesses required operations tree proportional height tree analyze worst case height tree theorem key tree height minimum degree proof tree height root key nodes keys nodes depth nodes depth nodes depth depth nodes figure illustrates tree number keys satisfies inequality figure tree height minimum number keys inside node simple algebra base logarithms bot sides proves theorem power trees compared red black trees height tree grows lg cases recall constant trees base logarithm times larger trees save factor lg red black trees number nodes examined tree operations examining arbitrary node tree requires disk access number disk accesses reduced exercises minimum degree exercises values tree figure legal tree exercises legal trees minimum degree represent exercises function minimum degree maximum number keys stored tree height exercises data structure result black node red black tree absorb red children incorporating children common variant tree tree requires internal node east half tree requires basic operations trees operations tree search tree create tree insert procedures adop conventions root tree main memory disk read root required disk write root required root node changed nodes passed parameters disk read operation performed procedures pass gorithms proceed downward root tree searching tree searching tree earching binary search tree making binary branching decision node multiway branching decision number node children precisely internal node branching decision tree search straightforward generalization tree search procedure defined binary search trees tree search takes input pointer root node subtree key searched subtree level form tree search root tree tree search returns ordered pair consisting node keyi nil returned tree search keyi keyi return leaf return nil disk read return tree search linear search procedure lines smallest keyi set lines check discovered key returning lines terminate search unsuccessfully leaf recurse search appropr iate subtree performing disk read child figure illustrates operation tree arch lightly shaded nodes examined search key tree search procedure binary search trees nodes encountered recursion form path downw ard root tree number disk accessed tree search logt height tree number keys tree time loop lines node total cpu time logt creating tree build tree tree create create root node tree insert add keys procedures auxiliary procedure allocate node allocates disk node time assume node created allocate node requires disk read informati stored disk node tree create allocate node leaf true disk write root tree create requires disk operations cpu time inserting key tree inserting key tree complicated inserting key binary search tree binary search trees search leaf position insert key tree simply create leaf node insert tree fail valid tree insert key existing leaf node insert key leaf node introduce operation splits node keys median key keyt nodes keys median key moves parent identify dividing point trees parent split key inserted split nodes propagate tree binary search tree insert key tree single pass tree root leaf split node order insertion travel tree searching position key belongs split node including leaf wh enever split node assured parent splitting node tree procedure tree split child takes input nonfull internal node assumed main memory node assumed main memory child procedure splits child adjusts additional child split root ill root child root node tree split child tree grows height splitting tree grows figure illustrates process node split median key moved parent node keys greater median key node child figure splitting node node split nodes median key moved parent tree split child allocate node leaf leaf keyj keyj leaf downto downto keyj keyj keyi keyt disk write disk write disk write tree split child works straightforward cutting pasting ith child node split node originally children keys reduced children keys operation node adopts largest children keys child positioned table children median key moves key separates lines create node larger keys children adjusts key count finally lines insert child median key order separate adjust key count lines write modified disk cpu time tree split child loops lines loops iterations procedure performs disk operations inserting key tree single pass tree insert key tree height single pass tree requiring disk accesses cpu time required logt tree insert procedure tree split child guarantee recursion descends node tree insert root allocate node root leaf false tree split child tree insert nonfull tree insert nonfull lines handle case root node root split node children root splitting root increase height tree figure illustrates case binary search tree tree increases height procedure finishes calling tree insert nonfull perform insertion key tree rooted nonfull root node tree insert nonfull recurses tree times guaranteeing node recurses calling tree split child figure splitting root root node split root node created root median key halves children tree grows height root split auxiliary recursive procedure tree insert nonfull inserts key node assumed nonfull ocedure called operation tree insert recursive operation tree insert nonfull guarantee assumption true tree insert nonfull leaf keyi keyi keyi keyi disk write keyi disk read tree split child keyi tree insert nonfull tree insert nonfull procedure works lines handle case leaf node inserting key leaf node insert leaf node subtree rooted internal node case lines determine child recursion descends detects recursion descend child case tree split child split child nonfull children lin determine children correct descend note disk read increments recursion descend case child created tree split child net lines guarantee procedure recurses node recurses insert subtree figure illustrates cases inserting tree figure inserting keys tree minimum degree tree node hold keys nodes modified inser tion process lightly shaded initial tree result inserting initial tree simple insertion leaf node result inserting previous tree node rstuv split nodes uv key moved root inserted leftmost halves node result inserting previous tree root split tree grows height inserted leaf jk result inserting previous tree node abcde split inserted rightmost halves node number disk accesses rformed tree insert tree height disk read disk write operations performed calls tree insert nonfull total cpu time logt tree insert nonfull tail recursive alternatively implemented loop demonstrating number main memory time exercises inserting keys order tree minimum degree draw configurations tree node split draw final configuration exercises explain circumstances redundant disk read disk write operations performed executing tree insert redundant disk read disk read memory redundant disk write writes disk identical stored exercises explain minimum key stored tree predecessor key stored tree exercises suppose keys inserted tree minimum degree nodes final tree exercises leaf nodes require pointers children conceivably larger internal nodes sk size modify procedures creating inserting tree handle variation exercises suppose tree search implemented binary search linear search node change cpu time required lg independently chosen function exercises suppose disk hardware choose size disk arbitrarily time takes read disk constants minimum degree tree selected size choose minimize tree search time optimal case milliseconds microseconds deleting key tree deletion tree analogous insertion complicated key deleted node leaf deletion internal node requires node children rearranged inserti guard deletion producing tree structure violates tree properties ensure node big insertion ensure node small deletion root allowed fewer minimum number keys allowed maximum number keys simple insertion algorithm node path key inserted simple approach deleti node root path key deleted minimum number keys assume procedure tree elete asked delete key subtree rooted procedure structured guarantee tree delete called recursively node number keys minimum degree note condition requires key minimum required usual tree conditions key moved child node recursion descends child rengthened condition delete key tree downward pass exception explain specification deletion tree interpreted understanding root node internal node keys situation occur cases deleted child root tree decreasing height tree preserving property root tree key tree sketch deletion works presenting pseudocode figure illustrates cases deleting keys tree figure deleting keys tree minimum degree tree node root fewer keys nodes modified lightly shaded tree figure deletion case simple deletion leaf deletion case predecessor moved position deletion case pushed node degjk deleted leaf case deletion case recursion descend node keys pushed merged form clptx deleted leaf case root deleted tree shrinks height deletion case moved position moved position key node leaf delete key key node internal node child precedes node keys predecessor subtree rooted recursively delete replace finding deleting performed single downward pass symmetrically child node keys successor subtree rooted recursively delete replace finding deleting performed single downward pass keys merge loses pointer keys free recursively delete key internal node determine root subtree tree keys execute step guarantee descend node keys finish recursing child keys immedi ate sibling keys extra key moving key moving key left sibling moving child pointer sibling siblings keys merge sibling involves moving key merged node median key node keys tree leaves expect practice deletion operations delete keys leaves tree delete procedure acts downward pass tree deleting key internal node procedure ward pass tree return node key deleted replace key predecessor successor cases procedure complicated involves disk operations tree height calls disk read disk write recursive invocations procedure cpu time required logt exercises deleting order tree figure exercises write pseudocode tree delete problems stacks secondary storage implementing stack computer small fast primary memory large slower disk storage operations push pop supported single word values stack support grow larger fit memory stored disk simple inefficient stack implementation entire stack disk maintain memory stack pointer disk ddress element stack pointer element mod word disk number implement push operation increment stack pointer read memory disk copy element pushed word write disk pop operation decrement stack pointer read disk retu stack write modified disk operations expensive count costs implementation total number disk accesses total cpu time disk access incurs charges disk access cpu time asymptotically worst case number disk accesses stack operations simple implementati cpu time stack operations express answer terms subsequent parts stack implementation stack memory maintain small memory track memory perform stack operation relevant disk resides memory memory written disk read disk memory relevant sk memory disk accesses required worst case number disk accesses required push operations cpu time worst case number disk accesses required stack operations cpu time suppose implement stack keeping memory addition small number bookkeeping manage stack amortized number disk accesses stack operation amortized cpu time stack operation problems joining splitting trees join operation takes dynamic sets element key key key returns set split operation inverse join dynamic set element creates set consisting elements keys key set consisting elements keys greater key problem investigate implement operations ees assume convenience elements consist keys key values distinct maintain node tree height subtree rooted field height impl ementation affect asymptotic running times sear ching insertion deletion implement join operation trees key join time heights path root tree key set keys set keys greater breaks set trees set keys keys relationship heights breaks sets trees keys implement split operation join operation assemble keys single tree keys single tree running time split operation lg number keys hint costs joining telescope chapter notes knuth aho hopcroft ullman sedgewick discussions balanced tree schemes trees comer comprehensive survey trees guibas sedgewick discuss relationships kinds balanced tree schemes including red black trees trees hopcroft invented trees precursor trees trees internal node children trees introduced bayer mccreight explain choice bender demaine farach colton studied trees perform presence memory hierarchy effects cache oblivious algorithms work efficiently explicitly knowing data transfer sizes memory hierarchy chapter binomial heaps overview chapter chapter data structures mergeable heaps support operations heap creates returns heap elements insert inserts node key field filled heap minimum returns pointer node heap key minimum extract min deletes node heap key minimum returning pointer node union h1 creates returns heap nodes heaps h1 heaps h1 destroyed operation addition data structures chapters support operations decrease key assigns node heap key assumed great current key delete deletes node heap table figure union operation ordinary binary heaps heapsort chapter work operations union worst case time lg binary heap union operation supported binary heaps perform concat enating arrays hold binary heaps merged running min heapify exercise union operation takes time worst case procedure binary heap worst case binomial heap worst case fibonacci heap amortized heap insert lg lg minimum lg extract min lg lg lg union lg decrease key lg lg delete lg lg lg figure running times operations implementations mergeable heaps number items heap time operation denoted chapter examine binomial heaps worst case time bounds figure union operation takes lg time merge binomial heaps total elements chapter explore fibonacci heaps wh ich time bounds operations note running times fibonacci heaps figure amortized time bounds worst case operation time bounds chapter ignores issues allocating nodes prior insertion freeing nodes deletion assume code calls heap procedures deals details binary heaps binomial heaps fibonacci heap inefficient support operation search node key reason operations decrease key delete refer node require pointer node input discussion priority queues mergeable heap pplication store handle application object mergeable heap element handle mergeable heap element pplication object exact nature handles depends application implementation defines binomial heaps afte defining constituent binomial trees introduces representation binomial heaps implement operations binomial heaps time bounds figure mentioned introduction default mergeable heaps mergeable min heaps operations minimum extract min decrease key apply alternatively define mergeable max heap operations maximum extract max increase key binomial trees binomial heaps binomial heap collection binomial trees sect ion starts defining binomial trees proving key properties define binomial heaps represented binomial trees binomial tree ordered tree defined recursively figure binomial tree b0 consists single node binomial tree consists binomial trees linked root leftmost child root figure binomial trees b0 b4 figure recursive definition binomial tree triangles represent rooted subtrees binomial trees b0 b4 node depths b4 binomial tree properties binomial trees lemma lemma properties binomial trees binomial tree nodes height tree nodes depth root degree greater node children root numbered left child root subtree proof proof induction property basis binomial tree b0 verifying property holds b0 trivial inductive step assume lemma holds binomial tree consists copies nodes copies linked form maximum depth node greater maximum depth inductive hypothesis maximum depth number nodes depth binomial tree composed copies linked node depth appears depth depth number nodes depth number nodes depth number nodes depth node greater degree root child root degree root degree inductive hypothesis figure left children root roots b0 linked children root roots b0 corollary maximum degree node node binomial tree lg proof properties lemma term binomial tree property lemma terms binomial coefficients exercise justification term binomial heaps binomial heap set binomial trees satisfies binomial heap properties binomial tree obeys min heap property key node greater equal key pa rent tree min heap ordered nonnegative integer binomial tree root degree property tells root mi heap ordered tree smallest key tree property implies node binomial heap consists lgn binomial trees observe binary representation lg bits blg blg b0 property lemma binomial tree appears bit binomial heap lg binomial trees figure binomial heap nodes binary representation consists min heap rdered binomial trees b0 nodes total nodes figure binomial heap nodes heap consists binomial trees b0 nodes totaling nodes binomial tree min heap ordered key node key parent root list linked list roots order increasing degree detailed representation binomial heap binomial tree stored left child sibling representation node stores degree representing binomial heaps figure binomial tree binomi heap stored left child sibling representation node key field satellite required application addition node pointers parent child leftmost child sibling sibling node root nil node children child nil rightmost child parent sibling nil node field degree number children figure roots binomi trees binomial heap organized linked list refer root list degrees roots strictly increase traverse root list binomial heap property node binomial heap degrees roots subset lg sibling field meaning roots nonroots root sibling points root root list usual sibling nil root root list binomial heap accessed field head simply pointer root root list binomial heap elements head nil exercises suppose node binomial tree binomial heap assume sibling nil root degree sibling compare degree root exercises nonroot node binomial binomial heap degree compare degree exercises suppose label nodes binomial tree binary postorder walk figure node labeled depth binary representation binary strings degree equal number rightmost binary representation figure binomial tree b4 nodes labeled binary postorder walk operations binomial heaps perform operations nomial heaps time bounds figure upper bounds lower bounds left exercise creating binomial heap binomial heap binomial heap procedure simply allocates returns object head nil running time finding minimum key procedure binomial heap minimum retu rns pointer node minimum key node binomial heap implementation assumes keys exercise binomial heap minimum nil head min nil key min min key sibling return binomial heap min heap ordered minimum key reside root node binomial heap minimum procedure chec ks roots number lg saving current minimum min pointer current minimum called binomial heap figure binomial heap minimum returns pointer node key lg roots check running time binomial heap minimum lg uniting binomial heaps operation uniting binomial heaps subroutine remaining operations binomial heap union procedure repeatedly links binomial trees roots degree procedure links tree rooted node tree rooted node parent node root tree binomial link sibling child child degree degree binomial link procedure node head linked list node children time works left ild sibling representation binomial tree matches orderi property tree tree leftmost child root root tree procedure unites binomial heaps h1 returning heap destroys representations h1 process binomial link procedure auxiliary procedure binomial heap merge merges root lists h1 single linked list sorted degree monotonically increasing order binomial heap merge proce dure pseudocode leave exercise merge procedure binomial heap union h1 binomial heap head binomial heap merge h1 free objects h1 lists point head nil return prev nil head sibling nil degree degree sibling nil degree sibling degree prev cases cases key key sibling sibling case binomial link case prev nil case head case sibling prev case binomial link case case sibling return figure binomial heap uni cases pseudocode occur figure execution binomial heap union binomial heaps h1 binomial heap output binomial heap merge h1 initially root root list degree key key case applies link occurs root degree case applies pointers position root list case applies roots equal degree link occurs case applies link case applies degree degree iteration loop pointers position root list nil binomial heap union procedure phases phase performed binomial heap merge merges root lists binomial heaps h1 single linked list sorted degree monotonically increasing order roots degree phase links roots equal degree root remains degree linked list sorted degree perform link operations procedure works lines start merging root lists binomial heaps h1 single root list root lists h1 sorted strictly increasing degree binomial merge returns root list sorted monotonically increasing degree root lists h1 roots altogether binomial heap merge runs time repeatedly examining roots heads root lists appending root lower degree output root list removing input oot list process binomial heap union procedure initia lizes pointers root list simply returns lines uniting binomial heaps root procedure maintain pointers root list points root examined prev points root preceding root list sibling prev initially predecessor start prev set nil points root root list sibling initially roots root list degree h1 binomial heaps root degree binomial heap merge guarantees roots degree adjacent root list fact execution binomial heap union roots degree appearing root list time moment situation occur iteration loop lines decide link based degrees degree sibling invariant loop time start body loop nil exercise precise loop invariant case figure occurs degree degree root tree root tree lines handle case link simply march poi nters position farther list updating point node node handled common case figure cases occur binomial heap union labels serve identify roots involved degrees keys roots case root tree case degree degree pointers position farther root list case degree degree degree sibling pointers position farther list iteration executes case case case degree degree degree sibling key key remove root list link creating tree case degree degree degree sibling key key remove root list link creating tree case figure occurs oots equal degree degree degree degree sibling handle case manner case march pointers position farther list iteration ecute case case combine equal degree roots tests cases lines handle cases cases occur roots equal degree degree degree degree sibling cases occur iteration occurs case cases link cases distinguished smaller key determines node root linked case figure key key linked removes root list leftmost child case figure smaller key linked lines remove root list cases depending root list leftmost child updates iteration case case setup iteration loop linked trees form tree points trees root list binomial heap merge trees root list enter case iteration degree degree enter case case iteration enter case iteration running time nomial heap union lg total number nodes binomial heaps h1 h1 n1 nodes nodes n1 h1 lg n1 roots lg roots lg n1 lg lg lg roots nomial heap merge time perform binomial heap merge lg iteration loop takes time lg n1 lgn2 iterations iteration advances pointers position root list removes root root list total time lg inserting node procedure inserts node binomial heap assuming allocated key filled binomial heap insert binomial heap nil child nil sibling nil degree head binomial heap union procedure simply node binomial heap time unites node binomial heap lg time binomial heap union takes care freeing temporary binomial heap direct implementation binomial heap union exercise extracting node minimum key procedure extracts node minimum key binomial heap returns pointer extracted node binomial heap extract min root minimum key root list remove root list binomial heap reverse order linked list children set head point head list binomial heap union return procedure works figure input binomial heap figure figure situation root minimum key removed root list root tree property lemma children left roots b0 trees figure reversing list children binomial heap node tree tree removed binomial heap uniting figure nodes originally finally returns figure action binomial heap extract min binomial heap root minimum key removed root list linked list children reversed binomial heap result uniting lines takes lg time nodes binomial heap extract min runs lg time decreasing key procedure decreases key node binomial heap signals error greater current key binomial heap decrease key key error key greater current key key nil key key exchange key key satellite fields exchange figure procedure decreases key manner binary min heap bubbling key heap ter ensuring key fact greater current key assigning key procedure tree initially pointing node iteration loop lines key checked key parent root key key binomial tree min heap ordered node violates min heap ordering key exchanged key parent satellite procedure sets level tree continues iteration figure action binomial heap decrease key situation iteration loop node key decreased key parent keys nodes exchanged situation iteration pointers moved level tree min heap order violated exchange moving pointers level min heap order satisfied loop terminates binomial heap decreas key procedure takes lg time property lemma maximum depth lg loop lines iterates lg times deleting key easy delete node key satellite binomial heap lg time implementation assumes node binomial heap key binomial heap delete binomial heap decrease key binomial heap extract min binomial heap delete procedure node unique minimum key entire binomial heap key exercise deals situation key temporaril bubbles key satellite root calling binomial heap decrease key root removed binomial heap extract min binomial heap delete procedure takes lg time exercises write pseudocode binomial heap merge exercises binomial heap node key inserted binomial heap figure exercises binomial heap node key deleted binomial heap figure exercises argue correctness binomial heap union loop invariant start iteration loop lines points root root degree roots degree roots degree roots preceding predecessor root li unique degrees root list predecessor degree degree root list unique finally node degrees monotonically increase traverse root list exercises explain binomial heap minimum pro cedure work correctly keys rewrite pseudocode work correctly cases exercises suppose represent key rewrite binomial heap delete procedure work correctly situation lg time exercises discuss relationship inserting binomial heap incrementing binary number relationship uniting binomial heaps adding binary numbers exercises light exercise rewrite binomial heap insert insert node directly binomial heap cal ling binomial heap union exercises root lists strictly decreasing order degree strictly increasing order binomial heap ope rations implemented changing asymptotic running time exercises inputs binomial heap extract min binomial heap decrease key binomial heap delete lg time explain worst case running times binomial heap insert binomial heap minimum binomial heap union lg problem problems heaps chapter introduced tree internal node root children eaves depth problem implement heaps support mergeable heap operations heaps differ trees ways heaps leaves store keys leaf stores key field key ordering keys leaves left keys order internal node small equal smallest key stored leaf subtree rooted root field height height tree finally heaps intended main memory disk reads writes needed implement heap operations ach operations parts lg time heap elements union operation lg time number elements input heaps minimum returns pointer leaf smallest key decrease key decreases key leaf key insert inserts leaf key delete deletes leaf extract min extracts leaf smallest key union unites heaps retu rning single heap stroying input heaps problems minimum spanning tree algorithm binomial heaps chapter presents algorithms solve problem finding minimum spanning tree undirected graph binomial heaps devise minimum spanning tree algorithm connected undirected graph weight function weight edge minimum spanning tree acyclic subset connects vertices total weight minimized pseudocode proven correct techniques constructs minimum spanning tree maintains partition vi vertices set vi set vi vi edges incident vertices vi mst ø vertex vi vi vi vi set vi choose set vi extract minimum weight edge assume loss generality vi vi vi destroying implement algorithm ing binomial heaps manage vertex edge sets change represen tation binomial heap add operations mergeable heap operations figure running time implementation chapter notes binomial heaps introduced vuillemin brown studied properties chapter fibonacci heaps overview chapter binomial heaps support lg worst case time mergeable heap operations insert minimum extract min union operations decrease key delete chapter examine fibonacci heaps support operations advant age operations involve deleting element amortized time theoretical standpoint fibonacci heaps desirable number extract min delete operations small lative number operations performed situatio arises applications algorithms graph problems decrease key edge dense graphs edges amortized time decrease key adds big improvement lg worst case time binary binomial heaps fast algorithms problems computing minimum spanning trees chapter finding single source shortest paths chapter essential fibonacci heaps practical point view constant factors programming complexity fibonacci heaps desirable ordinary binary ary heaps applications fibonacci heaps predomin antly theoretical simpler data structure ortized time bounds fibonacci heaps developed practical binomial heap fibonacci heap coll ection trees fibonacci heaps fact loosely based binomial heaps decrease key delete invoked fibonacci heap tree heap binomial tree fibona cci heaps relaxed structure binomi heaps allowing improved asymptotic time bounds work maintains ructure delayed convenient perform dynamic tables fibonacci heaps offer good data structure designed amortized analysis mind intuition analyses fibonacci heap operations remai nder chapter rely heavily potential method exposition chapter assumes read chapter binomial heaps specifications operations chapter table figure summarizes time bounds operations nary heaps binomial heaps fibonacci heaps presentation structure fibonacci heaps relies binomial heap structure operations performed fibonacci heaps performed binomial heaps binomial heaps fibonacci heaps designed efficient support operation search operations refer ven node require pointer node input bonacci heap application store handle appl ication object fibonacci heap element handle fibonacci heap element application object defines fibonacci heaps discusses representation presents potential function amortized analysis implement mergeable heap operations achieve amortized time bounds figure remaining operations decrease key delete presented finally finishes key analysis explains curious data structure structure fibonacci heaps binomial heap fibonacci heap collection min heap ordered trees trees fibonacci heap constraine binomial trees figure fibonacci heap figure fibonacci heap consisting min heap ordered trees nodes dashed root list minimum node heap node key marked nodes blackened potential fibonacci heap complete repres entation showing pointers arrows child arrows left sideways arrows details remaining figures chapter determined appears trees binomial heaps ordered trees fibonacci heaps rooted unordered figure node pointer parent pointer child children children linked circular doubly linked list child list child child list pointers left point left siblin node child left order siblings child list arbitrary circular doubly linked lists advantages fibonacci heaps remove node circular doubly linked list time lists concatenate splice circular doubly linked list time descriptions fibonacci heap operations refer operations informally letting reader details implementations fields node number ildren child list node stored degree boolean valued field mark node lost child time child anothe node newly created nodes unmarked node unmarked child node decrease key operation set mark fields false fibonacci heap accessed pointer min root tree minimum key node called minimum node fibonacci heap fibonacci heap min nil roots trees fibonacci heap linked left pointers circular doubly linked list called root list fibonacci heap pointer min points node root list key minimum order trees root list arbitrary rely attribute fibonacci heap number nodes potential function mentioned potential method analyze performance fibonacci heap operations fibonacci heap number trees root list number marked nodes potential fibonacci heap defined gain intuition potential function potential fibonacci heap figure potential set fibonacci heaps sum potentials constituent fibonacci heaps assume unit potential pay onstant work constant large cover specific constant time pieces work encounter assume fibonacci heap application heaps initial potential equation potential nonnegative subsequent times equation upper bound total amortized cost upper bound total actual cost sequence operations maximum degree amortized analyses perform maining sections chapter assume upper bound maximum degree node node fibonacci heap exercise mergeable heap operations supported lg support decrease key delete lg mergeable heap operations analyze mergeable heap operations implemented fibonacci heaps operations heap insert minimum extract min union supported fibonacci heap simply collection unordered binomial trees unordered binomial tree binomial tree defined recursively unordered binomial tree u0 consists single node unordered binomial tree consists unordered binomial trees root child root lemma properties binomial trees holds unordered binomial tree variation property exercise unordered binomial tree root degree greater node children root roots subtrees u0 u1 order node fibonacci heap collecti unordered binomial trees lg key idea mergeable heap operations fibonacci heaps delay work long performance trade ong implementations operations number trees bonacci heap small extract min operation determine maining nodes minimum node binomial heaps exercise pay price ensuring number trees small lg time insert node binomial heap unite binomial heaps shal attempt consolidate trees fibonacci heap insert node unite heaps save consolidation extract min operation minimum node creating fibonacci heap fibonacci heap heap procedure allo cates returns fibonacci heap object min nil trees potential fibonacci heap amortized cost fib heap equal actual cost inserting node procedure inserts node fibonacci heap assuming node allocated key filled fib heap insert degree nil child nil left mark false concatenate root list root list min nil key key min min lines initialize structural fields node making circular doubly linked list adds root list actual time node single node min heap ordered tree unordered binomial tree fibonacci heap children unmarked lines update pointer minimum node fibonacci heap finally increments reflect addition node figure node key insert fibonacci heap figure figure inserting node fibonacci heap fibonacci heap fibonacci heap node key inserted node min heap ordered tree root list left sibling root binomial heap insert procedure fib heap insert attempt consolidate trees fibonacci heap consecutive fib heap insert operations occur single node trees root list determine amortized cost fib heap insert input fibonacci heap fibonacci heap increase potential actual cost amortized cost finding minimum node minimum node fibonacci heap pointer min minimum node actual time potential change amortized cost operation equal actual cost uniting fibonacci heaps procedure unites fibonacci heaps h1 destroying h1 process simply concatenates root lists h1 determines minimum node fib heap union h1 fib heap min min h1 concatenate root list root list min h1 nil min nil min min h1 min min h1 free objects h1 return lines concatenate root lists h1 root list lines set minimum node sets total number nodes fibonacci heap objects h1 freed turns fibonacci heap fib heap insert procedure consolidation trees occurs change potential h1 h1 h1 h1 h1 amortized cost fib heap union equal actual cost extracting minimum node process extracting minimum node complicated operations presented delayed work consolidating trees root list finally occurs pseudocode tracts minimum node code assumes convenience node removed linked list pointers remaining list updated pointers extracted node left unchanged auxiliary procedure consolidate presented shortly fib heap extract min min nil child add root list nil remove root list min nil min consolidate return figure fib heap extract min works making root minimum node children remo ving minimum node root list consolidates root list linking roots equal degree root remains degree figure action fib heap extract min fibonacci heap situation minimum node removed root lis children root list array trees iterations loop lines procedure consolidate root list processed starting node pointed min pointers values iteration iteration loop values iteration loop lines situation time loop node key linked node key pointed node key linked node key pointed node key linked node key node pointed loop iteration set point root tree situation iterations loop fibonacci heap reconstruction root list array determination min pointer start saving pointer minimum node pointer returned nil fibonacci heap binomial heap extract min procedure delete node making children roots lines putting root list removing root list node root list children remains bonacci heap returning set pointer min root list point node case minimum node fib heap extract min figure fibonacci heap figure performed step reduce number trees fibonacci heap consolidating root list performed consolidate consolidating root list consists repeatedly executing steps root root list distinct degree roots root list degree key key link remove root list child operation performed fib heap link procedure field degree incremented mark cleared procedure consolidate auxiliary array root degree consolidate nil node root list degree nil node degree key key exchange fib heap link nil min nil nil add root list min nil key key min min fib heap link remove root list child incrementing degree mark false consolidate procedure works lines initialize making entry nil loop lines processes root root list processing root ends tree rooted node identical processed roots degree set array entry degree point loop terminates root degree remain array point remaining root loop lines repeatedly links root tree node tree root degree root degree loop maintains invariant start iteration loop degree loop invariant initialization ensures loop invariant holds time enter loop maintenance iteration loop points root degree degree link whichever smaller key parent othe result link operation lines exchange pointers link fib heap link increments degree leaves degree node longer root pointer array removed heap link increments degree restores invariant degree termination repeat loop nil case root degree loop terminates set perform iteration loop figures array trees iterations loop lines iteration loop links occur figures figures result iterations loop remains clean loop lines completes empties root list lines reconstruct array fibonacci heap figure consolidating root list fib heap extract min finishes decrementing returning pointer deleted node observe trees fibonacci heap unordered binomial trees fib heap extract min executed unordered binomial trees afterward ways trees changed lines fib heap extract min child root root exercise tree unordered binomial tree trees linked fib heap link degree trees unordered binomial ees link occurs trees roots children structure tree structure ready amortized cost extracting minimum node node fibonacci heap denote fibonacci heap prior fib heap extract min operation actual cost extracting minimum node accounted contribution children minimum node processed fib heap extract min work lines consolidate remains analyze contribution loop lines size root list calling consolidate consists original root list nodes minus extracted root node children extracted node number time loop lines roots linked total work performed loop proportional total actual work extracting minimum node potential extracting minimum node potential afterward roots remain nodes marked operation amortized cost scale units potential dominate constant hidden intuitively cost performing link pa reduction potential link reducing number roots lg amortized cost extracting minimum node lg exercises fibonacci heap calling fib heap extract min fibonacci heap figure exercises prove lemma holds unordered binomial trees property place property exercises mergeable heap ope rations supported maximum degree node fibonacci heap lg exercises professor mcgee devised data structure based fibonacci heaps mcgee heap structure fibonacci heap supports mergeable heap operations implementations operations fibonacci heaps insertion union perform consolidation worst case running times operations mcgee heaps professor data structure exercises argue operations keys comparing keys case implementations chapter mergeable heap operations amortized time decreasing key deleting node decrease key node fibonacci heap amortized time delete node node fibonacci heap amortized time operations preserve property trees fibonacci heap unordered binomial trees close bound maximum degree lg proving bound imply fib heap extract fib heap delete lg amortized time decreasing key pseudocode operation fib heap decrease key assume removing node linked list change structural fields removed node fib heap decrease key key error key greater current key key nil key key cut cascading cut key key min min cut remove child list decrementing degree add root list nil mark false cascading cut nil mark false mark true cut cascading cut fib heap decrease key procedure works lines ensure key greater current key assign key root key key parent structural occur min heap order violated lines test condition min heap order violated occur start cutting cut procedure cuts link parent making root mark fields desired time bounds record piece history node suppose events happened node time root linked node children removed cuts child lost cut parent making root field mark true steps occurred child cut cut procedure clears mark performs step fib heap link clears mark node linked node step performed time child cut mark set true child cut parent time linked node fib heap decrease key performs cascading cut operation root test cascading cut proc edure return unmarked procedure marks child ha cut returns marked lost child cut cascading cut calls recursively parent cascading cut pro cedure recurses tree root unmarked node cascading cuts occurred lines fib heap decrease key finish updating min node key changed node key decreased mi nimum node iginal minimum node node figure execution calls fib heap decrease key starting fibonacci heap figure figure involves cascading cuts figures invokes cascading cuts figure calls fib heap decrease key initial fibonacci heap node key key decreased node root parent key unmarked marked node key key decreased node key root parent key marked cascading cut occurs node key cut parent unmarked root nother cascading cut occurs node key marked node cut parent unmarked root cascading cuts point node key root node root cascading cuts unmarke result fib heap decrease key operation min pointing minimum node amortized cost fib heap decrease key start determining actual cost fib heap decrease key procedure takes time time perform cas cading cuts suppose cascading cut recursively called times invocation fib heap decrease key cascading cut takes time exclusive recursive calls actual cost fib heap decrease key incl uding recursive calls compute change potential denote fibonacci heap prior fib heap decrease key operation recu rsive cascading cut cuts marked node clears mark bit afterward trees original trees trees produced cascading cuts tree rooted marked nodes unmarked cascading cascading cut marked node ange potential amortized cost fib heap decrease key scale units potential dominate constant hidden potential function defined include term number marked nodes marked node cut cascading cut mark bit cleared potential reduced unit potential pays cut clearing mark bit othe unit compensates unit increase potential node root deleting node easy delete node node fibonacci heap amortized time pseudocode assume key fibonacci heap fib heap delete fib heap decrease key fib heap extract min fib heap delete analogous binomial heap delete minimum node fibonacci heap uniquely small key node removed fibonacci heap fib heap extract min procedure amortized time fib heap delete sum amortized time fib heap decrease key amortized time fib extract min lg amortized time fib heap delete lg exercises suppose root fibonacci heap marked explain marked root argue matte analysis marked root linked node lost child exercises justify amortized time fib heap decrease key average cost operation aggregate analysis bounding maximum degree prove amortized time heap extract min fib heap delete lg upper bound degree node node fibonacci heap lg exercise trees fibonacci heap unordered binomial trees lg cuts occur fib heap decrease key trees fibo nacci heap violate unordered binomial tree properties cut node parent loses children lg logn key analysis node fibonacci heap define size number nodes including subtree rooted note root list node size exponential degree bear mind degree maintained accurate count degree lemma node fibonacci heap suppose degree y1 yk denote children order linked earliest latest degree y1 degree yi proof degree y1 note yi linked y1 yi children degree node yi linked degree degree yi degree yi time node yi lost child cut lost children conclude degree yi finally analysis explains fibonacci heaps recall kth fibonacci number defined recurrence lemma express fk lemma integers proof proof induction assume inductive hypothesis lemma corollary complete analysis equality proved exercise fk golden ratio defined equation lemma node fibonacci heap degree size fk proof sk denote minimum ssible size nodes degree trivially s0 s1 number sk size sk increases monotonically lemma y1 yk denote children order linked compute lower bound size count child y1 size y1 lemma degree yi monotonicity sk sdegree yi induction sk fk nonnegative integer bases trivial induc tive step assume size sk fk corollary maximum degree node node fibonacci heap lg proof node node fibonacci heap degree lemma size base logarithms log fact integer log maximum degree node lg exercises professor pinocchio claims height node fibonacci heap lg professor mistaken exhibiting positive integer sequence fibonacci heap operations creates bonacci heap consisting tree linear chain nodes exercises suppose generalize cascading cut rule cut node parent loses kth child integer constant rule values lg problems alternative implementation deletion professor pisano proposed variant fib heap delete procedure claiming runs faster node deleted node pointed min pisano delete min fib heap extract min nil cut cascading cut add child list root list remove root list professor claim procedure uns faster based partly assumption performed actual time wrong assumption good upper bound actual time pisano delete min bound terms degree number calls cascading cut procedure suppose pisano delete fibonacci heap assuming node root bound potential terms degree conclude amortized time pisano delete asymptotically fib heap delete min problems fibonacci heap operations augment fibonacci heap support operations changing amortized running time fibonacci heap operations operation fib heap change key key node efficient implementation fib heap change key analyze amortized running time implementation cases greater equal key efficient implementation fib heap prune deletes min nodes nodes deleted arbitrary analyze amortized running time implementation hint modify data structure potential function chapter notes fibonacci heaps introduced fredman tarjan paper describes application fibonacci heaps problems single source shortest paths pairs shortest paths weighted bipartite matc hing minimum spanning tree problem subsequently driscoll gabow shrairman tarjan developed relaxed heaps alternative fibonacci heaps rieties relaxed heaps amortized time bounds fibonacci heaps decrease key worst case amortized time extract min delete lg worst case time relaxed heaps dvantages fibonacci heaps parallel algorithms chapter notes chapter data structures support fast decrease key operations sequence values returned extract min calls monotonically increasing time data integers specific range chapter data structures disjoint sets applications involve grouping distinct elements llection disjoint sets operations finding element belongs uniting sets chapter explores methods main taining data structure supports operations describes operations supported disjoint set data structure presents simple application simple linked lis implementation disjoint sets efficient representati rooted trees running time tree representation linear practical purposes theoretically superlinear defines discusses growing function slowly growing inverse appears running time operations tree based implementation amortized analysis prove upper bound running time barely superlinear disjoint set operations disjoint set data structure maintains collection disjoint dynamic sets set identified representative member set applications matter member representative care representative dynamic modifying set requests answer times applications prespecified rule choosing representative choosing smallest member set assuming elements ordered dynamic set implementations studied element set represented object letting denote object support operations set creates set memb representative sets disjoint require set union unites dynamic sets sx set union sets assumed disjoint prior operation representative set member sx implementations union choose representative sx representative require sets collection disjoint destroy sets sx removing collection set returns pointer representative unique set chapter analyze running times disj oint set data structures terms parameters number set operations total number set union set operations sets disjoint union operation reduces number sets union operations set remains number ion operations note set operations included total number operations assume set operations operations performed application disjoint set data structures applications disjoint set data structures arises determining connected components undirected graph figure graph connected components figure graph connected components collection disjoint sets edge processed procedure connected components llows disjoint set operations compute connected components graph connected components preprocessing step procedure component answers queries vertices connected component set vertices graph denoted set edges denoted connected components vertex set edge set set union component set set return true return false procedure connected components initially places vertex set edge unites sets exercise edges processed vertices connected component objects set connected components computes sets procedure component determine vertices connected component figure illustrates disjoint sets computed connected components actual implementation connect components algorithm representations graph disjoint set data structure ould reference object representing vertex pointer disjoint set object vice versa programming details pend implementation language address exercises suppose connected components undirected graph edges processed order list vertices connected component iteration lines exercises edges processed connected components vertices connected component set exercises execution connected components undirected graph connected components times set called times union called express answers terms edges graph static changing time connected components computed faster depth search exercise edges dynamically maintain connected components edge case implement ation efficient running depth search edge linked list representation disjoint sets simple implement disjoint set data structure represent set linked list object linked list serves set representative object linked list set member pointer object set member pointer representative list maintains pointers head representative tail object list figure sets linked list objects order subject sumption object list representative figure linked list representations sets objects representative objects representative object list set member pointer object list pointer object list representative list pointers head tail objects result union representative set linked list representation set set easy requiring time carry set create linked list object set return pointer representative simple implementation union simplest implementation union opera tion linked list set representation takes time set set figure perform union appending list list tail pointer list append list representative set element originally repres entative set update pointer representative object originally list takes time linear length list fact difficult sequence operations objects requires time suppose objects execute sequence set operations union operations figure spend time performing set operations ith union operation updates objects total number objects updated union operations operation number objects updated set set set union union union x4 union figure sequence operations objects takes time time operation average linked list set representation simple implementation union total number operations operation average requires time amortized operation weighted union heuristic worst case implementation union procedure requires average time appending longer list shorter list update pointer repres entative member longer list suppose list includes length list easily maintained append smaller list longer ith ties broken arbitrarily simple weighted union heuristic single union operation time sets members theore sequence set union set operations set operations takes lg time theorem linked list representation disjoint sets weighted union heuristic sequence set union set operations set operations takes lg time proof start computing object set size upper bound number times object pointer presentative updated fixed object time representative pointer updated started smaller set time representative pointer updated set mbers time representative pointer updated set ha members ontinuing observe representative poi nter updated lg times set members largest set members object representative pointer updated lg times union operations account updating head tail pointers list lengths time union operation total time updating objects lg time entire sequence operations easily set set operation takes time total time entire sequence lg exercises write pseudocode set union linked list representation weighted union uristic assume object attribute rep pointing representative set set attributes head tail size equals length list exercises data structure answers returned set operations program linked list repres entation weighted union heuristic set union union union x5 union x11 x13 union x10 set set x9 assume sets size operation union appends list list exercises adapt aggregate proof theorem amortized time bounds set set lg union linked list representation weighted union heuristic exercises tight asymptotic bound running time sequence operations figure assuming linked list representati weighted union heuristic exercises simple change union procedure linked list representation removes tail pointer object list weighted union heuristic change change asymptotic running time union procedure hint appending list splice disjoint set forests faster implementation sjoint sets represent sets rooted trees node member tree representing set disjoint set forest illustrated figure member points parent root tree representative parent straightforward algorithms representation faster linked list representation introducing heuristics union rank path comp ression achieve asymptotically fastest disjoi set data structure figure disjoint set forest trees representing sets figure tree left represents set representative tree represents set representative result union perform disjoint set operations set operation simply creates tree node perf orm set operation parent pointers root tree nodes visited path root constitute path union operation figure root tree point root heuristics improve running time improved li nked list implementation sequence union operations create tree linear chain nodes heuristics achieve running time lmost linear total number operations heuristic union rank weighted uni heuristic linked list representation idea root tree fewer nodes point root tree nodes explicitly keeping track size subtree rooted node approach eases analysis node maintain rank upper bound height node union rank root smaller rank point root larger rank union operation heuristic path compression simple effective figure set operations node path point directly root path comp ression change ranks figure path compression opera tion set arrows loops roots tree representing set prior executing set triangles represent subtrees roots nodes node pointer parent set executing set node path points directly root pseudocode disjoint set forests implement disjoint set forest ion rank heuristic track ranks node maintain integer rank upper bound height number edges longest path descendant leaf singleton set created set initial rank single node tree set operation leaves ranks unchanged applying union trees ere cases depending roots equal rank roots unequal rank root higher rank parent root lower rank ranks themse lves remain unchanged stead roots equal ranks arbitrarily choose roots parent increment rank method pseudocod designate parent node link procedure subroutine called union takes pointers roots inputs set rank union link set set link rank rank rank rank rank rank set procedure path compression simple set set return set procedure pass method pass path root pass pa update node points directly root set returns root executed returned case recursion bottoms executed recursive parameter returns pointer root updates node point directly root pointer returned heuristics running time separately union rank path compression improves running time operations disjoint set forests improvement greater heuristics union rank yields running time lg exercise bound tight exercise prove set operations union operations set operations path compression heuristic worst case running time log2 union rank path compression worst case running time slowly growing function define conceivable application disjoint set data structure view running time linear practical situations prove upper bound exercises exercise disjoint set forest union rank path compression exercises write nonrecursive version set path compression exercises sequence set union set operations set operations takes lg time union rank exercises sequence set set link operations link operations set operations takes time path compression union rank situation path compression heuristic analysis union rank path compression running time combined union rank path compression heuristic disjoint set operations elements examine function slowly grows prove running time potential method amortized analysis growing function slowly growing inverse integers define function ak expression functional itera tion notation refer parameter level function function ak strictly increases function grows closed form expressions lemma integer proof induction base case inductive step assume finally note lemma integer proof induction base case inductive step assume finally note ak grows simply examining ak levels definition a0 lemmas a0 estimated number atoms observable universe define inverse function ak integer min ak lowest level ak values ak impractically large values greater huge number practical purposes properties ranks remainder prove bound running time disjoint set operations union rank path compression order prove bound prove simple properties ranks lemma nodes rank rank strict inequality rank initially increases time rank change rank monotonically increases time proof proof straightforward induction number operations implementations set uni set leave exercise corollary follow path node root node ranks strictly increase lemma node rank proof node rank starts incr eases link operations union operations link operations link operation leaves ranks increases node rank ranks lemma weak bound ranks fact node rank lg exercise looser bound lemma suffice purposes proving time bound potential met hod amortized analysis prove time bound performing amortized anal ysis convenient assume invoke link operation union operation parameters link procedure pointers roots assume set operations performed separately followi lemma count extra set operations induced union calls asymptotic running time remains unchanged lemma suppose convert sequence set union set operations sequence set link set operations turning union set operations link sequence runs time sequence runs time proof union operation sequence converted operations time bound converted sequence implies time bound original sequence remainder sh assume initial sequence set union set opera tions converted sequence set link set operations prove time bound converted sequence appeal lemma prove running time original sequence operations potential function potential function assigns potential node disjoint set forest operations sum node potentials potential entire forest denotes potential forest operations forest prior operation arbitrarily set potential negative depends tree root qth operation rank rank suppose qth operation root rank define auxiliary functions define define level max rank ak rank level greatest level ak applied rank greater parent rank claim rank rank lemma a0 rank definition a0 implies level rank ak strictly increasing definition rank lemma implies level note rank monotonically increases time level auxiliary function iter largest number tim iteratively apply alevel applied initially rank greater parent rank claim implies iter implies iter rank note rank monotonically increases time order iter decrease level increase long level remains unchanged iter increase remain unchanged auxiliary functions place ready define potential node operations lemmas properties node potentials lemma node operation counts rank proof root rank rank definition suppose root rank lower bound maximizing level iter bound level bound iter rank rank rank rank rank upper bound minimizing level iter bound level bound iter rank rank rank potential amortized costs operations ready examine disjoint operations affect node potentials understanding change potential operation determine operation amortized cost lemma node root suppose qth operation link set qth operation rank level iter qth operation potential increase positive rank level iter potential drops proof root qth operation change rank change initial set operations remains unchanged components formula potential remain qth operation rank assume rank recall level monotonically increases time qth operation leaves level unchanged iter increases rema ins unchanged level iter unchanged level unchanged iter increases increases finally qth operation increases level increases term level rank drops rank level increased iter drop bound drop rank increase potential change iter decrease potential change level conclude final lemmas amor tized cost set link set operation recall equation amortized cost operation actual cost increase potential operation lemma amortized cost set operation proof suppose qth operation set operation creates node rank ranks potentials change noting actual cost set operation completes proof lemma amortized cost link operation proof suppose qth operation link actual cost link operation loss generalit suppose link parent determine change potential link note nodes potentials change children prior operation node potential increase link increase lemma node child link potential increase link definition root qth operation rank rank level rank iter rank inequalities quantity potential decreases root prior link rank link operation leaves root leaves rank increases rank increase potential link operation amortized cost link operation lemma amortized cost set operation proof suppose qth operation set path nodes actual cost set operation node potential increases set max nodes path potential decrease node potential creases appeal lemma nodes root root potential rank change max nodes potential decrease node path rank path node root level level set operation node follow path nodes path satisfy constraints satisfy node path rank node path root node path level node potential decreases level level prior path compre ssion caused set putting inequalities letting iter path compression path compression parent path compression rank rank path compression decrease rank rank change path compression path compression iter increase level increase occurs iter increases rank case lemma potential decreases amortized cost set operation actual cost change potential actual cost total potential decreases max amortized cost scale units potential dominate constant hidden putting preceding lemmas yields theorem theorem sequence set union set operations set operations performed disjoi set forest union rank path compression worst case time proof lemmas exercises prove lemma exercises prove node rank lg exercises light exercise bits store rank node exercises exercise simple proof operations disjoint set forest union rank path compression lg time exercises professor dante reasons node ranks increase strictly path root node levels monotonically increase path rank root level level professor correct exercises function min ak lg practical values exercise modify potential function argument prove sequence set union set operations set operations performed disjoint set forest union rank path compression worst case time problems minimum minimum problem asks maintain dynamic set elements domain operations insert extract min sequence insert extract min calls key inserted determin key returned extract min array extracted extracted key returned ith extract min problem sense allowed process entire sequence determining returned keys instance minimum problem insert represented number extract min represented letter correct values extracted array develop algorithm problem break sequence homogeneous subsequences represent i1 represents single extract min represents sequence insert calls subsequence initially place keys inserted operations set minimum determine extracted smallest greater set kl exists kl kl destroying return extracted argue array extracted returned minimum correct implement minimum efficiently disjoint set data structure tight bound worst case running time implementation problems depth determination depth determination problem maintain forest rooted trees operations tree creates tree node depth returns depth node tree graft node assumed root tree child node assumed tree root suppose tree representation disjoint set forest parent node root implement graft setting depth path root returning count nodes encountered worst case running time sequence tree depth graft operations union rank path compressi heuristics reduce worst case running time disjoint set forest set tree corresponds tree forest tree structure set correspond fact implementation record exact parent child relationships determine node depth key idea maintain node pseudodistance defined sum pseudodistances path root set equals depth path root v0 v1 vk v0 vk root depth implementation tree modify set impl ement depth implementation perform path compression runn ing time linear length path implementation updates pseudodistances correctly implement graft combines sets modifying union link procedures implementation updates pseudodistances correctly note root set root tree tight bound worst case running time sequence tree depth graft operations tree operations problems tarjan east common ancestors algorithm common ancestor nodes rooted tree node ancestor greatest depth common ancestors problem rooted tree arbitrary set unordered pairs nodes determine common ancestor pair solve common ancestors problem procedure performs tree walk initial lca root node assumed colored white prior walk lca set ancestor set child lca union ancestor set color black node color black print common ancestor ancestor set argue executed pair argue time lca number sets disjoint set data structure equal depth prove lca correctly prints common ancestor pair analyze running time lca assuming implementation disjoint set data structure chapter notes disjoint set data structures tarjan aggregate analysis tarjan tight upper bound terms slowly growing inverse ackermann function function ak ackermann function function inverse conceivable values lg upper bound proven earlier hopcroft ullman treatment adapted analysis tarjan turn based analysis kozen harfst reingold potential based version tarjan earlier bound tarjan van leeuwen discuss variants path compression heuristic including pass methods offer constant factors performance pass methods tarjan earlier analyses basic path compression heuristic analyses tarjan van leeuwen aggregate harfst reingold change potential function adapt path compression analysis pass variants gabow tarjan applications disjoint set operations time tarjan lower bound time required operations disjoint set data structure satisfying technical conditions lower bound generalized fredman saks worst case lg bit memory accessed vi graph algorithms chapter list chapter elementary graph algorithms chapter minimum spanning trees chapter single source shortest paths chapter pairs shortest paths chapter maximum flow introduction graphs pervasive data structure puter science algorithms working fundamental field hund reds interesting computational problems defined terms graphs touch chapter represent graph computer discusses algorithms based searching graph breadth search depth search applications depth search topologically sorting directed acyclic graph decomposing directed graph connected components chapter describes compute minimum ight spanning tree graph tree defined weight conn ecting vertices edge weight algorith computing minimum spanning trees good examples greedy algorithms chapter chapters problem computing hortest paths vertices edge length weight chapter considers computation shortest paths source vertex vertices chapter considers computation shortest paths tween pair vertices finally chapter compute maximum flow material network directed graph source material sink capacities material traverse directed edge general problem arises forms good algor ithm computing ximum flows solve variety problems efficiently describing running time graph algorithm graph measure size input rms number vertices number edges graph relevant parameters describing size input adopt common notational conventi parameters inside asymptotic notation notation notation inside notation symbol denotes symbol denotes algorithm runs time meaning algorithm runs time convention running time formulas easier ead risk ambiguity convention adopt appears pseudocode denote rtex set graph edge set pseudocode views vertex edge sets attributes graph chapter elementary graph algorithms chapter presents methods representing graph searching graph searching graph systematically edges graph visit vertices graph graph searching algorithm discover structure graph algorithms searching input graph structural graph algorithms organized simple ela borations basic graph searching algorithms techniques searching graph heart field graph algorithms discusses common computat ional representations graphs adjacency lists adjacency matrices presents simple graph searching algorithm called breadth search create breadth tree presents depth search proves andard order depth search visits vertices real application depth search topologically sorting directed acyclic graph application depth search finding connected components directed graph representations graphs standard ways represent graph collection adjacency lists adjacency matrix eith applicable directed undirected graphs adjacency list representation eferred compact represent sparse graphs graph algorithms presented book assume input graph represented adjacency list form adjacency matrix representation preferred graph dense close edge connecting vertices tw pairs shortest paths algorithms presented chapter assume input graphs represented adjacency matrices adjacency list representation graph consists array lists vertex adjacency list vertices edge consists vertices adjacent alternatively pointers thes vertices vertices adjacency list typically stored arbitrary order figure adjacency list representation undirected graph figure figure adjacency list representation directed graph figure figure representations undirected graph undirected graph vertices edges adjacency list representation adjacency matrix representation figure representations directed graph directed graph vertices edges adjacency list representation adjacency matrix representation directed graph sum ngths adjacency lists edge form represented undirected graph sum lengths adjacency lists undirected edge appears adjacency list vice versa bo directed undirected graphs adjacency list representation desirable property memory requires adjacency lists adapted represent weighted graphs graphs edge weight typically weight function weighted graph weight function weight edge simply stored vertex adjacency list adjacency list representation robust modified support graph variants potential disadvantage adjacency list representation quicker determine edge graph search adjacency list disadvantage remedied adjacency matrix representation graph cost asymptotically memory exercise suggestions variations adjacency lists permit faster edge lookup adjacency matrix representation graph assume vertices numbered arbitrary manner adjacency matrix representation graph consists matrix aij figures adjacency matrices undirected directed graphs figures adjacency matrix graph requires v2 memory independent number edges graph observe symmetry main diagonal adjacency matrix figure define transpose matrix aij matrix undirected graph represent edge adjacency matrix undirected graph transpose applications pays store entries diagonal adjacency matrix cutti memory needed store graph half adjacency list representation aph adjacency matrix representation weighted graphs weighted graph edge weight function weight edge simply stored entry row column adjacency matrix edge exist nil stored matrix entry problems convenient adjacency list representation asymptotically efficient adjacency matrix representation simplicity adjacency matrix preferable graphs small graph unweighted additional advantage storage adjacency matrix representation word computer memory matrix entry jacency matrix bit entry exercises adjacency list representation rected graph long compute degree vertex long compute degrees exercises adjacency list representation complete binary tree vertices equivalent adjacency matrix representation assume vertices numbered binary heap exercises transpose directed graph graph gt gt edges reversed efficient algorithms computing gt adjacency list adja cency matrix representations analyze running times algorithms exercises adjacency list representation multigraph time algorithm compute adjacency list repres entation equivalent undirected graph consists edges multiple edges vertices replaced single edge loops removed exercises square directed graph graph g2 g2 edge path edges efficient algo rithms computing g2 adjacency list adjacency matrix representations analyze running times algorithms exercises adjacency matrix representation graph algorithms require time v2 exceptions determining directed graph universal sink vertex degree degree determined time adjacency matrix exercises incidence matrix directed graph matrix bij entries matrix product represent transpose exercises suppose linked list array entry hash table vertices edge lookups equally expected time determine edge graph disadvantages scheme alternate data structure edge list solves problems alternative disadvantages compared hash table breadth search breadth search simplest algorithms searching graph archetype graph algorithms prim minimum spanning tree algorithm dijkstra single source shortest paths algorithm ideas breadth search graph distinguished source vertex breadth search systematically explores edges discover vertex reachable computes distance smallest number edges reachable vertex produces breadth fir tree root reachable vertices vertex reachable path breadth tree corresponds shortest path path smallest number edges algorithm works directed undirected graphs breadth search named expands frontier discovered undiscovered vertices uniformly breadth frontier algorithm discovers vertices distance discovering vertices distance track progress breadth search colors vertex white gray black vertices start white ecome gray black vertex discovered time encountered search time nonwhite gray black vertices discovered breadth search distinguishes ensure search pro ceeds breadth manner vertex black vertex gray black vertices adjacen black vertices discovered gray vertices adjacent white vertices represent frontier discovered undiscovered vertices breadth search constructs breadth tree initially root source vertex white vertex discovered scanning adjacency list discovered vertex vertex edge tree predecessor parent breadth tree vertex discovered parent ancestor descendant relationships breadth tree defined relative root usual path tree root vertex ancestor descendant breadth search procedure bfs assumes input graph represented adjacency lists maintains additi onal data structures vertex graph color vertex stored variable color predecessor stored variable predecessor discovered nil distance source vertex computed algorithm stored algorithm queue manage set gray vertices bfs vertex color white nil color gray nil ø enqueue ø dequeue color white color gray enqueue color black figure illustrates progress bfs sample graph figure operation bfs undirected graph tree edges shaded produced bfs vertex queue iteration loop lines vertex distances vertices queue procedure bfs works lines paint vertex white set infinity vertex set parent vertex nil paints source vertex gray considered discovered procedure initializes sets predecessor source nil lines initialize queue vertex loop lines iterates long remain gray vertices discovered vertices adjacency lists fully examined loop maintains invariant test queue consists set gray vertices loop invariant prov correctness easy holds prior iteration iteration loop maintains invariant prior iteration gray vertex vertex source vertex determines gray vertex head queue removes loop lines considers vertex adjacency list white discovered algorithm disc overs executing lines grayed distance set recorded parent finally tail queue vertices adjacency list examined blackened lines loop invariant maintained vertex painted gray enqueued vertex dequeued painted black breadth search depe order neighbors vertex visited breadth tree distances computed algorithm exercise analysis proving properties breadth search easier job analyzing running time input graph aggregate analysis initialization vertex whitened test ensures vertex enqueued dequeued operations enqueuing dequeuing time total time devoted queue operations adjacency list rtex scanned vertex dequeued adjacency list scanned sum lengths adjacency lists total time spent scanning adjacency lists overhead initialization total running time bfs breadth search runs time linear size adjacency list representation shortest paths claimed breadth search finds distance reachable vertex graph source vertex define shortest path distance minimum number edges path vertex vertex path path length shortest path showing breadth search computes shortest path distan ces investigate importa property shortest path distances lemma directed undirected graph arbitrary vertex edge proof reachable case shortest path longer shortest path edge inequality holds reachable inequality holds bfs properly computes vertex bounds lemma directed undirected graph suppose bfs source vertex termination vertex computed bfs satisfies proof induction number enqueu operations inductive hypothesis basis induction situation imme diately enqueued bfs inductive hypothesis holds inductive step onsider white vertex discovered search vertex inductive hypothesis implies assignment performed lemma vertex enqueued enqueued grayed clause lines executed white vertices inductive hypothesis maintained prove precisely queue operates bfs lemma times distinct values queue lemma suppose execution bfs graph queue vertices v1 v2 vr v1 head vr tail vr v1 vi vi proof proof induction number queue operations initially queue lemma holds inductive step prove lemma holds dequeuing enqueuing vertex head v1 queue dequeued v2 head queue lemma holds vacuously inductive hypothesis v1 v2 vr v1 v2 remain ing inequalities unaffected lemma v2 head enqueuing vertex requires closer examination code enqueue vertex bfs vr time removed vertex adjacency list scanned queue inductive hypothesis head v1 v1 vr v1 inductive hypothesis vr vr vr remaining inequalities una ffected lemma enqueued corollary values time vertices enqueued monotonically increasing time corollary suppose vertices vi enqueued execution bfs vi enqueued vi time enqueued proof lemma property vertex receives finite bfs prove breadth search correctly finds shortest path distances theorem correctness breadth search directed undirected graph suppose bfs source vertex execution bfs discovers vertex reachable source termination vertex reachable shortest paths shortest path edge proof assume purpose contradi ction vertex receives equal shortest path distance vertex minimum receives incorrect lemma vertex reachable vertex preceding shortest path chose putting properties time bfs chooses dequeue vertex time vertex white gray black cases derive contradiction inequality white sets contradicting inequality black removed queue corollary contradicting inequality gray painted gray dequeuing vertex removed earlier corollary contradicting inequality conclude vertices reachable discovered infinite values conclude proof theorem observe shortest path shortest path traversing edge breadth trees procedure bfs builds breadth tree searches graph illustrated figure tree represented field vertex formally graph source define predecessor subgraph nil predecessor subgraph breadth tree consists vertices reachable unique simple path shortest path breadth tree fact tree connected theorem edges called tree edges bfs source graph lemma predecessor subgraph breadth tree lemma applied directed undirected graph procedure bfs constructs predecessor subgraph breadth tree proof bfs sets reachable consists vertices reachable forms tree theorem unique path vertex applying theorem inductively conclude path shortest path procedure prints vertices shortest path assuming bfs compute shortest path tree print path print nil print path exists print path print procedure runs time linear numbe vertices path printed recursive pa vertex shorter exercises values result running breadth search directed graph figure vertex source exercises values result running bread search undirected graph figure vertex source exercises running time bfs input graph represented adjacency matrix algorithm modified handle form input exercises argue breadth search assigned vertex independent order vertices adjacency list figure breadth tree computed bfs depend ordering adjacency lists exercises directed graph source vertex set tree edges vertex unique path graph shortest path set edges produced running bfs matter vertices ordered adjacency list exercises types professional wrestlers good guys bad guys pair professional wrestlers rivalry suppose professional wrestlers list pairs wrestlers rivalries time algorithm determines ssible designate wrestlers good guys remainder bad guys rivalry good guy bad guy perform designation algorithm produce exercises diameter tree diameter largest shorte path distances tree efficient algorithm compute diameter tree analyze running time algorithm exercises connected undirected graph time algorithm compute path traverses edge direction maze large supply pennies chapters generalize study shortest paths weighted graphs edge real weight weight path sum weights constituent edges graphs considered chapter unweighted equivalently edges unit weight depth search strategy depth search implie search deeper graph depth search edges explored discovered vertex unexplored edges leaving edges explored search backtracks explore edges leaving vertex discovered process continues discovered vertices reachable original source vertex undiscove red vertices remain selected source search repeat source entire process repeated vertices discovered breadth search vertex discovered scan adjacency list discovered vertex depth search records event setting predecessor field breadth search predecessor subgraph forms tree predecessor subgraph produced depth search composed trees search repeated multiple sources predecessor subgraph depth search defined differently breadth search nil predecessor subgraph depth search forms depth forest composed depth trees edges called tree edges breadth search vertices colored search state vertex initially white grayed discovered search blackened finished adjacency list examined completely technique guarantees vertex ends depth tree trees disjoint creating depth forest depth search timestamps vertex vertex timestamps timestamp records discovered grayed timestamp records search finishes examining adjacency list blackens timestamps graph algorithms generally helpful reasoning behavior depth search procedure dfs records discovers vertex variable finishes vertex variable timestamps integers discovery event finishing event vertices vertex vertex white time gray time time black pseudocode basic depth search algorithm input graph undirected directed variable time global variable timestamping dfs vertex color white nil time vertex color white dfs visit dfs visit color gray white vertex discovered time time time explore edge color white dfs visit color black blacken finished time time figure illustrates progress dfs graph figure figure progress depth search algorithm dfs directed graph edges explored algorithm shaded tree edges dashed nontree edges labe led cross forward edges vertices timestamped discovery time finishing time procedure dfs works lines pa int vertices white initialize fields nil resets global time counter lines check vertex turn white vertex visit dfs visit time dfs visit called vertex root tree depth forest dfs returns vertex assigned discovery time finishing time dfs visit vertex initially white paints gray increments global variable time records time discovery time lines examine vertex adjacent recursively visit white vertex considered edge explored depth search finally edge leaving explored lines paint black record finishing time note depth search depend der vertices examined dfs order neighbors vertex visited dfs visit visitation orders tend problems practice depth search result effectively essentially equivalent running time dfs loops lines lines dfs time exclusive time execute calls dfs visit breadth search aggregate analysis procedure dfs visit called vertex dfs visit invoked white vertices thing paint vertex gray execution dfs visit loop lines executed times total cost executing lines dfs visit running time dfs properties depth search depth search yields valuable structure graph basic property depth search predecessor subgraph form forest trees structure depth trees mi rrors structure recursive calls dfs visit dfs visit called search adjacency list additionally vertex descendant vertex depth forest discovered time gray property depth search discovery finishing times parenthesis structure represent discovery vertex left parenthesis represent finishin parenthesis history discoveries finishings formed expression sense parentheses properly nested depth search figure corresponds parenthesization figure stating condition parenthesis structure theorem figure properties depth search result depth search directed graph vertices timestamped edge types figure intervals discovery time finishing time vertex correspond parenthesization rectangle spans interval discovery finishing times vertex tree edges intervals overlap nested vertex smaller interval descendant vertex larger graph redrawn tree forward edges depth tree edges descendant ancestor theorem parenthesis theorem depth search directed undirected graph vertices conditions holds intervals disjoint descendant depth forest interval contained interval descendant depth tree interval contained interval descendant depth tree proof case subcases subcase occurs discovered gray implies descendant discovered outgoing edges explored finished search returns finishes case theref ore interval contained interval subcase inequality implies intervals disjoint intervals disjoint vertex discovered gray vertex descendant case roles reversed argument corollary nesting descendants intervals vertex proper descendant vertex depth forest directed undirected graph proof theorem theorem character ization vertex descendant depth forest theorem white path theorem depth forest directed undirected graph vertex descendant vertex time search discovers vertex reached path consisting white vertices proof assume descendant vertex path depth tree descendant corollary white time suppose vertex reachable path white vertices time descendant depth tree wit hout loss generality assume vertex path descendant closest vertex path descendant predecessor path descendant fact vertex corollary note discovered discovered finished theorem implies interval contained interval corollary descendant classification edges interesting property depth search search classify edges input graph edge classification glean graph directed graph acyclic depth search yields edges lemma define edge types terms depth forest produced depth search tree edges edges depth forest edge tree edge discovered exploring edge edges edges connecting vertex ancestor depth tree loops occur dire cted graphs considered edges forward edges nontree edges connecting vertex descendant depth tree cross edges edges vertices depth tree long vertex ancestor vertices depth trees figures edges labeled type figure graph figure redrawn tree forward edges head downward depth tree edges graph redrawn fashion dfs algorithm modified classify edges encounters key idea edge classified color vertex reached edge explored forward cross dges distinguished white tree edge gray edge black forward cross edge case specifi cation algorithm case observe gray vertices form linear chain descendants stack active dfs visit invocations numbe gray vertices depth depth forest vertex discovered exploration proceeds deepest gray vertex edge reaches gray vertex reaches ancestor case handles remaining possi bility edge forward edge cross edge exercise undirected graph biguity type classification edge case edge classified type classification list applies equivalently exercise edge classified whichever encountered dur ing execution algorithm forward cross edges occur depth search undirected graph theorem depth search undirected graph edge tree edge edge proof arbitrary edge suppose loss generality discovered nished finish gray adjacency list edge explored direction undiscovered white time explored edge direction tree edge explored direction edge gray time edge explored applications theorems sections exercises chart row column bels white gray black cell point depth search directed graph edge vertex color vertex color edge edge types chart depth search undirected graph exercises depth search works graph figure assume loop lines dfs procedure considers vertices alphabetical order assume adjacency list ordered alphabetically sh discovery finishing times vertex classification edge figure directed graph exercises exercises parenthesis structure depth search figure exercises edge tree edge forward edge edge cross edge exercises undirected graph classifying edge tree edge edge encountered depth search equivalent classifying iority types classification scheme exercises rewrite procedure dfs stack eliminate recursion exercises counterexample conjectur path directed graph depth search descendant depth forest produced exercises counterexample conjectur path directed graph depth search result exercises modify pseudocode depth search prints edge directed graph type difications undirected exercises explain vertex directed graph depth tree incoming outgoing edges exercises depth search undirected graph identify connected components depth forest trees connected components precisely modi depth search vertex assigned integer label number connected components connected component exercises directed graph singly connected implies simple path vertices efficient algorithm determine directed graph singly connected arbitrary breadth sear limited source depth search search multiple sources conceptually breadth search proceed multiple sour ces depth search limited source approach reflects search typically breadth search employed shortest path distan ces predecessor subgraph source depth search subroutine algorithm chapter topological sort depth search perform topological sort directed acyclic graph dag called topological sort dag linear ordering vertices edge appears ordering graph acyclic linear ordering topological sort graph viewed ordering vertices horizontal directed edges left topol ogical sorting usual kind sorting studied directed acyclic graphs applications precedences events figure arises ofessor bumstead dressed morning professor garments socks shoes items order socks pants directed edge dag figure garment donned garment topological sort dag order dressed figure topologically sorted dag ordering vertices horizontal directed edges left figure professor bumstead topologically sort clothing dressed directed edge garment garment discovery finishing times depth search vertex graph topologically sort vertices arranged left order decreasing finishing time note rected edges left simple algorithm topologically sorts dag topological sort dfs compute finishing times vertex vertex finished insert linked list return linked list vertices figure topologically sorted vertices reverse order finishing times perform topol ogical sort time depth search takes time takes time insert vertices linked list prove correctness algorithm key lemma characterizing directed acyclic graphs lemma directed graph acyclic depth search yields edges proof suppose edge vertex ancestor vertex depth forest ther path edge completes cycle suppose cycle depth search yields edge vertex discovered preceding edge time vertices form path white vertices white path theorem vertex descendant depth forest edge theorem topological sort produces topological sort directed acyclic graph proof suppose dfs dag determine finishing times vertices suffices pair distinct vertices edge edge explored dfs edge explored gray ancestor edge contradicting lemma white black white descendant black finished set exploring assign timestamp edge dag proving theorem exercises ordering vertices produced topological sort dag figure assumption exercise figure dag topological sorting exercises linear time algorithm input directed acyclic graph vertices returns number paths directed acyclic graph figure paths vertex vertex pov por yv posr yv psr yv algorithm ount paths list exercises algorithm determines wh ether undirected graph cycle algorithm time independent exercises prove disprove directed graph cycles topological sort produces vertex ordering minimizes number bad edges inconsistent ordering produced exercises perform topological sorting directed acyclic graph repeatedly vertex degree output remove outgoing edges graph explain implement idea runs time algorithm cycles connected components classic application depth search decomposi directed graph connected components decomposition depth searches algorithms work directed graphs decomposition decomposition gorithm separately connected component solutions combined structure connections components recall appendix connected component directed graph maximal set vertices pair vertices vertices reachable figure figure directed graph connected components shaded regions vertex labeled discovery finishing times tree edges shaded graph gt transpose depth forest computed connected components hown tree edges shaded connected component corresponds depth tree vertices heavily shaded roots depth trees produced depth search gt acyclic component graph gscc contracting edges connected component single vertex remains component algorithm finding connected components graph transpose defined exercise graph gt consists edges directions reversed adjacency list representation time create gt interesting observe gt connected components reachable reachable gt figure transpose graph figure connected components shaded linear time time algorithm computes connected components directed graph depth searches gt connected components dfs compute finishing times vertex compute gt dfs gt main loop dfs vertices order decreasing computed output vertices tree depth forest formed separate connected component idea algorithm mes key property component graph gscc vscc escc define suppose connected components ck vertex set vscc v1 v2 vk vertex vi connected component edge vi escc directed edge looked contracting edges incident vertices connected component graph gscc figure component graph graph figure key property component graph dag lemma implies lemma distinct connected components directed graph suppose path path proof path paths reachable ther eby contradicting assumption distinct connected components vertices depth sear decreasing order finishing times computed depth searc essence visiting vertices component gra corresponds connected component topologically sorted order connected components performs depth searches potential ambiguity discuss values refer discovery finishing times computed firs dfs extend notation discovery finishing times sets vertices define min max earliest discovery time latest finish ing time vertex lemma corollary key property relating connected components finishing times depth search lemma distinct connected components directed graph suppose edge proof cases depending connected component discovered vertex depth search vertex discovered time vertices white path vertex consisting white vertices vertex path time consisting white vertices white path theorem vertices descendants depth tree corollary vertex discovered time vertices white path vertex consisting white vertices white path theorem vertices descendants depth tree corollary time vertices white edge lemma implies path vertex reachable time vertices white vertex implies corollary tells edge gt connected components component earlier finishing time depth search component finishing time corollary distinct connected components directed graph suppose edge proof connected components gt lemma implies corollary key understanding connected components procedure works exam ine perform depth search gt start connected component finishing time maximum search starts vertex visits vertices corollary edges gt connected component search visit vertices component tree rooted vertices completed visiting vertices search selects root vertex othe connected component finishing time maximum components search visit vertices corollary edges gt component visited general depth search gt visits connected component edges component compone nts visited depth tree connected component theorem formalizes argument theorem connected components correctly computes connected components directed graph proof argue induction number dept trees depth search gt vertices tree form connected component inductive hypothesis trees produced connected components basis induction trivial inductive step assume depth trees produced connected component tree produced root tree vertex connected component choose roots depth search connected component visited inductive hypothesis time search visits vertices white white path theorem vertices descendants depth tree inductive hypothesis corollary edges gt leave connected components visited vertex connected component descendant depth search gt vertices depth tree gt rooted form connected component completes inductive step proof depth search operates component graph gt scc gt map connect component visited depth search vertex gt scc vertices gt scc visited reverse topologically sorted order reverse edges gt scc graph gt scc gt scc gscc exercise depth search visits vertices gscc topologically sorted order exercises number connected ponents graph change edge exercises procedure conn ected components works graph figure finishing times computed forest produced assume loop lines dfs considers vertices alphabetical order adjacency lis alphabetical order exercises professor deaver claims algorith connected components simplified original transpose graph depth search scanning vertices order increasing finishing times professor correct exercises prove directed graph gt scc gscc transpose component graph gt component graph exercises time algorithm compute ponent graph directed graph edge vertices component graph algorithm produces exercises directed graph explain create graph connected components component graph small descri fast algorithm compute exercises directed graph semiconnected pairs vertices efficient algorithm determine semiconnected prove algorithm correct analyze running time problems classifying edge breadth search depth forest classifies edges graph tree forward cross edges breadth tree classify edges reachable source search categories prove breadth search undirected graph properties hold edges forward edges tree edge cross edge prove breadth search rected graph properties hold forward edges tree edge cross edge edge problems articulation points idges biconnected components connected undirected graph articulation point vertex removal disconnects bridge edge removal disconnects biconnected component maximal set edges edges set lie common simple cycle figure illustrates definitions determine articulation points bridges biconnected components depth search depth tree figure articulation points bridges biconnected components connected undirected graph problem articulation points heavily shaded vertices bridges heavily shaded edges biconnected components edges shaded regions bcc numbering prove root articulation point children nonroot vertex prove articulation point child edge descendant proper ancestor compute low vertices time compute articulation points time prove edge bridge lie simple cycle compute bridges time prove biconnected components partition nonbridge edges time algorithm label edge positive integer bcc bcc bcc biconnected component problems euler tour euler tour connected directed graph cycle averses edge vi sit vertex euler tour degree degree vertex time algorithm euler tour exists hint merge edge disjoint cycles problems reachability directed graph vertex labeled unique integer set vertex set vertices reachable define min vertex label minimum min vertex min time algorithm computes min vertices chapter notes tarjan excellent references graph algorithms breadth search discovered moore context finding paths mazes lee independently discovered algor ithm context routing wires circuit boards hopcroft tarjan advocated adjacency list representation adjacency matrix representation sparse aphs recognize algorithmic depth search dept search late artificial intelligence programs tarjan linear time algorithm nding connected components algorithm connected components adapted aho hopcroft ullman credit kosaraju unpublished sharir gabow developed algorithm connected components based contracting cycles stacks linear time knuth linear time algor ithm topological sorting chapter minimum spanning trees overview design electronic circuitry pins components electrically equiva lent wiring interconnect set pins arrangement wires connecting pins arrangements wire desirable model wiring problem connected undirected graph set pins set interconnections pairs pins edge weight cost ount wire needed connect acyclic subset connects vertices total weight minimized acyclic connects vertices form tree spanning tree spans graph problem determining tree minimum spanning tree problem figure connected graph minimum spanning tree figure minimum spanning tree nnected graph weights edges edges minimum spanning tree shaded total weight tree minimum spanning unique removing edge replacing edge yields spanning tree weight chapter examine gorithms solving minimum spanning tree problem kruskal algorithm prim algorithm easily time lg ordinary binary heaps fibonacci heaps prim algorithm sped time lg improvement smaller algorithms greedy algorithms chapter step algorithm choices greedy strategy advocates making choice mome strategy generally guaranteed globally optimal solutions probl ems minimum spanning tree problem prove greedy strategies yield spanning tree minimum weight chapter read independently chapter greedy methods presented classic applicati theoretical notions introduced introduces generic minimum spanni tree algorithm grows spanning tree adding edge time ways implement generic algorithm algorithm kruska connected components algorithm prim simila dijkstra shortest paths algorithm phrase minimum spanning tree shor tened form phrase minimum weight spanning tree minimizing number edges spanning trees edges theorem growing minimum spanning tree assume onnected undirected graph weight function minimum spanning tree algorithms chapter greedy approach problem differ apply approach greedy strategy captured generic algorith grows minimum spanning tree edge time algorithm manages set edges maintaining loop invariant prior iteration subset minimum spanning tree step determine edge violating invariant sense subset minimum spanning tree edge safe edge safely maintaining invariant generic mst ø form spanning tree edge safe return loop invariant initialization set trivially satisfies loop invariant maintenance loop lines intains invariant adding safe edges termination edges minimum spanni tree set returned minimum spanning tree tricky finding safe edge exist executed invariant dictates spanning tree loop body proper subset edge safe remainder provide rule theorem recognizing safe edges describes algorithms rule safe edges efficiently definitions cut undirected graph partition figure illustrates notion edge crosses cut endpoints cut respects set edges edge crosses cut edge light edge crossing cut weight minimum dge crossing cut note light edge crossing cut case ties generally edge light edge satisfying property weight minimum edge satisfying property figure ways viewing cut graph figure vertices set black white edges crossing cut connecting white vertices black vertices edge unique light edge crossing cut subset edges shaded note cut respects edge crosses cut graph vertices set left vertices set edge crosses cut connects vertex left vertex rule recognizing safe edges theorem theorem connected undirected graph real valued weight function defined subset included minimum spanning tree cut respects light edge crossing edge safe proof minimum spanning tree includes assume light edge construct minimum spanning tree includes cut paste technique showing safe edge edge forms cycle edges path illustrated figure opposite sides cut edge path crosses cut edge edge cut respects unique path removing breaks components adding reconnects form spanning tree figure proof theorem vertices black vertices white edges minimum spanning tree edges graph edges shaded light edge crossing cut edge edge unique path minimum spanning tree formed removing edge adding edge minimum spanning tree light edge crossing crosses cut minimum spanning tree minimum spanning tree remains safe edge minimum spanning tree safe theorem understanding workings generic mst algorithm connected graph algorithm proceeds set acyclic minimum spanning tree including cycle contradiction point execution algorithm graph forest connected components tree trees vertex case exam ple algorithm forest trees vertex safe edge connects distinct components acyclic loop lines generic mst executed times edges minimum spanning tree successively determined initially ø trees iteration reduces number forest single tree algorithm terminates algorithms corollary theorem corollary connected undirected graph real valued weight function defined subset included minimum spanning tree vc connected component tree forest light edge connecting component safe proof cut vc vc respects light edge cut safe exercises minimum weight edge graph belongs minimum spanning tree exercises professor sabatier conjectures converse theorem connected undirected graph real valued weight function defined subset included minimum spanning tree cut respects safe edge crossing light edge cut professor onjecture incorrect counterexample exercises edge contained minimum spa nning tree light edge crossing cut graph exercises simple graph set edges exists cut light edge crossing form minimum spanning tree exercises maximum weight edge cycle prove minimum spanning tree minimum spanning tree minimum spanning tree include exercises graph unique minimum spanning tree cut graph unique light edge crossing cut converse true counterexample exercises argue edge weights graph positive subset edges connects vertices minimum total weight tree conclusion follow weights nonpositive exercises minimum spanning tree graph sorted list edge weights minimum spanning tree list sorted list edge weights exercises minimum spanning tree graph subset subgraph induced subgraph induced connected minimum spanning tree exercises graph minimum spanning tree suppose decrease weight edges minimum spanning tree formally minimum spanning tree edge weights weight function choose edge positive number define weight function minimum spanning tree edge weights exercises graph minimum spanning tree suppose decrease weight edges algorithm finding minimum spanning tree modified graph algorithms kruskal prim minimum spanning tree algorithms elaborations generic algorithm specific rule determine safe edge generic mst kruskal algorithm set forest safe edge weight edge graph connects distinct components prim algorithm set forms single tree safe edge weight edge connecting tree vertex tree kruskal algorithm kruskal algorithm based directly generic minimum spanning tree algorithm finds safe edge add growing forest finding edges connect trees forest edge weight denote trees connected light edge connecting tree corollary implies safe edge kruskal algorithm greedy algorithm step adds forest edge weight implementation kruskal algorithm algorithm compute connected components disjoint set data structure maintain disjoint sets elements set vertices tree current forest operation set returns representative elemen set determine vertices belong tree testing set equals set combining trees accomplished union procedure mst kruskal ø vertex set sort edges nondecreasing order weight edge nondecreasing order weight set set union return kruskal algorithm works figure lines initialize set set create trees vertex edges sorted nondecreasing order weight loop lines checks edge endpoints belong tree edge forest creating cycle edge discarded vertices belong trees case edge vertices trees merged figure execution kruskal algorithm graph figure shaded edges belong forest grown edges considered algorithm sorted order weight arrow points edge consideration step algorithm edge joins distinct trees forest forest merging trees running time kruskal algorithm graph depends implementation disjoint set data struct ure assume disjoint set forest implementation union rank path compression heuristics asymptotically fastest implementation initializing set takes time time sort edges lg account cost set operations loop lines moment loop lines performs set union operations disjoint set forest set operations total time slowly growing function defined assumed connected disjoint set operations time lg lg total running time kruskal algorithm lg observing lg lg restate running time kruskal algorithm lg prim algorithm kruskal algorithm prim algorithm special case generic minimum spanning tree algorithm prim algorithm operates dijkstra algorithm finding shortest paths graph prim algorithm property edges set form single tree illustrated figure tree starts arbitrary root vertex grows tree spans vertices step light edge tree connects isolated vertex corollary rule adds edges safe algorithm terminates edges form minimum spanning tree strategy greedy tree augmen ted step edge contributes minimum tree weight figure execution prim algorithm graph figure root vertex shaded edges tree grown vertices tree black step algorithm vertices tree determine cut graph light edge crossing cut tree step algorithm choice adding edge edge tree light edges crossing cut key implementing prim algorithm efficien tly easy select edge tree formed edges pseudocode connected graph root minimum spanning tree grown inputs algorithm execution algorithm vertices tree reside min priority queue based key field vertex key minimum weight edge connecting vertex tree convention key edge field names parent tree algorithm set generic mst implicitly algorithm terminates min priority queue minimum spanning tree mst prim key nil key ø extract min key key prim algorithm works figure lines set key vertex root key set vertex processed set parent vertex nil initialize min priority queue vertices algorithm maintains loop invariant prior iteration loop lines vertices minimum spanning tree vertices nil key key weight light edge connecting vertex minimum spanning tree identifies vertex incident light edge crossing cut exception iteration removing set adds set vertices tree adding loop lines update key fields vertex adjacent tree updating maintains loop invariant performance prim algorithm depends implement min priority queue implemented binary min heap chapter build min heap procedure perform initialization lines time body loop executed times extract min operation takes lg time total time calls extract min lg loop lines executed times altogether sum lengths adjacency lists loop test membership implemented constant time keeping bit vertex tells updating bit vertex removed assignment nvolves implicit decrease key operation min heap implemented binary min heap lg time total time prim algorithm lg lg lg asymptotically implementation kruskal algorithm asymptotic running time prim gorithm improved fibonacci heaps chapter elements organize fibonacci heap perform extract min operation lg amortized time decrease key operation implement amortized time fibonacci heap implement min priority queue running time prim algorithm improves lg exercises kruskal algorithm return anning trees input graph depending ties broken edges sorted order minimum spanning tree sort edges kruskal algorithm algorithm returns exercises suppose graph represented acency matrix simple implementation prim algorith case runs v2 time exercises fibonacci heap implementation prim algorithm asymptotically faster binary heap implementation sparse graph dense graph v2 fibonacci heap implementation asymptotically fast binary heap implementation exercises suppose edge weights graph integers range fast kruskal algorithm dge weights integers range constant exercises suppose edge weights graph integers range fast prim algorithm edge weights integers range constant exercises suppose edge weights graph uniformly distributed half open interval algorithm kruskal prim faster exercises suppose graph minimum spanning tree alread computed minimum spanning tree update vertex incident edges exercises professor toole proposes divide conquer algorithm computing minimum spanning trees graph partition set vertices sets v1 v2 v1 v2 differ e1 set edges incident vertices v1 set edges incident vertices v2 recursively solve minimum spanning tree problem subgraphs g1 v1 e1 g2 v2 finally select minimum weight edge crosses cut v1 v2 edge unite minimum spanning trees single spanning tree argue algo rithm correctly computes minimum spanning tree provide algorithm fails problems minimum spanning tree undirected connected graph weight function suppose edge weights distinct minimum spanning defined set spanning trees minimum spanning tree minimum spanning tree spanning tree minimum spanning tree unique minimum spanning tree unique minimum spanning tree prove exist edges minimum spanning tree spanning tree vertices max edge maximum weight unique path v2 time algorithm computes max efficient algorithm compute minimum spanning tree problems minimum spanni tree sparse graphs sparse connected graph improve lg running time prim algorithm ith fibonacci heaps pre processing decrease number vertices running prim algorith choose vertex minimum weight edge incident minimum spanning tree construction contract chosen edges contracting edges time firs identify sets vertices united vertex create gra contracting edges time ren aming edges sets endpoints edges original graph renamed case edge weight minimum weights original edges initially set minimum spanning tree constructed edge set orig orig attribute reference edge initi graph edge contracted graph attribute holds weight edge edges contracted updated scheme choosing edge weights procedure mst reduce takes inputs orig returns contracted graph updated attributes orig graph procedure accumulates edges minimum spanning tree mst reduce orig mark false set mark false choose minimized union orig mark mark true set ø set set orig orig orig orig construct adjacency lists return orig set edges returned mst reduce minimum spanning tree graph formed mst prim vertex prove orig minimum spanning tree argue implement mst reduce runs time hint simple data structures suppose phases mst reduce outputs orig produced phase inputs orig phase accumulating edges argue running time phases suppose running phases mst reduce prim algorithm calling mst prim returned phase vertex pick running time lg lg argue choice minimizes asymptotic running time values terms prim algorithm preprocessing asymptotically beat prim algorithm preprocessing problems bottleneck spanning tree bottleneck spanning tree undirected graph spanning tree largest edge weight minimum spanning trees bottleneck spanning tree weight maximum weight edge argue minimum spanning tree bottleneck spanning tree finding bottleneck spanning tree harder finding minimum spanning tree remaining parts ill linear time linear time algorithm graph integer determines bottlen eck spanning tree algorithm ubroutine linear time algorithm bottleneck spanning tree problem hint subroutine contracts sets edges mst reduce procedure problem problems alternative minimum spanning tree algorithms problem pseudocode fferent algorithms takes graph input returns set edges algorithm prove minimum spanning tree prove minimum spanning tree efficient implementation algorith computes minimum spanning tree mst sort edges nonincreasing order edge weights edge nonincreasing order weight connected graph return mst ø edge arbitrary order cycles return mst ø edge arbitrary order cycle maximum weight edge return chapter notes tarjan surveys minimum spanning tree probl excellent advanced material history minimum spa nning tree problem written graham hell tarjan attributes minimum spanni tree algorithm paper boruvka boruvka algorithm consists running lg iterations procedure mst reduce problem kruskal algorithm reported kruskal algorithm commonly prim algorithm invented prim invented earlier jarník reason greedy algorithms effective finding minimum spanning trees set forests graph forms graphic matroid lg prim algorithm implemented fibonacci heaps runs time sparser graphs combination ideas prim algorithm kruskal algorithm boruvka algorithm togeth advanced data structures fredman tarjan algorithm runs lg time gabow galil spencer tarjan improved algorithm lg lg time chazelle algorithm runs time functional inverse ackermann function chapter notes chapter discussion ackermann function inverse previous minimum spanning algorithms chazelle algorithm follow greedy method problem spanning tree verification graph tree determine minimum spanning tree king linear time algorithm spanning verification building earlier work komlós dixon rauch tarjan algorithms deterministic fall comparison based model chapter karger klein tarjan randomized minimum spanning tree algorithm runs expected time algorithm recursion manner linear time selection algorithm recursive auxiliary problem identifies subset edges minimum spanning tree recursive finds minimum anning tree algorithm ideas boruvka algorithm king algorithm spanning tree verification fredman willard minimum spanning tree time deterministic algorithm mparison based algor ithm assumes data bit integers computer memory consists addressable bit chapter single source shortest paths overview motorist wishes shortest possi ble route chicago boston road map united states distance tween pair adjacent intersections marked determine shortest route enumerate rout chicago boston add distances route select shortest eas disallow routes cycles millions possibilities simply worth route chicago houston boston poor choice houston miles chapter chapter solve problems efficiently shortest paths problem weighted directed graph weight function mapping edges real valued weights weight path v0 v1 vk sum weights constituent edges define shortest path weight shortest path vertex vertex defined path weight chicago boston model road map graph vertices represent intersections edges represent road segments intersections edge weights represent road distances goal shortest path intersection chicago clark addison ave inter boston brookline ave yawkey edge weights interpreted metrics distances represent time cost penalties loss quantity accumulates linearly path wishes minimize breadth sea rch algorithm shortest paths algorithm works unweighted graphs graphs edge considered unit weight concepts breadth search study shortest paths weighted graphs reader encouraged review proceeding variants chapter focus single source shortest paths problem graph shortest path source vertex vertex problems solved algorithm single source problem including variants single destination shortest paths problem shortest path destination vertex vertex reversing direction edge graph reduce problem single source problem single pair shortest path problem shortest path vertices solve single source problem source vertex solve problem algorithms problem asymptotically faster ngle source algorithms worst case pairs shortest paths problem shortest path pair vertices problem solved running single source algorithm vertex usua lly solved faster additionally structure intere chapter addresses pairs problem optimal substructure shortest path shortest paths algorithms typically rely property shortest path vertices shortest paths edm onds karp maximum flow algorithm chapter relies property optimal substructure property hallmark applicability dynamic programming chapter greedy method chapter dijkstra algorithm greedy algorithm floyd warshall algorithm finds shortest paths pairs vertices chapter dynamic programming algorithm lemma states optimal substructure property shortest paths precisely lemma subpaths shortest paths shortest paths weighted directed graph weight function v1 v2 vk shortest path vertex v1 vertex vk pij vi vi subpath vertex vi vertex pij shortest path vi proof decompose path p1i pij pjk assume path vi weight path v1 vk weight contradicts assumption shortest path v1 vk negative weight edges instances single source shor test paths problem edges weights negative graph negative weight cycles reachable source shortest path weight remains defined negative negative weight cycle reachable shortest path weights defined path vertex cycle shortest path lesser weight path proposed shortest path traverses negative weight cycle negative weight cycle path define figure illustrates negative weights negative weight cycles shortest path weights path path path infinitely paths cycle weight shortest path weight shortest path weight analogously infinitely paths cycle weight shortest path traversing negative weight cycle arbitrarily times paths arbitrarily large negative weights reachable paths arbitrarily large negative weights vertices form negative weight cycl reachable figure negative edge weights directed graph vertex shortest path weight source vertices form negative weight cycle reachable shortest path weights vertex reachable vertex shortest path weight shortest path weight vertices reachable shortest path weights lie negative weight cycle shortest paths algorithms dijkstra algorithm assume edge weights input graph nonnegative road map exampl bellman ford algorithm negative weight edges input graph produce correct answer long negative weight cycles reachable source typically negative weight cycle algorithm detect report existence cycles shortest path cycle negative weight cycle positive weight cycle removing cycle path produces path source destin ation vertices lower path weight v0 v1 vk path vi vi positive weight cycle path vi path v0 v1 vi vk weight shortest path v0 vk leaves weight cycles rem ove weight cycle path produce path weight shortest path source vertex destination vertex weight cycle shortest path cycle long shortest path weight cycles repeatedly remove cycles path unt shortest path cycle free loss generality assume finding shortest paths cycles acyclic path graph distinct vertices edges restrict attention shortest paths edges representing shortest paths compute shortest path weights vertices shortest paths representation shortest paths breadth trees graph maintain vertex predecessor vertex nil shortest paths algorithms chapter set attributes chain predecessors originating vertex runs backwards shortest path vertex nil procedure print path print shortest path execution shortest paths algorithm values shortest paths breadth search interested predecessor subgraph induced values define vertex set set vertices nil predecessors source nil directed edge set set edges induced values vertices prove values produced algorithms chapter property termination shortest paths tree informally rooted tree shortest path source vertex reachable shortest paths tree breadth tree shortest paths source defined terms edge weights num bers edges precise weighted directed graph weight function assume negative weight cycles reachab source vertex shortest paths defined shortest paths tree rooted directed subgraph set vertices reachable forms rooted tree root unique simple path shortest path shortest paths unique shortest paths trees figure weighted directed graph shortest paths trees root figure weighted directed graph shortest path weights source shaded edges form shortest pat tree rooted source shortest paths tree root relaxation algorithms chapter technique relaxation vertex maintain attribute upper bound weight shortest path source shortest path estimate initialize shortest path estimates predecessors time procedure initialize single source vertex nil initialization nil process relaxing edge consists testing improve shortest path updating relaxation step decrease shortest path esti mate update predecessor field code performs relaxation step edge relax figure examples relaxing edge shortest path estimate decreases estimate figure relaxation edge weight shortest path estimate vertex vertex prior relaxation decreases relaxation step unchanged relaxation algorithm chap ter calls initialize single ource repeatedly relaxes edges relaxation shortestpath estimates predecessors change algorithms chap ter differ times relax edge order relax edges dijkstra algorithm shortest paths algorithm directed acyclic graphs edge relaxed bellman ford algorithm edge relaxed times strange term relaxation operation tightens upper bound term historical outco relaxation step viewed relaxation constraint tria ngle inequality lemma satisfied pressure satisfy cons traint constraint relaxed properties shortest paths relaxation prove algorithms chapter correct appeal properties shortest paths relaxation state properties proves formally reference property stated includes lemma corollary number properties refer shortest path estimates predecessor ubgraph implicitly assume graph initialized initialize single source shortest path estimates predecessor subgraph change sequence relaxation steps triangle inequality lemma edge upper bound property lemma vertices achieves path property corollary path convergence property lemma shortest path time prior relaxing edge times afterward path relaxation property lemma v0 v1 vk shortest path v0 vk edges relaxed order v0 v1 v1 v2 vk vk vk vk property holds relaxation steps occur intermixed relaxations edges predecessor subgraph property lemma predecessor subgraph shortest paths tree rooted chapter outline presents bellman ford algorithm wh ich solves single source shortest paths problem general case edges negative weight bellman ford algorithm remarkable simplicit benefit detecting negative weight cycle reachable source linear time algorithm computing shortest paths single source directed acyclic graph covers dijkstra algorithm ha lower running time bellman ford algorithm requires edge weights nonnegative bellman ford algorithm solve special case linear programming finally proves properties shortest paths relaxation stated require conventions arithmetic infinities assume real number proofs hold presence negative weight cycles assume real number algorithms chapter assume directed graph stored adjacency list representation additionally stored edge weight traverse adjacency list determine edge weights time edge bellman ford algorithm bellman ford algorithm solves single ource shortest paths problem general case edge weights nega tive weighted directed graph source weight function bellman ford algor ithm returns boolean indicating negative weight cycle reachable source cycle algorithm ndicates solution exists cycle algorithm produces shortest paths weights algorithm relaxation progressively decreasing estimate weight shortest path source vertex achieves actual shortest path weight algorithm returns true graph negative weight cycles achable source bellman ford initialize single source edge relax edge return false return true figure execution bellman ford algorithm graph vertices initializing values vertices algorithm passes edges graph pass iteration loop lines consists relaxing edge graph figures state algorithm passes edges making passes lines check negative weight cycle return boolean check works figure execution bellman algorithm source vertex values vertices shad edges predecessor values edge shaded pass relaxes edges order situation pass edges situation successive pass edges values final values bellman ford algorithm returns true bellman ford algorithm runs time initiali zation takes time passes edges lines takes time loop lines takes time prove correctness bellman ford algorithm start showing negative weight cycles algorithm computes correct sh ortest path weights vertices reachable source lemma weighted directed graph source weight function assume negative weight cles reachable iterations loop lines bellman ford vertices reachable proof prove lemma appealing pa relaxation property vertex reachable v0 v1 vk v0 vk acyclic shortest path path edges iterations loop lines relaxes edges edges relaxed ith iteration vi vi path relaxa tion property vk vk corollary weighted directed graph source vertex weight function vertex path bellman ford terminates proof proof left exercise theorem correctness bellman ford algorithm bellman ford weighted directed graph source weight function negative weight cycles reachable algorithm returns true vertices predecessor subgraph shortest paths tree rooted negative weight cycle reachable algorithm returns false proof suppose graph negative weight cycles reachable source prove claim termination vertices vertex reachable lemma proves claim reachable claim path propert claim proven predecessor subgraph property claim implies shortest paths tree claim bellman ford return true termination edges tests bellman ford return false returns true triangle inequality conversely suppose graph negative weight cle reachable source cycle v0 v1 vk v0 vk assume purpose contradiction bellman ford algorithm returns true vi vi vi vi summing inequalities cycle v0 vk vertex appears summations corollary vi finite contradicts inequality conclude bellman ford algorithm returns true graph negative weight cycles reachable source false exercises bellman ford algorithm directed graph figure vertex source pass relax edges order figure values pass change weight edge algorithm source exercise prove corollary exercise weighted directed graph negative weight cycles maximum pairs vertices minimum number edges shortest path shortest path weight number edges simple change bellman ford algorithm terminate passes exercise modify bellman ford algorithm sets vertices negative weight cycle path source exercise weighted directed graph weight function time algorithm vertex min exercise suppose weighted directed graph negative weight cycle efficient algorithm list vertices cycle prove algorithm correct single source shortest paths directed acyclic graphs relaxing edges weighted dag directed acyclic graph topological sort vertices compute shortest paths single source time shortest paths define dag negative weight edges negative weight cycles exist algorithm starts topologically sorting dag impose linear ordering vertices path vertex vertex precedes topological sort pass vertices topologically sorted order process vertex relax edge leaves vertex dag shortest paths topologically sort vertices initialize single source vertex topologically sorted order vertex relax figure execution algorithm figure execution algorithm shor test paths directed acyclic graph vertices topologically sorted left source vertex values vertices shaded edges values situation iteration loop lines situation iteration loop lines newly blackened rtex iteration iteration values final values running time algorithm easy analyze topological sort performed time initialize single source takes time iteration vertex loop lines vertex edges leave vertex examined total iterations loop lines aggregate analysis iteration loop takes time total running time linear size adjacency list representation graph theorem dag shortest paths procedure correctly computes shortest paths theorem weighted directed graph source vertex cycles termination dag shortest paths procedure vertices predecessor subgraph shortest paths tree proof vertices termination reachable path property suppose reachable shortest path v0 v1 vk v0 vk process vertices opologically sorted order edges relaxed order v0 v1 v1 v2 vk vk path relaxation property implies vi vi termination finally predecessor subgraph property shortest paths tree interesting application algorithm arises determining critical paths pert chart analysis edges represent jobs performed edge weights represent times required perform jobs edge enters vertex edge leaves job performed prior job path dag represents sequence jobs performed order critical path longest path dag longest time perf orm ordered sequence jobs weight critical path lowe bound total time perfor jobs critical path negating edge weights running dag shortest paths running dag shortest paths modification replace initialize single ource relax procedure exercises dag shortest paths directed graph figure vertex source exercise suppose change dag shortest paths read vertices topologically sorted order procedure remain correct exercise pert chart formulation unnatural natural vertices represent jobs edges represent sequencing constraints edge job performed job weights assigned vertices edges modify dag shortest paths procedure finds longest path directed acyclic graph weighted vertices linear time exercise efficient algorithm count total number paths directed acyclic graph analyze algorithm pert acronym program evaluation review technique dijkstra algorithm dijkstra algorithm solves single source hortest paths problem weighted directed graph case edge weights nonnegative assume edge good implementation running time dijkstra algorithm lower bellman ford algorithm dijkstra algorithm maintains set vertices final shortest path weights source determined gorithm repeatedly selects vertex minimum shortest path estimate adds relaxes edges leaving implementation min priority queue vertices keyed values dijkstra initialize single source ø ø extract min vertex relax dijkstra algorithm relaxes edges figure performs usual initialization values initializes set set algorithm maintains invariant start iteration loop lines initializes min priority queue vertices ø time invariant true time loop lines vertex extracted set maintaining invariant time loop vertex smallest shortest path estimate vertex lines relax edge leaving updating estimate predecessor shortest path improved observe vertices inserted vertex extracted loop lines iterates times figure execution dijkstra algorithm source leftmost vertex shortest path estimates rtices shaded edges predecessor values black vertices set white vertices min priority queue situation itera tion loop lines shaded vertex minimum chosen vertex situation successive iteration loop shaded vertex chosen vertex iteration values final values dijkstra algorithm chooses lightest closest vertex add set greedy strategy greedy strategies presented chapter read chapter understand dijkstra algorithm greedy strategies yield optimal general theorem corollary dijkstra algorithm ndeed compute shortest paths key time vertex set theorem correctness dijkstra algorithm dijkstra algorithm weighted directed graph negative weight function source terminates vertices proof loop invariant start iteration loop lines vertex suffices vertex time set rely upper bound property equality holds times initialization initially ø invariant trivially true maintenance iteration vertex set purpose contradiction vertex set focus attent ion situation iteration loop derive contradiction time examining shortest path vertex set time ø path path property violate assumption path shortest path prior adding path connects vertex vertex vertex predecessor figure path decomposed paths edges figure proof theorem set nonempty vertex shortest path source vertex decomposed vertex path precedes vertices distinct path reenter set claim prove claim observe chosen vertex edge relaxed time claim convergence property contradiction prove occurs shortest path edge weights nonnegative notably path vertices chosen inequalities fact equalities contradicts choice conclude equality maintained times termination termination ø earlier invariant implies vertices corollary dijkstra algorithm weighted directed graph nonnegative weight function source termination predecessor subgraph shortest paths tree rooted proof theorem predecessor subgraph property analysis fast dijkstra algorithm maintains min priority queue calling priority queue operations insert implicit extract min decrease key implicit relax called insert invoked vertex extract min vertex set edge adjacency list examined loop lines algorithm total number edges adjacency lists total iterations loop total decrease key operations observe aggregate analysis running time dijkstra algorithm depends min priority queue implemented case maintain min priority queue advantage vertices numbered simply store vth entry array insert decrease key operation takes time extract min operation takes time search rough entire array total time v2 v2 graph sparse v2 lg practical implement min priority queue bina min heap discussed implementation rtices heap elements maintain handles extract min operation takes time lg operations time ild binary min heap decrease key operation takes time lg operations total running time lg lg vertices reachable source running time improvement straightforward v2 time implementation v2 lg fact achieve running time lg implementing min priority queue fibonacci heap chapter amortized cost extract min operations lg decrease key takes amortized time historically development fibonacci heaps motivated observation dijk stra algorithm typically decrease key calls extract min calls method reducing amortized time decrease key operation lg increasing amortized time extract min yield asym ptotically faster implementati binary heaps dijkstra algorithm bears similarity breadth search prim algorithm computi minimum spanning trees breadth search set corresponds set black vertices breadth search vertices final shortest path weights black vertices breadth search correct breadth distances dijkstra algorithm prim algorithm algorithms min priority queue lightest vertex set set dijkstra algorithm tree grown prim algorithm add vertex set adjust weight remaining vertices set exercises dijkstra algorithm directed graph figure vertex source vertex source style figure values vertices set iteration loop exercises simple directed graph ith negative weight edges dijkstra algorithm produces incorrect answer proof theorem negative weight edges allowed exercises suppose change dijkstra algorithm change loop execute times times proposed algorithm correct exercises directed graph edge real number range represents reliability communication channel vertex vertex interpret probability channel fail assume probabilities independent efficient algorithm reliable path vertices exercises weighted directed graph weight function positive integer assume verti ces shortest path weights source vertex suppose define unweighted directed graph replacing edge unit weight edges series vertices suppose breadth search order vertices colored black breadth search order vertices extracted prio rity queue dijkstra exercises weighted directed graph weight function nonnegative integer modify dijkstra algorithm compute shortest paths source vertex time exercises modify algorithm exercise lg time hint distinct shortest path estimates point time exercises suppose weighted directed graph edges leave source vertex negative weights edge weights nonnegative negative weight cycles argue dijkstra algorithm correctly finds shortest paths graph difference constraints shortest paths chapter studies general linear programming oblem optimize linear function subject set linear inequalities investigate special case linear programming reduced finding shortest paths single source single source shortest paths problem sults solved bellman ford algorithm solv ing linear programming problem linear programming general linear programming problem matrix vector vector vector elements maximizes objective function subject constraints simplex algorithm focus chapter time polynomial size input linear programmi algorithms polynomial time reasons understand setup linear programming problems knowi problem cast polynomial sized linear programming problem imme diately polynomial time algorithm problem special cases linear programming faster algorithms exist single source shortest paths problem special case linear programming problems cast linear programming include single pair shortest path problem exercise maximum flow problem exercise care obj ective function feasible solution vector satisfies determine feasible solution exists focus feasibility problem systems difference constraints difference constraints row linear programming matrix entries constraints set difference constraints involving unknowns constraint simple linear inequality form oblem finding vector satisfies problem equivalent finding unknowns difference constraints satisfied solution problem verified directly checking inequality fact solution problem solutions component larger component fact mere coincidence lemma solution difference constraints constant solution proof satisfies systems difference constraints occur applications unknowns times events ccur constraint viewed stating time time events events jobs performed assembly product apply adhesive takes hours set time wait sets install time constraint equivalently alternatively require stalled adhesive applied time adhesive set halfway case pair constraints equivalently constraint graphs beneficial interpret systems diffe rence constraints graph theoretic point view idea difference constraints linear programming matrix viewed transpose incidence matrix exercise graph vertices edges vertex vi graph corresponds unknown variables directed edge graph corresponds inequalities involving unknowns formally difference constraints constraint graph weighted directed graph v0 v1 vn vi constraint v0 v1 v0 v2 v0 v3 v0 vn additional vertex v0 incorporated shortly guarantee vertex reachable vertex set consists vertex vi unknown additional vertex v0 edge set edge difference constraint edge v0 vi unknown difference constraint weight edge vi vi weight edge leaving v0 figure constraint graph difference constraints figure constraint graph difference constraints v0 vi vertex vi feasible solution theorem lution difference constraints finding shortest path weights constraint graph theorem difference constraints constraint graph negative weight cycles feasible solution negative weight cycle feasible solution proof constraint aph negative weight cycles equation feasible solution edge vi triangle inequality v0 v0 vi vi equivalently v0 v0 vi vi letting v0 vi v0 satisfies difference constraint vi corresponds edge vi constrai graph negative weight cycle difference constraints feasible solution loss generality negative weight cycle v1 v2 vk v1 vk vertex v0 cycle entering edges cycle corresponds followi difference constraints v1 v2 v2 v3 vk vk vk v1 suppose solution satisfying inequalities solution satisfy inequality sum inequalities sum left hand sides unknown subtracted left hand sum hand sums negative weight cycle contradiction solving systems difference constraints theorem tells bellman ford algorithm solve difference constraints ther edges source vertex v0 vertices constraint graph negative weight cycl constraint graph reachable v0 bellman ford algorithm returns true shortest path weights feasible solution figure shortest path weights provide feasible solution lemma feasible solution constant bellman ford gorithm returns false feasible solution difference constraints difference constraints constraints unknowns produces graph vertices edges bellman ford algorithm solve nm time exercise asks modify algorithm nm time exercises feasible solution determine feasible solution exists difference constraints x4 x5 x6 x6 x4 x5 x5 x4 x6 exercises feasible solution determine feasible solution exists difference constraints x5 x4 x4 x4 x4 x5 x5 x5 x4 exercises shortest path weight vertex v0 constraint graph positive explain exercises express single pair shortest path problem linear program exercises modify bellman ford algorithm lightly solve difference constraints inequalities unknowns running time nm exercises suppose addition fference constraints handle equality constraints form bellman ford gorithm adapted solve variety constraint exercises difference constraints solved bellman ford algorithm runs constraint graph extra vertex v0 exercises difference constraints unknowns bellman ford algorithm corre sponding constraint graph maximizes subject exercises bellman ford algorithm constraint graph difference constraints minimizes quantity max min subject explain fact handy algorithm schedule construction jobs exercises suppose row matrix linear program corresponds difference constraint single variable constraint form single variable constraint form adapt bellman ford algorithm solve variety constraint exercises efficient algorithm solve difference constraints elements real valued unknowns integers exercises efficient algorithm solve difference constraints elements real valued subset unknowns integers proofs shortest paths properties chapter correctness arguments relied triangle inequality upper bound property path property convergence property path relaxation property predecessor subgraph property stated properties proof chapter prove triangle inequality studying breadth search proved lemma simple property shortest distances unweighted graphs triangle inequality generalizes property weighted graphs lemma triangle inequality weighted directed graph weight function source vertex edges proof suppose shortest path source vertex weight path path weight path takes shortest path source vertex takes edge exercise asks handle case shortest path effects relaxation shortest path estimates group lemmas describes shor test path estimates execute sequence relaxation steps edges weighted directed graph initialized itialize single source lemma upper bound property weighted directed graph weight function source vertex graph initialized initialize single source invariant maintained sequence relaxation steps edges achieves lower bound proof prove invariant vertices induction number relaxation steps basis true initialization note negative weight cycle implies inductive step relaxation edge inductive hypothesis prior relaxation change invariant maintained inductive hypothesis triangle inequality note achieved lower bound decrease increase relaxation steps increase values corollary path property suppose weighted directed graph weight function path connects source vertex vertex graph initialized initialize single source equality maintained invariant sequence relaxation steps edges proof upper bound property lemma weighted directed graph weight function relaxing edge executing relax proof prior relaxing edge afterward relaxation afterward lemma convergence property weighted directed graph weight function source vertex shortest path vertices suppose initialized itialize single source sequence relaxation steps includes relax executed edges time prior times proof upper bound property point prior relaxing edge equality holds relaxing edge lemma lemma upper bound property conclude equality maintained lemma path relaxation property weighted directed graph weight function source vertex shortest path v0 v1 vk v0 vk initialized initialize single source sequence relaxation steps occurs includes der relaxations edges v0 v1 v1 v2 vk vk vk vk relaxations times afterward property holds matter edge relaxations occur including relaxations intermixed relaxations edges proof induction ith edge path relaxed vi vi basis edges relaxed initialization v0 upper bound property initialization inductive step assume vi vi examine relaxation edge vi vi convergence property relaxation vi vi equality maintained times relaxation shortest paths trees sequence relaxations caused shortest path estimates converge shortest path weights predecessor subgraph induced values shortest paths tree start lemma predecessor subgraph forms root tree root source lemma weighted directed graph weight function source vertex assume negative weight cycles reachable graph initialized initialize single source predecessor subgraph forms rooted tree root sequence relaxation steps edges maintains property invariant proof initially vertex source vertex lemma trivially true predecessor subgraph arises sequence relaxation steps prove acyclic suppose sake contradiction relaxation step creates cycle graph cycle v0 v1 vk vk v0 vi vi loss generality assume relaxation edge vk vk created cycle claim vertices cycle reachable source vertex nil predecessor vertex assigned finite shortest path estimate assigned nil upper bound property vertex cycle finite shortest path weight implies reachable examine shortest path estimates prior relax vk vk negative weight cycle contradicting assumption negative weight cycles reachable source vi vi update vi assignment vi vi vi vi vi changed decreased relax vk vk vk changed forehand strict inequality vk vk vk vk summing strict inequality inequalities sum shortest path estimates cycle vertex cycle appears summation equality implies sum weights cycle negative desired contradiction proven directed acyclic graph forms rooted tree root suffices exercise prove vertex unique path path exists vertex vertices nil values idea prove induction path exists vertices details left exercise complete proof lemma vertex path graph suppose suppose simple paths vertex decomposed decomposed figure implies contradiction conclude exists unique simple path forms rooted tree root figure showing path source vertex unique paths contradiction performe sequence relaxation steps vertices assigned true shortest path weights predecessor subgraph shortest paths tree lemma predecessor subgraph property weighted directed graph weight function source vertex assume negative weight cycles reachable initialize single source execute sequence relaxation steps edges produces predecessor subgraph shortest paths tree rooted proof prove ree properties shortest pat trees hold property set vertices reachable definition shortest path weight finite reachable vertices reachable finite values vertex assigned finite nil vertices reachable property directly lemma remains prove prope rty shortest paths trees vertex unique simple path shortest path v0 v1 vk v0 vk vi vi vi vi vi vi conclude vi vi vi vi summing weights path yields vk vk lower bound weight path vk conclude vk shortest path vk exercises shortest paths trees directed graph figure exercises weighted directed graph weight function source satisfies operty edge shortest paths tree rooted shortest paths tree rooted exercises embellish proof lemma handle cases shortest path weights exercises weighted directed graph source vertex initialized initialize single source prove sequence relaxation steps sets nil negative weight cycle exercises weighted directed graph negative weight edges source vertex suppose predecessor shortest path source reachable nil graph assignment values produces cycle lemma assignment produced sequence relaxation steps exercises weighted directed graph weight function negative weight cycles source vertex initialized initialize single source prove vertex exists path property maintained invariant sequence relaxations exercises weighted directed graph negative weight cycles source vertex initialized initialize single source prove exists sequence relaxation steps produces exercises arbitrary weighted directed graph negative weight cycle reachable source vertex infinite sequence relaxations edges constructed relaxation shortest path estimate change problems yen improvement bellman ford suppose order edge relaxations pass bellman ford algorithm pass assign arbitrary linear order v1 v2 vertices input graph partition edge set eb vi eb vi assume loops edge eb define gf gb eb prove gf acyclic topological sort v1 v2 gb acyclic topological sort v1 suppose implement pass bellman ford algorithm visit vertex order v1 v2 relaxing edges leave vertex visit vertex order v1 relaxing edges eb leave vertex prove scheme negative weight cycles reachable source vertex passes edges vertices scheme improve asymptotic running time bellman ford algorithm problems nesting boxes dimensional box dimensions xd nests box dimensions y1 yd exists permutation y1 yd argue nesting relation transitive efficient method determine dimensional box nests inside suppose set dimensional boxes efficient algorithm determine longest sequence boxes nests express running time algorithm terms problems arbitrage arbitrage discrepancies currency exchange rates transform unit currency unit currency suppose dollar buys indian rupees indian rupee buys japanese yen japanese yen buys dollars converting currencies trader start dollar buy dollars turning profit percent suppose currencies table exchange rates unit currency buys units currency efficient algorithm determine exists sequence currencies i1 ik ik ik i1 analyze running time algorithm efficient algorithm print sequence exists analyze running time algorithm problems gabow scaling algorith single source shortest paths scaling algorithm solves problem initially onsidering highest order bit relevant input edge wei ght refines initial solution highest order bits progressively high order bits refining solution time bits considered correct solution computed problem examine algorithm computing shortest paths single source scaling edge weights directed graph nonnegative integer edge weights max goal develop algorithm runs lg time assume vertic reachable source algorithm uncovers bits binary representation edge weights time bit ast bit lg number bits binary representationk scaled version bits wk binary representation w3 w3 define shortest path weight vertex vertex weight function source vertex scaling algorithm computes shortest path weights computes computes assume computing takes time entire algorithm takes lg time suppose vertices compute time compute time focus computing prove provei define prove reweighted edge nonnegative integer define shortest path weight weight function prove compute time conclude computed lg time problems karp minimum weight cycle algorithm directed graph weight function define weight cycle e1 ek edges µ min µ ranges directed cycles cycle µ µ called minimum weight cycle problem investigates efficient algorithm computing µ assume loss gene rality vertex reachable source vertex weight shortest path weight shortest path consisting edges path edges µ negative weight cycles minkn vertices µ vertices hint properties weight cycle vertices suppose µ weight path cycle prove hint weight path cycle µ minimum weight cycle exists vertex hint shortest path rtex minimum weight cycle extended cycle shortest path vertex cycle µ add constant weight edge µ increased fact time algorithm compute µ problems bitonic shortest paths sequence bitonic monotonically increases monotonically decreases circularly shifted monotonically increase monotonically decrease sequences bitonic bitonic chapter discussion bitonic sorters problem bitonic euclidean traveling salesman problem suppose directed graph weight function single source shortest paths source vertex additional piece vertex weights edges shortest path form bitonic sequence efficient algorit hm solve probl analyze running time chapter notes dijkstra algorithm appeared contained mention priority queue bellman ford algorithm based separate algorithms bellman ford bellman describes relation shorte paths difference constraints lawler describes linear time algorithm shortest path dag considers folklore edge weights small nonnega tive integers efficient algorithms solve single source shortest paths problem sequence values returned extract min calls dijkstra algorithm monotonical ly increasing time discussed chapter notes chapter case data structures implement priority queue operations efficien tly binary heap fibonacci heap ahuja mehlhorn orlin tarjan algorithm runs time graphs nonnegative edge weights largest weight edge graph bounds thorup algorithm runs lg lg time raman algorithm runs min lg lg time algorithms space depends word size underlying machine alt hough space unbounded size input reduced linear size input randomized hashing undirected graphs integer weights thorup time algorithm single source shortest paths contrast algorithms menti oned previous paragraph algorithm implementa tion dijkstra algorithm sequence values returned extract min calls monotonically increasing time graphs negative edge weights algorithm gabow tarjan runs time goldberg runs time max cherkassky goldberg radzik conducted extensive experiments comparing shortest path algorithms chapter pairs shortest paths overview chapter problem nding shortest paths pairs vertices graph problem making table distances pairs cities road atlas chapter weighted directed graph weight function maps edges real valued weights pair vertices shortest weight path weight path sum weights constituent dges typically output tabular form entry row column weight shortest path solve pairs shortest paths problem running single source shortest paths algorithm times vertex sour edge weights nonnegative dijkstra algorithm linear array implementation min priority queue running time v3 v3 binary min heap implementation min priority queue yiel running time lg improvement graph sparse alternatively implement min priority queue fibonacci heap yielding running time v2 lg negative weight edges allowed dijkstra algorithm longer slower bellman ford algorithm vertex running time v2e dense graph v4 chapter investigate relation pairs shortest paths problem matrix multiplication study algebraic structure single source algorithms assume adjacency list representation graph algorithms chap ter adjacency matrix representation johnson algorithm sparse graphs adja cency lists convenience assume vertices numbered input matrix representing edge weights vertex directed graph wij negative weight edges allowed assume time input graph negative weight cycles tabular output pairs shortest paths algorithms presented chapter matrix dij entry dij weight shortest path vertex vertex denote shortest path weight vertex vertex chapter dij termination solve pairs shortest paths problem input adjacency matrix compute shortest path weights predecessor matrix nil path predecessor shortest path predecessor subgraph chapter shortest paths tree source vertex subgraph induced ith row matrix shortest paths tree root vertex define predecessor subgraph nil shortest paths tree ocedure modified version print path procedure chapter prints shortest path vertex vertex print pairs shortest path print nil print path exists print pairs shortest path print order highlight essential features pairs algorithms chapter cover creation properties predecessor matrices tensively dealt predecessor subgraphs chapter basics covered exercises chapter outline presents dynamic programming algorithm based matrix multiplication solve pairs shortest paths problem usin technique repeated squaring algorithm v3 lg time dynamic programming algorithm floyd warshall algorithm floyd warshall algorithm runs time v3 covers problem finding transitive closure directed graph pairs shortest paths problem finally presents johnson algorithm algorithms chapter johnson algorithm adjacency list representation graph lves pairs shortestpaths problem v2 lg time good algorithm large sparse graphs proceeding establish conventions adjacency matrix representations gene rally assume input graph vertices convention denoting matrices uppercase letters individual elements subs cripted lowercase letters wij lij dij matrices pare nthesized superscripts iterates finally matrix assume stored attribute rows shortest paths matrix multiplication presents dynamic programmi algorithm pairs shortestpaths problem directed graph major loop dynamic program invoke operation sim ilar matrix multiplication algorithm repeated matrix multiplication start developing v4 time algorithm pairs shortest paths problem improve running time v3 lg proceeding recap steps chapter developing dynamic programming algorithm characterize structure optimal solution recursively define optimal solution compute optimal solution fashion fourth step constructing optimal solution computed dealt exercises structure shortest path start characterizing structure optimal solution pairs shortest paths problem graph proven lemma subpaths shortest path shortest paths suppose graph represented adjacency matrix wij shortest path vertex vertex suppose edges assuming negative weight cycles finite weight edges vertices distinct decompose path path edges lemma shortest path wkj recursive solution pairs shortest paths problem minimum weight path vertex vertex edges shortest path edges compute minimum weight shortest path consisting edges minimum weight path consisting edges predecessors recursively define equality wjj actual shortest path weights graph contai negative weight cycles pair vertices shortest path simple hus edges path vertex vertex edges lower weight shortest path actual shortest path weights computing shortest path weights input matrix wij compute series matrices final matrix actual shortest path weights observe vertices heart algorithm follow ing procedure matrices returns matrix extends shortest paths computed edge extend shortest paths rows matrix return procedure computes matrix returns computing equation written superscripts input output matrices independent running time n3 nested loops relation matrix multipli cation suppose compute matrix product matrices compute observe substitutions min equation equation extend shortest paths replace identity min identity straightforward n3 time procedure matrix multiplication matrix multiply rows matrix cij cij cij aik bkj return returning pairs shortest paths problem compute shortest path weights extending shortest paths edge edge letting denote matrix product returned extend shortest paths compute sequence matrices w2 w3 wn argued matrix wn shortest path weights procedure computes sequence n4 time slow pairs shortest paths rows extend shortest paths return figure graph matrices computed procedure slow pairs shortest paths figure directed graph sequence matrices computed slow pairs shortest paths reader verify equal improving running time goal compute matrices interested matrix recall absence negative weight cycles equation implies integers traditional matrix multipli cation associative matrix multiplication defined extend shortest paths procedure exercise compute lg matrix products computing sequence w2 w4 w2 w2 w8 w4 w4 lg final product equal procedure computes seque nce matrices technique repeated squaring faster pairs shortest paths rowsm extend shortest paths return iteration loop lines computem starting iteration double final iteration computes computingm equationm time test performed doubled test fails procedure returns matrix computed running time faster pairs shortest paths n3 lg lg matrix products takes n3 time observe ode tight elaborate data structures constant hidden notation small exercises slow pairs shortest paths weighted directed graph figure showing matrices result iteration loop faster pairs shortest paths figure weighted directed graph exercises exercises require wii exercises matrix shortest paths algorithms corre spond regular matrix multiplication exercises matrix multiplication defined extend shortest paths associative exercises express single source shortest paths problem product matrices vector evaluating product corresponds bellman ford algorithm exercises suppose compute vertices shortest paths algorithms compute predecessor matrix completed matrix shortest path weights n3 time exercises vertices shortest paths computed time shortest path weights define predecessor vertex minimum weight path edges modify extend shortest paths slow pairs shortest paths compute matrices matrices computed exercises faster pairs shortest paths proce dure written requires store lg matrices elements total space requirement lg modify procedure require space matrices exercises modify faster pairs shortest paths detect presence negative weight cycle exercises efficient algorithm lengt number edges minimum length negative weight cycle graph floyd warshall algorithm dynamic programming formulation solve pairs shortest paths problem directed graph algorithm floyd warshall algorithm runs v3 time nega tive weight edges assume ther negative weight cycles follow dynamic programming process develop algorithm studying algorithm simila method finding transitive closure directed graph structure shortest path floyd warshall algorithm diffe rent characterization structure shortest path matrix multiplication based pairs algorithms algorithm considers intermediate rtices shortest path intermediate vertex simple path v1 v2 vl vertex v1 vl vertex set v2 v3 vl floyd warshall algorithm based observation assumption vertices subset vertices pair vertices paths intermediate vertices drawn minimum weight path path simple floyd warshall algorith exploits relationship path shortest paths intermediate rtices set relationship depends intermediate vertex path intermediate vertex path intermediate vertices path set shortest path vertex vertex intermediate vertices set shortest path intermediate vertices set intermediate vertex path break figure lemma shortest path intermediate vertices set vertex intermediate vertex path shortest path intermediate vertices set shortest path vertex vertex intermediate vertices set figure path shortest path vertex vertex highest numbered intermediate vertex path portion path vertex vertex intermediate rtices set holds path vertex vertex recursive solution pairs shortest paths problem based observations define recursive formulation shortest path estimates weight shortest path vertex vertex intermediate rtices set path vertex vertex intermediate vertex numbered higher intermediate vertices path edge recursive definition discussion path intermedia vertices set matrix final answer computing shortest path weights based recurrence procedure compute values order increasing values input matrix defined equation procedure returns matrix shortest path weights floyd warshall rows return figure matrices computed floyd warshall algorithm graph figure figure sequence matrices computed floyd warshall algorithm graph figure running time floyd warshall algorith determined triply nested loops lines execution takes time algorithm runs time n3 final algorithm code tight elaborate data structures constant hidden notation small floyd warshall algorithm practical moderate sized input graphs constructing shortest path variety methods onstructing shortest paths floyd warshall algorithm compute matrix shortest path weights construct predecessor matrix matrix method implemented n3 time exercise predecessor matrix print pairs shortest path procedure print vertices shortest path compute predecessor matrix floyd warshall algorithm computes matrices compute sequence matrices defined predecessor vertex shortest path vertex intermediate rtices set recurs ive formulation shortest path intermediate vertices path predecessor choose predecessor chose shortest path intermediate vertices set choose predecessor chose shortest path intermediate vertices set formally leave incorporation matrix computations floyd warshall procedure exercise figure sequence matrices algorithm computes graph figure exercise asks difficult task proving predecessor subgraph shortest paths tree root reconstruct shortest paths exercise transitive closure directed graph directed graph vertex set path vertex pairs transitive closure defined graph path vertex vertex compute transitive closure graph n3 time assign weight edge floyd warshall algorithm path vertex vertex dij dij compute transitive closure n3 time save time space practice method nvolves substitution logical operations logical logical arit hmetic operations min floyd warshall algorithm define exists path graph vertex vertex intermediate vertices set construct transitive closure putting edge recursive definition analogous recurrence floyd warshall algorithm compute matrices order increasing transitive closure return figure matrices computed transitive closure procedure sample graph transitive closure pro cedure floyd warshall algorithm runs n3 time computers ogical operations single bit values execute faster arithmetic operations integer data direct transitive closure algorithm boolean values integer values space requirement floyd warshall algorithm factor size word computer storage figure directed graph matrices computed transitive closure algorithm exercises floyd warshall algorithm weighted directed graph figure matrix ite ration outer loop exercises compute transitive closure technique exercises modify floyd warshall procedur include computation matrices equations prove rigorously predecessor subgraph shortest paths tree root hint acyclic implies definition adapt proof lemma exercises appears floyd warshall algorithm requires n3 space compute procedure simply drops superscripts correct space required floyd warshall rows dij min dij dik dkj return exercises suppose modify whic equality handled equation alternative definition predecessor matrix correct exercises output floyd warshall algorithm detect presence negative weight cycle exercises reconstruct shortest paths floyd warshall algorithm values highest numbered intermediate vertex shortest path intermediate vertices set recursive formulation modify floyd warshall procedure compute values rewrite print pairs shortest path ocedure matrix input matrix table matrix chain multiplication problem exercises time algorithm computing transi tive closure directed graph exercises suppose transitive closure directed acyclic graph computed time monotonically increasing function time compute transitive closure general directed graph johnson algorithm sparse graphs johnson algorithm finds shortest paths pairs v2 lg time sparse graphs asymptotically tter repeated squa ring matrices floyd warshall algorithm algorithm returns matrix shortest path weights pairs vertices reports input graph negative weight cycle johnson algorithm subroutines dijkstra algorithm bellman ford algorithm chapter johnson algorithm technique reweighting works edge weights graph nonnegative shortest paths pairs vertices running dijkstra algorithm vertex fibonacci heap min priority queue running time pairs algorithm v2 lg negative weight edges negative weight cycles simply compute set nonnegative edge weights method set edge weights satisfy properties pairs vertices path shortest path weight function shortest path weight function edges weight nonnegative moment preprocessing determine weight function performed time preserving shortest paths reweighting lemma easy reweighting edges satisfies property denote shortest path weights derived weight function denote shortest path weights derived weight function lemma reweighting change shortest paths weighted directed graph weight function function mapping vertices real numbers edge define v0 v1 vk path vertex v0 vertex vk shortest path v0 vk weight function shortest path weight function v0 vk negative weight cycle weight function negative weight cycle weight function proof start showing path v0 vk path v0 vk shorter weight function shorter v0 vk finally negative weight cycle weight function negative weight cycle weight function cycle v0 v1 vk v0 vk equation v0 vk negative weight negative weight producing nonnegative weights reweighting goal ensure property holds nonnegative edges weighted directed graph weight function graph vertex extend weight function note edges enter shortest paths source negative weight cycles negative weight cycles figure graph graph figure figure johnson pairs shortest paths algorithm graph figure graph original weight function vertex black vertex edge reweighted weight function result running dijkstra algorithm vertex weight function source vertex black shaded edges shortest paths tree computed algorithm vertex values separated slash duv equal suppose negative weight cycles define triangle inequality lemma edges define weights equation property satisfied figure graph figure reweighted edges computing pairs shortest paths johnson algorithm compute pairs shor test paths bellman ford algorithm dijkstra algorithm subroutines assumes edges stored adjacency list algorithm returns usual matrix dij dij reports input graph negative weight cycle typical pairs shortest paths algorithm assume vertices numbered johnson compute bellman ford false print input graph negative weight cycle vertex set computed bellman ford algorithm edge vertex dijkstra compute vertex return code simply performs actions earlier produces runs bellman ford algorithm weight function source vertex negative weight cycle reports problem lines assume negative weight cycles lines set shortest path weight computed bellman ford algorithm lines compute weights pair vertices loop lines putes shortest path weight calling dijkstra algorithm vertex stores matrix entry duv correct shortest path weight calculated equation finally returns completed matrix figure execution johnson algorithm min priority queue dijkstra gorithm implemented fibonacci heap running time johnson algorithm v2 lg simpler binary min heap implementation yields running time lg asymptotically faster floyd warshall algorithm graph sparse exercises johnson algorithm shortest paths tween pairs vertices graph figure values computed algorithm exercises purpose adding vertex yielding exercises suppose edges relationship weight functions exercises professor greenstreet claims simpler reweight edges method johnson algorithm letting min define edges wrong professor method reweighting exercises suppose johnson algorithm directed graph weight function weight cycle edge exercises professor michener claims create source vertex johnson claims vertex weighted directed graph incorporating professor idea johnson incorrect answers connected vertex reachable vertex returned johnson professor modification correct problems transitive closure dynamic graph suppose maintain ansitive closure directed graph insert edges edge inse rted update transitive closure edges inserted assume graph edges initially transitive closure represented boolean matrix transitive closure graph updated v2 time edge graph edge v2 time required update transitive closure ter insertion efficient algorithm updating transitive osure edges inserted graph sequence insertions algorithm total time time update transitive closure ith edge inserted prove algorithm attains time bound problems shortest pa ths dense graphs graph dense v1 constant range ary min heaps problem shortest paths algorithms dense graphs match running times fibonacci heap based algorithms complicated data structure asymptotic running times insert extract min decrease key function number elements ary min heap running times choose constant compare running times ortized costs operations fibonacci heap compute shortest paths single source dense directed graph negative weight edges time hint pick function solve pair shortest paths problem dense directed graph negative weight edges time solve pair shortest paths problem time dense directed graph negative weight edges negative weight cycles chapter notes lawler good discussion pairs shortest paths problem analyze solutions sparse graphs attributes matrix multiplication algorithm folklore floyd warshall algorithm floyd based theorem warshall describes compute ansitive closure boolean matrices johnson algorithm researchers improved algorith computing shortest paths matrix multiplication fredman pairs shorte paths problem solved v5 comparisons sums edge wei ghts obtains algorithm runs v3 lg lg lg time running time floyd warshall algorithm monstrates algorithms fast matrix multiplication chapter notes chapter applied pairs shortest paths problem nw running time fastest algorithm multiplying matrices galil margalit seidel designed algorithms solve pairs shortest path problem undirected unweighted graphs vw time denotes function polylogarithmically bounded dense graphs algorithms faster time needed perform breadth searches researchers extended algorithms solving pairs shortest paths problem undirected graphs edge weights integers range asymptotically fastest algorithm shoshan zwick runs time vw karger koller phillips independently mcgeoch time bound depends set edges participate shortest path graph nonnegative edge weights algorithms v2 lg time improvements running dijkstra algorithm times aho hopcroft ullman defined algebraic structure closed semiring serves general framework solving path problems directed graphs floyd warshall algorithm tran sitive closure algorithm instantiations pairs gorithm based closed semirings maggs plotkin minimum spanning trees closed semiring chapter maximum flow overview model road map directed graph order shortest path point interpret directed graph flow network answer questions material flows imagine material oursing source material produced sink consumed source produces material steady rate sink consumes material rate flow material poi intuitively rate material moves flow networks mode liquids flowing pipes parts assembly lines current electrical networks communication networks directed edge flow network thought conduit material conduit stated capacity maximum rate material flow conduit gallons liquid hour pipe amperes electrical current wire vertices conduit junctions source sink material flows vertices coll ecting rate material enters vertex equal leaves vertex property flow conservation equivalent kirchhoff current law material electrical current maximum flow problem comput greatest rate material shipped source sink violating capacity constraints simplest problems flow networks chapter problem solved efficient algorithms basic techniques maximum flow algorithms adapted solve network flow problems chapter presents general methods solving maximum flow problem formalizes notions flow networks flows formally defining maximum flow problem describes classical method ford fulkerson finding maximum flows application method finding maximum matching undirected bipartite graph presents push relabel method underlies fastest algorithms network flow problems covers relabel algorithm implementation push relabel method runs time v3 algorithm fastest algorithm illustrates techniques asymptotically fastest algorithms efficient practice flow networks graph theoretic defin ition flow networks discuss properties define maximum flow problem precise ly introduce helpful notation flow networks flows flow network directed graph edge nonnegative capacity assume distinguish vertices flow network source sink convenience assume vertex lies path source sink vertex path graph connected figure flow network ready define flows formally flow network capacity function source network sink flow real valued function satisfies properties figure flow network lucky puck company trucking problem vancouver factory source winnipeg warehouse sink pucks shipped intermed iate cities crates day city city edge labeled capacity flow positive flows edge labeled slash notation separate flow capacity indi cate division edge labeled capacity capacity constraint require skew symmetry require flow conservation require quantity positive negative called flow vertex vertex flow defined total flow source notation denotes flow absolute cardinality maximum flow problem flow network source sink flow maximum network flow oblem explore flow properties capacity constraint simply flow vertex exceed capacity skew symmetry notational convenience flow vertex vertex negative flow reverse direction flow conservation property total flow vertex source sink skew symmetry rewrite flow conservation property total flow vertex flow exercise asks prove property formally observation flow properties deals flows positive total positive flow entering vertex defined total positive flow leaving vertex defined symmetrically define total net flow vertex total positive flow leavi vertex minus total positive flow entering vertex interpretation flow conservation property total positive flow entering vertex source sink equal total positive flow leaving vertex property total net flow vertex equal informally referred flow equals flow flow flow network model trucking problem figure lucky puck company factory source vancouver manufactures hockey pucks warehouse sink winnipeg stocks luc ky puck leases space trucks firm ship pucks factor warehouse trucks travel routes edges cities vertices ha limited capacity lucky puck ship crates day pair cities figure lucky puck control routes capacities alter flow network figure goal determine largest number crates day shipped produce sinc point producing pucks ship warehouse lucky puck concerned long takes puck factory warehouse care crates day leave factory crates day arrive warehouse surface model flow shipments flow network number crates shipped day city nother subject capacity constraint additionally flow conservation obeyed steady state rate pucks enter intermediate city equal rate leave crates accumula intermediate cities subtle difference shipme nts flows lucky puck ship pucks edmonton calgary ship pucks calgary edmonton suppose ship crates day edmonton v1 figure calgary v2 crates day calgary edmonton natural shipments directly flows sk ew symmetry constraint requires v1 v2 v2 v1 case v1 v2 v2 v1 lucky puck realize pointless sh crates day edmonton calgary crates calgary edmonton achieve net shipping crates edmonton calgary crates calgary edmonton fewer resources process represent scenario flow v1 v2 v2 v1 crates day v1 v2 canceled crates day v2 v1 general cancellation represent shipments cities flow positive edge vertices situation pucks shipped directions cities transformed cancellation equivalent situation pucks shipped direction direction positive flow flow arose physical shipme nts reconstruct exact shipments flow units shipped units shipped units shipped typically care actual physical shipments set pair vertices care net travels care underlying shipments model retains shipments directions cancellation implicitly algorithms chapter suppose edge flow algorithm increase flow edge mathematically operation decrease conceptually units canceling units flow edge networks multiple sources sinks maximum flow problem sources sinks lucky puck company set factories s1 set warehouses figure fortunately problem harder ordinary maximum flow figure converting multiple source multi ple sink maximum flow problem problem single source single sink flow network sources s1 s3 s4 s5 sinks equivalent single source single sink flow network add supersource edge infinite capacity multiple sources add supersink edge infin ite capacity multiple sinks reduce problem determining maximum flow network multiple sources multiple sinks ordinary maximum flow problem figure network converted dinary flow network single source single sink add supersource add directed edge capacity create supersink add directed edge capacity intuitively flow network corresponds flow network vice versa single source simply flow desired multiple sources single sink likewise consumes flow desired multiple sinks exercise asks prove formally problems equivalent working flows dealing functions arguments vertices flow network chapter implicit summation notation argument set vertices interpretation denoted sum ways replacing guments members sets vertices flow conservation constraint expressed condition convenience typically omit set braces implicit summati notation equation term set implicit set notation simplifies quations involving flows lemma proof left exercise captures commonly occurring identities involve flows implicit set notation lemma flow network flow equalities hold ø sums working implicit summation notation prove flow total flow sink intuitively expect property hold flow conservation vertices source sink equal amounts total pos itive flow entering leaving source definition total net flow greate positive flow leaves source enters symmetrically sink vertex total net flow positive flow enters sink leaves formal proof definition lemma lemma lemma lemma flow conservation chapter generalize result lemma exercises definition flow prove exercises prove vertex source sink total positive flow entering equal total positive flow leaving exercises extend flow properties definitions multiple source multiple sink problem flow multiple source multip sink flow network corresponds flow identical single source single sink network adding supersource supersink vice versa exercises prove lemma exercises flow network flow figure pair subsets pair subsets exercises flow network f1 functions flow sum f1 function defined f1 flows flow properties flow sum f1 satisfy violate exercises flow network real number scalar flow product denoted function defined prove flows network form convex set f1 flows f1 range exercises state maximum flow problem linear programming problem exercises professor adam children unfortunate ly dislike problem severe refuse walk school fact refuses walk block child stepped day children problem paths crossing corner fortunately professor house school corners send children school professor map town formulate problem determining children school maximum flow problem ford fulkerson method presents ford fulkerson met hod solving maximum flow problem method algorithm encompasses implementations differing running times ford fulkers method depends ideas transcend method relevant flow algorithms problems residual networks augmenting paths cuts ideas essential max flow min cut theorem theorem characterizes valu maximum flow terms cuts flow network sect ion presenting specific implementation ford fulkerson method analyzing running time ford fulkerson method iterative start initial flow iterati increase flow finding augmenting path simply path source sink send flow gmenting flow path repeat process augmenting path max flow min cut theorem termination pro cess yields maximum flow ford fulkerson method initialize flow exists augmenting path augment flow return residual networks intuitively flow network flow residual network consists edges admit flow formally suppose flow network source sink flow pair vertices additional flow push exceeding capacity residual capacity increase units exceed capacity constraint edge flow negative residual capacity greater capacity residual capacity interpret situation flow units cancel pushing flow units push units violating capacity constraint edge pushed additional units flow starting flow reaching capacity constraint flow network flow residual network induced gf promised edge residual network residual edge admit flow greater figure repeats flow network flow figure figure residual network gf figure flow network flow figure residual network gf augmenting path shaded residual capacity v2 v3 flow augmenting path residual capacity residual network induced flow edges edges reversals edge edge case appears original network exercise conclude edge residual network appears origin network observe residual network gf flow network capacities lemma flow residual network relates flow original flow network lemma flow network source sink flow gf residual network induced flow gf flow sum defined equation flow proof verify skew symmetry capacity constraints flow conservation obeyed skew symmetry note capacity constraints note equation flow conservation note finally augmenting paths flow network flow augmenting path simple path residual network gf definition residual network edge augmenting path admits additional positive flow violating capacity constraint edge shaded path figure augmenting path eating residual network gf figure flow network increase flow edge path units violating capacity constraint smallest residual capacity path v2 v3 maximum increase flow edge augmenting path residual capacity min lemma proof left exercise argument precise lemma flow network flow augmenting path gf define function fp fp flow gf fp corollary add fp flow closer maximum figure result adding fp figure figure corollary flow network flow augmenting path gf fp defined equation define function fp flow fp proof lemmas cuts flow networks ford fulkerson method repeatedly augmen flow augmenting paths maximum flow max flow min cut theorem prove shortly tells flow maximum residual network augmenting path prove theorem explore notion cut flow network cut flow network partition definition defini tion cut minimum spanning trees chapter cutting directed graph undirected graph insist flow net flow cut defined capacity cut minimum cut network cut capacity minimum cuts network figure cut v1 v2 v3 v4 flow network figure net flow cut v1 v3 v2 v3 v2 v4 capacity v1 v3 v2 v4 figure cut flow network figure v1 v2 v3 v4 vertices black vertices white net flow capacity observe net flow cut incl ude negative flows vertices capacity cut composed nonnegative values net flow cut consists positive flows directions positive flow positive flow subtracted hand capacity cut computed edges edges included computation lemma net flow acr oss cut equals flow lemma flow flow network source sink cut net flow proof noting flow conservation lemma lemma lemma corollary lemma result proved earlier equation flow total flow sink corollary lemma cut capacities bound flow corollary flow flow network bounded capacity cut proof cut flow lemma capacity constraints consequence corollary maximum flow network bounded capacity minimum cut network max flow min cut theorem state prove maximum flow fact equal capacity minimum cut theorem max flo min cut theorem flow flow network source sink conditions equivalent maximum flow residual network gf augmenting paths cut proof suppose sake contradiction maximum flow gf augmenting path corollary flow sum fp fp equation flow strictly greater contradicting assumption maximum flow suppose gf augmenting path gf path define exists path gf partition cut trivially path gf pair vertices place set lemma corollary cuts condition implies maximum flow basic ford fulkerson algorithm iteration fulkerson method augmenting path increase flow edge residual capacity implementation method computes maximum flow graph updating flow pair vertices connected edge connected edge direction assume implicitly capacities assumed graph residual capacity computed formula expression code temporary vari stores residual capacity path ford fulkerson edge exists path residual network gf min edge ford fulkerson algorithm simply expands ford fulkerson method pseudocode earlier figure result iteration sample lines initialize flow loop lines repeatedly finds augmenting path gf augments flow residual capacity augmenting paths exist flow maximum flow figure execution basic ford fulkerson algorithm successive iterations loop left pa residual network gf shaded augmenting path flow adding fp residual network input network residual network loop test augmenting paths flow maximum flow analysis ford fulkerson running time ford fulkerson depends augmenting path determined chosen algorithm terminate flow increase successive augmentati ons converge maximum flow augmenting path chosen breadth search algorithm runs polynomial time proving result simple bound case augmenting path chosen arbitrarily capacities integers practice maximum flow probl arises integral capacities capacities rational numbers scaling transformation integral assumption straightforward implementation ford fulkerson runs time maximum flow algorithm analysis lines time loop lines executed times flow increases unit iteration work loop efficient efficiently manage data structure implement network assume data structure directed graph edges network edges simple matter maintain capacities flows data structure flow edges residual network gf consist edges time path residual network depth search breadth earch iteration loop takes time making total running time ford fulkerson capacities integral optimal flow small running time ford fulkerson algorithm good figure happen simple flow network large maximum flow network units flow traverse path units traverse path augmenting path ford fulkerson figure flow iteration residual network figure iteration finds augmenting path figure flow figure residual network continue choosing augmenting path odd numbered iterations augmenting path numbered iterations perform total augmentations increasing flow unit figure flow network ford fulkerson time maximum flow augmenting path residual capacity residual network augmenting path residual capacity residual network edmonds karp algorithm bound ford fulkerson improved implement computation augmenting path breadth search augmenting path shortest path residual network edge unit distance weight ford fulkerson method implemented edmonds karp algorithm prove edmonds karp algorithm runs time analysis depends distances vertices residual network gf lemma notation shortest path distance gf edge unit distance lemma edmonds karp algorithm flow network source sink vertices shortest path distance residual network gf increases monotonically flow augmentation proof suppose vertex flow augmentation shortest path distance decrease derive contradiction flow augmentation decreases shortest path distance flow afterward vertex minimum distance decreased augmentation shortest path gf chose distance label vertex decrease claim lemma triangle inequality inequality equation contradicts assumption augmentation increased flow edmonds karp algorithm ugments flow shortest paths shortest path gf edge inequality equation contradicts assumption conclude assumption vertex exists incorrect theorem bounds number iterations edmonds karp algorithm theorem edmonds karp algorithm flow network source sink total number flow augmentations performed algorithm proof edge residual network gf critical augmenting path residual capacity residual capacity augmented flow augmenting path critical edge path disappears residual network edge augmenting path critical edges critical times vertices connected edge augmenting paths shortest paths critical time flow augmented edge disappears resi dual network reappear augmenti path flow decreased occurs appears augmenting path flow event occurs lemma time critical time critical distance source increases distance source initially intermediate vertices shortest path critical path implies unreachable source distance critical times pairs vertices edge residual graph total number critical edges entire execution edmonds karp algorithm augmenting path critical edge theorem iteration ford ful kerson implemented time augmenting path bread search total running time edmonds karp algorithm push relabel gorithms yield bounds algorithm method achieving v2 running time forms basis v3 time algorithm exercises figure flow cut v2 v4 v1 v3 capacity cut exercises execution edmonds kar algorithm flow network figure exercises figure minimum cut maximum flow augmenting paths appearing cancel flow exercises prove pair vertices capacity flow functions exercises recall construction converts multisource multisink flow network single source single sink network adds edges infinite capacity prove flow network finite edges original multisource multisink network finite capacity exercises suppose source multisource multisink problem produces units flow suppose sink consumes units convert problem finding flow obeys additional constraints problem finding maximum flow single source single sink flow network exercises prove lemma exercises maximum flow network sequence augmenting paths hint determine paths finding maximum flow exercises edge connectivity undirected graph minimum number edges removed disconnect graph edge connectivity tree edge connectivity cyclic chain vertices edge connectivity undirected graph determined running maximum flow algorithm flow networks vertices edges exercises suppose flow network symmetric edges edmonds karp algori thm terminates iterations hint edge change times critical square brackets treat identifier mutable field parentheses treat function ford fulkerson method fail termin ate edge capacities irrational numbers practice irrational num bers stored finite precision computers maximum bipartite matching combinatorial problems easily cast maximum flow problems multiple source multiple sink maximum flow problem combinatorial problems surface flow networks fact reduced maxi mum flow problems presents problem finding maximum tching bipartite graph order solve problem advantage integrality property provided ford fulkerson method fulkerson method solve maximum bipartite matching problem graph time maximum bipartite matching problem undirected graph matching subset edges vertices edge incident vertex matched matching edge incident unmatched maximum matching matching maximum car dinality matching matching strict attention finding maximum matchings bipartite aphs assume vertex set partitioned disjoint edges assume vertex incident edge figure illustrates notion matching figure bibartite graph vertex partition matching cardinality maximum matching ith cardinality problem finding maximum matching bipartite graph practical applications matching set machines set tasks performed simultaneousl presence edge machine capable performing task maximum matching work machines finding maximum bipartite matching ford fulkerson method maximum matching undirected bipartite graph time polynomial trick construct flow network flows correspond matchings figure define flow network bipartite graph source sink vertices vertex partition directed edges edges directed edges figure flow network bipartite graph bipartite graph vertex partition figure maxi mum matching shaded edges flow network maximum flow edge unit capacity shaded edges flow edges carry flow shaded edges correspond maximum matching bipartite graph complete construction sign unit capacity edge vertex incident edge lemma matching corresponds directly flow flow network flow flow network integer valued integer lemma bipartite graph vertex partition flow network matching integer valued flow conversely integer valued flow matching cardinality proof matching corresponds integer valued flow define edges define simple verify satisfies skew symmetry capacity constraints flow conservation intuitively edge corresponds unit flow traverses path paths induced edges vertex disjoint net flow cut equal lemma flow prove converse integer valued flow vertex entering edge capacity unit positive flow ente ring unit positive flow enter flow conservation unit positiv flow leave integer valued unit flow enter edge leave edge unit positive flow enters vertex edge leaving carries positive flow symmetric argument set defined statement lemma matching observe matched vertex edge lemma simplify expression cons iderably flow conservation implies lemma implies skew symmetry implies edges edges definition based lemma conclude maximum matching bipartite graph corresponds maximum flow flow network compute maximum matching running maximum flow algorithm hitch reasoning maximum flow algor ithm return flow integer flow integer theorem ford fulkerson method difficulty theorem integrality theorem capacity function takes integral values maximum flow produced ford fulkerson method property integer vertices integer proof proof induction number iterations leave exercise prove corollary lemma corollary cardinality maximum matching bipartite graph maximum flow flow network proof nomenclature lemma suppose maximum matching flow maximum maximum flow capacities integer valued theorem assume integer valued corresponds matching cardinality contradicting assumption maximum matching manner maximum flow matching maximum matching bipartite undirected graph maximum matching creating flow network running ford fulkerson method directly obtaining maximum matching integer valued maximum flow matching bipartite graph cardinality min maximum flow maximum matc hing bipartite graph time exercises ford fulkerson algorithm flow network figure residual network flow augmentation number vertices iter ation pick augmenting path lexicographically smallest exercise prove theorem exercise bipartite graph vertex partition flow network good upper bound length augmenting path execution ford fulkerson exercise perfect matching matching ery vertex matched undirected bipartite graph vertex partition define neighborhood set vertices adjacent member prove hall theorem exists perfect matching subset exercise bipartite graph regular vertex degree regular bipartite graph prove regular bipartite graph tching cardinality arguing minimum cut flow network capacity push relabel algorithms push relabel approach computing maximum flows asymptotically fastest maximum flow algorithms push relabel algorithms fastest actual implementati ons maximum flow algorithms based push relabel method flow problems su minimum cost flow problem solved efficiently push relabel methods introduces goldberg generic maximum flow algorithm mple implementation runs v2 time improving bound edmonds karp algorithm refines generic algorithm nother push relabel algorithm runs v3 time push relabel algorithms work loca lized manner ford fulkerson method examine entire residual network augmenting path push relabel algorithms work vertex time vertex neighbors residual network fulkerson method push relabel algorithms maintain flow conservation propert execution maintain preflow function satisfies skew symmetry capacity constraints relaxation flow conservation vertices total net flow vertex source nonnegative total net flow vertex excess flow vertex overflowing start describing intuition push relabel method investigate operations employed method pushing preflow relabeling vertex finally generic push relabel algorithm analyze correctness running time intuition intuition push relabel method understood terms fluid flows flow network interconnected pipes capacities applying analogy ford fulkerson method augmenting path network rise additional stream fluid branch points flowing source sink ford fulkerson method eratively adds streams flow generic push relabel algorithm intuition directed edges correspond pipes vertices pipe junctions interesting properties accommodate excess flow vertex flow pipe leading arbitrarily large reservoir accumulate fluid vertex reservoir pipe connections platform height increases gorithm progresses vertex heights determine flow pushed push flow downhill higher vertex lower vertex flow lower vertex higher vertex positive operations push flow push downhill height source fixed height sink fixed vertex heights start increase time algorithm sends flow downhill source sink sends outgoing pipe source capacity sends capacity cut flow enters intermediate vertex collects vertex servoir eventually pushed downhill eventually happen pipes leave vertex saturated flow connect vertices level uphill case rid overflowing vertex excess flow increase height operation called relabeling vertex height increased unit height lowest neighbors unsaturated pipe vertex relabeled outgoing pipe flow pushed eventually flow sink arrived arrive pipes obey capacity onstraints flow cut limited capacity cut preflow legal flow algorithm sends excess collected reservoirs overflowing vertices source continuing relabel vertices fixed height source reservoirs emptied preflow legal flow maximum flow basic operations preceding discussion ere basic operations performed push relabel algorithm pushing flow excess vertex neighbors relabeling vertex applicability operations depends heights vertices define precisely flow network source sink preflow function height function residual edge lemma lemma flow network preflow height function vertices edge residual graph push operation basic operation push applied overflowing vertex pseudocode updates preflow implied network assumes residual capacities computed constant time excess flow stored vertex maintained attribute height maintained attribute expression temporary variable stores flow pushed push applies overflowing action push min units flow min code push operates vertex assumed positive excess residual capacity positive increase flow min causing negative capacity exceeded computes update lines lines preflow push called remains preflow afterward observe code push depends heights prohibit invoked excess flow pushed downhill height differential lemma residual edges exist vertices heights differ long attribute height function gained allowing flow pushed downhill height differential operation push push push operation applies edge leaving vertex push operation applies saturating push edge saturated afterward nonsaturating push edge saturated residual network simple lemma characterizes result nonsaturating push lemma nonsaturating push vertex longer overflowing proof push nonsaturating flow pushed equal prior push reduced push relabel operation basic operation relabel applies overflowing edges relabel overflowing vertex vertex residual capacity flow pushed downhill recall definition source sink overflowing relabeled relabel applies overflowing action increase height min operation relabel vertex relabeled note relabeled edge leaves minimization code nonempty set property assumption overflowing vertex implies operation relabel greatest height allowed constraints height functions generic algorithm generic push relabel algorithm follow ing subroutine create initial preflow flow network initialize preflow vertex edge vertex initialize preflow creates initial preflow defined edge leaving source filled capacity edges carry flow vertex adjacent source initially initialized negative sum capacities generic algorithm initial height function height function edges edges saturated residual network initialization sequence push relabel operations executed order yields generic push relabel algorithm generic push relabel initialize preflow exists applicable push relabel operation select applicable push relabel operation perform lemma tells long overflowing vertex exists basic operations applies lemma overflowing vertex pushed relabeled flow network source sink preflow height function overflowing vertex push relabel operation applies proof residual edge height function push operation apply residual edges implies relabel operation applied correctness push relabel method generic push relabel algorithm solves maximum flow problem prove terminates preflow maximum flow prove terminates start obs ervations height function lemma vertex heights decrease execution generic push relabel flow network vertex height decreases relabel operation applied vertex height increases proof vertex heights change relabel operations suffices prove statement lemma vertex relabeled vertices min operation increase lemma flow network source sink execution generic push relabel attribute maintained height function proof proof induction number basic operations performed initially height function observed claim height function operation relabel leaves height function residual edge leaves operation relabel ensures afterward residual edge enters lemma operation relabel implies afterward operation relabel leaves height function operation push operation add edge remove case remains height function case removal residual network removes constraint remains height function lemma property height functions lemma flow network source sink preflow height function path source sink residual network gf proof assume sake contra diction path v0 v1 vk gf v0 vk loss generality simple path edge vi vi height function vi vi combining inequalities path yields contradicts requirement height function ready generic push relabel algorithm terminates preflow computes maximum flow theorem correctness generic push relabel algorithm algorithm generic push relabel rminates flow network source sink preflow computes maximum flow proof loop invariant time loop test generic push relabel executed preflow initialization initialize preflow preflow maintenance operations loop lines push relabel relabel operations affect height attributes flow values affect preflow argued preflow prior push operation remains preflow afterward termination termination vertex excess lemmas invariant preflow overflowing vertices flow height function lemma tells path residual network gf max flow min cut theorem theorem maximum flow analysis push relabel method generic push relabel algorithm terminat bound number operations perf orms types operations relabels saturating pushes nonsaturating pushes bounded separately knowledge bounds straightforward problem onstruct algorithm runs v2e time analysis prove lemma lemma flow network source sink preflow overflowing vertex simple path residual network gf proof overflowing vertex exists simple path gf suppose sake contradiction claim pair vertices turn implies exists edge simple path form gf contradicting choice term implicit summation nonpositive equation lemma lemma excesses nonnegative vertices assumed vertices contradicts assumption overflowing lemma bounds heights vertices corollary bounds number relabel operations performed total lemma flow network source sink time execution generic push relabel vertices proof heights source sink change vertices definition overflowing greater vertex initially relabeling operation relabeled overflowing lemma tells simple path gf v0 v1 vk v0 vk simple vi vi lemma vi vi expanding inequalities path yields v0 vk corollary bound relabel operations flow network source sink execution generic push relabel number relabel oper ations vertex proof vertices relabeled operation relabel increases initially lemma grows vertex relabeled times total number relabel operations performed lemma helps bound number saturating pushes lemma bound saturating pushes execution generic push relabel flow network number saturating proof pair vertices count saturating pushes calling saturating pushes pushes edge suppose saturating push occurred time order push occur algorith push flow happen decreases order increase likewise increase saturating pushes heights start lemma exceed implies number times vertex height increase increase saturating pushes fewer saturating pushes multiplying number edges bound total number saturating pushes lemma bounds number nonsa turating pushes generic push relabel algorithm lemma bound nonsaturating pushes execution generic push relabel flow network number nonsaturating pushes proof define potential functionh initially change relabeling saturating push nonsaturating push bound saturating pushes relabe lings contribute increase nonsaturating push decrease bounds derive upper bound number nonsaturating pushes examine ways increase relabeling vertex increases set sum relabeling increase height maximum height lemma saturating push vertex vertex increases heights change vertex height overflowing nonsaturating push decreases nonsaturating push overflowing overflowing lemma longer overflowing push addition overflowing push source potential function decreased increased net potential function decreased algorithm total increase relabelings saturated pushes constrained corollary lemma total decrease total number nonsaturating pushes bounded number relabelings saturating pushes nonsaturating push set stage analysis generic push relabel procedure algorithm based push relabel method theorem execution generic push relabel flow network number basic operations v2e proof corollary lemmas algorithm terminates v2 operations remains efficient method implementing operation choosing operation execute corollary implementation generi push relabel algorithm runs v2 time flow network proof exercise asks implemen generic algorithm overhead relabel operation push asks design data structure pick applicable operation time corollary exercises implement gene ric push relabel algorithm time relabel operation time push time select appli cable operation total time v2e exercises prove generic push relabel algorithm spends total time performing v2 relabel operations exercises suppose maximum flow flow network push relabel algorithm fast algorithm minimum cut exercises efficient push relabel algorithm maximum matching bipartite graph analyze algorithm exercises suppose edge capacities flow network set analyze running time generic push relabel algorithm terms hint times edge support nonsaturating push saturated exercises initialize preflow changed correctness asymptotic performance generic push relabel algorithm exercises distance number edges residual network gf generic push relabel maintains properties implies implies exercises previous exercise distance residual network gf generic push relabe algorithm modified maintain property implies implies total time implementation dicates maintaining property exercise number nonsaturating pushes executed generic push relabel flow network literature heig ht function typically called distance function height vertex called distance label term height suggestive intuition algorithm retain term relabel refer operation increases height vertex height vertex distance sink breadth search transpose gt relabel algorithm push relabel method apply basic operations order choosing order carefully managing twork data structure efficiently solve maximum flow problem faster v2e bound corollary examine relabel gorithm push relabel algorithm running time v3 asymptotically good v2e dense networks relabel algorithm maintains list vertices network algorithm scans list repeat edly selecting flowing vertex discharging performing push relabel operations longer positive excess vertex relabeled moved list relabel algorithm scan anew correctness analysis relabel algorithm pend notion admissible edges edge residual network flow pushed proving properties bout network admissible edges investigate discharge operation analyze relabe algorithm admissible edges networks flow network source sink preflow height function admissible edge inadmissible admissible network gf set admissible edges admissible network consists edges flow pushed lemma network directed acyclic graph dag lemma admissible network acyclic flow network preflow height function admissible network gf acyclic proof proof contradiction suppose gf cycle v0 v1 vk v0 vk edge admissible vi vi summing cycle vertex cycle appears summations derive contradiction lemmas push rela bel operations change admissible network lemma flow network preflow suppose attribute height function vertex overflowing admissible edge push applies operation create admissible edges inadmissible proof definition admissibl edge flow pushed overflowing operation push applies residual edge created pushing flow edge edge admissible opera tion asaturating push afterward inadmissible lemma flow network preflow suppose attribute height function vertex overflowing admissible edges leaving relabel applies relabel operation admissible edge leaving admissible edges entering proof overflowing lemma push relabel operation applies admissible edges leaving flow pushed relabel applies relabel operation min vertex realizes minimum set edge admissible relabel admissible edge leaving admissible edges enter relabel operation suppose vertex admissible relabel relabel lemma residual edges exist vertices heights differ relabeling vertex change residual network residual network admissible network neighbor lists edges relabel algorithm organized neighbor lists flow network neighbor list vertex singly linked list neighbors vertex appears list neighbor list vertices residual edge vertex pointed head vertex neighbor list pointed neighbor pointer nil vertex neighbor list relabel algorithm cycles neighbor list arbitrary order fixed execution algorithm vertex field current points vertex consideration initially current set head discharging overflowing vertex overflowing vertex discharged pushing excess flow admissible edges neighboring vertices relabeling edges leaving admissible pseudocode discharge current nil relabel current head elseif push current neighbor figure steps iterations loop lines executes long vertex positive excess iteration performs actions depending current vertex neighbor list nil relabels vertex resets current neighbor lemma states relabel operation applies situation nil admissible edge determi ned test pushes excess vertex nil inadmissible advances current position neighbor list figure discharging vertex takes iterations loop discharge push excess flow neighbors edges entering leaving number inside vertex excess iteration vertex height neighbor list iteration iteration number shaded neighbor current initially units excess push current iterations advance current admissible edges leaving iteration current nil shading neighbor list relabeled current reset head neighbor list relabeling vertex height iterations edges inadmissible units excess flow pushed iteration push current advanced iteration push iteration saturated edge inadmissible iteration iteration current nil vertex relabeled current reset iteration inadmissible units excess flow pushed iteration current advanced iteration iteration finds inadmissible iteration finds inadmissible iteration relabels vertex resets current iteration pushes units excess flow vertex excess flow discharge terminates dischar starts finishes current pointer head neighbor list general case observe discharge called overflowing vertex action performed discharge push procedure terminates relabel operation advancing pointer current push elabel called discharge operation applies lemma proves fact lemma discharge calls push push operation applies discharge calls relabel rela bel operation applies proof tests lines ensure push operation occurs operation applies proves statement lemma prove statement acco rding test lemma edges leaving inadmissible observe discharge repeatedly called pointer current moves list pass head finishes current nil point relabeled pass current pointer advance vertex pass edge deemed inadmissible test time pass completes edge leaving determined inadmissibl time pass key observation pass edge leaving inadmissible lemma pushes create admissibl edges leaving admissible edge created relabel operation vertex relabeled pass lemma vertex relabele pass entering admissible edges relabeling pass edges leaving remain inadmissible lemma proved relabel algorithm relabel algorithm maintain linked list consisting vertices key property vertices topologically sorted admissible network loop invariant recall lemma admissible network dag pseudocode relabel algorithm assume neighbor lists created vertex assumes points vertex list usual nil vertex list relabel initialize preflow order vertex current head head nil height discharge height list relabel algorithm works initializes preflow heights values generic push rela bel algorithm initializes list overflowing vertices order lines initialize current pointer vertex vertex neighbor list figure loop lines runs list discharging vertices start rtex list time loop vertex discharged relabeled discharge procedure moves list determination saving height variable height discharge operation comparing saved height height afterward iteration loop vertex list moved lis vertex iteration position list figure action relabel flow network iteration loop initially units flow leave source initial list initially vertex list neighbor list current neighbor shaded vertex discharged relabeled height units excess flow pushed remaining units excess pushed sink relabeled moved head case change structure vertex discharged figure detailed action discharging situation relabeled moved head vertex discharged pushing units excess flow vertex relabeled discharge operation remains place list vertex vertex discharged relabeled height units excess flow pushed relabeled moved vertex vertex discharged excess discharge returns remains place vertex discharged cess discharge returns remains place relabel reached list terminates overflowing vertices preflow maximum flow relabel computes maximum flow implementation generic push relabel algorithm observe performs push relabel operation apply lemma guarantees discharge performs apply rema ins relabel terminates basic operations apply remai nder correctness argument relies loop invariant test relabel list topological sort vertices admissible network gf vertex list excess flow initialization initia lize preflow edge admissible ø ordering topological sort gf initially head list vertices excess flow maintenance topological sort maintained iteration loop start observing admissible network changed push relabel operations lemma push operations edges admissible admissible edges created relabel operations vertex relabeled lemma states admissible edges entering admissible edges leaving moving algorithm ensures admissible edges leaving satisfy topological sort ordering vertex preceding excess flow denote vertex iteration vertices precede iteration include current vertices relabeled vertices relabeled discharged excess flow afterward relabeled discharge vertices preceding excess flow relabeled discharge vertices list acquired excess flow discharge remained topologically sorted times discharge pointed admissible edges created labeling pushing push operation excess flow vertices list vertices preceding excess flow termination loop terminates loop invariant ensures excess rtex basic operations apply analysis relabel runs v3 time flow network algorithm implementation generic push relabel algorithm advantage corollary bound number relabel operations executed vertex v2 bound total number relabel operations addition exercise bound total time spent performing relabel operations lemma bound total number saturating push operations theorem running time relabel flow network v3 proof phase relabel algorithm time consecutive relabel operations v2 phases v2 relabel operations phase consists calls discharge discharge perform label operation discharge list length discharge perform relabel discharge belongs phase phase calls discha rge v2 phases number times discharge called li relabel v3 total work performed loop relabel excluding work performed discharge v3 bound work performed discharge execution algorithm iteration loop discharge performs actions analyze total work involved performing actions start relabel operations lines exercise time bound v2 relabels performed suppose action updates current pointer action occurs degree times time vertex relabeled degree times vertex vertices total work advancing pointers neighbor lists handshaking lemma exercise type action performed discharge push operation total number saturating push operations observe nonsaturating push executed discharge immedi ately returns push reduces excess nonsaturating push discharge observed discharge called v3 times total time spent performing nonsaturating pushes v3 running time relab v3 v3 exercises illustrate execution rela bel manner figure flow network figure assume initial ordering vertices v1 v2 v3 v4 neighbor lists v1 v2 v3 v2 v1 v3 v4 v3 v1 v2 v4 v4 v2 v3 exercises implement push relabel algorithm maintain queue overflowing vertices algorithm repeat edly discharges vertex head queue vertices overflowing discharge overflowing afterward queue vertex head queue discharged removed algorithm terminates algorithm implemented compute maximum flow v3 time exercises generic algorithm works relabel updates simply computing change affect analysis relabel exercises discharge highest overflowing vertex push relabel method v3 time exercises suppose point execution push relabel algorithm ere exists integer vertex vertices source minimum cut exists gap heuristic updates vertex set max attribute height function gap heuristic crucial making implementations push relabel method perform practice problems escape problem grid undirected graph consisting rows columns vertices figure denote vertex ith row jth column vertices grid neighbors boundary vertices points figure grids escape problem starti points black grid vertices white grid escape shaded paths grid escape starting points y1 xm ym grid escape problem determine vertex disjoint paths starting points points boundary grid figure escape grid figure flow network vertices edges capacities total positive flow entering vert subject capacity constraint determining maximum flow network edge vertex capacities reduced ordinary maximum flow problem flow network comparable size efficient algorithm solv escape problem analyze running time problems minimum path cover path cover directed graph set vertex disjoint paths vertex included path paths start length including minimum path cover path cover fewest paths efficient algorithm minimu path cover directed acyclic graph hint assuming construct graph x0 y0 y1 yn x0 yi y0 maximum flow algorithm algorithm work directed aphs cycles explain problems space shuttle experiments professor spock consulting nasa planning series space shuttle flights decide commercial experiments perform instruments board flight light nasa considers set e1 experiments commercial sponsor experiment agreed pay nasa dollars experiment experiments set i1 instruments experiment requires instruments subset cost carrying instrument ik ck dollars professor job efficient algorithm determine experiments perform instruments carry flight order maximize net revenue total income experiments performed minus total cost instruments carried network network source vertex vertices i1 vertices e1 sink vertex edge ik capacity ck edge capacity ik edge ik infinite capacity finite capacity cut ik ik determine maximum net revenue capacity minimum cut values efficient algorithm determin experiments perform instruments carry analyze runni time algorithm terms problem updating maximum flow flow network source sink integer capacities suppose maximum flow suppose capacity single edge increased time algorithm update maximum flow suppose capacity single edge decreased time algorithm update maximum flow problem maximum flow scaling flow network source sink integer capacity edge max argue minimum cut capacity number augmenting path capacity time path exists modification ford fulkerson method compute maximum flow max flow scaling max initialize flow lgc exists augmenting path capacity augment flow return argue max flow scal ing returns maximum flow capacity mi nimum cut residual graph gf time executed argue loop lines executed times conclude max flow scaling implemented runs lg time problem maximum flow negative capacities suppose flow network negative posi tive edge capacities network feasible flow exist edge flow network explain negative capacity terms flow flow network negative edge capac ities source sink construct ordinary flow network capacity function source sink assign capacities edges edge set vertex set max max set prove feasible flow exists capacities nonnegative maximum flow exists edges sink saturated prove converse proof constructive flow saturates edges proof feasible flow algorithm finds maximum feasible flow denote mf worst case running tim ordinary maximum flow algorithm graph vertices edges analyze algorithm computing maximum flow flow network negative capacities terms mf problem hopcroft karp bipartite matching algorithm problem faster algor ithm hopcroft karp finding maximum matching bipartite graph algorithm runs time undirected bipartite graph edges endpoint matching simple path augmenting path respect starts unmatched vertex ends unmatched vertex edges belong alternately definition augmenting path augmenting path flow network problem treat path sequence edges sequence vertices shortest augmenting path respect matching augmenting path minimum number edges sets symmetric difference defined elements sets matching augmenting path respect symmetric difference matching vertex disjoint augmenting paths respect symmetric difference matching cardinality general structure algorithm hopcroft karp ø repeat maximum set vertex disjoint shortest augmenting paths respect return remainder problem asks anal yze number iterations algorithm number iterations repeat loop implementation matchings vertex graph degree conclude disjoint union simple paths cycles argue edges simp path cycle belong alternately prove vertex disjoint augmenting paths respect length shortest augmenting path respect matching maximum set vertex disjoint augmenting paths length respect suppose shortest augmenti path respect vertex disjoint edges suppose vertex disjoint set edges conclude edges prove shortest augmenting path length size maximum matching number repeat loop iterations algorithm hint grow iteration number algorithm runs time maximum set vertex disjoint shortest augmenting paths matching conclude total running time hopcroft karp chapter notes ahuja magnanti orlin lawler papadimitriou steiglitz tarjan good references network flow algorithms goldberg tardos tarjan provide nice survey gorithms network flow problems schrijver written interesting review historical developments field network flows ford fulkerson method ford fulkerson originated formal study problems area network flow including maximum flow bipartite matching problems early impl ementations ford fulkerson method augmenting paths breadth search edmonds karp independently dinic proved strategy yields polynomial time algorithm idea blocki flows developed dinic karzanov developed idea preflows push relabel method goldberg goldberg tarjan goldberg tarjan v3 time algorithm queue maintain set overflowing vert ices algorithm dynamic trees achieve running time lg v2 researchers developed push relabel ximum flow algorithms ahuja orlin ahuja orlin tarjan algorithms scaling cheriyan maheshwari proposed pushing flow overflowi vertex maximum height cheriyan hagerup suggested randomly permuting nei ghbor lists researchers developed clever derandomizati ons idea leading sequence faster algorithms algorithm king rao tarjan fastest algorithm runs loge lg time asymptotically fastest algorithm maximum flow problem goldberg rao runs time min v2 e1 lg v2 lg max algorithm pus relabel method based finding blocking flows previous maximum flow algorithms including chapter notion distance pus relabel algorithms analogous notion height length assigned implicitly edge algorithm takes approach assigns length high capacity edges length low capacity edges informally respect lengths shortest paths source sink tend high capacity fewer iterations performed practice push relabel algorithms dominate augmenting path linear programming based algorithms maximum flow problem study cherkassky goldberg underscores tw heuristics implementing push relabel algorithm heuristic peri odically perform breadth search residual graph order accurate height values heuristic gap heuristic exericse conclude choice push relabel variants chooses discharge overflowing vertex maximum height algorithm ximum bipartite tching discovered hopcroft karp runs time problem book lovász plummer excellent reference matching problems vii selected topics chapter list chapter sorting networks chapter matrix operations chapter linear programming chapter polynomials fft chapter number theoretic algorithms chapter string matching chapter computational geometry chapter np completeness chapter approximation algorithms introduction selection algorithmic topics extend complement earlier material book chapters intr oduce models computation combinational circuits para llel computers cover specialized domains computational geometry number theory chapters discuss limitations design ficient algorithms introduce techniques coping limitations chapter presents parallel model putation comparison networks roughly speaking comparison network algorithm comp arisons simultaneously chapter build comparison network sort numbers lg2 time chapter studies efficient algorithms operati matrices examining basic matrix properties explores strassen algorithm multiply matrices time presents general methods lu decomposition lup decomposition solving linear equa tions gaussian elimination n3 time matrix inversion matrix multip lication performed equally fast chapter concludes showing squares approximate solution computed set linear equati ons exact solution chapter studies linear programming maximize minimize objective limited resources competing constraints linear programming arises variety practical application areas chapter covers formulation solution linear programs solution method covered simplex algorithm oldest algorithm linear programming contrast algorit hms book simplex algorithm polynomial time worst case fairly efficient practice chapter studies operations polynomials signal processing technique fast fourier transform fft multiply degree polynomials lg time investigates efficient implementations fft including parallel circuit chapter presents number theoretic algorithms review elementary number theory presents euclid algorithm comp uting greatest common divisors algorithms solving modular linear equations ising number power modulo number presented application number theoretic algorithms rsa public key cryptosystem cryptosystem encrypt messages adversary read provide digital signatures chapter presents rabin randomized primality test large primes efficiently ssential requirement rsa finally chapter covers pollard rho heuristic factoring integers discusses state art integer factorization chapter studies problem finding occurre nces pattern string text string problem arises frequently text editing programs examining naive approach chapter presents elegan approach rabin karp showing efficient solution based finite automata chapter presents knuth morris pratt algorithm achieves efficiency cleverly preprocessing pattern computational geometry topic chapter discussing basic primitives computational geometry chapter sweeping method efficiently determine set segments contai intersections clever algorithms finding convex hull set points graham scan jarvis march illustrate power sweeping methods chapter closes effi cient algorithm finding closest pair set points plane chapter concerns np complete problems teresting computati onal problems np complete polynomial time algorithm lving chapter presents techniques determining wh problem np complete classic problems proved np complete determ ining graph hamiltonian cycle determining boolean formula satisfiable determining ven set numbers subset adds target chapter proves famous traveling salesman problem np complete chapter approximation algorithms approximate solutions np complete problems efficiently np complete problems approximate solutions optimal easy produ approximation algorithms work progressively problem size increases problems invest incr easing amounts comput ation time return increasingly approximate solutions chapter illustrates possibilities vertex cover problem unweighted weighted versions optimization version cnf satisfiability traveling salesman probl set covering problem subset sum problem chapter sorting networks overview examined sorting algorithms serial computers random access machines ram operatio executed time chapter investigate sorting algorithms based comparison twork model computation comparison operations performed simultaneously comparison networks differ ram respects perform comparisons algo rithm counting sort implemented comparison network ram model operations occur serially operati ons comparison network occur time parallel characteristic construction comparison networks sort values sublinear time defining comparison networks sorting networks natural definition running time comparison network terms depth network proves principle greatly eases task analyzing correctness sorting networks efficient sorting network desi gn essentially parallel version merge sort algorithm construction steps presents design bitonic sorter basic building block modify bitonic sorter produce merging network merge sorted sequences sorted sequence finally assemble merging networks sorting network sort values lg time comparison networks sorting networks comparison networks sort inputs sense discussion comparison networ ks characteristics comparison network composed solely wires comparators comparator figure device inputs outputs performs function figure comparator inputs outputs comparator drawn single vertical inputs outputs min max pictorial represen tation comparator figure bulky purposes adopt convention draw ing comparators singl vertical lines figure inputs left outputs smaller input appearing output larger input appearing output comp arator sorting inputs assume comparator operates time assume time appearance input values production output values constant wire transmits place place wires connect output comparator input network input wires network output wires chapter assume comparison network input wires values sorted enter network output wires produce computed network speak input sequence output sequence referring values input output wires wire carries intention clear context figure comparison network set comparators interconnected wires draw comparison network inputs collection horizontal lines comparators stretched verti cally note represent single wire sequence distinct wires connecting comparators figure represents wires input wire connects input comparator wire connecting output comparator input comparator output wire output comparator comparator nput connected wire network input wires connected output comparator comparator output connect wire network output wires connected input comparator main requirement interc onnecting comparators graph interconnections acyclic trace path output comparator input output input path trace cycle comp arator figure draw comparison network network inputs left network outputs data network left figure input output comparison network fact sorting network time input values input wires time values outputs comparators depth time values outputs comparators depth output wires b4 final values output wires time values outputs comparator depth output wires final values comparator produces output values input values figure suppose seque nce appears input wires time time comparators input values assuming comparator requir time unit compute output values comparators produce outputs time values figure note comparators produce values time parallel time comparators input values time unit time oduce outputs figure comparators operate parallel output comparator output comparator connect output wires b4 comparison network network output wires carry final values time time comparator inputs figure produces output values time values carried network output wires output sequence complete assumption comparator unit time define running time comparison network time takes output wires receive values input wires receive formally time largest number comparators input element pass thro ugh travels input wire output wire formally define depth wire input wire comparison network depth mparator input wires depths output wires depth max cycles comparators comparison network depth wire defined define depth comparator depth output wires figure comparator depths depth comparison network maximum depth output wire equivalently maximum depth comparator comparison network figure depth comparator depth comparator takes time unit produce output netw ork inputs time comparator depth produces outputs time depth network equals time network produce values output wires sorting network comparison network output sequence monotonically increasing input sequence comparison network sorting network network figure observe time minimum input values produced output comparator output comparator time output comparator symmetrical argument time maximum input values produced output comparator remains comparator ensure middl values occupy correct output positions time comparison network procedure specifies comparisons occur procedure size number comparators depends number inputs outputs describing families comparison networks goal chapter develop family sorter efficient sorting networks network family family number inputs equals number outputs input output sorting network family sorter named sorter exercises values wires network figure input sequence exercises exact power construct input output comparison network depth lg output wire carries minimum input output wire carri maximum input exercises sorti network add comparator comparison network sorting network add mparator network figure network sort input permutation exercises prove sorting network inputs depth lg exercises prove number comparat ors sorting network lg exercises comparison network figure prove fact sorting network structure insertion sort figure sorting network based insertion sort exercise exercises represent input comparison network comparators list pairs integers range pairs integer common order comparators network determined der pairs list representation time serial algorithm determining depth comparison network exercises suppose addition standard kind comparator introduce upside comparator produces minimum output wire maximum output wire convert sorting network total standard upside comparators standard prove conversion method correct principle principle sorting network works correctly input drawn set works corr ectly arbitrary input numbers numbers integers reals general set values linea rly ordered set construct sorting networks comparis networks principle focus operation input sequences consisting solely constructed sorting network proved sort sequences appeal principle properly sorts sequences arbitrary values proof principle relies notion monotonically increasing function lemma comparison network transforms input sequence output sequence monotonically increasing function network transforms input sequence output sequence proof prove claim monotonically increasing function single comparator inputs produces outputs min max induction prove lemma prove claim mparator input values upper output comparator min lower output max suppose apply inputs comp arator figure operation comparator yields min upper output max lower output monotonically increasing implies identities min max max min figure operation comparator proof lemma function monotonically increasing comparator produces values min max inputs completes proof claim induction depth wire general comparison network prove stronger result statement lemma wire assumes ai input sequence applied network assumes ai input sequence applied output wires incl uded statement proving prove lemma basis wire depth input wire ai result trivially applied network input wire carries ai inductive step wire depth wire output comparator depth input wires comparator depth strictly inductive hypothesis input wires comparator carry values ai input sequence applied carry ai input sequence applied earlier claim output wires comparator carry min ai max ai carry min ai max ai input sequence lemma proved application lemma figure sorting network figure repeated figure monotonically increasing function applied inputs wire applied wire figure figure sorting network figure input sequence sorting network monotonically increasing function applied inputs wire network applied wire comparison network sorting network lemma prove remarkable result theorem principle comparison network inputs sorts sequences correctly sorts sequences arbitrary numbers correctly proof suppose purpose contradiction network sorts sequences exists sequence arbitrary numbers network correctly sort exists input sequence elements ai ai network places ai output sequence define monotonically increasing function network places ai output sequence input lemma places ai output sequence input ai contradiction network fails sort sequence correctly exercises prove applying monotonically increasi function sorted sequence produces sorted sequence exercises prove comparison network inputs correctly sorts input sequence correctly sorts sequences exercises principle prove comparison network figure sorting network figure sorting network sorting numbers exercises state prove analog principle decision tree model hint handle equality properly exercises prove input sorting network comparator ith lines bitonic sorting network step construction efficient sorting network construct comparison network sort bitonic sequence sequence monotonically increases monotonically decreases circularly shifted monotonically increasing monotonically decreasing sequences bitonic boundary condition sequence numbers itonic sequences bitonic simple structure form form note sequence monotonically increasing monotonically decreasing bitonic bitonic sorter construct comparison network sorts bitonic sequences exercise asks bitonic sorter sort bitonic sequences arbitrary numbers half cleaner bitonic sorter composed seve ral stages called half cleaner half cleaner comparison networ depth input compared assume figure half cleaner half cleaner inputs outputs figure comparison network half cle aner sample input output values input assumed itonic half cleaner ensures output element half small output element half halves bit onic half clean bitonic sequence applie input half cleaner half cleaner produces output sequence smaller values half larger values half halves bitonic fact halves clean consisting property derive half cleaner note clean sequences bito nic lemma proves properties half cleaners lemma input half cleaner bitonic sequence output satisfies properties half half bitonic element half small element half half clean proof comparison network half cleaner compares inputs loss generality suppose input form situation input form symmetric cases dependi block consecutive midpoint falls cases midpoint occurs block split cases cases figure case lemma holds figure comparisons half cleaner input sequence assumed bitonic sequence loss generality assume form subsequences white subsequences gray inputs divided halves inputs compared cases division occurs middle subsequence cases division ccurs subsequence cases element half output small element half halves bitonic half clean bitonic sorter recursively combining half cleaners figure build bitonic sorter network sorts bitonic sequences stage bitonic sorter consists half cleaner lemma produces bitonic sequences half size elemen half small element half comple sort copies bitonic sorter sort halves recursively figure recursion explicitly figure recursion unrolled progressively smaller half cleaners remainder bitonic sorter depth bitonic sorter recurrence solution lg figure comparison network bitonic sorter recursive construction half cleaner copies bitonic sorter operate parallel network unrolling recursion half cleaner shaded sample values wires bitonic sequence sorted bitonic sorter depth lg analog principle exercise bitonic sequence arbitrary numbers sorted network exercises bitoni sequences length exercises bitonic sorter exact power lg comparators exercises lg depth bitonic sorter constructed number inputs exact power exercises input half cleaner bitonic sequence arbitrary numbers prove output satisfies properties half half bitonic element half small element half exercises sequences prove element sequence small element sequen sequences clean exercises prove analog principle bitonic sorting networks comparison network sort bitonic sequence sort bitonic sequence arbitrary numbers chapter notes ahuja magnanti orlin lawler papadimitriou steiglitz tarjan good references network flow algorithms goldberg tardos tarjan provide nice survey gorithms network flow problems schrijver written interesting review historical developments field network flows ford fulkerson method ford fulkerson originated formal study problems area network flow including maximum flow bipartite matching problems early impl ementations ford fulkerson method augmenting paths breadth search edmonds karp independently dinic proved strategy yields polynomial time algorithm idea blocki flows developed dinic karzanov developed idea preflows push relabel method goldberg goldberg tarjan goldberg tarjan v3 time algorithm queue maintain set overflowing vert ices algorithm dynamic trees achieve running time lg v2 researchers developed push relabel ximum flow algorithms ahuja orlin ahuja orlin tarjan algorithms scaling cheriyan maheshwari proposed pushing flow overflowi vertex maximum height cheriyan hagerup suggested randomly permuting nei ghbor lists researchers developed clever derandomizati ons idea leading sequence faster algorithms algorithm king rao tarjan fastest algorithm runs loge lg time asymptotically fastest algorithm maximum flow problem goldberg rao runs time min v2 e1 lg v2 lg max algorithm pus relabel method based finding blocking flows previous maximum flow algorithms including chapter notion distance pus relabel algorithms analogous notion height length assigned implicitly edge algorithm takes approach assigns length high capacity edges length low capacity edges informally respect lengths shortest paths source sink tend high capacity fewer iterations performed practice push relabel algorithms dominate augmenting path linear programming based algorithms maximum flow problem study cherkassky goldberg underscores tw heuristics implementing push relabel algorithm heuristic peri odically perform breadth search residual graph order accurate height values heuristic gap heuristic exericse conclude choice push relabel variants chooses discharge overflowing vertex maximum height algorithm ximum bipartite tching discovered hopcroft karp runs time problem book lovász plummer excellent reference matching problems vii selected topics chapter list chapter sorting networks chapter matrix operations chapter linear programming chapter polynomials fft chapter number theoretic algorithms chapter string matching chapter computational geometry chapter np completeness chapter approximation algorithms introduction selection algorithmic topics extend complement earlier material book chapters intr oduce models computation combinational circuits para llel computers cover specialized domains computational geometry number theory chapters discuss limitations design ficient algorithms introduce techniques coping limitations chapter presents parallel model putation comparison networks roughly speaking comparison network algorithm comp arisons simultaneously chapter build comparison network sort numbers lg2 time chapter studies efficient algorithms operati matrices examining basic matrix properties explores strassen algorithm multiply matrices time presents general methods lu decomposition lup decomposition solving linear equa tions gaussian elimination n3 time matrix inversion matrix multip lication performed equally fast chapter concludes showing squares approximate solution computed set linear equati ons exact solution chapter studies linear programming maximize minimize objective limited resources competing constraints linear programming arises variety practical application areas chapter covers formulation solution linear programs solution method covered simplex algorithm oldest algorithm linear programming contrast algorit hms book simplex algorithm polynomial time worst case fairly efficient practice chapter studies operations polynomials signal processing technique fast fourier transform fft multiply degree polynomials lg time investigates efficient implementations fft including parallel circuit chapter presents number theoretic algorithms review elementary number theory presents euclid algorithm comp uting greatest common divisors algorithms solving modular linear equations ising number power modulo number presented application number theoretic algorithms rsa public key cryptosystem cryptosystem encrypt messages adversary read provide digital signatures chapter presents rabin randomized primality test large primes efficiently ssential requirement rsa finally chapter covers pollard rho heuristic factoring integers discusses state art integer factorization chapter studies problem finding occurre nces pattern string text string problem arises frequently text editing programs examining naive approach chapter presents elegan approach rabin karp showing efficient solution based finite automata chapter presents knuth morris pratt algorithm achieves efficiency cleverly preprocessing pattern computational geometry topic chapter discussing basic primitives computational geometry chapter sweeping method efficiently determine set segments contai intersections clever algorithms finding convex hull set points graham scan jarvis march illustrate power sweeping methods chapter closes effi cient algorithm finding closest pair set points plane chapter concerns np complete problems teresting computati onal problems np complete polynomial time algorithm lving chapter presents techniques determining wh problem np complete classic problems proved np complete determ ining graph hamiltonian cycle determining boolean formula satisfiable determining ven set numbers subset adds target chapter proves famous traveling salesman problem np complete chapter approximation algorithms approximate solutions np complete problems efficiently np complete problems approximate solutions optimal easy produ approximation algorithms work progressively problem size increases problems invest incr easing amounts comput ation time return increasingly approximate solutions chapter illustrates possibilities vertex cover problem unweighted weighted versions optimization version cnf satisfiability traveling salesman probl set covering problem subset sum problem chapter sorting networks overview examined sorting algorithms serial computers random access machines ram operatio executed time chapter investigate sorting algorithms based comparison twork model computation comparison operations performed simultaneously comparison networks differ ram respects perform comparisons algo rithm counting sort implemented comparison network ram model operations occur serially operati ons comparison network occur time parallel characteristic construction comparison networks sort values sublinear time defining comparison networks sorting networks natural definition running time comparison network terms depth network proves principle greatly eases task analyzing correctness sorting networks efficient sorting network desi gn essentially parallel version merge sort algorithm construction steps presents design bitonic sorter basic building block modify bitonic sorter produce merging network merge sorted sequences sorted sequence finally assemble merging networks sorting network sort values lg time comparison networks sorting networks comparison networks sort inputs sense discussion comparison networ ks characteristics comparison network composed solely wires comparators comparator figure device inputs outputs performs function figure comparator inputs outputs comparator drawn single vertical inputs outputs min max pictorial represen tation comparator figure bulky purposes adopt convention draw ing comparators singl vertical lines figure inputs left outputs smaller input appearing output larger input appearing output comp arator sorting inputs assume comparator operates time assume time appearance input values production output values constant wire transmits place place wires connect output comparator input network input wires network output wires chapter assume comparison network input wires values sorted enter network output wires produce computed network speak input sequence output sequence referring values input output wires wire carries intention clear context figure comparison network set comparators interconnected wires draw comparison network inputs collection horizontal lines comparators stretched verti cally note represent single wire sequence distinct wires connecting comparators figure represents wires input wire connects input comparator wire connecting output comparator input comparator output wire output comparator comparator nput connected wire network input wires connected output comparator comparator output connect wire network output wires connected input comparator main requirement interc onnecting comparators graph interconnections acyclic trace path output comparator input output input path trace cycle comp arator figure draw comparison network network inputs left network outputs data network left figure input output comparison network fact sorting network time input values input wires time values outputs comparators depth time values outputs comparators depth output wires b4 final values output wires time values outputs comparator depth output wires final values comparator produces output values input values figure suppose seque nce appears input wires time time comparators input values assuming comparator requir time unit compute output values comparators produce outputs time values figure note comparators produce values time parallel time comparators input values time unit time oduce outputs figure comparators operate parallel output comparator output comparator connect output wires b4 comparison network network output wires carry final values time time comparator inputs figure produces output values time values carried network output wires output sequence complete assumption comparator unit time define running time comparison network time takes output wires receive values input wires receive formally time largest number comparators input element pass thro ugh travels input wire output wire formally define depth wire input wire comparison network depth mparator input wires depths output wires depth max cycles comparators comparison network depth wire defined define depth comparator depth output wires figure comparator depths depth comparison network maximum depth output wire equivalently maximum depth comparator comparison network figure depth comparator depth comparator takes time unit produce output netw ork inputs time comparator depth produces outputs time depth network equals time network produce values output wires sorting network comparison network output sequence monotonically increasing input sequence comparison network sorting network network figure observe time minimum input values produced output comparator output comparator time output comparator symmetrical argument time maximum input values produced output comparator remains comparator ensure middl values occupy correct output positions time comparison network procedure specifies comparisons occur procedure size number comparators depends number inputs outputs describing families comparison networks goal chapter develop family sorter efficient sorting networks network family family number inputs equals number outputs input output sorting network family sorter named sorter exercises values wires network figure input sequence exercises exact power construct input output comparison network depth lg output wire carries minimum input output wire carri maximum input exercises sorti network add comparator comparison network sorting network add mparator network figure network sort input permutation exercises prove sorting network inputs depth lg exercises prove number comparat ors sorting network lg exercises comparison network figure prove fact sorting network structure insertion sort figure sorting network based insertion sort exercise exercises represent input comparison network comparators list pairs integers range pairs integer common order comparators network determined der pairs list representation time serial algorithm determining depth comparison network exercises suppose addition standard kind comparator introduce upside comparator produces minimum output wire maximum output wire convert sorting network total standard upside comparators standard prove conversion method correct principle principle sorting network works correctly input drawn set works corr ectly arbitrary input numbers numbers integers reals general set values linea rly ordered set construct sorting networks comparis networks principle focus operation input sequences consisting solely constructed sorting network proved sort sequences appeal principle properly sorts sequences arbitrary values proof principle relies notion monotonically increasing function lemma comparison network transforms input sequence output sequence monotonically increasing function network transforms input sequence output sequence proof prove claim monotonically increasing function single comparator inputs produces outputs min max induction prove lemma prove claim mparator input values upper output comparator min lower output max suppose apply inputs comp arator figure operation comparator yields min upper output max lower output monotonically increasing implies identities min max max min figure operation comparator proof lemma function monotonically increasing comparator produces values min max inputs completes proof claim induction depth wire general comparison network prove stronger result statement lemma wire assumes ai input sequence applied network assumes ai input sequence applied output wires incl uded statement proving prove lemma basis wire depth input wire ai result trivially applied network input wire carries ai inductive step wire depth wire output comparator depth input wires comparator depth strictly inductive hypothesis input wires comparator carry values ai input sequence applied carry ai input sequence applied earlier claim output wires comparator carry min ai max ai carry min ai max ai input sequence lemma proved application lemma figure sorting network figure repeated figure monotonically increasing function applied inputs wire applied wire figure figure sorting network figure input sequence sorting network monotonically increasing function applied inputs wire network applied wire comparison network sorting network lemma prove remarkable result theorem principle comparison network inputs sorts sequences correctly sorts sequences arbitrary numbers correctly proof suppose purpose contradiction network sorts sequences exists sequence arbitrary numbers network correctly sort exists input sequence elements ai ai network places ai output sequence define monotonically increasing function network places ai output sequence input lemma places ai output sequence input ai contradiction network fails sort sequence correctly exercises prove applying monotonically increasi function sorted sequence produces sorted sequence exercises prove comparison network inputs correctly sorts input sequence correctly sorts sequences exercises principle prove comparison network figure sorting network figure sorting network sorting numbers exercises state prove analog principle decision tree model hint handle equality properly exercises prove input sorting network comparator ith lines bitonic sorting network step construction efficient sorting network construct comparison network sort bitonic sequence sequence monotonically increases monotonically decreases circularly shifted monotonically increasing monotonically decreasing sequences bitonic boundary condition sequence numbers itonic sequences bitonic simple structure form form note sequence monotonically increasing monotonically decreasing bitonic bitonic sorter construct comparison network sorts bitonic sequences exercise asks bitonic sorter sort bitonic sequences arbitrary numbers half cleaner bitonic sorter composed seve ral stages called half cleaner half cleaner comparison networ depth input compared assume figure half cleaner half cleaner inputs outputs figure comparison network half cle aner sample input output values input assumed itonic half cleaner ensures output element half small output element half halves bit onic half clean bitonic sequence applie input half cleaner half cleaner produces output sequence smaller values half larger values half halves bitonic fact halves clean consisting property derive half cleaner note clean sequences bito nic lemma proves properties half cleaners lemma input half cleaner bitonic sequence output satisfies properties half half bitonic element half small element half half clean proof comparison network half cleaner compares inputs loss generality suppose input form situation input form symmetric cases dependi block consecutive midpoint falls cases midpoint occurs block split cases cases figure case lemma holds figure comparisons half cleaner input sequence assumed bitonic sequence loss generality assume form subsequences white subsequences gray inputs divided halves inputs compared cases division occurs middle subsequence cases division ccurs subsequence cases element half output small element half halves bitonic half clean bitonic sorter recursively combining half cleaners figure build bitonic sorter network sorts bitonic sequences stage bitonic sorter consists half cleaner lemma produces bitonic sequences half size elemen half small element half comple sort copies bitonic sorter sort halves recursively figure recursion explicitly figure recursion unrolled progressively smaller half cleaners remainder bitonic sorter depth bitonic sorter recurrence solution lg figure comparison network bitonic sorter recursive construction half cleaner copies bitonic sorter operate parallel network unrolling recursion half cleaner shaded sample values wires bitonic sequence sorted bitonic sorter depth lg analog principle exercise bitonic sequence arbitrary numbers sorted network exercises bitoni sequences length exercises bitonic sorter exact power lg comparators exercises lg depth bitonic sorter constructed number inputs exact power exercises input half cleaner bitonic sequence arbitrary numbers prove output satisfies properties half half bitonic element half small element half exercises sequences prove element sequence small element sequen sequences clean exercises prove analog principle bitonic sorting networks comparison network sort bitonic sequence sort bitonic sequence arbitrary numbers merging network sorting network constructed merging networks networks merge sorted input sequences sorted output sequence modify bitonic sorter create merging network merger bitonic sorter prove correctness merging network inputs sequences exercise asks proof extended arbitrary input values merging network based tuition sorted sequences reverse order sequence concatenate sequences sequence bitonic exampl sorted sequences reverse concatenating yields bitonic merge input sequences suffices perform bitonic sort concatenated construct merger modifying half cleaner bitonic sorter key perform reversal ond half inputs imp licitly sorted sequences merged bitonically sorting sequence half cleaner bitonic sorter compares inputs stage merging network compare inputs figure correspondence subtlety order outputs stage merger reversed compared orde outputs ordinary half cleaner reversal bitonic seque nce bitonic outputs stage merg ing network satisfy properties lemma tonically sorted parallel produce sorted output merging network figure comparing stage merger half cleaner stage merger transforms monotonic input sequences bitonic sequences equivalent operation half cleaner bitonic input sequence transformed bitonic sequences merging network figure stage merger bitonic sorter depth merger lg bitonic sorter figure network merges sorted input sequences sorted output sequence network merger viewed bitonic sorter half cleaner altered compare inputs network decomposed stage parallel copies bitonic sorter network recursi unrolled sample zer values wires stages shaded exercises prove analog principle merging networks comparison network merge notonically increasing sequences merge monotonically increa sing sequences arbitrary numbers exercises inpu sequences applied input comparison network verify merging network exercises network merge item sorted items produce sorted sequence length depth lg exercises merging network inputs exact power monotonic sequences merged prove number comparators kind merging network lg interesting lower bound hint partition comparators sets exercises prove merging network regardle order inputs requires lg comparators sorting network tools construct network sort input sequence sorting network sorter merging network implement parallel version merge sort construction operation sorting network illustrated figure figure sorting network sorter constructed recursively combining merging networks recursive construction unrolling recursion replacing merger boxes actual merging tworks depth comparator sample valu wires figure recursive onstruction sorter input elements sorted copies sorter recursively sort parallel subsequences length sequences merged merger boundary case recursion case wire sort element sequence elem ent sequence sorted figure result unrolling recursion figure actual network replacing merger boxes figure actual merging networks data pass lg stages network sorter individual inputs network sorted element sequence stage sorter consists copies merger work parallel merge pairs element sequences produce sorted sequences length stage consists copies merger merge pairs element sorted sequences produce sorted sequences length general lg stage consistsk copies merger merge pairs element sorted sequences oduce sorted sequences length final stage sorted sequence consisting input values produced sorting network induction sort sequences principle theorem sort arbitrary values analyze depth rting network recursively depth sorter depth sorter copies sorter operate parallel depth lg merger depth sorter recurrence solution lg2 version master method exercise sort numbers parallel lg2 time exercises comparators sorter exercises depth sorter lg lg exercises suppose elements a2n partition smallest largest prove constant additional depth separately sorting a2n exercises depth sorting network inputs depth merging network inputs suppose sequence numbers sorted number positions correct position sorted order sort numbers depth exercises sort entries matrix repeating procedure times sort odd numbered row monotonically increasing order sort numbered row monotonically decreasing order sort column monotonically increasing order iterations required procedure sort order read matrix entries iterations sorted output problems transpositi sorting networks comparison network transposition network comparator connects adjacent lines network figure transposition sorting network inputs comparators prove transposition network inputs sorting network sorts sequence hint induction argument analogous proof lemma odd sorting network inputs transposition sorting network levels comparators connected brick pattern illustrated figure figure connected depth comparator figure odd sorting network inputs prove odd sorting networks sort problems batcher odd merging network construct merging netw ork based bitonic sorting problem construct odd merging network assume exact power merge sorted sequence elements lines lines a2n comparator lines recursively construct odd merging networ ks operate parallel merges sequence lines sequence lines a2n odd elements merges a2n elements combine sorted subsequences comparator a2i a2i draw input merging network professor corrigan suggests combine sorted subsequences produced recursive merging putting comparator a2i a2i comparator a2i a2i draw input network counterexample professor mistaken thinking network produced merging network input merging network pa works properly principle prove input odd merging network merging network depth input odd merging netw ork size problems permutation networks permutation network inputs outputs switches connect inputs outputs permutations figure input output permutation network consists single switch set feed inputs straight rough outputs cross figure permutation networks permutation network consists single switch set ways recursive construction p8 switches p4 switches p4 set realize permutation argue replace comparator sorting network switch figure network permutation network permutation set switche network input connected output figure recursive construction input output permutation network p8 copies p4 switches switches set realize permutation requires recursively p4 realize p4 realize realize permutation p8 drawing switch settings permut ations performed p4 exact power define recursively terms manner defined p8 time ordinary random access mach ine algorithm sets switches connected inputs outputs specifies permutations realized order accomplish element permutation prove algorithm correct depth size long ordinary random access machine compute switch settings including argue permutation network realize permutation distinct comb inations switch settings chapter notes knuth discussion sorting networks charts history explored armstrong nelson connor early batcher discovere network capable merging sequences numbers lg time odd merging problem technique sort numbers lg2 time shortly afterward discovered lg depth bitonic sorter simila presented knuth attributes principle ouricius proved context decision trees long time question remained open sorting network depth lg exists answer unsatisfying aks sorting network named developers ajtai komlós szemerédi sort numbers depth lg lg comparators unfortunatel constants hidden notation large thousands considered practical chapter matrix operations overview operations matrices heart scientific computing efficient algorithms working matrices practical chapter introduction matrix theory trix operations emphasizing problems multiplying matrices solving sets simultaneous linear equations introduces basic matrix concepts notations presents strassen surprising algorithm multiplying matrices nlg time solve set linear equations lup decompositions explores close relationship problem multiplying matrices problem inverting matrix finally discusses class symmetric positive definite matrices squares solution overdetermine set linear equations issue arises practice numerical stability limited precision floating point representations actual computers round errors numerical computations amplified ourse computation leading incorrect computations numerically unstable numerical stability occasion focus chapter refer reader excellent book golub van loan discussion stability issues properties matrices review basic concep matrix theory fundamental properties matrices focusing needed sections matrices vectors matrix rectangular array numbers matrix aij element matrix row column aij uppercase letters denote matrices subscripted lowercase letters denote elements set matrices real valued entries denoted general set matrices entries drawn set denoted transpose matrix matrix exchanging rows columns matrix equation vector dimensional array numbers vector size lowercase tters denote vectors denote ith element size vector standard form vector column vector equivalent matrix row vector transpose unit vector vector ith element elements size unit vector clear context matrix matrix entry su matrix denoted ambiguity number matrix easily resolved context matrix intended size matrix derived context square matrices frequently speci cases square matrices diagonal matrix aij diagonal elements matrix listing elements diagonal identity matrix diagonal matrix ith diagonal appears subscript size derived context ith column identity matrix unit vector tridiagonal matrix tij nonzero entries main diagonal main diagonal main diagonal upper triangular matrix uij entries diagonal upper triangular matrix unit upper triangular diagonal lower triangular matrix lij entries diagonal lower triangular matrix unit lower triangular diagonal permutation matrix row column permutation matrix matrix called permutation matrix multiplying vector permutation matrix permuting rearranging elements symmetric matrix satisfies condition symmetric matrix operations matrices elements matrix vector numbers number real numbers complex numbers integers modulo prime number defines add multiply numbers extend definitions encompass addition multiplication matrices define matrix addition aij bij matrices matrix sum cij matrix defined cij aij bij matrix addition performed componentwise matrix identity matrix addition number aij matrix aij scalar multiple multiplying elements special case define negative matrix aij ijth entry aij definition define matrix subtraction addition negative matrix define matrix multiplication start matrices compatible sense number columns equals number rows general expression matrix product assumed imply matrices compatible aij matrix bjk matrix matrix product matrix cik procedure matrix multiply implements matrix multiplication straightforward manner based equation assuming matrices square multiply matrices matrix multiply performs n3 multiplications additions running time n3 matrices alge braic properties typical numbers identity matrices identities matrix multiplication matrix multiplying matrix matrix matrix multiplication associative compatible matrices matrix multiplication distributes addition multiplication matrices commutative matrix vector products vector vector products defined vector equivalent matrix matrix case row vector matrix vector size vector size vectors size number matrix called product matrix xyt matrix called outer product zij euclidean norm vector size defined xtx norm length dimensional euclidean space matrix inverses ranks determinants define inverse matrix matrix denoted exists aa nonzero matrices inverses trix inverse called noninvertible singular nonzero singular matrix matrix inverse called invertible nonsingular matrix inverses exist unique exercise nonsingular matrices inverse operation commutes transpose operation vectors linearly dependent exist coefficients c1x1 c2x2 row vectors linearly dependent vectors linearly dependent linearly independent columns identity matrix linearly independent column rank nonzero matrix size largest set linearly independent columns row rank size largest set linearly independent rows fundamental prope rty matrix row rank equals column rank simply refer rank rank matrix integer min inclusive rank matrix rank identity matrix alternate equivalent definition rank nonzero matrix smallest number exist matrices respective sizes square matrix rank rank matrix column rank rank fundamental property ranks theorem theorem square matrix rank nonsingular null vector matrix nonzero vector theorem proof left exercise corollary relate notions column rank singularity null vectors theorem matrix column rank null vector corollary square matrix singular null vector ijth minor matrix matrix deleting ith row jth column determinant matrix defined recursively terms minors term det cofactor element aij theorems proofs express fundamental properties determinant theorem determinant properties determinant square matrix properties row column det determinant multiplied entries row column multiplied determinant unchanged entries row column row column determinant equals determinant determinant multiplied rows columns exchanged square matrices det det det theorem matrix singular det positive definite matrices positive definite matrices play portant role applications matrix positive definite size vectors identity matrix positive definite nonzero vector matrices app lications positive definite theorem theorem matrix column rank matrix positive definite proof ata nonzero vector vector ata exercise note sum squares elements vector element column rank implies theorem positive definite properties positive definite matrices explored exercises symmetric matrices exercises prove symmetric matrix exercises prove matrix inverses unique inverses exercises prove product lower triangular matrices lowe triangular prove determinant lower triangular upper triangular matrix equal product diagonal elements prove inverse lower triangular matrix exists lower triangular exercises prove permutation matrix matrix permuting rows permuting columns prove product permuta tion matrices permutation matrix prove permutation matrix invertible inverse permutation matrix exercises matrices prove adding row row inverse subtracting column column exercises nonsingular matrix complex entries entry real entry real exercises nonsingular symmetric matrix symmetric arbitrary matrix matrix product abt symmetric exercises prove theorem matrix column rank implies hint express linear dependence column matrix vector equation exercises prove compatible matrices rank min rank rank equality holds nonsingular square matrix hint alternate definition rank matrix exercises numbers x0 prove determinant vandermonde matrix hint multiply column x0 add column induction strassen algorithm matrix multiplication presents strassen remarkable recursive algorithm multiplying matrices runs nlg time large values outperforms naive n3 matrix multiplication algor ithm matrix multiply overview algorithm strassen algorithm viewed appli cation familiar sign technique divide conquer suppose compute product matrices assuming exact power divide matrices rewriting equation exercise deals situation exact power equation corresponds equations equations specifies multiplications matrices addition products equations define straightforward divide conquer strategy derive recurrence time multiply matrices recurrence solution n3 method faster ordinary strassen discovered recursive approach requires recursive multiplications matrices scalar additions subtractions yielding recurrence strassen method steps divide input matrices submatrices equation scalar additions subtractions compute matrices a7 b7 recursively compute matrix products ai compute desired submatrices result matrix adding subtracting combinations matrices scalar additions subtractions procedure satisfies recurrence missing details determining submatrix products clear strassen discovered submatrix products key making algorithm work rec onstruct plausible discovery method guess matrix product written form coefficients drawn set guess product computed adding subtra cting submatrices adding subtracting submatrices multiplying general strategies simple turns work form products manner method recursively assuming commutativity multiplicati product submatrices left submatrices prope rty essential recursive application method matr multiplication commutative convenience matrices represent linear combinations products submatrices product combines submatrix submatrix equation rewrite equation expression abbr eviated notation represents represents represents omit row column labels notation equations submatrices result matrix search faster matrix multiplication algorithm observing submatrix computed computed matrix multiplication matrix computed manner p4 define essential term terms appearing hand equations œ ha products compute submatrices essential terms bh dg note computes essential term computes essential term bh computes essential term p4 computes essential term dg remains compute remaining submatrices essential terms bg dh additional products innovation p5 order compute essential terms p5 a5b5 dh addition computing essential terms dh p5 computes inessential terms canceled p4 cancel inessential terms adding additional product manner p5 inessential terms p5 direction subtracting additional product submatrix products p7 compute product completes descrip tion strassen method discussion practical point view strassen algorithm method choice matrix multiplication reasons constant factor hidden running time strassen algorithm larger constant factor naive n3 method matrices sparse methods ta ilored sparse matrices faster strassen algorithm nu merically stable naive method submatrices formed vels recursion consume space reasons mitigated higham demonstrated difference numerical stability overemphasized strassen algorithm numerically unstable applications acceptable limits bailey discuss techniques reducing memory requirements strassen algorithm practice fast matrix multiplication implem entations dense matrices strassen algorithm matrix sizes crossover point switch naive method subproblem size reduces crossover point exact crossover point highly dependent anal yses count operations ignore effects caches pipelining produced crossover points low higham huss lederman empirical measurements typically yield higher crossover points low straightforward determine crossover point experimentation advanced techniques scope text fact multiply matrices nlg time current upper bound lower bound obvious bound obvious elements product matrix hard matrix multiplication exercises strassen algorithm compute matrix product work exercises modify strassen algorithm multiply matrices exact power algorithm runs time nlg exercises largest multiply matrices multiplications assuming commutativity multiplic ation multiply matrices time nlg running tim algorithm exercises pan discovered multiplying matrices multiplications multiplying matrices multiplications multiplying matrices multiplications method yields asymptotic running time divide conquer matrix multiplication algorithm compare strassen algorithm exercises multiply kn matrix kn matrix strassen algorithm subroutine answer question order input matrices reversed exercises multiply complex numbers real multiplications algorithm input produce real component imaginary component separately solving systems linear equations solving set simultaneous linear equations fundamental oblem occurs diverse applications linear expressed matrix equation matrix vector element belongs field typically real numbers discusses solve linear equations method called lup decomposition start set linear equations unknowns set values satisfy equations simultaneously solution equations treat case equations unknowns conveniently rewrite equations matrix vector equation equivalently letting aij nonsingular possesses inverse solution vector prove unique solution equation solutionsaa concerned case nonsingular equivalently theorem rank equal number unknowns possibilities merit discussion number equations number unknownsšor gene rally rank nšthen underdetermined underdetermined stem typically infinitely solutions solutions equations inconsistent number equations exceeds number unknowns overdetermined exist solutions finding good approximate solutions overdetermined systems linear equations problem addressed return problem solving equations unknowns approach compute multiply sides yieldingbb approach suffers practice numerical instability fortunately approachšlup decompositionšthat numerically stable advantage faster practice overview lup decomposition idea lup decomposition matrices unit lower triangular matrix upper triangular matrix permutation matrix matrices satisfying equation lup decomposition matrix nonsingular matrix possesses decomposition advantage computing lup decomposition matrix linear systems solved triangular case matrices lup decomposition solve equation solving triangular linear systems multiplying sides yields equivalent equation pb exercise amounts permuting equations decomposition lu pb solve equation solving triangular linear systems define desired solution vector solve lower triangular unknown vector method called forward substitution solved solve upper triangular unknown method called substitution vector solution permutation matrix invertible exerciselulypb step forward substitution work attack problem computing lup decomposition forward substitution forward substitution solve lower triangular time convenience represent permutation compactly array entry pij row column pb ith element unit lower triangular equation rewritten y1 l21y1 l31y1 l32y2 y3 ln1y1 ln2y2 ln3y3 yn solve y1 directly equation tells y1 solved y1 substitute equation yielding l21y1 substitute y1 equation obtaining y3 l31y1 l32y2 general substitute y1 yi forward ith equation solve yi substitution forward substitution solve nth equation work backward equation forward substitution process runs time upper triangular rewrite u11x1 u12x2 u1xn u1xn u1nxn y1 u22x2 u2xn u2xn u2nxnxnxn nxn ynxn nxn yn yn solve successively yn yn nxn ynxn nxn general procedure lup solve solves combining forward substitution pseudocode assumes dimension appears attribute rows permutation matrix represented array lup solve rows downto return procedure lup solve solves forward substitution lines œ3 solves backward substitution lines œ5 implicit loop summations loops running time methods linear equations defined solve unknown lup decomposition reader verify lu forward substitution solve ly pb obtaining computing y1 finally y3 substitution solve obtaining desired answer computing finally computing lu decomposition lup decompos ition computed nonsingular matrix forward substitution solve linear equations remains lup decomposition efficiently start case nonsingular matrix absent equivalently case factorization lu matrices lu decomposition process perform lu decomposition called gaussian elimination start subtracting multiples equation equations variable removed equations subtract multiples equation subsequent equations variables removed continue proce left upper triangular formšin fact matrix matrix row multipliers variables eliminated algorithm implement strategy recursive construct lu decomposition nonsingular matrix choose i1 break parts size column vector wt size row vector matrix matrix algebra ver ify equations simply multiplying factor matrices factorization row column vectors size term vwt a11 formed outer product dividing element result a11 matrix conforms size matrix subtracted matrix called schur complement respect a11 claim nonsingular schur complement nonsingular suppose schur complement singular theorem row rank strictly entries column matrix rows matrix row rank strictly row rank entire matrix strictly applying exercise equation rank strictly theorem derive contradiction singular schur complement nonsingular recursively lu decomposition vwt a11 lu unit lower triangular upper triangular matrix algebra providing lu deco mposition note unit lower triangular upper triangular a11 method work divides work upper leftmost entry schur complement vwt a11 divide step recursion elements divide lu decomposition called pivots occupy diagonal elements matrix reason include permutation matrix lup decomposition llows avoid dividing elements permutations avoid divi sion small numbers called pivoting class matrices lu decomposition works correctly class symmetric positive defi nite matrices matrices require pivoting recursive strategy outlined employ fear dividing prove result code lu decomposition matrix recursive strategy iteration loop replaces recursion transformation standard optimization tail recursive procedurešone operation recursive assumes dimension attribute rows output matrix diagonal lup lve entries code bother likewise output matrix diagonal diagonal entries filled code computes entries lu decomposition rows ukk akk lik aik ukk lik holds vi uki aki uki holds aij aij likukj return outer loop iterates recursive step loop pivot determined ukk akk loop lines œ6 execute wt vectors update elements vector determined vi stored lik elements wt vector determined stored uki finally elements schur complement computed lines œ9 stored matrix divide akk computed lik triply nested lu decomposition runs time n3 figure illustrates operation lu dec omposition standard optimization procedure elements stored place matrix set correspondence element aij lij uij update matrix holds procedure terminates pseudocode optimization pseudocode replacing reference difficult verify transformation preserves correctness figure operation lu decomposition matrix element a11 black circle pivot shaded column a11 shaded row wt elements computed rizontal elements left vertical schur complement matrix vwt a11 occupies lower operate schur complement matrix produced element a22 black circle pivot shaded column row a22 wt partitioning schur complement respectivel lines divide matrix elements computed elements computed left schur complement lower step completes fact orization element schur complement recursion terminates factorization lu computing lup decomposition generally solving linear equations pivot diagonal elements avoid dividing division undesirable division small nonsingular numerical instabilities result computation pivot large mathematics lup decomposition milar lu decomposition recall nonsingular matrix permutation matrix unit lower triangular matrix upper triangular matrix lu partition matrix lu decomposition nonzero element ak1 column position matrix column singular determinant theorems order preserve set equations exchange row row equivalent multiplying permutation matrix left exercise write a21 a31 an1 a11 replaces ak1 wt ak2 ak3 akn matrix ak1 perform linear algebra lu decomposition guaranteeing divide lu decomposition nonsingular schur complement vwt ak1 nonsingular inductive ly lup decomposition unit lower triangular matrix upper triangular matrix permutation matrix vwt ak1 lu define permutation matrix product permutation matrices exercise yielding lup decomposition unit lower triangular upper triangular notice derivation lu decomposition column vector ak1 schur complement vwt ak1 multiplied permutation matrix lu decomposition pseudocode lup decomposition replaces recursion iteration loop improvement direct implementation recursion dynamically maintain permutation matrix array ith row column implement code compute place matrix procedure terminates lup decomposition rows aik aik error singular matrix exchange exchange aki ak aik aik akk aij aij aikakj figure illustrates lup decompositi factors matrix array initialized lines œ3 represent identity permutation outer loop implements recursion time rough outer loop lines œ9 determine element ak largest absolute current column column matrix lu decomposition elements current column lines œ11 report matrix singular pivot exchange exchange kth rows lines œ14 making pivot element akk entire rows swapped derivation method vwt ak1 multiplied ak1 finally schur complement computed lines œ18 computed lines œ9 lu decomposition operation written work place figure operation lup decomposition input matrix identity permutation rows left step algorithm determines element black circle thir row pivot column rows swapped permutation updated shaded column row represent wt vector replaced lower matrix updated schur complement lines divide matr regions elements elements left elements hur complement lower œ step œ step occur fourth final step lup decomposition pa lu triply nested loop structur lup decomposition running time n3 lu decomposition pivoting costs constant factor time exercises solve equation forward substitution exercises lu decomposition matrix exercises solve equation lup decomposition exercises lup decomposition diagonal matrix exercises lup decomposition permutation matrix prove unique exercises exists singular matrix lu decomposition exercises lu decomposition perform outermost loop iteration lup decomposition inverting matrices practice generally trix inverses solve systems linear equations preferring numerically stable techniques lup decomposition comput matrix inverse lup decomposition pute matrix inverse prove matrix multiplication computing inverse matrix equivalently hard problems subject technical conditions algorithm solve asymptotic running time strassen algorithm matrix multiplication invert matrix stra ssen original paper motivated problem showing set linear equa tions solved usual method computing matrix inverse lup decomposition suppose lup decomposition matrix form matrices pa lu lup solve solve equation form time lup decomposition depends lup solve set equations form additional time general lup decomposition solve time kn2 versions equation differ equation viewed set distinct equations form equations define matrix inverse precise denote ith column recall unit vector ith column equation solved lup decomposition solve equation axi separately columns time computation lup decomposition takes time n3 lup decomposition computed time n3 inverse matrix determined time n3 matrix multiplication matrix inversion theoretical speedups obt ained matrix multiplication translate speedups matrix inversion fact ove stronger matrix inversion equivalent matrix multiplicat ion sense denotes time multiply matrices invert matrix time denotes time invert nonsingular matrix multiply matrices time prove separate theorems theorem multiplication harder inversion invert matrix time satisfies regularity conditionn multiply matrices time proof matrices matrix product compute define matrix inverse compute product upper submatrix construct matrix time invertn time regularity condition note satisfies regularity condition lgd constants proof matrix inversion harder matrix multiplication relies properties symmetric positive definite matrices proved theorem inversion ha rder multiplication suppose multiply real matrices time satisfies regularity conditions range constant compute inverse real nonsingular matrix time proof assume exact power choosing power enlarge matrix size power desired answer answer enlarged problem rst regularity condition ensures enlargement running time increase constant factor moment assume matrix symmetric positive definite partition submatrices schur complement respect form schur complement aa verified performing matrix multiplication matrices exist symmetric positive definite lemmas symmetric positive definite exercisectcts s1c equations recursive algorithm involving multiplications matricesc invert symmetric positive definite matrix inverting matrices performing multiplications matrices algorithm matrices additional cost extracting submatrices performing constant number additions subtractions matrices recurrence holds regularity condition statemen theorem apply case master theorem theorem remains prove asymptotic runni time matrix multiplication matrix inversion invertible symmetric positive definite basic idea nonsingular matrix matrix symmetric exercise positive definite theorem trick duce problem inverting problem inverting reduction based observation nonsingular matrix matrix inverse unique compute multiplying inverting symmetric positive definite matrix divide conquer algorithm finally multiplying result steps takes time nonsingular matrix real entries inverted time proof theorem suggests solving equation lu decomposition pivoting long nonsingular multiply sides equation yielding atb transformation affect solution invertible factor symmetric positive definite matrix computing lu decomposition forward substitution solve hand atb method theoretical ly correct practice procedure lup decomposition works lup decomposition requires fewer arithmetic operations consta factor numerical properties exercises time multiply matrices denote time required square matrix multiplying squaring matrices essentially difficulty time matrix multiplication algorithm implies time squaring algorithm time squaring algorithm implies time matrix multiplication algorithm exercises time multiply matrices time compute lup decomposition matrix multiplying matrices computing lup decompositions matrices sentially difficulty time matrix multiplication algorithm implies time lup decomposition algorithm time lup decomposition algorithm implies time matrix multiplication algorithm exercises time multiply matrices denote time required determinant matrix multiplying matrices computing determinant essentially difficulty time matrix multiplication algorithm implies time determinant algorithm time determinant algorithm implies time matrix multiplication algorithm exercises time multiply boolean matrices time transitive closure boolean matrices time boolean matrix multiplication algorithm implies lg time transitive closure algorithm time transitive closure algorithm implies time boolean matrix multiplication algorithm exercises matrix invers ion algorithm based theorem work matrix elements drawn field integers modulo explain exercises generalize matrix inversion algorithm theorem handle matrices complex numbers prove neralization works correctly hint transpose conjugate transpose transpose replacing entry complex conjugate symmetric matrices hermitian matrices matrices symmetric positive definite matrices squares approximation symmetric positive definite matrices interesting desirable properties nonsingular lu decompos ition performed worry dividing ction prove properties symmetric positive definite matrices interesting application curve fitting squares approximation property prove basic lemma positive definite matrix nonsingular proof suppose matrix singular corollary exists nonzero vector positive definite proof perform lu decompos ition symmetric positive definite matrix dividing involved proving properties submatrices define kth leading submatrix matrix ak consisting intersection rows columns lemma symmetric positive definite matr leading submatrix symmetric positive definite proof leading submatrix ak symmetric obvious prove ak positive definite assume derive contradiction ak positive definite exists size vector letting define size vector contradicts positive definite turn essential prop erties schur complement symmetric positive definite matrix ak leading submatrix partition generalize definition define schur complement respect ak lemma ak symmetric positive definite exists lemma defined note earlier definition schur complement consistent definition letting lemma schur complemen matrices symmetric positive definite matrices symmetric positive definite result theorem corollary needed prove correctness lu decomposition symmetric positive definite matrices lemma schur complement lemma symmetric positive definite matrix ak leading submatrix schur complement respect ak symmetric positive definite proof symmetric submatrix exercise product symmetric exercise symmetric remains positive definite onsider partition equation nonzero vector assumption positive definite break subvectors compatible ak exists matrix magic verify multiplying equation amounts completing square quadratic form exercise holds nonzero pick nonzero choose term equation vanish leaving expression ztsz xtax positive definite corollary lu decomposition symmetric positive defi nite matrix division proof symmetric positive definite matrix prove stronger statement corollary pivot strictly positive pivot a11 e1 unit vector step lu decomposition produces schur complement respect a11 lemma implies pivots positive induction squares approximation fitting curves sets data points application symmetric positive definite matrices suppose set data points y1 xm ym yi subject measuremen errors determine function approximation errors small form function depends problem hand assume form linearly weighted sum number summands specific basis functions chosen based knowledge problem hand common choice c2x c3x2 cnxn polynomial degree choosing calculate yi equation high degree fits noise data generally poor predict unseen values choose smaller hope choosing coefficients function finds patterns data points paying undue attention noise theoretical prin ciples exist choosing scope text case chosen ove rdetermined set equations solution approximate denote matrix values basis functions points aij ck denote desired size vector coefficients size vector predicted values size vector approximation errors minimize approximation errors choose minimize norm error vector squares solution minimize differentiating respect ck setting result equations equivalent single matrix equation equivalently exercise implies statistics called normal equation matrix symmetric exercise column rank theorem positive definite exists solution equation matrix called pseudoinverse matrix pseudoinverse natural generalization notion matrix inverse case nonsquare compare equation approximate solution solutionb exact solution producing squares fit suppose data points y1 y3 x4 y4 x5 y5 black dots figure fit points quadratic polynomial figure squares fit quadratic polynomial data points black dots data points white dots estimated values pred icted polynomialxx2 quadratic polynomial minimizes sum square errors error data point shaded c2x c3x2 start matrix basis function values pseudoinverse multiplying coefficient vector corresponds quadratic polynomialxx2 closest fitting quadratic data squares sense practical matter solve normal equation multiplying finding lu decomposition rank matrix guaranteed nonsingular symmetr positive definite exercise theorem exercises prove diagonal element symm etric positive definite matrix positive exercises symmetric positive definite matrix prove determinant positive completing square nner proof lemma exercises prove maximum element symmetric positive definite matrix lies diagonal exercises prove determinant leading subm atrix symmetric positive definite matrix positive exercises ak denote kth leading submatrix symm etric positive definite matrix prove det ak det ak kth pivot lu decomposition convention det a0 exercises function form c2x lg c3ex squares fit data points exercises pseudoinverse satisfies follo wing equations aa aa aa aa problems tridiagonal stems linear equations tridiagonal matrix lu decomposition solve equation forward substitution inverse symmetric positive definite tridiagonal matrix vector equation solved time performing lu decomposition argue method based forming asymptotically expensive worst case nonsingular tridiagonal matrix vector equation solved time performing lup decomposition problems splines practical method interpolating points curve cubic splines set yi point pairs x0 fit piecewise cubic curve spline points curve cubic polynomials ai bix cix2 dix3 falls range curve points cubic polynomials pasted called knots simplicity assume ensure continuity require yi yi ensure smooth insist continuity derivative knot suppose point pairs yi derivatives knot express coefficient ai terms values yi yi remember coefficients computed point pairs derivatives question remains choose derivatives knots method require derivatives continuous knots knots assume assumptions natural cubic spline continuity constraints derivative rewrite equations trix equation involving vector d0 d1 dn unknowns attributes matrix equation argue set point pairs interpolated natural cubic spline time problem determine natural cubic spline interpolates set points yi satisfying x0 equal matrix equation solved algorithm chapter notes excellent texts desc ribe numerical scientific computation greater room readable george liu golub van loan press flannery teukolsky vetterling strang golub van loan discuss numerical stabil ity det good indicator stability matrix proposing address question compute computing publication strassen algorithm caused excitement hard imagine naive algorithm improved asymptotic upper bound difficulty matrix multiplication considerably improved asymptotically efficient algorithm multiplying matrices coppersmith winograd running time graphical presentation strassen algorithm paterson gaussian elimination lu lup decompositions based systematic method solving linear systems equations earliest numerical algorithms earlier discovery commonly attributed gaussœ1855 famous paper strassen matrix inverted nlg time winograd originally proved matrix multiplication harder matrix inversion converse aho hopcroft ullman matrix decomposition singular decomposition svd svd matrix factored matrix nonzero values diagonal q1 mutually orthonormal columns q2 mutually orthonorma columns vectors orthonormal product vector norm books strang golub van loan good treatments svd strang excellent presentation symmet ric positive definite matrices linear algebra general chapter linear programming problems formulated maximizing minimizing objective limited resources competing constraints objective linear function variables constraints resources equalities inequalities variables linear programming problem linear programs variety practical appli cations studying application electoral politics political problem suppose politician win election district types areas urban suburban rural areas registered voters govern effectively win majority votes regions honorable supporting policies realize issues effective winning votes rtain places primary issues building roads gun control farm subsidies gasoline tax dedicated improved public transit campaign staff estimate votes win lose population segment spending advertis ing issue appears table figure table entry describes number thousands urban suburban rural voters spending advertising support issue negative entries denote votes lost task figure minimum money spend order win urban votes suburban votes rural votes policy urbansuburban rura lbuild roads gun control farm subsidies gasoline tax figure effects policies voters entry describes number thousands urban suburban rural voters spending advertising support policy issue negative entries denote votes lost trial error ith strategy win required number votes strategy expensive devote advertising building roads gun control farm subsidies gasoline tax case win urban votes suburban votes rural votes win exact number votes desired urban suburban areas votes rural area fact rural area votes ther voters order garner votes paid dollars advertising naturally strategy achieved goals spending advertising additional trial error answer question systematic method answering questions order formulate question mathematically introduce variables number thousands dollars spent advertising building roads number thousands dollars spent advertising gun control number thousands dollars spent advertising farm subsidies x4 number thousands dollars spent advertising gasoline tax write requirement win urban votes write requirements win suburban votes rural votes setting variables x4 inequalities satisfied strategy win sufficient number ype vote order costs small minimize spent advertising minimize expression negative advertising common occurrence political campaigns thing negative cost advertising require combining inequalities objective minimizing linear program format problem subject solution linear program yield optimal strategy politician general linear programs general linear programming problem sh optimize linear function subject set linear inequalities set real numbers set variables linear function variables defined real number linear function equation linear equality inequalities linear inequalities term linear constraints denote linear equalities linear equalities linear programming strict inequalities formally linear programming problem problem mi nimizing maximizing linear function subject finite set linear constraints minimize linear program minimization linear program maximize linear program maximization linear program remainder chapter cover formulation solution linear programs polynomial time algorith linear prog ramming study chapter udy simplex algorithm oldest linear programming algorithm simplex algor ithm polynomial time worst case fairly effici ent practice overview linear programming order properties algorithms linear prog rams convenient canonical forms expres forms standard slack chapter defined precisely informally linear program standard form maximization linear function subject linear inequalities linear program slack form maximiza tion linear function subject linear equalities typically standard form expressing linear programs convenient slack form details simplex algorithm restrict attention maximizing linear function variables subject set linear inequalities li program variables subject setting variables satisfies constraints feasible solution linear program graph constraints cartesian coordinate figure set feas ible solutions shaded figure forms convex region dimensional space convex region feasible region function maximize called objective function conceptually evaluate objective function point feasible region objectiv function point objective identify point maxi mum objective optimal solution linear programs easible region infinite number points determine effi cient point achieves maximum objective explicitly evaluating obj ective function point feasible region figure linear program constraint represented direction intersection constraints feasible region shaded dotted lines points objective optimal solution linear program objective dimensions optimize gra phical procedure set points slope plot slope origin figure intersection feasible region set feasible lutions objective case intersection feasible regi point generally intersection feasible region set feasible solutions objective figure lines feasible region figure bounded maximum intersection feasible region nonempty point occurs optimal lution linear program case point objective accident optimal solution linear program occurred vertex feasible region maximum intersects feasible region boundary feasible region intersection boundary feasible region vertex segment intersection vertex optimal solution vertex intersection segment point segment objective endpoints segment optimal solutions endpoint segment vertex optimal solution vertex case easily graph linear programs variables intuition holds thre variables constraint half space dimensional space intersection half spaces forms feasible region set points objective function obtains plane coefficients objective function nonnegative origin feasible solution linear program ane origin points increasing objective origin fe asible coefficients objective function negative intuitive picture complicated dimensions feasible region conve set points achieve optimal objective include vertex feasible region variables constraint defines half space dimensional space feas ible region formed intersection half spaces called simplex objective function hyperplane convexity optimal solution occur vertex simplex simplex algorithm takes input linear program returns optimal solution starts vertex simplex perf orms sequence iterati ons iteration moves edge simplex rrent vertex neighboring vertex objective smaller current vertex larger simplex algorithm terminates reaches local maximum vertex neighboring vertices smaller objective feasible region convex objective function linear local optimum global optimum concept called duality solution returned simplex algorithm optimal geometric view good intuitiv view operations simplex algorithm explicitly refer developing details simplex algorithm algebraic vi ew write linear program slack form set linear equalities linear equalities express variables called basic variables terms variables called nonbasic variables moving vertex accomplished making basic variable nonbasic making nonbasic riable basic operation called pivot viewed algebraically rewriting linear program equivalent slack form variable descri bed simple address details chapter issues include identifying linear programs solutions linear programs finite optimal solution linear programs origin feasible solution intuitive definition convex region fulfills requirement points region points segment region applications linear programming linear programming large number applications textbook operations filled examples lin ear programming andard tool taught students business schools election scenario typical examples linear programming airline wishes schedule flight crews federal aviation administration imposes constraints limiting number consecutive hours crew member work insisting crew work model aircraft month airline schedule crews flights crew members oil company decide ill oil siting drill location cost based geological surveys expected payoff number barrels oil company limited budget locating drills maximize oil expects budget linear programs modeling solving graph combinatorial problems textbook special case linear programming solve systems difference constraints study formulate graph network flow problems linear programs linear programming approximate solution graph problem standard slack forms describes formats standard slack form working linear programs standard form constraints inequalities slack form constraints equalities standard form standard form real numbers real numbers bm real numbers aij real numbers subject generalizing terminology introduced variable linear program expression objective function inequalities lines constraints constraints called nonnegativity constraints arbitrary linear program ha nonnegativity constraints standard form requires conveni ent express linear program compact form create matrix aij dimensional vector dimensional vector dimensional vector rewrite linear program defined œ subject ctx product vectors matrix vector product entry vector nonnegative linear ogram standard form tuple adopt convention dimensions introduce terminology solu tions linear programs terminology earlier variable linear program setting variables satisfies constraints feasible solution setting variables fails satisfy constraint called infeasible solution solution objective feasible solution objective maximum feasible solutions optimal solution objective optimal objective linear program feasib solutions linear program infeasible feasible linear program feasible solutions finite optimal objec tive linear program unbounded exercise asks linear program finite optimal objective feasible region bounded converting linear programs standard form convert linear program minimization maximization linear function subject linear constraints standard form linear program standard form reasons objective function minimi zation maximization variables nonnegativity constraints equality constraints equal sign equal sign inequality constraints equal sign greater equal sign converting linear program linear program property optimal solution yield optimal solution capture idea maximization linear programs equivalent feasible solution objective feasible solution objective feasible solution objective feasible solution objective definition imply correspondence feasible lutions minimization linear program maximization linear program equivalent feasible solution objective correspo nding feasible solution objective feasible solution objective feasible solution objective remove problems list removing argue linear program equivalent convert minimization linear program equivalent maximization linear program simply negate coefficients objectiv function identical sets feasible solutions feasible solution objective negative objective linear programs equi valent linear program minimize subject negate coefficients objective function minimize subject convert linear program variables nonnegativity constraints variable gativity constraint suppose variable nonnegativity constraint replace occurrence add negativity constraints objective function term cjxj replaced constraint term aijxj replaced feasible solution linear program corresponds feasible solution original linear program objective solutions equivalent apply conversion scheme variable nonnegativity constraint yield equivalent linear program variables negativity constraints continuing ensu variable nonnegativity constraint variable constraint variable replace variables modify linear program subject convert equality constraints inequality constraints suppose linear program equality constraint replace equality constraint pair inequality constraints repeating conversion equality constraint yields linear program nstraints inequalities finally convert greater equal constraints equal constraints multiplying constraints throu gh inequality form equivalent replacing coefficient aij aij equivalent equal constraint finishing replac equality constraint inequalities obtaining subject finally negate constraint consistency variable names rename obtaining standard form subject converting linear programs slack form efficiently solve linear program mplex algorithm prefer express form constraints quality constraints precisely convert form nonnega tivity constraints inequality constraints remaining constraints equalities inequality constraint introduce variable rewrite inequality constraints slack variable measures slack difference left hand hand sides equation inequality true equation inequality true apply conversion inequality constraint linear program obtaining equivale linear program inequality constraints nonnegativity constraints converting standard slack form denote slack variable ith inequality ith constraint nonnegativity constraint applying conversion constraint linear program standard form linear program form exampl linear program œ introduce slack variables x4 x5 x6 obtaining maximize subject linear program constraint nonnegativ ity constraints equalities variable subject nonnegativity constraint write equality constraint variables left hand equality hand equation set variables hand variables objective function variables left hand equalities called basic variables hand called nonbasic variables linear programs satisfy condi tions omit maximize subject explicit nonnegativity constraints variable denote objective function format slack form write linear program œ slack form standard form convenient concise notation describing slack form sets basic nonbasic variables change simplex algorithm runs denote set indices nonbasic variables denote set indices basic variables equations indexed entries variables hand indexed entries standard form aij denote constant terms coefficients denote optional constant term objective function concisely define slack form tuple denoting slack form variables constrained nonnegativ subtract sum values aij negatives coefficients slack form slack form c5 c6 note indices sets contiguous integers depend sets entries negatives coefficients slack form observe equation includes term coefficient a13 exercises express linear program œ compact notation œ exercises feasible solutions linear program œ objective exercises slack form œ exercises convert linear program standard form minimize subject exercises convert linear program slack form maximize subject basic nonbasic variables exercises linear program infeasible maximize subject exercises linear program unbounded maximize subject exercises suppose general linear program variables constraints suppose convert standard upper bound number variables constraints linear program exercises linear program feasible region bounded optimal objective finite formulating problems linear programs focus simplex algorithm chapter recognize problem formul ated linear program problem formulated polynomial sized linear program solved polynomial time ellipsoid interior point algorithms seve ral linear programming software packages solve problems efficiently oblem expressed linear program solved practice package concrete examples linear programming probl ems start problems studied single source shortest paths problem chapter maximum flow problem chapter minimum cost flow problem polynomial time algorithm based linear programming minimum cost flow problem examine finally multicommodity flow problem polynomial time algorithm based linear programming shortest paths single source shortest paths problem chapter formulated linear program focus formulation single pair shortest path problem leaving extension general single source shortest paths problem exercise single pair shortest path problem weighted directed graph weight function mapping edges real weights source vertex destination vertex compute weight shortest path express problem linear ogram determine set variables constraints define shortest path fortunately bellman ford algorithm bellman ford algorithm terminates computed vertex edge source vertex initi ally receives changed linear program compute shorte path weight subject linear program variables vertex constraints edge additional constraint source vertex maximum flow maximum flow problem expres sed linear program recall directed graph edge nonnegative capacity distinguished vertices sink source defined flow real valued function satisfies properties capacity constraints skew symmetry flow conservation maximum flow satisfies constraints maximizes flow total coming source flow satisfies linear constraints flow linear function recalling assume express maximum flow problem linear program subject linear program variables flow pair vertices constraints efficient solve sma ller sized linear program linear program œ ease notation flow capacity pair vertices efficient rewr ite linear program constraints exercise asks minimum cost flow linear programming solve oblems knew efficient algorithms fact efficien algorithm designed problem dijkstra algorithm single source shortest pat problem push relabel method maximum flow efficient linear programming theory practice real power linear programming ability solve problems recall problem faced politician beginni chapter problem obtaining sufficient number votes spendi money solved algorithms studied book solved linear programming books abound real problems linear programming solve linear programming solving variants problems efficient algorithm genera lization maximum flow problem suppose edge addition capacity real valued cost send units flow edge incur cost flow target send units flow total cost incurred flow minimized problem minimum cost flow problem figure minimum cost low problem send units flow incurring minimum total cost legal flow function satisfying constraints œ incurs total cost unit flow minimizes cost optimal solution figure total cost figure minimum cost flow problem denote capacities costs vertex source vertex sink send units flow solution minimum cost flow problem units flow edge flow capacity written flow capacity polynomial time algorithms specifi cally designed minimum cost flow problem scope book express minimum cost flow problem linear program lin ear program maximum flow problem additional constr aint flow units objective function minimizing cost subject multicommodity flow final flow problem suppose lucky puck company decides diversify product ship hockey pucks hockey sticks hockey helmet piece equipment manufactured factory warehouse shipped day factory warehouse sticks manufactured ncouver shipped saskatoon helmets manufactured edmonton shipped regina capacity shipping network change items commodities share network instance multicommodity flow problem problem directed graph edge nonnegative capacity maximum flow problem implicitly assume addition commodities k1 k2 kk commodity triple ki source commodity sink commodity demand sired flow commodity define flow commodity denoted flow commodity vertex vertex real valued function satisfies flow conservation skew symmetry capacity constraints define aggregate flow sum commodity flows aggregate flow edge capacity edge constraint subsumes capacity constraints individual commodities problem minimize determin flow write linear program ith null objective function polynomial time algorithm problem express linear program solve ith polynomial time linear programming algorithm exercises single pair shortest path linear program œ standard form exercises write explicitly linear program finding shortest path node node figure exercises single source shortest paths problem shortest path weights source vertex vertices graph write linear program solution property shortest path weight vertex exercises write explicitly linear program rresponding finding maximum flow figure exercises rewrite linear program maximum flow œ constraints exercises write linear program bipartite graph solves maximum bipartite matching problem exercises minimum cost multicommodity flow problem directed graph edge nonnegative capacity cost multicommodity flow problem commodities k1 k2 kk commodity triple ki define flow commodity aggregate flow edge multicommodity flow problem feasible flow aggregate flow edge capacity edge cost flow goal feasible flow minimum cost xpress problem linear program simplex algorithm simplex algorithm classi cal method solving linear ograms contrast algorithms book running time polynomial worst case yield insight linear programs remarkably fast practice addition geometric interpretation scribed earlier chapter simplex algorithm bears similarity gaussian elimination discussed gaussian elimination linear equalities solution unknown iteration rewrite equivalent form additional structure number iterations rewritten solution simple simplex algorithm proceeds simila manner view gaussian elimination inequalities main idea iterati simplex algorithm iteration basic solution easily slack form linear program set nonbasic variable compute values basic variables equality constraints basic soluti correspond vertex simplex algebraically iterati converts slack form equivalent slack form objective basic feas ible solution previous iteration greater achieve increase objective choose nonbasic variable increase variable objective increase increase variable limited constraints raise basic variable rewrite slack form exchanging roles basic variable chosen nonbasic variable setting variables guide algorithm proofs algorithm explicitly maintain solution simply rewrites linear program optimal solution obvious simplex algorithm extended linear program standard form subject order simplex algorithm convert linear program slack form addition algebraic manipulation slack algorithmic concept recalling variable nonnegativity constraint equality constraint tight setting nonbasic variables constraint basic variable setting nonbasic riables basic variable negative violates constraint slack variables explicitly maintain constraint tight determine increase values nonbasic values violating constraints associating slack variables x4 x5 x6 inequalities œ putting linear program slack form constraints œ equations variable setting variables defines values x4 x5 x6 infinite number solutions equations solution feasible x6 nonnegative infinite number feasible solutions infinite number solutions proofs focus basic solution set nonbasic variables hand compute values basic variables left basic solution objective observe basic solution sets iteration simplex algorithm rewrite set equations objective function set variables hand ther basic solution rewritten problem emphasize rewrite change underlying linear programming problem proble iteration identical set feasible solutions problem previous iteration problem basic solution previous iteration basic solution feasible basic feasible solution running simplex algorithm basic solution lmost basic feasible solution iterations simplex algorithm basic solution feasible goal iteration reformulate linear program basic solution greater objective select nonbasic variable xe coefficient objective function positive increase xe violating constraints variable xe basic variable nonbasic values basic variables objective function change continue ink increasing increase values x4 x5 x6 decrease nonnegativity constraint variable negative increases x4 negative x5 x6 negative increases constraint tightest constraint limits increase switch roles x6 solve equation rewrite equations x6 hand substitute equation equation combine equation constraint objective function rewrite linear program form operation pivot demonstrated pivot chooses nonbasic variable xe called entering variable basic variable called leaving variable exchanges roles linear program œ equivalent linear program equations œ operations perform simplex algorithm rewriting equations variables left ha hand substituting equation operation trivially creates equivalent problem elementary linear gebra creates equivalent problem demonstrate equivalence observe original basic solution satisfies equations œ objective basic solution lin ear program sets nonbasic values objective simple arithmetic verifies solution satisfies equations œ plugged objective function objective continuing riable increase increase x6 increases objective decreases attempt increase choose increase violating constraints constraint limits constraint limits constraint limits constr aint tightest rewrite constraint left hand x5 hand ubstitute equation equations œ equivalent basic soluti objective increase objective increase constraints upper bounds upper bound constraint increase basic variable x4 increases constraint places restriction increased increase nonbasic solve equation substitute equations point coefficients objectiv function negative chapter situation occurs rewritten linear program basic solution optimal solution problem solution objective optimal return original linear program œ variables original linear program solution objective note values slack variables nal solution measure slack inequality slack variable x4 inequality left hand hand slack variables x5 x6 inequalities left hand hand sides equal observe coefficients original slack form tegral coefficients linear programs ecessarily integral intermediate solutions integral final solutio linear program integral purely coincidental integral solution pivoting formalize procedure pivoting procedure pivot takes input slack form tuple leaving variable entering variable xe returns tuple describing slack form recall matrices negative coefficients slack form pivot compute coefficients equation basic variable xe compute coefficients remaining constraints compute objective function compute sets basic nonbasic variables return pivot works lines œ5 compute coefficients equation xe rewriting equation left hand xe left hand lines œ11 update remaining equations subs tituting hand equation occurrence xe lines œ16 substitution objective function lines update sets nonbasic basic variables returns slack form ale pivot error dividing proofs lemmas pivot called ale summarize pivot values variables basic solution lemma pivot ale values returned denote basic solution proof statement true sic solution sets nonbasic variables set nonbasic riable constraint pivot proves statement proves statement formal simplex algorithm ready formalize simplex gorithm demonstrated nice issues address determine linear program feasible linear program feasible initial basic solution feasible determine linear program unbounded choose entering leaving variables determine problem feasible slack form initial basic solution feasible assume procedure initialize simplex takes input linear program standard form matrix aij dimensional vector dimensional vector problem infeasible returns message program infeasible terminates returns slack form initial basic solution feasible procedure simplex takes input linear program standard form returns vector optimal solution linear program œ simplex initialize simplex choose aie aie choose minimizes return unbounded pivot return simplex procedure works calls procedure initialize simplex determines linear program infeasible returns slack form basic solution feasible main algorithm loop lines œ11 coefficients objective function negative loop terminates select variable xe coefficient objective functi positive entering variable freedom choose variable entering variable assume prespecified deterministic lines œ8 check constraint pick severely limits increase xe violating nonnegativity constraints basic variable constraint freedom hoose variables leaving variable assume prespecified deterministic rule constraints limits entering variable increase algorithm returns unbounded exchanges roles entering leaving variables calling subroutine pivot lines œ15 compute solution iginal linear programming variables setting nonbasic variables basic variable theorem solution optimal solu tion linear program finally returns computed values original linear programming variables simplex correct simplex initial feasible solution eventually terminates returns feasible solution determines linear program unbounded simplex terminates finally solution returned optimal lemma linear program suppose initialize simplex simplex returns slack form sic solution feasible simplex returns solution solution feasible solution linear program simplex returns unbounded linear program unbounded proof loop invariant start iteration loop lines œ11 slack form equivalent slack form returned initialize simplex basic solution slack form feasible initialization equivalence slack forms trivial iteration assume statement lemma initia lize simplex simplex returns slack form whic basic solution feasible invariant true basic variable set basic solution feasibility basic solu tion implies basic variable nonnegative invariant holds maintenance loop invari ant maintained assuming return statement executed handle case executes discuss termination iteration loop exchanges role basic nonbasic variable operations performed involve lving equations substituting equation slack form equivalent previous iteration loop invariant equivalent initial slack form demonstrate pa loop invariant assume start iteration loop inequalities remain true pivot variables set basic variables occur assignment suffices maintains invariant aij refer values pivot refer values returned pivot observe loop invariant ale simplex pivot remaining indices cases depending aie aie aie chose aie ale equation aie aie inequality aie ale nonnegative equation implies nonnegative argue basic solution feasible variables nonnegative values nonbasic variables set nonnegative basic variable defined equation basic solution sets loop invariant conclude basic variable nonnegative termination loop terminate ways terminates condition current basic solution feasible solution returned terminate return unbounded case iteration loop lines œ7 executed aie basic solution slack form iteration returned unbounded solution defined solution feasible variables nonnegative nonbasic variables positive nonbasic variables nonnegative basic variable loop invariant implies aie objective solution unbounded objective objective linear program unbounded iteration simplex maintains addition sets explicitly maintaining essential efficient implementation simplex algorithm strictly slack form uniquely determined sets basic nonbasic riables proving fact prove algebraic lemma lemma set indices real numbers real valued variable real number suppose settings proof equation holds values values draw conclusions conclude pick arbitrary set picked conclude slack form linear program unique ly determined set basic variables lemma linear program standard form set basic variables slack form uniquely determined proof assume purpose contradiction ere slack forms set basic variables slack form identical sets nonbasic variables write slack form equations formed subtracting equation equation equivalently apply lemma aij slack forms identical argument exercise case slack forms identical remains simplex terminates terminate solution returned optimal address optimality discuss termination termination iteration simplex algorithm increased objective basic solution exercise asks iteration simplex decrease objective basic solution iteration leaves objective unchanged phenomenon called degeneracy study greater objective changed assignment pivot simplex calls pivot objective remain unchanged assigned pivot pivot ale equal objective unchanged situation occur linear program x4 x5 suppose choose entering variable x4 leaving variable pivoting x4 x4 x5 point choice pivot entering x5 leaving b5 objective remains unchanged pivoting x4 x5 x4 x5 objective cha nged representation fortunately pivot entering leaving objective increase simplex algorithm continue degeneracy thing simplex algorithm terminating recall assumption simplex chooses indices lines deterministic rule simplex cycles slack forms iterations identical case simplex deterministic algorithm cycle series slack forms forever lemma simplex fails terminate iterations cycles proof lemma set basic variables uniquely determines slack form variables ways choose unique slack forms simplex runs iterations cycle cycling theoretically extremel rare avoidable choosing entering leaving variables carefully option perturb input impossible tw solutions objectiv break ties lexicographically break ties choosing variable smallest strategy bland rule omit proof strategies avoid cycling lemma lines simplex ties broken choosing variable smallest simplex terminate conclude lemma lemma assuming initialize simplex returns slack form basic solution feasible simplex reports linear program unbounded terminates feasible solution iterations proof lemmas initialize simplex returns slack form basic solution feasible simplex reports linear program unbounded terminates feasible solution contra positive lemma simplex terminates feasible solution terminates iterations exercises complete proof lemma showing case exercises pivot simplex decrease exercises suppose convert linear program standard form slack form basic solution feas ible exercises solve linear program simplex maximizex2 subject exercises solve linear program simplex maximize subject exercises solve linear program simplex minimize subject duality proven assumptions simplex terminate finds optimal soluti linear program order introduce powerful concept called linear programming duality duality property opt imization problem identification dual problem coupled scovery polynomial time algorithm duality powerful ability provide proof solution optimal suppose instance maximum flow problem flow maximum flow max flow min cut theorem theorem cut verified maximum flow duality maximization problem define minimization problem problems optimal objective values linear program objective maximize formulate dual linear program objectiv minimize optimal identical original li program referring dual linear programs orig inal linear program primal primal linear program standard œ define dual linear program minimize subject form dual change maximization minimization exchange roles hand sides objective function coeffi cients replace equal greater equal constraints primal variable yi dual constraints dual variable primal linea program œ dual linear program minimize subject theorem optimal dual linear program equal optimal primal lin ear program simplex algorithm implicitly solves primal dual linear programs simultaneously providing proof optimality demonstrating weak duality states feasible solution primal linear program grea ter feasible solution dual linear program lemma weak linear programming duality feasible solution primal linear program œ feasible solution dual linear program œ proof corollary feasible solution primal linear program feasible solution dual linear program optimal solutions primal dual linear programs proof lemma objective feasible solution primal exceed feasible solution dual primal linear program maximization problem dual minimization probl feas ible solutions objective improved proving dual solution equal optimal primal solution solution simplex algorithm linear program œ nal iteration yielded slack form œ basic solution final slack form timal solution linear program optimal solution linear program œ objective read optimal dual solution negatives coefficients primal objective function values dual variables precisely suppose slack form primal optimal dual solution set optimal solution dual lin ear program defined œ evaluating dual objective function objective confirms objective primal equal objective dual combining calculations lemma proof optimal objective primal linear program general optimal solution dual proof optimality solution primal manner theorem linear programming duality suppose simplex returns values primal linear program denote nonbasic basic variables final slack form denote coefficients final slack form defined equation optimal solution primal linear program optimal solution dual linear program proof corollary feasible solutions satisfy equation optimal primal dual solutions solutions statement theorem satisfy equation suppose simplex primal linea program lines œ algorithm proceeds series slack forms terminates final slack form objective function simplex terminated solution condition define rewrite equation basic solution final slack form slack forms equivalent evaluate origin objective function objective defined equation feasible dual linear program objective equals equation slack forms evaluated equal generally equivalence slack forms implies set values set values applying lemma equation equation objective dual equal primal remains solution feasible dual problem implies satisfies constraints dual finally set equation nonnegativity constraints satisfied feasible linear program initialize simplex returns feasible solution simplex terminates turning unbounded solution returned optimal solution construct optimal solution dual linear program exercises formulate dual linear program exercise exercises suppose linear program standard form produce dual converting standard form dual convenient produce dual directly explain arbitrary linear program directly dual linear program exercises write dual maximum flow linear program lines œ explain interpret form ulation minimum cut problem exercises write dual minimum cost flow li program lines œ explain interpret problem terms graphs flows exercises dual dual linear program primal linear program exercises result chapter interpreted weak duality maximum flow problem initial basic feasible solution test linear program feasib produce slack form basic soluti feasible conclude proving fundamental theorem linear programming simplex procedure produces correct result finding initial solution assumed procedure initialize simplex determines linear program feasible solutions slack form basic solution feasible procedure linear program feasible initial basic solution feasible linear program subject convert linear program slack form basic solution set solution violates constraint feasible solution initialize simplex return obvious slack form inspection clear linear program feasible solutions order determine formulate auxiliary linear program auxiliary linear program work slack form basic solution feasible solution auxiliary linear program determine initial linear program feasible provide feasible solution initialize simplex lemma linear program standard form œ laux linear program variables subject feasible optimal objective laux proof suppose feasible solution solution combined feasible solution laux objective x0 constraint laux objective function maximize x0 solution optimal laux conversely suppose optimal objective laux values remaining variables satisfy constraints strategy ini tial basic feasible solution linear program standard form initialize simplex minimum initial basic solution feasible return form laux adding x0 left hand equation setting objective function x0 slack form laux laux nonbasic variables basic variables pivot basic solution feasible laux iterate loop lines œ11 simplex optimal solution laux basic solution sets return final slack form x0 removed original objective function restored return infeasible initialize simplex works lines œ3 implicitly test basic solution initial slack form creating slack form requires explicit effort values slack standa forms basic solution feasiblešthat bšthen slack form returned form auxiliary linear program laux lemma initial basic solution feasible initial basic solution slack form laux feasible perfor pivot x0 entering leaving chosen negative shortly basic solution pivot feasible slack form basic solution feasible repeatedly pivot fully solve auxiliar linear program test demonstrates optimal solution laux objective create slack form basic solution feasible delete x0 terms constraints restore original objective function original objective function basic nonbasic variables objective function replace basic variable hand constraint hand discover original linear program infeasible return demonstrate ope ration initialize simp lex linear program œ linear program feasible nonnegative values satisfy inequalities lemma formulate auxiliary linear program subject lemma optimal objective auxiliary linear program original linear program easible solution optimal obj ective auxiliary linear program positive original li program feasible solution write linear program slack form obtaining x0x3 x0x4 x0 woods basic solution set x4 feasible auxiliary linear program ith pivot convert slack form basic lution feasible choose x0 entering variable choose leaving variable x4 basic variable basic solution negative pivoting slack form x4x0 x4x3 x4 basic solution x0 x4 feasible repeatedly pivot optimal solution laux case pivot entering x0 leaving yields slack form final solution auxiliary problem solution x0 initial problem feasible x0 remove set constraints original objective function substitutions include nonbasic variables objective function setting x0 simplifying objective function slack form slack form feasible basic soluti return procedure simplex formally corr ectness initialize simplex lemma linear program feasible solution initialize simplex returns infeasible returns valid slack form basic solution feasible proof suppose linear program feasible solution lemma optimal objective laux defined œ nonzero nonnegativity constraint x0 optimal solution negative objective objective finite setting feasible solution objective initialize simplex solution negative objective basic solution final slack form laux objective contradicting fact objective negative test infeasible returned suppose linear program feasible solution exercise basic solution initial slack form feasible case lines œ3 ill return slack form input convert standard form slack form remainder proof handle cas linear program feasible return argue case lines œ9 feasible solution laux objective lines œ2 perform pivot opera tion leaving variable left hand equation minimum entering variable x0 extra variable pivot entries nonnegative basic solution laux feasible letting basic solution pivot letting values returned pivot lemma implies pivot note ai0 coefficient x0 appears negation coefficient laux standard slack form ale ale remaining basic variables equation aie ale pivot equation ale inequality implies basic variable nonnegative basic solution pivot feasible execute solves laux assumed feasible solution lemma implies laux optimal solution objective slack forms equivalent final basic solution laux removing x0 linear program slack form feasible slack form returned fundamental theorem linear programming conclude chapter showing simplex procedure works linear program inf easible unbounded optimal solution finite objective case simplex appropriately theorem fundamental theo rem linear programming linear program standard form optimal solution finite objective infeasible unbounded infeasible simplex returns infeasible unbounded simplex returns unbounded simplex returns optimal solution finite objective proof lemma linear program infeasible simplex returns infeasible suppose linear program feasible lemma initialize simplex returns slack form basic solution feasible lemma simplex returns unbounded terminates feasible solution terminates finite solution theorem tells solution optimal hand simplex returns bounded lemma tells linear program unbounded simplex terminates ways proof complete exercises detailed pseudocode implement lines initialize simplex exercises initialize simplex runs main loop simplex unbounded returned exercises suppose linear program standard form suppose dual basic solutions initial slack forms feasible optimal objective exercises suppose strict inequalities linear program case fundamental theorem linea programming hold exercises solve linear program simplex maximize subject exercises solve linear program œ exercises variable linear program maximize subject arbitrary real numbers dual state values assert optimal solutions finite objective values feasible infeasible feasible infeasible feasible problems linear inequality feasibility set linear inequalities variables linear inequality feasibility problem asks setting variable simultaneously satisfies inequalities algorithm lin ear programming solve linear inequality feasibility problem number variables constraints linear programming problem polynomial algorithm linear inequality feasibility problem solve linear ogramming problem number variables linear inequalities linear inequality feasibility problem polynomial number variables cons traints linear program problems complementary slackness complementary slackness describes relationship values primal variables dual constraints values dual variables primal constraints optimal solution primal linear program œ optimal solution dual linear program œ compleme ntary slackness states conditions sufficient optimal verify complementary slackness holds linear program lines œ prove complementary slackness holds primal linear program dual prove feasible solution primal linear program lines œ optimal values feasible solution dual linear program œ exercises intege linear programming integer linear programming problem linear progra mming problem additional constraint variables integral values exercise determining integer linear program feasible solution np hard polynomial time algorithm problem weak duality lemma holds integer linear program duality theorem hold integer linear program primal linear program standard form define optimal objective primal linear program optimal objective dual optimal objective integer version primal primal constraint variables integer values optimal objective integer version dual exercises farkas lemma matrix vector farkas lemma states systems ya solvable vector vector prove farkas lemma chapter notes chapter study wide field linear programmi number books devoted exclusively linear programming including chv tal gass karloff schrijver vanderbei books good coverage linear programming including papadimitriou steiglitz ahuja magnanti orlin coverage chapter draws approach chvátal simplex algorithm linear programming invented dantzig shortly discovered number problems variety fields formulated linear programs solved simplex algor ithm realization led flourishing linear programming algorithms variants simplex algorithm remain popular methods solving linear programming problems history number places including notes ellipsoid algorithm polynom ial time algorithm linear programming khachian based earlier work shor judin nemirovskii ellipsoid algorithm solve variety problems combinatorial optimization work grötschel lov schrijver ellipsoid algorithm competitive simplex algorithm practice karmarkar paper includes description interior point algorithm subsequent researchers designed interior point algorithms ood surveys article goldfarb todd book ye analysis simplex algorithm active area klee minty constructed simplex algorithm runs iterations simplex algorithm performs practice researchers trie theoretical justification empirical observation begun borgwardt carried cer tain probabilistic assumptions input simplex algorithm converges expected lynomial time progress area spielman teng introduce smoothed analysis algorithms apply simplex algorithm simplex algorithm effici ently special cases noteworthy network simplex algorithm wh ich simplex algorithm specialized network flow problems network problems cluding shortest paths maximum flow minimum cost flow problems variants network simplex algorithm polynomial time article orlin citations chapter polynomials fft straightforward method dding polynomials degree takes time straightforward method multiplying takes time chapter fast fourier transform fft reduce time multiply polynomials lg common fourier transforms fft signal processing signal time domain function mapping time amplitude fourier analysis express signal weighted sum phase shifted sinusoids varying frequencies weights phases frequencies characterize signal frequency domain signal processing rich area fine books chapter notes reference polynomials polynomial variable algebraic field representation function formal sum values a0 coefficients polynomial coefficients drawn field typically set complex numbers polynomial degree highest nonzero coefficient ak integer strictly greater degree polynomial degree bound polynomial degree polynomial degree bound integer inclusive variety operations mi ght define polynomials polynomial addition polynomials degree bound sum polynomial degree bound underlying field polynomials polynomial multiplication polynomials degree bound product polynomial degree bound underlying field multiplied polynomials multiplying term term combining terms equal powers multiplyx3 express product note degree degree degree implying degree bound degree bound degree bound degree bound degree bound speak degree bound sum degree bounds polynomial degree bound degree bound chapter outline presents ways represent polynomi als coefficient representation point representation straight forward methods multiplying polynomials š equations štake time polynomials represented coefficient form time represented point form multiply polynomials coefficient representation lg time converting representations works study complex roots unity fft inverse perform conversions implement fft serial parallel models chapter complex numbers extensively symbol exclusively denote representation polynomials coefficient point representations polynomials sense equivalent polynomial point form unique counterpart coefficient form introduce representations combined multiplication degree bound polynomials lg time coefficient representation coefficient representation polynomial degree bound vector coefficients a0 matrix equations chapter generally treat vectors column vectors coefficient representation convenient operations polynomials operation evaluating polynomial point x0 consists computing x0 evaluation takes time horner rule x0 a0 x0 x0 x0 x0 adding polynomials repres ented coefficient vectors a0 b0 takes time produce coefficient vector c0 multiplication degree bound polynomials represented coefficient form method equations polynomial multiplication takes time coefficient vector multiplied coefficient vector operation multiplying polynomials coefficient form considerably difficult evaluating polynomial adding polynomials sulting coefficient vector equation called convolution input vectors denoted multiplying polynomials computing convolutions fundamental computational problems considerable practical chapter concentrates efficient algorithms point representation point representation polynomial degree bound set point pairs x0 y0 y1 yn distinct polynomial point representations set distinct points x0 basis representation computing point representation pol ynomial coefficient form principle straightforward select distinct points x0 evaluate horner method point evaluation takes time choose cleverly computation accelerated time lg inverse evaluation šdetermining coefficient form polynomial point representation šis called interpolation theorem hows interpolation defined assuming degree bound interpolating polynomial equals number point pairs theorem uniqueness interpolating polynomial set x0 y0 y1 yn point pairs values distinct unique polynomial degree bound yk proof proof based existence inverse matrix equation equivalent matrix equation matrix left denoted x0 vander monde matrix exercise matrix determinant theorem invertible nonsingular distinct coefficients solved uniquely point representation x0 proof theorem describes algorithm interp olation based solving set linear equations lu decomposition algorithms chapter solve equations time n3 faster algorithm point interpolation based lagrange formula verify hand equation polynomial degree bound satisfies yi exercise asks compute coefficients lagrange formula time point evaluation interpolation defined inverse operations transform coefficient representation polynomial point representation algorithms problems time point representation convenient operations polynomials addition point precisely point representation x0 y0 y1 yn note evaluated points point representation time add polynomials degree bound point form point representation convenient multiplying polynomials point pointwise multiply point representation point representation point representation face problem degree bound sum degree bounds standard point representation consists point pairs polynomial multiplying point pairs degree bound point pairs point representation exercise extended point representations consisting point pairs extended point representation x0 y0 y1 x2n y2n extended point representation point representation input polynomials extended point form time multiply point form result time required multiply polynomials coefficient form finally evaluate polynomial point form point problem pproach simpler converting polynomial coefficient form evaluating point fast multiplication polynomials coefficient form linear time multiplication met hod polynomials point form expedite polynomial multiplicati coefficient form swer hinges ability convert polynomial coefficient form point form evaluate vice versa interpolate points evaluation points choosing evaluation points carefully convert betw een representations lg time choose complex roots unity evaluation points produce point representation discrete fourier transform dft coefficient vector inverse operation interpolation performed inverse dft point pairs yielding coefficient vector fft performs dft inverse dft operations lg time figure strategy graphically minor concerns degree bounds product polynomials degree bound polynomial degree bound evaluating input polynomials double degree bounds adding high order coefficients vectors elements complex roots unity denoted w2n terms figure figure graphical outline effi cient polynomial multiplication process representations coefficient form point form arrows left correspond multiplication operation w2n terms complex roots unity fft lg time procedure multiplying polynomials degree bound input output representations coefficient form assume power requirement met adding high order coefficients double degree bound create coefficient representations degree bound polynomials adding high order coefficients evaluate compute point representations length applications fft order representations values polynomials roots unity pointwise multiply compute point representation polynomial multiplying values poi ntwise representation root unity interpolate create coefficient representation polynomial single application fft point pairs compute inverse dft steps time steps time lg fft proven theorem product polynomials degree bound computed time lg input output representations coefficient form exercises multiply polynomials equations exercises evaluating polynomial degree bound point x0 dividing polynomial x0 quotient polynomial degree bound remainder x0 x0 compute remainder coefficients time x0 coefficients exercises derive point representation point representation assuming points exercises prove distinct point pairs uniquely polynomial degree bound fewer distinct point pairs fail unique polynomial degree bound hint theorem set point pairs add arbitrarily chosen point pair exercises equation interpolate time hint compute coefficient representation polynomial divide numerator term exercise denominators computed time exercises explain wrong obvious appr oach polynomial division point representation dividing values discuss separately case division case exercises sets integers range compute cartesian sum defined note integers range elements number times element realized sum elements problem solved lg time hint represent polynomials degree interpolation notoriously tricky problem point view numerical stability approaches math ematically correct small differences inputs round errors computation larg differences result efficient fft implementations practical applications dft signal processing demand utmost speed examines efficient fft implementations examine iterative version fft algorithm runs lg time lower constant hidden notation recursive implementation insights led iterative plementation design efficient parallel fft circuit iterative fft implementation note loop lines œ13 recursive fft involves computing compiler terminol ogy common subexpression change loop compute storing temporary variable wn wn operation loop multiplying twiddle factor storing product adding subtracting butterfly operation schematically figure figure butterfly operation input values enter left twiddle factor multiplied sum difference output simplified drawing butterfly operation repr esentation parallel fft circuit fft algorithm iterati recursive structure figure arranged input vectors recursive calls invocation recursive fft tree structure initial tree node procedure labeled input vector recursive fft invocation recursive calls received element vector left child child figure tree input vectors recursive calls recursive fft procedure initial invocation tree observe arrange elements initial vector order leaves mimic execution recursive fft procedure elements pairs compute dft pair butte rfly operation replace pa dft vector holds element dft dft pairs compute dft vector elements executing butterfly operations replacing element dft elem ent dft vector holds element dft wecontinue manner vector holds element dft combine butterfly operations final element dft turn observation code array initially holds elements input vector order leaves tree figure determine order bit reversal permutation combining ha level tree introduce variable count levels ranging combining pairs form element dft lg combining element dft produce final result algorithm structure lg combine element dft element dft express body loop ecise pseudocode copy loop recursive fft procedure identifying twiddle factor butterfly operation depends power wm introduce variable solely sake readability intr oduce temp orary variable perform butterfly operation place replace structure loop body pseudocode forms basis parallel implementation code calls auxiliary procedur bit reverse copy copy vector array initial order values iterative fft bit reverse copy length power lg e2i bit reverse copy elements input vector desired order array order leaves figure bit reversal permutation rev lg bit integer formed reve rsing bits binary representation place vector element ak array position rev figure leaves order sequence binary reverse bits sequence bit reversal permutation general note level tree indices low order bit left subtree indices low order bit subtree stripping low order level continue process tree order bit reversal permutation leaves function rev easily computed bit reverse copy procedure written bit reverse copy length rev ak iterative fft implementation runs time lg bit reverse copy runs lg time iterate times reverse integer lg bits lg time practice initial advance code table mapping rev making bit reverse copy time low hidden constant alternatively clever amortized reverse nary counter scheme problem complete proof iterative fft runs time lg number times body innerm ost loop lines œ13 executed lg loop lines œ13 iteratess times innermost loop lines œ13 iterates times parallel fft circuit exploit propert ies allowed implem ent efficient iterative fft algorithm produce efficient parallel algorithm fft express parallel fft algorithm circuit comparison networks chapter comparators fft circuit butterfly operations drawn figure notion depth developed chapter applies circuit parallel fft computes fft inputs figure bit reverse permuta tion inputs lg stages stage consisting butterflies executed parallel depth circuit lg figure circuit parallel fft computes fft inputs butterfly operation takes input values wires twiddle factor produces outputs values wires stages butterflies labeled correspond iterations outermost loop iterative fft procedure wires passing butterfly interact wires pass middle butterfly affect butterfly values chan ged butterfly butterfly stage hing wire wire output labeled y1 inputs outputs wires labeled y0 fft inputs computed lg depth lg butterfly operations leftmost circuit parallel fft performs bit reve rse permutation remainder mimics iterative iterative fft procedure iteration outermost loop performs independent butterfly operations circuit performs parallel iteration iterativ fft corresponds stage butterflies figure stage lgs groups butterflies correspondin iterative fft butterflies group iterative fft butterflies figure correspond butterfly operations innermost loop lines œ12 iterative fft note twiddle factors butterflies correspond iterative fft stage exercises iterative fft computes dft input vector exercises implement fft algorithm bit reversal permutation occurring computation hint inverse dft exercises times iterative fft compute tw iddle factors stage rewrite iterative fft compute twiddle factors times stage exercises suppose adders butterfly operations fft circuit fail manner produce ze output independent inputs suppose adder failed identify failed adder supplying inputs fft circuit observing outputs efficient method problems divide conquer multiplication multiply linear polynomials multiplications hint multiplications divide conquer algorithms multiplying polynomials degree bound time nlg algorithm hould divide input polynomial coefficients high half low half algorithm divide odd bit integers multiplied nlg steps step operates constant number bit values problems toeplitz matrices toeplitz matrix matrix aij aij ai sum toeplitz matrices nece ssarily toeplitz product represent toeplitz matrix toeplitz matrices time lg time algorithm multiplying toeplitz matrix vector length representation efficient algorithm multiplying toeplitz matrices analyze running time problems multidimensiona fast fourier transform generalize dimensional discre fourier transform defined equation dimensions input dimensional array dimensions n1 n1n2 define dimensional discrete ourier transform equation k1 n1 k2 kd compute dimensional dft computing dimensional dft dimension turn compute n1 separate dimensional dft dimension result dft dimension input compute separate dimensional dft mension result input compute n3 separate dimensional dft dimension dimension ordering dimensions doe matter compute dimensional dft computing dime nsional dft order dimensions compute dimens ional dft computing fast fourier transform total time compute dimensional dft lg independent problems evaluating derivativ polynomial point polynomial degree bound tth derivative defined coefficient representation a0 point x0 determine x0 coefficients b0 compute x0 time explain b0 lg time prove explain evaluate lg time conclude nontrivial derivatives evaluated x0 lg time problems polynomial evaluation multiple points observed problem evaluating polynomial degree bound single point solved time horner rule ha discovered polynomial evaluated complex roots unity lg time fft evaluate polynomial degree bound arbitrary points lg2 time fact mpute polynomial remainder polynomial divided lg time result assume proof remainder dividedx3 mod coefficient representation polynomial points x0 compute values x0 define polynomials qij mod pij note qij degree prove mod point prove qkk q0 prove qik qij mod pik qkj qij mod pkj lg2 time algorithm evaluate x0 problems fft modular arithmetic defined discrete fourier transform quires complex numbers result loss precision round errors problems answer integers desirable utilize variant fft based modular arithmetic order guarantee answ calculated problem multiplying polynomials integer coefficients exercise approach modulus length bits handle dft points problem approach modulus reasonable length lg requires understand material chapter power suppose search smallest kn prime simple heuristic argument expect lg larger smaller expect examine lg candidate values average expected length compare length generator gk mod argue dft inverse dft defined inverse operations modulo principal nth root unity argue fft inverse work modulo time lg operations lg bits unit time assume algorithm compute dft modulo vector note generator chapter notes vanloan book outstanding treatment fast fourier transform press flannery teukolsky vetterling good description fast fourier transform applications excellent introduction signal processing popular fft application area texts oppenheim schafer oppenheim willsky oppenheim schafer book handle cases integer power fourier analysis limited dimensional ta image processing analyze data dimensions books gonzalez woods pratt discuss multdimensional fourier transfor image processing books tolimieri lu van loan discuss mathematics multidimensional fast fourier transforms cooley tukey credited devising fft fft fact discovered times previousl fully realized advent modern digitial puters press flannery teukolsky vetterling attribute origins method runge könig article heideman johnson burrus traces history fft gauss chapter number theoretic algorithms number theory viewed beau tiful useless subject pure mathematics today number theoretic algorithms cryptographic schemes based large prime numbers feasibility schemes rests ability large primes easily security rests inability factor product large primes chap ter presents number theory algorithms underlie applications introduces basic concepts number theory divisibility modular equivalence unique factorization studies oldest algorithms euclid algorithm computing greatest common divisor integers reviews concepts modular arithmetic studies set multiples number modulo solutions equation mod euclid algorithm chinese remainder theorem presented considers powers number modulo presents repeated squaring algorithm efficiently computing mod operation heart efficient prima lity testing modern cryptography describes rsa public key cryptosystem examines randomized primality test large primes efficientl essential task creating keys rsa cryptosystem finally reviews simple effective heuristic factoring small inte gers curious fact factoring problem people intractable security rsa depends difficulty factoring large integers size inputs cost arithmetic computations working large integers adjust size input cost elementary arithmetic operations chapter large input typically input large integers input integers sor ting measure size input terms number bits required represent input number integers input algorithm integer inputs ak polynomial time algorithm runs time polynomial lg lg lg ak polynomial lengths binary encoded inputs book convenien elementary arithmetic operations multiplications divisions computing remainders primitive operations unit time counting number arithmetic operations algorithm performs basis making reasonab estimate algor ithm actual running time computer elementary operations time consuming inputs large convenient measure bit operations number theoretic algorithm requires model multiplication bit integers ordinary method bit operations operation dividing bit integer shorter integer operation remainder bit integer divided shorter integer performed time simple algorithms exercise faster methods simple divide conquer method multiplying bit integers running time fastest method running time lg lg lg practical purposes algorithm bound basis analyses chapter algorithms generally analyz terms number arithmetic operations number bit operations require elementary number theoretic notions review notions elementary number theory set integers set natural numbers divisibility divisors notion integer divisible central theory numbers notation read divides kd integer integer divides multiple divide write divisor note generality lost defining divisors nonnegative understanding negative divisor divides divisor integer greater divisors integer divisible trivial divisors nontrivial divisors called factors factors prime composite numbers integer divisors trivial divisors prime number simply prime primes special properties play critical role number theory primes order exercise asks prove infinitely primes integer prime composite number simply composite composite integer unit prime composite integer negati integers prime composite division theorem remaind ers modular equivalence integer integers partitioned multiples multiples number theory based refinement partition classifying nonmultiples remainders divided theorem basis refinement proof theorem niven zuckerman theorem division theorem integer positive integer uni integers qn quotient division mod remainder residue division mod integers divided equivalence classes remainders modulo equivalence class modulo integer kn denotations set notation defined writing writing mod set equivalence classes sees definition read equivalent equation understanding represents represents class represented nonnegative element underlying equivalence classes mind reference member zn reference mod common divisors greatest common divisors divisor divisor common divisor divisors common divisors note common divisor integers property common divisors generally integers implies greatest common divisor integers largest common divisors denoted gcd gcd gcd gcd gcd integer min define gcd definition standard properties gcd function equation universally valid elementary properties gcd function theorem alternat ive characterization gcd theorem integers gcd smallest positive element set linear combinations proof smallest positive linear combination equation implies mod qs qx qy mod linear combination mod mod smallest positive linear combination analogous reasoning common divisor gcd equation implies gcd gcd divides linear combination gcd imply gcd combining gcd gcd yields gcd conclude greatest common divisor corollary integers gcd proof corollary equation gcd linear combination theorem corollary integers nonnegative integer gcd gcd proof corollary trivial gcd smallest positive element set anx bny times smallest positive element set corollary positive integers gcd proof proof left exercise prime integers integers prime common divisor gcd prime divisors divisors theorem states integers prime integer product prime theorem integers gcd gcd gcd proof theorem exist integers multiplying equations rearranging ybx yax pyy positive linear combination appeal theorem completes proof integers n1 nk pairwise prime gcd unique factorization elementary fact divisibility primes theorem primes integers proof assume purpose contradiction gcd gcd divisors assumption divides theorem implies gcd contradicting assumption implies gcd contradiction completes proof consequence theorem integer unique factorization primes theorem unique factorization composite integer written product form prime positive integers proof proof left exercise number uniquely factored exercises prove infinitely primes hint primes divide exercises prove exercises prove prime gcd exercises prove corollary exercises prove prime conclude integers primes mod exercises prove integers mod mod mod prove assumptions mod implies mod integers exercises integer integer kth power exists integer ak nontrivial power kth power integer determine bit integer nontrivial power time polynomial exercises prove equations œ exercises gcd operator associative prove integers gcd gcd gcd gcd exercises prove theorem exercises efficient algorithms operations dividing bit integer shorter integer remainder bit integer divided shorter integer algorithms time exercises efficient algorithm convert bit binary integer representation argue multiplication vision integers length takes time binary conversion performed time lg hint divide conquer approach obtaining halves result separate recursions greatest common divisor euclid algorithm computing greatest common divisor integers efficiently analysis running time brings surprising connection fibonacci numbers yield wors case input euclid algorithm restrict nonnegative integers restriction justified equation states gcd gcd principle compute gcd positive integers prime factorizations exponents set primes exercise asks algorithms factoring polynomial time approach computing greatest common divisors yield efficient algorithm euclid algorithm computing greatest common divisors based theorem theorem gcd recursion theorem nonnegative integer positive integer gcd gcd mod proof gcd gcd mod divide equation equal nonnegative gcd gcd mod gcd equation mod qb mod linear combination equation implies mod mod corollary implies gcd mod equivalently showing gcd mod gcd gcd mod mod qb mod linear combination mod equation conclude gcd corollary equivalently equation combine equations completes proof euclid algorithm elements euclid circa describes gcd algorithm earlier origin euclid algorithm expressed recursive program based directly theorem inputs arbitrary nonnegative integers euclid return return euclid mod running euclid computation gcd euclid euclid euclid euclid computation thr recursive invocations euclid correctness euclid theorem fact algorithm returns equation implies gcd gcd algorithm recurse indefini tely argument strictly decreases recursive nonnegative euclid terminates correct answer running time euclid algorithm analyze worst case running time euclid function size assume loss generality assumption justified observation euclid recursive euclid argument argument euclid spends recursive swapping guments proceeds procedure terminates recursive mod running time euclid proportional number recursive calls analysis fibonacci numbers fk defined recurrence lemma invocation euclid performs recursive calls fk fk proof proof induction basis induction f3 mod recursive argument strictly larger assumption holds recursive assume inductively lemma true recursive calls prove true recursive calls euclid calls euclid mod recursively turn recursive calls inductive hypothesis implies fk proving lemma mod fk mod implies mod fk fk fk theorem corollary lemma theorem lamé theorem integer fk euclid fewer recursive calls upper bound theorem consecutive fibonacci numbers worst case input euclid euclid f3 recursive fk mod fk fk gcd fk fk gcd fk fk mod fk gcd fk fk euclid fk fk recurses times meeting upper bound theorem fk golden ratio defined equation number recursive calls euclid lg exercise tighter bound euclid applied bit numbers perform arithmetic operations bit operations assuming multiplication division bit numbers bit operations problem asks bound number bit operations extended form euclid algorithm rewrite euclid algorithm compute dditional extend algorithm compute integer coefficients note negative coefficients computation modular multiplicative invers procedure extended euclid takes input pair nonnegative integers returns triple form satisfies equation extended euclid return extended euclid mod return figure illustrates execution extended euclid computation gcd š figure operation extended euclid inputs level recursion values inputs computed values returned triple returned triple computation higher level recursion extended euclid returns gcd gcd extended euclid procedure variation euclid procedure equivalent test euclid extended euclid returns coefficients extended euclid computes gcd mod euclid case gcd gcd mod start rewriting equation equation equation choosing satisfies equation proving correctness extended euclid number recursive calls clid equal number recursive calls extended euclid running mes euclid extended euclid onstant factor number recursive calls lg exercises prove equations imply equation exercises compute values extended euclid returns exercises prove integers gcd gcd kn exercises rewrite euclid iterative form constant memory stores constant number integer values exercises invocation euclid log recursive calls improve bound log gcd exercises extended euclid fk fk return prove answer correct exercises define gcd function tw arguments recursive equation gcd a0 gcd a0 gcd gcd function returns answer independent order arguments integers x0 gcd a0 a0x0 a1x1 anxn number divisions performed algorithm lg max a0 exercises define lcm common multiple integers nonnegative integer multiple ai compute lcm efficiently argumen gcd operation subroutine exercises prove n1 n3 n4 pairwise relativel prime gcd n1n2 n3n4 gcd n1n3 n2n4 generally n1 nk pairwise prime set lg pairs numbers derived prime modular arithmetic informally modular arithmetic arithmetic usual integers working modulo result replaced element equivalent modulo replaced mod informal model sufficient stick operations ddition subtraction multiplication formal model modular arithmetic framework group theory finite groups group set binary operation defined properties hold closure identity element called identity group associativity inverses exists unique element called inverse familiar group integers operation addition identity inverse group satisfies commutative law abelian group group satisfies finite group groups defined modular addition multiplication form finite abelian groups addition multiplication modulo positive integer groups based equivalence classes integers modulo defined define group zn suitable binary operations redefining ordinary operations addition multiplication easy define addition multiplication operations zn equivalence cla integers uniquely determines equivalence class sum product mod mod mod mod define addition multiplication modulo denoted subtraction defined zn division complicated facts stify common convenient practice nonnegative element equi valence class representative performing computations zn addition subtraction ltiplication performed usual representatives result replaced represen tative class mod definiti addition modulo define additive group modulo zn size additive group modulo zn figure operation table group z6 figure finite groups equivalence classes denoted representative elements group z6 group theorem zn finite abelian group proof equation zn closed associativity commutativity follow associativity commutativity identity element zn additive inverse element element definition multiplication modulo define multiplicative group modulo elements group set elements zn prime defined note kn mod integers exercise gcd implies gcd kn integers kn set defined group group operation multiplication modulo denote element denote figure group mod working identity group theorem finite abelian group proof theorem implies closed associativity commutativity proved proof theorem identity element existence inverses element output extended euclid equivalently mod multiplicative inverse modulo proof inverses uniquely defined deferred corollary computing ltiplicative inverses suppose extended euclid returns mod multipli cative inverse modulo working groups zn remainder chapter follow convenient practice denoting equivalence classes representative elements denoting operations usual arithmetic notations juxtaposition equivalences modulo interpreted equations zn statements equivalent mod convenience refer group operation understood context refer groups zn zn multiplicative inverse element denoted mod division defined equation mod mod mod mod size denoted function euler phi function satisfies equation runs primes dividing including prime prove formula intuitivel list remainders prime divides cross multiple list prime divisors prime composite subgroups group group subgroup integers form subgroup integers operation addition theorem tool recognizing subgroups theorem nonempty closed subs finite group subgroup finite group nonempty subset subgroup proof proof left exercise set forms subgroup z8 nonempty closed operation closed theorem extremely usef ul constraint size subgroup omit proof theorem lagrange theorem finite group subgroup divisor subgroup group proper subgroup corollary analysis mi ller rabin primality test procedure corollary proper subgroup finite group subgroups generated element theorem interesting produce subgroup finite group choose element elements generated group operation define group z6 sequence group zn ka mod group ak mod subgroup generated denoted defined generates subgroup generator finite finite subset including associativity implies closed theorem subgroup z6 order group denoted defined smallest positive integer theorem finite group order element equal size subgroup generates proof elements suppose purpose contradiction satisfying implies contradiction positiv element sequence distinct conclude corollary sequence periodic period mod consistent corollary define mod integers corollary finite group identity proof lagrange theorem implies mod exercises draw group operation tables groups z4 groups isomorphic exhibiting correspondence elements mod mod exercises prove theorem exercises prime positive integer exercises function defined mod permutation exercises list subgroups z9 solving modular linear equations problem finding solutions equation applications problem procedure finding keys rsa public key cryptosystem assume values modulo satisfy equation solution denote subgroup zn generated mod equation solution lagrange theorem theorem tells divisor theorem precise characterization theorem positive integers gcd zn proof showing recall extended euclid produces integers mod multiple belongs multiple multiple multiple element mod integer integer equation combining observe multiples inclusive corollary equation mod solvable unknown gcd corollary equation mod distinct solutions modulo gcd solutions proof mod solution theorem corollary theorem imply sequence ai mod periodic period appears times sequence ai mod length block values repeated times increases indices positions mod solutions equation mod theorem gcd suppose integers computed extended euclid equation mod solutions x0 x0 mod proof ax0 mod mod mod mod x0 solution mod theorem suppose equation mod solvable gcd x0 solution equation equation distinct solutions modulo x0 proof values x0 xd distinct modulo x0 solution mod ax0 mod axi mod x0 mod ax0 mod ax0 mod solution corollary solutions x0 xd developed mathema tics needed solve equation mod algorithm prints solutio equation inputs arbitrary positive integers arbitrary integer modular linear equation solver extended euclid x0 mod print x0 mod print solutions operation procedure equation mod calling extended euclid lines œ5 executed compute x0 mod loop lines œ5 prints solutions procedure modular linear equation solver works computes gcd values demonstrating solution equation mod divide equation mod solution corollary checks reports solutions othe rwise computes solution x0 mod theorem solution theorem states solutions adding multiples modulo loop lines œ5 prints solutions x0 spaced modulo modular linear equation solver performs lg gcd arithmetic operations extended euclid performs lg arithmetic operations iteration loop lines œ5 performs consta number arithmetic operations corollaries theorem specializations corollary gcd equation mod unique solution modulo common case considerable multiplicative inverse modulo corollary gcd equation mod unique solution modulo solution corollary notation mod refer multiplicative inverse modulo prime gcd solution equation mod integer returned extended euclid equation gcd implies mod compute mod efficiently extended euclid exercises solutions equation mod exercises prove equation mod implies mod gcd condition gcd supplying counterexample gcd exercises change procedure modular linear equation solver x0 mod work explain exercises f0 f1x mod polynomial degree coefficients drawn zp prime zp mod prove mod polynomial degree prove induction polynomial degree distinct zeros modulo prime chinese remainder theorem chinese mathematician sun tsu solved problem finding integers leave remainders divided solution solutions form arbitrary integers chinese remainder theorem rrespondence equations modulo set pairwise prime modu li equation modulo product chinese remainder theorem major integer factored n1n2 nk factors pairwise prime chinese remainder theorem descriptive structure theorem describes structure zn identical cartesian product componentwise additi multiplication modulo ith component description yield efficient algorithms working systems efficient terms bit operations working modulo theorem chinese remainder theorem n1n2 nk pairwise prime correspondence zn ai mod mapping correspondence bijection zn cartesian product operations performed elements zn equivalently performed tuples performing operations independently coordinate position ak proof transforming representations fairly straightforward ak easy requires divisions computing inputs ak bit complicated accomplished defining mi mi product mi n1n2ni nk define equation defined mi prime theorem corollary guarantees exists finally compute function ak equation ensures ai mod note mj mod implies mj mod note mod equation appea ling correspondence vector ith coordinate form basis representation sense aici mod aimi mod ai mod wished method computing ai produces result satisfies constraints ai mod correspondence transform direc tions finally equations œ follow directly exercise mod mod mod corollaries chapter corollary n1 nk pairwise prime n1n2 nk integers ak set simultaneous equations ai mod unique solution modulo unknown corollary n1 nk pairwise prime n1n2 nk integers mod mod application chines remainder theorem suppose equations mod mod n1 m1 compute mod mod mod mod mod mod mod mod figure illustration chinese remainder theorem modulo figure illustration chinese remainder theorem n1 row column modulo mod mod note row column row column equivalent moving row increases moving ght column increases increasing corresponds moving diagonally downward wrapping left work modulo working modulo directly working transformed representation separate modulo computations convenient computations equivalent exercises solutions equations mod mod exercises integers leave remainders wh divided exercises argue definitions theorem gcd exercises definitions theorem prove polynomial number roots equation mod equal product number oots equations mod n1 mod mod nk powers element natural multiples element modulo natural sequence powers modulo modulo indexing sequence a0 mod ith ai mod powers moduloi mod powers moduloi mod denote subgroup generated repeated multiplication order modulo denote order ord7 definition euler phi function size translate corollary notation euler theorem specialize prime fermat theorem theorem euler theorem integer theorem fermat theorem prime proof equation prime corollary applies element zp zp mod prime element power modulo primitive root generator primitive root modulo primitive root modulo possesses primitive root group cyclic omit proof theorem proven niven zuckerman theorem values cyclic primes positive integers primitive root element exists gz mod called discrete logarithm modulo base denote ind theorem discrete logarithm theorem primitive root equation gx mod holds equation mod holds proof suppose mod integer gx mod mod mod euler theorem mod conversely suppose gx mod sequence powers generates element corollary implies sequence powers periodic period gx mod mod discrete logarithms simp lify reasoning modular equation illustrated proof theorem theorem odd prime equation solutions proof theorem implies primitive root equation written noting ind observe theorem implies equation equivalent solve equation unknown indn apply methods equation letting gcd gcd noting theorem equation solutions equation solutions inspection number nontrivial square root modulo satisfies equation mod equivalent trivial square roots modulo nontrivial square root modulo llowing corollary theorem correctness proof miller rabin primality testing procedure corollary exists nontrivial square root modulo composite proof contrapositive theorem exists nontrivial square root modulo odd prime power odd prime mod mod square roots modulo trivial prime finally nontrivial square root exist composite raising powers repeated squaring frequently occurring operation number theoretic computati ons raising number power modulo number modular exponentiation precisely efficient compute mod nonnegative integers positive integer modular exponentiati essential operation primality testing routines rsa public key cryptosystem method repeated squaring solves problem efficiently ing binary representation b0 binary representation binary representation bits long bit b0 bit procedure computes mod increased doublings incrementations modular exponentiation b0 binary representation downto mod mod return essential squaring iteration explains repeated squaring algorithm computes sequence values modulo figure sequence exponents row table labeled figure modular exponentiation computing mod values execution loop final result variable needed algorithm included explanatory purposes algorithm maintains follo wing loop invariant prior iteration loop lines œ9 prefix binary representation mod loop invariant initialization initially prefix corresponds a0 mod maintenance denote values iteration loop values prior iteration iteration updates correct prior iteration mod mod a2c mod mod moda mod a2c mod mod case mod prior iteration termination termination prefix b0 binary representation mod mod inputs bit numbers total numbe arithmetic operations required total number bit operations required exercises draw table showing order element pick smallest primitive root compute table ind exercises modular exponentiation algor ithm examines bits left left exercises assuming explain compute mod procedure modular exponentiation rsa public key cryptosystem public key cryptosystem crypt messages communicating parties eavesdropper overhears encrypted messages decode public key cryptosystem enables party append unforgeable digital signature electronic message signature electronic version handwritten signature paper document easily checked forged loses validity bit message altered authentication identity signer contents signed message perfect tool electronical ly signed business contracts electronic checks electronic purchase orders electronic communications authenticated rsa public key cryptosystem based dramatic difference ease finding large prime numbers difficulty factoring product large prime numbers describes efficient procedure finding large prime numbers discusses problem factoring large integers public key cryptosystems public key cryptosystem participant public key secret key key piece rsa cryptosystem key consists pair integers participants alice bob trad itionally cryptography examples denote publ secret keys pa alice pb sb bob participant creates public secret keys secret key secret reveal public key publish fact convenient assume public key public directory participant easily public key participant public secret keys functions applied message denote set permissible messages set finite length bit sequences simplest original form ulation public key cryptography require public secret keys functions function alice public key pa denoted pa function secret key denoted functions pa permutations assume functions pa efficiently computable key pa public secret keys participant matched pair functions inverses message transforming keys pa successively order yields message public key cryptosystem essential alice compute function practical time privac mail encrypted alice authenticity alice digital gnatures rely assumption alice compute requirement alice secret loses uniqueness cryptosystem provide ith unique capabilities assumption alice compute hold pa compute pa inverse function efficiently major difficulty designing workable public key cryptosystem figuri create reveal transformation pa revealing compute inverse transformation public key cryptosystem encryption works figure suppose bob wishes send alice message encrypted lik unintelligible gibberish eavesdropper scenario sending message figure encryption public key bob encrypts message alice public key pa transmits ciphertext pa alice eavesdropper captures transmitted ciphertext gains alice receives decrypts secret key original message bob obtains alice public key pa public directory directly alice bob computes ciphertext pa message sends alice alice receives ciphertext applies secret key retrieve original message pa inverse functions alice compute alice compute alice compute encryption pa protected disclosure alice digital signatures easy impl ement formulation public key cryptosystem note ther ways approaching problem constructing digital signatures suppose alice wishes send bob digitally signed response digital signature scenario proceeds figure figure digital signatures public key alice signs message appending digital signature transmits message signature pair bob verifies checking equation pa equation holds accepts message signed alice alice computes digital signature message secret key equation alice sends message signature pair bob bob receives verify originated alice alice public key verify equation pa alice bob public key equation holds bob concludes message signed alice equation hold bob concludes message digital signature corrupted transmission errors pair attempted forgery digital signature authentication signer identity authentication contents signed ssage analogous handwritten signature written document property digital signature verifiable access signer public key signed message verified party passed parties verify signature message electronic check alice bob bob verifies alice signature check check bank verify signature funds transfer note signed message encrypted message clear protected disclosure composing protocols encryption signatures create messages signed encrypted signer appends digital signature message encrypts message signature pair public key intended recipient recipient decrypts received message secret key original message digital signature verify signature public key signer combined process paper based systems sign paper document seal document inside paper envelope opened intended recipient rsa cryptosystem rsa public key cryptosystem participant creates public secret keys procedure select random large prime numbers primes bits compute equation select small odd integer prime equation equals compute multiplicative inverse modulo corollary guarantees exists uniquely defined technique compute publish pair rsa public key secret pair rsa secret key scheme domain set zn transformation message public key transformation ciphertext secret key equations apply encryption signatures create signature signer applies secret key message sign ciphertext verify signature public key signer applied message encrypted public key secret key operations implemented procedure modular exponentiation analyze running time operations assume public key secret key satisfy lg lg lg applying public key requires modular multiplications bit operations applying secret key requires modular multiplications bit operations theorem correctness rsa rsa equations define inverse transformations zn satisfying equations proof equations zn med mod multiplicative inverses modulo integer mod med mp mod mod theorem mod med mod mod med mod med mod corollary chinese remainder theorem med mod security rsa cryptos ystem rests large difficulty factoring large integers adversary factor modulus public key derive secret key public key ing knowledge factors creator public key factoring large integers easy breaking rsa cryptosystem easy onverse statement factoring large integers hard breaking rsa hard unproven decades easier method break rsa public key cryptosystem factor modulus factoring large integers surprisingly difficult randomly selecting multiplying bit primes create public key broken feasible time current technology absence fundamental eakthrough design number theoretic algorithms implemented car recommended standards rsa cryptosystem capable providing high degree security applications order achieve security rsa cryptosystem advisable work integers bits long resist advances art factoring time writi rsa moduli commonly range bits create moduli sizes large primes efficiently addresses problem efficiency rsa hybrid key management mode fast public key cryptosystems syst encryption decryption keys identical alice wishes send long message bob privately selects random key fast public key cryptosystem encrypts obtaining ciphertext long short encrypts bob public rsa key short computing pb fast faster computing pb transmits pb bob decrypts pb decrypt obtaining hybrid approach digital signatures efficiently approach rsa combined public hash function hša function easy compute computat ionally infeasible messages short bit fingerprint message alice wishes sign message applies fingerprint encrypts secret key sends bob signed version bob verify signature computing verifying pa applied received equals create messages fingerprint computationally infeasible alter signed message preserve validity signature finally note certificates distributing public keys easier assume trusted authority public key alice signed message certificate stating alice public key pa certificate authenticating alice include certificate signed message recipient alice public key order verify gnature key signed recipient alice key alice exercises rsa key set secret key encryption message exercises prove alice public exponent adversary obtains alice secret exponent adversary factor alice modulus time polynomial number bits asked prove interested result remains true condition removed miller exercises prove rsa multiplicative sense pa m1 pa pa m1 mod fact prove adversary procedure efficiently decrypt percent messages zn encrypted pa employ probabilistic algorithm decrypt message encrypted pa high probability primality testing problem finding large primes discussion density primes proceed examin plausible incomplete approach primality testing effectiv randomized primality test miller rabin density prime numbers applications cryptography large random primes fortunately large primes rare time onsuming test random integers size prime prime distribution function specifies number primes equal prime numbers equal prime number theorem approximation theorem prime number theorem approximation accurate estimates small number theorist small number prime number theorem estim ate probability randomly chosen integer turn prime examine integers chosen randomly order prime length bit prime require testing randomly chosen bit numbers primality figure cut half choosing odd integers remainder problem determining large odd integer prime notational onvenience assume prime factorization prime factors e1 positive integers prime e1 simple approach problem testing primality trial division dividing integer integers greater skipped easy prime trial divisors divides assuming trial division takes constant time worst case running time exponential length recall encoded binary bits lg trial division works small small prime factor works trial division advantage determines prime composite determines prime factors composite interested onl finding number prime composite concerned finding prime factorization computing prime factorization nu mber computationally expensive surprising easier number prime determine prime factorization number prime pseudoprimality testing method primality testing works fact good practical applications refinement method removes small defect presented denote nonzero elements zn prime base pseudoprime composite fermat theorem theorem implies prime satisfies equation satisfy equation composite surprisingly converse holds criterion forms perfect test primality test satisfies equation declare composite otherwis output guess prime fact prime base pseudoprime procedure pretends manner checking primality procedure modular exponentiation input assumed odd integer greater pseudoprime modular exponentiation mod return composite return prime hope procedure errors type composite correct prime error base pseudoprime procedure err surpri singly rarely values errs values probability program error randomly chosen bit number precise estimates pomerance number base pseudoprimes ze estimate randomly chosen bit number called prime procedure chance base pseudoprime randomly chos bit number called prime chance base pseudoprime large prime application practical purposes wrong choosing large numbers random pseudoprime output prime numbers tested primality randomly chosen approach testing primality sh cleverness randomization yield primality testing routine works inputs elimin ate errors simply checking equation base number composite integers satisfy equation integers carmichael numbers carmichael numbers carmichael numbers extremely rare exercise helps explain rare improve primality test fooled carmichael numbers miller rabin randomized primality test miller rabin primality test overcomes problems simple test pseudoprime modifications randomly chosen base values base computing modular exponentiation notices nontrivial square root modulo discovered final set squarings stops outputs composite corollary justifies detecting composites manner pseudocode miller rabin primality test input odd number tested primality number randomly chosen base values code random numb generator random random returns randomly chosen integer satisfying code auxiliary procedure witness witness true witness compositeness nšthat prove manner composite test witness extension effective test mod formed basis pseudoprime justify construction witness miller rabin primality test tu odd binary representation binary representation odd integer zeros mod compute mod computing mod squaring result times successively witness tu odd x0 modular exponentiation mod return true return true return false pseudocode witness computes mod computing x0 mod squaring result times row loop lines œ6 induction sequence x0 values computed satisfies equation mod mod squaring step performed loop rminate early lines œ6 detect nontrivial square root discovered algorithm stops returns true lines œ8 return true computed mod equal pseudoprime procedure returns composite case returns false returned true lines argue witness returns true proof composite constructed witness returns true lin discovered mod prime fermat theorem theorem mod prime equation mod proof fact witness returns true lin discovered nontrivial square root modulo mod mod corollary states composite nontri vial square root modulo demonstration nontrivial square root modulo proof composite completes proof correctne witness invocation witness outputs true surely composite proof composite easily determined point alternativ description behavior witness function sequence x0 analyze efficiency miller rabin primality test note witness compute rest sequence positions sequence cases sequence return true witness compositeness fermat theorem sequence return false witness compositeness sequence ends equal return false witness compositeness sequence ends return true witness compositeness nontrivial square root examine miller rabin primality based witness assume odd integer greater miller rabin random witness return composite return prime surely procedure miller rabin probabilistic search proof composite main loop picks random values picked witness compositeness miller rabin outputs composite output correct correctness witne witness trials miller rabin assumes witnesses assumed prime output correct large small chance procedure unlucky choice witnesses exis illustrate operation miller rabin carmichael number supposing chosen base figure witness computes x0 a35 mod computes sequence nontrivial square root discovered squaring step a280 mod a560 mod witness compositeness witness returns true miller rabin returns composite bit number miller rabin requires arithmetic operations s3 bit operations requires asymptotically work modular exponentiations error rate miller rabin primality test miller rabin outputs prime small chance error pseudoprime chance error depend bad inputs procedure depends size luck draw choosing base values test ringent simple check equation expect general principles error rate small randomly chosen integers theorem presents precise argument theorem odd composite number num ber witnesses compositeness proof proof numbe nonwitnesses implies theorem start claiming nonwitness member nonwitness satisfy mod equivalently mod solution equation mod corollary gcd turn implies gcd member nonwitnesses belong complete proof nonwitnesses contained contained proper subgroup recall proper subgroup subgroup equal corollary number nonwitnesses number witnesses proper subgroup nonwitnesses break proof cases case exists mod carmichael number earlier carmichael numbers extremely rare case case arises practice chosen randomly tested primality nonempty closed multiplication modulo subgroup theorem note nonwitness belongs nonwitness satisfies mod proper subgroup case carmichael number case extremely rare practice miller rabin test pseudo primality test efficiently determine compositeness carmichael numbers case prime power suppose contrary prime derive contradiction assumed odd odd theorem implies cyclic group generator equation gn mod discrete logarithm theorem theorem implies mod contradiction divisible prime prime power odd composite number prime power decompose product n1n2 n1 odd numbers greater prime ways matter choose choose recall define tu odd input procedure witness computes sequence computations performed modulo pair integers acceptable mod acceptable pairs exist odd choose acceptable pair pick largest exists acceptable pair acceptable pair closed multiplication modulo subgroup corollary divides nonwitness member sequence produced nonwitness jth position maximality acceptable nonwitness chose existence demonstrate exists mod mod n1 corollary chinese remainder theorem corollary simultaneously satisfying equations mod n1 mod mod n1 mod corollary mod n1 implies mod mod implies mod mod remains working separately modulo n1 modulo working modulo n1 observe gcd gcd n1 common divisors common divisors n1 mod n1 gcd n1 working modulo observe mod implies gcd combine theorem implies gcd n1n2 gcd finish case conclusion proper subgroup case numbe witnesses compositeness theorem odd integer positive integer probability miller rabin errs proof theorem composite execution loop lines œ4 probability discovering witness compositeness miller rabin error ly unlucky discovering witness compositeness iterations main loop probability string misses choosing suffice imag inable application large primes applying miller rabin randomly chosen large integers argued choosing small lead erroneous randomly chosen odd composite integer expected number nonwitn esses compositeness smaller integer chosen randomly proven number nonwitnesses improved version theorem exist integers number nonwitnesses exercises prove odd integer prime prim power exists nontrivial square root modulo exercises strengthen euler theorem form mod defined prove composite number carmichael number smallest carmichael number lcm divides prove carmich ael numbers square free divisible square prime product primes reason common exercises prove nontrivial square root modulo gcd gcd nontrivial divisors integer factorization suppose integer factor decompose product primes primality test preceding composite prime factors factoring large integer difficult simply determining prime composite infeasible today supercomputers algorithms factor arbitrary bit number pollard rho heuristic trial division integers guaranteed factor completely number work procedure factor number b4 unlucky procedure heuristic running time success guaranteed procedure effective practice advantage pollard rho procedure constant number memory locations easily implement pollard rho progr ammable pocket calculator factors small numbers pollard rho random true mod gcd print procedure works lines œ2 initialize randomly chosen zn loop iterates forever searching factors iteration loop recurrence produce infinite sequence correspondingly incremen ted code written subscripted variables clarity program works subscripts dropped maintained modification procedure constant number memory locations program saves generated variable values saved subscripts powers x4 x8 x16 saves saves equal variable initialized doubled updated sequence subscript saved lines œ10 factor saved current computes greatest common divisor gcd nontrivial divisor checked prints procedure finding factor mewhat mysterious note pollard rho prints incorrect answer number prints nontrivial divisor pollard rho print guarantee produce good reason expect pollard rho print factor iterations loop composite expect procedure discover divisors factor completely n1 updates prime factor largest analysis behavior procedure studying long takes random sequence modulo repeat zn finite sequence depends previous sequence eventually repeats reach cycle reason rho heuristic figure sequence drawn tail rho cycle body rho figure pollard rho heuristic values produced recurrence mod starting prime factorization heavy arrows iteration steps executed fore factor discovered light arrows point unreached values iteration illustrate rho shape shaded values values stored pollard rho factor discovered reaching x7 gcd computed repeated factor discovered repeated values produced recurrence modulo equivalent modulo x4 x7 equivalent modulo values produced recurrence modulo equivalent modulo chinese remainder theorem node corresponds pair nodes question long takes sequence repeat modify argument purpose estimation assume function mod behaves random function random assumption yields consistent observed behavior pollard rho independently drawn zn uniform distribution zn birthday paradox analysis expected number steps sequence cycles required modification nontrivial factor gcd factorization e1 smallest prime factor good mind sequence induces sequence modulo mod defined arithmetic ope rations squaring subtraction modulo compute modulo view sequence smaller version wh happening modulo mod mod mod mod mod exercise mod mod mod explicitly computing sequence sequence defined obeys recurrence sequence reasoning expected number steps sequence repeats small compared sequence repeat sequence sequence repeats elements sequence equivalent modulo equivalent modulo figure parts illustration denote repeated sequence denote length cycle produced smallest values arguments expected values note gcd pollard rho saved mod cycle modulo saved cycle modulo eventually set greater procedure entire loop cycle modulo changing factor discovered runs stored modulo mod factor factor occasionally happen multiple discovered expected values expected number steps required produce factor reasons algorithm perform expected heuristic analysis running time rigorous ssible cycle values modulo larger case algorithm performs correctly slowly desired practice issue moot divisors produced algorithm trivial factors suppose prime happen values identical values factor revealed gcd operation reveals factor factors revealed time trivial factor revealed useless problem insignificant practice nece ssary heuristic restarted recurrence form mod values avoided reasons values fine analysis heuristic rigorous recurrence random procedure performs practice efficient heuristic analysis method choice finding small prime factors large number factor bit composite number completely prime factors n1 expect pollard rho require n1 arithmetic operations n1 bit operations pollard rho ability small factor expected number arithmetic operations appealing feature exercises referring executio history figure pollard rho print factor exercises suppose function zn zn initial x0 zn define smallest values terminology pollard rho algorithm length tail length cycle rho efficient algorithm determine analyze running time exercises steps expect pollard rho require discover factor form prime exercises disadvantage pollard rho written requires gcd computation step recurrence batch gcd computations accumulating product values row product gcd computation carefully implement idea works batch size pick effective working bit number problems binary gcd algorithm computers operations subtraction testing parity odd binary integer halving performed computing remainders problem investigates binary gcd algorithm avoids remainder computations euclid algorithm prove gcd gcda prove odd gcd gcd prove odd gcd gcd design efficient binary gcd algorithm input integers runs lg time assume subtractio parity test halving performed unit time problems analysis bit ope rations euclid algorithm ordinary paper pencil algorithm long division dividing yields quotient remainder method requires lg lg bit operations define µ lg lg number bit operations performed euclid reducing problem computing gcd computing gcd mod µ µ mod large constant euclid requires µ bit operations general bit operations applied bit inputs exercises algorithms fibonacci numbers problem compares efficiency methods computing nth fibonacci number assume cost adding subtracting multiplying numbers independent size numbers running time straightforward recursive method computing based recurrence exponential compute time memoization compute lg time integer addition multiplication hint matrix powers assume adding bit numbers takes time multiplying bit numbers takes time running tim methods reasonable cost measure elementary arithmetic operations problems quadratic residues odd prime number quadratic residue equation mod solution unknown quadratic residues modulo prime define legendre symbol quadratic residue modulo prove efficient algorithm dete rmining number quadratic residue modulo analyze efficiency algorithm prove prime form quadratic residue ak mod square root modulo time required square root quadratic residue modulo efficient randomized algo rithm finding nonquadratic residue modulo arbitrary prime member quadratic residue arithmetic operations algorithm require average chapter notes niven zuckerman provide excellent introduction elementary number theory knuth good discussion algorithms finding greatest common divisor basic number theoretic algorithms bach riesel provide surveys computational number theory dixon overview factorization primality testing conference proceedings edited pomerance excellent survey articles bach shallit provided exceptional overview basics computational number theory knuth discusses origin euclid algor ithm appears book propositions greek mathematician euclid elements written euclid description derive algorithm eudoxus euclid algorithm hold honor ing oldest nontrivial algorithm rivaled algorithm multiplication ancient egyptians shallit chronicles history analysis euclid algorithm knuth attributes special case chinese remainder theorem theorem chinese mathematician sun lived uncertain special case greek mathematician nichomachus generalized chhin chiu shao chinese remainder theorem finally stated prove generality euler randomized primality testing algo rithm presented miller rabin fastest randomized primality esting algorithm constant factors proof theorem slight adaptation suggested bach proof stronger result miller rabin monier randomization appears polynomial time primality testing algorithm fastest deterministic primality testing algorithm cohen lenstra version primality test adleman pomerance rumely testing number length lg primality runs lg lg lg lg time superpolynomial problem finding large random primes nicely discussed article beauchemin brassard crépeau goutier pomerance concept public key cryptosystem diffie hellman rsa cryptosystem proposed rivest shamir adleman field cryptography blossomed understanding rsa cryptosystem deepened modern implementations sign ificant refinements basic techniques presented addition tec hniques developed proving cryptosystems secure goldwasser micali randomization effectiv tool design secure public key encryption schemes signature schemes goldwasser micali rivest digital signature scheme conceiva ble type forgery provably difficult factoring menezes provide overview applied cryptography rho heuristic integer factorization invented pollard version presented variant proposed brent algorithms factoring large num bers running time grows roughly exponentially cube root length number factored general number field seive factori algorithm developed buhler extension ideas number field sieve factoring algorithm pollard lenstra refined coppersmith efficient algorithm general large input difficult rigorous analysis algorithm reasonable assumptions derive running time estimate elliptic curve method lenstra effective inputs number field sieve method pollard rho method small prime factor method time estimated chapter string matching overview finding occurrences pattern text problem arises equently text editing programs typically text document ing edited pattern searched word supplied user efficient algorithms problem greatly aid responsiveness text editing program string matching algorithms search patterns dna sequences formalize string matching problem assume text array length pattern array length assume elements characters drawn finite alphabet character arrays called strings characters pattern occurs shift text equivalently pattern occurs position text occurs shift valid shift invalid shift string matching problem problem finding valid shifts pattern occurs text figure illustrates definitions figure string matching problem goal occurrences pattern abaa text abcabaabcabac pattern occurs text shift shift valid shift character pattern connected vertical matching character text matched characters shaded naive brute force algorithm review string matching algorithm chapter performs preprocessing based pattern finds valid shifts phase matching figure preprocessing matching times algorithms chapter total running time algorithm sum preprocessing matching times presents interesting string matching gorithm rabin karp worst case running time algorithm naive method works average practice generalizes nicely pattern matching problems describes string matc hing algorithm constructing finite automaton desi gned search occurrences pattern text algorithm takes preprocessing time matching time cleverer knuth morr pratt kmp algorithm presented kmp algorithm matching time reduces preprocessing time algorithm preprocessing timematching time naive rabin karp finite automaton knuth morris pratt figure string matching algorithms chapter preprocessing matching times notation terminology read sigma star denote set finite length strings formed characters alphabet chapter finite length strings length string denoted belongs length string denoted concatenation strings denoted xy length consists characters characters string prefix string denoted wy string note string suffix string denoted yw string suffix prefix string abcca cca abcca note strings character xa ya note transitive relations lemma lemma overlapping suffix lemma suppose strings proof figure graphical proof figure graphical proof lemma suppose parts figure illustrate cases lemma vertical lines connect matching regions shaded strings brevity notation denote character prefix pattern p0 denote character prefix text tk notation state string matching problem finding shifts range pseudocode equal length strings compared equality primitive operation strings compared left comparison stops mismatch discovered assume time test linear function number matc hing characters discovered precise test assumed time length longest string write handle case characters compared match takes positive time perform comparison naive string matching algorithm naive algorithm finds valid shifts loop checks condition values naive string matcher length length print pattern occurs shift naive string matching procedure inte rpreted graphically sliding template pattern text noting shifts characters template equal corres ponding characters text illustrated figure loop considers shift explicitly test determines current shift valid test involves implicit loop check character positions positi ons match mismatch prints valid shift figure operation naive string matcher pattern aab text acaabc imagine pattern template slide text successive alignments naive string matcher vertical lines connect regions match hown shaded jagged connects mismatched character occurrence pattern shift procedure naive string matcher takes time bound tight worst case text string string pattern values shift implicit loop compare characters execute times validate shift worst case running time running time naive string matcher equal matchi time preprocessing naive string matcher optimal procedure problem chapter sh algorithm worst case preprocessing time worst case matching time naive string matcher inefficient gained text values valuable aaab valid shifts valid sections examine ways effective sort exercises comparisons naive string matcher pattern text exercises suppose characters pattern accelerate naive string matcher time character text exercises suppose pattern text randomly chosen strings length ary alphabet expected number character character comparisons implicit loop naive algorithm executions loop assume naive algorithm stops comparing characters shift mismatch entire pattern matched randomly chosen strings naive algorithm efficient exercises suppose pattern occurrences gap character match arbitrary string characters length pattern bac occurs text cabccbacbacab note gap character occur arbi trary number times pattern assumed occur text polynomial time algorithm determine pattern occurs text analyze running time algorithm rabin karp algorithm rabin karp proposed string matchi algorithm performs practice generalizes algorithms problems dimensional pattern matching rabin karp algorithm preprocessing time worst case running time based assumptions average case running time algorithm elementary number heoretic notions equivalence numbers modulo number refer relevant definitions expository purposes assume character digit general case ssume character digit radix notation view string consecutive characters representing length number character stri corresponds number dual inte rpretation input characters graphical symbols digits convenient denote digits standard text font pattern denote manner text denote length substring valid shift compute time values total time determine valid shifts time comparing moment worry possibility large numbers compute time horner rule t0 computed time compute remaining values time suffices observe computed constant time remove high order digit bring low order digit suppose subtracting removes high order digit multiplying result shifts number left position adding brings low order digit constant precomputed time lg techniques application straightforward time method adequate execution equation takes constant number arithmetic operations compute time compute t0 time occurrences pattern text preprocessing time matching time difficulty procedure large work conveniently characters assuming arithmetic operation digits long takes constant time unreasonable fortunately simple cure problem figure compute modulo suitable modulus computation t0 recurrence performed modulo compute modulo time modulo time modulus typically chosen prime fits computer word necessa computations performed single precision arithmetic general ary alphabet choose dq fits computer word adjust recurrence equation work modulo dm mod digit high order position digit text window figure rabin karp algorithm char acter git compute values modulo text string window length shaded numerical shaded number comput modulo yielding text string values computed modulo position length window assuming pattern windows modulo mod windows shaded figure text position occurrence pattern text position spurious hit computing window constant time prev ious window window dropping high order digit shifting left ltiplying adding low order digit computations performed modulo window computed window solution working modulo perfect mod imply hand mod shift invalid test mod fast heuristic test rule invalid shifts shift mod tested valid spurious hit testing explicitly checking condition large hope spurious hits occur infrequently cost extra checking low procedure ideas precise inputs procedure text pattern radix typically prime rabin karp matcher length length dm mod t0 preprocessing mod t0 dt0 mod matching print pattern occurs shift mod procedure rabin karp matcher works llows characters interpreted radix digits subscripts provided clarity program works correctly subscripts dropped initializes high order digit position digit window lines compute mod t0 mod loop lines iterates shifts maintaining invariant executed mod hit check rule possibility spurious hit valid shifts printed checked loop executed time executed ensure loop invariant holds reached computes mod mod constant time equation directly rabin karp matcher takes preprocessing time matching time worst case naive string matching algorithm rabin karp algorithm explicitly verifies valid shift verifications time shifts valid applications expect lid shifts constant applications expected matching time algorithm time required process spurious hits base heuristic analysis assumption ducing values modulo acts random mapping zq discussion division hashing difficult formalize prove assumption viable approach assume chosen randomly integers size pursue formalization expect number spurious hits chance arbitrary equivalent modulo estimated positions test fails spend time hit expected matching time rabin karp algorithm number valid sh ifts running time choose expected number valid shifts small prime chosen larger length pattern expect rabin karp procedure matching time expected matching time exercises working modulo spurious hits rabin karp matcher encounter text pattern exercises extend rabin karp method problem searching text string occurrence set patterns start assuming patterns length generalize soluti patterns lengths exercises extend rabin karp method handle problem pattern array characters patter shifted vertically horizontally rotated exercises alice copy long bit file a0 bob bit file b0 alice bob files identical avoid transmitting fast probabilistic check select prime randomly select integer alice evaluates bob evaluates prove chance files hint exercise write values takes asymptotic sense computing lone takes time time string matching finite automata string matching algorithms build fini automaton scans text string occurrences pattern presents method building automaton string matching automata fficient examine text character constant time text character matching time preprocessing pattern build automaton time build automaton large large describes clever problem definition finite automaton examine special string matching automaton occurrences pattern text discussion includes details simulate behavior string matching automaton text finally construct string matching automaton input pattern finite automata finite automaton tuple q0 finite set states q0 start state distinguished set accepting states finite input alphabet function called transition function finite automaton state q0 reads characters input string time automaton state reads input character moves transition state state current state member machine accepted string read input accepted rejected figure illustrates definitions simple state automaton figure simple state nite automaton state set start state q0 input alphabet tabular representation transition function equivalent state transition diagram state accepting state blackened directed edges represent transitions edge state state labeled automaton accepts strings odd number precisely string accepted yz ends ak odd sequence ates automaton enters input abaaa including start state accepts input input abbaa sequence states rejects input finite automaton induces function called final state function state ends scanning string accepts string function defined recursive relation q0 string matching automata string matching tomaton pattern automaton constructed pattern preprocessing step search text string figure illustrates construction pattern ababaca assume fixed patternstring brevit dependence notation figure state transition diagram stri matching automaton accepts strings string ababaca state start state state blackened accepting state directed edge state state labeled represents edges forming spine automaton heavy figure correspond successful matches pattern input characters left edges correspond failing matches edges failing matches convention state outgoing edge labeled transition function pattern string ababaca entries successful matches pa ttern input characters shaded operation automaton text abababacaba text character state automaton processing prefix occurrence pattern position order string matching tomaton pattern define auxiliary function called suffix function function mapping length longest prefix suffix max suffix function defined nce string p0 suffix string examples pattern ccaca ccab pattern length definition suffix function define string matching automat corresponds pattern state set start state q0 state state accepting state transition function defined equation state character intuitive rationale defining pqa machine maintains invariant operation result proved theorem scanning characters text string machine state length longest suffix prefix pattern character scanned machine transition state tia proof theorem tia pqa compute length longest suffix tia prefix compute longest suffix pqa prefix state machine length longest prefix suffix read setting pqa maintains desired invariant informal argument rigorous shortly string matching automaton figure transition automaton reads state ababab longest prefix suffix ababab p4 abab clarify operation string matching automaton simple efficient program simulating behavior automaton represented transition function finding occurrences pattern length input text string matching automat pattern length state set start state ly accepting state state finite automaton matcher length print pattern occurs shift simple loop structure finite aut omaton matcher implies matching time text string length matching time include preprocessing time required mpute transition function address problem proving procedure finite automaton matcher operates correctly operation automaton input text prove automaton state scanning character machine accepting state pattern scanned prove result lemmas suffix function lemma suffix function inequality string character xa proof referring figure xa conclusion xa trivially satisfied nonnegativity assume xa definition dropping xa largest xa figure illustration proof lemma figure xa lemma suffix function recursion lemma string character xa pqa proof definition figure pqa xa xa lemma pqa xa xa pqa lemma implies pqa pqa xa pqa pqa xa pqa xa xa pqa figure illustration proof lemma figure pqa xa ready prove main theorem aracterizing behavior string matching automaton input text theorem automaton keeping track step longest prefix pa ttern suffix read automaton maintains invariant theorem final state function string matching automaton pattern input text automaton proof proof induction theorem trivially true t0 t0 t0 assume prove denote denote tia definitions definition definition pqa definition tia lemma induction definition theorem machine enters state largest occurrence pattern scanned conclude fini automaton matcher operates correctly computing transition function procedure computes transition function pattern compute transition function length character min repeat pqa return procedure computes straightforward manner definition nested loops lines states characters lines set largest pqa code starts largest conceivable min decreases pqa running time compu transition function m3 outer loops contribute factor repeat loop times test pqa require comparing characters faster procedures exist time required compute improved utilizing cleverly computed pattern exercise improved procedure computing occurrences length pattern length text alphabet preprocessing time matching time exercises construct string matching automaton pattern aabab illustrate operation text string aaababaabaababaab exercises draw state transition diagram string matching automaton pattern ababbabbababbababbabb alphabet exercises pattern nonoverlappable implies state transition diagram string matchi automaton nonoverlappable pattern exercises patterns construct finite automaton determines occurrences pattern minimize numbe states automaton exercises pattern gap characters exercise build finite automaton occurrence text matching time knuth morris pratt algorithm linear time string matching algorithm knuth morris pratt algorithm avoids comput ation transition function altogether matching time auxiliary function precomputed pattern time array transition function computed efficiently amortized sense fly needed roughly speaking state character independent needed compute remark clar ified shortly array entries entries save factor preprocessing time computing prefix function pattern prefix function pattern encapsulates knowledge pattern matches shifts avoid testing useless shifts naive pattern matching algorithm avoid precomputation string matching automaton operation naive string matcher figure shift template pattern ababaca text characters matched pattern character fails match text character characters matched determines characters knowing text characters determine shifts invalid gure shift invalid pattern character aligned text character tch pattern character shift figure aligns pattern characters text characters necessa rily match general eful answer question figure prefix function pattern ababaca aligned text characters match matching charac ters shaded connected vertical lines knowledge matc characters deduce shift invalid shift consistent text valid deductions precomputed comparing pattern longest prefix proper suffix p5 precomputed represented array characters matched shift valid shift pattern characters match text characters shift shift shift greater invalid knowledge case shifts ruled case shift compare characters characters guaranteed match equation precomputed comparing pattern illustrated figure portion text suffix string equation interp reted largest valid shift turns convenient store number matching characters shift storing speed naive string matching algorithm finite automaton matcher formalize precomputation requi red pattern prefix function pattern function max length longest prefix proper suffix figure complete prefix function pattern ababababca figure illustration lemma pattern ababababca function pattern iterating slide template pattern note prefix matches proper suffix p8 figure row dotted vertical drawn p8 successive rows shifts prefix match suffix p8 matched characters shaded vertical lines connect aligned matching characters lemma claims knuth morris pratt matching algorithm ven pseudocode procedure kmp matcher modeled finite automaton matcher kmp matcher calls auxili ary procedure compute prefix function compute kmp matcher length length compute prefix function number characters matched scan text left character match character matches matched print pattern occurs shift match compute prefix function length return analysis running times procedures proving procedures correct complicated running time analysis running time compute prefix function potential method amortized analysis associate potential current state algorithm potential initi decreases executed negative increases execution loop body entering loop incremented iteration loop body holds justifies claim pay execution loop body decrease potential function increases potential function amortized cost loop body lines number outer loop iterations final potential function great initial potential function total actual worst case running time compute prefix function amortized analysis potential function matching time kmp matcher compared finite autom aton matcher reduced time preprocessing pattern keeping actual matching time bounded correctness prefix function computation start essential lemma showi iterating prefix function enumerate prefixes proper suffixes prefix defined terms unctional iteration understood sequence stops reached lemma characterizes figure illustrates lemma prefix function iteration lemma pattern length prefix function proof prove prove equation induction claim relations transitivity establishes claim prove contradiction suppose contrary integer set largest largest denote smallest integer greater choose number greater lemma largest property contradiction proves lemma algorithm compute prefix function computes order computation compute prefix function correct lemma corollary prove compute prefix function computes correctly lemma pattern length prefix function proof dropping character lemma define subset lemma set consists values consists values extend proper suffix corollary pattern length prefix function proof including extend proper suffix nonempty definition note lemma max equivalently combining equations completes proof finish proof compute prefix function computes correctly procedure compute prefix function start iteration loop lines condition enforced lines loop entered remains true su ccessive iteration lines adjust correct loop lines searches values point largest set corollary set set leave set lines set correctly case completes proof corre ctness compute prefix function correctness kmp algorithm procedure kmp matcher viewed reimplementation procedure finite automaton matcher prove code lines kmp matcher equivalent finite automaton matcher sets stored recomputed argued kmp matcher simulates behavior finite automaton matcher correctness kmp matcher correctness finite automaton matcher moment matcher correctness kmp matcher claim check claim pqt definitions dropping character pqt case proving claim claim denote entered equivalence lemma justify iteration enumerates elements lines determine examining elements decreasing order code claim perform iteration case case maximum element corollary kmp matcher avoid reference occurrence argument execution remains valid hint exercise equivalently pa remaining argument correctness knuth morris pratt algorithm correctness finite automaton matcher kmp tcher simulates behavior finite automaton matcher exercises compute prefix function pattern ababbabbabbababbabb alphabet exercises upper bound size function bound tight exercises explain determine occurrences pattern text examining function string string length concatenation exercises improve kmp matche replacing occurrence defined recursively equation explain modified algorithm correct explain sense modification constitutes improvement exercises linear time algorithm determine text cyclic rotation string arc car cyclic rotations exercises efficient algorithm computing transition function string matching automaton pattern algorithm time hint prove problems string matching based repetition factors yi denote concatenation string times ababab string repetition factor string denote largest repetition factor efficient algorithm takes input pattern computes running tim algorithm pattern defined max prove pattern chosen randomly binary strings length expected argue string matching gorithm correctly finds occurrences pattern text time repetition matcher length length print pattern occurs shift max algorithm galil seiferas extending ideas greatly linear time string match ing algorithm storage required chapter notes relation string matching theo finite automata discussed aho hopcroft ullman knuth morris pratt algorithm invented independently knuth pratt morris published work jointly rabin karp algorithm proposed rabin karp galil seiferas interesting deterministic linear time string mat ching algorithm space required store pattern text chapter computational geometry overview computational geometry branch comput science studies algorithms solving geometric problems modern engineering mathematics computational geometry applications elds computer graphics robo tics vlsi design computer aided design statistics input computational geometry problem typically description set geometric objects set points set segments vertices polygon counterclockwise order output response query objects lines intersect geometric object convex hull smallest closing convex polygon set points chapter computational geometry algorithms dimensions plane input object represented set points yi yi vertex polygon represented sequence p0 vertices order appearance boundary computational geometry performe dimensions higher dimensional spaces problems lutions difficult visualize dimensions good sample computational geometry techniques answer basic questions segments efficiently accurately segment clockwise counterclockwise shares endpoint turn traversing tw adjoining segments segments intersect presents technique called sweeping develop lg time algorithm determining intersections set segments rotational sweep algorithms compute convex hull smallest encl osing convex polygon set points graham scan runs time lg jarvis march takes nh time number vertices convex hull finally lg time divide conquer algorithm finding clos pair points set points plane segment properties computational geometry algorithms chapter require answers questions properties segments convex combination distinct points y1 point y3 range y3 y1 write intuitively point passing distinct points segment set convex combinations endpoints segment ordering matters speak directed segment origin treat directed segment vector xplore questions directed segments clockwise respect common endpoint p0 segments traverse left turn point segments intersect restrictions points answer question time surprise input size question methods additions subtractions multiplications comparisons division trigonometric functions computationally expensive prone problems round error straightforward method termining segments intersect compute equation form mx segment slope intercept point intersection lines check point segments division point intersection segments parallel method sensitive precision division operation real computers method whic avoids division accurate cross products computing cross products heart segment met hods vectors figure cross product interpreted signed area parallelogram formed points y1 equivalent definition cross product determinant matrix figure cross product vectors signed area parallelogram lightly shaded region vectors clockwise darkly shaded region vectors counterclockwise positive clockwise respect origin cross product negative counterclockwise exercise figure clockwise counterclockwise regions relative vector boundary condition arises cross product case vectors collinear pointing opposite directions determine directed segment clockwise directed segment respect common endpoint p0 simply translate p0 origin p0 denote vector define p0 compute cross product p0 p0 x0 y0 x0 y1 y0 cross product positive clockwise negative counterclockwise determining consecutive segments turn left question consecutive segments turn left point equivalently method determine angle p0p1p2 turns cross products answer question computi angle figure simply check directed segment clockwise counterclockwise relative directed segment compute cross product p0 p0 sign cross product negative counterclockwise respect left turn positive cross product clockwise orientation turn cross product points p0 collinear figure cross product determine consecutive segments turn point check directed segment clockwise counterclockwise relative directed segment counterclockwise points left turn clockwise turn determining segments intersect determine segments inters ect check segment straddles segment straddles point lies point lies boundary case arises lies directly segments intersec conditions holds segment straddles endpoint segment lies segment condition boundary case procedures implement segments intersect returns true segments intersect false calls subroutines direction computes relative orientations cross product method segment determines poi collinear segment lies segment segments intersect p4 d1 direction p4 direction p4 d3 direction d4 direction p4 d1 d1 d3 d4 d3 d4 return true elseif d1 segment p4 return true elseif segment p4 return true elseif d3 segment return true elseif d4 segment p4 return true return false direction return segment min max min yi yk max yi return true return false segments intersect works lines compute relative orientation endpoint respect segment relative orientations nonzero easily determine segments intersect segment straddles segment directed segments opposite orientations relative case signs d1 differ straddles signs d3 d4 differ test true segments straddle segments intersect returns true figure case segments straddle lines boundary case apply relative orientations nonzero boundary case applies tests lines fail segments intersect returns false figure case figure cases procedure segments intersect segments straddle lines straddles signs cross products p4 differ straddles signs cross products p4 p4 differ segment straddles straddle signs cross products p4 p4 point collinear point collinear segments intersect boundary case occurs relative orientation collinear segment directly segment onl endpoints segment procedure segment returns endpoints segment segment called lines procedure assumes collinear segment figures cases collinear points figure segments intersect returns true endpoints segments figure segments intersect returns false applications cross products sections chapter introdu additional cross products sort set points polar angles respect origin exercise asks cross products perform comparisons rting procedure red black trees maintain vertical ordering set segments keeping explicit key values replace key comparison red ack tree code cross product calculation determine segments intersect vertical exercises prove positive vector clockwise vector respect origin cross product negative counterclockwise exercises professor powell proposes dimension tested segment professor wrong exercises polar angle point respect origin point p0 angle vector p0 usual polar coordinate polar angle respect angle vector degrees radians polar angle respect angle vector degrees radians write pseudocode sort sequence points polar angles respect origin point p0 procedure lg time cross products compare angles exercises determine lg time points set points collinear exercises polygon piecewise linear clos curve plane curve formed sequence straight segments called sides polygon point joining consecutive sides called vertex polygon polygon simple generally assume cross set points plane enclosed simple polygon forms interior polygon set points polygon forms boundary set points surrounding polygon forms exterior simple polygon convex points boundary interior points segment drawn contained polygon boundary interior professor amundsen proposes method determine sequence p0 points forms consecutive vertices convex polygon output set subscript addition performed modulo left turns turns output method runs linear time produce correct answer modify professor method produ ces correct answer linear time exercises point p0 x0 y0 horizontal ray p0 set points yi x0 yi y0 set points p0 p0 determine horizontal ray p0 intersects segment time reducing problem determining segments intersect exercises determine point p0 interior simple convex polygon ray p0 check ray intersects boundary odd number times p0 boundary compute time point p0 interior vertex polygon hint exercise algorithm correct ray intersects polygon boundary vertex ray overlaps polygon exercises compute area vertex simple convex polygon time exercise definitions pertaining polygons cross product dimens ional concept vector perpendicular hand magnitude y1 chapter prove convenient treat cross product simply y1 determining pair segments intersects presents algorithm determining segments set segments intersect algorithm echnique sweeping common computational geometry algorithms exercises algorithm simple vari ations solve computational geometry problems algorithm runs lg time number segments determines intersection exists print intersections exercise takes time worst case intersections set segments sweeping imaginary vertical sweep passes set geometric objects left spatial dimension sweep moves case dimension treated dimension time sweeping method ordering geometric objects usua lly placing dynamic data structure advantage relationships segment intersection algorithm considers segment endpoint left order checks intersection time encounters endpoint prove correct algorithm determining segments intersect simplifying assumptions assume input segment vertical assume input segments intersect single point exercises algorithm robust slight modification work assumptions hold removing simplifying assumptions dealing boundary conditions difficult programming computa tional geometry algorithms proving correctness ordering segments assume vertical segm ents input segment intersects vertical sweep intersects single point order segments intersect vertical swee coordinates points intersection precise segments s1 segments comparable vertical sweep coordinate intersects s1 written s1 s1 comparable intersection s1 sweep higher intersection sweep figure relationships segment comparable segment figure ordering segments vertical sweep lines segment comparable segment segments intersect orders reversed sweep passes shaded region consecutive total order relation total order segments intersect sweep order differ differing values segments enter leave ordering segment enters orde ring left endpoint encountered sweep leaves ordering endpoint encountered sweep passes intersection segments figure positions total order reversed sweep lines left point intersection segments note assume segments intersect point vertical sweep intersecting segments consecutive total order sweep passes shaded region figure consecutive total order moving sweep sweeping algorithms typically manage sets data sweep status relationships objects intersected sweep event point schedule sequence coordinates ordered left defines halting positions sw eep halting position event point sweep stat occur event points algorithms algorithm asked exercise event point schedule determined dynamically algorithm progresses algorithm hand determines event points statically based solely simple properties input data segment endpoint event point sort segment endpoints increasing coordinate proceed left endpoints covertical coordinate break tie putting covertical left endpoints covertical endpoints set covertical left endpoints lower coordinates set covertical endpoints insert segment sw eep status left endpoint encountered delete sw eep status endpoint encountered segments beco consecutive total order check intersect sweep status total order require operations insert insert segment delete delete segment return segment segment return segment segment segments input perf orm operations lg time red black trees recall red black tree operations chapter involve comparing keys replace key compar isons comparisons cross products determine relative dering segments exercise segment intersection pseudocode algorithm takes input set segments returning boolean true pair segments intersects false total order implemented red black tree segments intersect ø sort endpoints segments left breaking ties putting left endpoints endpoints breaking ties putting points lower coordinates point sorted list endpoints left endpoint segment insert exists intersects exists intersects return true endpoint segment exist intersects return true delete return false figure illustrates execution algorithm li initializes total order determines point schedule sorting segment endpoints left breaking ties note performed lexicographically sorting endpoints usual coordinates left endpoint endpoint figure execution segments intersect dashed sweep event point ordering segment names sweep total order loop event point processed intersection segments segment deleted iteration loop lines processes event point left endpoint segment adds total order lines return true intersects segments consecuti total der defined sweep passing boundary condition occurs lies segment case require consecutively endpoint segment deleted total order lines return true intersection segments surrounding total order fined sweep passing segments consecutive total order deleted segments intersect deletes segment total order finally intersections processing event points returns false correctness segments intersect correct prove segments intersect returns true ere intersection segments easy segments inters ect returns true lines finds intersection input segments returns true intersection converse intersection segments intersect returns true suppose intersection leftmost intersection point breaking ties choosing lowest coordinate segments intersect intersections occur left order correct points left segments intersect point exists sweep consecutive total order left exists segment endpoint sweep event point consecutive total order sweep sweep left case order correct encountered lexicographic order algorithm processes event points lowest leftmost intersection points sweep intersection point event point processed intersection interfere total order left endpoint segment endpoint segment left endpoint events occur endpoint events segment segment encountered event point processed segments inter sect processed processed segments intersect possibilities action inserted segment total order lines detect case segments segment total order deleted making consecutive lines detect case case intersection segments intersect returns true event point processed segments intersect procedure returned processing event points situation occurred segments intersect intersection returned true intersection segments intersect returns true segments intersect turns true intersection segments intersect ways returns correct answer running time segments set segments intersect runs time lg takes time takes lg time merge sort heapsort event points loop lines iterates times iteration takes lg time red black tree operation takes lg time method intersection test takes time total time lg exercises intersections set segments exercises segments comparable determine time holds assume neithe segment vertical hint intersect cross products intersect determine cross products addition subtraction multiplication avoiding division cour application relation intersect declare intersection exercises professor maginot suggests modify segments intersect returning finding intersection prints segments intersect continues iteration loop professor calls procedure print intersecting segments claims prints intersections left occur set segments professor wrong counts set segments rst intersection print intersecting segments leftmost set segments print intersecting segments fails intersections exercises lg time algorithm determine vertex polygon simple exercises lg time algorithm determine simple polygons total vertices intersect exercises disk consists circle interior represented center point radius disks intersect point common lg time algorithm determine disks set intersect exercises set segments total intersections output intersections lg time exercises argue segments intersect works corre ctly segments intersect point exercises segments intersect works rrectly presence vertical segments endpoint vertical segm ent processed left endpoint endpoint processed endpoint answer exercise change vertical segments allowed segments intersect point intervening segment intersects point sweep lines left exercise asks segments intersect correct segments intersect point finding convex hull convex hull set points smallest convex polygon point boundary interior exercise precise definition convex polygon denote convex hull intuitively point nail sticking boa convex hull shape formed tight rubber band surrounds nails figure set points convex hull figure set points p0 p12 convex hull gray algorithms comput convex hull set points algorithms output vertices convex hull counterclockwise order graham scan runs lg time called jarvis march runs nh time number vertices convex hull figure vertex point algorithms exploit property deciding vertices vertices convex hull vertices throw fact met hods compute convex hulls lg time graham scan jarvis march echnique called rotati onal sweep processing vertices order polar angles form reference vertex methods include incremental method points sorted yielding sequence ith stage convex hull leftmost points updated ith point left forming exercise asks method implemented total lg time divide conquer method time set points divided subsets leftmost points rightmost points convex hulls subsets computed recursively clever method combine hulls time running time familiar recurrence divide conquer method runs lg time prune search method worst case linear time median algorithm finds upper portion upper chain convex hull repeatedly throwing constant fraction remaining points upper chain convex hull remains lower chain method asymptotically fastest convex hull vertices runs lg time computing convex hull set points interesting problem algorithms computa tional geometry problems start computing convex hull dimensional farthest pair problem set points plane points distance maximum exercise asks prove points vertices convex hull prove farthest pair vertices vertex convex polygon time computing convex hull input points lg time finding farthest pair convex polygon vertices farthest pair points set points lg time graham scan graham scan solves convex hull problem maintaining stack candidate points point input set pushed stack points vertices eventually popped stack algorithm terminates stack vertices counterclockwise order appearance boundary procedure graham scan takes input set points calls functions returns point stack changing returns point entry stack changing prove moment stack returned graham scan vertices counterclockwise order graham scan p0 point minimum coordinate leftmost point case tie remaining points sorted polar angle counterclockwise order p0 point angle remove farthest p0 push p0 push push angle formed points nonleft turn pop push return figure illustrates progress grah scan chooses point p0 point lowest coordinate picking leftmost poi case tie point p0 points coordinate p0 vertex sorts remaining points polar angle relative p0 method comparing cross products exercise points polar angle relative p0 farthest point convex combinations p0 farthest point remove consideration denote number points p0 remain polar angle measured radians point relative p0 half open interval points sorted polar angles sorted counterclockwise order relative p0 designate sorted sequence points note points vertices exercise figure points figure sequentially numbered order increasing polar angle relative p0 figure execution graham scan set figure current convex hull contained stack gray step sequence p12 points numbered order increasing polar angle relative p0 initial stack p0 stack iteration loop lines dashed lines nonleft turns points popped stack turn angle p7p8p9 p8 popped turn angle p6p7p9 p7 popped convex hull returned procedure matches figure remainder procedure stack lines initialize stack points p0 figure initial stack loop lines iterates point subsequence p4 intent ter processing point stack vertices p0 counterclockwise order loop lines removes points stack vert ices convex hull traverse convex hull counterclockwise turn vertex time loop finds vertex nonleft turn vertex popped stack checking nonleft turn turn test precludes possibility straight angle vertex convex hull straight angles vertex convex polygon convex combination vertices polygon pop vertices nonleft turns heading point push stack figures state stack iteration loop finally graham scan returns stack figure convex hull theorem formally prove correctness graham scan theorem correctness graham scan graham scan set points termination stack consists vertices counterclockwise order proof sequence points define subset points qi p0 points qm removed polar angle relative p0 point qm points qm suffices graham scan terminates stack consists vertices qm counterclockwise order botto note p0 vertices points p0 vertices qi proof loop invariant start iteration loop lines stack consists vertices qi counterclockwise order initialization invariant holds time execute time stack consists vertices q2 qi set vertices forms convex hull countercloc kwise order maintenance entering iteration loop point stack pushed previous iteration iteration point loop lines executed pushes point moment point pushed stack points contained iteration loop loop invariant vertices moment counterclockwise order continue focus moment pushed referring figure polar angle relative p0 greater polar angle angle pkpjpi left turn wise popped vertices push stack vertices counterclockwise order figure proof correctness graham scan polar angle relative p0 greater polar angle angle pkpj left turn adding vertices angle prptpi nonleft turn interior triangle formed p0 triangle vertex qi set points qi point popped iteration loop point stack time popped angle prptpi nonleft turn polar angle relative p0 greater polar angle figure interior triangle formed p0 triangle vertex triangle triangle formed points qi vertex qi vertex qi set points popped iteration loop equality applies points apply repeatedly qi qi qi conclude qi qi push stack vertices qi counterclockwise order incrementing loop invariant hold iteration termination loop terminates loop invariant implies stack consists vertices qm counterclockwise order completes proof running time graham scan lg takes time takes lg time merge sort heapsort sort polar angles cross product method compare angles removing farthest point polar angle total time lines time loop lines executed times push takes time iteration takes time exclusive time spent loop lines loop takes time exclusive nested loop aggregate analysis loop takes time point pushed stack analysis multipop procedure observe pop operation push operation points p0 popped stack fact pop operations performed total iteration loop performs pop iterations loop altogether test takes time pop takes time total time loop running time graham scan lg jarvis march jarvis march computes convex hull set points technique package wrapping gift wrapping algorithm runs time nh number vertices lg jarvis march asymptotically faster graham scan intuitively jarvis march simulates wra pping taut piece paper set start taping paper lowest point set point p0 start graham scan point vertex convex hull pull paper taut pull higher touches point point vertex convex hull keeping paper taut continue set vertices original point p0 formally jarvis march builds sequence p0 vertices start p0 figure convex hull vertex smallest polar angle respect p0 case ties choose point farthest p0 smallest polar angle respect reach highest vertex breaking ties choosing farthest vertex constructed figure chain construct left chain start choose point smallest polar angle respect negative axis continue forming left chain polar angles negative axis original vertex p0 figure operation jarvis march vertex chosen lowest point p0 vertex smallest polar angle point respect p0 smallest polar angle respect chain high highest point left chain constructed finding smallest polar angles respect negative axis implement jarvis march onceptual sweep convex hull separately constructing left chains implementations typically track angle convex hull chosen require sequence angles hull sides strictly incr easing range radians advantage constructing separate chains explicitly mpute angles techniques suffice compare angles implemented properly jarvis march running time nh vertices vertex minimum polar angle comparison polar angles takes time techniques compute minimum values time comparison takes time jarvis march takes nh time exercises prove procedure graham scan points vertices exercise model computation suppor addition comparison multiplication lower bound lg sort numbers prove lg lower bound computing order rtices convex hull set points model exercise set points prove pair points farthest vertices exercise polygon point boundary shadow set points segment boundary interior polygon star shaped exists point interior shadow point boundary set points called kernel figure vertex star shaped polygon vertices counterclockwise order compute time figure definition star shaped polygon exercise star shaped polygon segment point point boundary intersects boundary star shaped polygon shaded region left shadow shaded region shadow regions disjoint kernel exercise convex hull problem set points point time receiving point compute convex hull points graham scan point total running time lg solve convex hull problem total time exercise implement incremental method computing convex hull points runs lg time finding closest pair points problem findi closest pair points set points closest refers usual euclidea distance distance points y1 points set coincident case distance problem applications traffic control systems controlling air sea traffic closest vehicles order detect potential collisions brute force closest pair algorithm simply pairs points divide conquer algorithm problem running time familiar recurrence algorithm lg time divide conquer algorithm recursive invocation algorithm takes input subset arrays points input subset points array sorted coordinates monotonically increasing array sorted monotonically increasing coordinate note order attain lg time bound afford sort recursive recurrence running time lg solution lg2 version master method exercise ter presorting maintain sorted property withou sorting recursive recursive invocation inputs checks invocation simply performs brute force method pairs points return osest pair recursive invocation carries divide conquer paradigm divide finds vertical bisects point set sets points left points array divided arrays xr points sorted monotonically increasing coordinate array divided arrays points sorted monotonically increasing coordinate conquer divided recursive calls closest pair points closest pair points inputs subset arrays receives inputs xr closest pair distances returned min combine closest pair eith pair distance recursive calls pa points point algorithm determines pair distance observe pair points distance points pair units figure reside wide vertical strip centered pair exists algorithm figure key concepts proof closest pair algorithm check points point array units reside rectangle centered points pairwise units reside square left points points points rectangle points pairs coincident points point creates array array points wide vertical strip removed array sorted coordinate point array algorithm points units shortly points follow considered algorithm computes distance points track osest pair distance pairs points vertical strip closer pair recursive calls pair distance returned closest pair distance recursive calls returned description omits implementation details achieve lg running time proving correctness algorithm implement algorithm achieve desired time bound correctness correctness closest pair algorithm obvious aspects bottoming recursion ensure solve subproblem consisting point aspect check points point array prove property suppose level recu rsion closest pair points distance strictly point left units units units vertically figure rectangle centered points rectangle points reside rectangle square forming left half rectangle points units points reside square figure points reside square forming half rectangle points reside rectangle note points points limit achieved pairs coincident points pair consists point point pair intersection rectangle pair intersects rectangle points reside recta ngle easy check points point array assuming closest pair assume loss generality precedes array occurs early occurs late positions correctness closest pair algorithm implementation running time goal recurrence running time running time set points main difficulty ensuring arrays xr passed recursive calls sorted proper coordinate array sorted coordinate note array received recursive alread sorted division set easily accomplished linear time key observation form sorted subset sorted array invocation subset array sorted coordinate partitioned form arrays sorted coordinate arrays formed linear time method viewed opposite merge procedure merge sort splitting sorted array sorted arrays pseudocode idea length length length length length length length length length simply examine points array order point append array append array pseudocode works forming arrays xr remaining question ints sorted place simply presorting sort recursive sorted arrays passed ecursive whittled recursive calls necessa presorting adds additional lg running time step ecursion takes linear time exclusive recursive calls running time recursive step running time entire algorithm lg lg lg exercises professor smothers scheme closest pair algorithm check points point array idea place points set pairs coincident points point points reside rectangle flaw professor scheme exercise increasing asymptotic running time algorithm ensure set points passed recursive coincident points prove suffices check points arra positions point array exercise distance points defined ways euclidean plane lm distance points expression y1 euclidean distance distance modify closest pair algorithm l1 distance manhattan distance exercise points plane lý distance max y1 modify closest pair algorithm distance exercise change closest pair algorithm avoids presorting array leaves running time lg hint merge sorted arrays form sorted array problems convex layers set points plane define convex layers inductively convex layer consists points vertices define qi consist points points convex layers removed ith convex layer qi qi ø undefined time algorithm onvex layers set points prove lg time required compute convex layers set points model computation requires lg time sort real numbers problems maximal layers set points plane point dominates point point dominated points maximal note maximal points organized maximal layers maximal layer l1 set maximal points ith maximal layer li set maximal points suppose nonempty maximal layers yi coordinate leftmost point li assume points coordinate y1 yk point point distinct coordinate point minimum yk case maximal layers maximal layers maximal layers includes leftmost point maximal layers addition nonempty maximal layer lk lg time algorithm compute maximal layers set points hint sweep left difficulties llow input points coordinate resolve problems problems ghostbusters ghosts group ghostbusters battling ghosts ghostbuster armed proton pack shoots stream ghost eradicating stream straight terminates hits ghost ghostbusters decide strategy pair ghosts forming ghostbuster ghost pairs simultaneously ghostbuster shoot stream chosen ghost dangerous streams cross ghostbusters choose pairings streams cross assume position ghostbuster ghost fixed point plane positions collinear argue exists passing ghostbuster ghost number ghostbusters equals number ghosts lg time lg time algorithm pair ghostbusters ghosts streams cross problems picking sticks professor charon set sticks lying configuration stick endpoints endpoint ordered triple coordinates stick vertical wishes pick sticks time subject condition pick stick stick procedure takes sticks reports unrelated efficient algorithm determin pick sticks legal sequence stick pickups problems sparse hulled distributions problem computing convex set points plane drawn random stribution number points size convex hull points drawn distribution expectation n1 constant distribution sparse hulled sparse hulled distributions include points drawn uniformly unit radius disk convex hull n1 expected size points drawn uniformly interior convex polygon sides constant convex hull lg expected size points drawn dimensiona normal distribution convex hull expected size convex polygons n1 vertices compute convex hull n1 points n1 time polygons overlap convex hull set points drawn independently sparse hulled distribution computed expected time hint recursively convex hulls points points combine chapter notes chapter barely scratches surface computational geometry algorithms techniques books computational geometry include preparata shamos edelsbrunner rourke geometry studied tiquity development algorithms geometric problems preparata shamos note earliest notion complexity problem lemoine studying euclidean constructions compass ruler devised set primitives placing leg compass point acing leg compass drawing circle passing ruler edge point drawing lemoine interested number primitives needed construction called simplicity construction algorithm determines segments intersect shamos hoey original version graham scan graham package wrapping algorithm jarvis decision tree model computation yao proved lower bound lg running time convex hull algorithm number vertices convex hull account prune search algorithm kirkpatrick seidel takes lg time asymptotically optimal lg time divide conquer gorithm finding closest pair points shamos appears preparata shamos preparata shamos algorithm asymptotically optimal decision tree model chapter np completeness overview algorithms studied polynomial time algorithms inputs size worst case running time nk constant natural problems solved polynomial time answer problems turing famous halting problem solved computer matter time provided ere problems solved time nk constant generally problems solvable polynomial time algorithms ing tractable easy problems require superpolynomial time intractable hard subject chapter interesting class problems called np complete problems status unknown polynomial time algorithm discovered np complete problem prove polynomial time algorithm exist called np question deepest perplexing open problems theoretical computer science posed tantalizing aspect np compl ete problems surface problems ha polynomial time algorithms pairs problems solvable polynomial time np complete difference problems appears slight shortest longest simple paths chapter negative edge weights shortest paths single source directed graph time finding longest simple path vertices np complete fact np complete edge weights euler tour hamiltonian cycle euler tour connected directed graph cycle traverses edge visit vertex problem determine graph euler tour time fact edges euler tour time hamiltonian cycle directed graph simple cycle vertex determining directed graph hamiltonian cycle np complete chapte prove determining undirected graph hamiltonian cycle np complete cnf satisfiability cnf satisfiability boolean formula variables values boolean connectives parentheses boolean formula satisfiable assignment values variables evaluate define terms formally chapte informally boolean formula conjunctive normal form cnf auses ors variables negations boolean formula cnf satisfying assignment polynomial time algorithm determine cnf formula satisfiable chapter determining cnf formula satisfiable np complete np completeness classes np chapter refer classes problems np npc class np complete problems informally define formally class consists problems solvable polynomial time problems solved time nk constant size input problem problems examined previous chapters class np consists problems verifiable polynomial time certificate solution verify certificate correct time polynomia size input problem hamiltonian cycle problem directed graph certificate sequence v1 v2 v3 vertices easy check polynomial time vi vi v1 cnf satisfiability certific ate assignment values variables easily check polynomial time assignment satisfies boolean formula problem np problem solve polynomial time certificate ill formalize notion chapter np open question proper subset np informally problem cla npc refer np complete np hard problem np formally define hard problem np chapte state proof np complete problem solved polynomial time np complete problem polynomial time algorithm theo retical computer scie ntists np complete problems intractable nce wide range np complete problems studied ithout discovered polynomial time solution ast ounding solved polynomial time effort devoted proving np complete problems intractable conclusive outcome rule possibility np complete problems fact solvable polynomial time good algorithm designer understand rudiments theory np completeness establish oblem np complete provide good evidence intractability engineer spending time developing approximation algorithm chapter solving tractable ecial case searching fast algorithm solves problem natural interesting problems surface harder sorting graph searching network flow fact np complete familiar remarkable class problems overview showing problems np complete techniques problem np complete differ techniques book design analyze algorithms fundamental reason difference howing problem np complete making statement hard east hard easy prove existence efficient algorithm efficient algorithm exist np completeness oofs proof lg time lower bound comparison sort algorithm specific techniques showing np completeness differ decision tree method rely key concepts showing problem np complete decision problems optimization problems problems optimization problems feasible legal solution feasible solution problem shor test path undirected graph vertices path fewest edges shortest path single pair shortest path problem unweighted undirected graph np completeness applies dire ctly optimization problems decision problems answer simply formally showing problem np complet confines realm decision problems convenient relationshi optimization problems decision problems cast optimiza tion problem decision problem imposing bound optimize shortest path decision problem path directed graph vertices integer path exists consisting edges relationship optimization problem decision problem works favor optimi zation problem hard decision problem sense easier harder specific solve path solving shortest path comparing number edges shortest path decision problem parameter optimization problem easy decision oblem easy stated relevance np completeness provide evidence decision problem hard provide evidence optimization problem hard restricts attention decision problems theory np completeness implications optimization problems reductions notion showing problem harder easier applies problems decision problems advantage idea np completeness proof decision problem solve polynomial time input problem instance problem path instance graph vertices integer suppose decision problem solve polynomial time finally suppose procedure transforms instance instance characteristics transformation takes polynomial time answers answer answer procedure polynomial time reduction algorithm figure solve problem polynomial time instance problem polynomial time reduction algorithm transform instance problem polynomial time decision algorithm instance answer answer figure polynomial time reducti algorithm solve decision problem polynomial time polynomial time decision algorithm problem polynomial time transform instance instance solve polynomial time answer answer long steps takes polynomia time decide polynomial time word reducing solving problem solving problem easiness prove easiness recalling np completeness showing hard problem easy polynomial time reductions pposite problem np complete idea step furthe polynomial time reductions polynomial time gorithm exist problem suppose decision problem polynomial time algorithm exist concern ourselv problem suppose polynomia time reduction transf orming instances instances simple proof contradiction polynomial time algorithm exist suppose suppose polynomial time algorithm method figure solve problem polynomial time contradicts assumption polynomial time algorithm np completeness assume absolutely polynomial time algorithm problem proof methodology prove problem np complete assumption problem np complete np complete problem technique reduction relies ha ving problem np complete order prove problem np complete np complete problem problem circui satisfiability problem boolean combinational circuit composed gates set boolean inputs circuit output prove problem np complete chapter outline chapter studies aspects np completene bear directly analysis algorithms formalize notion oblem define complexity class polynomial time solvable decision prob lems notions fit framework formal language theory defines class np decision problems solutions verified lynomial time formally poses np question relationships problems studied polynomial time reductions defines np completeness sketches proof problem called circuit satisfiability np complete np complete problem problems proven np complete simply methodology reductions methodology illustrated showing formula satisfiability problems np complete vari ety problems np complete polynomial time study np completeness rmalizing notion polynomial time solvable problems problems generally regarded tractable philosophical mathematical reasons offer supporting arguments reasonable gard problem requires time n100 intractable practical problems require time order high degree polynomial polynomial time computable oblems encountered practice typically require time experience polynomial time algorithm problem discovered efficient algorithms follow current algorithm problem running time n100 algorithm running time discovered reasonable models comput ation problem solved polynomial time model solved polynomial time class problems solvable polynomial time serial random access machine book class problems solvable polynomial time abstract turing machines class problems solvable polynomial time parallel computer number processo grows polynomially input size class polynomial time solvable problems nice closure properties polynomials closed addition multipli cation composition output polynomial time algorithm fed input composite algorithm polynomial polynom ial time algorithm constant number calls polynomial time subroutines running time composite algorithm polynomial abstract problems understand class polynomi time solvable problems formal notion problem define abstract problem binary relation set problem instances set problem solutions instance shortest path triple consisting graph vertices solution sequence vertices graph sequence denoting path exists problem shortest path relation associates instance graph vertices shortest path graph connects vertices shortest paths unique problem instance solution formulation abstract problem general required purposes theory np completeness restricts attention decision problems solution case view abstract decision problem function maps instance set solution set decision problem shortest path problem path earlier instance decision problem path path shortest path edges path abstract problems decision problems optimization problems minimized maximized simple matter recast optimization problem decision problem harder encodings computer program lve abstract problem problem instances represented program understands encoding set abstract objects mapping set binary strings familiar encoding natural numbers strings encoding looked computer representations keyboard characters familiar asc ebcdic codes ascii code encoding compound object encoded binary string combining representations constituen parts polygons graphs functions ordered pairs programs coded binary strings computer algorithm solves abstract decision problem takes encoding problem instance input problem instance set set binary strings concrete problem algorithm solves concrete problem time provided problem instance length algorithm produce solution time concrete problem polynomial time solvable exists algorithm solve time nk constant formally define complexity class set concrete decision problems polynomial time solvable encodings map abstract problem concrete problems abstract decision problem mapping instance set encoding induce concrete decision problem denote solution abstract problem instance solution concrete problem instance technicality binary strings represent meani ngful abstract problem instance convenience assume string mapped arbitrar ily concrete problem produces solutions abstract problem binary string instances represent encodings abstract problem instances extend definition pol ynomial time solvability concrete problems abstract problems encodings idge definition independent encoding efficiency solving problem depend problem encoded unfo rtunately depends heavily encoding suppose integer provided sole input algorithm suppose running time algorithm integer provided unary string running time algorithm length inputs polynomial time natural binary representation integer input length lg case running time algorithmn exponential size input depending encoding algorithm runs ither polynomial superpolynomial time encoding abstract problem ther efore standing polynomial time talk solving abstract problem encoding practice rule expensive encodings unary actual encoding problem difference problem solved polynomial time representing integers base binary problem solvable polynomial time integer represented base converted integer represented base polynomial time function polynomial time computable exists polynomial time algorithm input produces output set problem instances encodings e1 polynomially exist polynomial time computable functions f12 f21 f12 e1 f21 e1 encoding computed encoding e1 polynomial time algorithm vice versa encodings e1 abstract problem polynomially rela ted problem polynomial time solvable independent encoding lemma lemma abstract decision problem instance set e1 polynomially encodings e1 proof prove forward direction backward direction symmetric suppose e1 solved time nk constant suppose problem instance encoding e1 computed encoding time constant solve problem input compute e1 algorithm e1 e1 long conversion encodings takes time e1 output serial computer longe running time solving problem e1 takes time e1 nck polynomial constants abstract problem inst ances encoded binary base affect complexity polynomial time solvable instances encoded unary complexity change order converse encoding independent fashion generall assume problem instances encoded reasonable concise fashion precise assume encoding inte ger polynomially binary representation encoding finite set polynomially rela ted encoding list elements enclosed braces separated commas ascii encoding scheme standard encoding hand derive reasonable encodings mathematical objects tuples aphs formulas denote standard encoding object enclose object angle braces denotes standard encoding graph long implicitly encoding polynomially standard encoding talk directly abstract problems reference encoding knowing choice encoding abstract problem polynomial time solvable henceforth generally assume problem instances binary strings encoded standard encoding explicitly contrary typically neglect distinction abstract concrete problems reader watch problem practice standard encoding obvious encoding difference formal language framework convenient aspects focusing decision problems easy machinery formal language theory worthwhile point review definitions theory alphabet finite set symbols language set strings symbols set language binary representations prime numbers denote string language ø language strings denoted set binary strings language subset variety operations languages set theoretic operations union intersection follow directly set theoretic definitions define complement concatenation languages l1 language x1x2 l1 closure kleene star language language l3 lk language concatenating times point view language theory set instances decision problem simply set characterized problem instances produce answer view language decision problem path language path undirected graph integer exists path consisting edges convenient path case refer decision problem language formal language framework express relation decision problems algorithms solve conc isely algorithm accepts string input algorithm output language accepted algorithm set strings set strings algorithm accepts algorithm rejects string language accepted algorithm algorithm reject string provided input algorithm loop forever language decided algorithm binary string accepted binary string rejected language accepted polynomial time algorithm accepted addition constant length string algorithm accepts time nk language decided polynomial time algorithm constant length string algorithm correctly decides time nk accept language algorithm worry strings decide language correctly accept reject string language path accepted polynomial time polynomial time accepting algorithm verifies encodes undirected graph verifies vertices breadth search compute shortest path compares number edges shortest path encodes undirected graph path edges algorithm outputs halts algorithm runs forever algorithm decide path explicitly output instances shortest path edges decision algorithm pa explicitly reject nary strings belong path decision problem path decision algorithm easy design running forever path edges outputs halts problems tu ring halting problem exists accepting algorithm decision algorithm exists informally define complexity class set languages membership determined complexity measure running time algorithm determines string belongs language actual definition complexity class technical interested eader referred seminal paper hartmanis stearns language theoretic framework provide alternat ive definition complexity class exists algorithm decides polynomial time fact class language accepted polynomial time theorem accepted polynomial time algorithm proof class languages decided polynomial time algorithms subset class languages accepted polynomial time algorithms accepted polynomial time algorithm cided polynomial time algorithm language accepted polynomial time algorithm classic simulation argument construc polynomial time algorithm decides accepts time nk constant exists constant accepts cnk steps input string algorithm simulates action time time algorithm inspects behavior accepted accepts outputting accepted rejects outputting overhead simulating increase running time polynomial factor polynomial time algorithm decides note proof theorem nonconstructive language bound running time algorithm accepts bound exists algorithm exists check bound algorithm easily exercises define optimization problem longest pat length relation associates instance undirected graph vert ices number edges longest simple path vertices defi decision problem longest path undirected graph integer exists simple path consisting edges optimization problem longest path length solv polynomial time longest path exercises formal definition problem nding longest simple cycle undirected graph decision problem language decision problem exercises formal encoding directed graphs binary strings adjacency matrix representation adjacen list representation argue representations polynomially exercises dynamic programming algorithm knapsack problem asked exercise polynomial time algorithm explain answer exercises polynomial time algorithm constant number calls polynomial time subroutines runs polynomial time polynomial number calls polynomial time subroutines result exponential time algorithm exercises class viewed set languages closed union inter concatenation complement kleene star l1 l1 hopcroft ullman lewis papadimitriou treatment turing machine model codomain binary strings set strings finite alphabet symbols assume algorithm output separate input takes time step produce bit output time steps size output shortly denotes set strings composed symbols set technically require functions f12 f21 map noninstances noninstances noninstance encoding string instance require f12 noninstance encoding e1 noninstance f21 noninstance noninstance e1 polynomial time verification algorithms verify membership languages suppose instance decision problem path path easily check length view certificate instance belongs path decision problem path certificate buy afte path belongs fact path solved linear time verifying member ship certificate takes long solving problem scratch examine problem polynomial time decision algorithm ven certificate verification easy hamiltonian cycles problem finding hamiltonian cycle undirected graph studied years formally hamiltonian cycle undirected graph simple cycle vertex graph ham iltonian cycle hamiltonian nonhamiltonian bondy murty cite letter hamilton describing mathematical game dodecahedron figure player sticks pins consecutive vertices player complete path form cycle rtices dodecahedron hamiltonian figure hamiltonian cycle gra phs hamiltonian figure bipartite graph odd number vertices exercise asks graphs nonhamiltonian figure graph representing vertices edge faces dodecahedron hamiltonian cycle shaded edges bipartite graph odd number vertices graph nonhamiltonian define hamiltonian cycle problem graph hamiltonian cycle formal language ham cycle hamiltonian graph algorithm decide language ham cycle problem instance decision algorithm lists permutations vertices checks permutation hamiltonian path running time algorithm reasonable encoding graph adjacenc matrix number vertices graph length encoding permutations verti ces running time nk constant naive algorithm polynomial time fact hamilt onian cycle problem np complete prove verification algorithms easier problem suppose friend tells graph hamiltonian offers prove vertices order hamiltonian cycle certa inly easy verify proof simply verify provided cycle hamiltoni checking rmutation vertices consecutive edges cycle exists graph verification algorithm implemented time length encoding proof hamiltonian cycl exists graph verified polynomial time define verification algorithm argument algorithm argument ordinary input string binary string called certificate argument algorithm verifies input string exists certificate language verified verification algorithm exists intuitively algorithm verifies language string certificate prove string certificate proving hamiltonian cycle problem certificate list vertices hamiltonian cycl graph hamiltonian hamiltonian cycle offers verify fact conversel graph hamiltonian list vertices fool verification algorithm believing graph hamiltonian verificati algorithm carefully checks proposed cycle complexity class np complexity class np class languages verified polynomial time algorithm precisely language belongs np exist input polynomial time algorithm constant exists certificate algorithm verifies language polynomial time earlier discussion hamiltonian cycle problem ham cycle np nice set nonempty np polynomial time algorithm decide algorithm easily converted argument verification algor ithm simply ignores certificate accepts input strings determines np unknown np ers np class intuitively class onsists problems solved class np consists problems solution verified learned experience difficult solve problem scratch verify presented solution working time constraints theoretical computer scientists generally analogy extends classes np np includes languages compelling evidence np existence languages np complete study class fundamental questions np question remain unresolved work researchers class np closed complement np imply define complexity class np set languages question np closed complement rephrased np np closed complement exercise np np np np language np np figure scenarios figure possibilities relationships complexity classes diagram region enclosing proper subset relation np np researchers regard possibility np closed complement np np case np np np np closed complement np np np np researchers regard possibility understanding precise relationship np woefully incomplete exploring theory np completeness disadvantage proving problems intractab practical point view great suppose exercises language graph isomorphism g1 g2 g1 g2 isomorphic graphs prove graph isomorphism np describing polynomial time algorithm verify language exercises prove undirected bipartite graph odd number vertices nonhamiltonian exercises ham cycle proble listing vertices hamiltonian cycle order polynomial time solvable exercises prove class np languages closed union intersection concatenation kleene star discuss closure np complement exercises language np decided algorithm running time constant exercises hamiltonian path graph simple path visits vertex language ham path hamiltonian path graph belongs np exercises hamiltonian path problem solved polynomial time directed acyclic graphs efficient algorithm problem exercises boolean formula constructed boolean input variables negations parentheses formula tautology evaluates assignment input variables define tautology language boolean formulas ta utologies tautology np exercises prove np exercises prove np np np exercises connected undirected graph vertices g3 graph connecting pairs vertices connected path length prove g3 hamiltonian hint construct spanning tree inductive argument np stands nondeterministic pol ynomial time class np originally studied context nondeterminism book simpler equivalent notion verification hopcroft ullman good presentation np completeness terms nondeterministic models computation np completeness reducibility compelling reason theore tical computer scientists np existence class np complete oblems class surprising property np complete problem solved polynomial time problem np polynomial time solution np years study polynomial time algorithm scovered np complete problem language ham cycle np complete problem decide ham cycle polynomial time solve oblem np polynomial time fact np turn nonempty ould certainty ham cycle np np complete languages sense hardest languages np compare relative hardne languages precise notion called polynomial time reducibility formally define np complete languages finish sketching proof language called circuit sat np complete sections notion reducibility problems np complete reducibility intuitively problem reduced problem instance easily rephrased instance solution solution instance problem solving linear equations indeterminate reduces problem solving qua dratic equations instance transform solution solution problem reduces problem sense harder solve returning formal language framework decision proble language l1 polynomial time reducible language written l1 exists polynomial time computable function function reduction function polynomial time algorithm computes called reduction algorithm figure illustrates idea polynomial time reduction language l1 language language subset reduction function polynomial time mapping l1 l1 reduction function maps instance decision problem represented language l1 instance problem represented providing answer directly answer l1 figure illustration polynomial time reduction language l1 language reduction function input question l1 answer question polynomial time reductions powerful tool proving languages belong lemma l1 languages l1 implies l1 proof polynomial time algorithm decides polynomial time reduction algorithm computes reduction function construct polynomial time algorithm decides l1 figure illustrates construction input algorithm transform test output provided output figure proof lemma algorithm reduction algorithm computes reduction function l1 polynomial time polynomial time algorithm decides illustrated algorithm decides l1 transform input decide correctness condition algorithm runs polynomial time polynomial time exercise np completeness polynomial time reductions provide formal showing problem hard polynomial time factor l1 l1 polynomial factor harder equal notation reduction mnemonic define set np complete languages hardest problems np language np complete np np language satisfies property property np hard define npc class np complete languages theorem np completeness crux deciding fact equal np theorem np complete problem polynomial time solvable np equivalently problem np polynomial time solvable np complete problem polynomial time solvable proof suppose npc np property definition np completeness lemma proves statement theorem prove statement note contrapositive statement reason np question centers np complete problems theoretical comput scientists np leads relationships np npc figure polynomial time algorithm np complete problem proving np polynomia time algorithm np complete problem discovered proof problem np compl ete excellent evidence intractability figure theoretica computer scientists view relationships np npc npc wholly contained np npc ø circuit satisfiability defined notion np complete problem point proved problem np complete prove problem np complete polynomial time reducibil ity tool prove np completeness problems focus demo nstrating existence np complete problem circuit satisfiability problem formal proof circui satisfiability problem np complete requires technical scope text informally proof relies basic understanding boolean combinational circuits boolean combinational circuits built boolean combinational elements interconnected wires boolean combinational element circuit element constant number boolean inputs outputs performs defined function boolean values drawn set represents false represents true boolean combinational elements circuit satisfiability problem compute simple boolean function logic gates figure basic logic gates circuit satisfiability problem gate inverter gate gate gate takes single binary input produces binary output opposite input gates takes binary inputs produces single binary output figure basic logic gates binary inputs outputs gate truth table describes gate operation gate gate gate operation gate boolean combinational element truth table gate figure truth table outputs combinational element setting inputs truth table gate tells inputs output symbols denote function denote function denote function generalize gates inputs gate output inputs output gate output inputs output boolean combinational circuit consists bo olean combinational elements interconnected wires wire connect output element input providing output element input figure boolean combinational circuits differ gate figure values individual wires input single wire combinational element output connected feed element nputs number element inputs fed wire called fan wire element output connected wire wire circuit input accepting input values external source element input connected wire wire circuit output providing circuit computation internal wire fan circuit output purpose defining circuit satisfiability problem limit number circuit outputs actual hardware design boolean combin ational circuit multiple outputs figure instances circuit satisfiability problem assignment inputs circuit output circuit circuit satisfiable assignment inputs circuit output circuit circuit unsatisfiable boolean combinational circuits cycles suppose create directed graph vertex combinational element directed edges wire fan directed edge wire connects output element input element acyclic truth assignment boolean combinational circuit set boolean input values output boolean combinational circuit satisfiable satisfying assignment truth assignment caus output circuit circuit figure satisfying assignment satisfiable exercise asks assignment values circuit figure produce output produces unsatisfiable circuit satisfiability problem boolean combin ational circuit composed gates satisfiable order pose question formally agree standard encoding circuits size boolean combinational circuit number boolean combinational elements number wires circuit devise graphlike encoding maps circuit binary string length polynomial size circuit formal language define circuit sat satisfiable boolean combinational circuit circuit satisfiability problem arises area comput aided hardware optimization subcircuit produces subcircuit replaced simpler subcircuit omits logic gates constant output helpful polynomial time algorithm problem circuit attempt determine satisfiable simply checking assignments nputs inputs assignments size polynomial checking takesk time superpolynomial size circuit fact claimed strong evidence polynomial time algorithm exis solves circuit satisfiability problem circuit satisfiabil ity np complete break proof fact parts based parts definition np completeness lemma circuit satisfiability problem belongs class np proof provide nput polynomial time algorithm verify circuit sat inputs standard encoding boolean combinational circuit input certificate assignment boolean values wires exercise smaller certificate algorithm constructed logic gate circuit checks provided certificate output wire correctly computed function values input wires output entire circuit algorithm outputs values assigned inputs provide satisfying assignment outputs satisfiable circuit input algorithm certificate length polynomial size output unsatisfiable circuit input certificate fool believing circuit satisfiable algorithm runs polynomial time good implementation linear time suffices circuit sat verified polynomial time circuit sat np proving circuit sat np complete language np hard language np polynomial time reducible circuit sat actual proof fact technical intricacies settle sketch proof based understanding workings computer hardware computer program stored computer memory sequence instructions typical instruction encodes operation performed addresses operands memory address result stored special memory location called program counter track instruction executed program counter automatically incremented instruction fetched causing computer execute instructions sequentiall execution instruction written program counter normal sequential execution altered allowing computer loop perform conditional branches point execution program entire state computation represented computer memory memory include program program counter working storage bits state computer maintains bookkeeping state computer memory configuration execution instruction viewed mapping configuration importantly computer hard ware accomplishes mapping implemented boolean combinational circuit denote proof lemma lemma circuit satisfiability problem np hard proof language np polynomial time algorithm computing reduction function maps binary string circuit circuit sat np exist algorithm verifies polynomial time algorithm construct input algorithm compute reduction function denote worst case running time algorithm length input strings constant nk length certificate nk running time polynomial total input size includes input string certificate length certificate polynomial length input string running time polynomial basic idea proof represent computation sequence configurations figure configuration broken parts consisting program program counter auxili ary machine state input certificate working storage starting initial configuration c0 configuration mapped subsequent configuration combinational circuit implementing computer hardwa output algorithm written designated location working storage finishes executing assume halts algorithm runs steps output appears bits figure sequence configurations produced algorithm running input certificate configuration represents state computer step computation includes program counter auxiliary machine state working storage certificate initial configuration c0 constant configuration mapped onfiguration boolean combinational circuit output distinguished bit working storage reduction algorithm constructs single combinational circuit computes configurations produced initial configuration idea paste copies circuit output ith circuit produces configuration fed directly input circuit configurations state register simply reside lues wires connecting copies recall polynomial time reduction algorithm input compute circuit satisfiable exists certificate obtains input computes constructs combinational circuit consisting copies input initial configuration computation output configuration circuit computes modifying inputs program initial program counter input initial state memory wired direct ly values remaining inputs circuit correspond certificate outputs circuit bit output circuit constructed computes input length nk reduction algorithm provided input string computes circuit outputs properties remain proved correctly computes reduction function satisfiable exists certificate runs polynomial time correctly computes reduction functi suppose exists certificate length nk apply bits inputs output certificate exists satisfiable direction suppose satisfiable exists input conclude correctly computes reduction function complete proof sketch runs time polynomial observation number bits required represent configuration polynomial program constant size independent length input length input length certificate nk algorithm runs nk steps working storage required polynomial assume memory contiguous exercise asks extend argument situa tion locations accessed scattered larger region memory pattern scattering differ input combinational circuit implementing computer hard ware size polynomial length configuration polynomial nk polynomial circuitry implements logic memory circuit consists nk copies size polynomial construction accomplished polynomial time reduction algorithm step construction takes polynomial time language circuit sat hard language np belongs np np complete theorem circuit satisfiability problem np complete proof lemmas definition np completeness exercises verify circuit figure unsatisfiable exercises relation transitive relation languages l1 l3 l1 l3 exercises prove exercises satisfying assignment certificate alternative proof lemma certificate easier proof exercises proof lemma assumes working storage algorithm occupies contiguous region polynomial ze proof assumption exploited argue assumption involve loss generality exercises language complete language class respect polynomial time reductions ø languages complete respect polynomial time reductions exercises complete np complete np exercises reduction algorithm proof lemma constructs circuit based knowledge professor sartre observes string input existence constant factor implicit nk running time language belongs np actual values professor concludes construct circuit language circuit sat np hard explain flaw professor reasoning hand size circuitk algorithm running timek running time polynomia circuit size np situation contradict fact problem np complete existence polynomial time algorithm special case impl polynomial time algorithm cases np completeness proofs np completeness circuit satisfiabi lity problem relies direct proof circuit sat language np prove languages np complete ithout directly reducing language np language illustrate methodology proving formula satisfiability problems np complete examples methodology lemma basis method showing language np complete lemma language npc np hard np npc proof np complete np lp supposition transitivity exercise np hard np npc reducing np complete language implicitly reduce language np lemma method proving language np complete prove np select np complete language algorithm computes function mapping instance instance prove function satisfies prove algorithm computing runs polynomial time steps np hard methodology reducing single np complete language simpler complicated process showing directly reduce language np proving circuit sat npc foot door knowing circ uit satisfiability problem np complete prove easily problems np complete develop catalog np complete problems choices languages reduce formula satisfiability illustrate reduction methodology np completeness proof problem determining boolean formula rcuit satisfiable problem historical honor problem np complete formulate formula satisfiability problem terms language sat instance sat boolean formula composed boolean variables boolean connectives boolean function inputs output implication parentheses loss generality assume redundant parentheses pa parentheses boolean connective easy encode boolean formula length polynomial boolean combinational circuits truth assignment boolean formula set values variables satisfying assignment truth assignment evaluate formula satisfying assignment satisfiable formula satisfiability problem asks boolean formula satisfiable formal language terms sat satisfiable boolean formula formula x4 satisfying assignment x4 formula belongs sat naive algorithm determine arbi trary boolean formula satisfiable polynomial time assignments formula variables length polynomial checking assignment requiresn time superpolynomial length theorem polynomial time algorithm exist theorem satisfiability boolean formulas np complete proof start arguing sat np prove circuit sat np hard showing circuit sat sat lemma prove theorem sat belongs np certificate consisting satisfying assignment input formula verified polynomia time verifying algorithm simply replaces variable formula evaluates expression equation task easily polynomial time expression evaluates formula satisfiable condition lemma np completeness holds prove sat np hard circuit sat sat instance circuit satisfiability reduced polynomia time instance formula satisfiability induction express boolean combinational circuit boolean formula simply gate oduces circuit output inductively express gate inputs formulas formul circuit writing expression applies gate function inputs formulas straightforward method constitute polynomial time reduction exercise asks shared subformu las gates output wires fan size generated formula grow exponentially reduction algorithm clever figure illustrates basic idea redu ction circuit sat sat circuit figure wire circuit formula variable proper operation gate expressed formula involving variables incident wires operation output gate x10 x7 x8 x9 figure reducing circuit satisfiability formula satisfiability formula produced reduction algorithm variable wire circuit formula produced reduction algorithm circuit output variable conjunction clauses describing operation gate circuit figure formula x10 x4 x5 x6 x4 x7 x4 x8 x5 x6 x9 x6 x7 x10 x7 x8 x9 circuit straightforward produce formula polynomial time circuit satisfiable formula satisfiable satisfying assignment wire circuit def ined output circuit assignment wire values variables clause evaluate conjunction evaluates conversely assignment evaluate circuit satisfiable analogous argument circuit sat sat completes proof cnf satisfiability problems proved np complete reduction formula satisfiability reduction algorithm handle input formula requirement lead huge number cases considered desirable reduce restricted language boolean formulas fewer cases considered restrict langua polynomial time solvable convenient language cnf satisfiability cnf sat define cnf satisfiability terms literal boolean formula occurrence variable negation boolean formula conjunctive normal form cnf expressed clauses literals boolean formula conjunctive normal form cnf clause distinct literals boolean formula x4 x4 cnf clauses literals cnf sat asked boolean formula cnf satisfiable theorem polynomial time algorithm determine satisfiability boolean formulas exist expressed simple normal form theorem satisfiability boolean formulas conjunctive normal form np complete proof argument proof theorem sat np applies equally cnf sat np lemma sat cnf sat reduction algorithm broken ree basic steps step progressively transforms input formula closer desired conjunctive normal form step prove circuit sat sat theorem construct binary parse tree input formula literals leaves connectives internal nodes figure parse tree formula figure tree formula x4 input formula clause literals associativity parenthesize expression fully internal node tree children binary parse tree viewed circuit computing function mimicking reduction proof theorem introduce variable yi output internal node rewrite original formula root variable conjunction clauses descri bing operation node formula expression y1 y1 y3 y4 y3 y4 y5 y5 y6 x4 y6 observe formula conjunction clauses literals additional requirement clause literals step reduction converts clause conjunctive normal form construct truth table evaluating assignments variables row truth table consists assignment variable clause clause assignment ing truth table entries evaluate build formula disjunctive normal form dnf equivalent convert formula cnf formula demorgan laws equations complement literals ange convert clause cnf truth table figure dnf formula equivalent y1 y1 y1 y1 y1 y1 figure truth table clause y1 applying demorgan laws cnf formula equivalent original clause clause formula converted cnf formula equivalent cnf formula consisting conjunction clause literals final step reduction transforms rmula clause distinct literals final cnf formula constructed clauses cnf formula auxiliary variables clause include clauses distinct literals simply include clause distinct literals l1 l1 literals include l1 l1 clauses literals fulfill syntactic requirement distinct literals clause l1 l1 equivalent l1 distinct literal include clauses note setting conjunction clauses evaluate cnf formula satisfiable satisfiable inspecting steps reduction circuit sat sat construction step preserves satisf iability step produces cnf formula algebraically equivalent step produces cnf formula effectively equivalent assignment variables produces formula algebraically equivalent reduction computed polynomial time constructing introduces variable clause connective constructing introduce clauses clause clause variables truth table clause rows construction introduces clauses clause size formula polynomial length original formula constructions easily accomplished polynomial time exercises straightforward nonpolynomial time reduction proof theorem circuit size converted formul method yields formula size exponential exercises cnf formula resu lts method theorem formula exercises professor jagger proposes sat cnf sat truth table technique proof theorem steps professor proposes boolean formula form truth table variables derive truth table formula dnf equivalent negate apply demorgan laws produce cnf formula equivalent strategy yield polynomial time reduction exercises problem determining boolean formula tautology complete np hint exercise exercises problem determining tisfiability boolean formulas disjunctive normal form polynomial time solvable exercises suppose polynomial time algorithm decide formula satisfiability algorithm satisfying assignments polynomial time exercises cnf sat set satisfiable boolean formulas cnf literals clause cnf sat algorithm effici ent hint observe equivalent reduce cnf sat problem directed graph efficiently solvable np complete problems np complete problems diverse domains boolean logic graphs arithmetic network design sets partitions storage retrieval sequencing scheduling mathematical programming algebra number theory game puzzles automata language theory program optimization biology chemistry physics reduction methodology provide np completene proofs variety problems drawn graph theory set partitioning figure outlines structure np completeness proofs language figure proved np complete reduction language points root circuit sat proved np complete theorem figure structure np completeness proofs sections proofs ultimately follow reduction np completeness circuit sat clique problem clique undirected graph subset vertices pair connected edge clique complete subgraph size clique number vertices clique problem optimization problem finding clique maximum size graph decision problem simply clique size exists graph formal definition clique graph clique size naive algorithm determining graph vertices clique size list subsets check forms clique running time algorithm polynomial constant general case algorithm uns superpolynomial time suspect efficient algorithm clique problem exist theorem clique problem np complete proof clique np graph set vertices clique certificate checking clique accomplished polynomial time checking pair edge belongs prove cnf sat clique clique problem np hard prove sult surpri sing surface logical formulas graphs reduction algorithm instance cnf sat ck boolean formula cnf clauses clause distinct literals construct graph satisfiable clique size graph constructed clause place triple vertices edge vertices hold triples literals consistent negation graph easily computed polynomial time construction graph figure figure graph derived cnf formula reducing cnf sat clique satisfying assignment formula assignment satisfies satisfies clique lightly shaded vertices transformation reduction suppose satisfying assignment clause literal assigned literal corr esponds vertex picking true literal clause yields set vertices claim clique vertices literals mapped satisfying assignment literals compleme nts construction edge belongs conversely suppose clique size edges connect vertices triple vertex trip assign literal fear assigning literal complement edges inconsistent literals clause satisfied satisfied variables correspond vertex clique set arbitrarily figure satisfying assignment clique size consists vertices clause clause clause clique vertices set satisfying assignment observe proof theorem reduced arbitrary instance cnf sat instance clique structure clique np hard graphs vertices restricted occur triples edges vertices triple clique np hard restricted case proof suffices clique np hard general graphs polynomial time algorithm solved clique general graphs solve clique restricted graphs sufficient reduce instances cnf sat special structure general instances clique case instances cnf sat chose reduce easy reduced np hard problem clique observe reduction instance cnf sat solution mistake polynomial tim reduction based knowing formula satisfiable determine polynomial time vertex cover problem vertex cover undirected graph subset vertex covers incident edges vertex cover set vertices covers edges size vertex cover number vertices graph figure vertex cover size figure reducing clique vertex cover undirected graph clique graph produced reduction algorithm vertex cover vertex cover problem vertex cover minimum size graph restating optimization problem decisi problem determine graph vertex cover size language define vertex cover graph vertex cover size theorem problem np complete theorem vertex cover problem np complete proof vertex cover np suppose graph integer certificate choose vertex cover verification algorithm affirms checks edge verification performed straightforwardly polynomial time prove vertex cover problem np hard showing clique vertex cover reduction based notion complem ent graph undirected graph define complement graph edges figure graph complement illustrates reduction clique vertex cover reduction algorithm takes input instance clique problem computes complement easily polynomia time output reduction algorithm instance vertex cover problem complete proof transformation reduction graph clique size graph vertex cover size suppose clique claim vertex cover edge implies belong pair vertices connected edge equivalently edge covered chosen arbitrarily edge covered vertex set size forms vertex cover conversely suppose vertex cover contrapositive implication clique size vertex cover np complete expect polynomial time algorithm finding minimum size vertex cover presents polynomial time approximation algorithm produ ces approximate solutions vertex cover problem size vertex cover produced algorithm minimum size vertex cover hope problem np complete polynomial time approximation algorithm obtai optimal lutions finding optimal solution np complete chapter approximation algorithms np complete problems hamiltonian cycle problem return hamiltoni cycle problem defined theorem hamiltonian cycle problem np complete proof ham cycle belongs np graph certificate sequence vertices ham iltonian cycle verification algorithm checks seque nce vertex vertex repeated forms cycle checks edge pair consecutive vertices vertices verification performed polynomial time prove vertex cover ham cycle ham cycle np complete undirected graph integer construct undirected graph hamiltonian cycle vertex cover size construction based widget piece gra enforces properties figure widget edge graph construct widget denote wuv denote vertex wuv widget wuv vertices widget wuv edges figure figure widget reducing vertex cover problem hamiltonian cycle problem edge graph corresponds widget wuv graph created reduction widget individual vertices labeled shaded paths widget include vertices assuming connections widget remainder vertices internal structure widget enforce properties limiting connections widget remainder graph construct vertices edges incident wuv hamiltonian cycle traverse edges wuv ways figures cycle enters vertex exit vertex visits widget vertices figure vertices figure case cycle reenter widget visit vertices cycle enters vertex exit vertex visits widget vertices figure vertices figure paths widget visit vertices impossible construct rtex disjoint paths connects connects union paths widget vertices vertices widgets selector vertices s1 sk edges incident selector vertices select vertices cover addition edges widgets types edges figure vertex add edges join pairs widgets order form path widgets edges incident arbitrarily order vertices adjacent vertex degree degree number vertices adjacent create path widgets edges incident adding edges degree figure order vertices adjacent graph figure includes edges vertex edges path widgets edges incident figure reduction instance vertex cover problem instance hamiltonian cycle problem undirected graph vertex cover size consisting lightly shaded vertices undirected graph produced reduction hamiltonian path correspondi vertex cover shaded vertex cover corresponds edges s1 appearing hamiltonian cycle intuition edges choose vertex vertex cover construct path degree covers widgets edges incident widgets path includes vertices vertex cover vertices vertex cover final type edge joins vertex vertex degree paths select vertices include edges degree size polynomial size construct time polynomial size vertices widgets selector vertices widget ntains vertices selector vertices total vertices edges widgets widgets connecting selector vertices widgets edges widget widgets vertex degree edges widgets summed vertices edges widgets finally edges pair consisting selector vertex vertex edges total number edgesk transformation graph reduction vertex cover size hamiltonian cycle suppose vertex cover size u1 u2 figure form hamiltonian cycle including edges vertex include edges degree connect widgets edges incident include edges widgets figures depending edge covered vertices hamiltonian cycle includes edges inspecting figure reader verify thes edges form cycle cycle starts s1 visits widgets correspo nding edges incident u1 visits visits widgets edges incident u2 returns s1 widget visited depending vertices cover edge vertex cover edge incident vertex cycle visits vertex widget cycle visits selector vertex hamiltonian conversely suppose hamiltonian cycle claim set vertex cover partition maximal paths start selector vertex traverse edge selector vertex passing selector vertex path cover path constructed cover path start edge vertex pass widgets edges incident selector vertex refer cover path equation widget visited wuv wvu widget visited vertices visited cover paths visited cover path edge covered vertex cover paths visit widget cover path pv implies edge covered vertex widget visited cover path edge covered vertex traveling salesman problem traveling salesman problem closely hamiltonian cycle problem salesman visit cities modeling problem complete graph vertices salesman wishes tour hamiltonian cycle visiting city finishing city starts integer cost travel city city salesman wishes tour total cost minimum total cost sum individual cost edges tour figure minimum cost tour cost formal language decision problem tsp complete graph function traveling salesman tour cost figure instance traveling salesman problem shaded edges represent minimum cost tour cost theorem fast algorithm traveling salesman problem exist theorem traveling salesman oblem np complete proof tsp belongs np instance problem certificate sequence vertices tour verification algorithm checks sequence vertex su edge costs checks sum process polynomial time prove tsp np hard ham cycle tsp instance ham cycle construct stance tsp form complete graph define cost function note undirected loops vertices instance tsp easily formed polynomial time graph hamiltonian cycle graph tour cost suppose graph hamiltonian cycle edge belongs cost tour cost conversely suppose graph tour cost costs edges cost tour edge tour cost edges conclude hamiltonian cycle graph subset sum problem np complete problem cons ider arithmetic subset sum problem finite set target subset elements sum subset solution usual define problem language subset sum exists subset arithmetic problem recall andard encoding assumes input integers coded binary ith assumption mind subset sum problem unlik ely fast algorithm theorem subset sum problem np complete proof subset sum np instance problem subset certificat checking accomplished verification algorithm polynomial time cnf sat subset sum cnf formula variables clauses ck distinct literals reduction algorithm constructs instance subset sum problem satisfiable subset sum loss generality simplifyi assumptions formula clause variable negation clause automatically satisfied assignment values variables variable appears clause matter lue assigned variable reduction creates numbers set variable numbers clause create numbers base number digits digit corresponds variable clause base bases property preventing carries lower gits higher digits figure construct set target label digit position variable ause digits labeled clauses digits labeled variables target digit labeled vari digit labeled clause variable integers vi digit labeled vari digits literal appears clause digit labeled vi literal appears clause digit labeled digits labeled clauses vi vi values set unique vl values equal vi digits simplifying assumptions vi equal digits vi equal set clauses assume clause appears clause clause vi differ clause integers digits labeled digit digit integers slack variables whic clause labeled digit position add target simple inspection figure demonstrates values unique set figure reduction cnf sat subset sum formula cnf c4 c4 satisfying assignment set produced reduction consists base numbers reading target subset lightly shaded satisfying assignment slack variables achieve target digits labeled c4 note greatest sum gits digit position occurs digits labeled clauses vi values values interpreting numbers base carries occur lower digits higher digits reduction performed polynomial time set values digits time produce digit poly nomial target digits reduction oduces constant time cnf formula satisfiable subset sum suppose satisfying assignment assignment include vi include include vi values correspond literals satisfying assignment included vi digits labeled variables variable labeled digit sum values matches digits target clause satisfied literal clause digit labeled clause contributed sum vi fact literals clause clause labeled digit sum vi values figure literals satisfying assignment clauses c4 literals v3 contribute sum digits c4 clause literals v3 contribute sum digit clause literals v3 contribute sum digit achieve target digit labeled clause including nonempty subset slack variables figure includes matched target digits sum carries occur values sum suppose subset sums subset include vi digits labeled variables sum vi set set claim clause satisfied assignment prove claim note achieve sum digit labeled subset include vi digit labeled contributions slack variables sum includes vi position literal appears clause set vi clause satisfied includes position literal appears set clause satisfied clauses satisfied completes proof exercises subgraph isomorphism problem takes graphs g1 g2 asks g1 isomorphic subgraph g2 subgraph isomorphism problem np complete exercises integer matrix integer vector integer programming problem asks integer vector elements set prove integer programming np complete hint reduce cnf sat exercises integer linear programming problem intege programming problem exercise values vector integers assuming integer programming problem np hard integer linear programming problem np complete exercises subset sum problem solv polynomial time target expressed unary exercises set partition problem takes input set numbers question numbers partitioned sets set partition problem np complete exercises hamiltonian pat problem np complete exercises longest simple cycle problem problem determini simple cycle repeated vertices maximum length graph problem np complete exercises half cnf satisfiability problem cnf formula variables clauses determine exists truth assignment variables half clauses evaluate half clauses evaluate prove half cnf satisfiability probl np complete problems independent set independent set graph subset vertices edge incident vertex independent set problem maximum size independent set formulate decision problem independent set problem prove np complete hint reduce clique problem suppose black box subroutine solve decision problem defined algorithm independent set maximum size running time algorith polynomial queries black box counted single step independent set decision problem np complete special cases polynomial time solvable efficient algorithm solve ndependent set problem vertex degree analyze running time prove algorithm works correctly efficient algorithm solv independent set problem bipartite analyze running time prove algorithm works correctly hint problems bonnie clyde bonnie clyde robbed bank bag money divide scenarios polynomial time algorithm prove problem np complete input case list items bag coins denominations coins worth dollars worth dollars divide money evenly coins arbitrary number denominations denomination nonnegative integer power denominations dollar dollars dollars divide money evenly checks amazing incidence bonnie clyde divide checks exact money checks accept split difference larger dollars problems graph coloring coloring undirected graph function edge numbers represent colors adjacent vertices colors graph coloring problem determine minimum number colo needed color graph efficient algorithm determin coloring graph exists cast graph coloring problem ecision problem decision problem solvable polynomial time graph coloring problem solvable polynomial time language color set graphs colored color np complete decision problem np complete prove color np complete reduction cnf sat formula clauses variables construct graph set consists vertex variable vertex negation variable vertices clause special vertices true false red edges graph types literal edges independent clauses clause edges depend clauses literal edges form triangle special vertices form triangle red argue coloring graph literal edges variable negation colored true colored false argue truth assignment coloring graph literal edges widget figure enforce condition clause clause requires unique copy vertices heavily shaded figure connect literals clause special vertex true argue colored true false widget colorable colored true complete proof color np complete figure widget clause problem problems scheduling profits deadlines suppose machine set tasks task processing time profit deadline machine process task time task uninterruptedly consecutive time units complete task deadline receive profit complete deadline receive profit optimization problem processing times profits deadlines set tasks schedule completes tasks returns greatest profit state problem decision problem decision problem np complete polynomial time algorithm decision problem assuming processing times integers hint dynamic programming polyomial time algorithm optimization problem assuming processing times integers technically define cycle terms vertices edges clarity abuse notation define hamiltonian cycle terms edges fact base work instance subsection set target figure interpreted base listed sorted order chapter notes book garey johnson wonderful guide np completeness discussing theory length providing catalogue problems np complete proof theorem adapted book list np complete problem mains drawn table contents johnson wrote series columns journal algorithms reporting developments np completeness hopcroft motwani ullman lewis papadimitriou papadimitiou sipser good treatments np completeness context complexity theory aho hopcroft ullman cover np completeness seve ral reductions including reduction vertex cover problem hamiltonian cycle problem class introduced cobham independently edmonds introduced class np conjectured np notion np completeness proposed cook np completeness proofs formula satisfiability cnf satisfiability levin independently discovered notion np completeness proof tiling problem karp introduced methodology reductions demonstr ated rich variety np complete problems karp paper included original np completeness proofs clique vertex cover hamiltonian cycle problems sin hundreds problems proven np complete researchers talk meeting celebrating karp birthday papadimitriou remarked bout papers year term np complete title abstract list keywords terms compiler database expert neu ral network operating work complexity theory lig ht complexity computing approximate solutions work definition np probabilistically checkable proofs definition implies problems clique vertex cover traveling salesman problem triangle inequality computing good approximate solutions np hard easier computing timal solutions introduction area arora thesis chapter arora lund survey article arora book edited mayr promel steger survey article johnson chapter approximation algorithms problems practical significance np complete abandon obtaining optimal solution intractable problem np complete polynomial ime algorithm solving actly hope approaches np completeness actual inputs small algorithm exponential running time perfectly satisfactory isolate special cases solvable polynomial time optimal solutions polynomial time worst case average practice optimality good algorithm returns nea optimal solutions called approximation algorithm chapter presents polynomial time approximation algorithms np complete problems performance ratios approximation algorithms suppose working optimization problem potential solution positive cost optimal solution depending problem optimal solution defined maximum cost minimum cost problem eith maximization minimization problem algorithm problem approximation ratio input size cost solution produced algorithm factor cost optimal solution algorithm achieves approximation ratio approximation algorithm definitions approximation ratio approximation algorithm apply minimization maximization oblems maximization problem ratio factor cost optimal solution larger cost approximate solution minimization problem ratio factor cost approximate solution larger cost optimal solution solutions assumed positive cost ratios defined approximation tio approximation algorithm implies approximation algorithm produces optimal solution approxi mation algorithm large approximation ratio return solution worse optimal problems polynomial time approxi mation algorithms small constant approximation ratios developed problems polynomial time approximation algorithms appr oximation ratios grow functions input size problem set cover problem presented np complete problems polynomia time approximation algorithms achieve increasingly smaller approximation ratio computation time trade comput ation time quality approximation subset sum problem studied situation deserve approximation scheme optimization problem approximation algorithm takes input instance problem fixed scheme approximation algorithm approximation scheme polynomial time approximation scheme fixed scheme runs time polynomial size input instance running time polynomial time approxima tion scheme increase rapidly decreases running time polynomial time approximation scheme ideally decreases constant factor running time achieve desired approximation increase constant factor running time pol ynomial approximation scheme fully polynomial time approximation scheme approximation scheme running time polynomial size input instance scheme running timen3 scheme constant factor decr ease achieved constant factor increase running time approximation ratio independent terms approximation ratio approximation algorithm indicating dependence chapter outline sections chapter examples polynomial time approximation algorithms np complete proble presents fully polynomial time approximation scheme study vertex cover problem np complete minimization problem approximation algorithm approximation ratio presents approximation algorithm approximation ratio case aveling salesman problem cost function satisfies triangle inequality triangle inequality constant approximation algorithm exist np greedy method effective approximation algorithm set covering problem obtaining covering worst logarithmic factor larger optimal cost presents approximation algorithms study optimization version cnf satis fiability simple randomized algorithm produces solution pected approximation ratio examine weighted variant vertex cover problem linear programming develop appr oximatation algorithm finally presents fully polynomial time approximation scheme subset sum problem vertex cover problem vertex cover problem defined proven np complete vertex cover undirected graph subset edge size vertex cove number vertices vertex cover problem vertex cover minimum size undirected graph vertex cover optimal vertex cover problem optimization version np complete decision problem difficult optimal vertex cover graph hard vertex cover optimal approximation algorithm takes input undirected graph returns vertex cover size guaranteed size optimal vertex cover approx vertex cover ø ø arbitrary edge remove edge incident return figure illustrates operation appr vertex cover variable vertex cover constructed initializes set sets copy edge set graph loop lines repeatedly picks edge adds endpoints deletes edges covered running time algorithm adjacency lists represent figure operation approx vertex cover input graph vertices edges edge heavy edge chosen approx vertex cover vertices lightly shaded set vertex cover created edges dashed removed covered vertex edge chosen vertices edge chosen vertices set vertex cover produced approx vertex cover vertices optimal vertex cover oblem vertices theorem approx vertex cover polynomial time approximation algorithm proof approx vertex cover runs polynomial time set vertices returned approx vertex cover vertex cover algorithm loops edge covered vertex approx vertex cover returns vert cover size optimal cover denote set edges picked approx vertex cover order cover edges vertex cover optimal cover include endpoint edge edges share endpoint edge picked edges incident endpoints deleted edges covered vertex lower bound size optimal vertex cover execution picks edge endpoints yielding upper bound exact upper bound fact size vertex cover returned combining equations proving theorem reflect proof prove size vertex cover returned approx vertex cover size optimal vertex cover size optimal vertex cover answer utilize lower bound optimal vertex cover exercise asks set edges picked approx vertex cover maximal matching graph maximal matching matching proper subset matching size maximal matching argued proof theorem lower bound size timal vertex cover algorithm returns vertex cover size size maximal matching relating size solution returned lower bound approximation ratio methodology sections exercises graph approx vertex cover yields suboptimal solution exercises denote set edges picked approx vertex cover prove set maximal matching graph exercises professor nixon proposes heuristic solve vertex cover problem repeatedly select vertex highest degree remove incident edges professor heuristic approximation ratio hint bipartite graph vertices uniform degree left vertices varying degree exercises efficient greedy algorithm finds timal vertex cover tree linear time exercises proof theorem vertex cover problem np complete clique problem complementary sense optimal vertex cover complement maximum size clique mplement graph relationship imply polynomial time approximation gorithm constant approximation ratio clique problem justify answer traveling salesman problem traveling salesman problem introduced complete undirected graph nonnegative integer cost edge hamilt onian cycle tour minimum cost extension notation denote total cost edges subset practical situations cheapest directly place place intermediate expensive putting cutting intermediate increase cost formalize notion cost function satisfies triangle inequality vertices triangle inequality natu ral applications automatically satisfied vertices graph points plane cost traveling vertices ordinary euclidean distance triangle inequality satisfied cost functions euclidean distance satisfy triangle inequality exercise traveling salesman problem np complete require cost function satisfy triangle ineq uality polynomial time algorithm solving prob lem good approximation algorithms examine approximation algor ithm traveling salesman problem triangle inequality triangle inequality polynomial time approximation algo rithm constant approximation ratio exist np traveling salesman prob lem triangle inequality applying methodology previous compute structure minimum spanning tree weight lowe bound length optimal traveling salesman tour minimum anning tree create tour cost minimum spanni tree weight long cost function satisfies triangle inequality gorithm implements approach calling minimum spanning tree algorithm mst prim subroutine approx tsp tour select vertex root vertex compute minimum spanning tree root mst prim list vertices visited preorder tree walk return hamiltonian cycle visits vertices order recall preorder tree walk recursivel visits vertex tree listing vertex encountered children visited figure illustrates operation approx tsp figure set vertices minimum spanning tree grown root vertex mst prim vertices visited preorder walk displays tour tour returned approx tsp tour displays optimal shorter figure operation approx tsp tour set points lie vertices integer grid unit units ordinary euclidean distance cost function points minimum spanning tree points computed mst prim vertex root vertex vertices happen labeled main tree mst prim alphabetical order walk starting walk tree visits vertices order preorder walk lists vertex encountered indicat dot vertex yielding ordering tour vertices visiting vertices order preorder walk tour returned approx tsp tour total cost optimal tour set vertices total cost exercise simple implementati mst prim running time approx tsp tour v2 cost function instance traveling salesman problem satisfies triangle inequality approx tsp tour returns tour cost cost optimal tour theorem approx tsp tour polynomial time pproximation algorithm traveling salesman problem triangle inequality proof approx tsp tour runs polynomial time denote optimal tour set vertices spanning tree deleting edge tour weight minimum spanning tree lower bound cost optimal tour walk lists vertices visited returned visit subtree walk walk order walk traverses edge extending definition cost natural manner handle multisets edges equations imply cost factor cost optimal tour generally tour visits vertices triangle inequality delete visit vertex cost increase vertex deleted visits ordering specifies directly repeatedly applying operation remove visit vertex leaves ordering ordering preorder walk tree cycle preorder lk hamiltonian cycle vertex visited fact cle computed approx tsp tour deleting vertices walk combining inequalities completes proof spite nice approximation ratio provided theorem approx tsp tour practical choice problem approximation algorithms typically perform practice references chapter general traveling salesman problem drop assumption cost function satisfies tria ngle inequality good approximate tours polynomial time np theorem np constant polynomial approximation algorithm approximation ratio general trave ling salesman problem proof proof contradiction suppose contrary number polynomial time approximation algorithm approximation ratio loss generality assume integer rounding solve instances hamilt onian cycle problem defined polynomial time hamiltoni cycle problem np complete theorem solving polynomial time implies np theorem instance hamiltonian ycle problem determine efficiently hamiltonian cycle making hypothesized approximation algorithm turn instance traveling salesman problem complete graph assign integer cost edge representations created representation time polynomial traveling salesman problem original graph hamiltonian cycle cost function assigns edge cost tour cost hand hamiltonian cycle tour edge tour edge cost edges costly gap cost tour hamiltonian cycle cost cost tour cost apply approximation algorithm traveling salesman problem guaranteed return tour cost times cost optimal tour hamiltonian cycle return hamiltonian cycle returns tour cost solve hamiltonian cycle problem polynomial time proof theorem general technique proving problem approximated suppose np hard problem produce minimization problem instances correspond instances instances correspond instances greater np approximation algorithm problem exercises suppose complete undirected graph vertices cost function satisfies triangl inequality prove exercises polynomial time transform instance traveling salesman problem instance hose cost function satisfies triangle inequality instances set optimal tours explai polynomial time transformation contradict theorem assuming np exercises closest point heuristic building approximate traveling salesman tour trivial cycle consisting single arbitrarily chosen vertex step identify vertex cycle distance vertex cycle minimum suppose vertex cycle nearest vertex extend cycle include inserting repeat vertices cycle prove heuristic returns tour total cost cost optimal tour exercises bottleneck traveling salesman problem problem findi hamiltonian cycle cost costly edge cycle minimized assuming cost function satisfies triangle inequality exists polynomial time approximation algorithm approxima tion ratio problem hint recursively visit nodes bottleneck spanning tree discussed problem walk tree skipping nodes skipping consecutive intermediate nodes costliest edge bottleneck spanning tree cost cost costliest edge bottleneck hamiltonian cycle exercises suppose vertices instance traveling salesman problem points plane cost euclidean distance points optimal tour crosses set covering problem set covering problem optimization problem models resource selection problems ecision problem generalizes np complete vertex cover problem np hard appr oximation algorithm developed handle vertex cover problem apply approaches examine simple greedy heuristic logarithmic approximation ratio size instance larger size approximate solution grow relative size optimal solution loga rithm function grows slowly approximation algorithm netheless instance set covering problem consists finite set family subsets element belongs subset subset covers elements problem minimum size subset members cover satisfying equation covers figure illustrates set covering problem size defined number sets number individual elements sets figure minimum set cover size figure instance set covering problem consists black points minimum size set cover greedy algorithm produces cover size selecting sets s1 s4 s5 s3 order set covering problem abstracti commonly arising combinatorial problems simple suppose represents set skills needed solve problem set people work problem form committee ople requisite skill member committee skill decision version set covering problem covering exists size additional parameter oblem instance cision version problem np complete exercise asks greedy approximation algorithm greedy method works picking stage set covers greatest number remaining elements uncovered greedy set cover ø select maximizes return figure greedy set cover adds sets s1 s4 s5 s3 order algorithm works set stage set remaining uncovered elements set cover constructed greedy decision making step subset chosen covers uncovered elements ties broken arbitrarily selected elements removed algorithm terminates set subfamily covers algorithm greedy set cover easily implemented time polynomial number iterations loop lines bounded min loop body implemented time implementation runs time min exercise asks linear time algorithm analysis greedy algorithm returns cover larger optimal set cover convenience chapter denote dth harmonic number boundary condition define theorem greedy set cover polynomial time approximation algorithm proof greedy set cover runs polynomial time greedy set cover approximation algorithm assign cost set selected algorithm distribute cost elements covered time costs derive desired relationship size optimal set cover size set cover returned algorithm denote ith subset selected greedy set cover algorithm incurs cost adds spread cost selecting evenly elements covered time denote cost allocated element element assigned cost covered time covered time step algorithm unit cost assigned cost assigned optimal cover set combining previous equalities remainder proof rests follo wing key inequality prove shortly set belonging family inequalities proving theorem remains prove inequality set s1 number elements remaining uncovered s1 selected algorithm define u0 number elements initially uncovered element covered sets s1 sk elements covered time observe s1 s1 greedy choice guarantees cover elements chosen bound quantity completes proof inequality corollary greedy set cover polynomial time approximation algorithm proof inequality theorem applications small constant solution returned greedy set cover small consta times larger optimal application occurs heuristic approxima vertex cover graph vertices degree case solution greedy set cover times large optimal solution performance guarantee tter approx vertex cover exercises set letters arid dash drain heard lost nose shun slate snare thread cover greedy set cover produces ties broken favor word appears dictionary exercises decision version set covering problem np complete reduction vertex cover problem exercises implement greedy set cover runs time exercises followi weaker form theorem trivially true exercises greedy set cover return number solutions depending break ties procedure bad set cover instance returns element instance set covering problem depending ties broken greedy set cover return number fferent solutions exponential randomization linear programming study techniques designing approximation algorithms randomization linear programming simple randomized algorithm optimization version cnf satisfiability linear programming design approximation gorithm weighted version vertex cover problem scratches surface powerful techniques chapter notes references study areas randomized approximation algorith max cnf satisfiability randomized algorithms compute exact solutions randomized algorithms compute approximate solutions randomized algorithm problem approximation ratio input size expected cost solution produced randomized algorithm factor cost optimal solution randomized algorithm achieves approximation ratio randomized approximation algorithm randomized approximation algorithm deterministic approximation algorithm approximation ratio expected instance cnf satisfiability defined satisfiable order satisfiable assignment variables clause evaluates instance satisfiable compute close satisfiable sh assignment variables satisfies clauses maximization problem max cnf satisfiability input max cnf satisfiability cnf satisfiability goal return ssignment variables maximizes number clauses evaluating randomly setting eac variable probability probability randomized approximation algorithm definition cnf satisfiability require clause consist distinct literals assume clause variable negation exercise asks remove assumption theorem instance max cnf satisfiability variables clauses randomized algorithm independently sets variable probability probability randomized approximation algorithm proof suppose independently set variable probability probability define indicator random variable yi clause satisfied yi long literals ith clause set literal appears clau assumed variable negation clause ttings litera clause independent clause satisfied literals set clause satisfied clause satisfied lemma yi number satisfied clauses y1 ym upper bound number satisfi clauses approximation ratiom approximating weighted vertex cover linear programming minimum weight vertex cover problem undirected graph vertex positive weight vertex cover define weight vertex cover goal vertex cover minimum weight apply algorithm unweight vertex cover random solution methods solutions optimal compute lower bound weight mini mum weight vertex cover linear program round soluti vertex cover suppose associate variable vertex require interpret vertex cover interpret vertex cover write constraint edge vertex cover view rise integer program finding minimum ight vertex cover minimize subject exercise finding values satisfy np hard formulation suppose remove constraint replace linear program linear programming relaxation minimize subject feasible solution integer program lines feasible solution linear program lines optimal solution linear program lower bound optimal lution integer program lower bound optimal solution minimum weight vertex cover problem procedure solution linear program construct approximate solution minimum weight vertex cover problem approx min weight vc ø compute optimal solution linear program lines return approx min weight vc procedure works initializes vertex cover formulates li program lines solves linear program optimal solution vertex guide choice vertices add vertex cover lines add rounding fractional variable solution linear program order solution integer program lines finally returns vertex cover theorem algorithm approx min weight vc pol ynomial time approximation algorithm minimum weight vertex cover problem proof polynomial time algorithm solve linear program loop lines runs polynomial time approx min weight vc polynomial time algorithm approx min weight approximation algorithm optimal solution minimum weight vertex cover problem optimal solution lin ear program lines optimal vertex cover feasible solution linear program lower bound claim rounding actional values variables produce set vertex cover satisfies vertex cover edge constraint implies included vertex cover edge covered weight cover combining inequalities approx min weight vc approximation algorithm exercises clause variable negation randomly setting variable probability probability randomized approximation algorithm exercises max cnf satisfiability problem max cnf satisfiability problem restrict clause literals randomized approximation algorithm max cnf satisfiability problem exercises max cut problem ven unweighted undirected graph define cut chapter weight cut number edges crossing cut goal cut maximum weight suppose vertex randomly independently place probability probability algorithm randomized approximation algorithm exercises constraints redundant sense remove linear program lines optimal solution linear program satisfy subset sum problem instance subset sum problem pair set positive integers positive integer decision problem asks exists subset adds target problem np complete optimization problem decision problem arises practical applications optimization proble subset sum large larger truck carry pounds boxes ship ith weighs pounds truck heavy load exceeding weight limit exponential time algorithm optimization problem modify algorithm fully polynomial time approximation scheme recall fully pol ynomial time approximation scheme running time polynomial size input exponential time exact algorithm suppose computed subset sum elements selected subsets sum exceed sum closest algorithm return optimal solution exponential time implement algorithm iterative procedure iteration computes sums subsets starting point sums subsets realize subset sum exceeding reason intain superset optimal solution implementation strategy procedure exact subset sum takes input set target pseudocode moment procedure iteratively computes li list sums subsets exceed returns maximum list positive integers positive integer denote list integers derived increasing element notation sets auxiliary procedure merge lists returns rted list merge sorted input lists duplicate values removed merge procedure merge sort merge lists runs time omit pseudocode merge lists exact subset sum l0 li merge lists li li remove li element greater return largest element exact subset sum works denote set values selecting subset summing members identity prove induction exercise list li sorted list element length lii exact subset sum exponential time algorithm general polynomial time algorithm special cases polynomial numbers bounded polynomial fully polynomial time approximation scheme derive fully polynomial time approxi mation scheme subset sum problem trimming list li created idea values close purpose finding approximate solution reason maintain explicitly precisely trimming parameter trim list remove elements result trimming element removed element approximates representing list represented satisfying inequality trim deleted represented deleted values represented deleted represented element trimmed version list element original version list trimming dramatically decrease number elements keeping close smaller representative list deleted element procedure trims list y1 ym time assuming sorted monotonically increasing order output procedure trimmed sorted list trim y1 y1 yi yi sorted append yi yi return elements scanned monotonically increasing order number returned list element represented number procedure trim construct approximation scheme procedure takes input set integers arbitr ary order target integer approximation parameter returns factor optimal solution approx subset sum l0 li merge lists li li li trim lin remove li element greater largest return initializes list l0 list element loop lines computing li sorted list suitably trimmed version set elements larger removed li created li ensure repeated trimming introduce inaccuracy moment approx subset sum returns rrect approximation exists suppose instance trimming parameter approx subset sum computes values lines l0 l1 l1 l1 l3 l3 l3 l4 l4 l4 algorithm returns answer optimal answer fact theorem approx subset sum fully polynomial tim approximation scheme subset sum problem proof operations trimming li removing li element greater maintain property element li member returned sum subset denote optimal solution subset sum problem inequality running tim algorithm polynomial size input induction element li exercise inequality hold fulfilling inequality inequality hold largest remains showingn equation limnn functionn increases approaches limit combining inequalities completes analysis approximation ratio approx subset sum fully polynomial time approximation scheme derive bound length li trimming successive elements li relationshipn differ factorn list lue log1n additional values number elements list li bound polynomial size input number bits lg needed represent number bits eeded represent set turn polynomial running time approx subset sum polynomial lengths li approx subset sum fully polynomial time approximation scheme exercises prove equation execu ting exact subset sum li sorted list element exercises prove inequality exercises prove inequality exercises modify approx imation scheme presented good approximation smalle sum subset input list problems bin packing suppose set objects size ith object satisfies pack obj ects minimum number unit size bins bin hold subset objects total size exceed prove problem determining minimum number bins required np hard hint reduce subset sum problem fit heuristic takes object turn places bin accommodate argue optimal number bins required argue fit heuristic leaves bin half prove number bins fit heuristics prove approximation ratio fit heuristic efficient implementation firs fit heuristic analyze running time problems approximating size maximum clique undirected graph define undirected graph set ordered tuples vertices defined v1 v2 vk adjacent w1 w2 wk vertex vi adjacent vi prove size maximum clique equal kth power size maximum clique argue approximation gorithm constant approximation ratio finding maximum size clique fully polynomial time approximation scheme problem problems weighted set covering problem suppose generalize set covering problem set family weight weight cover determine minimum weight cover handles case greedy set covering heuristic generalized natural manner provide approximate solution instance weighted set covering problem heuristic approximation ratio maximum size set problems maximum matching recall undirected graph matching set edge edges set incident vertex maximum matching bipartite graph problem matchings undirected graphs general graphs required bipartite maximal matching matching oper subset matching maximal matching maximum matching exhibiting undirected graph maximal matching maximum matching graph vertices undirected graph time greedy algorithm maximal matching problem concentrate polynomial time approximation algorithm maximum matching fastest algorithm maximum matching takes superlinear polynomial time approxima tion algorithm linear time linear time greedy algor ithm maximal matching approximation algorithm maximum matching size maximum matching lower bound size vertex cover maximal matching edge incident subgraph induced vertices conclude size vertex cover parts prove greedy algorithm approximation algorithm maximum matching problems parallel machine scheduling parallel machine scheduling problem jobs j1 j2 jn job jk nonnegative processing time identical machines m1 mm schedule specifies job jk machine runs time period runs job jk machine mi consecutive time units time period job mi ck denote completion time job jk time job jk completes processing schedule define cmax maxjn ck makespan schedule goal schedule makespan minimum suppose machines m1 jobs j1 j2 j3 j4 p4 schedule runs machine m1 job j1 job j2 machine runs job j4 job j3 schedule c4 cmax optimal schedule runs j2 machine m1 runs jobs j1 j3 j4 machine schedule c4 cmax parallel machine scheduling problem denote makespan optimal schedule optimal makespan leas large greatest processing time optimal makespan large average machine load suppose greedy algorithm parallel machine scheduling machine idle schedule job scheduled write pseudocode implement greedy algorithm running time algorithm schedule returned greedy algorithm conclude algorithm polynomial time approximation algorithm chapter notes methods mpute exact solutions thousands years thods approximate notion approximation algorithm hochbaum credits garey graham ullman johnson formalizing concept polynomial time approximation algorithm algorithm credited graham subject problem early work thousands approxima tion algorithms designed wide range problems wealth literature field texts ausiello hochbaum vazirani deal exclusively approximation algorithms surveys shmoys klein young texts garey johnson papadimitriou steiglitz coverage approximation algorithms lawler lenstra rinnooy kan shmoys provide extensive treatment approxi mation algorithms traveling salesman problem papadimitriou steiglitz attribute algorithm approx vertex cover gavril yannakakis vertex cover problem studied extensively hochbaum lists approximation algorithms problem approximation ratios algorithm approx tsp tour appears paper rosenkrantz stearns lewis christofedes improved algorithm approximation algorithm traveling salesman problem triangle inequality arora mitchell points euclidean plan polynomial time approximation scheme theorem sahni gonzalez analysis greedy heuristic set cove ring problem mode led proof published chvátal general result basic result presented johnson lovász algorithm approx subset sum anal ysis loosely odeled approximation algorithms kna psack subset sum problems ibarra kim randomized algorithm max cnf tisfiability implicit work johnson weighted vertex cover algorithm hochbaum touches power randomization linear programming design approximation algorithms combination ideas yields technique called randomized rounding problem formulat integer linear program linear programming relaxation solved variables solution interpreted probabilities probabilities guide solution original problem technique raghavan thompson subsequent motwani naor raghavan survey notable ideas field approximation algorithms include primal dual method survey finding sparse cuts divide conquer algorithms semidefinite programming mentioned chapter notes chapter probabilistically checkable proofs led lower bounds approxima bility problems including chapter addition references chapter arora lund good description relationship probabilistically checkable proofs hardness approximating problems viii appendix mathematical background chapter list appendix summations appendix sets appendix counting probability introduction analysis algorithms requires draw body mathematical tools tools simple high school algebra manipulate asymptotic notations solve recurrences appendix compendium concepts met hods analyze algorithms introduction terial appendix read book specific notational conventions occasionally differ books henc treat appendix reference material rest book included exercises problems order improve skills areas appendix offers methods evaluating ounding summations occur frequently analysis algorithms formulas chapter calculus text convenient methods compiled place appendix basic definitions notations sets relations functions graphs trees chapter basic properties mathematical objects appendix elementary principles counting permutations combinations remainder chapter definitions properties basic probability algorithms book require obability analysis easily omit sections chapter reading skimming encounter probabilistic analysis understand appendix organized reference purposes appendix summations overview algorithm iterative control construct loop running time expressed sum times spent execution body loop jth iteration insertion sort time proportional worst case adding spent iteration summation series evaluating summation yielded bound worst case running time algorithm general understand ing manipulate bound summations lists basic formulas involving summations offers techniques bounding summations formulas proof proofs presented illustrate methods proofs calculus text summation formulas properties sequence numbers finite sum nonnegative integer written summation defined finite series defined terms order sequence numbers infinite sum written interpreted limit exist series diverges converges terms convergent series order rearrange terms absolutely convergent series series series converges linearity real number finite sequences linearity property obeyed infinite convergent series linearity property exploited nipulate summations inco rporating asymptotic notation equation notation left hand applies variable hand applies manipulations plied infinite convergent series arithmetic series summation arithmetic series sums squares cubes summati ons squares cubes geometric series real summation geometric exponential series summation infinite infinite decreasing geometric series harmonic series positive integers nth harmonic number prove bound integrating differentiating series additional formulas integrat ing differentiating formulas differentiating sides infinite geometric series multiplying telescoping series sequence a0 terms subtracted sum telescopes telescoping sum series rewrite term products finite product written product defined convert formula product formula summation identity exercises simple formula exercises manipulating harmonic series exercises exercises exercises evaluate sum exercises prove linearity property summations exercises evaluate product exercises evaluate product bounding summations techniques bounding summations running times algorithms frequently methods mathematical induction basic evaluate series mathematical inducti prove arithmetic series evaluates easily verify inductive assumption holds prove holds guess exact summa tion order mathematical induction induction bound prove geometric seriesn prove constant initial condition long assuming bound holds prove holds long equivalently wished careful asym ptotic notation prove bounds induction fallacious proof assuming bound prove bug argument cons tant hidden big grows constant constant works bounding terms good upper bound series bounding term series suffices largest term bound quick upper bound arithmetic series general series amax maxknak technique bounding term series largest term weak method series fact bounded geometric series series suppose ak ak constant sum bounded infinite decreasing geometric series ak a0rk apply method bound summation order start summation rewrite term a0 ratio consecutive terms common bug applying method ratio consecutive terms assume summa tion bounded geometric series infinite harmonic ries diverges ratio kth terms series series bounded decreasing geometric series bo und series geometric series constant ratio pairs consecutive terms exceeds harmonic series exists ratio arbitrarily close splitting summations bounds difficult summation express series sum series partitioning range bound series suppose lower bound arithmetic series upper bound attempt bound term summation smallest term term lower bound summation upper bound lower bound splitting summation assume convenience asymptotically tight bound summation arising analysis algorithm split summation ignore constant number initial terms generally technique applies term ak summation independent constant k0 write initial terms summation constant constant number methods bound technique applies infinite summations asymptotic upper bound observe ratio consecutive terms summation split summation constant num ber terms summation decreasing geometric series technique splitting summations determine asymptotic bounds difficult situations bound lg harmonic series idea split range lg pieces upper bound contribution piece piece consists terms starting includingi approximation integrals summation expressed monotonically increasing function approximate integrals justification approximation figure summation represented area rectangles figure integral shaded region curve monotonically decreasing functi method provide bounds figure approximation integrals area rectangle rectangle total rectangle area represents summation integral represented shaded area curve comparing areas shifting rectangles unit integral approximation tight estimate nth harmonic number lower bound upper bound derive inequality yields bound exercises bounded constant exercises asymptotic upper bound summation exercises nth harmonic number lg splitting summation exercises approximate integral exercises integral approximation directly upper bound nth harmonic number problems bounding summations asymptotically tight bounds summations assume constants chapter notes knuth excellent reference material presented chapter basic properties series good calculus book apostol thomas finney appendix sets chapters book touch elemen discrete mathem atics chapter reviews completely notations defini tions elementary properties sets relations functions graphs trees readers versed material skim chapter sets set collection distinguishable objects called members elements object member set write read member member write set explicitly listing members list inside braces define set precisely numbers writing member set write member set object elements ordered sets equal written elements adopt special notations frequently encountered sets ø denotes set set members denotes set integers set denotes set real numbers denotes set natural numbers set elements set contained set implies write subset set proper subset written authors symbol denote ordinary subset relation proper subset relation set sets sets set ø define sets rms sets set define set stating property distinguishes elements define set integers integer colon notation read authors vertic bar place colon sets define sets applying set operations intersection sets set union sets set difference sets set set operations obey laws set laws ø ø ø idempotency laws commutative laws associative laws distributive laws absorption laws demorgan laws demorgan laws illustrated figure venn diagram graphical picture sets repres ented regions plane figure venn diagram illustrating demorgan laws sets represented circle sets consideration subsets larger set called universe sets integers set integers universe universe define complement set set laws demorgan laws rewritten complements sets sets disjoint elements common ø collection nonempty sets forms partition set sets pairwise disjoint imply ø union forms partition element appears number elements set called cardinality size set denoted sets cardinality elemen correspondence cardinality set ø cardinality set natural number set finite infinite infinite set correspondence natural numbers countably infinite uncountable integers countable reals uncountable finite sets identity conclude disjoint finite set elements called set set called singleton subset elements set called subset set subsets set including set denoted called power set ø power set finite set cardinality care setlike structures elements ordered ordered pair elements denoted defined formally set ordered pair ordered pair cartesian product sets denoted set ordered pairs element pair element element formally finite sets cardinality cartesian product cartesian product sets set tuples ai ai cardinality sets finite denote fold cartesian product single set set cardinality finite tuple viewed finite sequence length exercises draw venn diagrams illustrate distributive laws exercises prove generalization demorgan ws finite collection sets exercises prove generalization equation called principle inclusion exclusion pairs triples exercises set odd natural numbers countable exercises finite set power set elements distinct subsets exercises inductive definition tuple extending set theoretic definition ordered pair variation set object called multiset authors start natural num bers modern trend start relations binary relation sets subset cartesian product write binary relation set subset relation natural numbers set ary relation sets subset binary relation reflexive reflexive relations relation symmetric implies symmetric relation transitive imply relations transi tive relation imply relation reflexive symmetric transitive equivalence relation equivalence relation natural numbers equivalence relation set equivalence class set set elements equivalent define number equivalence relation reflexive implies symmetric imply transitive equivalence class equivalence class basic theorem equiva lence classes theorem equivalence relati partition equivalence classes equivalence relation set form partition partition determines equivalence relation sets partition equivalence classes proof proof equivalence classes nonempty pairwise disjoint sets union reflexive equivalence classes nonempty element belongs equivalence class union equivalence classes remains equivalence classes pairwise disjoint equivalence classes element common fact set symmetry transitivity imply arbitrary element implies proof partition define exists ai ai claim equivalence relation reflexivity holds ai implies symmetry holds set ai elements set transitivity holds sets partition equivalence classes observe ai implies ai ai implies binary relation set antisymmetric imply relation natural numbers antisymmetric imply relation reflexive tisymmetric transitive partial order set partial order defined partially ordered set relation descendant partial order people view individuals descendants partially ordered set single maximum element maximal elements case collection sized boxes maximal boxes fit inside box single maximum box box fit partial order set total linear order pairing elements relation total order natural numbers descendant relation total order set people individuals descended exercises prove subset relation subsets partial order total order exercises positive integer relation equivalent modulo equivalence relation integers mod exists integer qn equivalence classes relation partition integers exercises examples relations reflexive symmetric transitive reflexive transiti symmetric symmetric transitive reflexive exercises finite set equivalence relation addition antisymmetric equivalence classes respect singletons exercises professor narcissus claims relation symmetric transi tive reflexive offers proof symmetry implies transitivity implies professor correct precise order fit inside relation partial order view box fitting inside functions sets function binary relation exists precisely set called domain set called codomain write write uniquely determined choice intuitively function assigns element element element assigned elements element assigned elements binary relation mod function natural number mod contrast binary relation function choice precisely function argument define function stating element domain define functions equal domain codomain domain finite sequence length function domain set integers denote finite quence listing values infinite sequence function domain set natural numbers fibonacci sequence defined recurrence infinite sequence domain function cartesian product omit extra parentheses surrounding argument function write ai argument function technically single argument tuple function image image set defined range image domain range function defined function surjection range codomain function surjective function element appears argument contrast function surjective function argument produce function surjective function natural numb ers numbers surjection mapping surjective function injection distinct arguments produce distinct values implies function injective function number image element domain function injective produced arguments injection called function function bijection injective surjective function bijection function injectiv element image element surjective element appears image element function bijective bijection called correspondence pairs elements domain codomain bijection set called permutation function bijective inverse defined inve rse function exercises finite sets function injective surjective exercises function bijective domain codomain bijective domain codomain exercises natural definition inverse binary relation relation fact bijective function relational inverse functional inverse exercises bijection graphs presents kinds graphs dir ected undirected definitions literature differ fferences slight graphs represented computer memory directed graph digraph pair finite set binary relation set called vertex set elements called vertices singular vertex set called edge set elements called edges figure pictorial representation directed graph vertex set vertices represented circles figure edges represented arrows note loops edges vertex figure directed undirected graphs directed graph edge loop undirected graph vertex isolated subgraph graph induced vertex set undirected graph edge set consists unordered pairs vertices ordered pairs edge set convention notation edge set notation considered edge undirected graph loops forbidden edge consists distinct vertices figure pictorial representation undirected graph vertex set definitions directed undirected graphs terms meanings contexts edge directed graph incident leaves vertex incident enters vertex edges leaving vertex figure edges entering vertex edge undirected graph saythat incident vertices figure edges incident vertex edge graph vertex adjacent vertex graph undirected adjacency relation symmetric graph directed adjacency relation ecessarily symmetric adjacent directed graph write parts figure vertex adjacent vertex edge belongs graphs vertex adjacent vertex figure edge belong graph degree vertex undirected graph number edges incident vertex figure degree vertex degree vertex figure isolated directed graph degree vertex number edges leaving degree vertex number edges entering degree vertex directed graph degree degree vertex figure degree degree degree path length vertex vertex graph sequence v0 v1 v2 vk vertices v0 vk vi vi length path number ofedges path path vertices v0 v1 vk edges v0 v1 v1 v2 vk vk length path path reachable write directed path simple vertices path distinct figure path simple path ngth path simple subpath path v0 v1 vk contiguous subsequence vertices subsequence vertices vi vi subpath directed graph path v0 v1 vk forms cycle v0 vk path edge cycle simple addition v1 v2 vk distinct loop cycle length paths v0 v1 v2 vk v0 form cycle exists integer figure path forms cycle paths cycle simple cycle cycle formed edge loop directed graph loops simple undirected graph path v0 v1 vk forms simple cycle v0 vk v1 v2 vk distinct figure path cycle graph cycles acyclic undirected graph connected pair vertices connected path connected components graph equivalence asses vertices reachable relation graph figure connected components vertex reachable vertex undirected graph connected connected component vertex reachable vertex directed graph connected vertices reachable connected components directed graph equivalence classes vertices mutually reachable relation directed graph connected connected component graph figure connected components pairs vertices mutually reachable vertices form connected component vertex reached vertex graphs isomorphic exists bijection relabel vertices vertices maintaining edges figure pair isomorphic graphs respective vertex sets mapping required bijective function graphs figure isomorphic graphs vertices edges graph vertex degree graph figure pair isomorphic graphs verti ces graph mapped vertices graph graphs isomorphic graph vertex degree graph graph subgraph set subgraph induced graph subgraph induced vertex set figure appears figure edge set undirected graph directed version directed graph undirected edge replaced directed vers ion directed edges directed graph undirected version undirected graph undirected version edges directions removed loops eliminated edge undirected graph undirected version directed graph directed graph edges directed graph neighbor vertex vertex adjacent undirected version neighbor undirected graph neighbors adjacent kinds graphs special names complete graph undirected graph pair vertices adjacent bipartite graph undirected graph partitioned sets v1 v2 implies v1 v2 v2 v1 edges sets v1 v2 acyclic undirected graph forest connected acyclic undirected graph free tree letters irected acyclic graph graph dag variants graphs occasionally encounter multigraph undirected graph multip edges vertices loops hypergraph undirected graph hyperedge connecting vertices connects arbitrary subset vertices algorithms written ordinary directed undirected graphs adapted graphlike structures contraction undirected graph edge graph vertex set edges formed deleting edge vertex incident deleting whichever adding edge exercises attendees faculty party shake hands greet professor remembers times shook hands party department head adds number times professor shook ha nds result proving handshaking lemma undirected graph exercises directed undirected graph path vertices simple path directed graph cycle simple cycle exercises connected undirected graph satisfies exercises verify undirected aph reachable rela tion equivalence relation vertices graph whic properties equivalence relation hold general reachable relati vertices directed graph exercises undirected version directed graph figure directed version undirected graph figure exercises hypergraph represented bipartite graph incidence hypergraph correspond adjacency bipartite graph hint set vertices bipartite graph correspond vertices hypergraph set vertices bipartite graph correspond hyperedges trees graphs slig htly notions trees presents definitions mathematical properties kinds trees sections trees represented computer memory free trees defined free tree connected acyclic undirected graph omit adjective free graph tree undirect graph acyclic disconnected forest algorithms work trees work forests figure free tree figure forest forest figure tree connected graph figure tree forest cycle figure free tree forest graph cycle tree forest theorem captures facts free trees theorem propert ies free trees undirected graph statements equivalent free tree vertices connected unique simple path connected edge removed graph disconnected connected acyclic acyclic edge graph cycle proof tree connected vertices connected simple path vertices connected distinct simple paths figure vertex paths diverge vertex successor successor vertex paths reconverge vertex subpath subpath paths share vertices endpoints path concatenating reverse cycle contradicts assumption tree tree simple path vertices figure step proof theorem free tree vertices connected unique simple path assu sake contradiction vertices connected distinct simple paths paths diverge vertex reconverge vertex path concatenated reverse path forms cycle yields contradiction vertices connected unique simple path connected edge edge path unique path remove path removal disconnects assumption graph connected exercise prove induction connected graph vertices edges suppose vertices graphs satisfying fewer vertices satisfy removing arbitrary edge separates graph connected components component tisfies satisfy induction number edges components combined adding removed edge yields suppose connected acyclic suppose cycle vertices v1 v2 vk loss generality assume cycle simple gk vk ek subgraph consisting cycle note vk ek vertex vk vk adjacent vertex vi vk connected define gk vk ek subgraph vk vk vk ek ek vi vk note vk ek continue defining gk manner gn vn vn vn gn subgraph contradicts assumption acyclic suppose acyclic number connected components connected component free definition implies sum edges connected components fact tree plies vertices connected unique simple path adding edge creates cycle suppose acyclic edge cycle created connected arbitrary vertices adjacent adding edge creates cycle edges belong path chosen arbitrarily connected rooted ordered trees rooted tree free tree vertices distinguished distinguished vertex called root tree refer vertex rooted tree node tree figure rooted tree set nodes root figure rooted ordered trees rooted tree height tree drawn standard root node children nodes depth beneath children nodes depth beneath tree ordered relative left order children node matters rooted tree rooted tree identical tree ordered tree children node order node rooted tree root node unique path called ancestor ancestor descendant node ancestor descendant ancestor proper ancestor proper descendant subtree rooted tree induced descendants rooted subtree rooted node figure nodes edge path root tree node parent child root node parent nodes parent siblings node children external node leaf nonleaf node internal node number children node rooted tree called degree length path root node depth height node tree number edges longest simple downward path node leaf height tree height root height tree equal largest depth node tree ordered tree rooted tree children node ordered node children child child kth child trees figure considered ordered trees considered rooted trees binary positional trees binary trees defined recursively binary tree structure defined finite set nodes nodes composed disjoint sets nodes root node binary tree called left subtree binary tree called subtree binary tree nodes called tree null tree denoted nil left subtree nonempty root called left child root entire tree likewise root nonnull subtree child root entire tree subtree null tree nil child absent missing figure binary tree figure binary trees binary tree drawn standard left child node drawn beneath node left child drawn beneath binary tree left child node child absent left child node absent child ordered trees trees binary trees distinct binary tree represented internal nodes binary tree ordered tree internal node degree leaves tree squares binary tree simply ordered tree node degree binary tree node child position child left child child matters ordered tree ere distinguishing sole child left figure binary tree differs tree figure position node considered ordered trees trees identical positioning binary tree represented internal nodes ordered tree figure idea replace missing child binary tree node children leaf nodes drawn squares figure tree binary tree node leaf degree degree nodes orde children node preserves position positioning distinguishes nary trees ordered trees extended trees children node positional tree children node labeled distinct positive integers ith child node absent child labeled integer ary tree positional tree node children labels greater missing binary tree ary tree complete ary tree ary tree leaves depth internal nodes degree figure complete binary tree height leaves complete ary tree height root children depth children depth number leaves depth kh height complete ary tree leaves log number internal nodes complete ary tree height equation complete binary tree internal nodes figure complete binary tree height leaves internal nodes exercises draw free trees posed vertices draw rooted trees nodes root draw ordered trees nodes root draw binary trees nodes root exercises directed acyclic graph vertex v0 exists unique path v0 vertex prove undirected version forms tree exercises induction number degree odes nonempty binary tree number leaves exercises induction nonempty binary tree nodes height lg exercises internal path length binary tree sum internal nodes tree depth node likewise external path length sum leaves tree depth leaf binary tree internal nodes internal path length external path length prove exercises associate weight leaf depth binary tree prove sum leaves kraft inequality exercises binary tree leaves subtree leaves inclusive problems graph coloring undirected graph coloring function edge numbers represent colors adjacent vertices colors tree colorable equivalent bipartite colorable cycles odd length maximum degree vertex graph prove colored colors edges colored colors problems friendly graphs reword statements theorem undirected graphs prove assume friendship symmetric reflexive group people people number friends group group people mutual friends mutual strangers group people partitioned subgroups half friends person belong subgroup person member group friend half people group group seated table seated friends problems bisecting trees divide conquer algorithms operate graphs require graph bisected equal sized subgraphs induced partition vertices problem investigates bisections trees rmed removing small number edges require vertices subtree edges removed partition removing single edge partition vertices vertex binary tree sets constant optimal worst case simple binary tree evenly balanced partition removal single edge removing lg edges partition vertices vertex binary tree sets term node graph eory literature synonym vertex reserve term node ean vertex rooted tree notice degree node depends considered rooted tree free tree degree vertex free tree undirected graph number adjacent vertices rooted tree degree number children parent node count degree chapter notes boole pioneered development symbolic logic introduced basic set notations book published modern set theory created cantor period cantor focused sets infinite cardinality term function attributed leibniz refe kinds mathematical formulas limited definition genera lized times graph theory originated euler proved impossible cross bridges city königsberg return starting point compendium definitions graph theory book harary appendix counting probability chapter reviews elementary combinator ics probability theory good background areas skim chapter lightly concentrate sections chapters require probability chapters essential reviews elementary counting theory including standard formulas counting permutations combinations axioms probability basic facts probability distributions presented random variables introduced properties expectation variance investigates geometric binomial distributions studying bernoulli trials study binomial dist ribution continued advanced discussion tails distribution counting counting theory answer question ithout enumerating bit numbers orderings distinct elements review elements counting theory material sumes basic understanding sets reader advised start reviewing material rules sum product set items count expressed union disjoint sets cartesian product sets rule sum number ways choose element disjoint sets sum cardinalities sets finite sets members common equation position car license plate letter digit number possibilities position ere choices letter choices digit rule product number ways choose ordered pair number ways choose element times numbe ways choose element finite sets simply equation ice cream parlor offers fla vors ice cream toppings number sundaes scoop ice cream topping strings string finite set sequence elements binary strings length string length string substring string ordered sequence consecutive elements substring string substring length substring substring position substring string set viewed element cartesian product sk tuples strings length number binary strings intuitively construct string set ways pick element choices ways pick element times construction leads fold product nk number strings permutations permutation finite set ordered sequence elements element appearing permutations abc acb bac bca cab cba permutations set elements element sequence chosen ways ways ways permutation ordered sequence elements element appearing sequence ordinary permutation permutation set permutations set cb db number permutations set ways choosing element ways choosing element elements selected selection elements combinations combination set simply subset combinations set shortha denoting set construct combination set choosing distinct elements set number combinations set expressed terms number permutations set combination permutations elements distinct permutation set number combinations set number permutations divided equation quantity formula tells number ways choose elements set binomial coefficients notation read choose denote number combinations set equation formula symmetric numbers binomial coefficients appearance binomial expansion special case binomial expansion occurs formula corresponds counting binary strings number binary strings ways choose positions place identities involving binomial coefficien exercises kend opportunity prove binomial bounds bound size binomial coefficient lower bound advantage inequality derived stirling approximation upper bounds induction exercise prove bound convenience assume bound rewritten binary entropy function convenience assume lg exercises substrings string cons ider identical substrings positions substrings string total exercises input output boolean function function true false true false input output boolean functions input output boolean functions exercises ways professors sit circular conference table seatings rotated form exercises ways choose set distinct numbers sum exercises prove identity exercises prove identity exercises choose objects objects distinguished distinguished object chosen approach prove exercises result exercise table binomial coefficients table binomial coefficients called pascal triangle exercises prove exercises maximum achieved exercises argue provide algebraic proof argument based method choosing items equality hold exercises induction prove inequality equation extend exercises stirling approximation prove exercises differentiating entropy function achieves maximum exercises integer probability probability essential tool design analysis probabilistic randomized algorithms review basic probability theory define probability terms sample space set elements called elementary events elementary event viewed outcome experiment experiment flipping stinguishable coins view sample space consisting set strings ht event subset sample space xperiment flipping coins event obtaining head tail ht event called event event ø called null event events mutually exclusive treat elementary event event definition elementary ents mutually exclusive axioms probability probability distribution sample space mapping events real numbers probability axioms satisfied event mutually exclusive events generally finite countably infinite sequence events pairwise mutually exclusive probability event note axiom normalization requirement fundamental choosing probability event natural convenient follow axioms basic set theory null event ø probability denote event complement events coin flipping suppose elementary events probability probability head ht ht alternatively probability strict ly head probability head discrete probability distributions probability distribution discrete defined finite countably infinite sample space sample space event elementary events mutually exclusive finite elementary event probability uniform probability distribution case experiment picking element random process flipping fair coin probability obtaining head probability obtaining tail flip coin times uniform probability distribution defined sample space set size elementary event represented string length occurs probability event heads tails occur subset size strings length probability event continuous uniform probability distribution continuous uniform probability distribution probability distribution subsets sample space nsidered events continuous uniform probability distribution defined closed interval reals intuitively point interval equally uncountable number points points finite positive probability simultaneously satisfy axioms reason associate probability subsets axioms satisfied events closed interval continuous uniform probability distribution defines probability event note point probability remove endpoints interval open interval axiom generally set events continuous uniform probability distribution subset sample space finite countable union open closed intervals conditional probability independence prior partial knowledg outcome experiment suppose friend flipped fair coins told coins head probability coins heads eliminates possibility tails remaining elementary events equally infer occurs probability elementary events heads answer question conditional probability formalizes notion prior partial knowledge outcome experiment conditional probability event event occurs defined read probability intuitively event occurs event occurs set outcomes occur outcome elementary events normalize prob abilities ementary events dividing sum conditional probability ratio probability event probability event event coins heads event leas coin head events independent equivalent condition suppose fair coins flipped outcomes independent probability heads suppose event coin heads event coins differently events occurs proba bility probability events occur definition independence events independent events depend rst coin finally suppose coins welded fall heads fall tails possibilities equally probability coin heads probability heads event heads event heads independent collection events pairwise independent ai ai events collection mutually independent subset collection i1 ik satisfies suppose flip fair coins event coin heads event coin heads event coins ai ai events pairwise independent events mutually independent bayes theorem definition conditional probability commutative law events nonzero probability solving bayes theorem denominator normalizing constant reexpress mutually exclusive events substituting equation equivalent form bayes theorem bayes theorem simplify computing conditional probabilities suppose fair coin biased coin heads experiment consisting independent events coins chosen random coin flipped flipped suppose chosen coin heads times obability biased solve problem bayes theorem event biased coin chosen event coin heads times determine exercises prove boole inequality finite countably infinite sequence events exercises professor rosencrantz flips fair coin ofessor guildenstern flips fair coin probability professor rose ncrantz obtains heads professor guildenstern exercises deck cards bearing distinct number shuffled mix cards cards removed time deck wh probability cards selected sorted increasing order exercises procedure takes input integers fair coin flips produces output heads probability tails probability bound expected number coin flips hint represent binary exercises prove exercises prove collection events exercises construct set events pairwise indepe ndent subset mutually independent exercises events conditionally independent simple nontrivial tw events independent conditionally independent event exercises contestant game prize hidden curtains win prize select correct curtain picked curtain curtain lifted emcee lifts curtains knowing reveal stage asks switch current selection remaining curtain chances change switch exercises prison warden randomly picked prisoner free executed guard free forbidden prisoner stat prisoners prisoner asks guard privately executed arguing nce die guard revealing formation status guard tells executed prisoner feels happier figures prisoner free probability free chances explain general probability distribution subsets sample space considered events situa tion arises sample space uncountably infinite main requirement set events sample space closed operations comple ment event forming union finite countable number events taki intersection finite countable number events probability stributions finite countable sample spaces generally subsets sample space events notable exception continuous uniform probability distribution presented shortly discrete random variables discrete random variable function finite countably infinite sample space real numbers associates eal number outcome experiment work probability distribution induced set numbers random variables defined uncountably infinite sample spaces raise technical issues unneces sary address purposes henceforth assume random variables discrete random variable real number define event function probability density function random variable probability axioms andx experiment rolling pair ordinary sideddice elementary events sample space assume probability distribution uniform elementary event equally define random variable maximum values showing dice assigns elementary events common random variables defined sample space random variables function joint probability density function fixed fixed definition conditional probability define random variables independent events independent equivalently set random variables defined sample space define random variables sums products functions original variables expected random variable simplest summary distribution random variable average values takes expected synonymously expectation discrete random variable defined sum finite converges absolutely expectation denoted µx random variable apparent context simply µ game flip fair ins earn head lose tail expected random variable representing earnings expectation sum random variable sum expectations defined property linearity expectation holds independent extends finite absolutely convergent summations expectations linearity expectation key property enables perform probabilistic analyses ing indicator random variables random variable function defines random variable expectation defined letting constant expectations linear random variables constant random variables independent defined expectation general random variables mutually independent random variable takes values set natural numbers nice formula expectation term times subtracted times times subtracted apply convex function random variable jensen inequality provided expectations exist finite function convex variance standard deviation expected random variable spread variable values random variables actual values farther actual values notion variance mathematically expresse random variable values variance random variable justification equalities xe random variable simply real number equation applies equation rewritten xpression expectation square random variable variance random variable variance exercise var a2var independent random variables var var var general random variables pairwise independent standard deviation random variable positive square root variance standard deviation random variable denoted simply random variable understood context notation variance denoted exercises ordinary sided dice rolled expectation sum values showing expectation maximum values showing exercises array distinct numbers randomly ordered permutation numbers equally expectation maximum element array xpectation minimum element array exercises carnival game consists dice cage player bet dollar numbers cage shaken pa yoff player number dice loses dollar number appears dice dollar wins dollars expected gain playing carnival game exercises argue nonnegative random variables max exercises independent random variables prove independent choice functions exercises nonnegative random variable suppose defined prove markov inequality exercises sample space random variables prove real constant exercises larger expectation square random riable square expectation exercises random variable takes values var exercises prove var a2var definition variance geometric binomial distributions coin flip instance bernoulli trial defined experiment outcomes success occurs probability failure occurs probability speak bernoulli trials collectively trials mutually independent probability success distributi ons bernoulli trials geometric distribution binomial distribution geometric distribution suppose sequence bernoulli trials probability success probability failure trials occur success random variable number trials success values range failures success probability distribution satisfying equation geometric distribution figure illustrates distribution figure geometric distri bution probability success probability failure expectation distribution assuming expectation geometric distribution calculated identity average takes trials success intuitive result variance calc ulated exercise suppose repeatedly roll dice outcomes yield yield probability success roll times average binomial distribution successes occur bernoulli trials su ccess occurs probability failure probability define random variable number successes trials values range ways pick trials successes probability occurs pkqn probability distribution satisfying equation binomial distribution convenience define fam ily binomial distributions notation figure illustrates binomial distribution binomial fact kth term expansion figure binomial distribu tion bernoulli trials probability success xpectation distribution np required axiom probability axioms compute expectation random variable binomial distribution equations random variable llows binomial distribution definition expectation linearity expectation result algebra random variable describing number successes ith trial linearity expectation equation expected number successes trials approach calculate variance distribution equation takes values compute variance advantage independence trials equation figure binomial distribution increases runs reaches np decreases prove distribution behaves manner ratio successive terms ratio greater precisely positive distribution increases distribution decreases integer distribution maxima np attains maximum unique integer lies range np lemma upper bound binomial distribution lemma proof equation exercises verify axiom probability ioms geometric distribution exercises times average flip fair coins heads tails exercises exercises maximu binomial distribution exercises probability successes bernoulli trials probability probability success exercises professor rosencrantz flips fair coin times professor guildenstern probability number heads hint professor rosencrantz head success profe ssor guildenstern tail success argument verify identity exercises entropy function exercises bernoulli trials ith trial probability success random variable denoting total number successes prove exercises random variable total number successes set bernoulli trials ith trial probability success random variable total number successes set bernoulli trials ith trial probability success prove hint bernoulli trials experiment invo lving trials result exercise tails binomial distribution probability successes bernoulli trials probability success probability successes investigate tails binomial distri bution regions distribution np prove bounds sum terms tail provide bound tail distribution bounds left tail determined inverting roles successes failures theorem sequence bernoulli trials success occurs probability random variable denoting total number successes probability successes proof denote event ith trial success inequality boole inequality corollary restates theorem left tail binomial distribution general leave reader adapt proofs tail corollary sequence bernoulli trials success occurs probability random variable denoting total number successes probability successes bound concerns left tail binomial distribution rollary left tail diminishes exponentially theorem sequence bernoulli trials success occurs probability failure probability random variable noting total number successes np probability fewer successes proof bound series geometric series technique equation xb iteratively applying inequality times corollary sequence bernoulli trials success occurs probability failure probability np probability fewer successes half probability fewer successes proof np letting random variable denoting number successes theorem implies probability fewer successes bounds tail determined proofs left exercise corollary sequence bernoulli trials success occurs probability random variable denoting total number successes np probability successes corollary sequence bernoulli trials success occurs probability failure probability np probability successes half probability successes theorem considers bernoulli trials probability success subsequent corollary theorem provide bound tail binomia distribution setting trial theorem sequence bernoulli trials ith trial success occurs probability failure occurs probability qi random variable describing total number successes µ µ proof function strictly increasing determined markov inequality bulk proof consists bounding µ substituting suitable inequality evaluate µ notation ith bernoulli trial success random variable ith bernoulli trial success failure linearity expectation implies evaluate µ substitute µ obtaining mutual independe nce random variables implies mutual independence random variables exercise definition expectation exp denotes exponential function exp inequality inequalities qi eqi inequality equation inequalities choosing µ exercise applied bernoulli trials trial probability success theorem yields corollary bounding tail binomial distribution corollary sequence bernoulli trials trial success occurs probability failure occurs probability np proof equation µ np exercises obtaining heads flip fair coin times obtaining fewer heads flip coin times exercises prove corollaries exercises exercises prove np exercises conditions theorem imply conditions corollary imply exercises sequence bernoulli trials ith trial success occurs probability failure occurs probability qi random variable describing total number successes µ hint prove follow outline proof theorem inequality place inequality exercises hand inequality minimized choosing µ problems balls bins problem investigate assumptions number ways placing balls distinct bins suppose balls distinct order bin matter argue number ways placing balls bins suppose balls distin balls bin ordered prove ways place balls bins hint number ways arranging distinct balls indistinguishable sticks row suppose balls identical order bin matter number ways placing balls bins hint arrangements repeated balls identical suppose balls identical bin ball number placing balls suppose balls identical bin left number ways placing balls chapter notes general methods solving probability problems discussed famous correspondence pascal fermat began book huygens rigorous probability theory began work bernoulli moivre developments theory provided laplace poisson gauss sums random variables originally studied chebyshev markov probability theory axiomatized kolmogorov bounds tails distributions provided chernoff hoeffding seminal work random combinatorial structures erdös knuth liu good references elementary combinatorics counting standard textbooks billingsley chung drake feller rozanov offer comprehensive introductions probability