programming language letter general purpose procedural computer programming language supporting structured programming lexical variable scope recursion static type prevents unintended operations design constructs map efficiently typical machine instructions lasting applications coded assembly language applications include operating systems application software computers supercomputers embedded systems originally developed bell labs dennis ritchie utilities running unix applied implementing kernel unix operating s gradually gained popularity programming languages compilers vendors majority existing computer architectures operating systems standardized ansi ansi international organization standardization imperative procedural language designed compiled straightforward compiler provide low level access memory language constructs map efficiently machine instructions minimal runtime support low level capabilities language designed encourage cross platform programming standards compliant program written portability mind compiled wide variety computer platforms operating systems source code language platforms embedded microcontrollers supercomputers overview procedural languages algol tradition facilities structured programming lexical variable scope recursion static type prevents unintended operations executable code contained subroutines called functions strictly sense functional programming function parameters passed pass reference simulated explicitly passing pointer values program source text free format semicolon statement terminator curly braces grouping blocks statements language exhibits characteristics small fixed number keywords including set control flow primitives switch user defined names distinguished keywords kind sigil large number arithmetic bitwise logic operators assignment performed single statement function return values needed typing static weakly enforced data type implicit conversions declaration syntax mimics usage context define keyword statement type declaration function keyword function parentheses argument list user defined typedef compound types heterogeneous aggregate data types struct data elements accessed assigned unit union structure overlapping members member stored valid array indexing secondary notation defined terms pointer arithmetic structs arrays class objects assigned compared single built operators array keyword definition square brackets arrays syntactically month enumerated types enum keyword freely interconvertible integers strings distinct data type conventionally implemented null terminated character arrays low level access computer memory converting machine addresses typed pointers procedures subroutines returning values special case function untyped return type void functions defined lexical scope functions function data pointers permit hoc time polymorphism preprocessor performs macro definition source code file inclusion conditional compilation basic form modularity files compiled separately linked control functions data objects visible files static extern attributes complex functionality string manipulation mathematical functions consistently delegated library routines include features languages object orientation garbage collection implemented emulated external libraries glib object boehm garbage collector relations languages languages borrowed directly indirectly including unix shell limbo lpc objective perl python rust swift verilog systemverilog hardware description languages languages drawn control structures basic features python dramatic exception express highly syntax tend combine recognizable expression statement syntax underlying type systems data models semantics radically syntax formal grammar standard endings generally boundaries significance preprocessing phase comments delimiters c99 comments delimited nest sequences characters interpreted comment delimiters inside string character literals source files declarations function definitions function definitions turn declarations statements declarations define types keywords struct union enum assign types reserve storage variables writing type variable keywords char int built types sections code enclosed braces called curly brackets limit scope declarations single statement control structures imperative language statements actions common statement expression statement consisting expression evaluated semicolon evaluation functions called variables assigned values modify normal sequential execution statements control flow statements identified reserved keywords structured programming supported conditional execution iterative execution looping statement separate initialization testing reinitialization expressions break continue leave innermost enclosing loop statement skip reinitialization structured goto statement branches directly designated label function switch selects case executed based integer expression expressions variety built operators function calls order arguments functions operands operators evaluated unspecified evaluations interleaved effects including storage variables occur sequence point sequence points include expression statement entry return function sequence points occur evaluation expressions operators comma operator permits high degree object code optimization compiler requires programmers care reliable needed programming languages kernighan ritchie introduction programming language language blemishes operators wrong precedence parts syntax standard attempt correct blemishes impact existing software appeared edition model introductory program programming textbooks programming language program prints standard output terminal screen display original version standard conforming program program preprocessing directive include compiler replace entire text stdio standard header declarations standard input output functions printf scanf angle brackets surrounding stdio stdio located search strategy prefers headers provided compiler headers opposed double quotes typically include local project specific header files function named main defined main function serves special purpose programs time environment calls main function program execution type specifier int returned invoker case time environment result evaluating main function integer keyword void parameter list function takes arguments opening curly brace definition main function calls diverts execution function named printf case supplied library printf function passed provided single argument address character string literal string literal unnamed array elements type char set automatically compiler final valued character mark array printf escape sequence translates newline character output signifies current return printf function type int silently discarded careful program test return determine printf function succeeded semicolon terminates statement closing curly brace code main function c99 specification newer main function function implicitly return reaching terminates function explicit return statement required interpreted time exit code indicating successful execution data types type static weakly typed type algol descendants pascal built types integers sizes signed unsigned floating point numbers enumerated types enum integer type char single byte characters c99 boolean datatype derived types including arrays pointers records struct unions union low level systems programming escapes type compiler attempts ensure type correctness expressions programmer override checks ways type cast explicitly convert type pointers unions reinterpret underlying bits data object declaration syntax unintuitive function pointers ritchie idea declare identifiers contexts resembling declaration reflects usual arithmetic conversions efficient code generated produce unexpected comparison signed unsigned integers equal width requires conversion signed unsigned generate unexpected signed negative pointers supports pointers type reference records address location object function memory pointers dereferenced access data stored address pointed invoke pointed function pointers manipulated assignment pointer arithmetic time representation pointer typically raw memory address augmented offset word field pointer type includes type thing pointed expressions including pointers type checked compile time pointer arithmetic automatically scaled size pointed data type pointers purposes text strings commonly manipulated pointers arrays characters dynamic memory allocation performed pointers data types trees commonly implemented dynamically allocated struct objects linked pointers pointers functions passing functions arguments higher order functions qsort bsearch callbacks invoked event handlers null pointer explicitly points valid location dereferencing null pointer undefined segmentation fault null pointer values indicating special cases pointer final node linked list error indication functions returning pointers contexts source code assigning pointer variable null pointer constant written explicit casting pointer type null macro defined standard headers conditional contexts null pointer values evaluate false pointer values evaluate true void pointers void point objects unspecified type generic data pointers size type pointed object void pointers dereferenced pointer arithmetic allowed easily contexts implicitly converted object pointer type careless pointers dangerous typically unchecked pointer variable point arbitrary location undesirable effects properly pointers point safe places point unsafe places invalid pointer arithmetic objects point continue deallocation dangling pointers initialized wild pointers directly assigned unsafe cast union corrupt pointer general permissive allowing manipulation conversion pointer types compilers typically provide options levels checking programming languages address problems restrictive reference types arrays array types traditionally fixed static size compile time c99 standard form variable length arrays allocate block memory arbitrary size time standard library malloc function treat array unification arrays pointers declared arrays dynamically allocated simulated arrays virtually interchangeable arrays accessed pointers array accesses typically checked underlying array size compilers provide bounds checking option array bounds violations common carelessly written code lead repercussions including illegal memory accesses corruption data buffer overruns time exceptions bounds checking desired manually special provision declaring multi dimensional arrays relies recursion type declare arrays arrays effectively accomplishes thing values multi dimensional array thought increasing row major order multi dimensional arrays commonly numerical algorithms applied linear algebra store matrices structure array suited task arrays passed pointers bounds array fixed values explicitly passed subroutine requires dynamically sized arrays arrays accessed double indexing workaround allocate array additional row vector pointers columns c99 introduced variable length arrays address issues ordinary arrays array pointer interchangeability subscript notation designates pointer syntactic sugar advantage compiler knowledge pointer type address points base address pointed incremented bytes defined base address incremented multiplied size element points designates element array expression contexts notable exception operand sizeof array automatically converted pointer array element implies array copied named argument function address element passed function calls pass semantics arrays passed reference size element determined applying operator sizeof dereferenced element sizeof sizeof number elements declared array determined sizeof sizeof applies array names variables declared subscripts int semantics determine entire size arrays pointers arrays created dynamic allocation malloc code sizeof arr sizeof arr arr designates pointer work compiler assumes size pointer requested array arguments sizeof converted pointers exhibit ambiguity arrays created dynamic allocation accessed pointers true array variables suffer sizeof issues array pointers apparent equivalence array pointer variables distinction array expression contexts converted pointer element pointer occupy storage array address constant pointer variable array points changed impossible assign address array array contents copied memcpy function accessing individual elements memory management functions programming language provide facilities managing memory objects stored memory distinct ways allocate memory objects static memory allocation space object provided binary compile time objects extent lifetime long binary loaded memory automatic memory allocation temporary objects stored stack space automatically freed reusable block declared exited dynamic memory allocation blocks memory arbitrary size requested time library functions malloc region memory called heap blocks persist subsequently freed reuse calling library function realloc free approaches situations trade offs static memory allocation allocation overhead automatic allocation involve overhead dynamic memory allocation great deal overhead allocation deallocation persistent nature static objects maintaining state function calls automatic allocation easy stack space typically limited transient static memory heap space dynamic memory allocation convenient allocation objects size time programs extensive automatic static allocation simplest storage managed compiler freeing programmer error prone chore manually allocating releasing storage data structures change size runtime static allocations automatic allocations c99 fixed size compile time situations dynamic allocation prior standard variable sized arrays common article malloc dynamically allocated arrays automatic allocation fail time uncontrolled consequences dynamic allocation functions return indication form null pointer required storage allocated static allocation large detected linker loader program execution static objects null pointer values program startup automatically dynamically allocated objects initialized initial explicitly initially indeterminate values typically bit pattern storage represent valid type program attempts access uninitialized undefined modern compilers detect warn problem false positives false negatives occur issue heap memory allocation synchronized actual usage program order reused pointer heap memory allocation scope overwritten free called memory recovered reuse essentially lost program phenomenon memory leak conversely memory freed continue referenced leading unpredictable typically symptoms portion program removed actual error making difficult track problem issues ameliorated languages automatic garbage collection libraries programming language libraries primary method extension library set functions contained single archive file library typically header file prototypes functions contained library program declarations special data types macro symbols functions order program library include library header file library linked program cases requires compiler flags lm shorthand link math library common library standard library iso ansi standards implementation implementations target limited environments embedded systems provide subset standard library library supports stream input output memory allocation mathematics character strings time values separate standard headers stdio interfaces standard library facilities common set library functions applications targeted unix unix systems functions provide interface kernel functions detailed standards posix single unix specification programs written wide variety libraries libraries written compilers generate efficient object code programmers create interfaces library routines higher level languages perl python file handling streams file input output language handled libraries standard library header files stdio file handling generally implemented high level works streams stream perspective data flow independent devices file concrete device high level association stream file standard library buffer memory area queue temporarily store data final destination reduces time spent waiting slower devices hard drive solid state drive low level functions standard library generally bare metal programming programming independent operating embedded programming exceptions implementations include low level language tools number tools developed programmers statements undefined behavior erroneous expressions greater rigor provided compiler tool lint leading automated source code checking auditing beneficial language tools exist lint common practice lint detect questionable code program written program passes lint compiled compiler compilers optionally warn syntactically valid constructs errors misra proprietary set guidelines avoid questionable code developed embedded systems compilers libraries operating level mechanisms performing actions standard bounds checking arrays detection buffer overflow serialization dynamic memory tracking automatic garbage collection tools purify valgrind linking libraries special versions memory allocation functions uncover runtime errors memory usage systems programming implementing operating systems embedded applications code written portability purposes needed specific code access specific hardware addresses perform type punning match externally imposed interface requirements low time demand resources website programming cgi gateway web application server browser chosen interpreted languages speed stability universal availability consequence wide availability efficiency compilers libraries interpreters programming languages implemented reference implementations python perl written layer abstraction overhead low enables programmers create efficient implementations algorithms data structures computationally intense programs gnu multiple precision arithmetic library gnu scientific library mathematica matlab completely partially written intermediate language implementations languages approach portability convenience intermediate language additional machine specific code generators features number preprocessor directives optional superfluous commas initializer lists support compilation generated code shortcomings prompted development based languages designed intermediate languages implement user applications applications written newer higher level languages languages directly indirectly influenced languages limbo lpc perl python unix shell pervasive influence syntactical languages mentioned combine statement recognizably expression syntax type systems data models large scale program structures differ radically interpreters exist including cint scripting object oriented languages popular objective extensions provided object oriented capabilities languages originally implemented source source compilers source code translated compiled compiler programming language devised bjarne stroustrup approach providing object oriented functionality syntax adds greater typing strength scoping tools object oriented programming permits generic programming templates superset supports exceptions objective originally layer remains strict superset permits object oriented programming hybrid dynamic static typing paradigm objective derives syntax smalltalk syntax involves preprocessing expressions function declarations function calls inherited syntax object oriented features originally smalltalk addition objective cilk unified parallel supersets sources ritchie dennis development language acm sigplan history programming languages conference hopl