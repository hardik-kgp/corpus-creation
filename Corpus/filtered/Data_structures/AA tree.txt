aa tree aa tree computer science form balanced tree storing retrieving ordered data efficiently aa trees named arne andersson inventor aa trees variation red black tree form binary search tree supports efficient addition deletion entries red black trees red nodes aa tree subchild red node left child simulation tree tree greatly simplifies maintenance operations maintenance algorithms red black tree shapes properly balance tree aa tree hand shapes strict requirement links red balancing rotations red black trees require bit balancing metadata node color aa trees require log log bits metadata node form integer level invariants hold aa trees level leaf node level left child parent level child equal parent level grandchild strictly grandparent node level greater children link child level equal parent called horizontal link analogous red link red black tree individual horizontal links allowed consecutive forbidden left horizontal links forbidden restrictive constraints analogous red black trees result balancing aa tree procedurally simpler balancing red black tree insertions deletions transiently aa tree unbalanced violate aa tree invariants distinct operations needed restoring balance skew split skew rotation replace subtree left horizontal link horizontal link split left rotation level increase replace subtree consecutive horizontal links fewer consecutive horizontal links implementation balance preserving insertion deletion simplified relying skew split operations modify tree needed making callers decide skew split function skew input node representing aa tree rebalanced output node representing rebalanced aa tree nil return nil nil left return level left level swap pointers horizontal left links left left return return function skew function split input node representing aa tree rebalanced output node representing rebalanced aa tree nil return nil nil nil return level level horizontal links middle node elevate return left left level level return return function split insertion insertion normal binary tree search insertion procedure stack unwinds assuming recursive implementation search easy check validity tree perform rotations horizontal left link arises skew performed horizontal links split performed incrementing level root node current subtree note code increment level continue checking validity tree modifications bubble leaves function insert input inserted root tree insert output balanced version including normal binary tree insertion procedure set result recursive correct child case node created root subtree nil create leaf node return node nil nil left insert left insert note case unspecified insert implementor desire behavior perform skew split conditionals determine rotation occur inside procedures skew split return function deletion balanced binary trees deletion internal node turned deletion leaf node swapping internal node closest predecessor successor depending tree implementor whims retrieving predecessor simply matter left link remaining links successor left null pointer aa property nodes level greater children successor predecessor node level making removal trivial balance tree approaches andersson original paper simplest actual implementations opt optimized approach removal step maintaining tree validity lower level nodes children levels missing children entire level skewed split approach favored laid conceptually easily understood separate steps decrease level skew level split level skew split entire level time node complicating code function delete input delete root tree deleted output balanced nil return delete left delete left leaf easy reduce leaf case leaf return nil nil left successor delete predecessor left delete left rebalance tree decrease level nodes level skew split nodes level decrease_level skew skew nil skew split split return function function decrease_level input tree remove links skip levels output level decreased should_be min level left level should_be level level should_be should_be level level should_be return function good deletion algorithm andersson paper performance performance aa tree equivalent performance red black tree aa tree rotations red black tree simpler algorithms tend faster balances result performance red black tree consistent performance aa tree aa tree flatter faster search times