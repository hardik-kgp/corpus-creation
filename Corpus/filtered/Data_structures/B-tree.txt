tree computer science tree balancing tree data structure maintains sorted data searches sequential access insertions deletions logarithmic time tree generalization binary search tree node children balancing binary search trees tree suited storage systems read write large blocks data discs commonly databases file systems stands established origin trees invented rudolf bayer edward mccreight  purpose efficiently managing large random access files basic assumption indexes voluminous small chunks tree fit main memory article written july published november  overview trees internal leaf nodes variable number child nodes pre defined range data inserted removed node number child nodes order maintain pre defined range internal nodes joined split range child nodes permitted trees balancing frequently balancing search trees waste space nodes lower upper bounds number child nodes typically fixed implementation   tree simply referred   tree internal node   child nodes internal node tree number keys keys separation values divide subtrees internal node  child nodes subtrees  keys   values leftmost subtree  values middle subtree   values rightmost subtree greater  number keys chosen vary displaystyle  displaystyle d displaystyle minimum number keys  displaystyle  minimum degree branching factor tree practice keys space node factor  guarantee nodes split combined internal node  displaystyle d keys adding key node accomplished splitting hypothetical   displaystyle d  key node displaystyle key nodes moving key middle parent node split node required minimum number keys internal node neighbor displaystyle keys key deleted internal node combining neighbor deleting key internal node  displaystyle  keys joining neighbor add displaystyle keys key brought neighbor parent result node  displaystyle d keys number branches child nodes node number keys stored node   tree internal nodes store key child nodes keys child nodes tree parameters  displaystyle    displaystyle d  simply highest branching order   displaystyle d  tree balanced insertion splitting overfilled node   displaystyle d  keys displaystyle key siblings inserting mid key parent depth increases root split maintaining balance tree balanced deletion merging redistributing keys siblings maintain displaystyle key minimum root nodes merger reduces number keys parent forcing merge redistribute keys siblings change depth occurs root children displaystyle transitionally  displaystyle  keys case siblings parent merged reducing depth depth increase slowly elements tree increase depth infrequent leaf nodes node farther root trees substantial advantages alternative implementations time access data node greatly exceeds time spent processing data cost accessing node amortized multiple operations node occurs node data secondary storage disk drives maximizing number keys internal node height tree decreases number expensive node accesses reduced addition rebalancing tree occurs maximum number child nodes depends stored child node size disk block analogous size secondary storage   trees easier explain practical trees secondary storage large number child nodes improve performance variants term tree refer specific design refer general class designs narrow sense tree stores keys internal nodes store keys records leaves general class includes variations tree tree tree copies keys stored internal nodes keys records stored leaves addition leaf node include pointer leaf node speed sequential access tree balances neighboring internal nodes internal nodes densely packed variant ensures root nodes     knuth   costly operation inserting node tree splitting node trees created postpone splitting operation long maintain splitting node keys shared node spill operation costly split requires shifting keys existing nodes allocating memory inserting checked node free space key inserted node node  keys order tree maximum number pointers subtrees node checked sibling exists free space sibling  keys keys redistributed sibling nodes evenly purpose  keys current node key inserted key parent node keys sibling node ordered array  keys array split half   lowest keys stay current node middle key inserted parent rest sibling newly inserted key places situation sibling left analogous sibling nodes nodes current node sibling split key shifted tree parent node parent spill split operation propagates root node deleting nodes complex inserting trees turned order statistic trees rapid searches nth record key order counting number records records operations tree usage databases time search sorted file sorting searching algorithms characterized number comparison operations performed order notation binary search sorted table records roughly log  comparisons table    records specific record located  comparisons log      large databases historically disk drives time read record disk drive exceeds time needed compare keys record time read record disk drive involves seek time rotational delay seek time   milliseconds rotational delay averages half rotation period  rpm drive rotation period   milliseconds drive seagate st3500320ns track track seek time   milliseconds average reading seek time   milliseconds simplicity assume reading disk takes  milliseconds naively time locate record  disk reads times  milliseconds disk read   seconds time bad individual records grouped disk block disk block  kilobytes record  bytes  records stored block disk read time entire block disk head position disk blocks read delay  records block  comparisons disk reads comparisons disk block read speed search   comparisons required disk access sped speeds search improvement initial disk reads narrowed search range factor improved creating auxiliary record disk block called sparse auxiliary  size original database searched finding entry auxiliary block search main database searching auxiliary search block main database cost disk read hold   entries  comparisons main database comparisons auxiliary disk block searched disk reads desired record accessed  disk reads trick creating auxiliary repeated auxiliary auxiliary aux aux  entries fit disk block reading  disk blocks desired record read  blocks blocking core idea creation tree disk blocks hierarchy levels reading searching block aux aux root tree identifies relevant block aux level reading searching aux block identifies relevant block read final level leaf level identifies record main database  milliseconds  milliseconds record auxiliary indices turned search problem binary search requiring roughly log  disk reads requiring log disk reads blocking factor number entries block  entries block log      reads practice main database frequently searched aux aux aux reside disk cache incur disk read insertions deletions database change compiling simple changed managing database complicated deleting records database easy stay record marked deleted database remains sorted order large number deletions searching storage efficient insertions slow sorted sequential file room inserted record inserting record record requires shifting records operation expensive practical solution leave spaces densely packing records block block free space subsequent insertions spaces marked deleted records insertions deletions fast long space block insertion fit block free space nearby block auxiliary indices adjusted hope space nearby lot blocks reorganized alternatively sequence disk blocks advantages tree usage databases tree ideas tree keys sorted order sequential traversing hierarchical minimize number disk reads partially blocks speed insertions deletions balanced recursive algorithm addition tree minimizes waste making interior nodes half tree handle arbitrary number insertions deletions technical description terminology literature trees uniform terminology folk zoellick   bayer mccreight  comer  define order tree minimum number keys root node folk zoellick  points terminology ambiguous maximum number keys clear order  tree hold maximum  keys maximum  keys knuth   avoids problem defining order maximum number children maximum number keys term leaf inconsistent bayer mccreight  considered leaf level lowest level keys knuth considered leaf level level lowest keys folk zoellick   implementation choices designs leaves hold entire data record designs leaves hold pointers data record choices fundamental idea tree simplicity authors assume fixed number keys fit node basic assumption key size fixed node size fixed practice variable length keys employed folk zoellick   definition knuth definition tree order tree satisfies properties node children leaf node root  child nodes root children leaf node leaf node children  keys leaves level carry internal node keys separation values divide subtrees internal node  child nodes subtrees  keys   values leftmost subtree  values middle subtree   values rightmost subtree greater  internal nodes internal nodes nodes leaf nodes root node represented ordered set elements child pointers internal node maximum children minimum children number elements  number child pointers number elements      internal node half relationship implies half nodes joined legal node node split legal nodes room push element parent properties delete insert values tree adjust tree preserve tree properties root node root node number children upper limit internal nodes lower limit fewer  elements entire tree root node tree children leaf nodes knuth terminology leaf nodes carry internal nodes level leaves called leaves authors nodes store keys    root pointers nodes carrying tree depth  hold times items tree depth cost search insert delete operations grows depth tree balanced tree cost grows slowly number elements balanced trees store values leaf nodes kinds nodes leaf nodes internal nodes trees values node tree leaf nodes case worst case heights  height classic tree tree data structure terminology tree height definition  number entries tree maximum number children node node  keys induction tree height nodes completely filled   entries case height minimum height tree log   displaystyle h_ mathrm min lceil log _  rceil  displaystyle minimum number children internal root node ordinary tree  displaystyle left lceil  rceil comer   cormen    worst case height maximum height tree log   displaystyle h_ mathrm max left lfloor log _ frac   rfloor algorithms search searching searching binary search tree starting root tree recursively traversed level search reduces field view child pointer subtree range includes search subtree range defined values keys contained parent node limiting values separation values binary search typically nodes separation values child tree insertion insertions start leaf node insert element search tree leaf node element insert element node steps node fewer maximum allowed number elements room element insert element node keeping node elements ordered node evenly split nodes single median chosen leaf elements element values median left node values greater median node median acting separation separation inserted node parent split node parent node root create root node increasing height tree splitting root creates root single separator children lower bound size internal nodes apply root maximum number elements node  node split element moves parent element divide maximum number  elements legal nodes number odd  nodes    elements legal node element legal      elements node half number  minimum number elements allowed node alternative algorithm supports single pass tree root node insertion place splitting nodes encountered preemptively prevents recall parent nodes memory expensive nodes secondary storage algorithm send element parent split remaining  elements legal nodes adding element requires    accounts textbooks impose requirement defining trees deletion popular strategies deletion tree locate delete item restructure tree retain invariants single pass tree entering visiting node restructure tree key deleted encountered deleted triggering restructuring algorithm strategy special cases deleting element element internal node separator child nodes deleting element node minimum number elements children procedures cases order deletion leaf node search delete leaf node simply delete node underflow rebalance tree rebalancing deletion deletion internal node element internal node acts separation subtrees replacement separation note largest element left subtree separator likewise smallest element subtree greater separator elements leaf nodes separator subtrees algorithmically choose separator largest element left subtree smallest element subtree remove leaf node replace element deleted separator previous step deleted element separator leaf node leaf node deficient fewer required number nodes rebalance tree starting leaf node rebalancing deletion rebalancing starts leaf proceeds root tree balanced deleting element node brought minimum size elements redistributed bring nodes minimum redistribution involves moving element sibling node minimum number nodes redistribution operation called rotation sibling spare element deficient node merged sibling merge parent lose separator element parent deficient rebalancing merging rebalancing continue root minimum element count apply root making root deficient node problem algorithm rebalance tree deficient node sibling exists minimum number elements rotate left copy separator parent deficient node separator moves deficient node minimum number elements replace separator parent element sibling sibling loses node minimum number elements tree balanced deficient node left sibling exists minimum number elements rotate copy separator parent start deficient node separator moves deficient node minimum number elements replace separator parent element left sibling left sibling loses node minimum number elements tree balanced siblings minimum number elements merge sibling sandwiching separator parent copy separator left node left node deficient node sibling minimum number elements elements node left node left node maximum number elements node remove separator parent child parent loses element parent root elements free merged node root tree shallower parent fewer required number elements rebalance parent note rebalancing operations trees rotation parent copy key tree siblings merged siblings sequential access freshly loaded databases tend good sequential behavior behavior increasingly difficult maintain database grows random performance challenges initial construction common special case adding large pre sorted data initially tree simply perform series successive inserts inserting sorted data tree composed half nodes special bulk loading algorithm produce efficient tree higher branching factor input sorted insertions rightmost edge tree time node split guaranteed insertions place left half bulk loading advantage splitting overfull nodes evenly split unevenly leave left node completely create node keys child violation usual tree rules bulk loading tree composed completely nodes rightmost node level nodes half establish normal tree rules combine nodes guaranteed left siblings divide keys produce nodes half node lacks left sibling root permitted half filesystems addition databases tree variants filesystems quick random access arbitrary block file basic problem turning file block displaystyle address disk block cylinder head sector address operating systems require user allocate maximum size file file created file allocated contiguous disk blocks case convert file block address displaystyle disk block address operating simply adds file block address displaystyle address disk block constituting file scheme simple file exceed created size operating systems file grow disk blocks contiguous mapping logical blocks physical blocks involved dos simple file allocation table fat fat entry disk block entry identifies block file block disk block file allocation file represented linked list table order disk address file block displaystyle operating disk utility sequentially follow file linked list fat worse free disk block sequentially scan fat dos huge penalty disks files small fat entries short file chains fat12 filesystem floppy disks early hard disks   entries fat resident memory disks bigger fat architecture began confront penalties large disk fat perform disk reads learn disk location file block read written tops  tenex   level tree similarities tree disk block   bit file fit    word block file directory point physical disk block file fit   directory point aux  null block allocated point physical address block file fit   directory point block holding aux aux entry null point aux physical disk block   word file located disk reads read apple filesystem hfs microsoft ntfs aix jfs2 linux filesystems btrfs ext4 trees trees hfs reiser4 file systems dragonfly bsd hammer file modified tree variations access concurrency lehman yao read locks avoided concurrent access greatly improved linking tree blocks level pointer tree structure insertion search operations descend root leaf write locks required tree block modified maximizes access concurrency multiple users consideration databases tree based isam storage methods cost improvement removed btree normal operations strategies implement node merging source code united states patent  granted  appears meta access method concurrent tree access modification locks technique accesses tree upwards searches updates additional memory indexes point blocks level block cache reorganization deletes needed pointers block lehman yao