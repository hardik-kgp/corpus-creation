binary search tree computer science binary search trees bst called ordered sorted binary trees type container data structure stores items numbers names memory fast lookup addition removal items implement dynamic sets items lookup tables finding item key finding phone number person binary search trees keys sorted order lookup operations principle binary search key tree place insert key traverse tree root leaf making comparisons keys stored nodes tree deciding basis comparison continue searching left subtrees average comparison operations skip half tree lookup insertion deletion takes time proportional logarithm number items stored tree linear time required items key unsorted array slower operations hash tables variants binary search tree studied computer science article deals basic type making references advanced types definition binary search tree rooted binary tree internal nodes store key optionally distinguished trees commonly denoted left tree additionally satisfies binary search property states key node greater equal key stored left tree equal key stored tree leaves final nodes tree key structure distinguish frequently represented node record single data element sequencing purposes nodes compared keys records major advantage binary search trees data structures sorting algorithms search algorithms order traversal efficient easy code binary search trees fundamental data structure construct abstract data structures sets multisets associative arrays inserting searching element binary search tree key visited node compared key element inserted shape binary search tree depends order insertions deletions degenerate long intermixed sequence random insertion deletion expected height tree approaches square root number keys grows faster log lot prevent degeneration tree worst case time complexity details types order relation binary search requires order relation element item compared element sense total preorder element effectively takes place comparison called key duplicates elements key allowed tree depend order relation application context binary search trees total preorder realized flexibly comparison subroutine operations binary search trees support main operations insertion elements deletion elements lookup checking key searching searching binary search tree specific key programmed recursively iteratively examining root node tree null key searching exist tree key equals root search successful return node key root search left subtree key greater root search subtree process repeated key remaining subtree null searched key null subtree reached key tree easily expressed recursive algorithm implemented python algorithm implemented iteratively examples rely order relation total order order relation total preorder reasonable extension functionality case equality search leaves direction user binary tree sort equipped comparison function stable worst case algorithm search root tree leaf farthest root search operation takes time proportional tree height tree terminology average binary search trees nodes log height worst case binary search trees height unbalanced tree resembles linked list degenerate tree insertion insertion search key equal root search left subtrees eventually reach external node add key pair encoded record newnode left child depending node key examine root recursively insert node left subtree key root subtree key greater equal root typical binary search tree insertion performed binary tree alternatively recursive version implemented pointer pointer track code avoid explicit checking handling case insert node tree root destructive procedural variant modifies tree place constant heap space iterative version constant stack space prior version tree lost alternatively python reconstruct ancestors inserted node reference original tree root remains valid making tree persistent data structure rebuilt log space average case worst case version operation requires time proportional height tree worst case log time average case trees time worst case explain insertion order insert node tree key compared root key root compared key root left child key greater compared root child process continues node compared leaf node node left child depending key key leaf key inserted leaf left child leaf child ways inserting nodes binary tree inserting nodes leaves time preserving bst structure deletion removing node binary search tree mandatory maintain order sequence nodes possibilities method proposed hibbard guarantees heights subject subtrees changed cases deleting node children simply remove node tree deleting node child remove node replace child deleting node children node deleted delete choose order predecessor node order successor node replacement node figure copy user values child simply remove previous parent child child replace parent cases root replacement node root nodes children harder delete node order successor subtree left child node order predecessor left subtree child case node child delete simpler cases consistently order successor order predecessor instance child case lead unbalanced tree implementations select times runtime analysis operation traverse tree leaf possibility worst case requires time proportional height tree require node children single path visit node traversal binary search tree created elements retrieved order recursively traversing left subtree root node accessing node recursively traversing subtree node continuing pattern node tree recursively accessed binary trees conduct pre order traversal post order traversal binary search trees order traversal binary search tree result sorted list node items numbers strings comparable items code order traversal python callback function programmer wishes node printing screen node tree traversal requires time visit node algorithm asymptotically optimal traversal implemented iteratively applications greater equal search approximative search operation single step iterative traversal implemented callback construct takes average log worst case verification binary tree determine bst problem simple recursive solution bst property node subtree larger current node node left subtree smaller current node key figuring tree bst greedy algorithm simply traverse tree node check node larger left child smaller child work cases tree tree node meets condition node larger left child smaller child hold bst subtree node violation bst property making decision based solely values node children flowing parent case tree remember node node violating bst property contract condition check node node left child parent smaller equal parent pass parent subtree nodes subtree greater parent node child parent larger parent pass parent left subtree nodes subtree lesser parent recursive solution explain node key node key distinct elements bst elements node key places initial function essentially creating valid range starting min_value max_value shrinking node recursively pointed traversal order traversal binary search tree returns nodes sorted visited node traversing tree check key smaller smaller equal duplicates allowed tree compared current key examples applications sort binary search tree implement simple sorting algorithm heapsort insert values sort ordered data structure case binary search tree traverse order worst case time build_binary_tree feed sorted list values chains linked list left subtrees build_binary_tree yields tree schemes overcoming flaw simple binary trees common balancing binary search tree procedure tree worst case time log asymptotically optimal comparison sort practice overhead time space tree based sort node allocation inferior asymptotically optimal sorts heapsort static list sorting hand efficient methods incremental sorting adding items list time keeping list sorted times priority queue operations binary search trees serve priority queues structures insertion arbitrary key lookup deletion minimum maximum key insertion works explained min walks tree left pointers hitting leaf max analogous follow pointers delete min max simply minimum maximum delete insertion deletion logarithmic time binary heap binary heap priority queue implementations single tree support min max delete min delete max time making binary search trees suitable double ended priority queues types types binary search trees avl trees red black trees forms balancing binary search trees splay tree binary search tree automatically moves frequently accessed elements nearer root treap tree heap node holds randomly chosen priority parent node higher priority children tango trees trees optimized fast searches trees binary search trees optimized reduce storage space overhead memory databases degenerate tree tree parent node child node unbalanced worst case performance degrades linked list add node function handle balancing easily construct degenerate tree feeding data sorted performance measurement tree essentially behave linked list data structure performance comparisons heger presented performance comparison binary search trees treap average performance red black tree smallest number performance variations optimal binary search trees plan modifying search tree item accessed construct optimal binary search tree search tree average cost item expected search cost minimized estimates search costs considerably speed lookups average bst english spell checker balance tree based word frequency text corpora placing root agerasia leaves tree compared huffman trees seek place frequently items root order produce dense encoding huffman trees store data elements leaves elements ordered sequence elements tree accessed unknown advance splay trees asymptotically good static search tree construct sequence lookup operations alphabetic trees huffman trees additional constraint order equivalently search trees modification elements stored leaves faster algorithms exist optimal alphabetic binary trees oabts