bitboard bitboard specialized bit array data structure commonly computer systems play board games bit corresponds game board space piece parallel bitwise operations set query game state determine moves plays game bits bitboard relate rules game forming game position bitboards commonly masks transform answer queries positions bitboards applicable game progress represented state presence pieces discrete spaces gameboard mapping space states bits data structure bitboards efficient alternative board representation traditional mailbox representation piece space board array element bitboards effective bits states board fit single word double word cpu architecture single bitwise operators build query game states computer game implementations bitboards chess checkers othello word games scheme employed checkers programs s mid s facto standard game board representation computer automatons description bitboard specialized bit field format packs multiple boolean variables machine word typically representing position board game state game bit represents space bit positive property space true bitboards computer answer questions game state bitwise operation chess program white player pawns center board center squares compare bitboard player pawns center board bitwise operation center pawns result bits equal multiple bitboards represent properties spaces board special temporary bitboards temporary variables represent local properties hold intermediate collated efficacy bitboards augmented properties implementation bitboards fast incrementally update flipping bits source destination positions bitboard piece location piece moved bitmaps representing static properties spaces attacked piece type position chessboard pre collated stored table answering question legal moves knight space e4 answered single memory fetch bitfield implementations advantage presence fullword bit bit bitwise logical operations modern cpu architectures order efficient bitboards effective earlier bit minicomputer microprocessor architectures implementation issues result compression encoding contents massive tables probability transcription encoding errors bitboard programs tedious software developers write debug auxiliary generative methods application required build tables processor pros bitboard representations parallel bitwise operations cpus complete cycle fully pipelined cached cpus xor modern cpus instruction pipelines queue instructions execution processor multiple execution units perform instruction cycle instruction pipeline normal instruction sequences branches pipeline branch mispredicted bitboard operations require fewer conditionals increase pipelining effective multiple execution units cpus cpus bit width designed carry bitwise operations cycle width bit cpu bit operations occur instruction support higher lower width instructions bit cpus bit instructions cycle handicapped compared bit instructions bitboard larger width instruction set multiple instructions required perform width operation program bit bitboards faster bit processor bit processor cons bitboard representations longer code source object code long bit twiddling sequences technically tricky write debug bitboards sparse single bit bitboard implementations memory intensive issues increase cache misses cache threshing processor hardware instructions leading zeros count count zeros implementation handicapped operations extremely inefficient code assembly language loops cache memory pros bitboards require memory piece list board data structures execution efficient loop compare operations reduced single small number bitwise operation mailbox determine piece attacks space requires generating looping legal moves piece comparing space bitboards legal moves piece stored bitmap map anded bitmap space result piece attacks space cons games writing bitboard engine requires fair source code including data tables longer compact mailbox enumeration implementation mobile devices cell phones limited number registers processor instruction cache problem sized computers cache misses level level cache potential problem major drawback machines instruction cache issue incremental update kinds bitboards derived elaborate process cross correlation attack maps chess reforming maps change game state prohibitively expensive derived bitmaps incrementally updated process requires intricate precise code faster execute bitmaps changed spaces bitmaps board change incremental update bitmapped representation efficient older mailbox representation update intrinsically local incremental precomputed bitmaps table lookup kinds bitmaps depend board configurations precomputed retrieved table lookup collated state change board spaces attacked knight king located spaces chessboard require enumeration chess bitboards obvious simplest representation configuration pieces chessboard list array pieces conveniently searchable order smallest largest maps piece location board analogously collating spaces attacked piece requires serial enumeration spaces piece scheme called mailbox addressing separate lists maintained white black pieces white black pawns maps updated requires linear search piece captured piece list advantage mailbox simple code disadvantage linear lookups slow faster elaborate data structures map pieces locations called bitboards standard bitboard representations bit bit word double word bit architectures square chessboard mapping bits squares broad convention bits squares left bit represents square bit square h1 bit square a8 bit square h8 configurations board represented bitboards including locations kings white pawns black pawns bitboards piece types combinations pieces white pieces attack bitboards universal bitboard space pieces attacking space inverse bitboard spaces attacked piece space piece bitboards constants representing rank bits positions local transitional bitboards spaces adjacent king attacked opposing pieces collated convenient bitboards determining piece enprise bitboards friendly pieces guarding space opposing pieces attacking space matching pieces determine target piece space enprise drawbacks standard bitboards collating attack vectors sliding pieces rook bishop queen indefinite number attack spaces depending occupied spaces requires lengthy sequences masks shifts complements piece auxiliary bitboard representations acknowledgement code size computing complexity generating bitboards attack vectors sliding pieces alternate bitboard data structures devised collate bitboard representations knights kings pawns board configurations unaffected auxiliary bitboards sliding pieces rotated bitboards rotated bitboards complementary bitboard data structures enable tabularizing sliding piece attack vectors file attack vectors rooks diagonal anti diagonal attack vectors bishops rank attacks rooks indexed standard bitboards bitboards single table lookup replaces lengthy sequences bitwise operations bitboards rotate board occupancy configuration degrees degrees degrees standard bitboard byte rank chess board bitboard easy determine rook attacks rank table indexed occupied square occupied positions rank rook attacks occupied square rotating bitboard degrees rook attacks file examined adding bitboards rotated degrees degrees degrees produces bitboards diagonals easy examine queen examined combining rook bishop attacks rotating bitboard inelegant transformation dozens instructions direct hashing rank file attack vectors rooks diagonal anti diagonal attack vectors bishops separately masked indices hash table precomputed attack vectors depending occupancy bits rooks bits bishops attack vector piece union unidirectional vectors indexed hash table number entries hash table modest order k bytes hash function computations lookups piece required hashing scheme employed magic bitboards magic bitboards extrapolation time space tradeoff direct hashing lookup attack vectors transmutation attack vector hash table magic misnomer simply refers generation perfect hash function conjunction tricks reduce potential size hash table stored memory exabytes observation outer squares eighth ranks files irrelevant occupancy attack vector piece attacks squares depending blocking pieces occupancy eliminated consideration leaving x6 squares bits hash function schemes require perfect hashing function exhaustive process enumeration partly algorithmic partly trial error generate hash function intractable issue remains active tables size entries cases huge relative lower level cache sizes modern chip architectures cache flooding magic bitboards application provide performance gain modest hashing schemes rotated bitboards games games chess benefit bitboards connect efficient testing consecutive discs shift operations direction conway game life alternative arrays othello reversi reversi article word games efficient generation valid plays simple logical operations