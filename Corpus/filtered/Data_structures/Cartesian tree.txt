cartesian tree computer science cartesian tree binary tree derived sequence numbers uniquely defined properties heap ordered symmetric order traversal tree returns original sequence introduced vuillemin context geometric range searching data structures cartesian trees definition treap randomized binary search tree data structures binary search problems cartesian tree sequence constructed linear time stack based algorithm finding nearest smaller values sequence definition cartesian tree sequence distinct numbers uniquely defined properties cartesian tree sequence node number sequence node single sequence symmetric order traversal tree original sequence left subtree consists values earlier root sequence order subtree consists values root ordering constraint holds lower node tree tree heap property parent root node smaller node based heap property root tree smallest number sequence tree defined recursively root minimum sequence left subtrees cartesian trees subsequences left root properties uniquely define cartesian tree sequence numbers repetitions cartesian tree defined determining consistent tie breaking rule instance determining equal elements treated smaller applying rules cartesian tree figure range searching lowest common ancestors cartesian trees efficient data structure range minimum queries range searching problem involving queries minimum contiguous subsequence original sequence cartesian tree minimum lowest common ancestor leftmost rightmost values subsequence instance subsequence sequence illustration minimum subsequence forms lowest common ancestor leftmost rightmost values lowest common ancestors constant time query data structure takes linear space store constructed linear time bounds hold range minimization problem bender farach colton reversed relationship data structure problems showing lowest common ancestors input tree solved efficiently applying tree based technique range minimization data structure euler tour technique transform input tree sequence finds range minima sequence sequence transformation special form adjacent numbers representing heights adjacent nodes tree differ advantage data structure solve range minimization problem sequences special form cartesian trees transform range minimization problem lowest common ancestor problem apply euler tour technique transform problem range minimization sequences special form range minimization problem alternative interpretation terms dimensional range searching collection finitely points cartesian plane form cartesian tree sorting points coordinates coordinates order sequence values tree formed subset input points vertical slab defined inequalities leftmost point minimum coordinate rightmost point maximum coordinate lowest common ancestor cartesian tree bottommost point slab sided range query task list points region bounded inequalities answered finding bottommost point comparing coordinate point lies sided region continuing recursively slabs bounded leftmost rightmost points slab identified points sided region listed constant time point construction lowest common ancestors cartesian tree construct data structure linear space distances pairs points ultrametric space queried constant time query distance ultrametric minimax path weight minimum spanning tree metric minimum spanning tree construct cartesian tree root node represents heaviest edge minimum spanning tree removing edge partitions minimum spanning tree subtrees cartesian trees recursively constructed subtrees form children root node cartesian tree leaves cartesian tree represent points metric space lowest common ancestor leaves cartesian tree heaviest edge points minimum spanning tree weight equal distance points minimum spanning tree edge weights sorted cartesian tree constructed linear time treaps cartesian tree binary tree natural binary search tree ordered sequence values defining cartesian tree based values form search keys binary search tree work cartesian tree sorted sequence path rooted leftmost endpoint binary searching tree degenerates sequential search path generate balanced search trees generating priority values search key key sorting inputs key values sequence priorities generate cartesian tree construction equivalently viewed geometric framework coordinates set points search keys coordinates priorities idea applied seidel aragon suggested random numbers priorities data structure random choice called treap combination binary search tree binary heap features insertion treap performed inserting key leaf existing tree choosing priority performing tree rotation operations path node root tree repair violations heap property caused insertion deletion performed constant change tree sequence rotations single path tree priorities key chosen randomly independently key inserted tree cartesian tree properties random binary search tree tree computed inserting keys randomly chosen permutation starting tree insertion leaving previous tree structure unchanged inserting node leaf tree random binary search trees studied longer behave search trees logarithmic depth high probability good behavior carries treaps suggested aragon seidel reprioritize frequently accessed nodes causing root treap speeding future accesses keys efficient construction cartesian tree constructed linear time input sequence method simply process sequence values left order maintaining cartesian tree nodes processed structure upwards traversal tree process start node representing prior sequence follow path node root tree finding smaller node parent previous child left child total time procedure linear time spent searching parent node charged number nodes removed rightmost path tree alternative linear time construction algorithm based nearest smaller values problem input sequence define left neighbor occurs prior smaller closer position smaller neighbor defined symmetrically sequence left neighbors algorithm maintains stack subsequence input sequence stack popped element smaller pushed stack left neighbor element time pushed neighbors applying stack algorithm reverse sequence parent cartesian tree left neighbor neighbor whichever exists larger left neighbors constructed efficiently parallel algorithms formulation develop efficient parallel algorithms cartesian tree construction linear time algorithm cartesian tree construction based divide conquer algorithm recursively constructs tree half input merging trees spine left tree left spine tree performing standard merging operation algorithm parallelizable level recursion problems computed parallel merging operation efficiently parallelized application sorting levcopoulos petersson sorting algorithm based cartesian trees algorithm based tree maximum root modified straightforwardly support cartesian tree convention minimum root consistency modified version algorithm levcopoulos petersson algorithm viewed version selection sort heap sort maintains priority queue candidate minima step finds removes minimum queue moving output sequence algorithm priority queue consists elements parent cartesian tree removed algorithm consists steps construct cartesian tree input sequence initialize priority queue initially tree root priority queue remove minimum priority queue add output sequence add cartesian tree children priority queue levcopoulos petersson input sequences sorted size priority queue remain small allowing method advantage sorted input worst case running time algorithm log average values sequence number consecutive pairs sequence values bracket prove lower bound stating ω comparison based sorting algorithm ω log comparisons inputs