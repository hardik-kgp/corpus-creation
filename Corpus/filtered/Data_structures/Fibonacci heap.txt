fibonacci heap computer science fibonacci heap data structure priority queue operations consisting collection heap ordered trees amortized running time priority queue data structures including binary heap binomial heap michael fredman robert tarjan developed fibonacci heaps published scientific journal fibonacci heaps named fibonacci numbers running time analysis fibonacci heap minimum operation takes constant amortized time insert decrease key operations work constant amortized time deleting element special case deleting minimum element works log amortized time size heap starting data structure sequence insert decrease key operations delete operations log worst case time maximum heap size binary binomial heap sequence operations log time fibonacci heap binary binomial heap smaller constant factor merge fibonacci heaps constant amortized time improving logarithmic merge time binomial heap improving binary heaps handle merges efficiently fibonacci heaps priority queues improves asymptotic running time algorithms dijkstra algorithm computing shortest path nodes graph compared algorithm slower priority queue data structures structure fibonacci heap collection trees satisfying minimum heap property key child greater equal key parent implies minimum key root trees compared binomial heaps structure fibonacci heap flexible trees prescribed shape extreme case heap element separate tree flexibility operations executed lazy manner postponing work operations merging heaps simply concatenating lists trees operation decrease key cuts node parent forms tree point order introduced heap achieve desired running time degrees nodes degree number children low node degree log size subtree rooted node degree fibonacci number achieved rule cut child root node child cut node cut parent root tree proof degree bounds number trees decreased operation delete minimum trees linked result relaxed structure operations long time amortized running time analysis potential method pretend fast operations bit longer additional time combined subtracted actual running time slow operations time saved measured moment potential function potential fibonacci heap potential number trees fibonacci heap number marked nodes node marked children cut node child node roots unmarked amortized time operation sum actual time times difference potential constant chosen match constant factors notation actual time root tree heap unit time stored unit time link tree tree amortized time marked node units time stored cut node parent node root unit time remain stored root implementation operations fast deletion concatenation roots trees linked circular doubly linked list children node linked list node maintain number children node marked maintain pointer root minimum key operation minimum trivial pointer node change potential heap actual amortized cost constant mentioned merge implemented simply concatenating lists tree roots heaps constant time potential change leading constant amortized time operation insert works creating heap element merge takes constant time potential increases number trees increases amortized cost constant operation extract minimum delete minimum operates phases root minimum element remove children roots trees number children takes time process roots potential increases amortized running time phase log complete extract minimum operation update pointer root minimum key roots check phase decrease number roots successively linking roots degree roots degree child smaller key remains root degree increase repeated root degree trees degree efficiently array length log pointer root degree root degree linked array updated actual running time log number roots phase log roots degree difference potential function phase log amortized running time log log large choice simplifies log phase check remaining roots minimum takes log time potential change amortized running time extract minimum log operation decrease key node decrease key heap property violated key smaller key parent node cut parent parent root marked marked cut parent marked continue upwards reach root unmarked node set minimum pointer decreased minimum process create number trees trees marked originally root unmarked node marked number marked nodes combining potential actual time perform cutting large choice amortized running time constant finally operation delete implemented simply decreasing key element deleted minus infinity turning minimum heap extract minimum remove amortized running time operation log proof degree bounds amortized performance fibonacci heap depends degree number children tree root log size heap size tree rooted node degree heap size fibonacci number degree bound fact easily proved induction φ displaystyle f_ geq varphi integers displaystyle geq φ displaystyle varphi sqrt doteq φ displaystyle geq f_ geq varphi log base φ displaystyle varphi sides log φ displaystyle leq log _ varphi required node heap root main trees define size size tree rooted number descendants including prove induction height length longest simple path descendant leaf size degree base case height size inductive case suppose positive height degree children indexed order times children earliest latest respective degrees claim child children degree time trees combined degrees roots equal degree time child time lost child guaranteed marking process current degree proves claim heights strictly apply inductive hypothesis size nodes contribute size size size displaystyle textbf size geq sum _ textbf size y_ geq sum _ f_ sum _ f_ routine induction proves displaystyle sum _ f_ f_ displaystyle geq desired lower bound size worst case fibonacci heaps efficient drawbacks mentioned paper pairing heap form adjusting heap complicated coding efficient practice compared theoretically efficient forms heaps simplest version require storage manipulation pointers node compared pointers node needed structures structures referred binary heap binomial heap pairing heap brodal heap rank pairing heap total running time sequence operations starting structure bounded bounds operations sequence long complete delete delete minimum linear running time worst case reason fibonacci heaps amortized data structures real time systems create data structure worst case performance fibonacci heap amortized performance structure brodal queue creator complicated applicable practice created strict fibonacci heap simpler compared brodal structure worst case bounds simpler structure experiments practice strict fibonacci heap performs slower complicated brodal queue slower basic fibonacci heap relaxed heaps driscoll good worst case performance fibonacci heap operations merge summary running times time complexities heap data structures function names assume min heap meaning θ big notation practical considerations fibonacci heaps reputation slow practice large memory consumption node high constant factors operations experimental fibonacci heaps efficient practice derivatives including quake heaps violation heaps strict fibonacci heaps rank pairing heaps efficient pairing heaps array based heaps