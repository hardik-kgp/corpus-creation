hash array mapped trie hash array mapped trie hamt implementation associative array combines characteristics hash table array mapped trie refined version general notion hash tree operation hamt array mapped trie keys hashed ensure distribution keys constant key length typical implementation hamt array mapped trie node table fixed number slots slot nil pointer pointer node commonly  allocating space pointers node expensive node bitmap bits long bit presence nil pointer array pointers equal length number bitmap hamming weight advantages hamts hash array mapped trie achieves hash table speed memory economically hash table periodically resized expensive operation hamts grow dynamically generally hamt performance improved larger root table multiple slots hamt variants root grow lazily negligible impact performance implementation details implementation hamt involves population count function counts number binary representation number operation instruction set architectures high level languages population count implemented software  time series shift add instructions perform operation order magnitude slower implementations programming languages clojure scala frege persistent variant hash array mapped native hash map type haskell library unordered containers implement persistent map set data structures haskell library stm containers adapts algorithm context software transactional memory hamt library based clojure implementation rubinius implementation ruby includes hamt written ruby  primitives large maps erlang hamt representation internally release   pony programming language hamt hash map persistent collections package concurrent lock free version hash trie called ctrie mutable thread safe implementation ensures progress data structure proven correct ctrie operations atomicity linearizability lock freedom properties