hash table computing hash table hash map data structure implements associative array abstract data type structure map keys values hash table hash function compute called hash code array buckets slots desired ideally hash function assign key unique bucket hash table designs employ imperfect hash function hash collisions hash function generates key collisions accommodated dimensioned hash table average cost number instructions lookup independent number elements stored table hash table designs arbitrary insertions deletions key pairs amortized constant average cost operation situations hash tables turn average efficient search trees table lookup structure reason kinds computer software associative arrays database indexing caches sets hashing idea hashing distribute entries key pairs array buckets key algorithm computes suggests entry key array_size steps hash hashfunc key hash array_size method hash independent array size reduced number  array_size  modulo operator case array size power remainder operation reduced masking improves speed increase problems poor hash function choosing hash function basic requirement function provide uniform distribution hash values uniform distribution increases number collisions cost resolving uniformity difficult ensure design evaluated empirically statistical tests pearson chi squared test discrete uniform distributions distribution uniform table sizes occur application dynamic resizing exact doubling halving table size hash function uniform size power computed range bits hash function hand hashing algorithms prefer size prime number modulus operation provide additional mixing poor hash function open addressing schemes hash function avoid clustering mapping keys consecutive slots clustering lookup cost skyrocket load factor low collisions infrequent popular multiplicative hash claimed poor clustering behavior cryptographic hash functions believed provide good hash functions table size modulo reduction bit masking risk malicious users sabotage network service submitting requests designed generate large number collisions server hash tables risk sabotage avoided cheaper methods applying secret salt data universal hash function drawback cryptographic hashing functions slower compute cases uniformity size cryptographic hashing function preferable perfect hash function keys ahead time perfect hash function create perfect hash table collisions minimal perfect hashing location hash table perfect hashing constant time lookups cases contrast chaining open addressing methods time lookup low average large instance keys hash values key statistics critical statistic hash table load factor defined load factor displaystyle text load factor frac number entries occupied hash table number buckets load factor grows larger hash table slower fail work depending method expected constant time property hash table assumes load factor bound fixed number buckets time lookup grows number entries desired constant time achieved implementations solution automatically grow double size table load factor bound reached forcing hash entries real default load factor hashmap    offers good trade time space costs load factor examine variance number entries bucket tables   entries   buckets entry bucket entries bucket hashing working low load factor beneficial load factor approaches  proportion unused areas hash table increases reduction search cost wasted memory collision resolution hash collisions practically unavoidable hashing random subset large set keys   keys hashed buckets perfectly uniform random distribution birthday problem  chance keys hashed slot hash table implementations collision resolution strategy handle events common strategies methods require keys pointers stored table values separate chaining method separate chaining bucket independent sort list entries time hash table operations time bucket constant time list operation good hash table bucket entries rarely structures efficient time space cases preferred structures efficient fairly large number entries bucket needed desirable cases happen hashing function fixed separate chaining linked lists chained hash tables linked lists popular require basic data structures simple algorithms simple hash functions unsuitable methods cost table operation scanning entries selected bucket desired key distribution keys uniform average cost lookup depends average number keys bucket roughly proportional load factor reason chained hash tables remain effective number table entries higher number slots chained hash table  slots   stored keys load factor  times slower   slot table load factor   times faster plain sequential list separate chaining worst case scenario entries inserted bucket case hash table ineffective cost searching bucket data structure linear list lookup procedure scan entries worst case cost proportional number entries table bucket chains searched sequentially order entries bucket load factor large keys rearranging chain heuristic effective sophisticated data structures balanced search trees worth load factor large  hash distribution uniform guarantee good performance worst case scenario larger table hash function effective cases chained hash tables inherit disadvantages linked lists storing small keys values space overhead pointer entry record additional disadvantage traversing linked list poor cache performance making processor cache ineffective separate chaining list head cells chaining implementations store record chain slot array number pointer traversals decreased cases purpose increase cache efficiency hash table access disadvantage bucket takes space bucket entry save space hash tables slots stored entries meaning slots entries separate chaining structures list data structure supports required operations balancing binary search tree theoretical worst case time common hash table operations insertion deletion lookup brought log introduces extra complexity implementation worse performance smaller hash tables time spent inserting balancing tree greater time needed perform linear search elements list real hash table balancing binary search tree buckets hashmap class version  variant called array hash table dynamic array store entries hash slot newly inserted entry appended dynamic array assigned slot dynamic array resized exact fit manner meaning grown bytes needed alternative techniques growing array block sizes improve insertion performance cost space variation efficient cpu caching translation lookaside buffer tlb slot entries stored sequential memory positions dispenses pointers required linked lists saves space frequent array resizing space overheads incurred operating memory fragmentation small elaboration approach called dynamic perfect hashing bucket entries organized perfect hash table  slots memory  slots entries worst case slots average case variant guaranteed constant worst case lookup time low amortized time insertion fusion tree bucket achieving constant time operations high probability open addressing strategy called open addressing entry records stored bucket array entry inserted buckets examined starting hashed slot proceeding probe sequence unoccupied slot searching entry buckets scanned sequence target record unused array slot key table open addressing refers fact location address item determined hash method called closed hashing confused open hashing closed addressing separate chaining probe sequences include linear probing interval probes fixed  quadratic probing interval probes increased adding successive outputs quadratic polynomial starting original hash computation double hashing interval probes computed hash function drawback open addressing schemes number stored entries exceed number slots bucket array fact good hash functions performance dramatically degrades load factor grows   applications restrictions mandate dynamic resizing attendant costs open addressing schemes stringent requirements hash function distributing keys uniformly buckets function minimize clustering hash values consecutive probe order separate chaining concern objects map hash adjacent nearby completely irrelevant open addressing saves memory entries small times size pointer load factor small load factor close buckets stored entries open addressing wasteful entry open addressing avoids time overhead allocating entry record implemented absence memory allocator avoids extra indirection required access entry bucket locality reference linear probing small record sizes factors yield performance chaining lookups hash tables open addressing easier serialize pointers hand normal open addressing poor choice large elements elements entire cpu cache lines negating cache advantage large space wasted large table slots open addressing table stores references elements external storage space comparable chaining large records loses speed advantage generally speaking open addressing hash tables small records stored table internal storage fit cache suitable elements word table expected high load factor records large data variable sized chained hash tables perform coalesced hashing hybrid chaining open addressing coalesced hashing links chains nodes table open addressing achieves space usage diminished cache advantages chaining chaining exhibit clustering effects fact table efficiently filled high density chaining elements table slots cuckoo hashing alternative open addressing solution cuckoo hashing ensures constant lookup deletion time worst case constant amortized time insertions low probability worst case encountered hash functions key pair locations lookup hash function key hash function collision insertion key hashed hash function map bucket hash functions collision key collided removed space key key hashed hash functions maps bucket location collision process repeats collision process traverses buckets point table resized combining multiple hash functions multiple cells bucket high space utilization achieved hopscotch hashing alternative open addressing solution hopscotch hashing combines approaches cuckoo hashing linear probing general avoid limitations works load factor grows   algorithm suited implementing resizable concurrent hash table hopscotch hashing algorithm works defining neighborhood buckets original hashed bucket entry search limited number entries neighborhood logarithmic worst case constant average proper alignment neighborhood typically requires cache inserting entry attempts add bucket neighborhood buckets neighborhood occupied algorithm traverses buckets sequence open slot unoccupied bucket linear probing point bucket neighborhood items repeatedly displaced sequence hops cuckoo hashing difference case slot moved neighborhood items moved hope eventually finding slot hop brings open slot closer original neighborhood invalidating neighborhood property buckets open slot moved neighborhood entry inserted robin hood hashing interesting variation double hashing collision resolution robin hood hashing idea key displace key inserted probe count larger key current position net reduces worst case search times table ordered hash tables criterion bumping key depend direct relationship keys worst case variation number probes reduced dramatically interesting variation probe table starting expected successful probe expand position directions external robin hood hashing extension algorithm table stored external file table position corresponds fixed sized bucket records  choice hashing  choice hashing employs hash functions   hash table hash functions compute table locations object inserted table table location fewer objects default  table location equality bucket size  choice hashing employs principle power choices dynamic resizing insert number entries hash table exceeds product load factor current capacity hash table rehashed rehashing includes increasing size underlying data structure mapping existing items bucket locations implementations initial capacity greater maximum number entries divided load factor rehash operations occur limit proportion memory wasted buckets implementations shrink size table rehash items deleted point space time tradeoffs operation deallocation dynamic arrays resizing copying entries common approach automatically trigger complete resizing load factor exceeds threshold max larger table allocated entry removed table inserted table entries removed table table returned free storage pool likewise load factor falls threshold min entries moved smaller table hash tables shrink grow frequently resizing downward skipped case table size proportional maximum number entries hash table time current number disadvantage memory usage higher cache behavior worse control shrink fit operation provided request table size increases decreases fixed percentage expansion total cost resizings amortized insert delete operations constant independent number entries number operations performed table created minimum size doubled time load ratio exceeds threshold elements inserted table total number extra insertions occur dynamic resizings table  dynamic resizing roughly doubles cost insert delete operation alternatives rehashing hash table implementations notably real time systems pay price enlarging hash table interrupt time critical operations avoid dynamic resizing solution perform resizing gradually disk based hash tables alternative rehashing cost rebuilding entire table disk high incremental resizing alternative enlarging table perform rehashing gradually resize allocate hash table table unchanged lookup delete operation check tables perform insertion operations table insertion elements table table elements removed table deallocate ensure table completely copied table enlarged increase size table factor  resizing monotonic keys key values increase decrease monotonically variation consistent hashing achieved keeping list single key hash table resize operation lookup keys fall ranges defined list entries directed hash function hash table range common grow number entries doubling log ranges check binary search time redirection log log consistent hashing approach guarantees key hash issued change hash table grown linear hashing linear hashing hash table algorithm permits incremental hash table expansion implemented single hash table lookup functions hashing distributed hash tables decrease cost table resizing choose hash function hashes values change table resized hash functions prevalent disk based distributed hash tables rehashing prohibitively costly problem designing hash values change table resized distributed hash table problem popular approaches rendezvous hashing consistent hashing content addressable network algorithm kademlia distance performance analysis simplest model hash function completely unspecified table resize ideal hash function table size displaystyle open addressing collisions holds displaystyle elements single comparison successful lookup table size displaystyle chaining displaystyle keys minimum  displaystyle max  collisions θ  displaystyle theta  frac comparisons lookup worst hash function insertion collision hash tables degenerate linear search θ displaystyle theta amortized comparisons insertion displaystyle comparisons successful lookup adding rehashing model straightforward dynamic array geometric resizing factor displaystyle implies displaystyle frac keys inserted displaystyle times total number insertions bounded  displaystyle frac  θ displaystyle theta rehashing maintain displaystyle tables chaining open addressing unlimited elements perform successful lookup single comparison choice hash function realistic models hash function random variable probability distribution hash functions performance computed average choice hash function distribution uniform assumption called simple uniform hashing hashing chaining requires θ  displaystyle theta  frac comparisons average unsuccessful lookup hashing open addressing requires θ   displaystyle theta left frac   bounds constant maintain displaystyle frac table resizing displaystyle fixed constant  features advantages main advantage hash tables table data structures speed advantage apparent number entries large hash tables efficient maximum number entries predicted advance bucket array allocated optimum size resized set key pairs fixed ahead time insertions deletions allowed reduce average lookup cost careful choice hash function bucket table size internal data structures devise hash function collision free perfect case keys stored table drawbacks operations hash table constant time average cost good hash function higher loop lookup algorithm sequential list search tree hash tables effective number entries small cases high cost computing hash function mitigated saving hash key string processing applications spell checking hash tables efficient finite automata judy arrays keys store key represented small number bits hash table key directly array values note collisions case entries stored hash table enumerated efficiently constant cost entry pseudo random order efficient locate entry key nearest key listing entries specific order generally requires separate sorting step cost proportional log entry comparison ordered search trees lookup insertion cost proportional log finding nearest key cost ordered enumeration entries constant cost entry keys stored hash function collision free easy enumerate keys table moment average cost operation constant fairly small cost single operation high hash table dynamic resizing insertion deletion operation occasionally time proportional number entries drawback real time interactive applications hash tables general exhibit poor locality reference data accessed distributed seemingly random memory hash tables access patterns jump trigger microprocessor cache misses long delays compact data structures arrays searched linear search faster table small keys compact optimal performance point varies hash tables inefficient collisions extremely uneven hash distributions extremely chance malicious adversary knowledge hash function supply hash creates worst case behavior causing excessive collisions poor performance denial service attack critical applications data structure worst case guarantees universal hashing randomized algorithm prevents attacker predicting inputs worst case behavior preferable hash function hash table linux routing table cache changed linux version    countermeasure attacks associative arrays hash tables commonly implement types memory tables implement associative arrays arrays indices arbitrary strings complicated objects interpreted programming languages ruby python storing item multimap hash collision occurs multimap unconditionally stores items storing item typical associative array hash collision occurs actual keys associative array likewise stores items key item matches key item associative array typically erases item overwrites item item table unique key database indexing hash tables disk based data structures database indices dbm trees popular applications multi node database systems hash tables commonly distribute rows nodes reducing network traffic hash joins caches hash tables implement caches auxiliary data tables speed access data stored slower media application hash collisions handled discarding colliding entries erasing item stored table overwriting item item table unique hash sets recovering entry key hash table implementations entry exists structures implement set data structure records key belongs set keys case structure simplified eliminating parts entry values hashing implement static dynamic sets object representation dynamic languages perl python lua ruby hash tables implement objects representation keys names members methods object values pointers member method unique data representation hash tables programs avoid creating multiple character strings contents purpose strings program stored single string pool implemented hash table checked string created technique introduced lisp interpreters hash consing kinds data expression trees symbolic algebra records database files file binary decision diagrams transposition table implementations programming languages programming languages provide hash table functionality built associative arrays standard library modules  unordered_map class hash tables keys values arbitrary type programming language including variant android includes hashset hashmap linkedhashset linkedhashmap generic collections   zend  engine zend  engine hash functions daniel bernstein generate hash values managing mappings data pointers stored hash table source code labelled djbx33a daniel bernstein times  addition python built hash table implementation form dict type perl hash type internally implement namespaces pay attention security collision attacks python sets hashes internally fast lookup store keys values net framework support hash tables provided generic hashtable generic dictionary classes store key pairs generic hashset class stores values ruby hash table open addressing model ruby   onwards rust standard library generic hashmap hashset structs linear probing robin hood bucket stealing ansi smalltalk defines classes set identityset dictionary identitydictionary smalltalk implementations provide additional standardized versions weakset weakkeydictionary weakvaluedictionary tcl array variables hash tables tcl dictionaries immutable values based hashes functionality library functions tcl_inithashtable generic hash tables tcl_newdictobj dictionary values performance independently benchmarked extremely competitive