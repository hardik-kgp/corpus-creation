hilbert tree hilbert tree tree variant multidimensional objects lines regions objects high dimensional feature based parametric objects thought extension tree multidimensional objects performance trees depends quality algorithm clusters data rectangles node hilbert trees space filling curves hilbert curve impose linear ordering data rectangles types hilbert trees static databases dynamic databases cases hilbert space filling curves achieve ordering multidimensional objects node ordering good sense group data rectangles minimize area perimeter minimum bounding rectangles mbrs packed hilbert trees suitable static databases updates rare updates dynamic hilbert tree suitable dynamic databases insertions deletions updates occur real time dynamic hilbert trees employ flexible deferred splitting mechanism increase space utilization node defined set sibling nodes adjusting split policy hilbert tree achieve degree space utilization high desired proposing ordering tree nodes hilbert tree sorts rectangles hilbert center rectangles mbr hilbert point length hilbert curve origin point ordering node defined set sibling nodes deferred splitting adjusting split policy hilbert tree achieve high utilization desired contrary tree variants control space utilization basic idea static environment explains intuitive principles good tree design principles valid static dynamic databases roussopoulos leifker proposed method building packed tree achieves space utilization idea sort data coordinate corners rectangles sorting coordinates discussion points rectangles sorted coordinate lower left corner rectangle referred lowx packed tree sorted list rectangles scanned successive rectangles assigned tree leaf node node leaf node created scanning sorted list continues nodes tree fully packed exception node level leads space utilization higher levels tree created figure highlights problem lowx packed tree figure leaf nodes tree lowx packing method create points figure left fact father nodes cover area explains lowx packed tree achieves excellent performance point queries fact fathers large perimeters explains degradation performance region queries consistent analytical formulas tree performance intuitively packing algorithm ideally assign nearby points leaf node ignorance coordinate lowx packed tree violate empirical rule figure left points uniformly distributed mbr nodes generated lowx packed tree algorithm describes variants hilbert trees suitable static database updates rare updates nodes tree fully packed exception node level space utilization structure called packed hilbert tree called dynamic hilbert tree supports insertions deletions suitable dynamic environment packed hilbert trees introduction hilbert curve basic hilbert curve x2 grid denoted figure derive curve order vertex basic curve replaced curve order appropriately rotated reflected figure hilbert curves order order curve infinity space filling curves curve fractal fractal dimension hilbert curve generalized higher dimensionalities algorithms drawing dimensional curve order algorithm higher dimensionalities path space filling curve imposes linear ordering grid points path calculated starting curve path actual coordinate values point calculated hilbert curve harder order curve figure ordering x4 grid curve point curve hilbert point hilbert hilbert rectangle defined hilbert center figure hilbert curves order hilbert curve imposes linear ordering data rectangles traverses sorted list assigning set rectangles node tree final result set data rectangles node close linear ordering native space tree nodes smaller areas figure illustrates intuitive reasons hilbert based methods result good performance data composed points points figure grouping points hilbert values mbrs tree nodes tend small square rectangles nodes small area small perimeters small area values result good performance point queries small area small perimeter values lead good performance larger queries algorithm hilbert pack packs rectangles tree step calculate hilbert data rectangle step sort data rectangles ascending hilbert values step create leaf nodes level rectangles generate tree node assign rectangles node step create nodes higher level nodes level sort nodes level ascending creation time repeat step assumption data static frequency modification low simple heuristic constructing tree space utilization time good response time dynamic hilbert trees performance trees depends quality algorithm clusters data rectangles node hilbert trees space filling curves hilbert curve impose linear ordering data rectangles hilbert rectangle defined hilbert center tree structure hilbert tree structure leaf node entries form obj _id capacity leaf mbr real object low high low high obj pointer object description record main difference hilbert tree tree leaf nodes lhvs largest hilbert leaf node hilbert tree entries form ptr lhv capacity leaf node mbr encloses children node ptr pointer child node lhv largest hilbert data rectangles enclosed notice leaf node picks hilbert values children lhv extra cost calculating hilbert values mbr leaf nodes figure illustrates rectangles organized hilbert tree hilbert values centers numbers symbols parent node lhv brackets figure tree figure stored disk contents parent node data rectangle node hilbert rectangle node hilbert greater figure data rectangles organized hilbert tree hilbert values largest hilbert values lhvs brackets plain tree splits node overflow creating nodes original policy called splitting policy defer split waiting nodes split note tree split policy method referred splitting policy general extended splitting policy order splitting policy implement order splitting policy overflowing node push entries siblings split siblings called cooperating siblings algorithms searching insertion overflow handling searching searching algorithm tree variants starting root descends tree examines nodes intersect query rectangle leaf level reports entries intersect query window qualified data items algorithm search node root rect s1 search nonleaf nodes invoke search entry mbr intersects query window search leaf nodes report entries intersect query window candidates figure file structure hilbert tree insertion insert rectangle hilbert tree hilbert center rectangle key level node minimum lhv greater siblings chosen leaf node reached rectangle inserted correct order rectangle inserted leaf node adjusttree called mbr largest hilbert values upper level nodes algorithm insert node root rect inserts rectangle hilbert tree hilbert rectangle i1 leaf node invoke chooseleaf select leaf node place insert leaf node slot insert place hilbert order return invoke handleoverflow return leaf split inevitable propagate upward form set cooperating siblings leaf invoke adjusttree grow tree taller node split propagation caused root split create root children nodes algorithm chooseleaf rect int returns leaf node place rectangle initialize set root node leaf check leaf_ return choose subtree leaf node choose entry ptr lhv minimum lhv greater c4 descend leaf reached set node pointed ptr repeat algorithm adjusttree set set nodes node updated cooperating siblings overflow occurred newly created node split occurred routine ascends leaf level root adjusting mbr lhv nodes cover nodes propagates splits root level reached propagate node split upward np parent node split node insert np correct order hilbert room invoke handleoverflow np np split node adjust mbr lhv parent level set parent nodes nodes adjust mbr lhv nodes appropriately level set parent nodes np split repeat deletion hilbert tree insert orphaned nodes father node underflows keys borrowed siblings underflowing node merged siblings nodes clear ordering largest hilbert lhv contrast trees concept sibling nodes notice deletion operations require cooperating siblings insertion operations require siblings algorithm delete d1 host leaf perform exact match search leaf node delete remove node d3 underflows borrow entries cooperating siblings siblings ready underflow merge nodes adjust nodes d4 adjust mbr lhv parent levels form set cooperating siblings underflow occurred invoke adjusttree overflow handling overflow handling algorithm hilbert tree treats overflowing nodes moving entries cooperating siblings splitting nodes nodes algorithm handleoverflow node rect return node split occurred h1 ε set entries cooperating siblings add ε cooperating siblings distribute ε evenly nodes hilbert values h4 cooperating siblings create node distribute ε evenly nodes hilbert values return