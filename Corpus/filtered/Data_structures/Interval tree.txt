interval tree computer science interval tree tree data structure hold intervals efficiently intervals overlap interval point windowing queries instance roads computerized map inside rectangular viewport visible elements inside dimensional scene data structure segment tree trivial solution visit interval test intersects point interval requires time number intervals collection query return intervals query large interval intersecting intervals collection asymptotically optimal output sensitive algorithms runtime expressed terms number intervals produced query interval trees query time log initial creation time log limiting memory consumption creation interval trees dynamic allowing efficient insertion deletion interval log time endpoints intervals small integer range range faster fact optimal data structures exist preprocessing time query time reporting intervals query point simple naive approach simple case intervals overlap inserted simple binary search tree queried log time arbitrarily overlapping intervals compare intervals insertion tree orderings sorted points points naive approach build parallel trees ordered point ordered point interval discarding half tree log time merged requiring time queries log brute force interval trees solve problem article describes alternative designs interval tree dubbed centered interval tree augmented tree centered interval tree queries require log time total number intervals number reported construction requires log time storage requires space construction set intervals number construct data structure efficiently retrieve intervals overlapping interval point start entire range intervals dividing half x_center practice x_center picked tree balanced sets intervals completely left x_center s_left completely x_center s_right overlapping x_center s_center intervals s_left s_right recursively divided manner intervals left intervals s_center overlap center point stored separate data structure linked node interval tree data structure consists lists intervals sorted points intervals sorted points result binary tree node storing center point pointer node intervals completely left center point pointer node intervals completely center point intervals overlapping center point sorted point intervals overlapping center point sorted point intersecting data structure constructed receive queries consisting ranges points return ranges original set overlapping input point task intervals tree overlap point tree walked recursive algorithm traverse traditional binary tree extra logic support searching intervals overlapping center point node tree node compared x_center midpoint node construction x_center leftmost set intervals s_left considered greater x_center rightmost set intervals s_right considered node processed traverse tree root leaf ranges s_center processed x_center intervals s_center overlap x_center intervals s_center consult lists s_center constructed care interval scenario consult list sorted suppose closest number greater list ranges list point overlap overlap x_center larger simply start enumerating intervals list startpoint exceeds likewise greater x_center intervals s_center intervals list sorted interval endings matches x_center intervals s_center processing tree traversal stopped interval result interval intersect query interval hold start point completely encloses intervals start points inside separately constructed tree dimensional case search tree start points interval set pointer interval binary search log time start reveals minimum maximum points point range references interval overlaps result list care avoid duplicates interval binary flag interval mark result set finally intervals enclose pick point inside algorithm intervals intersecting point careful remove duplicates higher dimensions interval tree data structure generalized higher dimension identical query construction time log space range tree dimensions constructed efficient retrieval intervals points inside query region ranges thing left ranges enclose region dimension overlaps interval trees created axis intersecting queried dimensions square horizontal intersecting queried interval tree constructed horizontal axis likewise left vertical intersecting queried interval tree constructed vertical axis interval tree addition higher dimensions node traverse tree compared s_center overlaps sorted lists points dimensional case range tree constructed efficient retrieval points s_center overlap region deletion deleting interval tree node interval intervals node deleted tree complex normal binary tree deletion operation interval overlap center point nodes tree node stores intervals overlap intervals completely left center point left subtree subtree interval stored node closest root set nodes center point overlaps normal deletion operations binary tree case node deleted children involve promoting node leaf position node deleted leftmost child subtree rightmost child left subtree result promotion nodes promoted node descendants search nodes intervals overlap promoted node intervals promoted node consequence result nodes deleted algorithm balancing issues affect deletion affect rotation operations rotation preserve invariant nodes stored close root augmented tree represent intervals cormen interval trees insertion deletion require log time total number intervals tree prior insertion deletion operation augmented tree built simple ordered tree binary search tree balancing binary search tree ordered low values intervals extra annotation node recording maximum upper intervals node maintaining attribute involves updating ancestors node node deleted takes steps node addition removal height node removed tree tree rotations insertion deletion nodes updating intervals overlap low high high low searching trees nodes overlapping interval skip nodes nodes low interval nodes maximum high start interval membership queries performance gained tree avoids unnecessary traversals occur adding intervals exist removing intervals exist total order defined intervals ordering lower bounds upper bounds membership check performed log time versus log time required duplicates intervals overlap interval inserted removed solution advantage requiring additional structures change strictly algorithmic disadvantage membership queries log time alternately rate memory membership queries expected constant time implemented hash table updated lockstep interval tree double total memory requirement intervals stored reference adding interval tree key node interval nodes ordered low finally high node point interval searching point interval tree search interval walks tree key getkey high getvalue omit branches overlap query simplest case point query compareto returns negative compareto returns compareto returns positive code search interval check middle overlapswith defined higher dimensions augmented trees extended higher dimensions cycling dimensions level tree dimensions odd levels tree ranges coordinate levels ranges coordinate approach effectively converts data structure augmented binary tree augmented kd tree complicating balancing algorithms insertions deletions simpler solution nested interval trees create tree ranges coordinate node tree add interval tree ranges elements range node range advantage solution extended arbitrary number dimensions code base additional cost nested trees prohibitive nested solution earlier node needed coordinate yielding number nodes solutions additional overhead nested tree structures vertical interval structure negligible size consisting pointer root node number nodes depth tree medial length oriented tree medial length oriented tree augmented tree symmetrical binary search tree ordered medial points intervals maximum oriented binary heap node ordered length interval half length store minimum maximum subtree node symmetry overlap test start values intervals displaystyle left a_ b_ displaystyle overlap test performed displaystyle a_ b_ displaystyle a_ b_ simplified sum difference displaystyle s_ a_ b_ displaystyle d_ b_ a_ reduces overlap test displaystyle left s_ s_ d_ d_ adding interval adding intervals tree binary search tree medial key push displaystyle d_ binary heap node update minimum maximum values higher nodes searching overlapping intervals displaystyle a_ b_ m_ d_ query interval displaystyle m_ key node compared displaystyle m_ intervals starting root node node check query interval overlaps node subtree minimum maximum values node continue node calculate min displaystyle min left d_ intervals inside node children overlap query interval knowing displaystyle m_ m_ min displaystyle min left d_ left m_ m_ d_ perform query binary heap displaystyle d_ bigger min displaystyle min left d_ pass left children node thing worst case scan nodes binary search tree binary heap query optimum acceptable dimensional problem optimum dimensions algorithm expected faster traditional interval tree augmented tree search operations adding elements slower practice order growth