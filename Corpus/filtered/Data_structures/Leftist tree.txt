leftist tree computer science leftist tree leftist heap priority queue implemented variant binary heap node distance nearest leaf subtree rooted contrast binary heap leftist tree attempts unbalanced addition heap property leftist trees maintained descendant node lower height biased leftist tree invented clark allan crane fact left subtree taller subtree leftist tree mergeable heap inserting node tree node tree created merged existing tree delete item replaced merge left trees operations log time insertions slower fibonacci heaps support insertion constant amortized time log worst case leftist trees advantageous ability merge compared binary heaps θ cases merging skew heaps performance merging leftist heaps worst case log complexity merging skew heaps amortized log complexity bias usual leftist tree height biased leftist tree biases exist weight biased leftist tree rank node distance node nearest leaf subtree rooted node null child implicitly nodes equal minimum children values nodes missing child node child descriptions null children assumed knowing shortest path nearest missing leaf subtree rooted node depth children meaning size tree rooted displaystyle log displaystyle log number nodes subtree rooted operations height biased leftist tree operations height biased leftist tree merge operation merging min hblts merge operation takes min hblts input returns min hblt nodes original min hblts merge returns case min hblts assume trees rooted key displaystyle leq key swap condition holds merge recursively merging subtree change subtree maintain leftist tree property merge check subtree bigger left subtree recursive merge calls swap left subtrees child missing assumed root greater heap property maintained pseudocode merging min height biased leftist trees merge null return null return key key swap merge result null null left null swap left s_value subtree null shortest path descendant leaf node return s_value left s_value swap left s_value s_value return code merging min height biased leftist trees merge operation leftist tree works depicted boxes represent merge recursion unwinds swap left children s_value left s_value node case swapped subtrees rooted nodes keys insertion min hblt insertion merge operation insertion node existing min hblt creates hblt tree size node merges existing tree insert create_tree return merge deletion min element min hblt min element min hblt root order delete min root deleted subtrees merged form min hblt delete_min key merge left return initializing height biased leftist tree initializing height biased leftist tree ways merge node time hblt process inefficient takes nlogn time approach queue store node tree items queue removed merged queue initialize hblt time approach detailed diagrams supplied min height biased leftist tree initialize min hblt place element tree queue left set numbers initialized diagram represents cycle algorithm depicting contents queue steps easy follow notice freshly created hblt queue step occurrence greater occurs sixth step trees merged predictable complex merge tree lower tree child merge called subtree rooted tree child tree merge subtree tree tree child greater left child swapped root node complex recursively merge time child subtree grayed process deletion arbitrary element min hblt pointer node min hblt delete replace node result merging subtrees update values nodes path root swapping left subtrees maintain leftist tree property upward traversal continued hit root values change deleting element values path traversed increased node child parent parent decreased remain node parent left child parent decreased swapped sibling decrease child causing change current child lowest node pointer parent traverse path root updating values traversal ends node nodes traversed lie rightmost path rooted node number nodes traversed log size subtree rooted operation takes lg perform weight biased leftist tree leftist trees weight biased case storing values node store attribute denoting number nodes subtree rooted left wblts ensure left internal nodes wblt operations ensure invariant swapping children node subtree outgrows left hblt operations merging min wblts merge operation wblts single traversal number nodes subtrees prior recursive merge swap left subtrees total number nodes subtree tree merged bigger number nodes left subtree operations completed single path improves time complexity operations constant factor merge operation depicted graph operations wblt insertions deletion min element hblts merge operation wblts outperform hblts merge insertion deletion min key constant factor logn bound guaranteed deleting arbitrary element wblts θ nodes traversed hblt deleting leaf node key time updating values needed length rightmost path nodes change wblt tree update weight node root takes worst case variants variations basic leftist tree exist minor basic algorithm choice left child taller arbitrary rightist tree work avoid swapping children record child tallest bit merge operation decide merge metric height weight number nodes