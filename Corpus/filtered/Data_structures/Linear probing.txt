linear probing linear probing scheme computer programming resolving collisions hash tables data structures maintaining collection key pairs key invented  gene amdahl elaine mcgraw arthur samuel analyzed  donald knuth quadratic probing double hashing linear probing form open addressing schemes cell hash table stores single key pair hash function collision mapping key cell hash table occupied key linear probing searches table closest free location inserts key lookups performed searching table sequentially starting position hash function finding cell matching key cell thorup zhang  write hash tables commonly nontrivial data structures popular implementation standard hardware linear probing fast simple linear probing provide high performance good locality reference sensitive quality hash function collision resolution schemes takes constant expected time search insertion deletion implemented random hash function  independent hash function tabulation hashing good achieved practice hash functions murmurhash operations linear probing component open addressing schemes hash table solve dictionary problem dictionary problem data structure maintain collection key pairs subject operations insert delete pairs collection search key open addressing solutions problem data structure array hash table cells nonempty store single key pair hash function map key cell key stored typically scrambling keys keys values table hash collision occurs hash function maps key cell occupied key linear probing strategy resolving collisions placing key closest cell search search key cells examined cell hash function continuing adjacent cells   finding cell cell stored key cell key search returns cell cell key table cell preference cell searched case search returns result key dictionary insertion insert key pair table replacing existing pair key insertion algorithm sequence cells search finding cell cell stored key key pair cell insertion load factor table fraction occupied cells grow preset threshold table replaced table larger constant factor hash function dynamic array setting threshold close high growth rate table size leads faster hash table operations greater memory usage threshold values close low growth rates common choice double table size load factor exceed   causing load factor stay     deletion remove key pair dictionary sufficient simply emptying cell affect searches keys hash earlier emptied cell stored position emptied cell emptied cell searches incorrectly report key cell emptied search forward cells table finding cell key moved cell key hash equal earlier cell emptying cell safe deletion process terminates search finds key moved cell performs speeding searches moved key empties cell block occupied cells search movable key continues emptied cell terminates reaching cell process moving keys earlier cells key examined time complete process proportional length block occupied cells deleted key matching running time hash table operations alternatively lazy deletion strategy key pair removed replacing special flag indicating deleted key flag values contribute load factor hash table strategy clean flag values array rehash remaining key pairs large fraction array occupied deleted keys properties linear probing good locality reference require uncached memory accesses operation low moderate load factors provide high performance compared open addressing strategies performance degrades high load factors primary clustering tendency collision nearby collisions additionally achieving good performance method requires higher quality hash function collision resolution schemes low quality hash functions fail eliminate nonuniformities input distribution linear probing slower open addressing strategies double hashing probes sequence cells separation determined hash function quadratic probing size step varies depending position probe sequence analysis linear probing dictionary operations implemented constant expected time insert remove search operations implemented  long load factor hash table constant strictly time operation search insertion deletion proportional length contiguous block occupied cells operation starts starting cells equally hash table cells maximal block occupied cells probability starting location search time starting location expected time operation calculated product terms  summed maximal blocks contiguous cells table sum squared block lengths expected time bound random hash function random starting location specific state hash table summing blocks exist exist state table multiplying term potential block probability block occupied defining block event maximal contiguous block occupied cells length expected time operation     block displaystyle  sum _  sum _   operatorname operatorname block formula simplified replacing block simpler condition event elements hash values lie block cells length replacement sum longer depends  factor cancels terms outer summation simplifications lead bound    displaystyle leq  sum _   operatorname operatorname multiplicative form chernoff bound load factor bounded probability block length hashed values exponentially small function causing sum bounded constant independent perform analysis stirling approximation chernoff bound estimate probability block hashed values terms load factor α expected time successful search    α expected time unsuccessful search insertion key    α  constant load factors high probability longest probe sequence probe sequences keys stored table logarithmic length choice hash function linear probing sensitive unevenly distributed hash values combine high quality hash function produce irregularities analysis assumes key hash random number independent hashes keys assumption unrealistic applications hashing random pseudorandom hash values hashing objects identity instance linear probing identityhashmap class collections framework hash class associates object identityhashcode guaranteed remain fixed lifetime object arbitrary identityhashcode constructed object required object address construction involve slower computations random pseudorandom number generator instance  xorshift pseudorandom number generator construct values applications hashing compute hash function time hashed object created applications random pseudorandom numbers hash values objects hashes cryptographic hash functions designed computationally indistinguishable random functions slow hash tables methods constructing hash functions devised methods compute hash function proven work linear probing linear probing analyzed framework independent hashing class hash functions initialized small random seed equally map tuple distinct keys tuple indexes parameter thought measure hash function quality larger time compute hash function behave completely random functions linear probing  independence guarantee constant expected time operation  independent hash functions perform badly logarithmic time operation method constructing hash functions high quality practical speed tabulation hashing method hash key computed byte key table random numbers table byte position numbers table cells combined bitwise exclusive operation hash functions constructed  independent linear probing hash functions takes constant expected time operation tabulation hashing standard methods generating  independent hash functions limited keys fixed number bits handle strings types variable length keys compose simpler universal hashing technique maps keys intermediate values higher quality  independent tabulation hash function maps intermediate values hash table indices experimental comparison richter multiply shift family hash functions defined mod   displaystyle h_ cdot bmod  div  fastest hash function integrated hashing schemes producing highest throughputs good quality tabulation hashing produced lowest throughput point table require cycles expensive simple arithmetic operations murmurhash superior tabulation hashing studying provided mult murmur trade tabulation attractive practice