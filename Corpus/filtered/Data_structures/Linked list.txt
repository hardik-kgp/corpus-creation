linked list computer science linked list linear collection data elements order physical placement memory element points data structure consisting collection nodes represent sequence basic form node data reference link node sequence structure efficient insertion removal elements position sequence iteration complex variants add additional links allowing efficient insertion removal nodes arbitrary positions drawback linked lists access time linear difficult pipeline faster access random access feasible arrays cache locality compared linked lists linked lists simplest common data structures implement common abstract data types including lists stacks queues associative arrays expressions uncommon implement data structures directly linked list basis principal benefit linked list conventional array list elements easily inserted removed reallocation reorganization entire structure data items stored contiguously memory disk restructuring array time expensive operation linked lists insertion removal nodes point list constant number operations keeping link previous link removed memory list traversal hand simple linked lists random access data form efficient indexing basic operations obtaining node list finding node datum locating place node inserted require iterating list elements advantages disadvantages linked lists linked list dynamic length list increase decrease node follow previous physically memory disadvantages memory arrays storage pointers nodes linked list read order linked lists inherently sequential access nodes stored incontiguously greatly increasing time periods required access individual elements list cpu cache difficulties linked lists reverse traversing instance singly linked lists cumbersome navigate backwards doubly linked lists easier read memory consumed allocating space pointer basic concepts nomenclature record linked list called element node field node address node called link pointer remaining fields data cargo payload fields head list node tail list refer rest list head node list lisp derived languages node called cdr pronounced list payload head node called car singly linked list singly linked lists nodes data field field points node nodes operations performed singly linked lists include insertion deletion traversal code demonstrates add node data singly linked list doubly linked list doubly linked list node node link link field pointing previous node sequence links called forward backwards prev previous technique xor linking doubly linked list implemented single link field node technique requires ability bit operations addresses high level languages modern operating systems doubly linked lists maintain references active processes threads dynamic objects common strategy rootkits evade detection unlink lists multiply linked list multiply linked list node link fields field connect set data records order set department birth doubly linked lists special cases multiply linked list fact orders opposite leads simpler efficient algorithms treated separate case circular linked list node list link field null reference special lack nodes common convention point node list case list circular circularly linked open linear list pointer points node case circular doubly linked list node points node list sentinel nodes implementations extra sentinel dummy node data record convention simplifies accelerates list handling algorithms ensuring links safely dereferenced list data elements node lists list list data records nodes sentinel nodes list sentinel nodes hash linking link fields physically nodes data records stored array referenced indices link field stored separate array indices data records list handles reference node access list reference called address pointer handle list algorithms manipulate linked lists handles input lists return handles lists fact context algorithms word list list handle situations convenient refer list handle consists links pointing nodes combining alternatives alternatives listed arbitrarily combined circular doubly linked lists sentinels circular singly linked lists sentinels tradeoffs choices computer programming design method suited circumstances linked list data structure work case problems list common tradeoffs involving linked list structures linked lists dynamic arrays dynamic array data structure allocates elements contiguously memory count current number elements space reserved dynamic array exceeded reallocated copied expensive operation linked lists advantages dynamic arrays insertion deletion element specific point list assuming indexed pointer node removed insertion point constant time operation reference insertion dynamic array random locations require moving half elements average elements worst case delete element array constant time marking slot vacant fragmentation impedes performance iteration arbitrarily elements inserted linked list limited total memory dynamic array eventually underlying array data structure reallocate expensive operation memory fragmented cost reallocation averaged insertions cost insertion reallocation amortized  helps appending elements array inserting removing middle positions carries prohibitive costs data moving maintain contiguity array elements removed resized order avoid wasting space hand dynamic arrays fixed size array data structures constant time random access linked lists sequential access elements singly linked lists fact easily traversed direction linked lists unsuitable applications element heapsort sequential access arrays dynamic arrays faster linked lists machines optimal locality reference good data caching disadvantage linked lists extra storage needed references impractical lists small data items characters boolean values storage overhead links exceed factor size data contrast dynamic array requires space data small control data slow naïve allocator wasteful allocate memory separately element problem generally solved memory pools hybrid solutions combine advantages representations unrolled linked lists store elements list node increasing cache performance decreasing memory overhead references cdr coding replacing references actual data referenced extends referencing record good highlights pros cons dynamic arrays linked lists implementing program resolves josephus problem josephus problem election method works group people stand circle starting predetermined person count circle times reach person circle members close circle count circle times repeat process person left person wins election strengths weaknesses linked list dynamic array view people connected nodes circular linked list easily linked list delete nodes rearrange links nodes linked list poor finding person remove search list finds person dynamic array hand poor deleting nodes elements remove node individually shifting elements list exceptionally easy person circle directly referencing position array list ranking problem concerns efficient conversion linked list representation array trivial conventional computer solving problem parallel algorithm complicated subject balanced tree memory access patterns space overhead linked list permitting efficient indexing log time random access insertion deletion operations expensive overhead tree manipulations maintain balance schemes exist trees automatically maintain balanced state avl trees red black trees singly linked linear lists lists doubly linked circular lists advantages singly linked linear lists linear lists offer advantages preferable situations singly linked linear list recursive data structure pointer smaller object type reason operations singly linked linear lists merging lists enumerating elements reverse order simple recursive algorithms simpler solution iterative commands recursive solutions adapted doubly linked circularly linked lists procedures generally extra arguments complicated base cases linear singly linked lists tail sharing common final portion list terminal portion lists node list list remains tail simple persistent data structure true variants node belong circular doubly linked lists sentinel nodes shared singly linked circular lists sentinel node list lisp proper list ends link special node denoted nil car cdr links point lisp procedure safely car cdr list advantages fancy variants limited complexity algorithms efficiency circular list emulated linear list variables point nodes extra cost doubly linked singly linked double linked lists require space node xor linking elementary operations expensive easier manipulate fast easy sequential access list directions doubly linked list insert delete node constant number operations node address singly linked list address pointer node handle list case node link field previous node algorithms require access directions hand doubly linked lists tail sharing persistent data structures circularly linked linearly linked circularly linked list natural option represent arrays naturally circular corners polygon pool buffers released fifo order set processes time shared round robin order applications pointer node serves handle list circular list pointer node easy access node link applications require access ends list implementation queue circular structure handle structure single pointer circular list split circular lists constant time addresses node piece operation consists swapping contents link fields nodes applying operation nodes distinct lists joins list property greatly simplifies algorithms data structures quad edge face edge simplest representation circular list thing sense null pointer indicating list nodes choice algorithms test special case handle separately contrast null denote linear list natural creates fewer special cases sentinel nodes sentinel node simplify list operations ensuring previous nodes exist element lists node sentinel node list data field eliminate list tests scanning list node setting sentinel data field unnecessary test list inside loop merging sorted lists sentinels data fields set choice output node special handling lists sentinel nodes extra space applications short lists complicate operations creation list circular list simulate linear list avoid complexity adding single sentinel node list data nodes convention list consists sentinel node pointing node link list handle pointer data node sentinel list sentinel list trick simplify handling doubly linked linear list turning circular doubly linked list single sentinel node case handle single pointer dummy node linked list operations manipulating linked lists place care values invalidated previous assignments algorithms inserting deleting linked list nodes subtle pseudocode adding removing nodes singly doubly circularly linked lists place null refer list marker sentinel implemented number ways linearly linked lists singly linked lists node data structure fields variable firstnode points node list null list record node data data stored node node refe rence node null node record list node firstnode points node list null list traversal singly linked list simple node link node list firstnode node null node data node node code inserts node existing node singly linked list diagram works inserting node existing directly track previous node insert node function insertafter node node node newnode insert newnode node newnode node node newnode inserting list requires separate function requires updating firstnode function insertbeginning list list node newnode insert node current node newnode list firstnode list firstnode newnode functions removing node node removing node list diagram demonstrates remove node track previous element function removeafter node node remove node obsoletenode node node node destroy obsoletenode function removebeginning list list remove node obsoletenode list firstnode list firstnode list firstnode point deleted node destroy obsoletenode notice removebeginning sets list firstnode null removing node list iterate backwards efficient insertbefore removebefore operations inserting list specific node requires traversing list worst case running time appending linked list inefficient reference tail list structure traverse entire list order tail append list linearly linked lists length displaystyle list appending asymptotic time complexity displaystyle lisp family languages list appending provided append procedure special cases linked list operations eliminated including dummy element list ensures special cases list renders insertbeginning removebeginning unnecessary case data list list firstnode circularly linked list circularly linked list nodes linked continuous circle null lists queue stores reference node list node node node elements list removed constant time circularly linked lists singly doubly linked types circularly linked lists benefit ability traverse list node avoid storing firstnode lastnode list special representation list lastnode variable points node list null lastnode representation simplifies adding removing nodes list lists special case algorithms assuming somenode node circular singly linked list code iterates list starting somenode function iterate somenode somenode null node somenode node node node node somenode notice test node somenode loop test moved loop procedure fail list node function inserts node newnode circular linked list node node node null assumes list function insertafter node node node newnode node null newnode newnode newnode node node newnode suppose variable pointing node circular linked list null list append newnode list insertafter newnode newnode insert newnode list insertafter newnode null newnode linked lists arrays nodes languages support type reference create links replacing pointers array indices approach array records record integer fields indicating previous node array nodes array records supported parallel arrays linked list record arrays pointers record entry integer entry array integer prev previous entry double linked string real balance linked list built creating array structures integer variable store element integer listhead entry records  links elements formed placing array previous cell prev field element listhead set  location entry list notice entry    list cells additions list creating listfree integer variable free list created track cells entries size array increased elements deleted entries stored list code traverse list display names account balance listhead  loop list print records records balance print entry records faced choice advantages approach include linked list relocatable meaning moved memory directly serialized storage disk transfer network small list array indexes occupy space pointer architectures locality reference improved keeping nodes memory periodically rearranging general store naïve dynamic memory allocators produce excessive overhead storage node allocated allocation overhead incurred node approach seizing entry pre allocated array faster dynamic memory allocation node dynamic memory allocation typically requires search free memory block desired size approach main disadvantage creates manages private memory space nodes leads issues increases complexity implementation growing large array difficult impossible finding space linked list node large general memory pool easier adding elements dynamic array occasionally unexpectedly linear constant time amortized constant general memory pool leaves memory data list smaller expected nodes freed reasons approach languages support dynamic memory allocation disadvantages mitigated maximum size list time array created language support programming languages lisp scheme singly linked lists built functional languages lists constructed nodes called cons cons cell cons fields car reference data node cdr reference node cons cells build data structures primary purpose languages support abstract data types templates linked list adts templates building linked lists languages linked lists typically built references records internal external storage constructing linked list faced choice store data list directly linked list nodes called internal storage store reference data called external storage internal storage advantage making access data efficient requiring storage locality reference simplifying memory management list data allocated deallocated time list nodes external storage hand advantage generic data structure machine code linked list matter size data easy place data multiple linked lists internal storage data multiple lists including multiple references node data structure create separate routines add delete cells based field create additional linked lists elements internal storage external storage cells additional linked lists store references nodes linked list data general set data structures included linked lists external storage approach set data structures included linked list internal storage generic linked list package external storage likewise sets data stored data structure included single linked list internal storage fine approach languages involves data structures initial fields including prev double linked list references location defining separate structures type data generic structure defined minimum data shared structures contained structures generic routines created minimal structure perform linked list type operations separate routines handle specific data approach message parsing routines types messages received start set fields including field message type generic routines add messages queue received remove queue order process message message type field correct routine process specific type message internal external storage suppose wanted create linked list families members internal storage structure record member member family member string firstname integer age record family family family string lastname string address member members head list members family print complete list families members internal storage write afamily families start head families list afamily null loop list families print family amember afamily members head list family members amember null loop list members print member amember amember afamily afamily external storage create structures record node generic link structure node pointer data generic pointer data node record member structure family member string firstname integer age record family structure family string lastname string address node members head list members family print complete list families members external storage write famnode families start head families list famnode null loop list families afamily family famnode data extract family node print family memnode afamily members list family members memnode null loop list members amember member memnode data extract member node print member memnode memnode famnode famnode notice external storage extra step needed extract record node cast proper data type list families list members family stored linked lists data structure node language parametric types long number families member belong compile time internal storage works fine member needed included arbitrary number families specific number time external storage speeding search finding specific element linked list sorted requires time linear search primary disadvantages linked lists data structures addition variants discussed simple ways improve search time unordered list simple heuristic decreasing average search time heuristic simply moves element list scheme handy creating simple caches ensures items quickest common approach linked list efficient external data structure build red black tree hash table elements references linked list nodes multiple indexes built single list disadvantage indexes updated time node removed random access lists random access list list support fast random access read modify element list implementation skew binary random access list skew binary number involves list trees special properties worst case constant time head cons operations worst case logarithmic time random access element random access lists implemented persistent data structures random access lists viewed immutable linked lists likewise support  head tail operations simple extension random access lists min list additional operation yields minimum element entire list constant time mutation complexities data structures stacks queues implemented linked lists simply restrict type operations supported skip list linked list augmented layers pointers jumping large numbers elements descending layer process continues layer actual list binary tree type linked list elements linked lists nature result node include reference node linked lists contents form subtrees node unrolled linked list linked list node array data values leads improved cache performance list elements contiguous memory reduced memory overhead metadata stored element list hash table linked lists store chains items hash position hash table heap shares ordering properties linked list implemented array references node node previous data indexes calculated current data organizing list rearranges nodes based heuristic reduces search times data retrieval keeping commonly accessed nodes head list footnotes