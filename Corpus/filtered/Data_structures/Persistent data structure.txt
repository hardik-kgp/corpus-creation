persistent data structure computing persistent data structure data structure preserves previous version modified data structures effectively immutable operations visibly update structure place yield updated structure term introduced driscoll sarnak sleator tarjans article data structure partially persistent versions accessed newest version modified data structure fully persistent version accessed modified meld merge operation create version previous versions data structure called confluently persistent structures persistent called ephemeral types data structures common logical functional programming partial versus persistence partial persistence model programmer query previous version data structure update latest version implies linear ordering version data structure fully persistent model updates queries allowed version data structure cases performance characteristics querying updating older versions data structure allowed degrade true rope data structure addition data structure referred confluently persistent addition fully persistent versions data structure combined form version fully persistent techniques preserving previous versions copy write method creating persistent data structure platform provided ephemeral data structure array store data data structure copy entirety data structure copy write semantics updates data structure inefficient technique entire backing data structure copied write leading worst case performance characteristics modifications array size fat node fat node method record node fields nodes erasing values fields requires nodes allowed arbitrarily fat fat node pointer fields ephemeral node space arbitrary number extra field values extra field field version stamp version named field changed fat node version stamp indicating version node created purpose nodes version stamps node field version order navigate structure original field node version stamp complexity fat node fat node method requires space modification store data modification takes additional time store modification modification history amortized time bound assuming modification history stored growable array access time version node structure traversed modifications access operation log slowdown cost finding nearest modification array path copying path copying method copy nodes path node modified cascaded data structure nodes pointed node modified point node modifications cascading root node reached complexity path copying modifications costs log additive lookup time modification time space bounded size longest path data structure cost update ephemeral data structure balanced binary search tree parent pointers worst case modification time complexity log update cost linked list worst case modification time complexity update cost combination sleator tarjan combine techniques fat nodes path copying achieving access slowdown modification space time complexity node modification box stored box hold modification node modification pointers node key piece node specific data timestamp modification applied initially node modification box node accessed modification box checked timestamp compared access time access time specifies version data structure considered modification box access time modification time modification box normal node considered hand access time modification time modification box overriding node modifying node works assumed modification touches pointer field node modification box filled modification modification box copy node latest values modification performed directly node modification box node fields overwritten modification box stays finally change cascaded node parent path copying involve filling parent modification box making copy parent recursively node parent root root sorted array roots algorithm time modification box exists data structure time modification time splits tree parts data time data time unaffected modification complexity combination time space modifications require amortized analysis modification takes amortized space amortized time potential function ϕ ϕ number live nodes live nodes nodes reachable current root current time modification live nodes live nodes modification boxes modification involves number copies change modification box copies costs space time decreases potential function node copied live contributes potential function potential function drop node reachable tree reachable tree step algorithm modify node parent point copy finally copy modification box replaced live node replaced live node ϕ final step fills modification box costs time increases ϕ putting change ϕ δϕ algorithm takes δϕ space δϕ time examples persistent data structures simplest persistent data structure singly linked list cons based list simple list objects formed carrying reference list persistent tail list meaning items nodes tail duplicated shared list list long contents tail immutable sharing invisible program common reference based data structures red black trees stacks treaps easily adapted create persistent version effort queues dequeues extensions including min deques additional operation min returning minimal element random access deques additional operation random access linear logarithmic complexity exist persistent data structures destructive operations making impossible implement efficiently purely functional languages haskell specialized monads state languages types data structures avoided design primary advantage purely persistent data structures behave multi threaded environments linked lists singly linked lists bread butter data structure functional languages derived languages haskell purely functional node list allocated modified copied referenced destroyed garbage collector refers note purely functional supports destructive list operations subset true lisp list processing functional language dialects scheme racket lists represented memory circle node list arrow representing element node pointer node concatenating lists zs memory structure notice nodes list copied nodes shared result original lists persist modified reason copy node node original modified point start change trees binary search tree node tree recursive invariant subnodes contained left subtree equal stored node subnodes contained subtree greater stored node instance set data represented binary search tree function inserts data binary tree maintains invariant executing insert configuration produced notice points original tree persists common nodes shared tree tree persistence sharing difficult manage form garbage collection gc automatically free nodes live references gc feature commonly functional programming languages persistent hash array mapped trie persistent hash array mapped trie specialized variant hash array mapped trie preserve previous versions updates implement general purpose persistent map data structure hash array mapped originally paper phil bagwell entitled ideal hash trees paper presented mutable hash table insert search delete times small constant independent key set size operations small worst case times insert search removal operations guaranteed misses cost successful searches data structure modified rich hickey fully persistent clojure programming language conceptually hash array mapped work generic tree store nodes hierarchically retrieve path element key difference hash array mapped hash function transform lookup key bit integer path tree determined slices binary representation integer sparse array level tree leaf nodes tree behave buckets construct hash tables multiple candidates depending hash collisions implementations persistent hash array mapped branching factor implementation practice insertions deletions lookups persistent hash array mapped trie computational complexity log applications effectively constant time require extremely large number entries operation dozen steps usage programming languages haskell haskell pure functional language mutation data structures language persistent impossible preserve previous state data structure functional semantics change data structure render previous versions data structure invalid violate referential transparency standard library haskell efficient persistent implementations linked lists maps implemented size balanced trees sets clojure programming languages lisp family clojure implementation linked list dialects implementation linked list enforced persistence persistent convention clojure syntax literals efficient implementations persistent vectors maps sets based persistent hash array mapped data structures implement mandatory read parts collections framework designers clojure language advocate persistent data structures mutable data structures semantics benefit making freely shareable threads cheap aliases easy fabricate language independent data structures form basis clojure support parallel computing easy retries operations sidestep data races atomic compare swap semantics elm elm programming language purely functional haskell data structures persistent necessity persistent implementations linked lists persistent arrays dictionaries sets elm custom virtual dom implementation takes advantage persistent nature elm data reported developers elm virtual dom elm language render html faster popular frameworks react ember angular popular frontend framework react frequently state management implements flux architecture popular implementation library redux redux library inspired state management pattern elm programming language meaning mandates users treat data persistent result redux project recommends cases users libraries enforced efficient persistent data structures reportedly greater performance comparing making copies regular objects library persistent data structures immutable based data structures popularized clojure scala mentioned documentation redux libraries provide enforced immutability scala scala programming language promotes persistent data structures implementing programs object functional style scala implementations persistent data structures including linked lists red black trees persistent hash array mapped introduced clojure garbage collection persistent data structures implemented successive versions data structure share underlying memory ergonomic data structures generally requires form automatic garbage collection reference counting mark sweep platforms persistent data structures option garbage collection lead memory leaks cases positive impact performance application