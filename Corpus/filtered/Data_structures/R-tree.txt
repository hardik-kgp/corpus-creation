tree trees tree data structures spatial access methods indexing multi dimensional geographical coordinates rectangles polygons tree proposed antonin guttman theoretical applied contexts common real usage tree store spatial objects restaurant locations polygons typical maps streets buildings outlines lakes coastlines answers queries museums current location retrieve road segments location display navigation nearest gas station roads account tree accelerate nearest neighbor search distance metrics including great circle distance tree idea key idea data structure group nearby objects represent minimum bounding rectangle higher level tree tree rectangle objects lie bounding rectangle query intersect bounding rectangle intersect contained objects leaf level rectangle describes single object higher levels aggregation increasing number objects increasingly coarse approximation data set tree tree balanced search tree leaf nodes depth organizes data designed storage disk databases maximum number entries denoted displaystyle guarantees minimum root node performance experienced minimum maximum number entries trees guarantee trees reason complex balancing required spatial data opposed linear data stored trees trees searching algorithms intersection containment nearest neighbor search simple key idea bounding boxes decide search inside subtree nodes tree read search trees trees suitable large data sets databases nodes paged memory needed tree main memory data fit memory cached trees practical applications provide performance advantages naive check objects number objects memory applications alternatives provide performance simpler implement practice key difficulty tree build efficient tree hand balanced leaf nodes height hand rectangles cover space overlap search fewer subtrees processed original idea inserting elements efficient tree insert subtree requires enlargement bounding box data split sets cover minimal area improvements trees aims improving tree built grouped objectives building efficient tree scratch bulk loading performing existing tree insertion deletion trees guarantee good worst case performance generally perform real data theoretical bulk loaded priority tree variant tree worst case optimal increased complexity received attention practical applications data organized tree neighbors distance nearest neighbors norm points efficiently computed spatial join beneficial algorithms based queries local outlier factor deli clu density link clustering cluster analysis algorithm tree structure kind spatial join efficiently compute optics clustering variants priority tree tree tree tree hilbert tree tree algorithm data layout data trees organized variable number entries pre defined maximum minimum entry leaf node stores pieces data identifying child node bounding box entries child node leaf nodes store data required child point bounding box representing child external identifier child point data leaf entries points polygon data requires storage large polygons common setup store mbr minimum bounding rectangle polygon unique identifier tree search range searching input search rectangle query box searching searching tree search starts root node tree internal node set rectangles pointers child node leaf node rectangles spatial objects pointer spatial object rectangle node decided overlaps search rectangle child node searched searching recursive manner overlapping nodes traversed leaf node reached contained bounding boxes rectangles tested search rectangle objects result set lie search rectangle priority search nearest neighbor search query consists point rectangle root node inserted priority queue queue desired number returned search continues processing nearest entry queue tree nodes expanded children reinserted leaf entries returned encountered queue approach distance metrics including great circle distance geographic data insertion insert object tree traversed recursively root node step rectangles current directory node examined candidate chosen heuristic choosing rectangle requires enlargement search descends reaching leaf node leaf node split insertion exhaustive search expensive heuristic employed split node adding newly created node previous level level overflow overflows propagate root node node overflows root node created tree increased height choosing insertion subtree level algorithm decide subtree insert data object data object fully contained single rectangle choice clear multiple options rectangles enlargement choice impact performance tree classic tree objects inserted subtree enlargement advanced tree mixed heuristic employed leaf level minimize overlap case ties prefer enlargement area higher levels behaves tree ties preferring subtree smaller area decreased overlap rectangles tree key benefits traditional tree consequence heuristics subtree choosing splitting overflowing node redistributing objects node nodes exponential number options heuristic employed split classic tree guttman proposed heuristics called quadraticsplit linearsplit quadratic split algorithm searches pair rectangles worst combination node puts initial objects groups searches entry strongest preference groups terms area increase assigns object group objects assigned satisfying minimum splitting strategies greene split tree splitting heuristic minimize overlap prefers quadratic linear split algorithm proposed ang tan produce irregular rectangles performant real range window queries addition advanced splitting heuristic tree avoid splitting node reinserting node members tree balances overflowing nodes reduce overlap increase tree performance finally tree tree variant decide split node construct called super node extra entries good split high dimensional data deletion deleting entry require updating bounding rectangles parent underfull balanced neighbors dissolved children subtrees leaf objects reinserted process root node single element tree height decrease bulk loading nearest objects sorted coordinate split desired size packed hilbert tree variation nearest sorting hilbert center rectangle coordinate guarantee overlap sort tile recursive str variation nearest estimates total number leaves required number objects capacity displaystyle lceil text number objects text capacity rceil required split factor dimension achieve displaystyle lceil rceil repeatedly splits dimensions successively displaystyle equal sized partitions dimensional sorting occupy bulk loaded algorithm point data leaf nodes overlap tile data space equal sized overlap minimizing omt improvement str approach minimizes overlaps slices improves query performance priority tree