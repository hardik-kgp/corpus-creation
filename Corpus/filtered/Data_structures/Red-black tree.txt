red black tree red black tree kind balancing binary search tree computer science node binary tree extra bit bit interpreted color red black node color bits ensure tree remains balanced insertions deletions balance preserved painting node tree colors satisfies properties collectively constrain unbalanced tree worst case tree modified tree subsequently rearranged repainted restore coloring properties properties designed rearranging recoloring performed efficiently balancing tree perfect good guarantee searching log time total number elements tree insertion deletion operations tree rearrangement recoloring performed log time tracking color node requires bit node colors tree data specific red black tree memory footprint identical classic uncolored binary search tree cases additional bit stored additional memory cost terminology red black tree special type binary tree computer science organize pieces comparable data text fragments numbers leaf nodes red black trees data leaves explicit computer memory null child pointer nil figure red black tree encode fact child leaf description figure leaves considered explicit nodes view simplify description understanding algorithms operating red black trees order save marginal execution time nil leaves implemented sentinel nodes null pointers hand order save main memory single sentinel node individuals perform role leaf nodes references pointers internal nodes leaf nodes point unique sentinel node red black trees binary search trees efficient order traversal order left root elements search time traversal root leaf balanced tree nodes tree height log search time properties addition requirements imposed binary search tree satisfied red black tree node red black root black rule root changed red black vice versa rule analysis leaves nil black node red children black path node descendant nil nodes number black nodes note constraint restriction imposed children black nodes black node leaf node child black node perfect binary tree consists black nodes red black tree black depth node defined number black nodes root node number black ancestors black height red black tree number black nodes path root leaves constraint constant alternatively defined black depth leaf node constraints enforce critical property red black trees path root farthest leaf long path root nearest leaf result tree roughly height balanced operations inserting deleting finding values require worst case time proportional height tree theoretical upper bound height red black trees efficient worst case ordinary binary search trees guaranteed suffices properties red black tree number black nodes property shortest path root leaf consist black nodes longer paths constructed inserting red nodes property impossible insert consecutive red node ignoring black nil leaves longest path consists nodes alternating black red worst case counting black nil leaves longest path consists nodes shortest path black nodes longest path alternates red black nodes maximal paths number black nodes property path long path analogy trees order red black tree structure tree order node values child pointers tree node matching black node red black tree optional node matching equivalent red node red black tree equivalence red nodes graphical representation red black tree align horizontally parent black node creating horizontal cluster tree modified graphical representation red black tree leaf nodes depth red black tree structurally equivalent tree order minimum factor values cluster maximum capacity values tree type general red black tree ambiguity red black tree conversion multiple red black trees produced equivalent tree order tree cluster minimum black child pointers cluster values central black stored sides red cluster values black node red black tree red order tree maintain values contained cluster root black tree cluster parent values cluster operations red black trees economical time maintain vector values costly values stored directly node stored reference tree nodes economical space store color attribute node slot cluster vector values stored reference objects null references cluster represented vector slots pointers slots child references tree case tree compact memory improving data locality analogy trees larger orders structurally equivalent colored binary tree colors suppose add blue blue red black tree defined red black trees additional constraint successive nodes hierarchy blue blue nodes children red node equivalent tree clusters values colors blue red blue black blue red blue cluster black node red nodes blue nodes moderate volumes values insertions deletions colored binary tree faster compared trees colored trees attempt maximize factor horizontal cluster nodes minimum factor guaranteed colored binary trees limiting number splits junctions clusters trees faster performing rotations rotations frequently occur cluster multiple separate nodes colored binary tree storing large volumes trees faster compact grouping children cluster accessed locally optimizations trees increase average factors clusters equivalent multicolored binary tree notably maximizing average factor structurally equivalent tree reducing total height multicolored tree increasing number black nodes worst case occurs nodes colored binary tree black case occurs black thirds red nodes applications data structures red black trees offer worst case guarantees insertion time deletion time search time valuable time sensitive applications real time applications valuable building blocks data structures provide worst case guarantees data structures computational geometry based red black trees completely fair scheduler current linux kernels epoll implementation red black trees avl tree structure supporting log search insertion removal avl trees colored red black subset rb trees worst case height times worst case height rb trees avl trees rigidly balanced performance measurements ben pfaff realistic test cases runs avl rb ratios median geometric wavl trees performance red black trees valuable functional programming common persistent data structures construct associative arrays sets retain previous versions mutations persistent version red black trees requires log space insertion deletion addition time tree red black trees data elements order insertion deletion operations trees equivalent color flipping rotations red black trees trees tool understanding logic red black trees introductory algorithm texts introduce trees red black trees trees practice sedgewick introduced simpler version red black tree called left leaning red black tree eliminating unspecified degree freedom implementation llrb maintains additional invariant red links lean left inserts deletes red black trees isometric trees trees sequence operations tree isometry sedgewick trees isometry resolved color flip split red color children nodes leaves children moves parent node original description tango tree type tree optimized fast searches red black trees data structure version hashmap modified linkedlist store elements colliding hashcodes red black tree improvement time complexity searching element log operations read operations red black tree require modification binary search trees red black tree special case simple binary search tree result insertion removal violate properties red black tree restoring red black properties requires small number log amortized color quick practice tree rotations insertion insert delete operations complicated times remain log implementation suitable couple implementations explanations ben pfaff annotated library gnu libavl v2 june details insert removal operations demonstrated code code helper functions parent sibling uncle grandparent nodes rotate node left diagram notes label denote current node case insertion node replacement node leaf entire procedure applied recursively nodes case denote parent node denote grandparent denote sibling denote uncle sibling node parent human family trees cases roles labels nodes shifted case label continues represent node diagrams blue border rings current node left current half rings node target half step nodes newly assigned relative red black diagram assumed case implied assumptions white represents red black halves diagram numbered triangle represents subtree unspecified depth black circle atop triangle black height subtree greater compared subtree circle insertion insertion adding node manner standard binary search tree insertion coloring red big difference binary search tree node leaf leaves red black tree node replaces existing leaf black leaves depends color nearby nodes cases red black tree insertion handle root node node red black tree parent black red root tree uncle red red black note property node red black property leaves black holds property root black checked corrected case property red nodes black children threatened adding red node repainting node black red rotation property paths node leaves number black nodes threatened adding black node repainting node rotation case current node root tree case repainted black satisfy property root black adds black node path property paths node leaf nodes number black nodes violated case current node parent black property children red node black invalidated case tree valid property paths node leaf nodes number black nodes threatened current node black leaf children red paths children number black nodes path leaf replaced black property remains satisfied note cases assumed grandparent node parent red root black uncle node leaf case note remaining cases diagram parent node left child parent code samples cover possibilities note inserting place calls tail recursion algorithm cases called case recurse case grandparent node case iterative implementation effectively loop problem repair case escalated levels higher time takes maximally iterations repair tree height tree probability escalation decreases exponentially iteration average insertion cost practically constant removal regular binary search tree deleting node leaf children maximum element left subtree order predecessor minimum element subtree order successor node deleted delete node copied fewer leaf children leaf children children normal binary search trees red black trees leaf nodes sentinel nil nodes internal nodes children leaf nodes definition children internal nodes leaf children red black tree leaf nodes regular binary search tree copying violate red black properties reduces problem deleting node leaf child solved problem solution applies equally case node originally delete leaf child case considered leaf children remainder discussion address deletion node leaf child label denote node deleted denote selected child child leaf child child choose leaf child red node simply replace child black property occur leaf children red node black leaf child leaf child count black nodes sides tree violate property paths deleted node simply pass fewer red node deleted node parent child black property leaves black property children red node black hold simple case black red simply removing black node break properties children red node black paths node leaf nodes number black nodes repaint black properties preserved complex case black occur deleting black node leaf children black node black leaf child leaf child count black nodes sides tree invalid red black tree violation property replacing child recall case child child leaves relabel child position sibling parent child sibling diagrams parent parent left child child leaf black subtree included counted black height subtree includes count black height case leaf node note order tree remain defined null leaf remain leaf transformations children node deleting leaf null child easy property satisfied hand null leaf verified diagrams code cases property satisfied perform steps outlined code function replacenode substitutes child place tree convenience code assume null leaves represented actual node objects null code insertion works representation note null leaf represent null leaves actual node objects modify algorithm calling deletecase1 parent node delete code deleting parent black red trivial behaves null leaf called phantom leaf safely delete remain leaf operations addition sibling tests cases require updating longer true sibling children represented objects original parent black deleting original parent paths proceed fewer black node paths violates property paths node leaf nodes number black nodes tree rebalanced cases case root case removed black node path root black properties preserved note cases assume left child parent child left reversed cases code examples cases account function calls tail recursion algorithm place algorithm cases chained order delete case recurse case parent node case iterative implementation effectively loop loops case occur height tree probability escalation decreases exponentially iteration average removal cost constant additionally tail recursion occurs child node tail recursion loop child successive ancestors rotation occurs case possibility rotation loop cases parent node red rotation exit loop rotation occur loop additional rotations occur exiting loop rotations occur total mehlhorn sanders point avl trees support constant amortized deletion costs red black trees proof asymptotic bounds red black tree internal nodes height log definitions height subtree rooted node bh number black nodes leaf subtree counting black called black height lemma subtree rooted node displaystyle bh internal nodes proof lemma induction height basis height null bh displaystyle bh inductive step displaystyle bh internal nodes implies displaystyle displaystyle displaystyle bh internal nodes displaystyle displaystyle internal node children black height bh displaystyle bh displaystyle depending child red black inductive hypothesis child displaystyle bh internal nodes displaystyle displaystyle bh bh bh internal nodes lemma height tree logarithmic half nodes path root leaf black property red black tree black height root root lemma root log root root log displaystyle geq text root leftrightarrow log _ geq text root leftrightarrow text root leq log _ height root log set operations bulk operations addition single element insert delete lookup operations set operations defined red black trees union intersection set difference fast bulk operations insertions deletions implemented based set functions set operations rely helper operations split join operations implementation red black trees efficient highly parallelizable implementation red root join function join red black trees key return tree elements requires greater keys smaller keys trees black height join simply create node left subtree root subtree black root set red set black suppose larger black height case symmetric join spine black node balanced point node left child root set red child created replace node invalidate red black invariant red nodes row fixed double rotation double red issue propagates root root set black restoring properties cost function difference black heights input trees split split red black tree smaller trees smaller key larger key draw path root inserting red black tree insertion values left path values greater applying join subtrees left merged keys path intermediate nodes form left tree asymmetric applications split returns boolean denoting appears tree cost split log displaystyle log order height tree algorithm special properties red black tree generic balancing schemes avl trees join algorithm function joinrightrb return node red expose node joinrightrb black color color red color black return rotateleft return function joinleftrb symmetric joinrightrb function join joinrightrb color red color red color black return symmetric color black black node red node black displaystyle node displaystyle black height black node black height red node expose extract tree node displaystyle left child displaystyle key node displaystyle color node displaystyle child displaystyle node create node left child displaystyle key displaystyle color displaystyle child displaystyle split algorithm function split nil return nil false nil expose return true split return join split return join union red black trees representing sets red black tree represents recursive function computes union function union nil return nil return split root return join root union left union split presumed return trees holding keys input key holding greater keys algorithm destructive place destructive version exists algorithm intersection difference requires join2 helper routine join middle key based functions union intersection difference key multiple keys inserted deleted red black tree split calls join deal balancing criteria red black trees directly implementation called join based implementation complexity union intersection difference log displaystyle left log left red black trees sizes displaystyle displaystyle geq complexity optimal terms number comparisons importantly recursive calls union intersection difference independent executed parallel parallel depth log log displaystyle log log displaystyle join based implementation computational directed acyclic graph dag single element insertion deletion root larger tree split smaller tree parallel algorithms parallel algorithms constructing red black trees sorted lists items constant time log log time depending computer model number processors asymptotically proportional number items fast search insertion deletion parallel algorithms join based algorithms red black trees parallel bulk operations including union intersection construction filter map reduce popular culture red black tree referenced correctly episode missing canadian series robert sedgewick lectures jess red door pollock thought red door storage container jess red black antonio red turning black pollock budget deficits red ink black ink antonio binary search tree red black tree tracks simple path node descendant leaf number black nodes jess ladies