scapegoat tree computer science scapegoat tree balancing binary search tree invented arne andersson igal galperin ronald rivest worst case log lookup time log amortized insertion deletion time balancing binary search trees provide worst case log lookup time scapegoat trees additional node memory overhead compared regular binary search tree node stores key pointers child nodes scapegoat trees easier implement data structure alignment reduce node overhead small incremental rebalancing operations balanced tree algorithms scapegoat trees rarely expensively choose scapegoat completely rebuild subtree rooted scapegoat complete binary tree scapegoat trees worst case update performance theory binary search tree weight balanced half nodes left root half α weight balanced node defined meeting relaxed weight balance criterion size left α size node size α size node size defined recursively function size node node nil return return size node left size node degenerate tree linked list satisfies condition α α match complete binary trees binary search tree α weight balanced α height balanced height tree log α size tree contraposition tree α height balanced α weight balanced scapegoat trees guaranteed α weight balance times loosely α height balanced height scapegoat tree log α size tree violations height balance condition detected insertion time imply violation weight balance condition exist scapegoat trees red black trees restrictions height differ greatly implementations determining rotations case scapegoat trees rebalances place red black trees store additional color node determine location scapegoat trees scapegoat α weight balanced perform rebalance operation loosely avl trees actual rotations depend balances nodes determining balance differs greatly avl trees check balance insertion deletion typically stored node scapegoat trees calculate needed scapegoat balancing search trees scapegoat trees flexible balancing support α α high α fewer balances making insertion quicker lookups deletions slower vice versa low α practical applications α chosen depending frequently actions performed operations lookup lookup modified standard binary search tree worst case time log contrast splay trees worst case time reduced node memory overhead compared balancing binary search trees improve locality reference caching insertion insertion implemented basic ideas unbalanced binary search tree finding insertion point depth node recorded implemented simple counter incremented iteration lookup effectively counting number edges root inserted node node violates α height balance property defined rebalance required rebalance entire subtree rooted scapegoat undergoes balancing operation scapegoat defined ancestor inserted node α weight balanced ancestor rebalancing restore α height balanced property finding scapegoat climb node root select node α weight balanced climbing root requires log storage space allocated stack parent pointers avoided pointing child parent repairing walk determine potential node viable scapegoat check α weight balanced property definition size left α size node size α size node large optimisation realising sizes leaving calculated demonstrate assuming climbing root size parent size node size sibling size inserted node case trivialized size size size sibling node parent size sibling function required scapegoat subtree rooted scapegoat completely rebuilt perfectly balanced time traversing nodes subtree values sorted order recursively choosing median root subtree rebalance operations time dependent number nodes subtree insertion worst case performance time worst case scenarios spread insertion takes log amortized time sketch proof cost insertion define imbalance node absolute difference size left node node minus whichever greater max left displaystyle operatorname max operatorname left operatorname rebuilding subtree rooted lemma rebuilding subtree rooted ω displaystyle omega ω displaystyle omega big notation proof lemma displaystyle v_ root subtree rebuilding log omega v_ degenerate insertions inserted node increases height ω displaystyle omega v_ ω displaystyle v_ omega v_ log log displaystyle log leq log v_ ω displaystyle omega rebuilding ω displaystyle omega insertions subtree rooted displaystyle result rebuilding insertions performed log displaystyle log time final insertion rebuilding costs displaystyle aggregate analysis clear amortized cost insertion log displaystyle log ω log ω log displaystyle omega log omega log deletion scapegoat trees unusual deletion easier insertion enable deletion scapegoat trees store additional tree data structure property maxnodecount simply represents highest achieved nodecount set nodecount entire tree rebalanced insertion set max maxnodecount nodecount perform deletion simply remove node simple binary search tree nodecount α maxnodecount rebalance entire tree root remembering set maxnodecount nodecount deletion worst case performance time amortized log average time sketch proof cost deletion suppose scapegoat tree displaystyle elements rebuilt complete binary tree displaystyle deletions performed tree rebuilt deletions log displaystyle log time time search element flag deleted displaystyle deletion tree rebuilt takes log displaystyle log displaystyle time aggregate analysis clear amortized cost deletion log displaystyle log log log log displaystyle sum log log log