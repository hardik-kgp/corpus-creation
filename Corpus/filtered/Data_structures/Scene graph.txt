scene graph scene graph general data structure commonly vector based graphics editing applications modern computer games arranges logical spatial representation graphical scene scene graph collection nodes graph tree structure tree node children single parent parent applied child nodes operation performed group automatically propagates members programs associating geometrical transformation matrix transformation matrix group level concatenating matrices efficient natural process operations common feature instance ability group shapes objects compound object moved transformed selected easily single object scene graphs graphics editing tools vector based graphics editing leaf node scene graph represents atomic unit document shape ellipse bezier path shapes paths decomposed nodes spline nodes practical scene graph composed shapes lower level representation user driven node concept layer layer acts transparent sheet number shapes shape groups document set layers conveniently invisible dimmed locked read applications place layers linear list support sublayers layers layers desired depth internally real structural difference layers groups nodes scene graph differences needed common type declaration generic node class derive layers groups subclasses visibility member feature layer group scene graphs games applications scene graphs modern games graphics increasingly large worlds levels applications nodes scene graph generally represent entities objects scene instance game define logical relationship knight horse knight considered extension horse scene graph horse node knight node attached scene graph spatial logical relationship entities knight moves space horse moves large applications memory requirements major considerations designing scene graph reason large scene graph systems geometry instancing reduce memory costs increase speed knight separate scene node graphical representation knight mesh textures materials shaders instanced single copy data referenced knight nodes scene graph reduced memory budget increased speed knight node created appearance data duplicated scene graph implementation simplest form scene graph array linked list data structure displaying shapes simply matter linearly iterating nodes common operations checking shape intersects mouse pointer linear searches small scene graphs suffice scene graph operations dispatch applying operation scene graph requires dispatching operation based node type render operation transformation group node accumulate transformation matrix multiplication vector displacement quaternions euler angles leaf node sends object rendering renderer implementations render object directly invokes underlying rendering api directx opengl underlying implementation rendering api lacks portability separate scene graph rendering systems order accomplish type dispatching approaches object oriented languages easily achieved virtual functions represents operation performed node virtual functions simple write impossible add operations nodes access source code alternatively visitor pattern disadvantage difficult add node types techniques involve rtti time type operation realised class passed current node queries node type rtti correct operation array callbacks functors requires map types callbacks functors initialized runtime offers flexibility speed extensibility variations techniques exist methods offer benefits alternative scene graph rebuilding scene graph rebuilt operations performed slow produces highly optimised scene graph demonstrates good scene graph implementation depends heavily application traversals traversals key power applying operations scene graphs traversal generally consists starting arbitrary node root scene graph applying operation updating rendering operations applied recursively moving scene graph tree child nodes leaf node reached point scene graph engines traverse tree applying operation render operation takes transformations account recursively traversing scene graph hierarchy pre render operation called node transformation node adds transformation current transformation matrix operation finishes traversing children node calls node post render operation transformation node undo transformation approach drastically reduces matrix multiplication scene graph operations efficient nodes traversed order systems implement scene graph rebuilding reorder scene graph easier parse format tree d cases scene graphs typically render starting tree root node recursively draw child nodes tree leaves represent foreground objects drawing proceeds closer objects simply overwriting farther process employing painter algorithm systems employ depth buffers efficient draw closest objects farther objects depth tested rendered occluded nearer objects scene graphs bounding volume hierarchies bvhs bounding volume hierarchies bvhs numerous tasks including efficient culling speeding collision detection objects bvh spatial structure partition geometry spatial partitioning bvh tree bounding volumes spheres axis aligned bounding boxes oriented bounding boxes hierarchy size volume large encompass single object tightly smaller fraction object high resolution bvhs ascends hierarchy node volume tightly encompasses volumes beneath root tree volume encompasses volumes tree scene bvhs speeding collision detection objects object bounding volume intersect volume higher tree intersect object node rejected similarities bvhs scene graphs scene graph easily adapted include bvh node volume purpose built bound node convenient location hierarchy typical view scene graph benefits including bvh scene graph scene graphs spatial partitioning effective combining spatial partitioning scene graphs creating scene leaf node spatial partitioning data increase computational efficiency rendering spatial data static generally moving scene data partitioned form systems systems rendering separately fine real advantages method bad scene graph contained spatial partitioning scene graph thought grander spatial partitioning large drawings scene graphs generated solely runtime ray tracing rendering programs require defining group nodes automated fashion raytracer scene description model build internal representation breaks individual parts bounding boxes called bounding slabs boxes grouped hierarchically ray intersection tests visibility determination efficiently computed group box intersect eye ray skip testing members efficiency holds d applications user magnified document visible computer screen scrolls bounding box case bounding rectangle scheme determine scene graph elements visible drawn depending particulars application drawing performance large scene graph design impacted rendering efficiency considerations video games quake binary space partitioning bsp trees heavily favored minimize visibility tests bsp trees long time compute design scene graphs recomputed design scene graph levels tend remain static dynamic characters generally considered spatial partitioning scheme scene graphs dense regular objects heightfields polygon meshes tend employ quadtrees octrees specialized variants bounding box hierarchy heightfield occupies box volume recursively subdividing box subboxes oct octree individual heightfield elements reached efficient natural quadtree simply d octree standards phigs phigs commercial scene graph specification ansi standard disparate implementations provided unix hardware vendors hoops graphics appears commercial scene graph library provided single software vendor designed disparate lower level d interfaces major production version v3 completed shortly silicon graphics released iris inventor scene graph built iris api open inventor portable scene graph built opengl scene graph libraries category scenegraph apis x3d x3d royalty free open standards file format time architecture represent communicate scenes objects xml iso ratified standard storage retrieval playback real time graphics content embedded applications open architecture support wide array domains user scenarios