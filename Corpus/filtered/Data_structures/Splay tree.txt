splay tree splay tree balancing binary search tree additional property accessed elements quick access performs basic operations insertion removal log amortized time sequences random operations splay trees perform search trees specific pattern sequence unknown splay tree invented daniel sleator robert tarjan  normal operations binary search tree combined basic operation called splaying splaying tree element rearranges tree element root tree basic search operation perform standard binary tree search element question tree rotations specific fashion bring element alternatively algorithm combine search tree reorganization single phase advantages good performance splay tree depends fact optimizing frequently accessed nodes nearer root accessed worst case height average log frequently nodes root advantage practical applications locality reference implementing caches garbage collection algorithms advantages include comparable performance average case performance efficient trees small memory footprint splay trees store bookkeeping data disadvantages disadvantage splay trees height splay tree linear case accessing elements decreasing order height tree corresponds worst case access time actual cost operation high amortized access cost worst case logarithmic log expected access cost reduced log randomized variant representation splay trees change accessed read manner operations complicates splay trees multi threaded environment extra management needed multiple threads allowed perform operations concurrently unsuitable general purely functional programming limited ways implement priority queues operations splaying node accessed splay operation performed root perform splay operation carry sequence splay steps moves closer root performing splay operation node access accessed nodes root tree remains roughly balanced achieve desired amortized time bounds step depends factors left child parent node root left child parent grandparent remember set gg great grandparent point splay operation gg null root updated types splay steps symmetric variants left handed sake brevity type types zig step step root tree rotated edge zig steps exist deal parity issue step splay operation odd depth operation zig zig step step root children left children picture case left children tree rotated edge joining parent rotated edge joining note zig zig steps thing differentiate splay trees rotate root method introduced allen munro prior introduction splay trees zig zag step step root child left child vice versa tree rotated edge rotated edge join trees elements smaller elements steps join single tree splay largest item item root null child set child root split tree element return trees elements equal elements greater splay root tree left elements smaller tree element larger split subtree rest tree insertion insert splay tree insert normal binary search tree item inserted splay performed result newly inserted node root tree alternatively split operation split tree trees create tree root left tree tree deletion delete node method binary search tree children swap rightmost node left tree order predecessor leftmost node subtree order successor remove node deletion reduced problem removing node   children binary search tree splay tree deletion splay parent removed node tree alternatively node deleted splayed brought root tree deleted leaves tree trees trees joined join operation implementation variants splaying mentioned performed pass access path node record access path pass requires extra space access operation alternative parent pointer node avoids extra space access operations reduce time efficiency update pointers method based argument restructure tree access path making pass splaying routine sets nodes left tree tree middle tree items original tree greater current item middle tree consists tree rooted current node sets updated access path keeping splay operations check method semisplaying modifies zig zig case reduce restructuring operations implementation splay trees pointers represent node tree implementation based splaying version method deletion splay tree definition version splay tree finds splays insertions deletions operation linear time complexity analysis simple amortized analysis static splay trees carried potential method define size number nodes tree rooted node including rank log  size φ sum ranks nodes tree φ tend high balanced trees low balanced trees apply potential method calculate δφ change potential caused splay operation check case separately denote rank rank function operation nodes rotation operation figures zig step zig zig step zig zag step amortized cost operation δφ actual cost actual cost zig zig zig zag operation  rotations summed entire splay operation telescopes  rank root rank log zig operation adds amortized cost  operation total amortized time sequence operations log displaystyle t_ mathrm amortized log amortized time actual time add decrease potential initial state operation φ final state operations completed φ φ φ log displaystyle phi _ phi _ sum _ mathrm rank _ mathrm rank _ log inequality fact node minimum rank  maximum rank log finally bound actual time log log displaystyle t_ mathrm actual log log weighted analysis analysis generalized assign node weight define size sum weights nodes tree rooted node including define rank φ analysis applies amortized cost splaying operation log log log displaystyle mathrm rank root mathrm rank log log left log frac sum weights decrease initial final potential bounded φ φ log displaystyle phi _ phi _ leq sum _ tree log frac maximum size single node minimum actual time bounded log log displaystyle left sum _ sequence log frac sum _ tree log frac performance theorems theorems conjectures worst case runtime performing sequence accesses splay tree elements dynamic optimality conjecture addition proven performance guarantees splay trees unproven conjecture great original sleator tarjan paper conjecture dynamic optimality conjecture basically claims splay trees perform binary search tree algorithm constant factor dynamic optimality conjecture displaystyle binary search tree algorithm accesses element displaystyle traversing path root displaystyle cost  displaystyle  accesses rotations tree cost  rotation displaystyle cost displaystyle perform sequence displaystyle accesses cost splay tree perform accesses displaystyle corollaries dynamic optimality conjecture remain unproven traversal conjecture  displaystyle t_   displaystyle t_  splay trees elements displaystyle sequence visiting elements  displaystyle t_  preorder depth search order total cost performing sequence displaystyle accesses  displaystyle t_  displaystyle deque conjecture displaystyle sequence displaystyle double ended queue operations push pop inject eject cost performing displaystyle splay tree displaystyle split conjecture displaystyle permutation elements splay tree cost deleting elements order displaystyle displaystyle variants order reduce number restructuring operations replace splaying semi splaying element splayed halfway root reduce restructuring splaying access operations access path longer threshold access operations