treap computer science treap randomized binary search tree closely forms binary search tree data structures maintain dynamic set ordered keys binary searches keys sequence insertions deletions keys shape tree random variable probability distribution random binary tree high probability height proportional logarithm number keys search insertion deletion operation takes logarithmic time perform description treap raimund seidel cecilia aragon portmanteau tree heap cartesian tree key randomly chosen numeric priority binary search tree inorder traversal order nodes sorted order keys structure tree determined requirement heap ordered priority number leaf node greater equal priority children cartesian trees generally root node maximum priority node left subtrees formed manner subsequences sorted order left node equivalent describing treap formed inserting nodes highest priority binary search tree rebalancing priorities independent random numbers distribution large space priorities ensure nodes priority shape treap probability distribution shape random binary search tree search tree formed inserting nodes rebalancing randomly chosen insertion order random binary search trees logarithmic height high probability true treaps aragon seidel assigning higher priorities frequently accessed nodes instance process access chooses random number replaces priority node number higher previous priority modification tree lose random shape frequently accessed nodes root tree causing searches faster naor nissim application maintaining authorization certificates public key cryptosystems operations treaps support basic operations search key apply standard binary search algorithm binary search tree ignoring priorities insert key treap generate random priority binary search tree create node leaf position binary search determines node exist long root tree larger priority number parent perform tree rotation reverses parent child relation delete node treap leaf tree simply remove single child remove tree child parent root tree parent finally children swap position tree position successor sorted order previous cases final case swap violate heap ordering property additional rotations performed restore property bulk operations addition single element insert delete lookup operations fast bulk operations defined treaps union intersection set difference rely helper operations split join split treap smaller treaps smaller key larger key insert treap maximum priority larger priority node treap insertion root node treap values left subtreap values greater subtreap costs single insertion treap joining treaps product split safely assume greatest treap smallest treap create node larger max treap smaller min treap assign minimum priority set left child heap child heap rotate heap order leaf node easily deleted result treap merged original treaps effectively undoing split costs generally join operation work treaps key arbitrary priority highest join algorithm function join prior prior return node prior return node left join return node join left split algorithm function split nil return nil false nil expose return true split return join split return join union treaps representing sets treap represents recursive algorithm computes union function union nil return nil return priority priority swap split key return join union left key union split presumed return trees holding keys input key holding greater keys algorithm destructive place destructive version exists algorithm intersection requires join helper routine complexity union intersection difference log treaps sizes recursive calls union independent executed parallel split union join deal balancing criteria treaps directly implementation called join based implementation note hash values keys priorities structurally equal nodes merged construction merged node unique representation set keys provided simultaneous root node representing set keys sets tested equality pointer comparison constant time technique enhance merge algorithms perform fast difference sets small input sets equal union intersection functions break returning input sets result difference function return set size symmetric difference modified merge algorithms bounded log randomized binary search tree randomized binary search tree introduced martínez roura subsequently work aragon seidel treaps stores nodes random distribution tree shape maintains nodes tree order maintain randomized structure storing random priorities node randomized binary search tree stores small integer node number descendants counting numbers maintained tree rotation operations constant additional time rotation key inserted tree nodes insertion algorithm chooses probability place root tree calls insertion procedure recursively insert left subtree depending key greater root numbers descendants algorithm calculate probabilities random choices step placing root subtree performed treap inserting leaf rotating upwards alternative algorithm martínez roura splits subtree pieces left children node deletion procedure randomized binary search tree node insertion procedure insertion procedure average random decisions join subtrees descending left children deleted node single tree subtrees joined average depth θ log joining trees size θ log random choices average left subtree node deleted join operation trivial left child deleted node selected subtree root probability proportional number descendants join proceeds recursively comparison stored node randomized binary tree simpler treap small integer high precision random number greater number calls random number generator log calls insertion deletion insertion insertion procedure complicated update numbers descendants node minor technical difference treap small probability collision keys priority cases statistical differences true random number generator pseudo random number generator typically digital computers case differences theoretical model perfect random choices design algorithm capabilities actual random number generators vanishingly small treap randomized binary search tree random distribution tree shapes update history modifications trees performed data structures sequence insertion deletion operations instance treap numbers inserted order number deleted remaining nodes parent child relationship prior insertion middle number randomized binary search tree tree deletion equally trees nodes independently tree looked prior insertion middle number