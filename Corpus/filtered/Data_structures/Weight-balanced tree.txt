weight balanced tree computer science weight balanced binary trees wbts type balancing binary search trees implement dynamic sets dictionaries maps sequences trees introduced nievergelt reingold s trees bounded balance bb α trees common knuth balancing trees wbts store bookkeeping pertaining balance nodes perform rotations restore balance disturbed insertion deletion operations node stores size subtree rooted node sizes left subtrees factor balance avl trees store height subtrees red black trees store fictional color bit bookkeeping wbt property applications number elements tree equal size root size needed implement operations order statistic tree largest element set determining element sorted order weight balanced trees popular functional programming community implement sets maps mit scheme slib implementations haskell description weight balanced tree binary search tree stores sizes subtrees nodes node fields key ordered type optional mappings left pointer node size type integer definition size leaf typically represented nil pointer size internal node sum sizes children size size left size based size defines weight weight size operations modify tree weight left subtrees node remain factor α rebalancing operations avl trees rotations double rotations formally node balance defined node α weight balanced weight left α weight weight α weight α numerical parameter determined implementing weight balanced trees larger values α produce balanced trees values α nievergelt reingold proved α displaystyle alpha frac sqrt approx condition balancing algorithm work work lower bound α arbitrarily small custom complicated rebalancing algorithm applying balancing correctly guarantees tree elements height log α log log α log displaystyle leq log _ frac alpha frac log _ log _ left frac alpha log number balancing operations required sequence insertions deletions linear balancing takes constant overhead amortized sense maintaining tree minimum search cost requires kinds double rotations avl tree insert delete operations desire logarithmic performance rotations required single pass set operations bulk operations set operations defined weight balanced trees union intersection set difference fast bulk operations insertions deletions implemented based set functions set operations rely helper operations split join operations implementation weight balanced trees efficient highly parallelizable join function join weight balanced trees key return tree elements requires greater keys smaller keys trees balanced weight join simply create node left subtree root subtree suppose heavier weight case symmetric join spine node balanced point node left child root child created replace node invalidate weight balanced invariant fixed single double rotation assuming α displaystyle alpha frac sqrt split split weight balanced tree smaller trees smaller key larger key draw path root inserting tree insertion values left path values greater applying join subtrees left merged keys path intermediate nodes form left tree asymmetric applications split returns boolean denoting appears tree cost split log displaystyle log order height tree algorithm special properties weight balanced tree generic balancing schemes avl trees join algorithm function joinrightwb expose balance return node joinrightwb expose balance return node balance balance return rotateleft node return rotateleft node rotateright function joinleftwb symmetric joinrightwb function join heavy return joinrightwb heavy return joinleftwb node balance displaystyle weights displaystyle displaystyle balanced expose extract tree node displaystyle left child displaystyle key node displaystyle child displaystyle node create node left child displaystyle key displaystyle child displaystyle split algorithm function split nil return nil false nil expose return true split return join split return join union weight balanced trees representing sets weight balanced tree represents recursive function computes union function union nil return nil return split root return join root union left union split presumed return trees holding keys input key holding greater keys algorithm destructive place destructive version exists algorithm intersection difference requires join2 helper routine join middle key based functions union intersection difference key multiple keys inserted deleted weight balanced tree split union join deal balancing criteria weight balanced trees directly implementation called join based algorithms complexity union intersection difference log displaystyle left log left weight balanced trees sizes displaystyle displaystyle geq complexity optimal terms number comparisons importantly recursive calls union intersection difference independent executed parallel parallel depth log log displaystyle log log displaystyle join based implementation computational directed acyclic graph dag single element insertion deletion root larger tree split smaller tree