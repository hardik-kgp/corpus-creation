search algorithm pronounced star graph traversal path search algorithm computer science completeness optimality optimal efficiency major practical drawback displaystyle space complexity stores generated nodes memory practical travel routing systems generally outperformed algorithms pre process graph attain performance memory bounded approaches solution cases peter hart nils nilsson bertram raphael stanford institute sri international published algorithm  extension edsger dijkstra  algorithm achieves performance heuristics guide search description informed search algorithm search meaning formulated terms weighted graphs starting specific starting node graph aims path goal node smallest cost distance travelled shortest time maintaining tree paths originating start node extending paths edge time termination criterion satisfied iteration main loop determine paths extend based cost path estimate cost required extend path goal selects path minimizes displaystyle node path cost path start node heuristic function estimates cost cheapest path goal terminates path chooses extend path start goal paths eligible extended heuristic function problem specific heuristic function admissible meaning overestimates actual cost goal guaranteed return cost path start goal typical implementations priority queue perform repeated selection minimum estimated cost nodes expand priority queue open set fringe step algorithm node lowest removed queue values neighbors updated neighbors queue algorithm continues goal node lower node queue queue goal cost shortest path goal admissible heuristic algorithm length shortest path actual sequence steps algorithm easily revised node path track predecessor algorithm node point predecessor node predecessor start node searching shortest route map represent straight distance goal physically smallest distance points heuristic satisfies additional condition edge graph denotes length edge called monotone consistent consistent heuristic guaranteed optimal path processing node equivalent running dijkstra algorithm reduced cost pseudocode pseudocode describes algorithm remark pseudocode node reached path removed openset subsequently reached cheaper path openset essential guarantee path returned optimal heuristic function admissible consistent heuristic consistent node removed openset path guaranteed optimal test tentative_gscore gscore neighbor fail node reached algorithm action nodes cities connected roads straight distance target point key green start blue goal orange visited algorithm real applications edges railroads great circle distance shortest distance sphere target algorithm searching path washington angeles implementation details number simple optimizations implementation details affect performance implementation note priority queue handles ties performance situations ties broken queue behaves lifo manner behave depth search equal cost paths avoiding exploring equally optimal solution path required search common node reference node parent search references recover optimal path references node priority queue entry path node cost standard approach check node appears priority queue priority parent pointers changed correspond lower cost path standard binary heap based priority queue directly support operation searching elements augmented hash table maps elements position heap allowing decrease priority operation performed logarithmic time alternatively fibonacci heap perform decrease priority operations constant amortized time special cases dijkstra algorithm uniform cost search algorithm viewed special case  displaystyle  general depth search implemented global counter initialized large time process node assign newly discovered neighbors single assignment decrease counter earlier node discovered higher displaystyle dijkstra algorithm depth search implemented efficiently including displaystyle node properties termination completeness finite graphs negative edge weights guaranteed terminate complete solution path start goal exists infinite graphs finite branching factor edge costs bounded ε  textstyle varepsilon  fixed ε displaystyle varepsilon guaranteed terminate exists solution admissibility search algorithm admissible guaranteed return optimal solution heuristic function admissible admissible intuitive proof terminates search path start goal actual cost lower estimated cost path start goal open node node displaystyle heuristic admissible estimates optimistic paragraph safely ignore nodes lead cheaper solution overlook possibility lower cost path start goal continue search possibilities exist actual proof bit involved displaystyle values open nodes guaranteed optimistic heuristic admissible displaystyle values open nodes guaranteed optimal sum displaystyle guaranteed optimistic optimal efficiency algorithm optimally efficient respect set alternative algorithms alts set problems problem algorithm alts set nodes expanded solving subset equal set nodes expanded solving definitive study optimal efficiency rina dechter judea pearl considered variety definitions alts combination heuristic admissible consistent admissible interesting positive result proved consistent heuristic optimally efficient respect admissible search algorithms pathological search problems roughly speaking notion pathological problem tie breaking result hold heuristic admissible consistent case dechter pearl exist admissible algorithms expand arbitrarily fewer nodes pathological problems optimal efficiency set nodes expanded number node expansions number iterations main loop heuristic admissible consistent node expanded times exponential number times worst case circumstances dijkstra algorithm outperform large margin bounded relaxation admissibility criterion guarantees optimal solution path examine equally meritorious paths optimal path compute approximate shortest paths speed search expense optimality relaxing admissibility criterion oftentimes bound relaxation guarantee solution path worse  ε times optimal solution path guarantee referred ε admissible number ε admissible algorithms weighted static weighting admissible heuristic function weighted version search ε ε  heuristic function perform search usual eventually faster fewer nodes expanded path search algorithm cost ε times cost path graph dynamic weighting cost function  ε displaystyle  varepsilon   displaystyle cases  frac leq  text cases displaystyle depth search anticipated length solution path sampled dynamic weighting sampling nodes estimate debias heuristic error ε displaystyle a_ varepsilon heuristic functions focal list select candidate nodes select promising node focal list ε selects nodes function displaystyle bh_ constants nodes selected algorithm backtrack function displaystyle dh_ constants alpha attempts promote depth exploitation preferring expanded nodes alpha cost function α  α displaystyle f_ alpha  w_ alpha α λ π λ displaystyle w_ alpha cases lambda leq tilde lambda text cases λ λ constants λ λ displaystyle lambda leq lambda π parent ñ expanded node complexity time complexity depends heuristic worst case unbounded search space number nodes expanded exponential depth solution shortest path branching factor average number successors state assumes goal state exists reachable start state state space infinite algorithm terminate heuristic function major practical performance search good heuristic prune nodes uninformed search expand quality expressed terms effective branching factor determined empirically problem instance measuring number nodes expanded depth solution solving    displaystyle    dots good heuristics low effective branching factor optimal  time complexity polynomial search space tree single goal state heuristic function meets condition log displaystyle log optimal heuristic exact cost goal error grow faster logarithm perfect heuristic returns true distance goal space complexity roughly graph search algorithms generated nodes memory practice turns biggest drawback search leading development memory bounded heuristic searches iterative deepening memory bounded sma applications commonly common pathfinding problem applications video games originally designed general graph traversal algorithm finds applications diverse problems including problem parsing stochastic grammars nlp cases include informational search online learning relations algorithms sets greedy search algorithm takes cost distance traveled account common variants dijkstra algorithm viewed special case heuristic  displaystyle  nodes turn dijkstra special cases dynamic programming special case generalization branch bound variants anytime anytime repairing ara anytime dynamic block field fringe fringe saving fsa generalized adaptive gaa incremental heuristic search informational search iterative deepening ida jump point search lifelong planning lpa bidirectional nba simplified memory bounded sma realtime theta time bounded tba adapted bidirectional search algorithm special care stopping criterion