depth search depth search dfs algorithm traversing searching tree graph data structures algorithm starts root node selecting arbitrary node root node case graph explores branch backtracking version depth search investigated th century french mathematician charles pierre trémaux strategy solving mazes properties time space analysis dfs differs application area theoretical computer science dfs typically traverse entire graph takes time displaystyle linear size graph applications space displaystyle worst case store stack vertices current search path set visited vertices setting time space bounds breadth search choice algorithms depends complexity properties vertex orderings algorithms produce applications dfs relation specific domains searching solutions artificial intelligence web crawling graph traversed large visit entirety infinite dfs suffer termination cases search performed limited depth limited resources memory disk space typically data structures track set visited vertices search performed limited depth time linear terms number expanded vertices edges number size entire graph vertices searched space complexity variant dfs proportional depth limit result smaller space needed searching depth breadth search applications dfs lends heuristic methods choosing branch depth limit priori iterative deepening depth search applies dfs repeatedly sequence increasing limits artificial intelligence mode analysis branching factor greater iterative deepening increases running time constant factor case correct depth limit geometric growth number nodes level dfs collect sample graph nodes incomplete dfs incomplete bfs biased nodes high degree graph depth search starting assuming left edges graph chosen edges assuming search remembers visited nodes repeat small graph visit nodes order edges traversed search form trémaux tree structure applications graph theory performing search remembering visited nodes visiting nodes order forever caught cycle reaching iterative deepening technique avoid infinite loop reach nodes output depth search convenient description depth search graph terms spanning tree vertices reached search based spanning tree edges original graph divided classes forward edges point node tree descendants edges point node ancestors cross edges tree edges edges belong spanning tree classified separately forward edges original graph undirected edges tree edges edges dfs ordering enumeration vertices graph dfs ordering output application dfs graph displaystyle graph displaystyle vertices σ  displaystyle sigma v_  dots v_ list distinct elements displaystyle  displaystyle setminus v_  dots v_ ν σ displaystyle nu _ sigma greatest displaystyle displaystyle v_ neighbor displaystyle displaystyle exists  displaystyle  σ  displaystyle sigma v_  dots v_ enumeration vertices displaystyle enumeration σ displaystyle sigma dfs ordering source  displaystyle v_   displaystyle  leq displaystyle v_ vertex   displaystyle setminus v_  dots v_  ν   displaystyle nu _ v_  dots v_  maximal recall displaystyle set neighbors displaystyle equivalently σ displaystyle sigma dfs ordering  displaystyle  leq leq displaystyle v_ v_ setminus v_ exists neighbor displaystyle v_ displaystyle v_ displaystyle vertex orderings depth search linearly order vertices graph tree common ways preordering list vertices order visited depth search algorithm compact natural describing progress search earlier article preordering expression tree expression polish notation postordering list vertices order visited algorithm postordering expression tree expression reverse polish notation reverse postordering reverse postordering list vertices opposite order visit reverse postordering preordering searching directed graph node sequence traversals choosing visit algorithm note repeat visits form backtracking node check unvisited neighbors included preorderings postorderings reverse postorderings reverse postordering produces topological sorting directed acyclic graph ordering control flow analysis represents natural linearization control flows graph represent flow control code fragment natural code order natural order pseudocode input graph vertex output vertices reachable labeled discovered recursive implementation dfs  procedure dfs  label discovered  directed edges adjacentedges  vertex labeled discovered  recursively dfs order vertices discovered algorithm called lexicographic order recursive implementation dfs worst case space complexity displaystyle  procedure dfs iterative  stack  push   pop  labeled discovered  label discovered  edges adjacentedges  push variations dfs visit neighbors vertex opposite order neighbor visited recursive variation list adjacent edges iterative variation visited neighbor list adjacent edges recursive implementation visit nodes graph order recursive implementation visit nodes recursive implementation breadth search differs ways stack queue delays checking vertex discovered vertex popped stack making check adding vertex applications algorithms depth search building block include finding connected components topological sorting finding  edge vertex connected components finding  edge vertex connected components finding bridges graph generating order plot limit set group finding connected components planarity testing solving puzzles solution mazes dfs adapted solutions maze including nodes current path visited set maze generation randomized depth search finding biconnectivity graphs complexity computational complexity dfs investigated john reif precisely graph displaystyle  displaystyle v_  dots v_ ordering computed standard recursive dfs algorithm ordering called lexicographic depth search ordering john reif considered complexity computing lexicographic depth search ordering graph source decision version problem testing vertex occurs vertex order complete meaning nightmare parallel processing depth search ordering lexicographic computed randomized parallel algorithm complexity class rnc  remained unknown depth traversal constructed deterministic parallel algorithm complexity class