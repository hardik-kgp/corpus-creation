push relabel maximum flow algorithm mathematical optimization push relabel algorithm alternatively preflow push algorithm algorithm computing maximum flows flow network push relabel basic operations algorithm execution algorithm maintains preflow gradually converts maximum flow moving flow locally neighboring nodes push operations guidance admissible network maintained relabel operations comparison ford fulkerson algorithm performs global augmentations send flow paths source sink push relabel algorithm considered efficient maximum flow algorithms generic algorithm polynomial  time complexity asymptotically efficient  edmonds karp algorithm specific variants algorithms achieve lower time complexities variant based highest label node selection rule  time complexity generally regarded benchmark maximum flow algorithms subcubic log  time complexity achieved dynamic trees practice efficient push relabel algorithm extended compute minimum cost flows idea distance labels led efficient augmenting path algorithm turn incorporated push relabel algorithm create variant higher empirical performance concepts definitions notations network capacity function â„ flow network chosen source sink vertices â„ denote pre flow â„ denote excess function respect flow defined â„ denote residual capacity function respect flow defined denote residual network respect flow push relabel algorithm nonnegative integer valid labeling function distance labels heights nodes determine arcs selected push operation labeling function denoted ğ“ â„• function satisfy conditions order considered valid valid labeling ğ“ ğ“  source condition ğ“ sink conservation ğ“  algorithm label values fixed ğ“ lower bound unweighted distance reachable disconnected ğ“ lower bound unweighted distance result valid labeling function exists paths paths longer  arc called admissible ğ“ ğ“  admissible network áº½ composed set arcs admissible admissible network acyclic operations initialization algorithm starts creating residual graph initializing preflow values performing set saturating push operations residual arcs exiting source labels initialized label source number nodes graph ğ“ nodes label initialization complete algorithm repeatedly performs push relabel operations active nodes applicable operation performed push push operation applies admissible arc active node moves min units flow push assert  ğ“ ğ“  Î´ min Î´ Î´ Î´ Î´ push operation reach called saturating push capacity residual arc excess node pushed residual arc called unsaturating saturating push relabel relabel operation applies active node admissible arcs modifies ğ“ minimum admissible arc created note increases ğ“ creates steep arc arc  ğ“ ğ“  relabel assert  ğ“ ğ“  ğ“ min ğ“   effects push relabel push relabel operation ğ“ remains valid labeling function respect push operation admissible arc add arc ğ“ ğ“  ğ“  remove arc effectively removes constraint ğ“ ğ“  relabel operation node preserves validity ğ“ notice trivially guaranteed definition arcs arcs increased ğ“ satisfy constraints tightly violate generic push relabel algorithm generic push relabel algorithm proof concept implementation details select active node push relabel operations generic version algorithm terminate  ğ“ ğ“  paths longer  order ğ“ satisfy valid labeling condition disconnected initialisation algorithm fulfills requirement creating pre flow saturates arcs ğ“  trivially valid initialisation algorithm repeatedly executes applicable push relabel operation operations apply point pre flow converted maximum flow generic push relabel create pre flow saturates arcs ğ“ ğ“  applicable push relabel operation execute operation correctness algorithm maintains condition ğ“ valid labeling execution proven true examining effects push relabel operations label function ğ“ relabel operation increases label minimum satisfy ğ“ ğ“  constraint push operation send flow ğ“ ğ“  add delete addition affect valid labeling ğ“ ğ“  deletion removes constraint valid labeling property ğ“ ğ“  applies residual arcs preflow valid labeling ğ“ exists augmenting path residual graph proven contradiction based inequalities labeling function supposing augmenting path exist algorithm terminates nodes active excess flow excess preflow obeys flow conservation constraint considered normal flow flow maximum flow max flow min cut theorem augmenting path algorithm return maximum flow termination time complexity order bound time complexity algorithm analyze number push relabel operations occur main loop numbers relabel saturating push nonsaturating push operations analyzed separately algorithm relabel operation performed      times labeling ğ“ node decrease maximum label   nodes relabel operation performed   times nodes  bound  relabel operation saturating push admissible arc removes arc arc reinserted saturating push relabeled push arc relabeled process ğ“ increases saturating pushes total number saturating pushes  time bound saturating push operations bounding number nonsaturating pushes achieved potential argument potential function Ï†  ğ“ Ï† sum labels active nodes obvious Ï†  initially stays nonnegative execution algorithm relabels saturating pushes increase Ï† Ï† equal  termination remaining active nodes algorithm execution execution algorithm nonsaturating pushes difference relabel saturating push operations order Ï† terminate  relabel operation increase Ï†    saturating push activates inactive push increasing Ï†   total contribution saturating pushes operations Ï†    nonsaturating push deactivates activate saturating push result decreases Ï† ğ“ ğ“  relabels saturating pushes increase Ï† total number nonsaturating pushes difference         time bound  nonsaturating push operations sum algorithm executes  relabels saturating pushes  nonsaturating pushes data structures designed pick execute applicable operation  time time complexity algorithm  sample execution generic push relabel algorithm defined simple network flow graph diagram values denote label ğ“ excess node execution algorithm residual graph residual arcs capacity larger residual graph multiple iterations perform operation loop initial flow  interactively practical implementations generic push relabel algorithm  time complexity efficient implementations achieve  lower time complexity enforcing rules selecting applicable push relabel operations empirical performance improved heuristics current arc data structure discharge operation current arc data structure mechanism visiting neighbors node flow network static circular order singly linked list neighbors created node data structure simple pointer list steps list rewinds head runs based current arc data structure discharge operation defined discharge operation applies active node repeatedly pushes flow node inactive relabeling create admissible arcs process discharge  current arc neighbors relabel rewind current arc current arc admissible push current arc point neighbor active node selection rules definition discharge operation reduces push relabel algorithm repeatedly selecting active node discharge depending selection rule algorithm exhibits time complexities sake brevity ignore referring nodes discussion fifo selection rule fifo push relabel algorithm organizes active nodes queue initial active nodes inserted arbitrary order algorithm removes node queue discharging inactive node active appended queue algorithm  time complexity relabel selection rule relabel push relabel algorithm organizes nodes linked list maintains invariant list topologically sorted respect admissible network algorithm scans list performs discharge operation current node active node relabeled moved list scan restarted algorithm  time complexity highest label selection rule highest label push relabel algorithm organizes nodes buckets indexed labels algorithm selects active node largest label discharge algorithm  time complexity lowest label selection rule time complexity  implementation techniques description generic push relabel algorithm ğ“ set node preferable perform backward breadth search compute exact labels algorithm typically separated phases phase computes maximum pre flow discharging active nodes labels phase converts maximum preflow maximum flow returning excess flow reach phase time complexity order push relabel operations dominated phase alternatively implemented flow decomposition heuristics crucial improving empirical performance algorithm commonly heuristics gap heuristic global relabeling heuristic gap heuristic detects gaps labeling function label  ğ“ node ğ“ ğ“ node ğ“ ğ“ disconnected relabeled  global relabeling heuristic periodically performs backward breadth search compute exact labels nodes heuristics skip unhelpful relabel operations bottleneck algorithm contribute ineffectiveness dynamic trees sample implementations