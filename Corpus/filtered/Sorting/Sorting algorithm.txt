sorting algorithm computer science sorting algorithm algorithm puts elements list order frequently orders numerical order lexicographical order efficient sorting optimizing efficiency algorithms search merge algorithms require input data sorted lists sorting canonicalizing data producing human readable output formally output sorting algorithm satisfy conditions output nondecreasing order element smaller previous element desired total order output permutation reordering retaining original elements input input data stored array random access list sequential access algorithms applied type data suitable modification sorting algorithms referred word word sort grammatically english noun phrases sentence inefficient insertion sort large lists phrase insertion sort refers insertion sort sorting algorithm classification sorting algorithms classified computational complexity worst average behavior terms size list typical serial sorting algorithms good behavior log parallel sort log bad behavior big notation ideal behavior serial sort average case optimal parallel sorting log comparison based sorting algorithms Ï‰ log comparisons inputs computational complexity swaps place algorithms memory usage computer resources sorting algorithms place strictly place sort memory items sorted log additional memory considered place recursion algorithms recursive recursive merge sort stability stable sorting algorithms maintain relative order records equal keys values comparison sort comparison sort examines data comparing elements comparison operator general method insertion exchange selection merging exchange sorts include bubble sort quicksort selection sorts include shaker sort heapsort algorithm serial parallel remainder discussion exclusively concentrates serial algorithms assumes serial operation adaptability presortedness input running time algorithms account adaptive stability stable sort algorithms sort repeated elements order input sorting kinds data data examined determining sort order card sorting cards sorted rank suit possibility multiple correctly sorted versions original list stable sorting algorithms choose rule items compare equal cards relative order preserved input output stability reason data sorted student cases dynamically webpage data sorted class imagine students order names shuffled order annoying sorting algorithm stable student names good order user previous chosen sort orders preserved screen stable sort algorithm reason stability users programmers choose sort sorting sort sort algorithm stable users formally data sorted represented record tuple values data sorting called key card cards represented record rank suit key rank sorting algorithm stable records key appears original list sorted list equal elements indistinguishable integers generally data entire element key stability issue stability issue keys unstable sorting algorithms specially implemented stable artificially extend key comparison comparisons objects equal keys decided order entries original input list tie breaker remembering order require additional time space application stable sorting algorithms sorting list primary secondary key suppose sort hand cards suits order clubs diamonds hearts spades suit cards sorted rank sorting cards rank sort stable sort suit suit stable sort preserves ordering rank idea extended number keys utilised radix sort achieved unstable sort lexicographic key comparison compares suit compares rank suits popular sorting algorithms large number sorting algorithms practical implementations algorithms predominate insertion sort small data sets large data sets asymptotically efficient sort heap sort merge sort quicksort efficient implementations generally hybrid algorithm combining asymptotically efficient algorithm sort insertion sort small lists recursion highly tuned implementations sophisticated variants timsort merge sort insertion sort additional logic android python introsort quicksort heap sort variant forms sort implementations net restricted data numbers fixed interval distribution sorts counting sort radix sort bubble sort variants rarely practice commonly teaching theoretical discussions physically sorting objects alphabetizing papers tests books people intuitively generally insertion sorts small sets larger sets people bucket initial letter multiple bucketing practical sorting large sets space cheap spreading objects floor large area operations expensive moving object large distance locality reference merge sorts practical physical objects hands list merge algorithms heap sort quick sort suited human algorithms library sort variant insertion sort leaves spaces practical physical simple sorts simplest sorts insertion sort selection sort efficient small data low overhead efficient large data insertion sort generally faster selection sort practice fewer comparisons good performance sorted data preferred practice selection sort fewer writes write performance limiting factor insertion sort insertion sort simple sorting algorithm efficient small lists sorted lists sophisticated algorithms works elements list inserting correct position sorted list money wallet arrays list remaining elements share array space insertion expensive requiring shifting elements shellsort variant insertion sort efficient larger lists selection sort selection sort place comparison sort complexity making inefficient large lists generally performs worse insertion sort selection sort simplicity performance advantages complicated algorithms situations algorithm finds minimum swaps position repeats steps remainder list swaps swapping expensive efficient sorts practical general sorting algorithms based algorithm average time complexity generally worst case complexity log common heap sort merge sort quicksort advantages drawbacks simple implementation merge sort additional space simple implementation quicksort worst case complexity problems solved ameliorated cost complex algorithm algorithms asymptotically efficient random data practical efficiency real data modifications overhead algorithms smaller data hybrid algorithm commonly switching insertion sort data small algorithms perform sorted data sorted data common real data sorted time algorithms finally unstable stability desirable property sort sophisticated algorithms employed timsort based merge sort introsort based quicksort falling heap sort merge sort merge sort takes advantage ease merging sorted lists sorted list starts comparing elements swapping merges lists lists merges lists lists merged final sorted list algorithms scales large lists worst case running time log easily applied lists arrays requires sequential access random access additional space complexity involves large number copies simple implementations merge sort surge popularity practical implementations sophisticated algorithm timsort standard sort routine programming languages python jdk7 merge sort standard routine perl jdk1 heapsort heapsort efficient version selection sort works determining largest smallest element list placing list continuing rest list accomplishes task efficiently data structure called heap special type binary tree data list heap root node guaranteed largest smallest element removed list heap rearranged largest element remaining moves root heap finding largest element takes log time linear scan simple selection sort heapsort log time worst case complexity quicksort quicksort divide conquer algorithm relies partition operation partition array element called pivot selected elements smaller pivot moved greater elements moved efficiently linear time place lesser greater sublists recursively sorted yields average time complexity log low overhead popular algorithm efficient implementations quicksort place partitioning typically unstable sorts complex fastest sorting algorithms practice modest log space usage quicksort popular sorting algorithms standard programming libraries caveat quicksort worst case performance rare naive implementations choosing element pivot occurs sorted data common case complex issue quicksort choosing good pivot element consistently poor choices pivots result drastically slower performance good choice pivots yields log performance asymptotically optimal step median chosen pivot algorithm works log finding median median medians selection algorithm operation unsorted lists exacts overhead sorting practice choosing random pivot yields log performance shellsort shellsort invented donald shell improves insertion sort moving order elements position time concept shellsort insertion sort performs bubble sort variants bubble sort variants cocktail sort simple highly inefficient sorts frequently introductory texts theoretical ease analysis rarely practice recreational variants shell sort open questions behavior bubble sort bubble sort simple sorting algorithm algorithm starts data set compares elements greater swaps continues pair adjacent elements data set starts elements repeating swaps occurred pass algorithm average time worst case performance rarely sort large unordered data sets bubble sort sort small number items asymptotic inefficiency high penalty bubble sort efficiently list length sorted elements place number elements place position bubble sort exchange order pass pass elements order sort time comb sort comb sort simple sorting algorithm based bubble sort originally designed rediscovered popularized stephen lacey richard box byte magazine article published april basic idea eliminate turtles small values list bubble sort slow sorting tremendously rabbits large values list pose problem bubble sort accomplishes initially swapping elements distance array swapping elements adjacent shrinking chosen distance operating normal bubble sort shellsort thought generalized version insertion sort swaps elements spaced distance comb sort thought generalization applied bubble sort distribution sort distribution sort refers sorting algorithm data distributed input multiple intermediate structures gathered output bucket sort flashsort distribution based sorting algorithms distribution sorting algorithms single processor distributed algorithm individual subsets separately sorted processors combined external sorting data large fit single computer memory counting sort counting sort applicable input belong set possibilities algorithm runs time memory length input works creating integer array size bin count occurrences member input input counted incrementing bin afterward counting array looped arrange inputs order sorting algorithm small algorithm efficient extremely fast demonstrates great asymptotic behavior increases modified provide stable behavior bucket sort bucket sort divide conquer sorting algorithm generalizes counting sort partitioning array finite number buckets bucket sorted individually sorting algorithm recursively applying bucket sorting algorithm bucket sort works elements data set evenly distributed buckets radix sort radix sort algorithm sorts numbers processing individual digits numbers consisting digits sorted time radix sort process digits number starting digit lsd starting digit msd lsd algorithm sorts list digit preserving relative order stable sort sorts digit sorted list lsd radix sort requires stable sort msd radix sort algorithm stable sorting desired place msd radix sort stable common counting sort algorithm internally radix sort hybrid sorting approach insertion sort small bins improves performance radix sort memory usage patterns sorting size array sorted approaches exceeds primary memory slower disk swap space employed memory usage pattern sorting algorithm algorithm fairly efficient array fit easily ram impractical scenario total number comparisons number times sections memory copied swapped disk dominate performance characteristics algorithm number passes localization comparisons raw number comparisons comparisons nearby elements happen bus speed caching cpu speed compared disk speed virtually instantaneous popular recursive quicksort algorithm reasonable performance adequate ram recursive copies portions array practical array fit ram number slow copy operations disk scenario algorithm preferable requires total comparisons work problem works complex records relational database sorted small key field create array sort entire array sorted version entire array produced pass reading unnecessary sorted adequate smaller entire array fit easily memory entire array effectively eliminating disk swapping problem procedure called tag sort technique overcoming memory size problem external sorting ways combine algorithms takes advantage strength improve performance instance array subdivided chunks size fit ram contents chunk sorted efficient algorithm quicksort merged merge mergesort faster performing mergesort quicksort entire list techniques combined sorting large sets data vastly exceed memory sorted algorithm combination algorithms designed perform virtual memory reduce swapping required algorithms problems include partial sorting sorting smallest elements list alternatively computing smallest elements unordered selection computing smallest element solved inefficiently total sort efficient algorithms exist derived generalizing sorting algorithm notable quickselect quicksort conversely sorting algorithms derived repeated application selection algorithm quicksort quickselect pivoting differing recurses sides quicksort divide conquer quickselect decrease conquer kind opposite sorting algorithm shuffling algorithm fundamentally require source random numbers shuffling implemented sorting algorithm random sort assigning random number element list sorting based random numbers generally practice simple efficient algorithm shuffling fisher yates shuffle