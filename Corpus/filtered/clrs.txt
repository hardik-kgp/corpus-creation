introduces probabilistic analysis randomized algorithms typically probabilistic analysis determine running time gorithm cases presence inherent probability distribution running time differ inputs size cases assume inputs conform probability distribution averaging running inputs cases probability distribution inputs random choices algorithm gorithm behavior determined input values produced randomnumber generator randomized algorithm randomized algorithms enforce probability distribution inputsthereby ensuring input poor performanceor bound error rate algorithms allowed produce incorrect limited basis appendices mathematical material helpful read book material appendix chapters read book specific notational conventions differ cases appendices reference material hand obably material chapters appendices written tutorial flavor chapter role algorithms computing algorithms study gorithms worthwhile wh role algorithms relative technologies computers chapter answer questions algorithms informally algorithm welldefined computational procedure takes set values input produces set values output algorithm sequence computational steps transform input output view algorithm tool solving computational problem statement problem specifies gene ral terms desired inputoutput relationship algorithm describes specific computationa procedure achieving inputoutput relationship sort seque nce numbers nondecreasing order problem arises frequently practice fertile ground introducing standard design techniques analysis tools formally define sorting problem input sequence numbers output permutation reordering input sequence input sequence sorting algorithm returns output sequence input sequence called instance sorting problem general instance problem consists input satisfying constraints imposed problem statement needed compute solution problem sorting fundamental operation puter science programs intermediate step result large number good rting algorithms developed algorithm application depends onamong factorsthe number items sorted extent items sorted restrictions item values kind storage device main memory disks tapes algorithm correct input instance halts correct output correct algorithm solves computational problem incorrect algorithm halt input inst ances halt answer desired contrary mi ght expect incorrect algorithms error rate controlled chapter study algorithms finding large prime numbers ordinarily concerned correct algorithms algorithm english computer program hardware design requirement specification provide precise description computational procedure kinds problems solved algorithms sorting computationa problem algorithms developed suspected wh size book practical applications algorithms ubiquit ous include examples human genome project goals identifying genes human dna determining sequences billion chemical base pairs human dna storing databases developing tools data analysis steps requires sophisticated algorithms solutions problems involved scope book ideas chapters book solution biological problems enabling scientists accomplish tasks resources efficiently savings time human machine money extracted laboratory techniques internet enables people access retrieve large amounts order clever algorithms employed manage manipulate large volume data amples problems solved include finding good routes data travel techniques solving problems chapter search engine sides techniques chapters electronic commerce enables goods serv ices negotiated exchanged electronically ability informa tion credit card numbers passwords bank statements private essential electronic commerce publickey cryptography digital signatures covered chapter core technologies based numerical algorithms number theory manufacturing comm ercial settings portant allocate scarce resources bene ficial oil company place wells order maximize expect profit candidate presidency united states determine spend money buying campaign advertising order maximize chan ces winning election airline assign crews flights leas expensive making flight covered government regulations garding crew scheduling met internet service provider determine place additional resources order serve customers effectively examples problems solved lin ear programming study chapter details examples scope book underlying techniques apply problems problem areas solve concrete problems book including road map distance pair adjacent intersections marked goal determine shortest route intersection number routes huge disallow routes cross themselv choose routes shortest model road map model actual roads graph meet chapter appendix shortest path rtex graph solve problem efficiently chapter sequence matrices determine product matrix multiplication associative legal multiplication orders perform matrix multiplications product parenthesized orders a1a2a3a4 a1a2a3a4 a1a2a3a4 a1a2a3a4 a1a2a3a4 matrices square size multiplication order affect long matrix multiplications matrices differing sizes sizes compa tible matrix multiplication multiplication order big difference number multiplication orders exponential orders long time chapter general technique dynamic programming solve problem efficiently equation mod integers integers modulo satisfy equation solution simplyorder chapter efficient method points plane convex hull points convex hull smallest convex polygon points intuitively point ing represented nail sticking board convex hull represented tight rubber band surrounds nails nail rubber band turn vertex convex hull figuresubsets points vertices convex hull knowing points vertices convex hull order choices erefore vertices convex hull chapter good methods finding convex hull lists exhaustive surmised books heft exhibit characteristics common interesting algorithms candidate solutions finding challenge practical applications oblems list shortest paths easiest examples transportation firm trucking railroad company financial findi shortest paths road rail network shorter paths lower labor fuel costs routing node internet shor test path network order route message data structures book data structures data structure store organize data order facilitate access modifications single data structure works purposes kn strengths limitations technique book cookbook algorithms someday encounter problem pub lished algorithm exercises problems book book teach techniques algorithm design analysis develop algorithms correct answer understand efficiency hard problems book efficient algorithms usual measure efficiency speed long algorithm takes produce resu problems efficient solution chapter studies interesting subset problems npcomplete npcomplete problems interesting firs efficient algorithm np complete problem proven efficient algorithm exist unknown efficient algorithms exist npcomplete problems set npcom plete problems remarkable property efficient algorithm exists efficient algorithms exist relationship npcompl ete problems lack efficient solutions tantalizing seve ral npcomplete problems identical problems efficient algorithms small change problem statement big change efficiency algorithm valuable npcomplete problems surprisingly real applications called produce efficient algorithm np complete problem spend lot time fruitless search problem npcompl ete spend time developing efficient algorithm good solution concrete trucking mpany central warehouse day loads truck warehouse sends locations deliveries day truck warehouse ready loaded day reduce costs company select order delivery stops yields west distance traveled truck problem wellknown travelingsalesman problem npcomplete efficient algorithm assumptions ere efficient algorithms distance smallest chapter discusses approximation algorithms exercises realworld computational problems appears sorting determining order multip lying matrices finding convex hull exercises speed measures efficiency realworld setting exercises select data structure discuss strengths limitations exercises shortestpath travelingsalesman problems exercises realworld problem solution solution good algorithms technology suppose computers infinitely fast computer memory free reason study algorithms swer reason demonstrate solution method rminates ith correct answer computers infinitely fast correct method solving problem implementation bounds good software engineering practice designed documented whichever method easiest implement computers fast infinitely fast memory cheap free computing time bounded resource space memory resources wisely algorithms efficient terms time space efficiency algorithms devised solve problem differ dramatically efficiency differences signifi differences hardware software chapter algorithms sorting insertion sort takes time roughly equal c1n2 sort items constant depend takes time roughly proportional merge sort takes time roughly equal c2n lg lg stands log2 constant depend insertion sort sma ller constant factor merge sort constant factors running time dependence input size merge sort factor lg running time insertio sort factor larger insertion sort faster merge sort small input sizes input size large merge sorts advantage lg compensate difference constant factors matter smaller crossover point merge sort faster concrete pit faster computer computer running insertion sort slower computer computer running merge sort sort array numbers suppose computer executes billion instructions computer executes instru ctions computer times faster computer raw compu ting power difference dramatic suppose worlds craftiest programmer codes insertion sort machine language computer code requires instructions sort numbers merge sort hand programmed computer average programmer highlevel language inefficient compiler code lg instructions sort numbers computer takes computer takes algorithm running time grow slowly poor compiler computer runs times faster computer advantage merge sort pronounced sort numbers insertion sort takes days merge sort takes minutes genera problem size increases relative advantage merge sort algorithms technologies algor ithms computer hardware technology total performance depends choosing efficien algorithms choosing fast hardware rapid advances computer technologies algorithms algorithms contemporary computers light advanced technologies hardware high clock rates pipelining superscalar architectures easytouse intuitive graphi cal user interfaces guis objectoriented systems localarea widearea networking answer applications explicitly require algorithmic content appli cation level simple webbased applications require degree algorithmic content webbased service determines travel location everal services existed time writing plementation rely fast hardware graphical user interface widearea networ king object orientation require algorithms operatio finding routes shortestpath algorithm rendering maps interpolating addresses application require algorithmic conten application level relies heavily algorithms application rely fast hardware hardware design algorithms appli cation rely graphical user interfaces design gui relies algorithms application rely networking routing networks relies heavily algorithms application wri tten language machine code processed compiler interpreter assembler extensive algorithms algorithms core technologies contemporary computers everincreasing capacities computers solve larger problems comparison insertion sort merge sort larger problem sizes differences efficiencies algorithms prominent solid base algorithmic knowledge technique characteristic separates skilled programmers novices modern computing technology accomplish tasks wit hout knowing algorithms good background algorithms exercises application requires algorithmic ontent application level discuss function algorithms involved exercises suppose comparing implementations insertion sort merge sort machine inputs size insertion sort runs steps merge sort runs lg steps values insertion sort beat merge sort exercises smallest algorithm running time runs faster algorithm running time machine problems comparison running times function time table determine largest size problem solved time assuming algorithm solve problem takes microseconds minute1 hour day month1 year1 centurylg lg n3 chapter notes excellent texts genera topic algorithms including aho hopcroft ullman baase van gelder brassard bratley goodrich tamassia horowitz sahni rajasekaran kingston knuthkozen manber mehlhornpurdom brown reingold nievergelt deo sedgewick skiena wilf practical aspect algorithm design discussed bentley gonnet surveys field algorithms handbook theoretical computer science volume crc handbook algorithms theory computation overviews algorithms computational biology textbooks gusfield pevzner setubal medinas waterman chapter started chapter familiarize framework book design analysis algorithms contained include references material introduced chapters summations appendix solve examining insertion sort algorith solve sorting problem introduced chapter define pseudocode familiar readers computer programming algorithms algorithm argue rrectly sorts analyze running time analysis introduces notation focuses time increases number items sorted discussion insertion sort introduce divide conquer approach design algorithms develop algorithm called merge sort analysis merge sorts running time insertion sort algorithm insertion sort solves sorting problem introduced chapter input sequence numbers output permutation reordering input sequence numbers sort keys book typically algorithms programs written pseudocode respects pascal ja introduced languages trouble reading algorithms separates pseudocode real code eudocode employ expressive method clear concise algorithm clearest method english surprised english phr ase sentence embedded real code difference pseudocode real code pseudocode typically concerned issues software engineering issues data abstraction modularity error handling order convey essence algorithm concisely start insertion sort efficient algorithm sorting small number elements insertion sort works ople sort hand playing cards start left hand cards face table remove card time table insert correct position left hand correct position card compare cards hand left illustrated figure times cards held left hand sorted cards originally cards pile table figure sorting hand cards insertion sort pseudocode insertion sort presented procedure called insertionsort takes parameter array sequence length sorted code number elements denoted lengtha input numbers sorted place numbers rearranged array constant number stored array time input array sorted output sequence insertionsort finished insertionsorta lengtha key insert sorted sequence ai key ai aiai key loop invariants correctness insertion sort figure algorithm works current card inserted hand iteration outer loop indexed subarray consisting elements constitute sorted hand elements correspond pile cards table fact elements elements originally positions sorted order state properties formally loop invariant start iteration loop lines subarray consists elements originally sorted order figure operation insertionsort array array indices rectangles values stored array positions rectangles iterations loop lines iteration black rectangle holds key compared values shaded rectangles left test sh aded arrows array values moved position black arrows indi cate key moved final sorted array loop invariants understand algorithm correct things loop invariant initialization true prior iteration loop maintenance true iteration loop remains true iteration termination loop terminates invari ant property helps algorithm correct properties hold loop invariant true prior iteration loop note similarity mathematical induc tion prove property holds prove base case inductive step showing invariant holds iteration base case showing invariant holds iteration iteration inductive step property loop invariant correctness differs usual mathematical induction inductive step infinitely induction loop terminates properties hold insertion sort initialization start showing loop invariant holds loop iteration subarray consists single element fact original element subarray sorted trivially loop invariant holds prior iteration loop maintenance tackle prope rty showing iteration maintains loop invariant formally body outer loop works movingposition proper position lines point inserted formal treatment econd property require state loop invariant loop point prefer bogged formalism rely informal analysis property holds outer loop termination finally examine loop terminates insertion sort outer loop ends exceeds substituting wording loop invariant subarray consists elements originally sorted order subarray entire array entire array sorted algorithm correct method loop invariants correctness chapter chapters pseudocode conventions conventions pseudocode indentation block structure body loop consists lines body loop lines indentation style applies ifthenelse statements indentation stead conventional indicators block structure statements greatly reduces clutter preserving enhancing clarity2 looping constructs repeat conditional constructs interpretations pascal subtle difference respect loops pascal loopcounter variable undefined exiting loop book loop counter retains exiting loop loop loop counters exceeded loop bound property correctness argument insertion sort loop header lengtha loop terminates lengtha1 equivalently n1 length symbol remainde comment multiple assignment form assigns variables expression treated equivalent assignment assignment variables key local procedure global variables explicit indication array elements accessed array square brackets ai ith element array notation range values array subarray consisting elements compound data typically organized objects composed attributes fields field accessed field object square brackets treat array object attribute length indicating ements number elements array write lengtha square brackets array indexing object attributes ill clear context interpretation intended variable representing array object treated pointer data representing array object fields object setting fx set fx afterward fx point object assignment pointer refer object case special nil parameters passed procedure called procedure receives copy parameters assigns parameter change calling procedure objects passed pointer data representing object copied objects fields parameter called procedure assignment called procedure visible calling procedure assignment visible boolean operators short circuiting evaluate expression evaluate evaluates false entire expression evaluate true evaluate hand evaluates true evaluate determine entire expression expression evaluate expression evaluates false shortcircuiting operators write boolean expressions nil fx worrying evaluate fx nil exercises figure model illustrate operat ion insertionsort array exercises rewrite insertionsort procedure sort nonincreasing nondecreasing order exercises searching problem input sequence numbers output ai special nil write pseudocode linear search scans sequence loop invariant prove gorithm correct loop invariant fulfills properties exercises problem adding nbit binary integers stored nelement arrays sum integers stored binary form element array state problem formally write pseudocode adding integers loop loop moment chec loop invariant prior iteration initi assignment loop counter variable test loop header case insertionsort time assigning variable test lengtha real programming languages generally advisable indentation block structure levels indentation hard determine code split blockstructured languages equivalent constructs exact syntax differ pascal analyzing algorithms analyzing algorithm pred icting resources algorithm requires occasionally resources memory communica tion bandwidth computer hardware primary concern ofte computational time measure generally analyzing candidate algorithms problem efficient easily identified analysis viable candidate inferior algorithms ually discarded process analyze algorithm model implementation technology including model res ources technology costs book assume generic oneprocessor randomaccess machine ram model computation implementation technology understand algorithms implemented computer programs ram model instructions executed concurrent operations chapters occasion investigate models digital hardware strictly speaking precisely define instructions ram model costs tedious yield insight algorithm design analysis careful abuse ram model ram instruction sorts sort instruction ram unrealistic real computers su instructions guide real puters designed ram del instructions commonly real computers arithmetic add subtract multiply divide remainder floor ceiling data movement load store copy control conditional unconditional branch subroutine return instruction takes constant time data types ram model integer floating point typically concern precision book applicati ons precision crucial assume limit size word data working inputs size typically assume integers represented lg bits constant require word hold enabling individual input elements restrict constant word size grow arbitrarily word size grow arbitrarily store huge amounts data word operate constant timeclearly unrealistic scenario real computers instruc tions listed instructions represent gray area ram model expone ntiation constanttime instruction general case takes instructions compute xy real numbers restricted situations exponentiation constanttime operation computers shift left instruction constant time shifts bits integer positions left computers shiftin bits integer position left equivalent multiplication shifting bits positions left equivalent multiplication computers compute constanttime instruction shifting integer positions left long number bits computer word endeavor avoi gray areas ram model treat computation constanttime operation small positive integer ram model attempt model memory hierarchy common contemporary computers mode caches virtual memory implemented demand paging computational models attempt account memoryhierarchy effects times real programs real machines handful problems book amine memoryhierarchy effects analyses book models include memory hierarchy bit complex ram model difficult work rammodel analyses excellent predic tors performance actual machines analyzing simple algorithm ram model challenge mathematical tools required include combinatorics proba bility theory algebraic dexterity ability identify gnificant terms formula behavior algorithm nput summarizing behavior simple easily understood formulas typically select mach ine model analyze algorithm face choices deciding expres analysis simple write manipulate impor tant characteristics algorithms resource requirements suppresses tedious details analysis insertion sort time insertionsort procedur depends input sorting numbers takes longer sorting num bers insertionsort amounts time sort input sequences size depending sorted general time algorithm grows size input traditional running time program function size input define terms running time size input carefully notion input size depends problem studied problems sorting computing discrete fourie transforms natural measure number items inputfor array size sorting problems multiplying integers measure input size total number bits needed represent input ordinary binary notation size input numbers ther instance input algorithm graph input ze numbers vertices edges graph input size measure problem study running time algorithm input number primitive operations steps executed convenient define notion step machine independent moment adopt view constant time required execute pseudocode time assume execution ith takes time constant view point keeping ram model reflects pseudocode implemented actual computers discussion expression running time insertionsort evolve messy formula statement costs simpler notation concise easily manipulate simpler notation easy determine algorithm efficient start presenting insertionsort procedure time cost statement number times statement executed lengtha number times loop test executed loop exits usual test loop header test executed time loop body assume comments executable statements time insertionsorta cost times lengtha key insert sorted sequence ai key ai ai ai key running time algorithm sum running times statement executed statement takes steps execute executed times contribute cin total running time5 compute running time sertionsort sum products cost times columns obtaining inputs size algorithms running time depend input size insertion sort case occurs array sorted ai key initial bestcase running time c1n c2n running time expressed constants depend statement costs linear function array reverse sorted orderthat decreasing orderthe worst case compare element element entire sorted subarraynoting appendix review solve summations worst case running time insertionsort worstcase running time expressed an2 constants depend statement costs quadratic function typically insertion sort running time algorithm fixed input chapters interesting randomized algorithms behavior vary fixed input worstcase averagecase analysis analysis insertion sort looked case input array sorted worst case input array reverse sorted remainder book concentrate finding worstcase running time longest running time input size reasons orientation worstcase running time algorith upper bound running time input knowing guarantee algorithm longer educated guess running time hope worse algorithms worst case occurs fairly searching database piece inform ation searching algorithms worst case occur database searching applications searches absent frequent average case roughly bad worst case suppose randomly choose numbers apply insertion sort long determine subarray insert element average half elements half elements greater average check half subarray j2 work averagecase running time turns quadratic function input size worstcase running time cases interested averagecase expected running time algorithm chapter technique probabilistic analysis determine expected running times problem performing averagecase analysis appare constitutes average input problem assume inputs size equally practice assumption vi olated randomized algorithm random choices probabilistic analysis order growth simplifying abstractions ease analysis insertionsort procedure actual cost statement constants represent costs observed constants worstcase running time an2 constants depend statement costs ual statement costs abstract costs mplifying abstraction rate growth order growth running time interests leading term formula an2 lowerorder terms insignificant large ignore leading rms constant coefficient nce constant factors rate growth determin ing computational efficiency large inputs write insertion sort worstcase running time pronounced theta nsquared notation informally chapter defined precisely chapter algorithm ficient worstcase running time lower order growth cons tant factors lowerorder terms evaluation error small inputs large inputs algorithm worst case n3 algorithm exercises express function n31000 terms notation exercises sorting numbers stored array finding smallest element exchanging element smallest element exchange continue manner elements write pseudocode algorithm selection sort loop invariant algorithm maintain elements elements bestcase worst case running times selection sort notation exercises linear search exercise elements input sequence checked average assuming element searched equally element array worst case averagecase worstcase running times linear search notation justify answers exercises modify algorith good bestcase running time subtleties computational steps english variants procedure requires constant time book sort points xcoordinate takes constant time note statement calls subroutine takes constant time subroutine invoke separate process calling subroutinepassing parameters etcfrom process executing subroutine characteristic hold resource memory statement references memory executed times consume memory total designing algorithms ways design algorithms insertion sort incremental approach sorted subarray insert single element proper place yielding sorted subarray examine alternative sign approach divide conquer divide conquer design sorting algorithm worstcase running time insertion sort advantage divide conquer algorithms running times easily determin techniques introduced chapter divide conquer approach algorithms recursive structure solve problem recursively times deal closely rela ted subproblems algorithms typically follow divide conquer approach break problem subproblems milar original problem smaller size solve subproblems recursively combine solutions create solution original problem divide conquer paradigm involves thr steps level recursion divide problem number subproblems conquer subproblems solving recursively subproblem sizes small solve subpr oblems straightforward manner combine solutions subproblems solution original problem merge sort algorithm closely divide conquer paradigm intuitively operates divide divide nelement sequence sorted subsequences elements conquer sort subsequences recursively merge sort combine merge sorted subsequences produce sorted answer recursion bottoms sequence sorted length case work sequence length sorted order key operation merge sort algorithm merging sorted sequences combine step perform merging auxiliary procedure mergea array indices numbering elements array procedure assumes subarrays aq sorted order merges form single sorted subarr replaces current subarray merge procedure takes time number elements merged works returning cardplaying motif suppose piles cards face table pile sorted smallest cards merge piles single sorted pile face table basic step consists choosing smaller cards faceup piles removing pile exposes card placing card face output pile repeat step input pile time remaining input pile place ace output pile computationally basic step takes constant time checking cards perform basic steps merging takes time pseudocode implements idea additional twist avoids check pile basic step idea pile sentinel card special valu simplify code sentinel card exposed smaller card piles sentinel cards exposed nonsentinel cards output pile advance cards output pile performed basic steps mergea n1create arrays l1 n1 r1n1 li aq ln1 rn2li ak liak merge procedure works computes length n1 subarray computes length subarray aq create arrays left lengths n1loop lines copies subarray l1 n1 loop lines copies subarray aq r1 lines sentinels ends arrays lines illustrated figure perform basic steps maintaining loop invariant start iteration loop lines subarray smallest elements l1 n1 r1 sorted order li smallest elements arrays copied figure operation lines mergeasubarray a9 sequence copying inserting sentinels array array lightly shaded positions final values lightly shaded positions values copied lightly shaded positions comprise values originally a9 sentinels heavily shaded positions values pied heavily shaded positions values copied arrays respective indices prior iteration loop lines arrays indices termina tion point subarray a9 sorted sentinels elements arrays copied loop invariant holds prior iteration loop lines iteration loop maintains invariant invariant property correctness loop terminates initialization prior iteration loop subarray subarray smallest elements li smallest elements arrays copied maintenance iteration maintain loop invariant suppose li li smallest element copied smallest elements copies li ak subarray smallest elements incrementing loop update reestablishes loop invariant iteration li lines perform action maintain loop invariant termination termination loop invariant subarray smallest elements l1 n1 r1 sorted order arrays n1 elements larg copied largest elements sentinels merge procedure runs time observe lines takes constant time loops lines n1 time iterations loop lines takes constant time merge procedure su broutine merge sort algorithm procedure mergesorta sorts elements subarray subarray element therefor sorted divide step simply computes partitions subarrays elements aq elements mergesortamergesorta mergesorta mergea sort entire sequence initial merge sorta lengtha lengtha figure illustrates operation procedure bottomup power algorithm consists merging pairs item sequences form sorted sequences length merging pairs sequences length form sorted sequences length sequences length merged form final sorted sequence length figure operation merge sort array lengths sorted sequences merged increase algorithm progresses analyzing divide conquer algorithms algorithm recursive running time recurrence equation recurrence describes running time problem size terms running time smaller inputs mathematical tools solve recurrence provide bounds performance algorithm recurrence running time divi deandconquer algorithm based steps basic paradigm running time problem size problem size small constant straightforward solution takes constant time write suppose division problem yields subproblems size original merge sort divide conquer algorithms dn time divide problem subproblems time combine solutions subproblems solution original problem recurrence chapter solve common recurrences form analysis merge sort pseudocode mergesort works correctly number elements recurrencebased analysis simplified assume original problem size power divide step yields subsequences size chapter assu mption affect orde growth solution recurrence reason set recurrence worstcase running time merge sort numbers merge sort elemen takes constant time elements break running time divide divide step computes middle subarray takes constant time dn conquer recursively solve subproblems size contributes running time combine merge procedure nelement subarray takes time add functions dn merge sort analysis adding function function sum linear function adding term conquer step recurrence worstcase running time merge sort chapter master theorem lg lg stands log2 logarithm function grows slowly linear function large inputs merge sort lg running time outperforms insertion running time worst case master theorem tuitively understand solution recurrence lg rewrite recurrence constant represents time required solve problems size time array element divide combine steps figure solve recurrence convenience assume exact power figure expanded equivalent tree representing recurrence term root cost level recursion subtrees root smaller recurrences process carried step expanding cost subnodes level recursion cn2 continue expanding node tree breaking constituent pa rts determined recurrence problem sizes cost tree figure construction recursion tree recurrence tn2 progressively expanded form recursion tree fully expanded tree lg levels height lg level contributes total cost total cost lg lg add costs level tree level total cost level total cost cn2 cn2 level total cost cn4 cn4 cn4 cn4 general level nodes contributing cost cn2i ith level total cost cn2i level nodes contributing cost total cost total number levels recursion tree figure lg fact easily informal inductive argument base case occurs case level lg lg correct number levels assume inductive hypothesis numb levels recursion tree nodes lg lg assuming original input size power input size i1 tree i1 nodes level tree nodes total number levels lg i1 compute total cost presented recurrence simply add costs levels lg levels costing total cost cnlg lg ignoring loworder term constant desired result lg exercises figure model illustrate oper ation merge sort array exercises rewrite merge procedure sentinels stopping array elements copied copying remainder array exercises mathematical inducti exact power solution recurrence exercises insertion sort expressed recursive procedure order sort recursively sort insert sorted array write recurrence running time recursive version insertion sort exercises referring searching problem exercise observe sequence sorted check midpoi sequence eliminate half sequence consideration binary search algorithm repeats procedure halving size remaini portion sequence time write pseudocode iterative recursive binary search argue worstcase running time binary search lg exercises observe loop lines insertionsort procedure linear search scan backward sorted subarray binary search exercise improve overal worstcase running time insertion sort lg exercises lg ntime algorithm set integers integer determines exist elements sum problems insertion sort small arrays merge sort merge sort runs lg worstcase time insertion sort runs worst case time constant factors inse rtion sort faster small sense insertion sort merge sort subproblems small modification merge sort nk sublists length sorted insertion sort merged sta ndard merging mechanism determined nk sublists length sorted insertion sort nk worstcase time sublists merged lg nk worstcase time modified algorithm runs nk lg nk worstcase time largest asymptotic notation function modified algorithm asymptotic running time standard merge sort chosen practice problems correctness bubblesort bubblesort popular sorting gorithm works repeatedly swapping adjacent elements order bubblesorta lengtha lengtha downto exchange denote output bubblesort prove bubblesort correct prove terminates lengtha proved bubblesort sorts parts prove inequality state precisely loop invariant loop lines prove loop invariant holds proof structure loop invariant proof presented chapter termination condition loop nvariant proved state loop invariant loop lines prove inequality proof structure loop invariant proof presented chapter worstcase running time bubblesort compare running time insertion sort problems correctness horners rule code fragment implements horners rule evaluating polynomial coefficients a0 ai asymptotic running time code fragment horners rule write pseudocode implement naive polynomialevaluation algorithm computes term polynomial scratch running time algorithm compare horners rule prove loop invariant loop lines start iteration loop lines interpret summation terms equaling proof follow structure loop invariant proof presented chapter termination conclude arguing code fragment correctly evaluates polynomial characterized coefficients a0 problems inversions array distinct numbers ai pair called inversion list inversions array array elements set inversions relationship running time insertion sort number inversions input array justify answer algorithm determines nu mber inversions permutation elements lg worstcase time hint modify merge sort chapter formally interpret equations notation expression denotes integer greater equal denotes greatest integer equal notations defined chapter easiest verify setting yields subarrays aq sizes examine cases depending odd constant represents time solve problems size time array element divi combine steps problem letting larger times understanding recurrence upper bound running time letting lesser times understanding recurrence lower bound running time bounds order lg lg running time chapter notes knuth published volumes general title art computer programmingvolume ushered modern study computer algorithms focus analysis running time series remains engaging worthwhile reference topics presented knuth word algorithm derived alkhowârizmî ninthcentury persian mathematician aho hopcroft ullman advocated asymptotic analysis algorithms comparing relative performance popularized recurrence relations running times recursive algorithms knuth encyclopedic treatment sorting algorithms comparison sorting algorithms includes stepcounting analyses performed insertion sort knuths disc ussion insertion sort encompasses variations algorithm sh ells sort introduced shell insertion sort periodic subsequences input produce faster sorting algorithm merge sort knuth men tions mechanical collator capable merging decks punched cards sing pass invented von neumann pioneers computer science wrote program merge sort edvac computer early history proving programs correct gries credits naur article field gries attributes loop invariants floyd textbook mitchell describes progre proving programs correct chapter growth functions overview order growth running time algorithm defined chapter simple characterization algorithm efficiency compare relative performance alternative gorithms input size large merge sort lg worstcase running time beats insert ion sort worstcase running time determine exact running time algorithm insertion sort chapter extra precision worth effort computing large inputs multip licative constants lowerorder terms exact running time dominated effects input size input sizes large order growth running time relevant studying asymptotic efficiency algorithms concerned running time gorithm increases size input limit size input increases bound algorithm asymptotically efficient choice small inputs chapter standard methods simplifying asym ptotic analysis algorithms defining types asymptotic notation notation notational conventions book presented finally review behavior functions commonly analysis algorithms asymptotic notation notations asympto tic running time algorithm defined terms functions domains set natural numbersnotations convenient describing worstcase runningtime function defined integer input sizes convenient abuse asymptotic notation variety ways ample notation easily extended domain real numbers alternatively restrict subset natural numbers understa precise meaning notation abused misused defines basic asymptotic notations introduces common abuses notation chapter worstcase running time insertion sort define notation function gn denote gn set functions gn exist positive constants n0 c1gn c2gn n01 function belongs set gn exist positive constants sandwiched c1gn c2gn large gn set write gn member gn write gn express notion abuse equality denote set membership confusing advantages figure intuitive picture functions gn gn values n0 lies c1gn c2gn n0 function equal gn constant factor gn asymptotically tight bound figure graphic examples notations n0 minimum greater work notation bounds function constant factors write gn exist positive constants n0 n0 lies c1gn c2gn inclusive onotation upper bound function constant factor write ogn positive constants n0 n0 lies cgn notation lower bound function cons tant factor write gn positive constants n0 n0 lies cgn definition gn requires member gn asymptotically nonnegative nonnegative large asymptotically positive function pos itive large function gn asymptotica lly nonnegative set gn assume function notation asymptotically nonnegative assumption holds asymptotic notations defined chapter chapter introduced informal notion notation amounted throwing lowerorder terms ignoring leading coefficient highestorder term justify intuition formal definition determine positive constants n0 c1n2 c2n2 n0 dividing yields righthand inequality hold choosing likewise lefthand inequality hold choosing choosing n0 verify choices constants exist thing choice exists note cons tants depend function function belonging require constants formal definition verify n3 suppose purpose contradiction n0 exist n3 c2n2 n0 c26 hold arbitrarily large constant intuitively lowerorder term asymptotically positiv function determining asymptotically tight bounds ecause insignificant large tiny fraction highestorder term dominate lowerorder terms setting smaller coefficient highest order term setting larger perm inequalities definition notation satisfied coefficient highestorder term likewise constant factor equal coefficient quadratic function an2 constants throwing lowerorder terms ignoring constant yields formally thing constants reader verify c1n2 an2 c2n2 n0 general polynomial ai constants problem constant degree0 polynomial express constant function n0 notation minor abuse howe ver clear variable tending infinity notation constant constant function respect variable onotation notation asymptotically bounds function asymptotic upper bound onotation function gn denote ogn pronounced bigoh set functions ogn exist positive constants n0 cgn n0 onotation upper bound function constant factor figure intuition onotation values n0 function gn write ogn function member set ogn note gn implies ogn notation stronger notion onotation written settheoretically gn ogn proof quadratic function an2 quadratic function on2 surprising linear function on2 easily verified n0 readers onotation strange write on2 literature onotation informally asymptotically tight bounds defined notation book write ogn claiming constant multiple gn asymptotic upper bound claim tight upper bound distinguishing asymptotic upper bounds asymptotically tight bounds standard algorithms literature onotation running time algorithm inspecting algorithms structure doubly nested loop structure insertion sort algorithm chapter yields on2 upper bound worstcase running time cost itera tion loop bounded o1 constant indices loop executed pairs values onotation describes upper bound bound worstcase running time algorithm bound running time algorithm input on2 bound worstcase running time insertion sort applies running time input bound worstcase running time insertion sort imply bound running time insertion sort input chapter input sorted insertion sort runs time technically abuse running time insertion sort on2 actual running time varies dependi input size running time on2 function on2 matter input size chosen running time input bounded equivalently worstcase running time on2 notation onotation asymptotic upper bound function notation asymptotic lower bound function gn denote gn pronounced bigomega omega set functions gn exist positive constants n0 cgn n0 intuition notation figure values n0 cgn definitions asymptotic notations easy prove theorem exercise theorem functions gn gn ogn gn application theorem proof an2 constants implies an2 an2 on2 practice theorem asymptotic upper lower bounds asymptotically tight bounds prove asymptotically tight bounds asymptotic upper lower bounds notation describes lower bound bound bestcase running time algorithm implication bound running time algorithm arbitrary inputs bestcase running time insertion sort implies running time insertion sort running time insertion sort falls on2 falls linear function quadratic function bounds asymptotically tight instance running time insertion sort exists input insertion sort runs time input sorted contradictory worstcase running time insertion sort exists input algorithm time running time modifier algorithm gn matter input size chosen running time input constant times gn large asymptotic notation equations inequalities asymptotic notation mathematical formulas introducing onotation wrote on2 write interpret formulas asymptotic notation stands righthand equation inequality on2 defined equal sign set membership on2 general asymptotic notation appears formula interpret standing anonym ous function care formula function set case asymptotic notation manner eliminate inessential clutter equation chapter expressed worstcase running time merge sort recurrence interested asymptotic behavior point lowerorder terms understood included anonymous function denoted term number anonymous functions expres sion understood equal number times asymptotic notation expression single anonym ous function function expression o1 o2 doesnt ha clean interpretation cases asymptotic notation appears lefthand equation interpret equations rule matter anonymous functions chosen left equal sign choose anonymous functions equal sign equation valid meaning function function gn gn righthand equation coarser level lefthand number relationships chained interpret equation separately rule equation functionequation function gn mentioned function hn gn hn note interpretation implies chaining equations intuitively onotation asymptotic upper bound provided onotation asymptotically tight bound on2 asymptotically tight bound on2 onotation denote upper bound asymptotically tight formally define ogn littleoh set ogn positive constant exists constant n0 cgn n0 on2 on2 definitions onotation onotation difference ogn bound cgn holds constant ogn bound cgn holds constants intuitively onotation function insignificant relative gn approaches infinity authors limit definition onotation definition book restricts anonymous functions asymptotically nonnegative notation analogy notation notation onotation onotation notation denote lower bound asymptotically tight define gn gn ofn formally define gn littleomega set gn positive constant exists constant n0 cgn n0 n22 n22 relation gn implies limit exists arbitrarily large relative gn approaches infinity comparison functions relational properties real numbers apply asym ptotic comparisons assume gn asymptotically positive transitivity gn gn hnimply hnfn ogn gn ohnimply ohnfn gn gn hnimply hnfn ogn gn ohn imply ohnfn gn gn hnimply hnreflexivity ofn symmetry gn gn transpose symmetry ogn gn fnfn ogn gn fnbecause properties hold asymptotic ations draw analogy asymptotic comparison functions comparison real numbers ogn bfn gn bfn gn bfn ogn bfn gn bwe asymptotically smaller gn ogn asymptotically larger gn gn property real numbers carry asymptotic notation trichotomy real numbers hold real numbers compar functions asymptotically comparable functions gn case ogn gn holds functions n1sin compared asymptotic notation exponent n1sin oscillates values exercises gn asymptotically nonnegative functions basic definition notation prove max gn gn exercises real constants exercises explain statement running time algorithm on2 meaningless exercises n1 o2n o2n exercises prove theorem exercises prove running time algorithm gn worstcase running time ogn bestcase running time gn exercises prove ogn gn set exercises extend notation case parameters infinity independently rates function gn denote ogn set functions ogn exist positive constants n0 m0 cgn n0 m0 definitions gn gn set notation colon shoul read real problem ordinary notati functions distinguish functions values calculus parameters func tion function written nn2 adopting rigorous notation complicate algebraic manipulations choose tolerate abuse standard notations common functions reviews standard mathemati cal functions notations explores relationships illustrat asymptotic notations monotonicity function monotonically increasing implies fm monotonically decreasing implies fm function strictly increasing implies fm strictly decreasing implies fm floors ceilings real number denote greatest integer equal read floor integer greater equal read ceiling real integer real number integers floor function fx monotonically increasing ceiling function fx modular arithmetic integer positive integer mod remainder residue quotient welldefined notion remainder integer divided convenient provide special notation equality remainders mod mod write mod equivalent modulo mod remainder divided equivalently mod divisor write mod equivalent modulo polynomials nonnegative integer polynomial degree function form constants a0 coefficients polynomial polynomial asymptotically positive asymptotically positive polynomial degree real constant function monotonically increasing real constant function monotonically decreasing function polynomially bounded onk constant exponentials real identities a0 amn amn amn anm amn function monotonically increasing convenient assumerates growth polynomials exponen tials fact real constants conclude nb oan exponential function base strictly greater grows faster polynomial function denote base natural logarithm function real denotes factorial function defined real inequality equality holds approximation approximation good equation asymptotic notation limiting behavior logarithms notations lg log2 binary logarithm loge natural logarithm lgk lg nk exponentiation lg lg lglg composition notational conven tion adopt logarithm functions apply term formula lg lg lgn hold constant function logb strictly increasing real equation logarithm bases equation changing base logarithm constant logarithm constant factor notation lg dont care cons tant factors onotation computer scientists natural base logarithms algorithms data structures involve splitting problem parts simple series expansion ln1 inequalities equality holds function polylogarithmically bounded olg constant relate growth polynomials polylogarithms substituting lg equation yielding limit conclude lgb ona constant positive polynomial function grows faster polylogarithmic function factorials notation read factorial fined integers weak upper bound factorial function terms factorial product stirlings approximation base natural logarithm tig hter upper bound lower bound prove exercise stirlings approximation helpful proving equation equation holdsfunctional iteration notation fin denote function iteratively applied times initial formally function reals nonnegative integers recursively define fin iterated logarithm function notation lg read log star denote iterated logarithm defined lgi defined lg logarithm nonpositive number undefined lg defined lgi1 distinguish lgi logarithm function applied times succession starting argument lg logarithm raised ith power iterated logari thm function defined lg min lgi iterated logarithm slowly growing function lg lg lg lg lg265536 number atoms observable universe estimated rarely encounter input size lg fibonacci numbers fibonacci numbers defined recurrence fibonacci number sum previous yielding sequencefibonacci numbers golden ratio conjugate formulas proved induction exercise ith fibonacci number equal rounded nearest integer fibonacci numbers grow exponentially exercises gn monotonically increasing functi ons functions gn gn gn addition nonnegative gn monotonically increasing exercises prove equation exercises prove equation prove onn exercises function lg polynomially bounded function lg lg polynomially bounded exercises asymptotically larger lglg lglg exercises prove induction ith fibonacci number satisfies equality golden ratio conjugate exercises prove fibonacci number satisfies fi2 problems asymptotic behavior polynomials degreed polynomial constant definitions asymptotic notations prove properties onk nk nk onk nk problems relative asymptotic growths pair expressions table assumeconstants answer form table written box lgk nk nsin nlg clg lgn lg problems ordering ymptotic growth rates rank functions order growth arrangement g1 g2 g30 functions satisfying g1 g2 g2 g3 g29 g30 partition list equivalence classes gn class gn single nonnegative function functions gin ogin gin problems asymptotic notation properties gn asymptotically positive functions prove disprove conjectures ogn implies gn ofn gn min gn ogn implies lg olg gn lg gn large ogn implies gn ofn2 ogn implies gn fn2 problems variations authors define read omega infinity alternative definition exists positive constant cgn infinitely integers functions gn asympto tically nonnegative ogn true place potential advantages disadvantages characterize running times programs authors define manner alternative definition ogn ogn direction theorem substitute authors define õ read softoh logarithmic factors õ gn exist positive constants n0 cgn lgkn n0 define manner prove analog theorem problems iterated functions iteration operator lg function applied monotonically increasing function reals constant define iterated function welldefined cases quantity number iterated applications function required reduce argument functions constants tight bound lg n13 nlg chapter notes knuth traces origin onotation numbertheory text bachmann onotation invented landau discussion distribution prime numbers notations advocated knuth correct popular technically sloppy practice literature onotation upper lower bounds people continue onotation notation technically precise discussion history development asymptotic notations knuth brassard bratley authors define asymptotic notations definitions agree common situations alternative definitions encompass functions asympt otically nonnegative long absolute values appropriately bounded equation robbins properties elementary mathematical functions good thematical reference abramowitz stegun zwillinger calculus book apostol thomas finney knuth graham knuth patashnik wealth material discrete mathematics computer science technicalities practice neglect technical details state solve recurrences good glossed assumption integer arguments functions running time algorithm defined integer algorithms size input integer recurrence describing worstcase running time mergesort boundary conditions represent anot class details typically ignore running time algorithm constantsized nput constant recurrences running times algorithms generally small convenience genera lly omit statements boundary conditions recurrences assume constant small state recurrence explicitly values small reason changing solution recurrence solution typically doesnt change constant factor order growth unchanged state solve recurrences omit floors ceilings boundary conditions forge ahead details determine matter dont wh experience helps theorems stating tails dont affect asympt otic bounds recurrences encountered analysis algorithms theorem chapter address details fine points recurrence solution methods substitution method substitution method solving recurrences entails steps guess form solution mathematical induction cons tants solution works substitution guessed answer function inductive hypothesis applied smaller values method powerful applied cases easy guess form answer substitution method tablish upper lower bounds recurrence determine upper bound recurrence recurrences guess solution lg method prove lg choice constant start assuming bound holds lgn2 substituting recurrence yields n2lg lgn2 lg lg lg lg step holds long mathematical induction requi res solution holds boundary conditions typically showing boundary conditions suitable base cases inductive proof recurrence choose constant large bound lg works boundary conditions requirement lead problems assume sake argument sole boundary cond ition recurrence bound lg yields lg odds base case inductive proof fails hold difficulty proving inductive hypothesis specific boundary condition easily overcome recurrence advantage asymptotic notation requiring prove lg n0 n0 constant choosing idea remove difficult boundary condition consideration inductive proof observe recurrence depend directly replacebase cases inductive proof letting n0 note distinction base case recurrence base cases inductive proof derive recurrence inductive proof lg constant completed choosing large lg lg turns choice suffices base cases hold recurrences examine straightforward extend boundary conditions inductive assumption work small making good guess general guess correct solutions recurrences guessing solution takes experience occasionally creativity fortunately heuristics good guesser recursion trees generate good guesses recurrence guessing solution reasonable recurrence difficult argument righthand intuitively additional term affect solution recurrence large difference large cut evenly half guess lg verify correct substitution method exercise good guess prove loose upper lower bounds recurrence reduce nge uncertainty start lower bound recurrence term recurrence prove initial upper bound on2 gradually lower upper bound raise lower bound converg correct asymptotically tight solution lg subtleties times correctly guess asymptotic bound solution recurrence math doesnt work induction problem inductive assumption strong prove detailed bound hit snag revising guess subtracting lowerorder term permits math recurrence guess solution choice constant substituting guess recurrence imply choice tempting larger guess on2 work fact guess solution correct order stronger inductive hypothesis intuitively guess constant lowerorder term mathematical induction doesnt work prove exact form inductive hypothesis overcome difficulty subtracting lowerorder term previous guess guess constant long constant chosen large handle boundary conditions people idea subtracting lowerorder term counterintuitive math doesnt work shouldnt increas ing guess key understanding step remember math ematical induction prove stronger assuming mething stronger smaller values avoiding pitfalls easy err asymptotic notation recurrence falsely prove guessing arguing wrong constant error havent proved exact form inductive hypothesis changing variables algebraic manipulation unknown recurrence recurrence difficult simplify recurre nce change variables convenience worry rounding values integers renaming lg yields rename t2m produce recurrence sm2 recurrence recurrence solution lg changing lg olg lg lg exercises solution olg exercises solution lg solution recurrence lg conclude solution lg exercises making inductive hypo thesis overcome difficulty boundary condition recurrence adjusting boundary conditions inductive proof exercises lg solution exact recurrence merge sort exercises solution lg exercises solve recurrence making change variables solution asymptotically tight worry values integral recursiontree method substitution method provide succinct proof solution recurrence correct difficult good guess drawing recursion tree analysis merge sort recurrence straightforward devise good guess recursion tree node represents cost single subproblem set recursive function invocations sum costs level set perlevel costs sum perlevel costs determine total cost levels recursion recursion trees recurrence describes running time divide conquer algorithm recursion tree generate good guess verified substitution method recursion tree generate good guess tolerate small oppiness veri fying guess careful drawing recursion tree summing costs recursion tree direct proof solution recurren recursion trees generate good guesses recursion trees directly prove theorem forms basis master method recursion provide good guess recurrence n4 start focusing findi upper bound solution floors ceilings insubstantial solving recurrences sloppiness tolerate create recursion tree recurrence tn4 cn2 written imp lied constant coefficient figure derivation recursion tree n4 cn2 convenience assume exact power tolerable sloppiness figure expanded equivalent tree representing recurrence cn2 term root represents cost level recursion subtrees root represent costs incurred subproblems size n4 process carried step expanding node cost n4 cost children root cn42 continue expanding node tree breaking constituent parts determined recurrence figure construction recursion tree recurrence tn4 cn2 progressively expanded form recursion tree fully expanded tree height log4 log4 levels subproblem sizes decrease furt root eventually reach boundary condition root reach subproblem size node depth n4i subproblem size hits n4i equivalently log4 tree log levelslog4 determine cost level tree level times nodes level number nodes depth subproblem sizes reduce factor level root node depthlog4 cost cn4i2 multiplying total cost nodes depthlog4 cn4i2 cn2 level depth log4 nodes contributing cost total cost add costs levels determine cost entire tree formula messy realize advantage small amounts sloppiness infinite decreasing geometric series upper bound backing step applying equation a6 derived guess on2 original recurrence n4 coefficients cn2 form decreasing geometric series equation a6 sum coefficients bounded constant roots contribution total cost cn2 root contributes constant fraction total cost total cost tree dominated cost root fact on2 upper bound recurrence verify moment tight bound rst recursive contributes cost lower bound recurrence substitution method verify guess correct on2 upper bound recurrence n4n2 dn2 constant constant tn4 cn2 dn42 cn2 dn42 cn2 dn2 cn2 dn2 step holds long intricate figure recursion tree tn3 t2n3 figure recursion tree recurrence n3 n3 omit floor ceiling functions simplicity represent constant factor term add values acr oss levels recursion tree level longest path root leaf kn log32 height tree log32 intuitively expect solution recurr ence number levels times cost level ocn log32 lg total cost evenly distributed levels recursion tree complic ation cost leaves recursion tree complete binary tree height log32 leaves cost leaf constant total cost leaves lg recursion tree complete binary tree fewer leaves root internal node absent levels contribute cost levels cont ribute work accurate accounting cost remember guess substitution method tole rate sloppiness attempt guess lg upper bound correct substitution method verify lg upper bound solution recurre nce dn lg suitable positive constant tn3 t2n3 dn3lg n3 d2n3lg2n3 dn3lg dn3lg d2n3 lg d2n3lg32 dn lg dn3 lg n3 lg32 dn lg dn3 lg n3 lg n3lg dn lg dnlg dn lg long clg perform accurate accounting costs recursion tree exercises recursion tree determine good asymptotic upper bound recurrence tn2 substitution method verify answer exercises argue solution recurrence n3 n3 constant lg appealing recursion tree exercises draw recursion tree n2cn constant provide tight asymptotic bound solution verify bound substitution method exercises recursion tree asymptot ically tight soluti recurrence ta constants exercises recursion tree asymptot ically tight soluti recurrence constant rangeconstant master method master method cookbook meth solving recurrences formconstants asymptotically positive function master method requires memorization thr cases solution recurrences determined easily pencil paper recurrence describes running time algor ithm divides problem size subproblems size nb positive constants subproblems solved recu rsively time nb cost dividing problem combining subproblems function notation dncn recurrence arising mergesort procedure matter technical corre ctness recurrence isnt defined nb integer replacing terms nb nb nb doesnt affect asymptotic behavior recurrence prove convenient ther efore omit floor ceiling functions writing divide conquer recurrences form master theorem master method depends theorem theorem master theorem constants function defined nonnegative integers recurrence atnb interpret nb nb nb bounded asymptotically constantconstant nb constant large applying master theorem examples spend moment understand ree cases comparing function function intuitively solution recurr ence determined larger functions case function larger solution case function larger solution case functions size multiply logarithmic factor solution intuition technicalities understood case smaller polynomially smaller asymptotically smaller factor constant case larger polynomially larg addition satisfy regularity condition nb cfn condition satisfied polynomially bounded functions encounter realize cases cover possibilities gap cases smaller polynomially smaller gap tween cases larger polynomially larger function falls gaps regularity condition case fails hold master thod solve recurrence master method master method simply determin case master theorem applies write answer tn3 recurrenceapply case master theorem conclude solution n3 case applies solution recurrence lg recurrence tn4 lg lg case applies regularity condition holds large nb n4lg n4 lg case solution recurrence nlg master method apply recurrence tn2 lg proper form lg case apply lg asymptotically larger problem polynomially larger ratio asymptotically positive constant recurrence falls gap case case exercise solution exercises master method tight asympt otic bounds recurrences tn2 tn2 tn2 n3 exercises recurrence n2n2 describes running time algorithm competing algorithm running time atn4 largest integer asymptotically faster exercises master method solution binarysearch recurrence lg exercise description binary search exercises master method applied recurrence tn2 lg asymptotic uppe bound recurrence exercises regularity condition nb cfn constant case master theorem constants function satisfies conditions case master theorem regularity condition proof master theorem proof master theorem theorem proof understood order apply theorem proof parts analyzes master recurrence simplifying assumption defined exact powers intuition needed understand master theorem true analysis extended positive integers mathematical technique applied problem handling floors ceilings abuse asymptotic notation behavior functions defined exact powers recall definitions asymptotic notations require bounds proved large numbers thos powers asymptotic notations apply set nonnegative integers abuse minor guard wh asymptotic notation limited domain draw impr oper conclusions proving exact power guarantee function defined case upper bound proved on2 sort drastic consequence asymptotic notation limited domain making absolutely clear context proof exact powers proof ster theorem analyzes recurrence nb master method assumption exact power integer analysis broken lemmas reduces problem solving master recurrence problem evaluating expres sion summation determines bounds summation lemma puts prove version master theorem case exact power lemmaconstants nonnegative function defined exact powers define exact powers recurrence positive integer proof recursion tree figure root tree cost children cost nb convenient integer visualizing recursion tree thematics require children children cost nb2 nodes distance root general nodes distance root cost nbj cost leaf leaf depth log leaves tree figure recursion tree generated nb tree complete aary tree leaves height logb cost level sum equation equation summing costs level tree figure cost level internal nodes fnbj total internal node levels underlying divide conquer algorithm sum represents costs dividing problems subproblems recombining subproblems cost leaves cost subproblems size terms recursion tree cases master theorem correspond cases total cost tree domi nated costs leaves evenly distributed levels tree dominated cost root summation equation describes cost dividing combining steps underlying divide conquer algorithm lemma asymptotic bounds summations growth lemmaconstants nonnegative function defined exact powers function gn defined exact powers bounded asymptotically exact powers constantnb cfn constant gn proof case implies substituting equation yields bound summation onotation factoring terms simplifying leaves increasing geometric series constants rewrite expression substituting expression summation equation yields case proved assumption case substituting equation yields bound summation case time geometric series discover term summation substituting expression summation equation yields gn case proved case proved appears definition gn terms gn nonnegative conclude gn exact powers assumption afnb cfn constant fnb cafn iterating times fnbj caj equivalently fnbj substituting equation simplifying yields geometri series series case decreasing terms constant conclude gn exact powers case proved completes proof lemma prove version master theorem case exact power lemmaconstants nonnegative function defined exact powers define exact powers recurrence positive integer bounded asymptotically exact powers constantconstant nb cfn constant large proof bounds lemma evaluate summation lemma case case case floors ceilings complete proof master theore extend analysis situation floors ceilings master recu rrence recurrence defined integers exact powers obtaining lower bound upper bound routine bound nb nb pushed case yield desired result bound nb nb pushed case lower bounding recurrence requires technique upper bounding recurrence bound modify recursion tree figure produce recursion tree figure recursion tree sequence recursive invocations arguments figure recursion tree generated atnb recursive argument equation nb nbb nbbb denote jth element sequence goal determine depth nk constant inequality general letting logb depth logb problem size constant figure equation arbitrary integer restricted exact power evaluate summation manner analogous proof lemma case afnb cfn bb constant ajfnj cjfn sum equation evaluated lemma case proof case lemma observe logb implies bjn bound implies exists constant large constant case proved proof case identical key prove bound proof case algebra intricate proved upper bounds master theorem integers proof lower bounds exercises simple exact expression equation case positive integer arbitrary real number exercises master recurrence solution simplicity confine alysis exact powers exercises case master theorem ove rstated sense regularity condition afnb cfn constant implies exists constant problems recurrence examples asymptotic upper lower bounds recurrences assume constant bounds tight justify answers tn2 n3 t9n10 tn4 tn3 tn2 problems finding missing integer array integers easy determine missing integer time auxiliary array b0 record numbers problem access entire integer single operation elements represented binary operation access fetch jth bit ai takes constant time operation determine missing integer time problems parameterpassing costs book assume parame ter passing procedure calls takes constant time nelement array passed assumption valid systems pointer array passe array problem examines implications pa rameterpassing strategies array passed pointer time array passed copying time size array array passed copying subrange accessed called procedure time subarray passed recursive binary search algor ithm finding number sorted array exercise recurrences wors tcase running times binary search arrays passed methods good upper bounds solutions recurrences size original problem size subproblem redo mergesort algorithm problems recurrence examples asymptotic upper lower bounds recurrences assume constant small bounds tight justify answers tn2 lg tn5 lg tn3 tn2 lg tn2 tn4 tn8 lg lg problems fibonacci numbers problem develops properties bonacci numbers defined recurrence technique generating functions lve fibonacci recurrence define generating function formal power series ith fibonacci number z2fz prove rounded nearest integer hint observe prove fi2 problems vlsi chip testing professor diogenes supposedly identical vlsi chips principle capable testing professo test jig accommodates chip time jig loaded chip tests reports good bad good chip reports accurately chip good bad answer bad chip trusted tcomes test chip chip conclusion good good good bad good bad bad bad good bad bad bad bad chips bad professo determine chips good strategy based kind pairwise test assume bad chips conspi fool professor problem finding single good chip chips assuming chips good pairwise tests sufficient reduce problem half size good chips identified pairwise tests assuming chips good solve recurrence describes number tests problems monge arrays array real numbers monge array ai ak ai ak pick rows columns monge array elements inters ections rows columns sum upperleft lowerright elements equal sum lowe rleft upperright elements array mongeprove array monge ai ai ai ai note induction separately rows columns array monge change element order monge hint column containi leftmost minimum element row prove f1 fm monge array description divide conquer algorithm computes leftmost minimum element row monge array construct submatrix consisting evennumbered rows recursively determine leftmost minimum row compute leftmost minimum oddnumbered rows explain compute leftmost minimum oddnumbered rows leftmost minimum evennumbered rows time write recurrence describing running time algorithm solution log vlsi stands large scale integrati integratedcircuit chip technology fabricate microprocessors today chapter notes recurrences studied early fibonacci fibonacci numbers named moivre introduced method generating functions problem solving recurrences master method adapted bentley haken saxe extended method justified exercise knuth liu solve linear recurrences method generating functions purdom brown graham knuth patashnik extended discussions recurrence solving researchers including akra bazzi roura verma methods solving general divi deandconquer recurrences solved master method result akra bazzi works recurrences form coefficients ai positive sum bounded positive nondecreasing constants exist constants n0 fnc n0 method work recurrence tn3 t2n3 master method apply solve recurrence exists unique positive solution recurrence large constant akrabazzi method difficult serves solving recurrences mode division problem unequally sized subproblems master method simpler applies subproblem sizes equal chapter probabilistic analysis randomized algorithms chapter introduces probabilistic analysis randomized algorithms unfamiliar basi probability theory read appendix reviews material probabilistic analysis random ized algorithms revisited times book hiring problem suppose hire office assistant previous attempts hiring unsuccessful decide employment agency employment agency send candidate day inte rview person decide hire person pay employment agency small fee interview applicant hire applicant costly current office assistant pay large hiri fee employment agency committed times possi ble person job decide interviewing applicant applicant qualified current office assistant current office assistant hire applicant pay price strategy estimate price procedure hireassistant expresses strategy hiring pseudocode assumes candidates office assistant job numbered procedure assumes interviewing candidate determine candidate candidate initialize procedure creates dummy candidate numbered qualif ied candidates hireassistantn candidate leastqualified dummy candidateinterview candidate candidate candidate hire candidate cost model problem ffers model chapter concerned running time hireassist ant cost incurred interviewing hiring surface analyzin cost algorithm analyzing running time merge sort anal ytical techniques identical analyzing cost running time case counting number times certa basic operations executed interviewing low cost hiring expensive costing number people hired total algorithm onci mch matter people hire interview candidates incur cost nci interviewing concentrate analyzing mch hiring cost quantity varies ith algorithm scenario serves model common computational paradigm case maximum mini mum sequence examining element sequence maintaining curr ent winner hiring problem models update notion element winning worstcase analysis worst case hire candidate interview situation occurs candidates increasing orde quality case hire times total hiring cost onch reasonable expect candidates increasing order quality fact idea order arrive control order natural expect happen typical average case probabilistic analysis probabilistic analysis probability alysis problems commonly probabilistic analysis analyze running time algorithm analyze quantities hiring cost procedure hireassistant order perform probabilistic analysis knowledge assumptions distribution inputs analyze algorithm computing expected running time expectation distribution inputs averaging running time inputs careful deciding stribution inputs problems reasonable assume inputs probabilistic analysis technique designing efficient algorithm gaining insight problem prob lems descri reasonable input distribution cases probabilistic analysis hiring problem assume applicants random order problem assume compare candidates decide qualified total order candidates appendix definition total order rank candidate unique number ranki denote rank applicant adopt convention higher rank corresponds qualified applicant ordered list rank1 rank rank permutation list applicants random order equivalent list ranks equally permutations numbers alternatively ranks form uniform random permutation permutations appears equal probability probabilistic analysis hiring problem randomized algorithms order probabilistic analysis someth ing distribution inputs cases input distribution distribution model knowledge computationally probabi lity randomness tool algorithm design analysis making behavi algorithm random hiring problem ndidates presented random order knowing order develop randomized algorithm hiring probl greater control order interview candidates change model employment agency candidates send list candidates advance day choos randomly candidate interview candidates names change relying guess candidates random order gained control process enforced random order generally algorithm randomized behavior determined input values produced randomnumber generator assume disposal randomnumber generator random randoma returns integer inclusive integer equally random0 produces probab ility produces probability random3 returns probability integer returned random independent integers returned previous calls imagine random rolling sided die output practice programming environments offer pseudorandomnumber generator deterministic algorithm returning numbers statistically randoma exercises assumption determine candidate procedure hireassistant implies total order ranks candidates exercises implementation procedure random calls random0 expected running time procedur function exercises suppose output probabi lity probability disposal procedure biasedrandom outputs outputs probability probabilityalgorithm biasedrandom subroutine returns unbiased answer returning probability probability expected running time algorithm function indicator random variables order analyze algorithms includi hiring problem indicator random variables indicator random variables provide convenient method converting probabilities expectations suppose sample space event indicator random variable event defined simple determine xpected number heads flipping fair coin sample space define random variable takes values probability define indicator random variable xh coin coming heads express event variable counts number heads flip coin heads write expected number heads flip coin simply expected indicator variable xh exh eiy pry expected number heads flip fair coin lemma expected indica tor random variable event equal probability occurs lemma sample space event sample space xa exa pra proof definition indicator random variable equation definition expected exa eia denotes complement indicator random variables cumbersome application counting expected number heads flip single coin analyzing situations perform repeated random trials indicator random variables simple arrive result equation c36 equation compute number heads coin flips separately obability obtaining heads heads heads simpler method proposed equation c37 implicitly indicator random variables making argument explicit indicator random variable asso ciated event ith flip heads letting yi random variable noting outcome ith flip iyi random variable denoting total number heads coin flips compute expected number eads expectation sides equation left equation expectation sum random variables lemma easily compute expectation random variables equation c20linearity expectationit easy compute expectation sum equals sum expectations random variables linearity expectation indicator random riables powerful analytical technique applies dependence random variable easily compute expected number heads compared method equation c36 indicator random variables greatly simplify calculation indicato random variables thr oughout book analysis hiring problem indicator random variables returning hiring problem compute expected number times hire office assistant order probabilistic analysis assume candidates arrive random order discussed previous remove assumption random variable equals number times hire office assist ant apply definition expected equation c19 calculation cumbersome sh indicator random variables greatly simplify calculation indicator random variab computing defining variable number times hire office assistant define variables candidate hired indicator random variable associat event ith candidate hired lemma exi candidate hired comput probability lines hireassistant executed candidate hired candidate candidates assumed ndidates arrive random order candidates appeared random order candidates equally bestqualified candidate probability qualified candidates probability hired lemma conclude compute interview people hire average summarize result lemma lemma assuming candidates presented random order algorithm hireassistant total hiring cost och proof bound definition hiring cost equation expected interview cost improvement worstcase hiring cost onch exercises hireassistant assuming candidates presented random order probability hire time probability hire times exercises hireassistant assuming candidates presented random order probability ill hire exercises indicator random variab compute expected sum dice exercises indicator random variable solve problem hatcheck problem customers hat hatch eck person restaurant hatcheck person hats customers random order expected number customers hat exercises array distinct numbers ai pair called inversion problem inversions suppose element chosen randomly independently uniformly range indicator random variable compute expected number inversions randomized algorithms previous knowing distribution inputs analyze averagecase behavior gorithm times knowledge averagecase analysis mentioned randomized algorithm problem hiring problem helpful assume permutations input equally probabilistic analysis guide development randomized algorithm assuming distribution inputs impose distribution particul running algorithm randomly permute candidates order enforce property permutation equally modification change expectation hiring office assistant roughly times input expect case inputs drawn distribution explore distinction probabilistic analysis randomized algorithms claimed assuming candidates presented random order expected number times hire office assistant note algorithm deterministic input number times office assistant hired number times hire office assistant differs inputs depends ranks candidates number depends ranks candidates represent input listing order ranks candidates rank1 rank2 rankn rank list office assistant hired times successive candidate previous lines executed iteration algorithm list ranks office assistant hired iteration list ranks office assistant hired times interviewing candidates ranksrecalling cost algorithm dependent times hire office assistant expensive inputs inexpensive inputs moderately expensive inputs hand randomized algorithm firs permutes candidates determines candidate randomization algorithm input distribution input times maximum updated quantity differs algorithm time algorithm produce permutation perform updates time algorithm produce permutation perform update time perform number updates time algorithm execution depends random choices differ previous execution algorithm algorithm randomized algorithms input elicits worstcase behavior worst enemy produce bad input ray random permutation input order irrelevant randomized algorithm performs badly randomnumber generator produces unlucky permutation hiring problem change needed code randomly permute array randomizedhireassistantn randomly permute list candidates candidate leastqualified dummy candidateinterview candidate candidate candidate hire candidate simple change created randomized algor ithm performance matches assuming ndidates presented random order lemma expected hiring cost procedure randomizedhireassistant och proof permuting input array achi eved situation identical probabilistic analysis hireassistant comparison lemmas captures difference probabilistic analysis randomized algorithms lemma assumption input lemma assumption alth ough randomizing input takes additional time remainder secti discuss issu involved randomly permuting inputs randomly permuting arrays randomized algorithms randomize input permuting input array ways randomization discuss methods assume array loss generality elements goal produce random permutation array common method assign element ai array random priority sort elements priorities initial array choose random priorities produce array priority smallest fourth finally procedure permutebysorting permutebysortinga lengtharandom1 n3 sort sort keys return chooses random number n3 range n3 priorities unique exercise asks prove probability entries unique exercise asks implement algorithm priorities identi cal assume priorities unique timeconsuming step procedure sorting chapter comparison sort sorting takes lg time achieve lower bound merge sort takes lg time comparison sorts lg time sorting jth smallest priority ai position output manner obtai permutation remains prove procedure produces uniform random permutation permutation numbers equally produced lemma procedure permutebysorting produces uniform random permutation input assuming priorities distinct proof start particul permutation element ai receives ith smallest priority permutation occurs probability event element ai receives ith smallest priority compute probability event occurs xn1 exercise c26 probability equal prx4 prxi xi1 xi2 prxn xn1 probability priority chosen randomly set smallest observe element smallest priority remaining elements equal chance smalle priority general xi1 xi2 elements ai smallest priorities order remaining elements equal chance ith smallest priority probability obtaining identity permutation extend proof work rmutation priorities fixed permutation set denote rank priority assigned element ai element jth smallest priority rank define event element ai receives ith smallest priority proof applies calculate probability obtaining permutation calcula tion identical probability obtaining permutation prove permutation uniform random permutation suffices element ai probability winds position exercise weaker condition fact insufficient method generating random permutation permute array place procedure randomizeinplace time iteration element ai chosen randomly elements ai subsequent iteration ai altered randomizeinplacea lengtha swap ai arandomi loop invariant procedure randomizeinplace produces uniform random permutation set elements kpermutation sequence elements appendix kpermutations lemma procedure randomizeinplace putes uniform random permutation proof loop invariant prior ith iteration loop lines permutation subarray permutation probability invariant true prior loop iteration iteration loop maintains invariant invariant property correctness loop terminates initialization situation loop iteration loop invariant permutation subarray permutation probability subarray subarray permutation elements permutation probability loop invariant holds prior iteration maintenance assume iteration permutation appears subarray probability ith iteration ipermutation appears subarray probability incrementing iteration maintain loop invariant examine ith iteration ipermutation denote elements permutation consists permutation xi1 algorithm places ai e1 denote event iterations created permutation xi1 loop invariant e1 event ith iteration puts position ai ipermutation formed precisely e1 occur compute e1 equation c14 e1 pre2 e1pre1 probability e1 equals algorithm chooses randomly values positions ai termination termination subarray npermutation probability randomizeinplace produces uniform random permutation randomized algorithm simplest efficient solve problem randomized algorithms occasionally book exercises professor marceau objects loop invariant proof lemma questions true prior iteration reasoning easily declare subarray rmutations probability subarray permutation shoul invalidating loop invariant prior iteration rewrite procedure randomizeinplace loop invariant applies nonempty subarray prio iteration modify proof lemma procedure exercises professor kelp decides write procedure produce random permutation identity permutation proposes procedure permutewithoutidentitya lengthaswap ai arandomi code professor kelp intends exercises suppose swapping element ai random element subarray ai swapped random element array permutewithalla lengthaswap ai arandom1 code produce uniform random permutation exercises professor armstrong suggests procedure generating uniform random permutation permutebycyclica lengtha offset random1dest offset dest dest dest bdest ai return element ai probability winding position professor armstrong mistak showing permutation uniformly random exercises prove array procedure permutebysorting probability elements unique exercises explain implement algorithm rmutebysorting handle case priorities identical algorithm produce uniform random permutation priorities identical probabilistic analysis indicator random variables advanced illustrates probabilistic analysis examples determines probability room people pair shares birthday examines random tossing balls bins investigates streaks consecutive heads coin flipping final exam ple analyzes variant hiring problem ecisions interviewing candidates birthday paradox birthday paradox people room chance bor day year answer surprisingly paradox fact fewer number days year half number days year answer question people room integers number people room ignore issue leap years assume years days day year person birthday falls assume birthda uniformly distributed days year probability people matching birthdays depends random selection birthdays independent assume birthdays independent probability birthday birthday fall day rprbj probability fall day intuitively chosen probability chosen day probability birthday probability birthday falls day notice coincidence depends assumption birthdays independent analyze probability people matching birthdays complementary event probability birthdays match minus probability rthdays event people distinct birthdays ai event person birthday person write ak bk1 equation c16 recurrence prb1 pra1 initial condition probability distinct birthdays probability bk1 distinct birthdays times probabilitybk1 distinct bk1 distinct conditional probabilityak bk1 days iteratively apply recurrence inequality kk ln12 probability birthdays distinct kk solving quadratic equationpeople room probability people birthday mars year martian days long takes martians analysis indicator random variables indicator random variables prov ide simpler approximate analysis birthday paradox pair people room define indicator random variable xij equation probability people matching birthdays lemma xij prperson person birthday letting random variable counts number pair individuals birthday expectations sides applying linearity expectation kk expected number pa irs people birthday individuals room expect birthday expected number pairs birthday people expect matching pair birthdays mars year martian days long martians analysis probabilities determined number people required probability exceed matc hing pair birthdays exists analysis indicator random variables determined number expected number matching birthdays exact numbers people differ situations asymptotically balls bins process randomly tossing identical balls bins numbered tosses independent toss ball equally bin probability tossed ball lands bin balltossing process sequence bernoulli trials appendix probability success success ball falls bin model analyzing hashing chapter answer variety interesting questions balltossing process problem asks additional questions balls bins balls fall bin number balls fall bin binomial distribution balls tossed equation c36 tells expected number balls fall bin nb balls toss average bin ball number tosses bin receives ball geometri distribution probability equation c31 expected number tosses success balls toss bin ball toss ball falls bin hit expected number tosses required hits hits partition tosses stages ith stage consists tosses hit ith hit stage consists toss guaranteed hit bins toss ith stage bins balls bins toss ith stage probability obtaining hit denote number tosses ith stage number tosses required hits random variable geometric distribu tion probability success equation c31 linearity expectation bound a7 harmonic series takes tosses expect bin ball problem coupon collectors problem person ying collect coupons acquire randomly coupons order succeed streaks suppose flip fair coin times longest stre ak consecutive heads expect answer lg analysis prove expected length longest streak heads olg probability coin flip head aik event streak heads length ith coin flip precisely event consecutive coin flips yield headscoin flips mutually independent event aik probability flips heads probability str eak heads length lg position small lg positions streak probability streak heads length lg booles inequality c18 probability union events sum probabilities dividual events note booles inequality holds events independent inequality bound length longest streakevent longest reak heads length length longest streak definition expected evaluate sum upper bounds computed inequality method yield weak bounds intuition gained analysis good bound informally observe individual term summation equation factors large lg small lgn fairly small formally note events disjoint probability streak heads length lg inequality noting chances streak heads exceeds lg flips diminish probability streak lg heads starts position air lg lg probability nnr nr1 longest streak lg equivalently probability nr1 longest streak length lg coin flips probability streak lg heads chances streak longer lg heads prove complementary lower bound expected length longest streak heads coin flips lg prove bound streaks length partitioning flips groups flips choose lg groups heads longest streak length lg longest streak expected length lg partition coin flips lg groups lg consecutive flips bound probability group heads equation probability group starting position heads ai lg lgn probability streak heads length lg position lg groups formed mutually exclusive independent coin flips probability groups fails streak length lg argument inequality fact verify large probability longest streak exceeds lg calculate lower bound expected length longest streak equation proceeding manner analysis upper bound birthday paradox simpler approximate analysis indicator random variables xik iaik indicator random variable streak head length ith coin flip count total number streaks define expectations linearity expectation plugging values calculate expected number streaks length number large greater streaks length expected occur probability occurs high number small streaks length expected occur probability occurs low lg positive constant large expected number streaks length lg small conclude ccur hand n121 n12 expect larg number streaks length lg streak length occur rough estimates conclude length longest streak lg online hiring problem final variant hiring problem suppose interview candidates order hire applicants settle candidate close exchange hiring obey company requirement interview ither offer position applicant receive job tradeoff minimizing interviewing maxi mizing quality candidate hired model problem meeting applicant score scorei denote score ith applicant assume applicants receive score applicants highest score remaining applicants higher score decide adopt strategy selecting positive integer interviewing rejecting applicants hiring applicant higher score preceding applicants turns bestqualified applicant interviewed hire nth applicant strategy formalized procedure onlinemaximum appears procedure onlinemaximum returns candidate hire onlinemaximumk bestscore scorei bestscore bestscore scoreiscorei bestscore return return determine probability hire qualified applicant choose implement strategy moment assume fixed mj max scorei denote maximum score applicants event succeed choosing bestqualified applicant event succeed bestqualified applicant ith interviewed disjoint noting succeed bestqualified applicant compute order succeed bestqualified applicant ith things happen bestqualified applicant position event denote algorithm sele applicants positions score bestscore scores unique ignore possibility scorej bestscore case values scorek scorei mk greater mk return greater denote event applicants position chosen fortunately events independent event depends relative ordering values positions depends position greater values ordering positions affect greater affect ordering positions apply equation c15 probability maximum equally positions event occur maximum positions positions equally positions ki kni equation approximate integrals bound summation inequalities a12 evaluating definite integrals bounds provide tight bound maximize probability success focus choosing maximizes lower bound lowerbound expression easier maximize upperbound expression differentiating expression knln respect setting derivative equal lower bound probability maximized lnne equivalently implement strategy succeed hiring bestqua lified applicant probability exercises people room probability birthday people probability people birthday july greater exercises suppose balls tossed bins toss independent ball equally bin expected number ball tosses fore bins balls exercises analysis birthday paradox birthdays mutually independent pairwise independence sufficient justify answer exercises people invi ted party order people birthday exercises probability kstring set size kpermutation question relate birthday paradox exercises suppose balls tossed bins toss ndependent ball equally bin expected number bins expected number bins ball exercises sharpen lower bound streak length showing flips fair coin probability streak longer lg lg lg consecutive heads occurs problems probabilistic counting bbit counter ordinarily count morriss probabilistic counting count larger expense loss precision counter represent count form increasing sequence nonnegative values assume initial counter representing count n0 increment operation works counter probabilistic manner overflow error reported counter increased probability ni1 remains unchanged probability ni1 select counter ordinary interesting situations select i1 ith fibonacci numbersee problem assume large probability overflow error negligible expected represented counter increment operations performed analysis variance count represented counter depends sequence simple case estimate variance represented register increment operations performed problems searching unsorted array problem examines algor ithms searching unsorted array consisting elements randomized strategy pick random ai terminate continue search picking random continue picking random indices checked element note pick set indices time examine element write pseudocode procedure rand omsearch implement strategy algorithm terminates indices picked suppose ai expected number indices picked randomsearch terminates generalizing solution suppose indices ai expected number indices picked randomsearch terminates yo answer function suppose indices ai expected number indices picked elements checked randomsearch terminates deterministic linear earch algorithm refer deterministicsearch specifi cally algorithm searches order ai array reached assume permutati ons input array equally suppose ai expected running time deterministicsearch wh worstcase running time deterministicsearch generalizing solution suppose indices ai expected running time deterministicsearch worstcase running time determin isticsearch answer function suppose indices ai expected running time deterministicsearch worstcase running time deterministicsearch finally randomized algorith scramblesearch works randomly permuting input array unning deterministic linear search permuted array letting number indices ai worstcase expected running times scramble search cases generalize solution handle case searching algorithms explain answer chapter notes bollobás hofri spencer wealth advanced probabilistic techniques advantages randomized algorithms discussed surveyed karp rabin textbook motwani raghavan extensive treatment randomized algorithms variants hiring problem studied problems commonly referred secretary problems work area paper ajtai meggido waarts sorting order statistics chapter list chapter heapsort chapter quicksort chapter sorting linear time chapter medians order statistics introduction presents algorithms solve sorting problem input sequence numbers output permutation reordering input sequence input sequence nelement array represented fashion linked list structure data practice numbers sorted rarely isolated values collection data called record record key sorted remainder record consists satellite data carried key practice sorting algorithm permutes permute satellite data record includes large satellite data permute array pointers records records order minimize data movement sense implementation details distinguish algorithm fullblown program sort indi vidual numbers large record numbers irrelevant method sorting procedure determin sorted order focusing problem sorting typically assume input consists numbers translation algorithm sorting number program sorting records conceptually straightforward engineering situation subtleties actual programming task challenge sorting computer scientists sorting fundamental problem study algorithms reasons sort nherent application order prepare customer statements banks sort checks check number algorithms sorting key subrou tine program renders graphical objects layered sort objects relation draw objects numerous algorithms text sorting subroutine wide variety rting algorithms rich set techniques fact techniques thr oughout algorithm design represented body sorting algorithms een developed years sorting problem historical sorting problem ove nontrivial lower bound chapter upper bounds match lower bound asymptotically sorting algorithms asym ptotically optimal lower bound sorting prove lower bounds problems engineering issues fore implementing sorting algorithms fastest sorting program situation depe factors prior knowledge keys satellite data memory hierarchy caches virtual memory host computer software environment issues dealt algorithmic level tweaking code sorting algorithms introduced algorithms sort real numbers chapter insertion sort takes time worst case loops tight fast inplace sorting algorithm small input sizes reca sorting algorithm sorts place constant number elements input array stored array merge sort asymptotic running time lg merge procedure operate place introduce algorit hms sort arbitrary real numbers heapsort presented chapter sorts numbers place lg time data structure called heap implement priority queue quicksort chapter sorts numbers place worstcase running time averagecase running time lg generally outperforms heapsort practice inser tion sort quicksort tight code hidden constant factor running time small popul algorithm sorting large input arrays insertion sort merge sort heapsort quicksort comparison sorts determine sorted order input array comparing elements chapter introducing decisiontree model order study perf ormance limitations comparison sorts model prove lower bound lg worstcase running time comparison sort inputs showing heapsort merge sort asymptotically optimal comparison sorts chapter beat lower bound lg gather sorted order input comparing elements counting sort algorithm exampl assumes input numbers set array indexing tool determining relative order counting sort sort numbers time counting sort runs time linear size input array algorithm radi sort extend range counting sort integers sort integer digits digit set radix sort sort numbers dn time constant radix sort runs linear time algorith bucket sort requires knowledge probabilistic stribution numbers input array sort real numbers uniformly distributed half open interval averagecase time order statistics ith order statistic set numbers ith smallest number set select ith order statistic sorting input indexing ith element output assumptions nput distribution method runs lg time lower bound proved chapter chapter ith smallest element time elements arbitrary real numbers presen algorithm tight pseudocode runs time worst case linear time erage complicated algorithm runs worstcase time background rely difficult mathematics sections require mathematical sophistication averagecase analyses quicksort bucket sort orderstatistic algorithm probability reviewed appendix material probabilistic analysis randomized algorithms chapter analysis worstcase lineartime algorithm order stat istics involves sophisticated mathematics worstcase analyses chapter heapsort overview chapter introduce sorting algorithm merge insertion sort heapsorts running time lg insertion sort merge sort heapsort sorts place constant number array elements stor input array time heapsort combines ttributes sorting algorithms discussed heapsort introduces algorithm design technique data structure case heap manage formation execution algorithm heap data structure heapsort efficient priority queue heap data structure reappear algorithms chapters note term heap originally coin context heapsort refer garbagecollected storage programming languages lisp provide heap data structure garbagecollected storage refer heaps book structure defined chapter heaps binary heap data structure array object viewed complete binary tree b53 figure node tree corresponds element array stores node tree completely filled levels lowest lled left point array represents heap ject attributes length number elements array heapsizea number elements heap stored array lengtha valid numbers element aheapsizea heapsizea length element heap root tree node indices parent parenti left child lefti child righti computed simply parenti return lefti return righti return figure maxheap viewed binary tree array number circle node tree stored node number node array array lines showing parentchild relationships parents left children tree height node height computers left procedure compute instruction simply shifting binary representation left bit position sim ilarly procedure compute shifting binary representation left bit position adding loworder bit parent procedure compute shifting bit position good implementation heapsort procedures implemented macros inline procedures kinds binary heaps maxheap minheaps bot kinds values nodes satisfy heap property specifics depend kind heap maxheap maxheap property node root aparenti ai node lue parent largest element maxheap stored root subtree rooted node values larger contained node minheap organized opposite minheap property node root aparenti ai smallest element minheap root heapsort algorithm maxheaps minheaps commonly priority queues discuss precise maxheap minheap pplication prope rties apply maxheaps minheaps term heap viewing heap tree define height node heap number edges longest simple downward path node leaf define height heap height root heap elements based complete binary tree height lg exercise basic operations heaps time proportional height tree olg time remainder chapter presents basic procedur sorting algorithm priorityqueue data structure maxheapify procedure runs olg time key maintaining maxheap property buildmaxheap procedure runs linear time produces maxheap unordered input array heapsort procedure runs lg time sorts array place maxheapinsert heapextractmax heapincreasekey heapmaximum procedures olg time heap data structure priority queue exercises minimum ximum numbers elements heap height exercises nelement heap height lg exercises subtree maxheap root subt ree largest occurring subtree exercises maxheap smallest elem ent reside assuming elements distinct exercises array sorted order minheap exercises sequence maxheap exercises array representation storing nelement heap leaves nodes indexedmaintaining heap property maxheapify subroutine manipulating maxheaps inputs array array maxheapify called assumed binary trees rooted lefti righti maxheaps ai smaller children violating maxheap property unction maxheapify ai float maxheap subtree rooted maxheap maxheapifya lefti righti heapsizea ai largest largest heapsizea alargest largest largest exchange ai alargest maxheapifya largest figure illustrates action maxheapify step largest elements ai alefti arighti determined stored largest ai largest subt ree rooted node maxheap procedure terminates children largest element ai swapped alargest node children satisfy maxheap property node indexed largest original ai subtree rooted largest violate maxheap property cons equently maxheapify called recursively subtree figure action maxheapifya heapsizea initial configuration node violating maxheap operty larger children maxheap prope rty restored node exchanging destroys maxheap property node recursive max heapifya swapping a9 node fixed recursive maxheapifya yields change data structure running time maxheapify subtree size rooted node time relationships elements ai alefti aright time maxheapify subtree rooted children node childrens subtrees size n3the worst case occurs row tree half fulland running time maxheapify recurrence t2n3 solution recurrence case master theorem theorem olg alternatively characterize running time maxheapify node height exercises figure model illustrate operation maxheapifya array exercises starting procedure maxheapify write pseudocode procedure min heapifya performs manipulation minheap running time minheapify compare maxheapify exercises calling maxheapifya element ai larger children exercises calling maxheapifya heapsize exercises code maxheapify efficient terms constant factors recursive compilers produce inefficient code write efficient maxheapify iterative contro construct loop recursion exercises worstcase running time maxheapify heap size lg hint heap nodes node values maxheapify called recursively node path root leaf building heap procedure maxheapify bottomup manner convert array lengtha maxheap exercise elements subarray an21 leaves tree element heap procedure buildmaxheap remaining nodes tree runs max heapify buildmaxheapa heapsizea lengtha lengtha2 downto maxheapifya figure action buildmaxheap figure operation buildmaxheap showing data structure maxheapify buildmaxheap element input array binary tree represents figure loop refers node maxheapifya data structure loop iteration refers node subsequent iterations loop buildmaxheap observe maxheapify called node subtrees node maxheaps maxheap buil dmaxheap finishes buildmaxheap works correctly loop invariant start iteration loop lines node root maxheap invariant true prior loop iteration iteration loop maintains invariant invariant property correctness loop terminates initialization prior iteration loop node leaf root trivial maxheap maintenance iteration maintains loop invariant observe children node numbered higher loop invariant roots maxheaps preci sely condition required maxheapifya node maxheap root maxheapify preserves property nodes roots maxheaps decrementing loop update reestablishes loop invariant iteration termination termination loop invariant node root maxheap node compute simple upper bound running time buildmaxheap maxheapify costs olg time calls running time lg upper bound correct asymptotically tight derive tighter bound observing time axheapify node varies height node tree heights nodes small tighter analysis relies properties nelement heap height lg exercise n2h1 nodes height exercise time required maxheapify called node height express total cost buildmaxheap summation evaluated substituting formula a8 yields running time buildmaxheap bounded build maxheap unordered array linear time build minheap procedure buildminheap buildmaxheap axheapify replaced minheapify exercise buildminheap produces minheap unordered linear array linear time exercises figure model illustrate operat ion buildmaxheap array exercises loop buildmaxheap decrease lengtha2 increase lengtha2 exercises n2h1 nodes height nelement heap heapsort algorithm heapsort algorithm starts build maxheap build maxheap input array lengtha maximum element array stored root correct final position exchanging discard node heap decrementing heapsizea observe easily maxheap chil dren root remain maxheaps root element violate maxheap prop erty needed restore max heap property maxheapifya leaves maxheap heapsort algorithm repeat process maxheap size heap size exercise precise loop invariant heapsorta buildmaxheapa lengtha downto exchange ai heapsizea heapsizea maxheapifya figure operation heapsort maxheap initially built maxheap iteration loop lines figure operation heapsort maxheap data structure built buildmaxheap maxheap max heapify time lightly shaded nodes remain heap sorted array heapsort procedure takes time lg buildmaxheap takes time calls maxheapify takes time olg exercises figure model illustrate eration heapsort array exercises argue correctness heapsort loop invariant start iteration loop lines subarray maxheap smallest elements subarray ai largest elements sorted exercises running time heapsort array length sorted increasing order decreasing order exercises worstcase running time heapsort lg exercises elements distinct bestcase running time heapsort lg priority queues heapsort excellent algorithm good implementation quicksort presented chapter beats practice neverthele heap data structure enormous utility popular applications heap efficient priority queue heaps kinds priority queues max priority queues minpriori ty queues focus implement max priority queues turn based maxheaps exercise asks write procedures minpriority queues priority queue data structure maintaining set elements called key maxpriority queue supports operations inserts inserts element set operation written maximums returns element largest key extractmax removes returns element largest key increasekey increases element key assumed large current key application maxpriority queues schedule jobs shared computer max priority queue track jobs performed relative priorities job finished interrupted highestpriority job selected pending extractmax job queue time insert alternatively minpriority queue supports operations insert minimum extractmin decreasekey minprio rity queue eventdriven simulator items queue ents simulated time occurrence serves key ents simulated order time occurrence simulation events simulated future simulation program extr actmin step choose event simulate events produced inserted minpriority queue insert minpriority queue highlighting decreasekey operation chapters surprisingly heap implemen priority queue application job scheduling eventdriven simulation elements priority queue correspond objects application determine application object corresponds priorityqueue element viceversa heap implement priority queue theref ore store handle application object heap element exact makeup handle pointer integer depends application sim ilarly store handle heap element application object handle typically array heap elements change loca tions array heap operations actual implementation relo cating heap element update array applicati object details accessing application objects depend heavily application implementation pursue noting actice handles correctly maintained discuss implement operatio maxpriority queue procedure heapmaximum implements maximum operation time heapmaximuma return procedure heapextractmax implemen extractmax operation loop body lines heapsort procedure heapextractmaxa heapsizea error heap underflow max aheapsizea heapsizea heapsizea maxheapifya return max running time heapextractmax olg performs constant work olg time maxheapify procedure heapincreasekey implem ents increasekey operation priorityqueue element key increased identified array procedure updates key element ai increasing key ai violate maxheap property ocedure manner reminiscent insertion loop lines insertionsort traverses path node root proper place newly increased key traversal repeatedly compares elemen parent exchanging keys continuing elements key larger terminating elements key smaller maxheap property holds exercise precise loop invariant heapincreasekeya key key ai error key smaller current key ai key aparenti ai exchange ai aparenti parenti figure heapincreasekey operation running time heapincreasekey nelement heap olg path traced node updated root length olg figure operation heapincreasekey maxheap figure node heavily shaded node key increased iteration loop lines node parent exchanged keys moves parent maxheap iteration loop point aparenti ai maxheap property holds procedure terminates procedure maxheapinsert implements insert operation takes input key element inserted maxheap procedure expands maxheap adding tree leaf key calls heapincrease key set key node correct maintain maxheap property maxheapinserta key heapsizea heapsizea aheapsizea heapincreasekeya heapsizea key running time maxheapinsert nelement heap olg summary heap support prio rityqueue operation set size olg time exercises illustrate operation heapextractmax heap exercises illustrate operation maxheapinserta heap heap figure model apincreasekey exercises write pseudocode procedures apminimum heapextractmin heapdecreasekey minheapinsert implement minpriority queue minheap exercises bother setting key inserted node maxheapinsert thing increase key desired exercises argue correctness heapincreasekey loop invariant start iteration loop lines array heapsizea satisfies maxheap property excep violation ai larger aparenti exercises implement firstin firstout queue priority queue implement stack priority queues stacks defined exercises operation heapdeletea deletes item node heap implementation heapdelete runs olg time nelement maxheap exercises lg ktime algorithm merge sorted lists sorted list total number elements input lists hint minheap kway merging problems building heap insertion procedure buildmaxheap implemented repeatedly maxheapinsert insert elements heap implementation buildmaxheapa heapsizealengtha maxheapinserta ai procedures buildmaxheap buildmaxheap create heap input array prove provide counterexample worst case buildmaxheap requires lg time build nelement heap problems analysis dary heaps dary heap binary heap exception nonleaf nodes children children represent dary heap array height dary heap elements terms efficient implemen tation extractmax dary maxheap analyze running time terms efficient implementation insert dary maxheap analyze running time terms efficient implem entation increasekeya sets ai max ai updates dary maxheap structure appropriately analyze running time terms problems young tableaus young tableau matrix entries row sorted order left entries column sorted order entries young tableau treat nonexistent elements young tableau hold finite numbers draw young tableau elements argue young tableau y1 argue elements ym algorithm implement extractmin nonempty young tableau runs time algorithm recursive subroutine solves problem recursively solving subproblem hint maxheapify define maximum running time extractmin young tableau solve recurrence yields time bound insert element nonfull young tableau time sorting method subroutine young tableau sort numbers on3 time omntime algorithm determine whethe number stored young tableau chapter notes heapsort algorithm invented williams implement priority queue heap buildmaxheap procedure suggested floyd minheaps implem ent minpriority queues chaptersimplementation improved tim bounds operations chapters faster implementations priority queues integer data data structure invented van emde boas supports operations minimum maximum insert delete search extractmin extractmax predecessor successor worstcase time olg lg subject restric tion universe keys set data bbit integers computer memory consists addressable bbit fredman willard implement minimum o1 time insert extractmin time thorup improved bound olg lg time bound space unbounded implemented linear space randomized hashing special case priority queue occurs sequence extractmin operations monotone values returned successive extractmin operations monotonically increasing time case arises applications dijkstras singlesource shortestp aths algorithm discussed chapter discreteevent simulation dijkstras algorithm pa rticularly decreasekey operation implemented effici ently monotone case data integers range ahuja melhorn orlin tarjan implement extractmin insert olg amortized time chapter amortized analysis decreasekey o1 time data structure called radix heap olg bound improved fibonacci heaps chapter conjunction radix heaps bound improved olg13 expected time cherkassky goldberg silverstein combine multilevel bucketing structure denardo fox heap thorup mentioned raman improved bound ominlg lg13 fixed detailed discussions papers raman thorup chapter quicksort quicksort sorting algorithm worstcase running time input array numbers spite slow worstcase running time quicksort practical choice sorting remarkably effi cient average expected running time lg constant factors hidden lg notation small advantage sorting place works virtual memory environments describes algorithm import ant subroutine quicksort partitioning behavior quicksort complex start intuitive discussion performance postpone precise analysis chapter presents version quicksort random sampling algorithm good averagecase running time input elicits worstcase behavior randomized algorithm analyzed time worst case lg time average description quicksort quicksort merge sort based divide conquer paradigm introduced threestep divide conquer process sorting typical subarray divide partition rearrange array subarrays aq element equal aq turn equal element aq compute partitioning procedure conquer sort subarrays aq recursive calls quicksort combine subarrays sorted place work needed combine entire array sorted procedure implements quicksort quicksorta partitiona quicksorta quicksorta sort entire array initial quicksort lengtha partitioning array key algorithm partition procedure rearranges subarray place partitiona exchange ai exchange ai return figure operation partition element array partition selects element pivot element partition subarray procedure runs array partitioned regions start iteration loop lines region satisfies properties state loop invariant figure operation partition sample array lightly shaded array elements partition values greater heavily shaded elements partition values greater unshaded elements partitions final white element pivot initial array variable settings elements partitions swapped partition smaller values values partition larger values values swapped smaller partition grows values swapped smaller partition grows gh larger partition grows include loop terminates lines pivot element swapped lies partitions iteration loop lines array akak ak figure summarizes structure indices covered cases values entrie relationship pivot figure regions maintained procedure partition subarray values equal values ai greater values values loop invariant true prior iteration iteration loop maintains invariant invariant property correctness loop terminates initialization prior iteration loop values values conditions loop invariant trivially satisfied assignment satisfies condition maintenance figure cases depending outcome test figure action loop increment incremented condition holds entries remain unchanged figure incremented ai swapped incremented swap ai condition satisfied item swapped loop invariant greater figure cases iteration procedure partition action increment maintains loop invariant incremented ai swapped incremented loop invariant maintained termination termination entry array sets invariant partitioned values array sets equal greater singleton set final lines partition pivot element place middle array swapping leftmost element greater output partition satisfies specifications divide step running time partition subarray exercise exercises figure model illustrate eration partition array exercises partition return elements array modify partition pr2 elements array exercises argument running time partition subarray size exercises modify quicksort sort nonincreasing order performance quicksort running time quicksort depends whethe partitioning balanced unbalanced turn depends elements partitioning partitioning balanced algorithm runs asymptotically fast merge sort partitioning unbalanced asymptotically slowly insertion sort informally investigate quicksort performs assumptions balanced versus unbalanced partitioning worstcase partitioning worstcase behavior quicksort occurs partitioning routine produces subproblem elements elements claim proved assume unbalanced titioning arises recursive partitioning costs time recursive array size returns t0 recurrence running time t0 intuitively sum costs incurred level recursion arithmetic series equation evaluates straightforward substitution method prove recurrence solution exercise partitioning maximally unbalanced recursive level algorithm running time worstcase running time quicksort insertion sort running time occurs input array completely sorteda common situation insertion sort runs time bestcase partitioning split partition produces subproblems size size size case quicksort runs faster recurrence running time case master theorem theorem solution lg equal balancing sides partition level recursion produces asymptotically faster algorithm balanced partitioning averagecase running time quicksort closer case worst case analyses key understanding understand balance partitioning reflected recurrence describes running time suppose partitioning gorithm produces to1 proportional split blush unbalanced recurrence n10 n10 running time quicksort explicitly cluded constant hidden term figure recursion tree recurrence notice level tree cost boundary condition reached depth log lgn levels cost recursion terminates depth log lg total cost quicksort lg to1 proportional split level recursion intuitively unbalanced quicksort runs lg time asymptotically split ght middle fact to1 split yields lg running time reason split constant proportionality yields recursion tree depth lg cost level running time lg split constant proportionality figure recursion tree quicksort partition produces to1 split yielding running time lg nodes subproblem sizes perlevel costs perlevel costs include constant implicit term intuition average case develop clear notion average case quicksort assumption frequently expect encounter inputs behavior quicksort determined relative ordering values array elements input values array probabilistic analysis hiring problem assume permut ations input numbers equally quicksort random input arra partitioning level informal analysis assumed expect splits bala nced fairly unbalanced exercise asks percent time partition produces split balancedpercent time produces split balanced average case partition produces mi good bad splits recursion tree averagecase execution partition good bad splits distributed randomly tree suppose intuition good bad splits alternate levels tree good splits bestcase splits bad splits worstcase splits figure splits consecutive levels recursion tree root tree cost partitioning subarrays produced sizes worst case level subarray size bestcase partitioned subarrays sizeassume boundary condition cost subarray size figure levels recursion tree quicksort partitioning root costs produces bad split subarrays sizes partitioning subarray size costs produces good split subarrays sizesingle level recursion tree balanced parts partitioning cost subproblems hown elliptical shading subproblems remaining solved square shading larger subproblems remaining solved combination bad split good split produces subarrays sizes combined partitioning cost situation worse figure single level partitioning produces subarrays size cost situation balanced intuitively cost bad split absorbed cost good split split good running time quicksort levels alternate good bad splits running time good splits lg larger constant hidden onotation rigorous analysis average case exercises substitution method prove recurrence solution claimed exercises running time quicksort elements array exercises running time quicksort array distinct elements sorted decreasing order exercises banks record transactions account order times transactions people receive bank statements checks listed order check number people write checks order check number merchants cash reasonable dispatch problem converting timeoftransaction ordering checknumber ordering problem sorting almostsorted input argue procedure insertionsort tend beat procedure quicksort problem exercises suppose splits level quicksort proportionconstant minimum depth leaf recursion tree lg lg maximum depth lg lg1 dont worry integer roundoff exercises argue constant probability random input array partition produces split balanced randomized version quicksort exploring averagecase behavior quicksort assumption permutations input numbers equally engineering situation expect hold exercise add randomization algorithm order good averagecase performance inputs people rega randomized version quicksort sorting algorithm choice large inputs randomized algorithm explicitly permuting input quicksort randomization technique called random sampling yields simpler analysis pivot randomly chosen element subarray exchanging element element chosen random modification randomly sample range ensures pivot element equally elements subarray pivot ement randomly chosen expect split input array balanced average partition quicksort partition procedure simply implement swap partitioning randomizedpartitiona randomp exchange ai return partitiona quicksort calls randomized partition place partition randomizedquicksorta randomizedpartitiona randomizedquicksorta randomizedquicksorta analyze algorithm exercises analyze averagecase performance random ized algorithm worstcase performance exercises running procedure randomizedquicksort calls randomnumber generator random worst case case answer terms notation analysis quicksort intuition worstcase behavior quicksort expect analyze behavior quicksort rigorously worstcase analysis applies quicksort randomizedquicksort conclude averagecase analysis randomizedquicksort worstcase analysis worstcase split vel recursion quicksort produces running time intuitively worstcase running time algorithm prove assertion substitution method running time quicksort on2 worstcase time procedure quicksort input size recurrence parameter ranges procedure partition produces subproblems total size guess cn2 constant substituting guess recurrence expression q2 nq12 achieves maximum parameters range endpoint derivative expression respect positive exercise observation bound max qn1q2continuing bounding cn2 c2n cn2 pick constant large c2n term dominates term on2 specific case quicksort takes time partitioning unbalanced alternatively exercise asks recurrence solution worstcase running time quicksort expected running time intuitive argument averagecase running time randomizedquicksort lg level ecursion split induced randomizedpartition puts constant fraction elements partition recursion tree depth lg work performed level add levels unba lanced split levels total time remains lg analyze expect running time randomized quicksort precisely understanding partitioning procedure operates understanding derive lg bound expected running time upper bound expected running time combined lg bestcase bound yields lg expected running time running time comparisons running time quicksort dominat time spent partition procedure time partition procedure called pivot element selected element included ture recursive calls quicksort partition calls partition entire execution quicksort algorithm partition takes o1 time time proportional number iterations loop lines iteration loop performs comparison inline compari pivot element element array count total nu mber times executed bound total time spent loop entire execution quicksort lemma number compar isons performed partition entire execution quicksort nelement array running time quicksort proof discussion calls partition constant work executes loop number times iteration loop executes goal compute total number comparisons performed calls partition attempt anal yze comparisons partition derive bound total number comparisons understand algorithm comp ares elements array ease analysis rename elements array z1 z2 zn ith smallest element define set zij zi1 zj set elements zj inclusive algorithm compare zj answer question observe pair elements compared elements compared pivot element partic ular partition finishes pivot element comp ared elements analysis indicator random variables define xij compared zj comp arison takes place time execution algorithm iteration partition pair compared easily characterize total number comparisons performed algorithm expectations sides linearity expectation lemma remains compute compared zj items compared input quicksort numbers order assume pivot element partition separates numbers sets pivot element compared elements number set compar number set general pivot chosen zj zj compared subsequent time hand chosen pivot item zij compared item zij zj chosen pivot item zij zj compared item zij values compared item z79 chosen pivot contrast compared pivot element chosen z29 zj compared element chosen pivot zij zj compute probability event occurs prior point element zij chosen pivot set zij partition element zij equally chosen pivot set zij elements probability element chosen pivot events mutually exclusive combining equations evaluate sum change variables bound harmonic series equation a7 conclude randomizedpartition expected running time quicksort lg exercises recurrence exercises quicksorts bestcase running time lg exercises q2 achieves maximum exercises randomizedquicksorts expected running time lg exercises running time quicksort improved practice advantage fast running time insertion sort input sorted quicksort called subarray fewer elements simply return thout sorting subarray toplevel quicksort returns insertio sort entire array finish sorting process argue sorting algorithm runs onk lgnk expected time picked theory practice exercises modifying partition procedure randomly picking elements array partitioning median middle elements approximate probability worst to1 split function range problems hoare partition correctness version partition chapter original partitioning algorithm original partition algorithm hoare hoarepartitiona true repeatrepeat ai exchange ai return demonstrate operation hoarepartition array showing values array auxiliary values iteration loop lines questions careful argument procedure hoare partition correct prove indices access element subarray hoarepartition terminates returns element equal element hoarepartition terminates partition procedure separates pivot originally partitions forms hoarepartition procedure hand places pivot originally partitions split nontrivial rewrite quicksort proce dure hoarepartition problems alternative quicksort analysis alternative analysis running time randomized quicksort focuses expected running time individual recursive quicksort number comparisons performed argue array size probability element chosen pivot define indicator random variables iith smallest element chosen pivot random variable denoting runn ing time quicksort array size argue equation simplifies hint split summation parts bound equation recurrence equation solution lg hint substitution log positive constants problems stooge sort professors howard fine howard proposed elegant sorting algorithm stoogesorta ai exchange aireturn round stoogesorta twothirds stoogesorta twothirds stoogesorta twothirds argue lengtha stoogesort lengtha correctly sorts input array recurrence worstcase running time stoogesort tight asymptotic notation bound worstcase running time compare worstcase running time oogesort insertion sort merge sort heapsort quicksort professors deserve tenure problems stack depth quicksort quicksort algorithm recursive calls partition left subarray recurs ively sorted subarray recursively sorted recursive quicksort real ly avoided iterative control structure technique called tail recursion provided automatically good compilers cons ider version quicksort simulates tail recursion quicksorta partition sort left subarray partitiona quicksortaargue quicksort lengtha correctly sorts array compilers execute recu rsive procedures stack pertinent including parameter values recursive stack initial procedure invoked pushed stack terminates popped assume array parameters represented pointers procedure stack requires o1 stack space stack depth maximum stack space time computation scenario stack depth quicksort nelement input array modify code quicksort worstcase stack depth lg maintain lg expected running time algorithm problems medianof3 partition improve randomizedquick sort procedure partition pivot chosen car efully picking random element subarray common approach medianof3 method choose pivot median middle element set elements ndomly selected subarray exercise problem assume elements input array distinct denote sorted output array medianof3 method choose pivot element define prx ai exact formula functionnote increased likelihood choosing pivot median compared ordinary implementation assume limiting rati probabilities define good split choosing pivot ai n3 increased lihood good split compared ordinary implementation hint approximate sum integral argue lg running time quicksort medianof3 method constant factor problems fuzzy sorting intervals sorting problem num bers number interval real belongs closed intervals form ai ai goal fuzzysort intervals produce permutation i1 intervals su exist satisfying design algorithm fuzzysorting intervals algorithm general structure algorithm quicksorts left endpoints ai advantage overlapping intervals improve running time intervals overlap problem fuzzysorting intervals easier easier algorithm hould advantage overlapping extent exists argue algorithm runs expected time lg general runs expected time intervals overla exists ai algorithm checking case explicitly performance naturally improve overlap increases chapter notes quicksort procedure invented hoare hoares version appears problem partition procedure lomuto analysis avrim blum sedgewick bentley provide good reference details implementation matter mcilroy engineer killer adversary produces array virtually implementation quicksort takes time implementation randomized adversary produces array afte random choi ces quicksort algorithm chapter sorting linear time overview introduced algorithms sort numbers lg time merge sort heapsort achieve upper bound worst case quicksort achieves average algori thms produce sequence input numbers algorithm lg time algorithms share interesting property sorted order determine based comparisons input elements sorting algorithms comparison sorts sorting algorithms introdu ced comparison sorts prove comparison sort lg comparisons worst case sort elements merge sort apsort asymptotically optimal comparison sort exists faster constant factor sectionsexamine sorting algorithms counting sort radix sort bucket sortthat linear time needless algorithms operations comparisons determine rted order lg lower bound apply lower bounds sorting comparison sort comparisons elements gain order input sequence elements ai perform tests ai ai ai ai ai determine relative order inspect values elements gain order assume loss generality input elements distinct assumption comparisons form ai useless assume comparisons form note comparisons ai ai ai ai equivalent yield identical informati relative order ai assume comparisons form ai decisiontree model comparison sorts viewed abstractly terms decision trees decision tree binary tree represents comparisons elements performed sorting algorithm ope rating input size control data movement aspects algorithm figure decision tree insertion sort algorithm operating input sequence elements figure decision tree insertion sort operating elements internal node annotated comparison ai leaf annotated permutation ordering shaded path decisions sorting input sequencepermutationleaf sorted ordering permutations inpu elements decision tree leaves decision tree ternal node annotated range number elements inpu sequence leaf annotated permutation background permutations execution sorting algorithm corresponds tracing path root decision tree leaf internal node comparison ai left ubtree dictates subsequent comparisons ai subtree dictates subsequent comparisons ai leaf sorti algorithm established ordering correct sorting algorithm produce permutation input condition comparison sort correct permutations elements leaves decision tree leaves reachable root path actual execution comparison sort refe leaves reachable decision trees permutation appears reachable leaf lower bound worst case length longest path root decision tree reachable leaves represents worstcase number comparisons sorting algorithm performs worstcase number comparisons comparison sort algorithm equals height decision tree lower bound heights decision trees permutation appears reachable leaf lower bound running time comparison sort algorithm theorem establishes lower bound theorem comparison sort algorithm requires lg comparisons worst case proof preceding discussion suffices determine height decision tree permutation appears reachable leaf decision tree height reachable leaves comparison sort elements permutations input appears leaf binary tree height leaves logarithms implies lg lg func tion monotonically increasing lg equation corollary heapsort merge sort asympt otically optimal comparison sorts proof lg upper bounds running times heapsort merge sort match lg worstcase lower bound theorem exercises smallest depth eaf decision tree comparison sort exercises asymptotically tight bounds lg stirlings approximation evaluate summation techniques exercises comparis sort running time lin ear half inputs length fraction inputs length fraction exercises sequence elements sort input sequence consists nk subsequences elements elements subsequence smaller elements succeeding subs equence larger elements preceding subsequence eded sort sequence length sort elements nk subsequences lg lower bound number comparisons needed solve variant sorting problem hint rigorous simply combine lower bounds individual subsequences counting sort counting sort assumes input elements teger range integer sort runs time basic idea counting sort determine input element number elements place element directly position output array elements belongs output position scheme modified sli ghtly handle situation elements position code counting sort assume input array lengtha require othe arrays array holds sorted output array c0 temporary working storage countingsorta lengtha caj caj number elements equal number elements equal lengtha downto bcaj caj caj figure illustrates counting sort initialization loop lines inspect input element loop lines input element increment holds number input elements equal integer lines determine input elements equal keeping running sum array figure operation countingsort input array element nonnegative integer larger array auxiliary array array output array auxiliary array iterations loop lines lightly shaded elements array filled final sorted output array finally loop lines place element correct sorted position output array elements distinct enter caj correct final position output array caj elements equal elements distinct decrement caj time place array decrementing caj input element equal exists position output array time counting sort require loop lines takes time loop lines takes time loop lines takes time loop lines takes time time kn practice counting sort case running time counting sort beats lower bound lg proved comparison sort fact comparisons input elements occur code counting sort actual values elements array lg lower bound sorting apply depart comparisonsort model property ounting sort stable numbers output array order input array ties numbers broken rule whichever number appears rst input array appears output array norma lly property stability satellite data carried element sort counting sorts stab ility reason counting sort subroutine radix sort counting sorts stability cruc ial radix sorts correctness exercises figure model illustrate oper ation countingsort arrayexercises prove countingsort stable exercises suppose loop header countingsort procedure rewritten length algorithm works prope rly modified algorithm stable exercises algorithm integers range preprocesses input answers query integers fall range o1 time algorithm preprocessing time radix sort radix sort algorithm cardsorti machines computer museums cards organized lumns column hole punched places sorter mechanically programmed examine column card deck distribute card bins depending place punched operator gather cards bin bin cards place punched car place punched digits places column places encoding nonnumeric characters ddigit number occupy field columns card sorter column time problem sorting cards ddigit number requires sorting algorithm intuitively sort numbers digit sort bins recursively combine decks order cards bins sort bins procedure generates intermediate piles cards track exercise radix sort solves problem card rting counterintuitiv ely sorting digit cards combined single deck cards bin preceding cards bin preceding cards bin entire deck sorted secondleast digit recombined manner process continues cards sorted digits remarkably point cards fully sorted ddigit number passes deck required sort figure radix sort operates deck digit numbers figure operation radix sort list digit numbers leftmost column input remaining column list successive sorts increasingly digit positions shading digit position sorted produce list previous essential digit sorts algorithm stable sort performed card sorter stable operator wary changing order cards bin cards bin digit chosen column typical computer sequential ndomaccess machine radix sort sort records keyed multiple fields sort dates keys year month day coul sorting algorithm comparison function dates compar years tie compares months tie occurs compares days alternatively sort times stable sort day month finally year code radix sort straightforward procedure assumes element nelement array digits digit lowestorder digit digit highestorder digit radixsortastable sort sort array digit lemma ddigit numbers digit values radixsort correctly sorts numbers dn time proof correctness radix sort induction column sorted exercise analysis running time depe nds stable sort intermediate sorting algorithm digit range k1 values large counting sort obvious choice pass ddigit numbers takes time passes total time radix sort dn constant radix sort runs linear time generally flexibility break key digits lemma bbit numbers positive integer radixsort correctly sorts numbers brn time proof view key digits bits digit integer range counting sort view bit word bit digits rpass counting sort takes time passes total running time dn brn values choose minimizes expression brn lg choosing yields running time bbn asymptotically optimal lg choosing lg time ithin constant factor choosing lg yields running time lg increase lg term numerator increases faster term denominator increasing lg yields running time lg decrease lg term increases term remains radix sort preferable comparisonbase sorting algorithm quicksort olg case choose lg radix sorts running time appears quicksorts averagecase time lg constant factors hidden notation differ radix sort fewer passes quicksort keys pass radix sort longer sorting algorithm preferable depends characteristics implementations underlying machine quicksort hard ware caches effectively radix sort input data version radix sort counting sort intermediate stable sort sort place lg ntime comparison sorts primary memory storage premium inplace algorithm quicksort preferable exercises figure model illustrate operation radixsort list english cow dog sea rug row mob box tab bar ear tar dig big tea fox exercises sorting algorithms stable insertion sort merge sort heapsort quicksort simple scheme sorting algorithm stable additional time space scheme entail exercises induction prove radix sort works proof assumption intermediate sort stable exercises sort integers range time exercises cardsorting algorithm ction sorting passes needed sort ddigit numbers worst case piles cards operator track worst case bucket sort bucket sort runs linear time input drawn uniform distribution counting sort bucket sort fast assumes input counting sort assumes input consists integers small range bucket sort assumes input generated random process distributes elements uniformly interval definition uniform distribution idea bucket sort divide interval equalsized subintervals buckets distribute input numbers buckets inputs uniformly distributed dont expect numbers fall bucket produce output simply sort numbers bucket buckets order listing elements code bucket sort assumes input nelement array element ai array satisfies ai code requires auxiliary array b0 linked lists buckets assumes mechanism maintaining lists describes implement sic operations linked lists bucketsorta lengthainsert ai list ai sort list insertion sort concatenate lists b0 order figure operation bucket sort input array numbers figure operation bucketsort input array array b0 sorted lists buckets algorithm bucket holds values halfopen interval i10 sorted output consists concatenation order lists b0 b9 algorithm works elements ai assume loss generality ai ai element ai bucket bucket lower ai bucket loop lines puts proper order ai buckets puts proper order bucket sort works correctly analyze running time observe lines time worst case remains balance total time calls insertion sort analyze cost calls insertion sort random variable denoting number elements bucket insertion sort runs quadratic time running time bucket sort expectations sides linearity expectation claim surprise bucket input array equally fall bucket prove equation define indicator random variables xij iaj falls bucket compute expand square regroup terms linearity expectation evaluate summations separately indicator random variable xij probability variables xij xik independent substituting expected values equation proves equation expected equation conclude expected time bucket sort o2 entire bucket sort algorithm runs linear expected time input drawn uniform distribution bucket sort linear time long input property sum squares bucket sizes linear total number elements equation tells bucket sort linear time exercises figure model illustrate oper ation bucketsort array exercises worstcase running time bucke tsort algorithm simple change algorithm preserves linear expected runni time worstcase running time lg exercises random variable equal number heads flips fair coin exercises points unit circle yi suppose points uniformly distributed probability finding point region circle proportional area region design expectedtime algorithm sort points distances origin hint design bucket sizes bucketsort reflect uniform distribution points unit circle exercises probability distribution function px random variable defined px suppose list random variables drawn continuous probability distribution function computable o1 time sort numbers linear expected time problems averagecase lower bounds comparison sorting problem prove lg lower bound expected running time deterministic randomized comparison sort distinct input elements examining deterministic comparison sort decision tree ta assume permutation inputs equally suppose leaf ta labeled probabil ity reached random input prove leaves labeled labeled denote external path length decision tree sum depths leaves decision tree leaves left subtrees dlt drt minimum decision trees leaves min ik1 hint decision tree leaves achieves minimum i0 number leaves i0 number leaves prove range function lg lg minimized k2 conclude lg prove dta lgn conclude expected time sort elements lg randomized comparison sort extend decisiontree model handle randomization incorporating ki nds nodes ordinary comparison nodes randomization nodes randomization node models random choice form random1 algorithm node children equally chosen execution algorithm randomized comparison sort exists deterministic comparison sort comparisons average problems sorting place linear time suppose array data records sort key record algorithm sorting set records possess subset desirable characteristics algorithm runs time algorithm stable algorithm sorts place constant storage space addition original array algorithm satis fies criteria algorithm satis fies criteria algorithm satis fies criteria sorting algorithms fro parts sort records bbit keys radix sort obn time explain suppose records keys range modify counting sort reco rds sorted place time storage input array algorithm stable hint problems sorting variablelength items array integers integers numbers digits tal number digits integers array sort array time array strings fferent strings numbers characters total number characters strings sort strings time note desired order standard alphabetical order problems water jugs suppose red blue water jugs shapes sizes red jugs hold amounts water blue red jug blue jug holds water vice versa task grouping jugs pairs red blue jugs hold water perform operation pick pair jugs red blue red jug water pour water blue jug operation red blue jug hold water volume assume comparison takes time unit goal algorithm minimum number comparisons determine grouping remember directly compare red jugs blue jugs deterministic algorithm comparisons group jugs pairs prove lower bound lg number comparisons algorithm solving problem randomized algorithm xpected number comparisons lg prove bound correct worstcase number comparisons algorithm problems average sorting suppose sorting array require elements increase average precisely nelement array ksorted holds array sorted permutation numberssorted sorted prove nelement array ksorted ai ai algorithm ksorts nelement array lgnk time lower bound time produce ksorted array constant ksorted array length sorted lg time hint solution exercise constant requires lg time ksort nelement array hint solution previous lower bound comparison sorts problems lower bound merging sorted lists problem merging sort lists arises frequently subroutine mergesort procedure merge tw sorted lists merge problem lower bound worstcase number comparisons quired merge sorted lists items lower bound comparisons decision tree numbers ways divide sorted lists numbers decision tree algorithm correctly merges sorted lists comparisons tighter bound elements consecutive sorted order opposite lists compared answer previous lower bound comparisons merging sorted lists chapter notes decisiontree model studying comparison sorts introduced ford johnson knuths comprehensive treatise sorting covers variations sorting problem including informationtheoretic wer bound complexity sorting lower bounds sorting generalizations decisiontree model studied comprehensively benor knuth credits seward inventing counting sort idea combining counting sort radi sort radix sorting starting digit appears folk algorithm operators mechanical cardsorting machines knuth published reference method document comrie describing punchedcard equipment buck sorting basic idea proposed isaac singleton munro raman stable sorting algorithm performs on1 comparisons worst case fixed constant lg ntime algorithms fewer comparisons algo rithm munro raman moves data times operates place case sorting bbit integers lg time considered researchers positive assumptions model computation restrictions algorithm assume computer memory divided addressable bbit fredman willard introduced fusion tree data structure sort integers lg lg lg time bound improved time andersson algorithms require multiplication precomputed constants andersson hagerup nilsson raman sort integers lg lg time multiplication method requires storage unbounded terms multiplicative hashing reduce storage needed lg lg worstcase bound running time expectedtime bound generalizing exponential search trees andersson thorup onlg lg n2time sorting algorithm multiplication rand omization linear space combining techniques ideas han improved bound sorting lg lg lg lg lg time algorithms impor tant theoretical breakthroughs fairly complicated time compete existing sorting algorithms practice chapter medians order statistics overview ith order statistic set elements ith smallest element minimum set elements order statistic maximum nth order statistic median informally halfway point set odd median unique occurring medians occurring parity medians occur lower median upper median simplicity texthowever consistently phrase median refer lower median chapter addresses problem selecting ith order statistic set distinct numbers assume convenience set distinct numbers virtually extends situation set repeated values selection problem formally input set distinct numbers number output element larger elements selection problem solved lg time sort numbers heapsort merge sort simply ith element output array faster algorithms examine problem selecting minimum maximum set elements interesting general selection problem investigated subsequent sections analyzes practical algorithm achieves bound running time average case algorithm theoretical achieves running time worst case minimum maximum comparisons determine minimum set elements easily upper bound comparisons examine element set turn track smallest element procedure assume set resides array lengtha minimuma min lengtha min ai min ai return min finding maximum accomplished comparisons lower bound comparisons problem determining minimum ink algorithm determines minimum tournament elements comparison match tournament smaller elements key observation element winner lose match comparisons determine minimum algorithm mini mum optimal spect number comparisons performed simultaneous minimum maximum applications minimum maximum set elements graphics ogram scale set data fit rectangular display screen graphical output device program determine minimum maximum coordinate difficult devise algorithm minimum maximum elements comparisons asymptotically optimal simply minimum maximum independently comparisons total comparisons fact comparisons sufficient minimum maximum strategy maintain mi nimum maximum elements processing element input comparing current minimum maximum cost compar isons element process elements pairs compare pairs elements input compare smaller current minimum larger current maximum cost comparisons elements setting initial values current minimum maximum depends odd odd set minimum maximu element process rest elements pairs perform comparison elements determine initial values minimum maximum process rest elements pairs case odd analyze total nu mber comparisons odd perform comparisons perform initial comparison comparisons total case total number comparisons exercises smallest elements lg comparisons worst case hint smallest element exercises comparisons worst case maximum minimum numbers hint numbers maximum minimum investigate comparison counts selection expected linear time general selection problem appears fficult simple problem finding minimum surprisingly asymptotic running time problems divide conquer algorithm selection problem algorithm randomizedselect modeled quicksort algorithm chapter quicksort idea partition input array recursively quicksort recursively processes sides partition randomizedselect works partition difference analysis quicksort expected running time lg expected time randomizedselect randomizedselect procedure randomizedpartition introduced randomizedquicksort randomized algorithm behavior determined pa output randomnum ber generator code randomizedselect returns ith smallest element array randomizedselecta return randomizedpartitionapivot answer return aq elseif return randomizedselecta return randomizedselecta randomizedpartition executed algorithm array partitioned subarrays aq element equal aq turn element aq quicksort refer aq pivot element randomizedselect computes number elements subarray number elements low partition pivot element checks aq ith smallest element aq returned algorithm determines subarrays aq ith smallest element lies desired element li low partition recursively selected subarray desired element lies high partition values smaller ith smallest element ršnamely elements qšthe desired element kth smallest element aq recursively code appears recursive calls subarrays elements exercise asks situati happen worstcase running time randomizedselect minimum extremely unl ucky partition largest remaining element partitioning takes time algorithm rks average case randomized partic ular input elicits worstcase behavior time required randomizedselect input array elements random variable denote upper bound procedure randomizedpartition equally return element pivot subarray elements equal pivot probabilitydefine indicator random variables ithe subarray elements randomizedselect choose aq pivot element priori terminate immediat ely correct answer recurse subarray recurse subarray aq decision depends ith smallest element falls relative aq assuming monotonically increasing bound time needed recursive time needed recursive largest input assume upper bound ith element partition greater number elements randomizedselect indicator random variablesubarrays recurse sizes recurrence expected values order apply equation c23 rely tmax independent random variables exercise asks justify assertion expression max term tn2 appears summation odd terms tn2 appears solve recurrence substitution assume constant satisfies initial conditions recurrence assume o1 constant pick cons tant pick constant function term describes nonrecursive component running time algorithm bounded inductive hypothesis order complete proof large expression equivalently cn4 add sides factor nc4 long choose constant divide sides assume o1 conclude order statistic media determined average linear time exercises randomizedselect recursiv length array exercises argue indicator random variable tmaxk independent exercises write iterative version randomizedselect exercises suppose randomizedselect select minimum element array sequence partitions worstcase performance randomizedselect selection worstcase linear time examine selection algorithm running time worst case randomizedselect algorithm select finds desired element recursively partitioning input array idea algorithm guarantee good split array partitioned select deterministic partitioning algorithm partition quicksort modified element partition input parameter select algorithm determines ith smallest input array elements executing steps select returns input ith smallest divide elements input array n5 groups elements group remaining mod elements median n5 groups insertion sorting elements group picking median sorted list group elements select recursively median n5 medians step number medians convention lower median partition input array medianofmedians modified version partition number elements low partition kth smallest element nk elements high partition return select recursively ith smallest element low kth smallest element high analyze running time select determine lower bound number elements greater partitioning element figure helpful visualizing bookkeeping half dians step greater than1 median ofmedians half n5 groups contribute elements greater group fewer elements divide group discounting groups number elements greater figure analysis algorithm select elements represented small circles group occupies column medians groups whitened medianofmedians labeled finding median number elements lower median arrows drawn larger elements smaller group elements greater group elements left elements greater shaded background number elements n10 worst case select called recursively n10 elements step develop recurrence worstcase running time algorithm select stepstime step consists calls insertion sort sets size o1 step takes time tn5 step takes time t7n10 assuming monotonically increasing assumption unmotivated input fewer elements requires o1 time origin magic constant clear shortl recurrence running time linear subs titution suitably large constant assuming suitably large constant assumption holds large pick constant func tion term describes nonrecursive component runni time algorithm bounded substituting inductive hypothesis righthand recurrence yields n5 n10 cn5 cn10 cn10 cn10 inequality equivalent inequality ann assumechoosing satisfy inequality note special constant replace integer strictly greater choose worstcase running time select linear comparison sort select randomizedselect determine relative order elements comparing elements recall chapter sorting requires lg time comparison model average problem lineartime sorting algorithms chapter assumptions input contrast lineartime selection algorithms chapter require assumptions input subject lg lower bound manage solve selection problem sorting running time linear algo rithms sort lineartime behavior result assumptions input case sorting algorithms chapter sorting requires lg time comparison model average problem method sorting ndexing presented introduction chapter asymptotically inefficient exercises algorithm select input elements divided groups algorithm work linear time divided oups argue select linear time groups exercises analyze select n4 elements greater medianofmedians n4 elements exercises quicksort lg time worst case exercises suppose algorithm comparisons ith smallest element set elements smaller elements larger elements performing additional comparisons exercises suppose blackbox worstcase lineartime median subroutine simple lineartime algorithm solves sele ction problem arbitrary order statistic exercises kth quantiles nelement set order statistics divide sorted set equalsized sets lg ktime algorithm list kth quantiles set exercises ontime algorithm set distinct numbers positive integer determines numbers closest median exercises arrays numbers sorted order olg ntime algorithm median elements arrays exercises professor olay consulting oil comp planning large pipeline running east west oil field wells spur pipeline connected directly main pipeline shortest path north south figure ycoordinates wells shoul professor pick optimal location main pipeline mini mizes total length spurs optimal location termined linear time figure professor olay determine position eastwest oil pipeline minimizes total length northsouth spurs problems largest nu mbers sorted order set numbers largest sorted order comparison based algorithm algorithm implem ents methods asymptotic worstcase running time analyze running times algorithms terms sort numbers list largest build maxpriority queue numbers extractmax times orderstatistic algorithm ith largest number partition number sort largest numbers problems weighted median distinct elements positive weights w1 w2 wn weighted lower median element satisfying argue median weighted median weights compute weighted median elements lg worstcase time sorting compute weighted median worstcase time linear time median algorithm select postoffice location problem defined points weights w1 w2 wn point input points minimizes sum distance points argue weighted median solution dimensional postoffice location problem points simply real numbers distance points solution dimensiona postoffice location problem points coordinate pairs distance points y1 manhattan distance y1 problems small order statistics worstcase number comparisons select select ith order statistic numbers satisfy constant hidden notation large small relative implement procedure select subroutine fewer comparisons worst case algorithm uin comparisons ith smallest elements hint disjoint pairwise compar isons recurse set smaller element pair uin lgni constant uin olg nk uin nk lg assumption numbers distinct greater concerned equality chapter notes worstcase lineartime medi anfinding algorithm devised blum floyd pratt rivest tarjan fast averagetime version hoare floyd rivest developed improved averagetime version partitions element recursively selected small sample elements unknown comparisons needed determine median lower bound comparisons median finding bent john upper bound schonhage paterson pippenger dor zwick improved bounds eir upper bound lower bound paterson describes work iii data structures chapter list chapter elementary data structures chapter hash tables chapter binary search trees chapter redblack trees chapter augmenting data structures introduction sets fundamental computer scie nce mathematics mathematical sets unchanging sets manipulated algorithms grow shrink change time sets dynamic chapters basic techniques representing finite dynami sets manipulating computer algorithms require types operations performed sets algorithms ability insert elements delete elements test membership set dynamic supports operations called dictionary algorithms require complicated operations minpriority queues introduced chapter context heap data structure support operations inserting element extracting smallest element set implement dynamic set depends operations supported elements dynamic set typical implementation dynamic set element represen ted object fields examined manipulated pointer object discusses implementation objects inters programming environments basic data types kinds dynamic sets assume objects fields identifying key field keys dynamic set set key values object satellite data carried object fields unused set implementation fields manipulated set operations fields data pointers objects set dynamic sets presuppose keys awn totally ordered set real numbers set ual alphabetic ordering totally ordered set satisfies trichotomy property defined total ordering define minimum element set eak element larger element set operations dynamic sets operations dynamic set grouped categories queries simply return set modifying operations change set list typical operations specific application require implemented searchs query set key returns pointer element keyx nil element belongs inserts modifying operation augments set element pointed assume fields element needed set implementation initialized deletes modifying operation pointer element set removes note operation pointer element key minimums query totally ordered set returns pointer element smallest key maximums query totally ordered set returns pointer element largest key successors query element key totally ordered set returns pointer larger element nil maximum element predecessors query element key totally ordered set returns pointer smaller element nil minimum element queries successor predecessor extended sets nondistinct keys set keys normal presumption minimum calls successor enumerates elements set sorted order time execute set operation usua lly measured terms size set arguments chapter describes data structure support operations listed set size time olg overview iii chapters œ14 data structures implement dynamic sets construct efficient algorithms variety problems data structurešthe heapšhas introduced chapter chapter presents essentials working simple data structures stacks queues linked lists rooted trees objects pointers implemented programming environments support primitives material familiar introductory programming chapter introduces hash tables support dictionary operations insert delete search worst case hashing requires time perform search operation expected time hashtable operations o1 analysis hashing relies probability chapter requires background subject binary search trees covered chapter support dynamicset operations listed worst case operation takes time tree elements randomly built binary search tree expected time operation olg binary search trees serve basis data structures redblack trees variant binary search trees introduced chapter ordinary binary search trees redblack trees guaranteed perform operations olg time worst case redblack tree balanced search tree chapter presents kind balanced search tree called btree mechanics redblack trees intricate glean properties chapter studying mechanics neverthele walking code instructive chapter augment redblack ees support operations basic listed augment dynamically maintain order statistics set keys augment maintain intervals real numbers chapter elementary data structures chapter examine representation dynamic sets simple data structures pointers complex data struct ures fashioned pointers redimentary stacks ues linked lists rooted trees discuss method objects point ers synthesized arrays stacks queues stacks queues dynamic sets whic element removed set delete operation prespecified stack element deleted set inserted stack implements lastin firstout lifo policy queue element deleted set longest time queue implements firstin fifo policy efficient ways implement stacks queues computer simple array implement stacks insert operation stack called push delete operation element argument cal led pop names allusions physical stacks spring loaded stacks plates cafeterias order plates popped stack reverse order pushed stack plate accessible figure implement stack elements array s1 array attribute tops indexes recen tly inserted element stack consists elements s1 tops s1 element stack stops element figure array implementation stack stack elements lightly shaded positions stack elements element stack calls pushs pushs stack pops returned element pushed ement appears array longer stack element tops stack elements stack tested emptiness query operation stackempty stack popped stack underflows error tops exceeds stack overflows pseudocode implementation dont worry stack overflow stack operations implemented lines code stackemptys tops return true return false pushs tops tops stops pops stackemptys error underflow tops tops return stops figure effects modifying operations push pop stack operations takes o1 time queues insert operation queue enqueue delete operation dequeue stack operation pop dequ eue takes element argument fifo property queue operate people registrars office queue head tail element enqueued ta kes place tail queue newly arriving student takes place element dequeued head queue student head waited longest fortunately dont worry computational elements cutting figure implement queue elements array q1 queue attribute headq indexes points head attribute tailq indexes location newly arriving element inserted queue elements queue locations headq head tailq wrap sense location location circular order headq tail queue initially headq tailq queue attempt dequeue element queue underflow headq tailq queue attempt enqueue element queue overflow figure queue implemented array q1 queue elements lightly shaded positions queue elements locations q7 configuration queue calls enqueue enqueueq enqueueq configuration queue dequeueq returns key head queue head key procedures enqueue dequeue error checking underflow overflow exercise asks supply code checks error conditions enqueueq qtailq tailq lengthq tailq tailq tailq dequeueq qheadq headq lengthq headq headq headq return figure effects enqueue dequeue operations operation takes o1 time exercises figure model illustrate result operation sequence push pushs pushs pops pushs pops initially stack stored array s1 exercises explain implement stacks array stack overflows total number ements stacks push pop operations o1 time exercises figure model illustrate result operation sequence enqueueq enqueueq enqueue dequeueq enqueue dequeue initially queue stored array q1 exercises rewrite enqueue dequeue detect underflow overflow queue exercises stack insertion deletion elements queue insertion deletion deque doubleended queue insertion deletion ends write o1time procedures insert elements delete elements ends deque constructed array exercises implement queue acks analyze running time queue operations exercises implement stack ues analyze running time stack operations linked lists linked list data structure objects arranged linear order array linear order determined array indi ces order linked list determined pointer ject linked lists provide simple flexible representation dynamic sets supporting hough efficiently operations listed figure element doubly linked list object key field pointer fields prev object cont satellite data element list nextx points successor linked list prevx points predecessor prevx nil element predecessor element head list nextx nil element successor element tail list attribute headl points element list headl nil list figure doubly linked list representing dynamic set element list object fields key pointers arrows previous objects field tail prev field head nil diagonal slash attribute headl points head execution listinsertl keyx linked list object key head object points head key result subsequent listdeletel points object key list forms singly linked doubly linked sorted circular list singly linked omit prev pointer element list sorted linear order list corresponds linear order keys stored elemen list minimum element head list maximum element tail list unsorted elements order circular list prev pointer head list points tail pointer tail list points head list viewed ring elements remainder assume lists working unsorted doubly linked searching linked list procedure listsearch finds element key list simple linear search returning pointer element object key appears list nil returned linked list figure listsearch returns pointer ement listsearch returns nil listsearchl headl nil keyx nextx return search list objects listsearch procedure takes time worst case search entire list inserting linked list element key field set listinsert procedure splices linked list figure listinsertl nextx headl headl nil prevheadl headl prevx nil running time listinsert list elements o1 deleting linked list procedure listdelete removes element linked list pointer splices list updating pointers delete element key listsearch retrieve pointer element listdeletel prevx nil nextprevx nextx headl nextx nextx nil prevnextx prevx figure element deleted linked list listdelete runs o1 time delete element key time required worst case listsearch sentinels code listdelete simpler ignore boundary conditions head tail list listdelet nextprevx nextx prevnextx prevx sentinel dummy object simplify boundary conditions suppose provide list object nil represents nil fields list elements ference nil list code replace reference sentinel nill figure turns regular doubly linked list circular doubly linked list sentinel sentinel nil head tail field nextnill points head list prevnill points tail field tail prev field head point nill nextnill points head eliminate attribute headl altogether replacing referenc references nextnill lis consists sentinel nextnill prevnill set nill figure circular doubly linked list sentinel sentinel nil appears head tail attribute headl longer needed access head list nill list linked list figure key head key tail list executing listinser keyx object head list list deleting object key tail object key code listsearch remains references nil headl changed listsearcl nextnill nill keyx nextx return twoline procedure listdelet delete element list procedure insert element list listinser nextx nextnill prevnextnill nextnill prevx nill figure effects listinser listdelet sample list sentinels rarely reduce asymptotic time boun data structure operations reduce constant factors gain sentinels loops matter clarity code speed linked lis code simplified sentinels save o1 time listinser listdelet procedures situations sentinels helps tighten code loop reducing coefficient running time sentinels indiscriminately small lists extra storage sentinels represent wasted memory book sentinels simplify code exercises dynamicset operation insert implemented singly linked list o1 time delete exercises implement stack singly linked list operations push pop o1 time exercises implement queue singly linked list operations enqueue dequeue o1 time exercises written loop iteration listsearc procedure requires tests nill keyx eliminate test nill iteration exercises implement dictionary operations insert delete search singly linked circular lists unning times procedures exercises dynamicset operation union takes disjoint sets s1 input returns set s1 consisting elements s1 sets s1 destroyed operation support union o1 time suitable list data structure exercises ntime nonrecursive procedure reverses singly linked list elements procedure constant storage needed list exercises explain implement doubly linked lists pointer npx item usual prev assume pointer values interpreted kbit integers define npx npx nextx xor prev kbit exclusiveor nextx prevx nil represented needed access head list impl ement search insert delete operations list reverse list o1 time implementing pointers objects implement pointers objects langua ges fortran provide ways implementing linked data structures explicit pointer data type synthe size objects pointers arrays array indices multiplearray representation objects represent collection objects fields array field figure impl ement linked list figure arrays array key holds values keys dynamic set pointers stored arrays prev array keyx nextx prevx represent object linked list interpretation pointer simply common key prev arrays figure linked list figure represented arrays key prev vertical slice arrays represents single object stored pointers correspond array indices arrows interpret lightly shaded object positions list elements variable head figure object key object key linked list figure key appears key2 key appears key5 next5 prev2 constant nil appears field tail prev field head integer represent actual arrays variable holds head list pseudocode square brackets denote indexing array selection field attribute object meanings keyx nextx prevx consistent implementation practice singlearray representation objects computer memory typi cally addressed integers suitably large integer programming nguages object occupies contiguous set locations computer memory pointer simply address memory location object othe memory locations object indexed adding offset pointer strategy implementi objects programming environments provide explicit pointer data types figure single array store linked list figures object occupies contiguous subarray field object corresponds offset range pointer object figure offsets key prevrespectivel read previ pointer add pointer offset reading ai figure linked list figures represented single array list element object occupies conti guous subarray length array fields key prev correspond offsetspointer object element object objects list elements lightly shaded arrows list ordering singlearray representation flexible permits object lengths stored array problem mana ging heterogeneous collection objects difficult problem managi homogeneous collection objects fields data structures composed homogeneous elements sufficient purposes multiplearray representation objects allocating freeing objects insert key dynamic set represente doubly linked list allocate pointer unused object linkedlist representation manage storage objects linkedlist representation allocated systems garbage collector responsible determining objects unused applications simple bear responsibility returning unused object storage manager explore problem allocating freei deallocating homogeneous objects doubly linked list represented multiple arrays suppose arrays multiplearray representation length moment dynamic set elements objects represent elements dynamic set remaining mœn objects free free objects represent elements inserted dynamic set future free objects sing ly linked list free list free list array stores pointers list head free list held global variable free dynamic set represented linked list nonempty free list intertwined list figure note object representation list free list figure allocateobject freeobject procedures list figure lightly shaded free list heavily shaded arrows freelist structure result calling allocateobject returns setting key4 calling listinsertl freelist head object next4 free list executing listdeletel freeobject5 object freelist head object free list free list stack object allocated freed list implementation stack ope rations push pop plement procedures allocating freeing objects assume global variable free procedures points element free list allocateobject free nil error space free free nextx return freeobjectx nextx free free free list initially unallocated objects free list exhausted allocateobject procedure signals error common single free list service linked lists figure linked lists free list intertwined key prev arrays figure linked lists l1 lightly shaded heavily shaded free list darkened intertwined procedures o1 time practical modified work omogeneous collection objects letting fields object field free list exercises draw picture sequence stored doubly linked list multiplearray representation singlearray representation exercises write procedures allocateobject freeobject homogeneous collection objects implemented singlearray representation exercises dont set reset prev fields objects implementation allocateobject freeobject procedures exercises desirable elements doubly linked list compact storage locations multiplearray representation case paged virtualmemory computing environmen explain procedures allocate object freeobject implemented representation compact assume pointers elements linked list list hint array implementation stack exercises doubly linked list length stored arrays key prev length suppose arrays manage allocateobject freeobject procedures doubly linked free list suppose items list nm free list write procedure compactifylist list free list moves items occupy array positions adjusts free list remains correct occupying array positions running time procedure constant extra space car eful argument correctness procedure representing rooted trees methods representing lists previous extend homogeneous data structure problem representing rooted trees linked data structures nary trees method rooted trees nodes arbitrary number children represent node tree object linked lists assume node key field remaining fields pointers nodes vary type tree binary trees figure fields left store pointers parent left child child node binary tree px nil root node left child leftx nil child root entire tree pointed attribute roott roott nil tree figure representation binary tree node fields px leftx lower left rightx lower key fields rooted trees unbounded branching scheme representing binary tree extended class trees number children node constant replace left fields child1 child2 childk scheme longer works number children node unbounded fields arrays multiplearray representation allocate advance number children bounded large constant nodes sma number children waste lot memory fortunately clever scheme binary trees represent trees arbitrary numbers children advantage space nnode rooted tree leftchild rightsibling representation figure node parent pointer roott points root tree pointer children node pointers figure leftchild rightsibling representation tree node fields px leftchild lower left rightsiblingx lower keys leftchild points leftmost child node rightsiblingx points sibling node children leftchild nil node rightmost child parent rightsiblingx nil tree representations represent rooted trees ways chapter represented heap based complete binary tree single array trees chapter traversed root parent pointers pointers children schemes scheme depends application exercises draw binary tree rooted represented fields key leftnilnil nil nil nil nil nil nil nil nil exercises write ontime recursive procedure nnode binary tree prints key node tree exercises write ontime nonrecursive proce dure nnode binary tree prints key node tree stack auxiliary data structure exercises write ontime procedure prints arbitrary rooted tree nodes tree stored leftchild rightsibling representation exercises write ontime nonrecursive proce dure nnode binary tree prints key node constant extr space tree modify tree tempor arily procedure exercises leftchild rightsibling representation arbitrary rooted tree pointers node leftchild rightsibling parent node parent reached identified constant time children reached identified time linear number children onl pointers boolean node parent node children reached identified time linear number children problems comparisons lists types lists followi table asymptotic worstcase running time dyna micset operation listed unsorted singly linked sorted singly linked unsorted doubly linked sorted doubly linked searchl insertl deletel successorl predecessorl minimuml maximuml problems mergeable eaps linked lists mergeable heap supports operations makeheap creates mergeable heap insert minimum extractmin union implement mergeable heaps linked lists cases operation efficient analyze running time operation terms size dynamic sets operated lists sorted lists unsorted lists unsorted dynamic sets merged disjoint problems searching sorted compact list exercise asked maintain nelement list compactly positions array assume keys distinct compact list sorted keyi keynexti nexti nil assumptions randomized algorithm search list expected time compactlistsearchl headl nil keyi random1 keyi key keyj keyi return nexti nil keyi return nil return ignore lines œ7 procedure ordinary algorithm searching sorted linked list points position list turn search terminates falls list keyi case keyi key keyi key terminating search thing lines œ7 attempt skip ahead randomly chosen position skip beneficial keyj larger keyi larger case marks position list reach ordinary list search list compact choice indexes object list slot free list analyzing performance compactlistsearch directly analyze algorithm compactlistsearc executes separate loops algorithm takes additional parameter determines upper bound number iterations loop compactlistsearc headlrandom1 keyi keyj keyj keyi return nil keyi nexti nil keyi return nil return compare execution algorithms compactlistsearch compactlistsearcl assume sequence integers returned calls random1 algorithms suppose compactlistsearchl takes iterations loop lines œ8 argue compactlistsearc returns answer total number iterations loops compact listsearc compactlistsearc random variable describes distance linked list chain pointers position desired key iterations loop lines œ7 occurred argue expected running time compactlistsearcl hint equation c24 prove compactlistsearcl runs otnt expected time conclude compactlistsearch runs expected time assume keys stinct compactlistsearch argue random skips asymptotically list repeated key values defined mergeable eap support minimum extractmin refer mergeable minheap alternatively supported maximum extractmax mergeable maxheap chapter notes aho hopcroft ullman knuth excellent references elementary data structures texts cover basic data structures implementation programming language examples types textbooks include goodrich tamassia main shaffer weissgonnet experimental data performanc data structure operations origin stacks queues data structures computer science unclear notions existed mathematics pa perbased business practices introduction digital computers knuth cites turing development stacks subroutine linkage pointerbased data structures folk knuth pointers early computers drum memories language developed hopper represented algebraic formulas binary trees knuth credits iplii language developed newell shaw simon recognizing promoting pointers ipliii language developed included explicit stack operations chapter hash tables overview applications require dynamic set supports dictionary operations insert search delete compiler computer language maintains symbol table keys elements arbitrary character strings correspond identifiers language hash table effective data structure implementing dictionaries searching element hash table long searching element linked listš time worst casešin practice hashing performs extremely reasonable assu mptions expected time search element hash table o1 hash table generalization simpler notion ordinary array directly addressing ordinary array effective ability examine arbitrary position array o1 time discusses direct addressing direct addressing applicable afford allocate array position key number keys stored smal relative total number keys hash tables effective alternative directly addressing array hash table typically array size proportional number keys stored key array directly array computed key presents main ideas focusing chaini handle collisions key maps array describes array indices computed keys hash functi ons analyze variations basic theme open addressing deal collisions hashing extremely effective practical technique basic dicti onary operations require o1 time average explains perfect hashing support searches o1 worstcase time set keys stored static set keys stored directaddress tables direct addressing simple technique works universe keys small suppose application dynamic set element key drawn universelarge assume elements key represent dynamic set array directaddress table denoted t0 position slot corresponds key universe figure illustrates approach slot points element set key set element key tk nil figure implementing dynamic set directaddress table key universecorresponds table set actual keys determines slots tabl pointers elements slots heavily shaded nil dictionary operations trivial implement directaddresssearcht return directaddressinsertt tkeyx directaddressdeletet tkeyx nil operati ons fast o1 time required applications elements dyna mic set stored directaddress table storing elem ents key satellite data object external directaddress table pointer slot table object store object slot saving space unnecessary store key field object object table key keys stored slot exercises suppose dynamic set represented directaddress table length procedure finds maximum element worstcase performance procedure exercises bit vector simply array bits bit vector length takes space array pointers bit vector represent dynamic set distinct elements satellite data dictionary operations o1 time exercises implement directaddress table keys stored elements distinct elements satellite data thr dictionary operations insert delete search o1 time dont forget delete takes argument pointer object deleted key exercises implement dictionary direct addressing huge array start array entries garbage initia lizing entire array impractical size scheme implemen ting directaddress dictionary huge array stored object o1 space operations search insert delete o1 time initialization data structure o1 time hint additional stack size number keys stored dictionary determine entry huge arra valid hash tables difficulty direct addressing obvious universe large storing table size impractical impossible memory typical computer set keys stored small relative space allocated wasted set keys stored dictionary smaller universe keys hash table requires storage directaddress table storage requirements reduced maintain benefit searching element hash table requires o1 time catch bound average time direct addressing holds worstcase time direct addressing element key stored slot hashing element stored slot hk hash function compute slot key maps universe keys slots hash table t0 element key hashes slot hk hk hash key figure illustrates basic idea point hash function reduce range array indices handled values handle values storage requirements correspondingly reduced figure hash function map keys hashtable slots keys k2 k5 map slot collide hitch keys hash slot situation collision fortunately effective techniques resolving conflict created collisions ideal solution avoid collisions altogether achieve goal choosing suitable hash function idea random avoiding collisions minimizing number term hash evoking images random mixing chopping captures spirit approach hash function deterministic input produce output hk tw keys hash avoiding collisions altogether ther efore impossible welldesigned randomlooking hash function minimize number collisions method resolving llisions occur remainder presents simplest collision resolution technique called chaining introduces alternative method resolving collisions called open addressing collision resolution chaining chaining elements hash slot linked list figure slot pointer head list stored elements hash elements slot nil figure collision resolution chaining hashtable slot linked list keys hash hk1 hk4 hk5 hk2 hk7 dictionary operations hash table easy implement collisions resolved chaining chainedhashinsertt insert head list thkeyx chainedhashsearcht search element key list thk chainedhashdeletet delete list thkeyx worstcase running time insertion o1 insertion procedure fast assumes element inserted table assumption checked ditional cost perfor ming search insertion searching worstcase running time proportiona length list analyze operation osely deletion element accomplished o1 time lists doubly li nked note chainedhashdelete takes input element key dont search lists singly linked great input element key list thkeyx link predecessor properly set splice case deletion searching essentially running time analysis hashing chaining hashing chaining perform long search element key hash table slots stores elements define load factor nm average number elements stored chain analysis terms equal greater worstcase behavior hashing chaining terrible keys hash slot creating list length worstcase time searching time compute hash functionšno linked list elements hash tables worstcase performance perfect hashing provide good worstcase performance set keys static average performance hashing depends hash function distributes set keys stored slots average discusses issues assume elemen equally hash slots independently element hashed assumption simple uniform hashingdenote length list average enj nm assume hash hk computed o1 time time required search element key depends linearly length nhk list thk setting o1 time required compute hash function access slot hk expected number elements amined search algorithm number elements list thk checked keys equal cases search unsuccessful element table key search finds element key theorem hash table collisions reso lved chaining unsuccessful search takes expected time assumption simple uniform hashing proof assumption simple uniform hashing key stored table equally hash slots expected time search unsuccessfully key expected time search list thk expected length nhk expected number elements examined unsuccessful search total time required luding time computing hk situation successful search list equally searched probability list searched proportional number elements expected search time theorem hash table collisions reso lved chaining successful search takes time average assumption simple uniform hashing proof assume element searched equally elements stored table number elements examined successful search element number elements list elements list inserted inserted elements list expected numbe elements examined average elements table expected number elements list list denote ith element inserted table ki keyxi keys ki define indicator random variable xij ihki hkj assumption simple uniform hashing hki hkj lemma exij expected number elements examined successful search total time required successful search including time computing hash functionanalysis number hashtable slots proportional number elements table nm omm o1 searching takes constant time average insertion takes o1 worstcase time deletion takes o1 worstcase time list doubly linked dictionary operations supported o1 time average exercises suppose hash function hash distinct keys array length assuming simple uniform hashing expected number collisions precisely expected cardinality hk hl exercises demonstrate insertion keys hash table collisions resolved chaining table slots hash function hk mod exercises professor marley hypothesizes substantial performance gains modify chaining scheme list sorted order professors modification affect running time successful searches unsuccessful searches insertions deletions exercises storage elements allocated deallocated hash table linking unused slots free list assume slot store flag element pointer poi nters dictionary freelist operations o1 expected time free list doubly linked singly linked free list suffice exercises nm subset size consisting keys hash slot worstcase search ing time hashing chaining hash functions discuss issues rega rding design good hash functions schemes creation schemes hashing division hashing multiplication heuristic nature scheme universal hashing randomization provide provably good performance good hash function good hash function satisfies assumption simple uniform hashing key equally hash slots independently key hashed typically check condition rarely probability distribution keys drawn keys drawn independently occasionally distribution exam ple keys random real numbers independently uniformly distributed range hash function hk satisfies condition simple uniform hashing practice heuristic chniques create hash function performs qualitative distribution keys design process compilers symbol table keys character strings representing identifiers ogram closely symbols pts occur program good hash function woul minimize chance variants hash slot good approach derive hash expected independent patterns exis data division method discussed computes hash remainde key divided prime number method frequently goo assuming prime number chosen unrelated patterns distribution keys finally note applications ha sh functions require stronger properties provided simple uniform hashing keys close sense yield hash values property desirable linear probing defined universal hashing desired properties interpreting keys natural numbers hash functions assume universe keys setnatural numbers keys natural numbe interpret natural numbers character string interpreted integer expressed suitable radix notation identifier interpreted pair integers ascii character set expressed radix128 integer ually straightforward application devise method interpreting key large natural number assume keys natural numbers division method division method creating hash functions map key slots remainder divided hash function hk mod hash table size key hk requires single division operation hashing division fast division method avoid values power hk lowestorder bits loworder pbit patterns equally hash function depend bits key exercise asks choosing character string interpreted radix poor choice permuting characters change hash prime close exact power good choice suppose allocate hash table collisions resolved chaining hold roughly character strings character bits dont mind examining average elements unsuccessful searc allocate hash table size number chosen prime ear power treating key integer hash function hk mod multiplication method multiplication method creating hash functions operates steps multiply key constant range extract fractional ka multiply floor result short hash function hk mka mod mod fractional ka ka ka advantage multiplicati method critical typically choose power integer easily implement function computers uppose word size machine bits fits single word restrict fraction form s2w integer range referring figure multiply wbit integer result wbit r12w r0 r1 highorder word product r0 loworder word product desired pbit hash consists bits r0 figure multiplication method hashing wbit representati key multiplied wbit highestorder bits lower wbit half product form desired hash hk method works constant works values optimal choice pends characteristics data hashed knuth suggests work suppose adapting knuths suggestion choose fraction form s232 closest r1 r0 bits r0 yield hk universal hashing malicious adversary chooses keys hashed fixed hash function choose keys hash slot yielding average retrieval time fixed hash function vulnerable terrible worstcase behavior effective improve situation choose hash function randomly independent keys stored approach called universal hashing yield provably good performance aver age matter keys chosen adversary main idea universal hashing select hash function random carefully designed class functions execution case quicksort randomization guarantees sing input evoke worstcase behavior randomization algorithm behave differently execution input guarant eeing good averagecase performance input returning compilers symbol table programmers choice identifiers consistently poor hashing performance poor performance occurs compiler hooses random hash function set identifiers hash probability situation occurring small set identifiers size finite collection hash functions map universe keys rangecollection universal pair distinct keys number hash functions hk hl hash function randomly chosen chance collision distinct keys chance collision hk hl randomly independently chosen settheorem universal ass hash functions good averagecase behavior recall denotes length list theorem suppose hash function chosen universal coll ection hash functions hash keys table size chaining resolve collisions key table expected length nhk list key hashes key table expected length enhk list key proof note expectations ov choice hash function depend assumptions distribution keys pair distinct keys define indicator random variable xkl ihk hl definition single pair keys collides probability prhk hl lemma implies xkl define key random variable yk equals number keys hash slot remainder proof depends key table nhk yk enhk yk nm key appears list thk count yk include key nhk yk enhk eyk corollary universal hashing desired payoff impossible adversary pick sequen operations forces worstcase running time cleverly randomizing choice hash function time guarantee sequence operations handled good expected running time corollary universal hashing collision resolution chaining table slots takes expected time handle sequence insert search delete operations insert operations proof number insertions o1 insert delete operations constant time theorem expected time search operation o1 linearity expectation expected time entire sequence operations designing universal class hash functions easy design universal class hash functions littl number theory prove consult chapter unfamilia number theory choosing prime number large key range inclusive zp denote setdenote setprime solve equations modulo methods chapter assume size universe keys greater number slots hash table hav define hash function hab zp linear transformation reductions modulo moduloh34 family hash functions hash function hab maps zp zm class hash functions nice property size output range arbitraryšnot primeša feature choices choices hash functions theorem class hash functions defined equations universal proof distinct keys zp hash function hab ak mod mod note observe ak mod prime nonzero modulo product nonzero modulo theorem computation hab distinct inputs map distinct values modulo collisions mod level choices pair yields pair solve sk l1 mod mod ak mod l1 mod denotes unique multiplicative inverse modulo pairs onetoone correspondence pairs pairs pair inputs pick uniformly random pair equally pair distinct values modulo probability distinct keys collide equal probability mod randomly chosen distinct values modulo remaining values number values mod inequality probability collides reduced modulo pair distinct values zp prhab hab universal exercises suppose search linked list length element key hash hk key long character string advantage hash values searching list element key exercises suppose string characters hashed slots treating radix128 number division method number easily represented bit computer word string characters treated radix128 number takes apply division method compute hash character string constant number rds storage string exercises version division method hk mod character string interpreted radix string derived string permuting characters hash application property undesirable hash function exercises hash table size hash function hk mk mod compute locations keys mapped exercises define family hash functions finite set finite set universal pairs distinct elements hk hl probability drawing hash function random family universal family hash functions exercises set ntuples values drawn zp zp prime define hash function hb zp input ntuple a0 an1 hb zp argue puniversal definition universal exercise hint exercise open addressing open addressing elements stored hash table table entry element dynamic set nil searching element systematically examine table slots desi red element clear element table lists elements stored table chaining open addressing hash table insertions load factor exceed store linked lists chaining inside hash table unused hashtable slots exercise advantage open addressing avoids pointers altogether pointers compute sequence slots examined extra memory freed oring pointers hash table larger number slots memory yielding fewer collisions faster retrieval perform insertion open addr essing successively examine probe hash table slot key fixed orderrequires search time sequence positions probed depends key inserted determine slots probe extend hash function include probe number starting input hash function open addressing require key probe sequence hk0hk1 hkm permutationhashtable position eventually considered slot key table fills pseudocode assume elements hash table keys satellite key identical element key slot key nil slot hashinserttrepeat hk nil return error hash table overflow algorithm searching key probes sequence slots insertion algorithm examined key inserted search terminate unsuccessfully nds slot inserted probe sequence argument assumes keys deleted hash table procedure hashsearch takes input hash table key returning slot key nil key table hashsearchtrepeat hk returnnil return nil deletion openaddress hash table difficult delete key slot simply mark slot storing nil ing impossible retrieve key insertion probed slot occupied solution mark slot storing special deleted nil modify procedure hashinsert treat slot key inserted modification hashsearch needed pass deleted values searching special deleted search times longer dependent load factor reason chaining commonly selected collis ion resolution technique keys deleted analysis assumption uniform hashing assume key equally permutationsprobe sequence uniform hashing generalizes notion simp uniform hashing defined earlier situation hash unction produces single number probe sequence true uniform hashing difficult implement practice suitable approximations double hash ing defined techniques commonly compute probe sequences required open addressing linear probing quadratic probing double hashing techniques guarantee hk hk hk permutationkey techniques fulfills assumption uniform hashing capable generating probe sequences uniform hashing requires double ha shing greatest number probe sequences expect linear probing ordinary hash functionrefer auxiliary hash function method linear probing hash function hk hk modkey slot probed thk slot auxiliary hash function probe slot thk slot wrap slots t0 finally probe slot thk initial probe determines entire probe sequence distinct probe sequences linear probing easy implement suffers problem primary clustering long runs occupied slots build increasing average search time clusters slot preceded slots filled probability long runs occupied slots tend longer average search time increases quadratic probing quadratic probing hash function form auxiliary hash function auxiliary constantsinitial position probed thk positions probed offset amounts depend quadratic manner probe number method works linear probing hash table values constrained problem select parameters keys initial probe position eir probe sequences hk1 hk2 implies hk1 hk2 property leads ilder form clustering called secondary clustering linear probing initial probe determines entire sequence distinct probe sequences double hashing double hashing methods open addressing permutations produced charact eristics randomly chosen permutations double hashing hash function form hk h1k ih2k mod h1 auxiliary hash functions initial probe position th1k successive probe positions offset previous positions h2k modulo case linear quadratic probing probe sequence depends ways key initial probe position offset vary figure insertion double hashing figure insertion double hashing hash table size h1k mod h2k modmodmod key inserted slot slots examined occupied h2k prime hashtable size entire hash table searched exercise convenient ensure condition power design produces odd number prime design returns positive integer choose prime h1k mod h2k mod chosen h1k h2k probe position slot modulo examined key ound slot examined double hashing improves linear quadratic probing probe sequences h1k h2k pair yields distinct probe sequence result performance double hashing app ears close performance ideal scheme uniform hashing analysis openaddress hashing analysis open addressing analysis chaining expressed terms load factor nm hash table infinity open addressing element slot implies assume uniform hashing idealized scheme probe sequence hk hk hk insert search key equally permutationkey unique fixed probe sequence meant probability distribution space keys operation ha sh function keys probe sequence equally analyze expected number probe hashing open addressing assumption uniform hashing analysis number probes unsuccessful search theorem openaddress hash table load factor nm expected number probes unsuccessful search assuming uniform hashing proof unsuccessful search probe accesses occupied slot desired key slot probed define random variable number probes uns uccessful search define event ai event ith probe occupied slot event intersection events ai1 bound bounding ai1 exercise c26 ai1 pra1 ai1 ai2 elements slots nm probability jth probe occupied slot probes occupied slots probability finding remaining elements unexamined slots assumption uniform hashing probability ratio quantities observing implies jm nm equation c24 bound expected number probes bound intuitive interpretation probe probability probe finds occupied slot probe probability slots occupied probe constant theorem predicts unsu ccessful search runs o1 time hash table half erage number probes unsuccessful search percent average number obestheorem performance hashinsert procedure corollary inserting element openad dress hash table load factor requires probes average assuming uniform hashing proof element inserted room table inserting key requires unsuccessful search placement key slot expected number probes computing expected number probes successful search requires work theorem openaddress hash table load factor expected number probes successful search assuming uniform hashing assuming key table equally searched proof search key probe sequence element key inserted corollary key inserted hash table expected number probes search mm averaging keys hash table average number probes successful search ith harmonic number defined equation a7 technique bounding summation integral bound expected number probes successful search hash table half expected numbe probes successful search hash table percent expected number probes exercises inserting keys hash table length open addressing primary hash function hk mod illustrate result inserting keys linear probing quadratic probing double hashing h2k mod exercises write pseudocode hashdelete outlined text modify hashinsert handle special deleted exercises suppose double hashing resolve collisions hash function hk h1kih2k mod h2k greatest common divisor key unsuccessful search key examines dth hash table returning slot h1k h2k prime search examine entire hash table hint chapter exercises openaddress hash table uniform hashing upper bounds expected number probes unsuccessful search expected number probes successful search load factor exercises openaddress hash table load factor nonzero expected number probes unsuccessful search equals expected number probes successful search upper bounds theorems expected numbers probes perfect hashing hashing exce llent expected performance hashing excellent worstcase performance set keys static keys stored table set keys app lications naturally static sets keys set reserved programming language set file names cdrom hashing technique perfect hashing worstcase number memory accesses required perform search o1 basic idea create perf ect hashing scheme simple twolevel hashing scheme universal hashing level figure illustrates approach figure perfect hashing store setouter hash function hk ak mod mod h75 key hashes slot table secondary hash table stores keys hashing slot size hash table mj hash function mod mod mj h275 key stored slot secondary hash table collisions seco ndary hash tables searching takes constant time worst case level essentially hashing chaining keys hashed slots hash function carefully selected fami ly universal hash functions making list keys hashing slot small secondary hash table hash function choosing hash functions carefully guarantee collisions secondary level order guarantee collisions secondary level size mj hash table square number keys hashing slot quadratic dependence mj storage requirements excessive choosing level hash function expected total ount space hash functions chosen universal classes hash functions firstlevel hash function chosen class prime number greater key lue keys hashing slot rehashed secondary hash table size mj hash function chosen class proceed steps sha determine ensure secondary tables collisions expected memory overallšfor primary hash table secondary hash tablesšis theorem store keys hash table size hash function randomly chosen universal class hash functions probability collisions proof pairs keys collide eac pair collides probability chosen random universal family hash functions random variable counts number collisions expected number collisions note analysis analysis birthday paradox applying markovs inequality c29 prx completes proof situation theorem hash function chosen random collisions set keys hashed remember static easy collisionfree hash function random trials large hash table size excessive adopt twolevel hashing approach approach theorem hash entries slot outer firstlevel hash function hash keys slots keys hash slot secondary hash table size provide collisionfree constant time lookup turn issue ensuring memory size mj jth secondary hash table grows quadratically number keys stored risk storage excessive firstlevel table size memory primary hash table storage sizes mj secondary hash tables storage parameters defining secondary hash functions drawn classtheorem corollary provide bound expected combined sizes secondary hash tables corollary bounds probability combined size secondary hash tables superlinear theorem store keys hash table size hash function randomly chosen universal class hash functions number keys hashing slot proof start identity holds nonnegative integer evaluate summation observe total number collisions properties universal hashing expected summation corollary store keys hash table size hash function randomly chosen universal class hash functions set size secondary hash tableexpected storage required secondary hash tables perfect hashing scheme prooftheorem completes proof corollary store keys hash table size hash function randomly chosen universal class hash functions set size secondary hash tableprobability total storage secondary hash tables exceeds proof apply markovs inequality c29 time inequality corollary testing randoml chosen hash functions universal family yield reasonable storage exercises suppose insert keys hash table size open addressing uniform hashing probability collisions occur enn12 hint equation argue exceeds probability avoiding collisions rapidly problems longestprobe bound hashing hash table size store items open addressing collision resolution assuming uniform hashing probability ith insertion requires strictly probes probability ith insertion requires lg probes random variable denote number probes required ith insertion lg random variable max denote maximum number probes required insertions prx lg expected length longest probe sequence olg problems slotsize bound chaining suppose hash table slots collisions resolved chaining suppose keys inserted table key equally hashed slot maximum number keys keys inserted mission prove olg nlg lg upper bound expected argue probability qk keys hash slot probability probability slot keys keys nqk stirlings approximation equation qk ekkk exists constant k0 clg lg lg conclude k0 lg lg lg argue conclude olg lg lg problems quadratic probing suppose key search hash table positionssuppose hash function mapping key space setsearch scheme compute hk set probe position desired key position terminate search set mod mod return step assume power scheme instance general quadratic probing scheme exhibiting constants equation prove algorithm examines table position worst case problems kuniversal ha shing authentication class hash functions maps universe keyskuniversal fixed sequence distinct keys chosen random sequence hx1 hx2 hxk equally mk sequences length elements drawnuniversal universal set ntuples values drawn zp zp prime ntuple a0 an1 values zp zp define hash function hab input ntuple x0 xn1 hab argue universal suppose alice bob agree secretly hash function hab universal family hash functions alice sends message bob internet authenticates message bob sending authentication tag hab bob checks pair receives satisfies hab suppose adversary intercepts route fool bob replacing pair pair argue probability adversary succeeds fooling bob accepting matter computing power adversary mj dont hash function slot choose hash function hab ak mod mod mj slot chapter notes knuth gonnet excellent references analysis hashing algorithms knuth credits luhn inventing hash tables chaining method resolving collisions time amdahl originated idea open addressing carter wegman introduced notion universal classes hash functions fredman komlós szemerédi developed perfect hashing scheme static sets presented extension method dynamic sets handling insertions deletions amortized expected time o1 dietzfelbinger chapter binary search trees overview search trees data structures support dynami cset operations including search minimum maximum predecessor successor insert delete search tree dictionary priority queue basic operations binary search tree time proportional height tree complete binary tree nodes operations lg worstcase time tree linear chain nodes operations worstcase time expected height randomly built binary search tree olg basic dynamicset operations tree lg time average practice gua rantee binary search ees built randomly variations binary search trees worstcase perfor mance basic operations guaranteed good chapter presents variation redblack trees height olg chapter introduces btrees good maintaining databases randomaccess secondary disk storage presenting basic properties binary search trees sections walk binary search tree print values sorted order search binary search tree minimum maximum element predecessor successor element insert delete binary search tree basic mathematical operties trees appendix binary search tree binary search tree organized suggests binary tree figure tree represented linked data structure node object addition key field satellite data node fields left point nodes left child child parent child parent missing field nil root node node tree parent field nil figure binary search trees node keys left subtree keyx keys subtree keyx binary search trees represent set values worstcase running time searchtree operations proportional height tree binary search tree nodes height efficient binary search tree height keys keys binary search tree stored satisfy binarysearchtree property node binary search tree node left subtree keyy keyx node subtree keyx keyy figure key root keysleft subtree larger keys subtree smaller property holds node tree key figure smaller key left subtree larger key subtree binarysearchtree prope rty print keys binary search tree sorted order simple recursive algorithm called inorder tree walk algorithm named key root subtree printed values left subtree subtree preorder tree walk prints root values subtree postorder tree walk prints root lues subtrees procedure print elements binary search tree inordertreewalk roott inordertreewalkx nil inordertreewalkleftx print keyx inordertreewalkrightx inorder tree walk prints keys binary search trees figure order correctness algorithm induction directly binarysearchtree property takes time walk nnode binary search tree initial procedure called recursively node treešonce left child child theorem formal proof takes linear time perform inorder tree walk theorem root nnode subtree inordertreewalk takes time proof denote time inordertr eewalk called root nnode subtree inordertreewalk small constant time subtree test nil t0 positive constant suppose inordertreewalk called node left subtree nodes subtree nodes time perform inordertree walk tk positive constant reflects time execute inordertreewalk exclusive time spent recursive calls substitution method proving dn t0 tk dn dn dn completes proof exercises set keysdraw binary search trees height exercises difference binarysearc htree property minheap property minheap property print keys nnode tree sorted order time explain exercises nonrecursive algorithm performs inorder tree walk hint easy solution stack auxiliary data structure complicated elegant solution stack assumes pointers tested equality exercises recursive algorithms perform preorder postorder tree walks time tree nodes exercises argue sorting elements takes lg time worst case comparison model comparisonbased algorithm onstructing binary search tree arbitrary list elements takes lg time worst case querying binary search tree common operation performed nary search tree searching key stored tree search operation binary search trees support queries minimum maximum successor predecessor examine operations supported time binary search tree height searching procedure search ode key binary search tree pointer root tree key treesearch returns pointer node key exists returns nil treesearch nil keyx return keyx return treesearchleftx return treesearchrightx procedure search root traces path downward tree figure node encounters compares key keyx keys equal search terminates smaller keyx search continues left subtree binarysearchtree property implies stored subtree symmetrically larger keyx search continues subtree nodes encountered recursion form path downward root tree running time treesearch height tree figure queries binary search tree search key tree follow path root minimum tree left pointers root maximum key pointers root successor node key node key minimum key subt ree node key subtree successor lowest ancestor left child ancestor case node key successor procedure written iterati vely unrolling recursion loop computers rsion efficient iterativetreesearchx nil keyx keyx leftx rightx return minimum maximum element binary search tree minimum left child pointers root nil encountered figure procedure returns pointer mini mum element subtree rooted node treeminimum leftx nil leftx return binarysearchtree property guarantees tree minimum correct node left subtree key subtree large keyx minimum key subtree rooted keyx node left subtree key subtree smaller keyx key left subtree larger keyx minimum key subtree rooted subtree rooted leftx pseudocode treemaximum symmetric treemaximumx rightx nil rightx return procedures time tree height treesearch sequence nodes encountered forms path downward root successor predecessor node binary search tree successor sorted order determined inorder tree walk keys distinct successor node node smallest key greater keyx structure binary search tree determine successor node comparing keys procedure returns successor node binary search tree exists nil largest key tree treesuccessorx rightx nil return treeminimum rightx px nil rightyreturn code treesuccessor broken cases subtree node nonempty successor leftmost node subtree calling treeminimum rightx successor node key figure node key hand exercise asks subtree node successor lowest ancestor left child ancestor figure successor node key node key simply tree encounter node left child parent accomplished lines œ7 treesuccessor running time treesuccessor tree height follow path tree follow path tree procedure treepredecessor symmetric treesucc essor runs time keys distinct define successor predecessor node node returned calls treesuccessorx treepredecessorx summary proved theorem theorem dynamicset operations search minimum maximum successor predecessor time binary sear tree height exercises suppose numbers binary search tree search number sequences sequence nodes examined exercises write recursive versions tree minimum treemaximum procedures exercises write treepredecessor procedure exercises professor bunyan thinks discovered remarkable property binary search trees suppose search key binary search tree ends leaf sets keys left search path keys search path keys search path professor bunyan claims keys satisfy smallest counterexample professors claim exercises node binary search tree children successor left child predecessor child exercises binary search tree keys distinct subtree node successor lowest ancestor left child ancestor recall node ancestor exercises inorder tree walk nnode binary search tree implemented finding minimum element tree treeminimum making n1 calls treesuccessor prove algorithm runs time exercises prove matter node start heighth binary search tree successive calls treesuccessor time exercises binary search tree keys distinct leaf node parent keyy smallest key larger keyx largest key smaller keyx insertion deletion operations insertion deletion dynamic set represented binary search tree change data structure modifi reflect change binarysearchtree property continues hold modifying tree insert element straightf orward handling deletion intricate insertion insert binary search tree procedure treeinsert procedure passed node keyz left nil rightz nil modifies fields inserted position tree treeinsertt nil roott nil keyz keyx leftx rightx pz nil roott tree keyz keyy lefty righty figure treeinsert works procedures treesearch iterativetreesearch treeinsert root tree traces path downward pointer traces path pointer maintained parent initialization loop lines œ7 pointers tree left depending comparison keyz keyx set nil nil occupies position place input item lines œ13 set pointers inserted figure inserting item key binary search tree lightly shaded nodes path oot position item inserted dashed link tree insert item primitive operations search trees procedure treeinsert runs time tree height deletion procedure deleting node binary search tree takes argument pointer procedure considers cases figure children modify parent pz replace nil child node single child splice making link child parent finally node children splice zs successor left child exercise replace zs key satellite data key satellite data figure deleting node binary search tree node removed depends children node lightly shaded children remove child splice children splice successor child replace zs key satellite data key satellite data code treedelete organizes cases differently treedeletet leftz nil rightz nil treesuccessorz lefty nil lefty righty nil px nil roott leftpy leftpy rightpy keyz keyy copy satellite data return lines œ3 algorithm determines node splice node input node child successor children lines œ6 set nonnil child nil children node spliced lines œ13 modifying pointers splicing complicated proper handling boundary conditions occur nil root finally lines œ16 successor node spliced key satellite data moved overwriting previous key satellite data node returned calling procedure recycle free list procedure runs time tree height summary proved theorem theorem dynamicset operations insert delete time binary search tree height exercises recursive version treeinsert procedure exercises suppose binary search tree constructed repeatedly inserting distinct values tree argue number nodes examined searching tree number nodes examined lue inserted tree exercises sort set numbers building binary search tree numbers treeinsert repeatedly insert numbers printing numbers inorder tree walk wh worstcase bestcase running times sorting algorithm exercises suppose data structure pointer node binary search tree suppose predecessor deleted tree procedure treedelete problem treedelete rewritten solve problem exercises operation deletion commutative sense deleting binary search tree leaves tree deleting argue counterexample exercises node treedelete children coul splice predecessor successor argued fair strategy equal priority predecessor successor yields empirical perf ormance treedelete changed implement fair strategy randomly built binary search trees basic operations binary search tree time height tree height binary search tree varies items inserted deleted items inserted strictly increasing order tree chain height hand exercise b54 lg quicksort behavior average case closer case worst case average height binary search tree insertion deletion create tree created insertion analysis tractable define randomly built binary search tree keys arises inserting keys random order initially tree permutations input keys equally exercise asks notion assuming binary search tree keys equally expected height randomly built binary search tree keys olg assume keys distinct start defining random variables measure height randomly built binary search tree denote height randomly built binary search keys define exponential height build binary search tree keys choose key root denote random variable holds keys rank set keys equally element set left subtree root randomly built binary search tree keys subtree randomly built binary search tree keys height binary tree larger heights subtrees root exponential height binary tree larger exponential heights subtrees root yn max yi1 yni base cases y1 exponential height tree nodeconvenience define y0 define indicator random variables zn1 zn2 znn zni irn equally element prrn lemma zni yn polynomial ultimately imply olg indicator random variable zni irn independent values yi1 yni chosen left subtree exponential height yi1 randomly built keys ranks subtree randomly built binary search tree keys number keys subtrees structure choice random variables yi1 zni independent likewise subtree exponential height yni randomly built keys ranks greater structure independent random variables yni zni independent term y0 y1 eyn1 appears summation eyi1 eyni recurrence substitution method positive integers recurrence solution identity exercise asks prove identity base case verify bound holds substitution bounded eyn ultimate goal bound exercise asks function fx convex apply jensens inequality c25 derive logarithms sides olg proven theorem expected height randomly built binary search tree keys olg exercises prove equation exercises binary search tree nodes average depth node tree lg height tree wlg asymptotic upper bound height nnode binary search tree average depth node lg exercises notion randomly chosen binary search tree keys binary search tree keys equally chosen notion randomly built binary search tree hint list possibilities exercises function fx convex exercises randomizedquicksort operating sequence input numbers prove constant o1nk input permutations yield lg running time problems binary search trees equal keys equal keys pose problem imple mentation binary search trees asymptotic performance treeinsert insert items identical keys ini tially binary search tree propose improve treeinsert sting keyz keyx testing keyz keyyif equality holds implement strategies strategy asymptotic performance inserting items identical keys initially binary search tree strategies compare keys substitute arrive strategies boolean flag node set leftx rightx based alternates false true time visited insertion node key list nodes equal keys insert list randomly set leftx rightx worstcase performance informally derive averagecase performance problems radix trees strings a0a1ap b0b1bq ai ordered set characters string lexicographically string exists integer min ai ai bit strings rule lettingrule orde ring englishlanguage dictionaries radix tree data structure figure stores bit strings searching key a0a1ap left node depth ai ai set distinct binary strings lengths sum radix tree sort lexicographically time figure output sort sequence figure radix tree storing bit strings nodes key determined traversing path root node store keys nodes keys illustrative purposes nodes heavily shaded keys tree nodes establish path nodes problems average node depth randomly built binary search tree problem prove average pth node randomly built binary search tree nodes olg result weaker theorem technique reveals surprising simila rity buildin binary search tree running randomizedquicksort define total path length binary tree sum nodes depth node denote argue average depth node expected lg denote left subtrees tree argue nodes ptl ptr denote average total path length randomly built binary search tree nodes rewritten recalling alternative analysis randomized version quicksort problem conclude lg recursive invocation quicksort oose random pivot element partition set elements sorted node binary search tree partitions set elements fall subtree rooted node implementation quicksort comparisons sort set elements comparis ons insert elements binary search tree order comparisons differ comparisons problems number binary trees denote number binary trees nodes problem formula asymptotic estimate b0 referring problem definition generating function generating function xbx2 express closed form taylor expansion fx point fkx kth derivative evaluated nth catalan number taylor expansion taylor expansion generalization binomial expansion nonintegral exponents real number integer interpret chapter notes knuth good discussion simple binary search trees variations binary search trees independently discovered number people late radix trees ofte called middle letters word retrieval discussed knuth construct optimal binary search tree search frequencies prior constructing tree frequencies searching key frequencies sear ching values fall keys tree construct binary search tree set searches frequencies examines minimum number nodes proof bounds expected height randomly built binary search tree aslam mart nez roura randomized algorithms insertion deletion binary search trees result eith operation random binary search tree definition random nary search tree differs randomly built binary search chapter chapter redblack trees chapter binary search tree height implement basic dynamicset operationsšsuch search predecessor successor minimum maximum insert deletešin time set operations fast height search tree small ight large performance linked list redblack trees searchtree schemes balanced order guarantee basic dynamicset operations olg time worst case properties redblack trees redblack tree binary search tree extra bit storage node color red black constraining nodes colored path root leaf redblack trees ensure path long tree balanced node tree fields color key left child parent node exist pointer field node nil regard pointers extern nodes leaves binary search tree normal keybearing nodes internal nodes tree binary search tree redblack tree satisfies redblack properties node red black root black leaf nil black node red children black node paths node scendant leaves number black nodes figure redblack tree figure redblack tree black nodes darkened red nodes shaded node redblack tree red black children red node black simple path node descendant number black nodes leaf nil black nonnil node marked blackheight nils blackheight redblack tree nil replaced single sentinel nilt black blackheights roots parent sentinel redblack tree leaves roots parent drawing styl remainder chapter matter convenience dealing boundary conditions redblack tree code single sentinel represent nil redblack tree sentinel nilt object fields ordinary node tree color field black fieldsšp left keyšcan set arbitrary values figure pointers nil pointers sentinel nil sentinel treat nil child node ordinary node parent add distinct sentinel node nil tree parent nil defined approach waste space sentinel nilt represent nilsšall leaves roots parent values fields left key sentinel immaterial set procedure convenience generally confine internal nodes redblack tree hold key values remainder chapter omit leaves draw redblack trees figure number black nodes path including node leaf blackheight node denoted bhx property notion blackheight defined descending paths node number black nodes define blackheight redblack tree blackh root lemma redbl ack trees good search trees lemma redblack tree internal nodes height lg proof start showing subtree rooted node bhx internal nodes prove aim induction height height leaf nilt subtree rooted bhx internal nodes inductive step node positive height internal node children ild blackheight bhx bhx depending color red black height child height apply inductive hypothesis conclude child bh internal nodes subtree rooted bhx1 bhx1 bhx internal nodes proves claim complete proof lemma height tree property half nodes simple path oot leaf including root black blackheight root moving lefthand logarithms sides yields lg lgn consequence lemma dynamicset operations search minimum maximum successor predecessor implemented olg time redblack trees time search tree height chapter redblack tree nodes search tree height olg references nil algorithms chapter replaced nilt algorithms tree insert treedelete chapter olg time redblack tree input directly support dynamicset operations insert delete guarantee modified binary search tree redblack tree sections operations supported olg time exercises style figure draw complete binary search tree height keysadd nil leaves color nodes ways black heights redblack treesexercises draw redblack tree ter treeinsert called tree figure key inserted node colored red tree redblack tree colored black exercises define relaxed redblack tree binary search tree satisfies red black properties root red black relaxed redblack tree root red color root black tree redblack tree exercises suppose absorb red node redblack tree black parent children red node children black parent ignore keys degr ees black node red children absorbed depths leaves tree exercises longest simple path node redblack tree descendant leaf length shortest simple path node descendant leaf exercises largest number internal nodes redblack tree blackheight smallest number exercises redblack tree keys realizes largest ratio red internal nodes black internal nodes ratio tree smallest ratio ratio rotations searchtree operations treeinsert treedelete redblack tree keys olg time modify tree result violate red black properties enumerated restore properties change colors node tree change pointer structure change pointer structure rotation local operation search tree preserves binarysearchtree property figure kinds rotations left rotations rotations left rotation node assume child nilt node tree child nilt left rotation pivots link root subtree left child left child child figure rotation operations binary search tree operation leftrotatet transforms configuration nodes left configuration changing constant number pointers configuration transformed confi guration left inverse operation rightrotatet letters represent arbitrary subtrees rotation operation preserves binarysearchtree property keys precede keyx precedes keys precede keyy precedes keys pseudocode leftrotate assumes rightx nilt roots parent nilt leftrotatet rightx set rightx lefty turn left subtree subtree plefty px link parent px nilt roott leftpx leftpx rightpx lefty left px figure leftrotate operates code rightrotate symmetric leftrotate rightrotate o1 time pointers changed rotation fields node remain figure procedure leftrotate modifies binary search tree inorder tree walks input tree modified tree produce listing key values exercises write pseudocode rightrotate exercises argue nnode binary search tree rotations exercises arbitrary nodes subtrees left tree figure depths change left rotation performed node figure exercises arbitrary nnode binary search tree transformed arbitrary nnode binary search tree rotations hint rotations suffice transform tree rightgoing chain exercises binary search tree rightconverted binary search tree series calls rightrotate trees rightconverted tree rightconverted rightconverted on2 calls rightrotate insertion insertion node nnode redblack tree accomplished olg time modified version treeinsert procedure insert node tree ordinary binary search tree color red guarantee redblack properties pre served auxiliary procedure rbinsertfixup recolor nodes perform rotations rbinsert inserts node key field assumed filled redblack tree rbinsertt nilt roott nilt keyz keyx leftx rightx pz nilt roott keyz keyy lefty righty leftz nilt rightz nilt colorz red rbinsertfixupt differences proced ures treeinsert rbinsert instances nil treeinsert replaced nilt set leftz rightz nilt lines œ15 rbinsert order intain proper tree structure color red fourth coloring red violation redblack properties rbinsertfixup rbinsert restore redblack properties rbinsertfixupt colorpz red pz leftppz rightppz colory red colorpz black case colory black case colorppz red case ppz case rightpz pz case leftrotatet case colorpz black case colorppz red case rightrotatet ppz case clause left exchanged colorroott black understand rbinsertfixup works break examination code major steps determine violations redblack properties introduced rbinsert node inserted colored red examine goal loop lines œ15 finally explore cases1 loop broken accomplish goal figure rbinsertfixup operates sample redblack tree figure operation rbinsertfixup node insertion parent pz red violation property occurs zs uncle red case code applied nodes recolored pointer moved tree tree parent red zs uncle black child pz case applied left rotation performed tree left child parent case applied rotation yields tree legal redblack tree redblack properties violated rbinsertfixup property continues hold property children newly inserted red node sentinel nilt property number black nodes path node satisfied node replaces black sentinel node red sentinel children properties violat property requires root black property red node red child violations colored red property violated root property violated zs parent red figure violation property node inserted loop lines œ15 intains threepart invariant start iteration loop node red pz root pz black violation redblack properties violation property property violation property occurs root red violation property occurs pz red deals violations redblack properties central showing rbinsertfixup restores dblack properties understand situations code focusing node nodes tree helpful red node ppz exists reference lines recall loop invariant true prior iteration loop iteration maintains loop invariant loop invariant property loop termination start initialization termination arguments examine body loop works gue loop maintains invariant iteration demons trate outcomes iteration loop pointer moves tree rotations performed loop terminates initialization prior iteration loop started redblack tree violations red node invariant holds time rbinse rtfixup called rbinsertfixup called red node pz root pz started black change prior rbinsertfixup propertieshold rbinsertfixup called violation property red root newly node internal node tree parent children sentinel black violation property violation property violation redblack properties entire tree violation property children node black sentinels tree violations prior violation pz red violations redblack properties termination loop terminates pz black root pz sentinel nil black violation property loop termination loop nvariant property fail hold property restores property rbinsertfixup terminates redblack properties hold maintenance cas loop symmetric depending zs parent pz left child child zs grandparent ppz determined code situation pz left child node ppz exists loop invariant pz root pz black enter loop iteration pz red pz root ppz exists case distinguished cases color zs parents sibling uncle point zs uncle rightppz test red case executed control passes cases cases zs grandparent ppz black parent pz red property violated pz case zs uncle red figure situation case lines œ8 case executed pz red ppz black color pz black fixing problem pz red color ppz red maintaining property repeat loop ppz node pointer moves levels tree figure case procedure rbinsert property violated parent pz red action child left child subtrees black root black height code case colors node preserving property downward paths node leaf ha number blacks loop continues node zs grandparent ppz violation property occur red parent red case maintain loop invariant start iteration denote node current iteration ppz denote node test iteration iteration colors ppz red node red start iteration node pz pppz iteration color node change node root black prior iteration remains black start iteration argued case main tains property introduce violation properties node root start iteration case corrected lone violation property iteration red root property violat violation node root start iteration case created violation property case corrected lone violation property existed start iteration red left pz pz black violation property pz red coloring red created violation property pz case zs uncle black child case zs uncle black left child cases color zs uncle black cases distinguished left child pz lines œ11 constitute case figure case case node child parent left rotation transform situation case lines œ14 node left child pz red rotation blackheight nodes property enter case directly case zs uncle black execute case additionally node ppz exists argued node existed time lines executed moving level level identity ppz remains unchanged case execute color anges rotation preserve property longer red nodes row body loop executed time pz black figure cases procedure rbinsert case property violated case case parent pz red subtrees black root property case blackheight transformed case left rotation preserves property downward paths node leaf number blacks case color anges rotation preserve property loop terminates property satisfied longer red nodes row cases maintain loop invariant argued pz black test loop body execute case point pz red change color occurs cases case pz black pz root start iteration black case propertiesmaintained cases node root cases violation property cases introduce violation property node red child black node rotation case cases correct lone violation property intro duce violation iteration loop main tains invariant rb insertfixup correctly restor redblack properties analysis running time rbinsert height redblack tree nodes olg lines œ16 rbinsert olg time rbinsert fixup loop repeats case executed pointer moves levels tree total number times loop executed olg rbinsert takes total olg time interestingly performs rotations loop terminates case case executed exercises rbinsert set color newly inserted node red notice chosen set zs color black property redblack tree violated didnt choose set zs color black exercises redblack trees result successively inserting keys initially redblack tree exercises suppose blackheight subtrees figures label node figure blackhei ght verify property preserved transformation exercises professor teach concerned rbinsertfixup set color nilt red case test loop terminate root professors concern unfounded arguing rbinsertfixup sets colornilt red exercises redblack tree formed inserting nodes rbinsert argue tree red node exercises implement rbinsert efficiently representation redblack trees includes storage parent pointers case falls case cases mutually exclusive deletion basic operations nnode redblack tree deletion node takes time olg deleting node redbl ack tree complicated inserting node procedure rbdelete minor modi fication treedelete procedure splicing node calls auxiliary procedure rbdeletefixup colors performs rotati ons restore redblack properties rbdeletet leftz nilt rightz nilt treesuccessorz lefty nilt lefty righty px nilt roott leftpy leftpy rightpykeyz keyy copy satellite data colory black rbdeletefixupt return differences procedures treedelete rbdelete references nil treedelete replaced references sentinel nilt rbdelete test nil treedelete removed assignment px performed unconditionally rbdelete sentinel nilt parent pointer points parent splicedout node rbdeletefixup lines œ17 black red redblack properties hold spliced reasons blackheights tree changed red nodes adjacent root red root remains black node passed rbdeletefixup nodes node sole child spliced child sentinel nilt children sentinel nilt case unconditional assignment guarantees parent node parent keybearing internal node sentinel nil examine procedure rbdeletefixup restores redblack properties search tree rbdeletefixupt roott colorx black leftpx rightpx colorw red colorw black case colorpx red case leftrotatet px case rightpx case colorleftw black colorrightw black colorw red case px case colorrightw black colorleftw black case colorw red case rightrotatet case rightpx case colorw colorpx case colorpx black case colorrightw black case leftrotatet px case roott case clause left exchanged colorx black splicedout node rbdelete black problems root red child root ha violated property px red violated property removal path contained fewer black node property violated ancestor tree correct problem node extra black add count black nodes path interpretation property holds splice black node push blackness child problem node red black violating property node doubly black redandblack contributes count black nodes paths color attribute red redandblack black doubly black extra black node reflected pointing node color attribute procedure rbdeletefixup restores propertiesexercises procedure restores properties remainder focu property goal loop lines œ22 extra black tree points redandblack node case color singly black points root case extra black simply removed suitable rotations reco lorings performed loop points nonroot doubly black node determine left child child parent px code situation left child situation childšline šis symmetric maintain pointer sibling node doubly black node nilt number blacks path px singly black leaf smaller number path px cases code illustrated figure examining case generally verify transformation cases preserves property key idea case number black nodes including extra black including root subtree subtrees preserved transformation hus property holds prior transformation continues hol afterward figure illustrates case number black nodes root subtree transformati remember node adds extra black number black node root transformation figure counting involve color attribute root subtree red black define countred countblack number black nodes root countc transformati case transformation node color attribute node redandblack red doubly black black cases verified exercise figure cases loop procedure rbdeletefixup darkened nodes color attributes black heavily shaded nodes color attributes red lightly shaded nodes color attributes represented red black letters represent arbitrary subtrees case configuration left transformed configurati changing colors andor performing rotation node pointed extra black doubly black redandblack case loop repeat case case transformed caseexchanging colors nodes performing left rotation case extra black represented pointer moved tree coloring node red setting point node enter case case loop terminates node redandblack color attribute red case transformed case exchanging colors nodes performing rotation case extra black represented removed changing colors performing left rotation wit hout violating redblack properties loop terminates case sibling red case lines œ8 rbdeletefixup figure occurs node sibling node red black children switch colors px perform leftrotation px violating redblack properties sibling ws children prior rotation black converted case casecasesoccur node black distinguished colors ws children case sibling black ws children black case lines œ11 rbdeletefixup figure ws children black black black leaving black leaving red compensate removing black add extra black px originally red black repeating loop px node observe enter case case node redandblack original px red color attribute node red loop terminates tests loop condition node colored singly black case sibling black ws left child red ws child black case lines œ16 figure occurs black left child red child black switch colors left child left perform rotation violating redblack properties sibling black node red child transformed case case case sibling black ws child red case lines œ21 figure occurs node sibling black ws child red making color cha nges performing left rotation px remove extra black making singly black violating redblack properties setting root loop terminate tests loop condition analysis running time rbdelete height redblack tree nodes olg total cost procedure rbdeletefixup takes olg time rbdeletefixup casesterminate performing constant number color ree rotations case case loop repeated pointer moves tree olg times rotations performed procedure rbdeletefixup takes olg time performs rotations time rbdelete olg exercises argue executing rb deletefixup root tree black exercises argue rbdelete red property restored rbdeletefixupt exercises exercise redblack tree resu lts successively inserting keys initially redblack trees result successive deletion keys order exercises lines code rbdeletefixup examine modify sentinel nilt exercises cases figure count black nodes root subtree subtrees verify count remains transformation node color attribute notation countc countc symbolically count exercises professors skelton baron concerne start case rbdeletefixup node px black profe ssors correct lines œ6 wrong px black start case professors worry exercises suppose node inserted redblack tree rbinsert deleted rbdelete redbl ack tree initial redblack tree justify answer problems persistent dynamic sets algorithm maintain versions dynamic set upda ted set called persistent implement persistent set copy entire set modifi approach slow program consume space persistent set operations insert delete search implement binary earch trees figure maintain separate root version set order insert key set create node key node left child node key modify existing node key node key left child node key child existing node key node key turn child root key left child existing node key copy tree share nodes original tree figure figure binary search tree keys persistent binary search tree insertion version set consists nodes reachable root previous version consists nodes reachable heavily shaded nodes adde key inserted assume tree node fields key left parent field exercise general persistent binary search tree identify nodes changed insert key delete node write procedure persistenttreeinse persistent tree key insert returns persistent tree result inserting height persistent binary search tree time space requirements implementation persistenttreeinsert space requirement proportional number nodes allocated suppose included parent field node case persistenttreeinsert perform additional copying prove persistenttreeinsert require time space number nodes tree redblack trees guara ntee worstcase running time space olg insertion deletion problems join operation redblack trees join operation takes dynamic sets s1 element s1 keyx1 keyx keyx2 returns set s1 problem investigate implemen join operation redblack trees redblack tree store blackheight field bht argue field maintained rbinsert rbdelete requiring extra storage nodes tree increasing asymptotic running times descending determine blackheight node visit o1 time node visited implement operation rbjoin destroys returns redblack tree total number nodes assume bht1 bht2 olg ntime algorithm finds black node largest key nodes blackheight bht2 ty subtree rooted ty replace ty o1 time destroying binarysearchtree property color redblack propertiesmaintained properties enforced olg time argue generality lost making assumption symmetric situation arises bht1 bht2 argue running time rbjoin olg problems avl trees avl tree binary search tree height balanced node heights left subtrees differ implement avl tree maintain extra field node hx height node binary search tree assume roott points root node prove avl tree nodes height olg hint prove avl tree height fh nodes fh hth fibonacci number insert avl tree node place binary search tree order insertion tree longer height balanced heights left children node differ procedure balancex takes subtree rooted left children height balanced heights differ hrightx hleftx alters subtree rooted height balanced hint rotations recursive procedure avlinsert takes node avl tree newly created node key filled adds subtree rooted maintaining property root avl tree treeinsert assume keyz filled left nil rightz nil assume hz insert node avl tree avlinsertroott nnode avl tree avlinsert operation lg rotations performed problems treaps insert set items binary search tree tree horribly unbalanced leading long search times randomly built binary search trees tend balanced strategy average builds balanced tree fixed set items ndomly permute items insert order tree items receive items time randomly build binary search tree examine data structure answ ers question affirmative treap binary search tree modi fied ordering nodes figure usual node tree key keyx addition assign priorityx random number chosen independently node assume priorities distinct keys distinct nodes treap ordered keys obey binarysearchtree property priorities obey minheap order property left child keyv keyu child keyv keyu child priorityv priorityu figure treap node labeled keyx priorityx root key priority combination properties tree called treap features binary search tree heap helps treaps suppose insert nodes keys treap treap tree formed nodes inserted normal nary search tree order randomly chosen priorities priority priorityxj inserted set nodes keys priorities distinct unique treap nodes expected height treap lg time search treap lg insert node existing treap thing assign node random priority insertion algorithm treap insert operation illustrated figure figure operation treapinsert original treap prior insertion treap inserting node key priority cœd intermediate stages inserting node key priority treap insert ion parts treap inserting node key priority explain treapinsert works xplain idea english pseudocode hint execute usual binarysearchtree insertion procedure perform rotations restore minheap order property expected running time treapinsert lg treapinsert performs search sequence rotations operations expected running time costs practice search reads treap modifying contrast rotation parent child pointers treap computers read operations faster write operations treapinsert perform rotations expected number rotations performed bounded constant order definitions illustrated figure left spine binary search tree path root node smallest key left spine path root consists left edges symmetrically spine path root consisting edges length spine number nodes figure spines binary search tree left spine shaded spine shaded treap inserted treapinsert length spine left subtree length left spine subtree prove total number rotations performed insertion equal calculate expected values loss generality assume keys comparing nodes keyx keyy define indicator random variables xik spine left subtree xik priority priority keyy keyx keyy keyz keyx priority priority symmetry argument conclude expected number rotations performed inserting node treap rbinsertfixup cases rbdeletefixup mutually exclusive chapter notes idea balancing search tree adelsonvelski landis introduced class balanced search trees called avl trees problem class search trees called trees introduced hopcroft unpublished balance maintained tree manipula ting degrees nodes tree generalization trees introduced bayer mccreight called btrees topic chapter redblack trees invented bayer symmetric binary btrees guibas sedgewick studied properties length introduced redblack color convention andersson simplertocode variant redblack trees weiss calls variant aatrees aatree sim ilar redblack tree left children red treaps proposed seidel aragon default implementation dictionary leda wellimple mented collection data structures algorithms variations balanced binary trees including weightbalanced trees kneighbor trees scapegoat trees intriguing splay trees introduced sleator tarjan selfadjusting good description splay trees tarjan splay trees maintain balance explicit balance condition color splay operations involve rotations performed tree time access amortized cost chapter operation nnode tree olg skip lists alternative bala nced binary trees skip li linked list augmented number additional pointers dictionary operation runs expected time olg skip list items chapter augmenting data structures engineering situations requi textbook data structureš doubly linked list hash table binary search treešbut require dash creativity rare situations create type data structure suffice augment text book data structure storing additional program operations data structure support desired application augmenting data structure straightforward updated maintained ordinary operations data structure chapter discusses data structures constructed augmenting redblack trees describes data structure supports general orderstatistic operations dynamic set ith smallest number rank element total ordering set abstracts proc ess augmenting data structure theorem simplify augmentation redblack trees theorem design data structure maintaining dynamic set intervals time intervals query interval interval set overlaps dynamic order statistics chapter introduced notion order statistic ith order statistic set elements simply element set ith smallest key order statistic retrieved time unordered set redblack trees modified order statistic determined olg time rank elementšits position linear order setšcan likewise determined olg time data structure support fast orderstatistic operations figure orderstatistic tree simply redblack tree additional stored node usual redblack tree fields keyx colorx px leftx rightx node field sizex field numb internal nodes subtree rooted including size subtree define sentinels size set sizenilt identity sizex sizeleftx sizerightx figure orderstatistic tree augmented redblack tree shaded nodes red darkened nodes black addition usual fields node field sizex number nodes subtree rooted require keys distinct orderstatistic tree tree figure keys keys presence equal keys notion rank defined remove ambiguity orderstatistic tree defining rank element position printed inorder walk tree figure key stored black node rank key stored red node rank retrieving element rank maintain size formation insertion deletion examine implementation orderstatistic queries additional operation retrieves element rank procedure osselectx returns pointer node ith smallest key subtree rooted ith smallest key orderstatistic tree osselectroott osselectx sizeleftx1 return elseif return osselectleftx return osselectrightx œ idea osselect selection algorithms chapter sizeleftx number nodes inorder tree walk subtree rooted sizeleft rank subtree rooted osselect compute rank node subtree rooted node ith smallest element return ith smallest element left subtree recurse left ith smallest element subtree elements subtree rooted subtree inorder tree walk ith smallest element subtree rooted œ rth smallest element subtree rooted rightx element determined recursively osselect operates search smallest element orderstatistic tree figure root key size left subtree rank node rankth smallest element subtree recursive node key size left subtree rank subtree node rank smallest element left subtree recursive node key rank subtree recurse smallest element subtree rooted node key left subtree size smallest element pointer node key returned procedure recursive level orderstatistic tree total time osselect worst proportional height tree tree redblack tree height olg number nodes hus running time select olg dynamic set elements determining rank element pointer node orderstatistic tree procedure osrank returns position linear order determined inorder tree walk osrankt sizeleftxroott rightpy sizeleftpyreturn procedure works rank viewed number nodes preceding inorder tree walk osrank maintains loop invariant start iteration loop lines œ6 rank keyx subtree rooted node loop invariant osrank works correctly initialization prior iteration sets rank keyx subtree rooted setting invariant true time test executes maintenance iteration loop set rank keyx subtree rooted start loop body rank keyx subtree rooted loop body iteration loop subtree rooted counted number nodes subtree rooted node precede inorder walk add nodes subtree rooted sibling precede inorder walk precedes left child node pys subtree precedes leave child nodes pys left subtree precede add sizeleft current termination loop terminates roott subtree rooted entire tree rank keyx entire tree osrank orderstatistic tree figure rank node key sequence values keyy loop iteration keyy rank returned iteration loop takes o1 time level tree iteration running time osrank worst proportional height tree olg nnode orderstatistic tree maintaining subtree sizes size field node osselect osrank compute order statistic fields efficiently maintained basic modifying operations redblack trees rk naught subtree sizes maintained insertion deletion asymptotic running time operation insertion redblack tree consists phases phase tree root inserti node child existing node phase tree changing colors ultimately performing rotations maintain redblack properties maintain subtree sizes phase simply increment sizex node path traversed root leaves node size olg nodes traversed path additional cost maintaining size fields olg phase structural underlying redblack tree caused rotations rotation local operat ion nodes size fields invalidated link rotation performed incident nodes referring code leftrotatet add lines sizey sizex sizex sizeleft sizerightx figure illustrates fields update change rightrotate symmetric figure updating subtree sizes rotations link rotation performed incident nodes size fields updated updates local requiring size stored roots subtrees triangles rotations performed dur ing insertion redblack tree o1 additional time spent updating size fields phase total time insertion nnode orderstatistic tree olg asymptotically ordinary redblack tree deletion redblack tree consists phases operates underlying search tree rotations performs structural phase splices node update subtree sizes simply traverse path node root decrementing size field node path path length olg nnode redblack tree additional time spent maintaining size fields phase olg o1 rotations phase deletion handled manner insertion insertion deletion including maintenance size fields olg time nnode orderstatistic tree exercises osselect operates redblack tree figure exercises osrankt operates redblack tree figure node keyx exercises write nonrecursive version osselect exercises write recursive procedure oskeyrank takes input orderstatistic tree key returns rank dynamic set represented assume keys distinct exercises element nnode orderstatistic tree natural number ith successor linear order tree determined olg time exercises observe size field node referenced osselect rank compute rank node subtree rooted node suppose store node rank subtree root maintained insertion deletion remember operations rotations exercises orderstatistic tree count number inversions problem array size time lg exercises chords circle define endpoints lg ntime algorithm determining number pairs hords intersect inside circle chords diameters meet center correct answer assume chords share endpoint augment data structure process augmenting basic data struct ure support additional functionality occurs frequently algorithm design design data structure supports operations intervals examine steps involved augmentation ove theorem augment redblack trees easily cases augmenting data structure broken steps choosing underlying data structure determining additional main tained underlying data structure verifying additional maintained basic modifying operations underlying data structure developing operations prescriptive design method shoul blindly follow steps order design work element trial rror progress steps proceeds parallel point determining additional developing operations steps maintain additional efficiently nevert heless fourstep method good focus efforts augmenting data struct ure good organize documentation augmented data structure steps design orderstatistic trees step chose redblack trees underlying data structure clue suitability redblack trees efficient support dynamicset operations total order minimum maximum successor predecessor step provided size field node stores size subtree rooted generally additional operations efficient implemented osselect osrank keys stored tree olg time additional pointer data exercise step ensured insertion deletion maintain size fields running olg time ideally elements data structure updated order maintain additional inform ation simply stored node rank tree osselect osrank procedures inserting minimum element change node tree store subtree sizes inst ead inserting element change olg nodes step developed operations osselect osrank operations bother augment ta structure place occasionally developing operations additional expedite existing exercise augmenting redblack trees redblack trees underlie augmented data structure prove kinds additional efficiently maintained insertion deletion making step easy proof follo wing theorem argument size field maintained orderstatistic trees theorem augmenting redblack tree field augments redblack tree nodes suppose contents node computed nodes left rightx including fleftx frightx maintain values nodes insertion deletion asymptotically olg performance operations proof main idea proof change field node propagates ancestors tree changing fx require fpx updated updating fpx require fppx updated tree froott updated node depends process terminates height redblack tree olg changing field node costs olg time updating nodes dependent change insertion node consists phases phase inserted child existing node px fx computed o1 time supposition depends fields children children sentinel nilt fx computed change propagates tree total time phase insertion olg phase structural tree rotations nodes change rotation total time updating fields olg rotation number rota tions insertion total time insertion olg insertion deletion phases phase tree occur deleted node replaced successor deleted node successor spliced propagating updates caused costs olg modify tree locally fixing redblack tree phase requires rotati ons rotation requires olg time propagate updates insertion total time deletion olg cases maintenance size fields orderstatistic trees cost updating rotation o1 olg derived proof theorem exercise exercises dynamicset queries mi nimum maximum successor predecessor supported o1 worstcase time augmented order statistic tree asymptotic performance operations orderstatistic trees hint add pointers nodes exercises blackheights nodes redblack tree maintained fields nodes tree asympt otic performance redblack tree operations argue exercises depths nodes redblack tree efficiently maintained fields nodes tree argue exercises associative nary operator field maintained node red black tree suppose include node additional field fx ax1 ax2 axm xm inorder listing nodes subtree rooted fields properly updated o1 time rotation modify argument size fields orderstatistic trees maintained o1 time rotation exercises augment redblack ees operation rbenumerate outputs keys redblack tree rooted rbenumerate implemented lg time number keys output number internal nodes tree hint add fields redblack tree interval trees augment redblack trees support operations dynamic sets intervals closed interval ordered pair real numbers interval represents set open halfopen intervals omit endpoints set resp ectively assume intervals closed extending open halfopen intervals conceptually straightforward intervals convenient representing events occupy continuous period time query databa time intervals events occurred interval data structure efficient maintaining interval database represent interval object fields lowi low endpoint highi t2the high endpoint intervals overlap ø lowi highi lowi highi intervals satisfy interval trichotomy properties holds overlap left highi lowi highi lowi figure possibilities figure interval trichotomy closed intervals overlap situations lowi highi lowi highi intervals overlap highi lowi intervals overlap high lowi interval tree redblack tree maintains dynamic set elements element interval int interval trees support operations intervalinsertt adds element int field assumed interval interval tree intervaldeletet removes element interval tree intervalsearcht returns pointer element interval tree intx overlaps interval sentinel nilt element set figure interval tree represents set intervals track step method review design interval tree operations figure interval tree set intervals sorted left endpoint interval tree represents inorder tree walk tree lists nodes sorted order left endpoint step underlying data structure choose redblack tree node interval int key low endpoint lowint interval inorder tree walk data structure lists intervals sorted order low endpoint step additional addition intervals node maxx maximum interval endpoint stored subtree rooted step maintaining verify insertion deletion performed olg time interval tree nodes determine maxx interval int max values node children maxx max highintx maxleftx maxrightx theorem insertion deletion olg time fact updating max fields rotation accomplished o1 time exercises step developing operations operation intervalsearch finds node tree interval overlaps interval interval overlaps tree pointer sentinel nilt returned intervalsearcht roott nilt overlap intx leftx nilt maxleftx lowi leftx rightx return search interval overlaps starts root tree proceeds downward terminates overlapping interval points sentinel nilt iteration basic loop takes o1 time height nnode redblack tree olg intervalsearch procedure takes olg time intervalsearch correct examine works interval tree figure suppose interval overlaps interval root overlap maxleftx greater lowi loop continues left child rootšthe node overlap time maxleftx low loop continues child interval stored node overlaps procedure returns node unsuccessful search suppose interval overlaps interval tree figure root roots interval overlap maxleftx greater lowi left node note interval subtree overlaps išwe interval overlap maxleftx lowi note interval left subtree overlaps interval overlap left child nil loop terminates sentinel nilt returned intervalsearch correct understand suffices examine single path root basic idea node intx overlap search proceeds safe direction overlapping interv tree theo rem states property precisely theorem execution intervalsearcht returns node interval overlaps returns nilt tree node interval overlaps proof loop lines œ5 terminates nilt overlaps intx case correct return focus case loop terminates nilt invariant loop lines œ5 tree interval overlaps interval subtree rooted loop invariant initialization prior iteration sets root invariant holds maintenance iteration loop executed loop invariant maintained case executed branch condition leftx nilt max leftx lowi leftx nilt subtree rooted leftx interval overlaps setting rightx maintains invariant suppose leftx nilt maxleftx lowi figure interval left subtree highi maxleftx lowi figure intervals proof theorem maxleftx case dashed search interval left subtree overlap search left left subtree interval overlaps situation interval left subtree highi maxleftx overlap overlap interval subtree lowi low interval trichotomy overlap left subtree intervals overlap setting rightx maintains invariant hand executed contrapositive loop invariant holds interval overlapping subtree rooted left interval overlapping tree executed branch condition maxleftx lowi definition max field interval left subtree highi maxleftx lowi figure illustrates situation overlap true highi lowi interval trichotomy highi lowi interval trees keyed low endpoints intervals searchtree property implies interval subtree highi lowi lowi interval trichotomy overlap concl ude interval left subtree overlaps setting left maintains invariant termination loop terminates nilt interval overlapping subtree rooted contrapositive loop invariant implies interval overlaps correct return nilt intervalsearch procedure works correctly exercises write pseudocode leftrotate operate nodes interval tree updates max fields o1 time exercises rewrite code interval search works properly intervals assumed open exercises efficient algor ithm interval returns interval overlapping minimum low endpoint nilt interval exists exercises interval tree interval intervals overlap listed omin lg time number inte rvals output list optional solution modify tree exercises modifications intervaltr procedures support operation intervalsearchexactlyt returns pointer node interval tree low intx lowi highintx highi nilt node operations including intervalsearchexactly olg time nnode tree exercises maintain dynamic set numbers supports operation mingap magnitude diffe rence closest numbers mingapq returns closest numbers operations insert delete search mingap efficient alyze running times exercises vlsi databases commonly represen integrated circuit list rectangles assume rectangle rectilinearly iented sides parallel yaxis representation rectangle consists minimum maximum ycoordinates lg ntime algorithm decide set rectangles represented rectangles ove rlap algorithm port intersecting pairs report overlap exists ctangle covers boundary lines intersect hint sweep set rectangles problems point maximum overlap suppose track point maximum overlap set intervalsša point largest number intervals database overlapping point maximum overlap whic endpoint segments design data structure efficiently supports operations intervalinsert intervaldelete findpom turns point maximum overlap hint redblack tree endpoints associate left endpoint associate endpoint augment node tree extra maintain point maximum overlap problems josephus permutation josephus problem defined suppose people arranged circle positive integer designated person proceed circle removing mth person person removed counting continues circle remains process continues people removed order people removed circle defines mjosephus permutation integersjosephus permutationsuppose constant ontime algorithm integer outputs mjosephus permutation suppose constant lg ntime algorithm integers outputs mjosephus permutation chapter notes book preparata shamos interval trees literature citing work edelsbrunner mccreight book details interval tree wh ich static database intervals intervals overlap query interval enumerated lg time advanced design analysis techniques chapter list chapter dynamic programming chapter greedy algorithms chapter amortized analysis introduction covers techniques design analysis efficient algorithms dynamic programming chapter greedy algorithms chapter amortized analysis chapter earlier parts presented applicable techniques divide conquer randomization solution recurrences techniques sophisticated effectively attacking computational problems themes introduced recur book dynamic programming typically plies optimization problems set choices order arri optimal solution choices subproblems form dynamic programmi effective subproblem partial set choices key technique store solution subproblem case reappear chapter simple idea transform exponentialtime gorithms polynomialtime algorithms dynamicprogramming algorithms greedy gorithms typically apply optimization problems set choices order arrive optimal solution idea greedy algorithm choice locally optimal manner simple coinchanging minimize number coins needed change suffices select repeatedly largestdenomination coin larger owed problems greedy approach optimal solution dynamicprogramming approach easy whethe greedy approach effective chapter reviews matroid theory helpful making determination amortized analysis tool analyzing gorithms perform sequence operations bounding cost sequence operations bounding actual cost operation separately amortized analysis provide bound actual cost entire sequence reason idea effective impossible sequence operations individual operations worstcase time bounds operati ons expensive cheap amortized analysis analys tool thinking design algorithms design algorithm analysis running time closely intertwined chapter introduces ways perform amortized analysis algorithm chapter dynamic programming overview dynamic programming divideandconq uer method solves problems combining solutions subproblems programming context refers tabular method writing computer code chapter divide conquer algorithms partition problem independent subproblems lve subproblems recursively combine solutions solve original problem contrast dynamic programming applicable subproblems ndependent subproblems share subsubproblems context dividea ndconquer algorithm doe work repeatedly solving common subsubproblems dynamicprogramming algorithm solves subsubproblem saves answer table avoiding work recomputing answer time subsubproblem encountered dynamic programming typically applied optimization problems problems solutions ach solution solution optimal minimum maximum solution optimal solution problem opposed optimal solution solutions achieve optimal development dynamicprogramming algor ithm broken sequence steps characterize structure optimal solution recursively define optimal solution compute optimal solution bottomup fashion construct optimal solution computed steps œ3 form basis dynamicprogrammi solution problem step optimal solution required perform step maintain additional dur ing computation step ease construction optimal solution sections follow dynamicpr ogramming method solve optimization problems examines problem scheduling automobile assembly lines station auto construc tion stay asks multiply chain matrices fewest total scalar multiplications performed ven examples dynamic programming discusses key characteristics problem dynamic programming viable solution technique longest common subsequence sequences finally dynamic programming construct binary search trees optimal distribution keys looked assemblyline scheduling dynamic programming solv manufacturing problem colonel motors corporation produces automobiles factory assembly lines figure automobile chassis enters asse mbly parts number stations finish auto exits assembly stations numbered denote jth station sij jth station s1j performs function jth station s2j stations built times technol ogies time required station varies stations position lines denote assembly time required station sij aij figure chassis enters station assembly lines progresses station entry time chassis enter assembly exit time completed auto exit assembly figure manufacturing problem fastest factory assembly lines stations jth station denoted sij assembly time station aij automobile chassis enters factory time jth station chassis station transfer cost stays takes time tij transfer station sij exiting nth station takes time completed auto exit factory problem determine stations choose choose order minimize total time ctory auto chassis enters assembly lin passes time station assembly negligible occasionally special rush order customer automobile manufactured rush orders chassis passes stations order factory manager switch partiallycompleted auto assembly station time tran sfer chassis assembly station sij tij nth station assembly complete problem determine stations choose choose order mini mize total time thr ough factory auto figure fastest total time choosing stations stations figure instance assemblyline problem costs aij tij heavily shaded path indi cates fastest factory values fij lij instance obvious brute force minimizing time factory infeasible stations list stations easy compute time long takes chassis pass factory ways choose stations viewing set stations subset noting subsets determining fastest rough factory enumerating ways computing long takes require time infeasible large step structure fastest factory step dynamicprogramming paradi gm characterize structure optimal solution assemblyline scheduling problem perform step fastest chassis starting point station s1j chassis easy determine long ta kes station s1j choices chassis station s1j1 directly station s1j time station station negligible alternatively chassis coul station s2j1 transferred station s1j transfer time t2j1 possibilities separately common suppose fastest station s1j station s1j1 key observation chassis fastest starting point station s1j1 fast station s1j1 substitute faster yield faster station s1j contradiction suppose fastest station s1j station s2j1 observe chassis ta ken fastest starting point station s2j1 reasoning faster station s2j1 substitute faster yield faster station s1j contradiction generally asse mblyline scheduling optimal solution problem finding fastest station sij optimal solution subproblems finding fastest s1j1 s2j1 refer property optimal substructure hallmarks pplicability dynamic programming optimal substructure construct optimal solution problem optimal solutions subproblems ssemblyline scheduling reason fastest station s1j stationfastest station s1j fastest station s1j1 directly station s1j fastest station s2j1 transfer station s1j symmetric reasoning fastest station s2j fastest station s2j1 directly station s2j fastest station s1j1 transfer station s2j solve problem finding fastest station solve subproblems finding fastest ways station lines build optimal solution instance assemblyline scheduling problem building optimal solutions subproblems step recursive solution step dynamicprogramming paradi gm define optimal solution recursively terms optimal lutions subproblems assemblyline scheduling problem pick subproblems problems finding fastest station lines fij denote fastest time chassis starting point station sij ultimate goal determine fastest time chassis factory denote chassis station factory exit faster ways fastest entire factory easy reason f11 f21 station chassis directly station compute fij focusing f1j recall fastest station s1j fastest station s1j1 directly station s1j fastest station s2j1 transfer station s1j case f1j f1j a1j case f1j f2j t2j1 a1jsymmetricallycombining equations œ155 recursive equations figure fij values computed equations fij values values optimal solutions subproblems track construct optimal solution define li number station fastest station sij avoid defining li1 station precedes station define station fastest entire factory lij values trace fastest values lij figure trace fastest factory starting station s16 l16 station s25 continuing l25 station s24 l24 station s13 l13 station s22 l22 station s11 step computing fastest times point simple matte write recursive algorithm based equation recurrences compute fastest factory problem recursive algorithm running time exponential rij number references fij recursive algorithm equation recurrences exercise asks rij f11 referenced n1 times exercise asks total number references fij values compute fij values order recursive observe fij depends values f1j f2j computing fij values order increasing station numbers jšleft figure bšwe compute fastest factory time takes time fastestway procedur takes input values aij tij number stations assembly fastestwaya f11 e1 a11 f21 a21f1j a1j f2j t2j1 a1j f1j f1j l1j f1j f2j t2j1 a1j l1j f2j a2j f1j t1j1 a2j f2j f2j a2j l2j f2j f1j t1j1 a2j l2j f1n f2n f1nf2n fastestway works lines œ2 compute f11 f21 equations loop lines œ13 computes fij lij lines œ8 compute f1j l1j equation lines œ13 compute f2j l2j equation finally lines œ18 compute equation lines œ2 œ18 constant time iterations loop lines œ13 takes constant time entire procedure takes time view process computing values fij li filling table entries referring figure tables values fij lij left column entry fij values f1j f2j knowing ready computed stored determine values simply table step constructing fastest factory computed values fij lij construct sequence stations fastest factory discussed figure procedure prints stations decreasing order station number exercise asks modify print increasing order station number printstationsl print station downto lij print station figure printstations produce output station station station station station station exercises modify printstations proce dure print stations increasing order station number hint recursion exercises equations substitution method rij number references fij recursive gorithm equals exercises result exercise total numbe references fij values n1 exercises tables fij lij values total entries reduce space requirem ents total entries computing print stations fastest factory exercises professor canty conjectures exist aij tij values fastestway produces lij values l1j l2j station number assuming transfer costs tij nonnegative professor wrong matrixchain multiplication dynamic programming algorithm solves problem matrix chain multiplication sequence chain matrices multiplied compute product evaluate expression standard algorithm multiplying pairs matrices subroutine parenthesized resolve ambiguities matrices multiplied product matrices fully parenthesized single matrix product fully parenthesized matrix products surrounded parentheses matrix multiplication associative parenthesizations yield product chain matrices product fully parenthesized distinct ways parenthesize chain matrices dramatic impact cost evaluating product cost multiplying matrices standard algorithm followi pseudocode attributes rows columns numbers rows columns matrix matrixmultiplya columnsa rowsb error incompatible dimensions rowsa columnsb columnsa ai return multiply matrices compatible number columns equal number rows matrix matrix matrix matrix time compute dominated number scalar multiplications pqr express costs terms number scalar multiplications illustrate costs incurred parenthesizations matrix product problem chain matrices suppose dimensions matrices multiply parenthesization perform scalar multiplications compute matrix product scalar multiplications multiply matrix total scalar multiplications multiply parenthesization perform scalar multiplications compute matrix product scalar multiplications multiply matrix total scalar multiplications computing product parenthesization times faster matrixchain multiplication problem stated chain matrices matrix ai dimension pi1 fully parenthesize product minimizes number scalar multiplications note matrixchain multiplicati problem multiplying matrices goal determine orde multiplying matrices lowest cost typically time invested determining optimal order paid time saved performing matrix multiplications performing scalar multiplications counting number parenthesizations solving matrixchain multipli cation problem dynamic programming convince exhaustively checking parenthesizations yield efficient algorithm denote number alte rnative parenthesizati ons sequence matrices matrix fully parenthesize matrix product fully parenthesized matrix product product fully parenthesized matrix subproducts split subproducts occur kth matricesrecurrence problem asked solution recurrence sequence catalan numbers grows nn32 simpler exercise exercise solution recurrence number solutions exponential bruteforce method exhaustiv search poor strategy determining optimal pare nthesization matrix chain step structure optimal parenthesization step dynamicprogramming paradi gm optimal substructure construct optimal solution problem optimal solutions subproblems matrixchain multiplicati problem perform step convenience adopt notation aij matrix evaluating product ai ai1 observe problem nontrivial parenthesization product ai ai1 split product ak ak1 integer range compute matrices aik ak1j multiply togeth produce final product aij cost parenthesization cost computing matrix aik cost computing ak1j cost multiplying optimal substructure proble suppose optimal parenthesization ai ai1 splits product ak ak1 parenthesization prefix subchain ai ai1 ak optimal parenthesization ai ai1 optimal parenthesization ai ai1 ak costly parenthesize ai ai1 ak substituting parenthesization optimal parenthesization ai ai1 produce parenthesization ai ai1 cost lower optimum contradiction obser vation holds parenthesization subchain ak1 ak2 optimal parenthesization ai ai1 optimal parenthesization ak1 ak2 optimal substructure construct optimal solution problem optimal solutions subproblem solution nontrivial instance matrixchain multipli cation problem requires split product optimal solution optimal solutions subproblem instances build optimal solution instance matrixchain multiplication problem splitting problem tw subproblems optimally parenthesizing ai ai1 ak ak1 ak2 finding optimal solutions subprobl instances combining optimal subproblem solutions ensure search correct place split product considered pos sible places examined optimal step recursive solution define cost optimal solution recursively terms optimal solutions subproblems matrixchain multiplicati problem pick subproblems problems determining minimu cost parenthesization ai ai1 mi minimum number scalar multip lications needed compute matrix aij problem cost cheapest compute a1n m1 define mi recursively problem trivial chain consists matrix aii ai scalar multiplications compute product micompute mi advantage structure optimal solution step assume optimal parenthesization splits product ai ai1 ak ak1 mi equal minimum cost computing subproducts aik ak1j cost multiplying matrices toge ther recalling matrix ai pi1 computing matrix product aik ak1j takes pi1 scalar multiplications mi mi mk pi1 recursive equation assume values optimal parenthesization values check recursive definition minimum cost parenthesizing product ai ai1 mi values costs optimal solutions subproblems track construct optimal solution define split product ai ai1 optimal parenthesization equals mi mi mk pi1 step computing optimal costs point simple matter wr ite recursive algorithm based recurrence compute minimum cost m1 multiplying algorithm exponential time bruteforce method checking parenthesizing product observation point subproblems problem choice satisfying recursive algorithm encounter subproblem times branches recursion tree property overlapping subproblems hallmark applicability dynamic programming rst hallmark optim substructure computing solution recurrence recursively perform step dynamicprogramming paradigm pute optimal cost tabular bottomup approach eudocode assumes matrix ai dimensions pi1 input sequence p0 lengthp procedure auxiliary table m1 storing mi costs auxiliary table s1 records achieved optimal cost computing mi table construct optimal solution order correctly implement bottomup pproach determine entries table computing mi equation cost mi computing matrixchain product matrices depends costs computing matrixchain products fewer matrices matrix aik product matrices matrix ak1j product matrices algor ithm table manner corresponds solving parenthesization problem matrix chains increasing length matrixchainorderp lengthp michain length mimi mk pi1 pkpj mi mi return algorithm computes miminimum costs chains length lines œ3 recurrence compute mi minimum costs chains length execution loop lines œ12 time loop computes mi minimum costs chains length step mi cost computed lines œ12 depends table entries mi mk computed figure illustrates procedure chain matrices defined mi portion table strictly main diagonal figure table rotated main diagonal horizontally matrix chain listed layout minimum cost mi multiplying subchain ai ai1 matrices ound intersection lines running northeast ai northwest horizontal row table entries matrix chains length matrixchainorder computes rows left row entry mi computed products pi1 entries southwest southeast mi figure tables computed matrixchainorder matrix dimensions matrix dimension a5 a6 tables rotated main diagona runs horizontally main diagonal upper triangle table upper triangle table minimum number scalar multiplications multiply matrices m1 darker entries pairs shading computing simple inspection nested loop structure matrixchainorder yields running time on3 algorithm loops nested deep loop takes values exercise asks running time algorithm fact n3 algorithm requires space store tables matrixchainorder efficient exponentialtime method enumerating pa renthesizations checking step constructing optimal solution matrixchainorder determines optimal number scalar multiplications needed compute matrixchain product directly multiply matrices difficult onstruct optimal solution computed stored table s1 entry records optimal parenthesization ai ai1 splits product ak ak1 final matrix multiplication computing a1n optimally a1s1n as1 n1n earlier matrix multiplications computed recursively s1 s1 determines matrix multiplication computing a1s1n ss1 determines matrix multiplication computing as1n1n recursive procedure prints optimal parenthesization ai ai1 table computed matrix chainorder indices initial printoptimalparens prints optimal parenthesization printoptimalparenss print ai print printoptimalparenss printoptimalparenss print figure printoptimalparenss prints parenthesization a5a6 exercises optimal parenthesization matrixc hain product sequence dimensionsexercises recursive algorit hm matrixchainmultiplya performs optimal matrixchain multiplicati sequence matrices table computed matrixc hainorder indices initial matrixchainmultiplya exercises substitution method solution recurrence exercises number times table entry mi referenced computing table entries matrixchainorder total number references entire table hint equation exercises parenthesization nelement expression pairs parentheses elements dynamic programming worked examples dynamicprogramming method wondering method applies engineering perspective dynamicprogramming solution problem examine key ingredients optimi zation problem order dynamic programming applicable optimal substr ucture overlapping subproblems variant method called memoization advantage overlappingsubproblems property optimal substructure step solving optimization probl dynamic programming characterize structure optimal soluti recall problem exhibits optimal substructure optimal solution problem optimal solutions subproblems problem exhibits optimal subs tructure good clue dynamic programming apply greedy strategy applies chapter dynamic programming build optimal solution problem optimal solutions subproblems car ensure range subproblems includes optimal solution discovered optimal substructure problems examined chapter observed fastest station contained fastest station observed optimal parenthesization ai ai1 splits product ak ak1 optimal solutions problems parenthesizing ai ai1 ak ak1 ak2 common pattern discovering optimal substructure solution problem cons ists making choice choosing preceding assemblyline station choosing split matrix chain making choice leaves subproblems solved suppose problem choice leads optimal solution concern determine choice assume choice determine subproblems ensue characterize space subproblems solutions subproblems optimal solution problem optimal ing cutandpaste technique supposing subproblem solu tions optimal deriving contradiction cutting nonoptimal subproblem solution pasting optimal solution original problem contradicting supposition optimal solution subproblem typically sim ilar cutandpaste argument modified effort characterize space subproblems good rule thumb space simple expand space subproblems considered assemblyline schedul ing fastest entry factory stations s1 subproblem space worked general space subproblems conversely suppose constrain subproblem space matrixchain multiplication matrix products form optimal parenthesization split product ak ak1 guarantee equals subproblems form ak ak1 ak2 subproblem form problem subproblems vary ends vary subproblem ai ai1 optimal substructure varies problem domains ways subproblems optimal solution original problem choices determining subproblems optimal solution assemblyline scheduling optimal solution subproblem choices order determine optimal solution fastest station sij fastest s1 fastest whichever represents subproblem optimally solve matrix chain multiplication subchain ai ai1 serves subproblems choices matrix ak split product subproblemsšparenthesizing ai ai1 ak parenthesizing ak1 ak2 ajšand solve optimally determine optimal solutions subproblems choose candidates informally running time dynamicp rogramming algorithm depends product factors number subproblems choices subproblem assemblyline scheduling subproblems choices examine yielding running time matrixchain multiplication subproblems choices on3 running time dynamic programming optimal substructure bottomup fashion optimal solutions subproblems lved subproblems optimal solution problem finding optimal solu tion problem entails making choice subproblems solving problem cost problem solution subproblem costs cost directly attributable choice assemblyline scheduling exampl solved subproblems finding fastest stations s1 chose stations preceding station cost attributable choice depends switch lines stations cost ai stay j1 aij switch matrixchain ltiplication determined optimal parenthesizations subchains ai ai1 chose matrix ak split product cost attributable choice term pi1 chapter examine greedy algorithms similarities dynamic programming problems greedy algorithms apply optimal substructure salient differ ence greedy algorithms dynamic programming greedy algorithms optimal substructure topdown fashion finding optimal solutions subproblems making choice greedy algorithms choicešthe choice timešand solve subproblem subtleties careful assume timal substructure applies problems directed graph vertices unweighted shortest path path consisting fewest edges path simple removing cycle path produces path fewer edges unweighted longest simple path simple path consisting edges include requirement simplicity traverse cycle times lik create paths arbitrarily large number edges unweighted shortestpath problem exhibits optimal substructure suppose problem nontrivial path intermediate vertex note decompose path subpaths number edges equal sum number edges number edges claim optimal shortest path shortest path cut andpaste argument path fewer edges cut paste produce path fewer edges contradicting optimality symmetrically shortest path shortest path intermediate vertices finding shortest path shortest path choosing intermediate vertex yields shortest path variant observation optimal substructure shortest path tween pair vertices weighted directed graph tempting assume problem finding unweighted longest simple path exhibits optimal substructure decompose longest simple path subpaths mustnt longest simple path mustnt longest simple path answer figure path longest simple path longest simple path path simple path longer longest simple path path simple path longer figure directed graph showing problem finding longest simple path unweighted directed graph optimal substructure path longest simple path subpath longest simple path subpath longest simple path longest simple pa ths optimal substructure lacking assemble legal solution problem solutions subproblems combine longest simple paths path simple problem finding unweighted longest simple path sort optimal substructure efficient dynamicprogramming algorithm problem fact problem npcomplete whichšas chapter šmeans solved polynomial time substructure longest simp path shortest path subproblems solution problem longest shortest paths subproblems finding longest simple path independent shortest paths subproblems independent solution subproblem affect solution subproblem problem figure problem finding longest simple path subproblems finding longest simple paths subproblems choose path vertices longer vertices subproblem combination solutions subproblems yield path simple vertex problem solve required path vertex splicing subproblem solutions vertex vertices subproblem solution prevents subproblem solution solve subprob lem solve optimally subproblems independent looked resources solving subproblem resources vertices rendered unavailable subproblem subproblems independent nding shortest path answer nature subproblems share res ources claim vertex shortest path splice shortest path shortest path produce shortest path assured vertex paths suppose vertex appears decompose optimal substructure problem path edges edges construct path path edges contradicts assumption shortest path assured subproblems shortestpath problem independent problems examined sections independent subproblems matrix chain multiplication subproblems multiplying subchains aiai1 ak ak1ak2 subchains disjoint matrix included assemblyline scheduling determ ine fastest station sij fastest ways stations s1j1 s2j1 solution fastest station include subproblem solutions subproblem automatically independent solution overlapping subproblems ingredient optimization problem dynamic programming applicable space subproblems small sense recursive algorithm problem solves ubproblems generating subproblems typically tota number distinct subproblems polynomial input size recursive algorithm revisits problem optimization problem overlapping subproblems3 contrast problem divide conquer appro ach suitable generates brandnew problems step recursion dyna micprogramming algorith typically advantage overlapping subproblems solving subproblem storing solution table looked needed constant time lookup examined recursive solution assemblyline scheduling references fij tabular solution takes exponentialtime recursive algorithm linear time illustrate overlappingsubproblems propert greater reexamine matrixchain multiplication problem referring figure observe matrixchainorder repeatedly solution subproblems lower rows solving subproblems higher rows entry m3 referenced times computations m1 m3 m3 m3 recomputed time looked increase running time dramatic inefficient ecursive procedure determines mi minimum number scalar multiplications needed compute matrixchain product aij aiai1 procedure based directly recurrence recursivematrixchainp return mirecursivematrixchainp recursivematrixchainpk pi1 mi mi return mi figure recursion tree produced recursivematrixchainp node labeled values parameters observe pairs values occur times figure recursion tree computation recursivematrixchain node parameters computations performed shaded subtree replaced single table lookup memoizedmatrixchainp fact time compute m1 recursive procedure exponential denote time cursivematrixchain compute optimal parent hesization chain matrices assume execution lines œ2 lines œ7 unit time inspection procedure yields recurrence notingterm appears collecting summation rewrite recurrence prove substitution method n1 basis easyinductively completes proof tal work performed recursivematrixchainp exponential compare topdown recursive algorith bottomup dynamicprogramming algorithm efficient becau takes advantage overlapping subproblems property subproblems dynamic programming algorithm solves recursive algorithm hand repeatedly resolve subproblem time reappears recursion tree recursion tree natural recu rsive solution problem subproblem repeatedly total number subproblems small good idea dynamic programming work reconstructing optimal solution practical matter store choi subproblem table reconstruct informa tion costs stored assembly scheduling stored li station preceding sij fastest sij alternatively filled entire fij table determine station precedes s1j fastest sij extra work f1j f1j station s1 precedes s1 fastest s1 case f1j f2jprecedes s1 assemblyline scheduling reconstructing predecessor stations takes o1 time station lij table matrixchain multiplication table saves work reconstructing optimal solution suppose maintain table filled table mi optimal subproblem costs choices determining subproblems optimal solution parenthesizing ai ai1 constant time reconstruct subproblems chose soluti problem storing matrix split product ai ai1 reconstruct choice o1 time memoization variation dynami programming offers efficiency usual dynamicprogramming approach maintaini topdown strategy idea memoize natural inefficient recursiv algorithm ordinary dynamic programming maintain table subprob lem solutions control structure filling table recursive algorithm memoized recursive algorithm maintains entry table solution subproblem table entry initially special entry filled subproblem encountered execution recursive algorithm solution computed stored table subsequent time subproblem encountered valu stored table simply looked returned memoized version recursivema trixchain memoizedmatrixchainp lengthp mi return lookupchainp lookupchainp mi return mi mi lookupchainp lookupchainpk pi1 mi mi return mi memoizedmatrixchain matrixchainorder maintains table m1 computed values mi minimum number scalar multiplications needed compute matrix aij table entry initially entry filled lookupchain executed mi procedure simply retu rns computed cost mi cost computed recursivematrixchain stored mi returned convenient unfilled table entry initialize mi recursivematr ixchain lookupchain returns mi computes time lookupchain calle parameters figure illustrates memoizedmatrix chain saves time compared recursivematrixchain shaded subtrees represent values looked computed dynamicprogramming algorithm matrixchainorder procedure memoizedmatrixchain runs on3 time table entries initialized memoizedmatrixchain categorize calls lookup chain types calls mi lines œ9 executed calls mi lookupchain simply returns calls type table entry calls type recursive calls calls firs type lookupchain recursive calls on3 calls type type takes o1 time type takes time time spent recurs ive calls total time on3 memoization turns ntime algorithm on3time algorithm summary matrixchain multiplication problem solved topdown memoized algorithm bottomup dynamicprogramming algorithm on3 time methods advantage overla ppingsubproblems property subproblems total methods computes solution subproblem memoization natu ral recursive algorithm runs exponential time solved subproblems repeatedly solved general practice subproblems solved bottomup dynamic programming algorithm outperforms topdown memoi zed algorithm constant factor overhead recursio overhead maintaining table problems regular pattern table accesses dynamicprogramming algorithm exploited reduce time space requirements alternatively subproblems subproblem space solved memoized solution advantage solv ing subproblems required exercises efficient determine optimal number multiplications matrix chain multiplication problem enumerating ways parenthesizing product computing number multiplications running recursivematrix chain justify answer exercises draw recursion tree mergesort procedure array elements explain memoization effective speeding good divide conquer algorithm mergesort exercises variant matrixchain ltiplication problem goal parenthesize sequence matrices maximize minimize number scalar multiplications problem exhibit optimal substructure exercises assemblyline schedu ling overlapping subproblems exercises stated dynamic programming solv subproblems choose optimal solution prob lem professor capulet claims solve subproblems order optimal solution suggests optimal solution matr ixchain multiplication problem choosing matrix ak split subproduct ai ai1 selecting minimize quantity pi1 solving subproblems instance matrixchain multiplication problem greedy approach yields suboptimal solution misspelling word memoization memorization memoization memo technique consists recording term unweighted distinguish problem finding shortest paths weighted edges chapters breadth search technique chapter solve unweighted problem strange dynamic progr amming relies subproblems independent overlapping requirements sound contradictory notions points axis subproblems problem independent share resources subproblems overlapping subprobl occurs subproblem problems approach presupposes set subproblem para meters relation table positions subproblems established approach memoize hashing subproblem parameters keys longest common subsequence biological applications compare dna organisms strand dna consists string molecules called bases bases adenine guanine cytosine thymine representing bases initial letters strand dna expresse string finite set appendix definition string dna organism s1 accggtcgagtgcgcggaagccggccgaa dna organism gtcgttcggaatgccgttgctctgtaaa goal comparing strands dna determine strands measure closely organisms similarity defined ways dna strands su bstring chapter explores algorithms solve problem s1 substring alternatively strands number needed turn small problem notion measure similarity strands s1 finding strand s3 bases s3 s1 bases order consecutively longer strand s3 s1 longest strand s3 gtcgtcggaagccggccgaa formalize notion similarity longestcommons ubsequence problem subsequence sequence sequence elements left formally sequence xm sequence z1 z2 zk subsequence exists stri ctly increasing sequence i1i2 ik indices xij zj subsequence sequence sequences sequence common subsequence subsequence sequence common subsequence sequence longest common subsequence lcs length sequence common length sequence lcs sequence common subsequence length greater longestcommonsubsequence problem sequences xm y1 yn maximumlength common subsequence lcs problem solved efficiently dynamic programming step characterizing longest common subsequence bruteforce approach solving lcs problem enumerate subsequences check subsequence subsequence keeping track longest subsequence subsequence corresponds subset indices subsequences approach requires exponential time making impractical long sequences lcs problem optimalsubstructur property theorem natural classes subproblems correspond pairs prefixes input sequences precise sequence xm define ith prefix x4 x0 sequence theorem optimal subs tructure lcs xm y1 yn sequences z1 z2 zk lcs xm yn zk xm yn zk1 lcs xm1 yn1 xm yn zk xm implies lcs xm1 xm yn zk yn implies lcs yn1 proof zk xm append xm yn common subsequence length contradicting supposition longest common subsequence zk xm yn prefix zk1 length common subsequence xm1 yn1 lcs suppose purpose contradiction common subsequence xm1 yn1 length greater appending xm yn produces common subsequence length greater contradiction zk xm common subsequence xm1 common subsequence xm1 length greater common subsequence xm contradicting assumption lcs proof symmetric characterization theorem lcs sequences lcs prefixes sequences lcs problem optimalsubstructure property recursive solution overlappingsubproblems property moment step recursive solution theorem implies subproblems examine finding lcs xm y1 yn xm yn lcs xm1 yn1 appending xm yn lcs yields lcs xm yn solve subproblems finding lcs xm1 finding lcs yn1 whichever lcss longer lcs cases exhaust possibilities optimal subproblem solutions lcs overlappingsubproblems property lcs problem lcs lcss yn1 xm1 subproblems subsubpr oblem finding lcs xm1 yn1 subproblems share subsubproblems matrixchain multiplication problem recursive solution lcs problem involves establishing recurrence optimal solution define length lcs sequences sequences length lcs length optimal substructure lcs problem recursive formula observe recursive formulation condition problem restricts subproblems subproblem finding lcs xi1 yj1 stead subproblems finding lcs yj1 xi1 previous dynamicprogramming algorithms examinedšfor asse mblyline scheduling matrixchain multiplicationšno subproblems ruled conditions problem finding lcs dynamicprogramming algor ithm rules subproblems based conditions problem editdistance problem problem characteristic step computing length lcs based equation easily write exponentialtime recursive algorithm compute length lcs sequences distinct subproblems dynamic ogramming compute solutions procedure lcslength takes sequences xm y1 yn inputs stores values table c0 entries computed rowmajor order row filled left row maintains table simplify construction optimal solution intuitively points table entry optimal subproblem solution chosen computing procedure returns tables length lcs lcslengthx lengthx lengthy c0 return figure tables produced lcslength sequences running time procedure omn table entry takes o1 time compute figure tables computed lcslength sequences square row column arrow entry šthe lower righthand corner tablešis length lcs entry depends values entries computed reconstruct elements lcs follow arrows lower righthand corner path shaded path corresponds entry highlighted member lcs step constructing lcs table returned lcslength construct lcs xm y1 yn simply bm trace table arrows encounter entry implies element lcs elements encountered reverse order method recursive procedure prints lcs proper forward order initial invocation printlcsb lengthx lengthy printlcsb return printlcsbprint elseif printlcsb printlcsb table figure procedure prints bcba procedure takes time decremented stage recursion improving code developed algorithm improve time space true straightforward dynamicprogramming algorithms simplify code impr ove constant factors yield asymptotic improvement performance yield substantial asymptotic savings time space eliminate table altogether entry depends table entries determine o1 time values compute inspecting table reconstruct lcs time procedure printlcs exercise asks pseudocode save space method aux iliary space requirement computing lcs asymptotically decrease space table reduce asymptotic ace requirements lcslength rows table time row comput previous row fact space row compute length lcs exercise improvement works eed length lcs reconstruct elements lcs smaller tabl retrace steps time exercises determine lcs exercises reconstruct lcs completed table original sequences xm y1 yn time table exercises memoized version lcslength runs omn time exercises compute length lcs min entries table o1 additional space min entries o1 additional space exercises on2time algorithm longest monot onically increasing subsequence sequence numbers exercises lg ntime algorithm longest monotonically increasing subsequence sequence numbers hint observe element candidate subsequence length large elem ent candidate subsequence length maintain candidate subsequences linking input sequence optimal binary search trees suppose designing program tran slate text english french occurrence english word text french equivalent perform lookup operations build binary search tree english keys french equivalents satellite ta search tree individual word text total time spent search ing low ensure olg search time occurrence redblack tree balanced binary search tree frequencies case frequently word appears root rarely word mycophagist appears root organization slow translation number nodes vi sited searching key binary search tree depth node key occur frequently text nearer root text french translation binary search tree organize binary sear tree minimize number nodes visited searches word occurs optimal binary search tree formally sequence k1 k2 kn distinct keys sorted order k1 k2 kn build binary search tree keys key ki probability search ki searches values dummy keys d0 d1 dn representing values d0 represents values k1 dn represents lues greater kndummy key represents values ki ki1 dummy key probability qi search correspond figure binary search trees set keys key ki internal node dummy key leaf search succe ssful finding key ki unsuccessful finding dummy key figure binary search trees set keys probabilities qi binary search tree expected search cost binary search tree expected search cost tree optimal probabilities searches key dummy key determine expected cost search binary search tree assume actual cost search number node examined depth node search expected cost search deptht denotes nodes depth tree equality equation figure calculate expected search cost node node node depth probability contribution k1k2k3k4k5d0d1node depth probability contributiond3d4d5total set probabilities goal construct binary search tree expected search cost smallest tree optimal binary search tree figure optimal binary search tree probabilities figure caption expected cost optimal binary search tree tree height smallest construct optimal binary search tree putting key greatest probability root key k5 greatest search probability key root optimal binary search tree k2 lowest expected cost binary search tree k5 root matrixchain multiplication exhaustive checking possibilities fails yield efficient algorithm label nodes nnode binary tree keys k1 k2 kn construct binary search tree add dummy keys leaves problem number binary trees nodes nn32 exponential number binary arch trees examine exhaustive search surprisingly solv problem dynamic programming step structure optimal binary search tree characterize optimal substructure optim binary search trees start observation subtrees subtree binary search tree keys contiguous range ki addition subtree keys ki leaves dummy keys di1 state optimal substructure optimal binary search tree subtree keys ki subtree optimal subproblem keys ki dummy keys di1 usual cutandpaste argument applies subtree expected cost lower cut paste binary search lower expected cost contradicting optimality optimal substructure construct optimal solution problem optimal soluti ons subproblems keys ki keys kr root optimal subtr keys left subtree root kr keys ki kr1 dummy keys di1 dr1 subtree keys kr1 dummy keys long examine candidate roots kr determine optimal binary search trees ki kr1 kr1 guaranteed optimal binary search tree worth noting ubtrees suppose subtree keys ki select ki root argument kis left subtree keys ki ki1 natural interpret sequence keys bear mind subtrees dummy keys adopt convent ion subtree keys ki ki1 actual keys single dummy key di1 symmetrically select root kjs subtree keys subtree actual keys dummy key step recursive solution ready define optimal solution recursively pick subproblem domain finding optimal binary search tree ontaining keys kiactual keys dummy key di1 define expected cost searching optimal binary search tree keys ki ultimately compute e1 easy case occurs dummy key di1 expected search cost qi1 select root kr ki optimal binary search tree keys ki kr1 left subtree optimal binary search tree keys kr1 subtree expected search cost subtree subtree node depth node subtree increases equation expected search cost subtree increases sum probabilities subtree subtree keys ki denote sum probabilities kr root optimal subtree keys kiwr noting wr rewrite recursive equation assumes node kr root choose root lowest expected search cost final recursive formulation values expected search costs optimal binary search trees track structure optimal binary search trees define rooti kr root optimal bina search tree keys ki compute values rooti leave construction optimal binary search tree values exercise step computing expected search cost optimal binary search tree point noticed milarities characterizations optimal binary search trees matrixchain multiplication problem domains subproblems consist contiguous subran ges direct recursive implementation equation inefficient direct recursive matrixchain multiplication algorithm store values table e1order subtree dummy key dn compute store start order subtree dummy key d0 compute store e1 entries table rooti recording root subtree keys ki table entries table efficiency compute scratch time computing jšwhich additionsšwe store values table w1 base case compute qi1 compute compute values time pseudocode takes inputs probabilities q0 qn size returns tables root optimalbstp qi1 qi1 rooti return root description ity matrixchainorder procedure operation procedure fairly straightforward loop lines œ3 initializes values loop lines œ13 recurrences compute iteration loop computes iteration computes innermost loop lines œ13 candidate determine key kr root optimal nary search tree keys ki loop saves current root finds key root figure tables rooti computed procedure optimalbst key distribution figure matrixchain multiplication tables rotated diagonals horizontally optimalbst computes rows left row figure tables rooti computed optimalbst key distribution figure tables rotated diagonals horizontally optimalbst procedure takes n3 time matr ixchainorder easy running time on3 loops nested deep loop takes values loop indices optimalbst bounds matrixchainorder directions matrixchainord optimalbst procedure takes n3 time exercises write pseudocode pro cedure constructoptimalbstroot table root outputs structure optimal nary search tree figure procedure print structure k2 root k1 left child k2 d0 left child k1 d1 child k1 k5 child k2 k4 left child k5 k3 left child k4 left child k3 d3 child k3 d4 child k4 d5 child k5 optimal nary search tree figure exercises determine cost structure optimal binary search tree set keys probabilities qiexercises suppose maintaining table computed directly equation optimalbst computed change affect ymptotic running time optimalbst exercises knuth roots optimal subtrees root rooti rooti fact modify optimalbst procedure time problems bitonic euclidean travelingsalesman problem euclidean travelingsalesman problem problem determ ining shortest closed tour connects set points plane figure solution point problem general problem npcompl ete solution believed require polynomial time chapter figure points plane unit grid shortest closed tour length tour bitonic shortest bitonic tour set points length bentley suggested simplify problem restrict ing attention bitonic tours tours start leftmost point strictly rightmost point strictly left starting point figure shortest bitonic tour points case polynomialtime algorithm on2time algorithm determining timal bitonic tour assume points xcoordinate hint scan left maintaining optimal possibilities parts tour problems printing neatly problem neatly printing paragraph printer input text sequence lengths l1 measured characters print paragraph neatly number lines hold maximum characters criterion neatness leave space number extra space charac ters nonnegative fit minimize sum lines cubes numbers extra space characters ends lines dynami cprogramming algorithm print paragraph neatly printer analyze running time space requirements algorithm problems edit distance order transform source string text target string y1 perform transformation operations goal produce series transformations change array zšassumed large hold characters needšto hold intermediate initially termination zj maintain current indices operations allowed alter indices initially required examine character transformation sequence transformation operations transformation operations copy character setting zj incrementing operation examines replace character character setting zj incrementing operation examines delete character incrementing leaving operation examines insert character setting zj incrementing leaving operation examines characters twiddle exchange characters copying opposite order setting zj zj setting operation examines kill remainder setting operation examines characters examined operation performed final operation transform source string algorithm ta rget string altruistic sequence operations underlined characters zj operation operation initial strings algorithm _ copy algorithm a_ copy algorithm al_ replace algo rithm alt_ delete algor ithm alt_ copy algorithm altr_ insert algori thm altru_ insert algori thm altrui_ insert algori thm altruis_ twiddle algorithm altruisti_ insert algorith altruistic_ kill algorithm_ altruistic_ note sequences transformation operat ions transform algorithm altruistic transformation operations cost cost operation depends specific application assume operations cost constant assume indi vidual costs copy replace operations combined costs delete insert operations copy replace operations cost sequence transformation operations sum costs ndividual operations sequence sequence cost transforming algorithm altruistic costcopy costreplace costdelete costinser costtwiddle costkill sequences y1 set transformationoperation costs edit distance cost xpensive operation sequence transforms dynamicprogramming gorithm finds edit distance y1 prints optimal operation sequence analyze running time space requirements algorithm editdistance problem generalization problem aligning dna sequences setubal meidanis methods measuring similarity dna sequences aligning method align sequences consists inserting spaces arbitrary locations sequences including sequences length space position position space assign score position position receives score space space space score alignment sum scores individual positions sequences gatcggcat caatgtgaatc alignment atcg gcat caat gtgaatc position scor position score score alignment total scor _ explain cast problem finding optimal alignment edit distance problem subset transformati operations copy replace delete insert twiddle kill problems planning company party professor stewart consulting president corporat ion planning company party company hierarchical structure supervisor relation forms tree rooted president personnel office ranked employee conviviality rating real number order party fun attendees president employee supervisor attend professor stewart tree describes structure corporation leftchild rightsibling representation node tree holds addition pointers employee employ ees conviviality ranking algorithm guest list maximizes sum conviviality ratings guests analyze running time algorithm problems viterbi algorithm dynamic programming directed graph speech recognition edge labeled sound finite set sounds labeled graph formal model person speaking restricted language path graph starting distinguished vertex v0 corresponds sequence sounds produced model label directed pa defined concatenation labels edges path efficient algorithm edgelabeled graph distinguished vertex v0 sequence characters returns path v0 label path exists algorithm return nosuchpath analyze running time algorithm hint concepts chapter suppose edge nonnegative probability traversing edge vertex producing sound sum probabilities edges leaving vertex equals probability path defined oduct probabilities edges view probability path v0 probability random walk v0 follow path choice edge vertex probabilistically probabilities edges leaving extend answer path returned probable path starting v0 label analyze running time algorithm problems moving checkerboard suppose checkerboard checker checker edge board edge board rule step checker squares square square left checker leftmost column square checker rightmost column time square square receive px dollars px pairs legal assume px positive algorithm figures set moves checker edge edge gathering dollars algorithm free pick square edge starting point square edge destination order maximize number dollars gathered runn ing time algorithm problems scheduling maximize profit suppose machine set jobs process machine job processing time profit deadline machine process job time job uninterruptedly consecutive time units job completed deadline receive profit completed deadline receive profit algorithm schedule obtains maximum profit assuming processing times integers running time algorithm subject text edible mushrooms mycophagist root chapter notes bellman began systematic study dynamic programming word programming linear programming refers tabular solution method optimization tech niques incorporating elements dynamic programming earlier bellman provided solid mathematical basis shing lg ntime algorithm matrixchain multiplication problem omntime algorithm longestcommonsubs equence problem appears folk algorithm knuth posed question subquadratic algorithms lcs problem exist masek paterson answered question affirmative algorithm runs omn lg time sequences drawn set bounded size special case element appears input sequence szymanski problem solved lg time extend problem computi string edit distances problem early paper variablelength binary encodings gilbert moore applications constructing optimal binary sear trees case probabilities paper on3time algorithm aho hopcroft ullman algorithm exercise knuth tucker devised algorithm cas probabilities on2 time space subsequently knuth reduced time lg chapter greedy algorithms overview algorithms optimization problems typically sequence steps set choices step optimizati problems dynamic programming determine choices overkill simpler efficient algorithms greedy algorithm choice moment locally optimal choice hope choice lead globally optimal solution chapter explores optimization problems solvable greedy algorithms reading chapter read dynamic programming chapter greedy algorithms yield optimal solutions problems examine simple nontrivial prob lem activityselection problem greedy algorithm efficiently computes solution arrive greedy algorithm dynamicprogramming solution showing greedy choices arrive optimal solution reviews basic elements greedy approach givi direct approach proving greedy algorithms correct dynami cprogrammingbased process presents application gree techniques design datacompression huffman codes investigate theory underlying combinatorial structures called matroids eedy algorithm produces optimal solution finally illustrates application matroids problem scheduling unittime tasks deadlines penalties greedy method powerful works wide range problems chapters algorithms viewed applications greedy method including minimumspanningtree algorithms chapter dijkstras algorithm shortest paths single source chapter chvatals gree setcovering heuristic chapter minimumspanningtree algorithms classic greedy method chapter chapter read independently read activityselection problem problem scheduli competing activities require exclusive common resource goal selecting maximum size set mutually compatible activities suppose set proposed activities resource lecture hall activity time activity ai start time finish time selected activity ai takes place halfopen time interval activities ai compatible intervals overlap ai compatible activityselection problem select maximum size subset mutually compatible activities set activities sorted monotonically increas ing order finish time shortly advantageous activities rted order subset a9 a11 consists mutually compatible activities maximal subset subset a8 a11 larger fact a8 a11 largest subset mutually compatible activ ities larg subset a9 a11 solve problem steps start formulati dynamicprogramming solution problem combine optimal solutions subproblems form optimal solution orig inal problem seve ral choices determining subproblems optimal solution observe choicešthe greedy choicešand greedy choice subproblems guaranteed nonempty subproblem remains based observations develop recursive greedy algorithm solve activityscheduling problem complete process developing greedy solution converting recursive algorithm iterative steps involved typical development greedy algorithm illustrate relationship greedy algorithms dynamic programming optimal substructure activityselection problem mentioned start developing dynamicprogramming solution activity selection problem chapter step optimal substructure construct optimal solution problem timal solutions subproblems chapter define appr opriate space subproblems start defining sets sij ak sk fk sij subset activities start activity ai finishes finish activity starts fact sij consists activities compatible ai compatible activities finish ai finishes activities start earlier starts order represent entire problem add fictitious activities a0 an1 adopt conventions f0 sn1 s0n1 ranges restrict ranges assume activities sorted monotonically increas ing order finish time claim sij ø suppose ther exists activity ak sij ai sorted order sk fk contradicts assumption ai sorted order conclude assuming sorted activities monotonically increasing order finish time space subproblems select maximumsize subset mutually compatible activities sij knowing sij substructure activityselection problem nonempty subproblem sij1 suppose solution sij includes activity ak sk fk activity ak generates subproblems sik activities start ai finishes finish ak starts skj activities start ak finishes finish starts consists subset activities sij solution sij union solutions sik skj activity ak number activities solution sij size solution sik size solution skj ak optimal substructure problem suppose optimal solution aij sij includes activity ak solutions aik sik akj skj optimal solution sij optimal usual cut andpaste argument applies solution sik included activities aik cut aik aij paste producing solution sij activities aij assumed aij optimal solution derive contradiction sim ilarly solution skj activities akj replace akj produce solution sij activities aij optimal substructure construct optimal solution problem optimal solutions subproblem solution nonempty subproblem sij includes activity ak optimal solution optimal solutions subproblem instances sik skj build maximumsize subset mutually compatible activities sij splitting problem subproblems finding maximumsize subsets mutually compatible activities sik skj finding maximumsize subsets aik akj mutually compatible activities subproblems forming maximumsize subset aij mutually compatible activities optimal solution entire problem solution s0n1 recursive solution step developing dynamicprogra mming solution recursively define optimal solution activityselection problem number activities maximumsize subset mutually compatible activities sij sij ø nonempty subset sij ak maximumsize subset mutually compatible activities sij maximumsize subsets mutually compatible activities subproblems sik skj equation recurrence ck recursive equation assume values maximumsize subset sij values check recursive definition converting dynamicprogramming solution greedy solution point straightforward exercise write tabular bottomup dynamic programming algorithm based recurrence fact exercise asks key observations simplify solution theorem nonempty subproblem sij activity sij earliest finish time fm min fk ak sij activity maximumsize subset mutually compatible activities sij subproblem sim choosing leaves subproblem smj nonempty proof prove bit simpler suppose sim nonempty activity ak sk fk fm ak sij earlier finish time contradicts choice conclude sim prove suppose aij maximumsize subset mutually compatible activities sij order activities aij monotonically increasing order finish time ak activity aij ak maximumsize subset mutually compatible activities sij ak construct subset activities disjoint activities aij ak activity aij finish fm fk noting number activities aij maximumsize subset mutu ally compatible activities sij includes theorem valuable recall optimal substructure varies subproblems optimal solution original problem choices determining subproblems dynamic programming solution subproblems optimal solution ji1 choices solving subproblem sij theorem reduces quantities subproblem optimal solution subproblem guaranteed solving subproblem sij choice earliest finish time sij fortunately easily determine activity addition reducing number subproblems number choices theorem yields benefit solve subpr oblem topdown fashion bottomup manner typically dynamic programming solve subproblem sij choose activity sij earliest finish time add solution set activities optimal solution subproblem sij chosen solution smj optimal solution sij solve smj solving sij solve sij choose activity sij earliest finish time solve smj note pattern subproblems solve original problem s0n1 suppose choose activity s0n1 earliest finish time sorted activities monotoni cally increasing finish times f0 m1 subproblem suppose choose activity earliest finish time case subproblem continuing subproblem form activity number mi subproblem consists activitie finish number activities varies subproblem subproblem pattern activities choose choose activity earliest finish time finish times activities chosen subproblems strictly increasing time activity monotonically increasing order finish times activity choose solving subproblem earliest finish time legally scheduled activity picked greedy choice sense intuitively leaves opportunity remaining activities scheduled greedy choice maximizes unscheduled time remaining recursive greedy algorithm streamline dynamicprogramming solution treat topdown method ready algorithm works purely greedy topdown fashion straightforw ard recursive solution procedure recursiveactivityselector takes start finish times activities represented arrays starting indices subproblem sij solve returns maximumsize set mutually compatible activities sij assume input activities ordered monotonical ly increasing finish time equation sort order lg time breaking ties arbitrarily initial recursiveactivityselector recursiveactivityselectorsactivity sij return recursiveactivityselectors return ø figure operation algorithm recursive recursive activityselector loop lines œ3 activity sij loop examines ai1 ai2 aj1 finds activity compatible ai activity loop terminates finds activity procedure returns union maximumsize subset smj returned recursive recursiveactivityselectors alternatively loop terminate case examined activities finish times finding compatible ai case sij ø procedure returns ø figure operation recursiveactivityselector activities earlier activities considered recursive horizontal lines fictitious activity a0 finishes time initial recursiveactivity selectors activity selected recursive activities selected shaded activit white considered starting time activity occurs nish time activity arrow points left reject arrow points directly selected recursive recursiveactivityselector returns ø set selected activities a8 a11 assuming activities sorted finish times running time recursiveactivityselector recursive calls tivity examined loop test activity ak examined iterative greedy algorithm easily convert recursive procedure iterative procedure recursiveactivityselector tail recursive problem ends recursive union operation straightforward task transform tailrecursive procedure iter ative form fact compilers programming languages perform task automatically written recursive activityselector works subproblem sij subproblems subproblems consist activities finish procedure greedyactivityselector iterative version procedure recursiveactivityselector assumes input activities ordered monotonically increasing finish time collects selected activities set returns set greedyactivityselectors lengths return procedure works variable indexes addition activity ai recursive version activities considered order monotonically creasing finish time maximum finish time activity lines œ3 select activity initialize activity initialize activity loop lines œ7 finds earliest activity finish sin1 loop considers activity turn adds compatible selected activities activity earliest finish sin1 activity compatible activity suffices equation check start time earlier finish time activity activity compatible lines œ7 add activity set set returned greedyactivityselector precisely set returned recursiveactivityselectors recursive version greedyactivityselector schedules set activities time assuming activities alr eady sorted initially finish times exercises dynamicprogramming algorithm activityselection problem based recurrence algorithm compute sizes defined produce maximumsize subset activities assume inputs sorted equation compare running time solution running time greedyactivityselector exercises suppose selecting activity finish select activity start compatib selected activities approach greedy algorithm prove yields optimal solution exercises suppose set activities schedule large number lecture halls schedule activities lecture halls efficient greedy algorithm determine activ ity lecture hall intervalgraph coloring problem create interval graph vertices activities edges connect incompatible activities smallest number colors required color ery vertex adjacent vertices color corresponds finding fewe lecture halls needed schedule activities exercises greedy approach activity selection problem produces maximumsize set mutually compatible activities exam ple approach selecting activity duration hose compatible selected activities work approaches selecting compatible activity overlaps fewest remaining activ ities selecting compatible remaining activity earliest start time speak sets sij subproblems sets activities clear context referring sij set activities subproblem input set elements greedy strategy greedy algorithm obtains optimal solu tion problem making sequence choices decision point algorithm choice moment chosen heuristic strategy produce optimal solution activityselection problem discusses general properties greedy methods process develop greedy algorithm bit involved typical steps determine optimal substructure problem develop recursive solution prove stage recursion optimal choices greedy choice safe greedy choice subproblems induced greedy choice develop recursive algorithm implements greedy strategy convert recursive algorithm iterative algorithm steps eat dynamicprogramming underpinnings greedy algorithm practice streamline steps designing greedy algorithm develop su bstructure eye making greedy choice leaves subproblem solve optimally activity selection problem defined subproblems sij varied greedy choice restrict subproblems form sin1 alternatively fashioned optimal substructure greedy choice mind dropped ond subscript defined subproblems form ak sk proven greedy choice activity finish combined optimal solution remaining set compatible activities yields optimal solution generally design greedy algorithms sequence steps cast optimization problem whic choice left subproblem solve prove optimal solu tion original problem greedy choice greedy choice safe demonstrate greedy hoice remains subproblem property combine optimal solution subproblem greedy choice arrive timal solution original problem direct process sections chapter beneath greedy algorithm ways cumbersome dynamicprogramming solution greedy algorithm solv optimization problem general greedychoice property optimal substructure key ingredients demonstrate problem properties developing greedy algorithm greedychoice property key ingredient greedychoice property globally optimal solution arrived making locally optimal greedy choice choice choice current problem subproblems greedy algorithms diff dynamic programming dynamic programming choice step choice depends solutions subproblems typically solve dynamicprogramming problems bottomup manner progressing smaller subproblems larger subproblems greedy algorithm choice moment solve subproblem arising choice hoice greedy algorithm depend choices depend future choices solutions subproblems dynamic programming solves subproblems greedy strategy progresses topdown fashion making greedy oice reducing problem instance smaller prove greedy choice step yields globally optimal solution cleverness required typically case theorem proof examines globally optimal solution subproblem solution modified greedy hoice smaller subproblem greedychoice property gains efficiency making choice subproblem activityselec tion problem assuming sorted activities monotonically increasing order finish times needed examine activity frequently cas preprocessing input data structure priority queue greedy choices yielding efficient algorithm optimal substructure problem exhibits optimal substructure optimal solution problem optimal solutions subproblems property key ingredient assessing applicability dynamic programming greedy algorithms optimal substructure recall demonstrated optimal solution subproblem sij includes activity ak contai optimal solutions subproblems sik skj optimal substructure argued knew activity ak construct optimal solution sij selecting ak activities optimal solu tions subproblems sik skj based observation optimal substructure devise recurrence optimal solution direct approach regard ing optimal substructure applying greedy algorithms mentioned luxury assuming arrived subproblem greedy choice original problem argue optimal solution subproblem combined greedy choice yields optimal solution iginal problem scheme implicitly induction subproblems prove maki greedy choice step produces optimal solution greedy versus dynamic programming optimalsubstructure property exploited greedy dynamic programming strategies tempte generate dynamicprogramming solution problem greedy solution suffices mistakenly greedy solution works fact dynamicprogra mming solution required illustrate subtleties techniques investigate variants classical optimization problem œ1 knapsack problem posed thief robbing store finds items ith item worth vi dollars weighs pounds vi integers valuable load carry pounds knapsack integer items called œ1 knapsack problem item left thief fractional item item fractional knapsack problem setup thief fractions items binary œ1 choice item item œ1 knapsack problem gold ingot item fractional knapsack problem gold dust knapsack problems exhibit optimals ubstructure property œ1 problem valuable load weighs pounds remove item load remaining load valuable load weighing wj thief original items excluding comparable fractional problem remove weight item optimal load remaining load valuable load weighing thief original items wj pounds item problems fractiona knapsack problem solvable greedy strategy œ1 problem lve fractional problem compute pound viwi item obeying greedy strategy thief item greate pound supply item exhausted carry takes item greatest pound carry sorting items pound greedy algorithm runs lg time proof fractional knapsack problem greedychoice property left exercise greedy strategy work œ1 knapsack problem problem instance illustrated figure items knapsack hold pounds item weighs pounds worth dollars item weighs pounds worth dollars item weighs pounds worth dollars pound item dollars pound greater pound item dollars pound item dol lars pound greedy strategy item case analysis figure optimal solution takes items leavi solutions involve item suboptimal figure greedy strategy work œ1 knapsack problem thief select subset items weight exceed pounds optimal subset includes items solution item suboptimal item greatest pound fractional knapsack problem items order greatest valu pound yields optimal solution comparable fractional problem greedy strategy takes item yield optimal solution figure item doesnt work œ1 problem thief unable knapsack capacity space lowers effective pound load œ1 problem item inclusion knapsack mpare solution subproblem item included solution subproblem item excluded choice problem formulated rise overlapping subproblemsša hallmark dynamic progra mming dynamic programming solve œ1 problem exercise exercises prove fractional knapsack problem greedychoice property exercises dynamicprogramming solution œ1 knapsack problem runs time number items maximum weight items thief knapsack exercises suppose œ1 knapsack problem der items sorted increasing weight order sorted decreasing efficient algorithm optimal solution variant knapsack problem argue algorithm correct exercises professor midas drives automobile wark reno interstate cars gas tank holds gas travel miles map distances gas stations route professor wishes gas stops efficient method professor midas determine gas stations prove strategy yields optimal solution exercises efficient algo rithm set points real determines smallest set unitlength closed intervals points argue algorithm correct exercises solve fract ional knapsack problem time assume solution problem exercises suppose sets positive integers choose reorder set reordering ai ith element set ith element set receive payoff algorithm maximize payoff prove gorithm maximizes payoff state running time huffman codes huffman codes ffective technique compressing data savings typical depending characteristics data compressed data sequence charac ters huffmans greedy gorithm table frequencies occurrence characters build optimal representing character binary string suppose character data file store compactly observe characters file ccur frequencies figure characters character occurs times frequency thousands fixedlength codewordvariablelength codeword figure charactercoding problem data file characters characters aœf frequencies character ssigned bit codeword file encoded bits variablelength code file encoded bits ways represent file problem designing binary character code code short character represented unique binary string fixedlength code bits represent charactersmethod requires bits code entire file variablelength code considerably fixedlength code frequent characters short codewords infrequent characters long codewords figure code bit string represents bit string represents code requires bits represent file vings fact optimal character code file prefix codes codes codeword prefix codeword codes called prefix codes optimal data compression achievable character code achieved prefix code loss generality restricting attention prefix codes encoding simple binary char acter code concatenate codewords representing character file exam ple variablelength prefix code figure code character file abc denote concatenation prefix codes desirable simplif decoding codeword prefix codeword encoded file unambiguous simply identify initial codeword translate original character repeat decoding process remainder encoded file string parses uniquely decodes aabe decoding process convenient representation prefix code initial codeword easily picked binary tree leaves characters representation interpret binary codeword character path root character left child child figure trees codes note binary search trees leaves rted order internal nodes character keys figure trees coding schemes figure leaf labeled character frequency occurrence internal node labeled sum frequencies leaves subtree tree fixedlength code tree optimal prefix codeoptimal code file represented binary tree nonleaf node children exercise fixedlength code optimal tree figure binary tree codewords restrict attention binary trees alphabet characters drawn character frequencies positive optimal prefix code leaves letter alphabet internal nodes exercise b5 tree prefix code simple matter compute number bits required encode file character alphabet denote frequency file dtc denote depth leaf tree note dtc length codeword character number bits require encode file define cost tree constructing huffman code huffman invented greedy algorithm cons tructs optimal prefix code called huffman code keeping observations proof correctness relies greedychoice property optimal ubstructure demonstrating properties hold developing pseudocode pseudocode clarify algorithm greedy choices pseudocode assume set characters character object defined frequency algorithm builds tree optimal code botto mup manner set leaves performs sequence merging operations creat final tree minpriority queue keyed identify frequent objects merge result merger objects object frequency sum frequencies objects merged huffmanc allocate node leftz extractmin rightz extractmin insertq return extractminq return root tree huffmans algorithm proceeds figure letters alphabet initial queue size merge steps required build tree final tree represents optimal prefix code codeword letter sequence edge labels path root letter figure steps huffmans algorithm frequencies figure contents queue sorted increasing order frequency step trees lowest frequencies merge leaves rectangles character frequency internal nodes circles sum frequencies children edge connecting internal node children labeled edge left child edge child codeword letter sequence labels edges connecting root leaf letter initial set nodes letter œe intermediate stages final tree initializes minpriority queue characters loop lines œ8 repeatedly extracts nodes lowest frequency queue replaces queue node representing merger frequency computed sum frequencies node left child child order arbitrary switching left child node yields code cost mergers node left queueš root code treešis returned analysis running time huffmans algorithm assumes implemented binary minheap chapter set characters initialization performed time buildminheap procedure loop lines œ8 executed times eac heap operation requires time lg loop contributes lg running time total running time huffman set characters lg correctness huffmans algorithm prove greedy algorithm huffman correct problem determining optimal prefix code exhibits greedychoice optimalsubstructure properties lemma greedychoice property holds lemma alphabet character frequency characters lowest frequencies exists optimal prefix code codewords length differ bit proof idea proof tree representing arbitrary optimal prefix code modify tree representing anothe optimal prefix code characters sibling leaves maximum dept tree codewords lengt differ bit characters sibling leaves maximum depth loss generality assume fb fx fx lowest leaf frequencies order fb arbitrary frequencies order fb figure exchange positions produce tree exchange positions produce tree equation difference cost figure illustration key step proof lemma optimal tree leaves deepest leaves siblings leaves leaves huffmans algorithm merges arbitrary positions leaves swapped tree leaves swapped tree swap increase cost tree optimal tree fx nonnegative fx nonnegative minimumfrequency leaf nonnegative leaf maximum depth exchanging increase cost nonnegative optimal implies optimal tree sibling leaves maximum pth lemma lemma implies process building optimal tree mergers loss generality greedy choice merging hose characters lowest frequency greedy choice view cost single merger sum frequencies items merged exercise total cost tree constructed su costs mergers mergers step huffman chooses incurs cost lemma problem cons tructing optimal prefix codes optimal substructure property lemma alphabet frequency defined character characters minimum frequency alphabet characters removed character define fz fx tree representing optimal prefix code alphabet tree replacing leaf node internal node children represents optimal prefix code alphabet proof cost tree expressed terms cost tree compone costs equation fcdtc fcdc dz fxdt fydt fx fyd fzdz fx fyfrom conclude fx equivalently fx prove lemma contradiction suppose represent optimal prefix code exists tree loss generality lemma siblings tree common parent replaced leaf frequency fz fx fx fx yielding contradiction assumption represents optimal prefix code represent optimal prefix code alphabet theorem procedure huffman produces optimal prefix code proof lemmas exercises prove binary tree correspond optimal prefix code exercises optimal huffman code set frequencies based fibonacci numbers d3 e5 f8 g13 h21 generalize answer optimal code frequencies fibonacci numbers exercises prove total cost tree code computed sum internal nodes combined frequencie children node exercises prove order characters alphabet frequencies monotonically decreasing exists optimal code codewo lengths monotonically increasing exercises suppose optimal prefix code setcharacters transmit code bits represent optimal prefix code lg bits hint bits structure tree discovered walk tree exercises generalize huffmans algorithm ternary code codewords symbolsprove yields optimal ternary codes exercises suppose data file sequence bit characters characters common maximum character equency minimum character frequency prove huffman coding case efficient ordinary bit fixedlength code exercises compression scheme expect compress file randomly chosen bit characters single bit hint compare number files number encoded files prefixfree codes term prefix codes standard literature theoretical foundations greedy methods beautiful theory greedy algorithms sk etch theory determining gree method yields optimal solutions involves combinatorial structures matroids theory cover cases greedy method applies exam ple cover activityselection problem huffman coding problem cover cases practical theory rapidly developed extended cover applications notes chapter references matroids matroid ordered pair satisfying conditions finite nonempty set nonempty family subsets called independent subsets hereditary satisfies property note set ø member element satisfies exchange property word matroid hassler whitney studying matric matroids elements rows matrix set rows independent linearly independent usual sense easy structure defines matroid exercise matroids graphic matroid sgg defined terms undirected graph set sg defined set edges subset acyclic set edges independent subgraph forms forest graphic matroid closely mini mumspanningtree problem covered chapter theorem undirected graph sgg matroid proof sg finite set hereditary subset forest forest putting removing edges acyclic set edges create cycles remains satisfies exchange property suppose gb forests acyclic sets edges edges theorem forest edges vk trees prove trees consisting single vertex edges edge forest duces number trees forest trees forest gb trees forest gb fewer trees forest forest gb tree vertices trees forest connected edge vertices trees forest edge connects vertices trees forest edge forest creating cycle satisfies exchange operty completing proof matroid matroid element extension preserving independence extension graphic matroid independent set edges edge extension addition create cycle independent subset matroid maximal extensions maximal contained larger inde pendent subset property theorem maximal independent subsets matroid size proof suppose contrary maximal independent subset exists larger maximal independent subset exchange property implies extendible larger independent set contradicting assumption maximal illustration theorem graphic matroid connected undirected graph maximal independent subset free tree edges connects vertices tree called spanning tree matroid weighted weight function assigns strictly positive weight wx element weight function extends subsets summation denote length edge graphic matroid total length edges edge set greedy algorithms weighted matroid problems greedy approach provide optimal solutions formulated terms finding maximumweight independent subset weighted matroid weighted matroid independent set maximized subset independent maximum weight optimal subset matroid weight wx element positive optimal subset maxima independent subsetšit helps large minimumspanningtree problem connected undirected graph length function positive length edge term length refer iginal edge weights graph reserving term weight refer weights asso ciated matroid asked subset edges connects vertices minimum total length view problem finding optimal subset matroid weighted matroid weight function w0 w0 larger maximum length edge weighted matroid weights positive optimal subset spanning tree minimum total length iginal graph maximal independent subset corresponds spanning tree w0 maximal independent subset independent subset maximizes quantity minimize algorithm optimal subset arbitrary matroid solve minimumspanningtree problem chapter algorithms minimumspa nningtree problem greedy algorithm works weighted matroid algorithm takes input weighted matroid positive weight function returns optimal subset pseudocode denote components andm weight function algorithm greedy considers element turn order monotonical ly decreasing weight imme diately adds set accumulated independent greedym ø sort monotonically decreasing order weight monotonically decreasing order weight wxreturn elements considered turn order monotonically decreasing weight element considered maintaining independence discarded set independent definition matroid independent subset independent induction greedy returns independent subset moment subset maximum weight optimal subset running time greedy easy analyze denote sorting phase greedy takes time lg executed times element execution requires check set independent check takes time ofn entire algorithm runs time lg nf prove greedy returns optimal subset lemma matroids exhibit greedychoice property suppose weighted matroi weight function sorted monotonically decreasing order weight element independent exists exists exists optimal subset proof exists independent subset set nonempty optimal subset assume element weight greater wx observe implies independent hereditary choice ensures wx wy construct set choice independent exchange property repeatedly element preserving independence wb wy wx wb optimal optimal lemma proven element opt ion initially option lemma matroid element extension independent subset extension ø proof extension independent hereditary independent extension ø corollary matroid element extension ø extension independent subset proof corollary simply contrapositive lemma corollary element greedy error passing initial elements extension ø lemma matroids exhibit optimalsubstructure property element chosen greedy weighted matroid remaining problem finding maximum weight independent subset reduces finding maximumweight independent subset weighted matroid andthe weight function weight function restricted contraction element proof maximumweight independent subset independent subset conversely independent subset yields independent subset cases wx maximumweight solution yields maximumweight solution vice versa theorem correctness greedy algorithm matroids weighted matroid weight function greedym returns optimal subset proof corollary elements passed ove initially extensions ø forgotten element selected lemma implies greedy err adding exists optimal subset finally lemma implies remaining problem finding optimal subset matroid contraction procedure greedy sets remaining steps interpreted acting matroid independent independent sets subsequent operation greedy maximumweight independent subset operation greedy maximumweight independent subset exercises sk matroid finite set andk set subsets size exercises matrix field reals matroid set columns columns linearly independent exercises matroid matroid maximal maximal independent sets complements maximal independent sets exercises finite set s1 sk partition nonempty disjoint subsets define structure conditionmatroid set sets member block partition determines independent sets matroid exercises transform weight function weighted matroid problem desired optimal solution minimumweight maximal independent subset standard weightedmatroid problem argue carefully transformation correct taskscheduling problem interesting problem solved matroids problem optimally scheduling unittime tasks single proces sor task deadline penalty paid deadline missed problem complicated solved surp risingly simple manner greedy algorithm unittime task job program computer requires unit time complete finite set unittime tasks schedule permutation order tasks performed task schedule time finishes time task time finishes time problem scheduling unittime tasks deadlines penalties single processor inputs set unittime tasks set integer deadlines d1 dn satisfies task ai supposed finish time set nonnegative weights penalties w1 w2 wn incur penalty task ai finished time incur penalty task finishes deadline asked schedule minimizes total penalty incurred missed deadlines schedule task late schedule finishes deadline task early schedule arbitrary schedule earlyfirst form early tasks precede late tasks note early task ai late task switch positions ai ai early late claim arbitrary schedule canonical form early tasks precede late tasks early tasks scheduled order monotonically increasing deadlines schedule earlyfirst form long early tasks ai finishing respective times schedule swap positions ai early swap ai early swap task moved earlier schedule early swap search optimal schedule reduces finding set tasks early optimal schedule determined create actual schedule listing elements order monotonically increasing deadline listing late tasks order producing canonical ordering optimal schedule set tasks independent exists schedule tasks tasks late early tasks schedule forms independent set tasks denote set independent sets tasks problem determining set tasks independentdenote number tasks deadline earlier note n0a set lemma set tasks statements equivalent set independent tasks scheduled order monotonically increasing deadlines task late proof schedule late tasks set tasks finish time implies holds follow stuck scheduling tasks order monotonically increasing deadlines implies ith largest deadline finally trivially implies property lemma easily compute set tasks independent exercise problem minimizing sum penalti late tasks problem maximizing sum penal ties early tasks theorem ensures greedy algorithm independent set tasks maximum total penalty theorem set unittime tasks deadlines set independent sets tasks matroid proof subset independent set tasks independent prove exchange property suppose independent sets tasks largest exists n0a n0b nnb nna njb nja range tasks deadline ai task deadline ai independent property lemma independent independent independent completing proof matroid theorem greedy algorithm maximumweight independent set tasks create optimal schedule tasks early tasks method effi cient algorithm scheduling unittime tasks deadlines penalties single processor running time on2 greedy independence checks algorithm takes time exercise faster implementation problem figure problem scheduling unittime tasks deadlines penalties single processor greedy gorithm selects tasks rejects a5 a6 finally accepts a7 final optimal schedule a7 a5 a6 total penalty incurred w5 w6 task ai figure instance problem scheduling unittime tasks deadlines penalties single processor exercises solve instance scheduling problem figure penalty replaced exercises property lemma determine time set tasks independent problems coin changing problem making change cents fewest number coins assume coins integer greedy algorithm change consisting quarters dimes nickels pennies prove algorithm yields optimal solution suppose coins denominations powers denominations c0 ck integers greedy algorithm yields optimal solution set coin denominations greedy algorithm yield optimal solution set include penny solution onktime algorithm change set coin denominations assuming coins penny problems scheduling minimize average completion time suppose set tasks task ai requires units processing time complete started computer tasks computer task time completion time task ai time task ai completes processing goal minimize average completion time minimize suppose tasks schedule runs average completion timealgorithm schedules tasks minimize average completion time task nonpreemptively task ai started continuously units time prove algorithm minimizes average completion time state running time algorithm suppose tasks task release time processed suppose preemption task suspended restarted time task ai processing time start running time preempted time resume time preempted time finally resume time complete time task ai total time units running time divided pieces completion time ai algorithm schedules tasks minimize average completion time scenario prove algorithm minimizes averag completion time state running time algorithm problems acyclic subgraphs undirected graph definition matroid matroid acyclic subset incidence matrix undirected graph matrix mve edge incident vertex mve argue set columns linearly independent field int egers modulo set edges acyclic result exercise provide alternate proof matroid suppose nonnegative weight edge undirected graph efficient algorithm acyclic subset maximum total weight gv arbitrary directed graph defined directed cycles directed graph matroid defining condition matroid fails hold incidence matrix directed graph matrix mve edge leaves vertex mve edge enters vertex mve argue set columns linearly independent set edges directed cycle exercise tells set linearly independent sets columns matrix forms matroid explain carefully parts ontradictory fail perfect correspondence notion set edges acyclic notion set columns incidence matrix linearly independent problems scheduling variations algorithm problem scheduling unittime tasks deadlines penalties time slots initially time slot unitlength slot time finishes time tasks order monotonically decreasing penalty task exists time slot deadline assign latest slot filling slot assign task latest unfilled slots argue algorithm optimal answer fast disjoints forest presented implement algorithm efficiently assume set input tasks sorted monotonically decreasing order penalty analyze running time implementation chapter notes material greedy algorithms matroids lawler papadimitriou steiglitz greedy algorithm appeared combinatorial optimization literature article edmonds theory matroids dates article whitney proof correctness greedy gorithm activityselection problem based gavril taskscheduling problem studied lawler horowitz sahni brassard bratley huffman codes invented lelewer hirschberg surveys datacompression techniques extension matroid theory greedoid theory pioneered korte lov ász greatly generalize theory presented chapter amortized analysis overview amortized analysis time required perform seque nce datastructure operations averaged operations performed ortized analysis average cost operation small averages sequence operations single operation sequence expensive amortized analysis differs averagecase analysis probabil ity involved amortized analysis guarantees average performance operation worst case sections chapter common techniques amortized analysis starts aggregate analysis determine upper bound total cost sequence operations average cost operation average cost amortized cost operation operations amortized cost covers accounting method determine amortized cost operation type operation type operation amortized cost accounting method overcharges operations early sequence storing overcharge prepaid credit specific objects data structure credit sequence pa operations charged cost discusses potential method accounting method determine amortized cost operati overcharge operations early compensate undercharges potential method maintains credit potential energy data structure associating credit individual objects data structure examples examine ree methods stack additional operation multipop pops objects binary counter counts single operation increment reading chapter bear mind charges assigned amortized analysis analysis purposes code credit assigned object accounting method assign attribute credit code insight data structure gained performing amortized analysis optimizing design potential method analyze dynamically expa nding contracting table aggregate analysis aggregate analysis sequence operations takes worstcase time total worst case average cost amortized cost operation note amortized cost applies operation types operations sequence methods study chapter accounting method poten tial method assign amortized costs types operations stack operations aggregate analysis analyze stacks augmented operation presented fundamental stack operations takes o1 time pushs pushes object stack pops pops stack returns popped object operations runs o1 time cost total cost sequence push pop operations actual running time operations add stack operation multipop sk removes objects stack pops entire stack fewer objects pseudocode operation stackempty returns true ther objects stack false multipops stackemptys pops figure multipop figure action multipop stack initially objects popped multipops result operation multipops empties stackšshown šsince fewer objects remaining running time multipop stack objects actual running time linear number pop operations actual ly executed suffices analyze multipop terms ract costs push pop number iterations loop number min kof objects popped stack iteration loop pop total cost multipop min sk actual running time linear function cost analyze sequence push pop multipop operations initially stack worstcase cost ltipop operation sequence stack size worstcase time stack operation sequence operations costs on2 multipop operations costing analysis correct on2 result worstcase cost operation individually tight aggregate analysis upper bound considers entire sequence operations fact single multipop operation expensive sequence push pop multipop operations initially stack cost object popped time pushed number times pop called nonempty stack including calls multipop number push operations sequence push pop multipop ope rations takes total time average cost operation onn o1 aggregate analysis assign amortized cost operation averag cost stack operations amortized cost o1 emphasize average cost running time stack operation o1 probabilistic reasoning involved worstcase bound sequence operations dividing total cost yielded average cost operation amortized cost incrementing binary counter aggregate analysis problem implementing kbit binary counter counts upward array a0 bits lengtha counter binary number stored counter lowest order bit a0 highestorder bit ak initially ai add modulo counter procedure incrementalengtha ai ai lengtha ai figure binary counter incremented times starting initial lue start iteration loop lines œ4 add position ai adding flips bit position yields carry position iteration loop loop ends ai adding position flipping care cost increment operation linear number bits flipped figure bit binary counter sequence increment operations bits flip achieve shaded running cost flipping bits notice total cost total number increment operations stack cursory analysis yields bound correct tight single execution increment takes time worst case array sequence increment operations initially counter takes time onk worst case tighten analysis yield worstcase cost sequence increments observing bits flip time increment called figure a0 flip time increment called nexthighestorder bit flips time sequence increment operations initially counter flip times bit flips fourth time n4 times sequence increments general lg bit ai flips n2i times sequence increment operations initially counter lg bit ai flips total number flips sequence equation a6 worstcase time sequence increment operations initially counter average cost operation amortized cost operation onn o1 exercises set stack operations included multipush operation pushes items stack o1 bound amortized cost stack operations continue hold exercises decrement operation included kbit counter operations cost nk time exercises sequence operations performed data structure ith operation costs exact power aggregate analysis determine amortized cost operation accounting method accounting method amortized analysis assi gn differing charges operations operations charged cost charge operation called amortized cost operations amortized cost exceeds actual cost difference assigned specific objects data structure credit credit pay operations amortized actual cost view amortized cost operation split actual cost credit deposited method aggregate analysis operations amortized cost choose amortized costs opera tions carefully analysis amortized costs worst case average cost operation small total amortized cost sequence operations upper bound total actual cost sequence aggregate analysis relationship hold sequences operations denote actual cost ith operation amortized cost ith operation require sequences operations total credit stored data structure difference total amortized cost total actual cost inequality total credit data structure nonnegative times total credit allowed negative result undercharging early operations promise repaying acc ount total amortized costs incurred time tal actual costs incurred sequence operations time total amorti zed cost upper bound total actual cost care total credit data structure negative stack operations illustrate accounting method amortized analysis return stack recall actual costs operations push pop multipop min argument supplied multipop stack size called assign amortized costs push pop multipop note amortized cost multipop constant actual cost variable amortized costs o1 general amortized costs operations consideration differ asymptotically pay sequence stack operations charging amortized costs suppose dollar represent unit cost start stack recall analogy stack data structure stack plates cafeteria push plate stack dollar pay actual cost push left credit dollar dollars charged plate point time plate stack dollar credit dollar stored plate prepayment cost popping stack execute pop operation charge operation pay actual cost credit stored stack pop plate dollar credit plate pay actual cost operation charging sh operation bit neednt charge pop operation neednt charge multipop operati ons pop plate dollar credit plate pay actual cost pop operation pop plate dollar credit plate pay pop operation charged pay multipop operations plate stack dollar credit stack nonnegative number plates ensured credit nonnegative sequence push pop multipop operations total amortized cost upper bound total actual cost total amortized cost total actual cost incrementing binary counter illustration accounting thod analyze increment operation binary counter starts observed earlier running time operation proportional number bits flipped cost dollar represent unit cost flipping bit amortized analysis charge amorti zed cost dollars set bit bit set dollar dollars charged pay actual setting bit place dollar bit credit flip bit point time counter dollar credit neednt charge reset bit pay reset dollar bit amortized cost increment determined cost resetting bits loop paid dollars bits reset bit set increment amortized cost increment operation dollars number ounter negative credit nonnegative increment operations total amortized cost bounds total actual cost exercises sequence stack operations performed stack size exceeds operations copy entire stack backup purposes cost stack operations including copying stack assigning suitable amortized costs stack operations exercises redo exercise accounting method analysis exercises suppose increment counter reset bits implement counter array bits sequence increment reset operations takes time initially counter hint pointer highorder potential method representing prepaid work credit stored specific objects data structure potential method amortized analysis represents prepaid work potential energy potential released pay future operations potential data structure ther specific objects data structure potential method works start initial data structure d0 operations performed actual cost ith operation data structure applying ith operation data structure di1 potential function maps data structure real number potential data structure amortized cost ith operation respect potential function defined amortized cost operation actual cost increase potential operation equation total amortized cost operations equality equation a9 terms telescope define potential function dn d0 total amortized cost upper bound total actual cost practice operations performed require d0 guarantee accounting method pay advance convenient define d0 exercise easy handle cases d0 intuitively potential difference di1 ith operation positive amortized cost represents overcharge ith operation potential data structure increases potential difference negative amortized cost represents undercharge ith operation actual cost operation paid decrease potential amortized costs defined equations depend choice potential function potential functions yield amortized costs upper bounds actual costs tradeoffs choosing potential function potential function depends desired time bounds stack operations illustrate potential method return stack operations push pop multipop define potential function stack number objects stack stack d0 start d0 number objects stack negative stack ith operation nonnegative potential d0 total amortized cost operations respect represents upper bound actual cost compute amortized costs stack operations ith operation stack objects push operation potential difference di1 equation amortized cost push operation di1suppose ith operation stack multipops min objects popped stack actual cost operation potential difference di1 amortized cost multipop operation di1 amortized cost ordinary pop operation amortized cost operations o1 total amortized cost sequence operations argued d0 total amortized cost operations upper bound total actual cost worstcase cost operations incrementing binary counter poten tial method agai incrementi binary counter time define potential counter ith increment operation number counter ith operation compute amortized cost increment operation suppose ith increment operation resets bits actual cost operation addition resetting bits sets bit ith operation resets bits bi1 bi1 case bi1 potential difference di1 bi1 bi1 amortized cost di1counter starts d0 total amortized cost sequence increment operations upper bound total actual cost worstcase cost increment operations potential method easy alyze counter start initially b0 increment operations b0 recall number bits counter rewrite equation d0 b0 dn total actual cost increment operations note b0 long total actual cost execute increment operations total actual cost matter initial counter exercises suppose potential function d0 d0 exists potential function d0amortized costs theamortized costs exercises redo exercise potential method analysis exercises ordinary binary minheap data structure elements supports instructions insert extractmin olg worstcase time potential function amortized cost insert olg amortized cost extractmin o1 works exercises total cost executing stack operations push pop multipop assuming stack s0 objects finishes objects exercises suppose counter number binary representation cost performing increment operations assume constant exercises implement queue ordinary stacks exercise amortized cost enqueue dequeue operation o1 exercises design data structure support operations set integers inserts inserts set deletelargerhalfs deletes largest elements explain implement data structure sequence operations runs time dynamic tables applications advance objects stored table allocate space table table reallocated larger size objects stored iginal table copied larger table simila rly objects deleted table worthwhile allocate table smaller size study problem dynamically expanding contr acting table amortized analysis amortized cost insertion deletion o1 actual cost operation large triggers expansion contraction guarantee unused space dynamic table exceeds constant fraction total space assume dynamic table supports operations tableinsert table delete tableinsert inserts table item occupies single slot space item likewise tabledelete thought removing item table freeing slot details datastructuring method organize table unimportant stack heap chapter hash table chapter array coll ection arrays implement object storage convenient concept introduced analysis hashing chapter define load factor nonempty table number items stored table divided size number slots table assign table items size define load factor load factor dynamic table bounded constant unused space table constant fraction total space start analyzing dynamic table whic insertions performed general case insertions deletions allowed table expansion assume storage table allocated array slots table fills slots equivalently load factor software environments attempt insert item table alternative abort error assume software environment modern memorymanagemen allocate free blocks storage request item inserted table expand table allocating table slots table table reside contiguous mory allocate array larger table copy items table table common heuristic allocate table slots insertions performed load factor table wasted space exceeds half total space table pseudocode assume object representing table field tablet pointer block storage representing table field numt number items table field sizet total number slots table initially table numt sizet tableinsert sizet allocate tablet slot sizet numt sizet allocate newtable sizet slots insert items tablet newtable free tablet tablet newtable sizet sizet insert tablet numt numt notice insertion procedures tableinsert procedure elementary insertion table lines analyze running time tableinsert terms number elementary inse rtions assigning cost elementary insertion assume actual running time tableinsert linear time insert individual items overhead allocating initial table constant overhead allocating freeing storage lines dominated cost transferring items event clause lines œ9 executed expansion analyze sequence tableinsert operations initially table cost ith operation room current table operation perform elementary insert ion current table expansion occurs cost elementary insertion items copied table table operations performed wors tcase cost operation leads upper bound on2 total running time operations bound tight cost xpanding table borne tableinsert operations ith operation expansion exact power amorti zed cost operation fact o1 aggregate analysis cost ith operation total cost tableinsert operations operations cost costs remaining operations form geometric series total cost tableinsert operations amortized cost single operation accounting method gain feeling amortized cost tableinsert operation intuiti vely item pays elementary insertions inserting current tabl moving table expanded moving item moved table expanded suppose size table expansion number items table table credit charge dollars insertion elementary insertion occurs immedi ately costs dollar dollar credit item inserted dollar credit items table filling table requires additional insertions time table items item dollar pay reinsertion expansion potential method analyze sequence tableinsert operations design tabledelete operation o1 amortized cost start defining potential function expansion builds ta ble size time table expansion paid potential function possibility expansion numt sizet2 desired befo expansion numt sizet numt desired initial potential table half numt sizet2 implies nonnegative sum amortized costs tableinsert operations upper bound sum actual costs analyze amortized cost ith tableinsert operation numi denote number items stored table ith operation sizei denote total size table ith operation denote potential ith operation initially num0 size0ith tableinsert operation trigger expansion sizei sizei1 amortized cost operation i1 numi sizei numi1 sizei1 numi sizei numi sizei ith operation trigger expansion sizei sizei1 sizei1 numi1 numi1 implies size numi1 amortized cost operation i1 numi numi sizei numi1 sizei1 numi numi numi numi numi numi numi figure plots values numi sizei notice potential builds pay expansion table figure sequence tableinsert operations number numi items table number sizei slots table potential numi size measured ith operation numi dashed sizei thick notice expansion potential built number items tabl pay moving items table potential drops increased item caused expansion inserted table expansion contraction implement tabledelete operation simple remove item table desirable contract table load factor table small wasted space exorbitant table contraction analogous table expansion number items table drops low allocate smaller table copy items table storage table freed returning memorymanagement ideally preserve properties load factor dynamic tabl bounded constant amortized cost table ope ration bounded constant assume cost measured rms elementary insertions deletions natural strategy expansion contraction double table size item inserted table halve size wh deletion caus table half strategy guarantees load factor table drops amortized cost operation large scenario perform operations table exact power operations insertions previous analysis cost total sequence insertions numt sizet operations perform sequence stands insertion stands deletion insertion expansion table size deletions contraction table size insertions expansion cost expansion contraction total cost operations amortized cost operation difficulty strategy obvious expansion perform deletions pay contraction likewise contraction perform insertions pay expansion improve strategy allowing load factor table drop continue double table size item inserted table halve table size deletion table load factor table bounded constant idea expansion load factor table half items table deleted contraction occur contraction occur load factor fall likewise contraction load factor table number items table doubled insertions expansion occur expansion occurs load factor exceed omit code tabledelete analogous tableinsert convenient assume analysis number items table drops storage table freed numt sizet potential method analyze cost sequence tableinsert tabledelete operations art defining potential function expansion contraction builds load factor increases decreases denote load factor nonempty table numt sizet table numt sizet numt size table potential function observe potential table tential negative total amortized cost seque nce operations respect upper bound actual cost sequence proceeding precise analysis pause observe properties potential function notice load factor potential load factor sizet numt implies numt potential pay expansion item insert load factor sizet numt implies numt potential pay contraction item deleted figure illustrates potential behaves sequence operations figure sequence tableinsert tabledelete operations number numi items table number sizei slots table potential measured ith operation numi dashed sizei thick notice expansion potential built number items table pay moving items table likewise contracti potential built number items table analyze sequence tableinsert tab ledelete operations denote actual cost ith operation denote amortized respect numi denote number items stored table ith operation sizei denote total size table ith operation denote load factor table ith operation denote potential ith operation initially num0 size0 start case ith operation tableinsert analysis identical table expansion i1 table expands amortized cost operation i1 table expand result operation expansion occurs i1 amortized cost ith operation i1 sizei2 numi sizei12 numi1 sizei2 numi sizei2 numi i1 ciii1 numi sizei sizei1 numi1 numi1 sizei1 size i12 numi1 numi1 sizei1 i1 sizei1 sizei1 sizei1 sizei1 amortized cost tableinsert operation turn case ith operation tabledelete case numi numi1 ai1 operation contraction sizei size i1 amortized cost operation i1 sizei numi size i1 numi1 sizei numi size numi i1 ith operation trigger contraction actual cost operation numi delete item numi items sizei2 sizei14 numi1 numi amortized cost operation i1 numi sizei2 numi sizei12 numi1 numi numi numi numi numi ith operation tabledelete i1 amortized cost bounded constant analysis left exercise summary amortized cost operation bounded constant actual time sequence operations dynamic table exercises suppose implement dynamic openaddress hash table table load factor reaches strictly insertion dynamic opena ddress hash table expected amortized cost insertion o1 expected actual cost insertion o1 insertions exercises i1 ith operation dynamic table tabledelete amortized cost operation respect potential function bounded constant exercises suppose contracting table halving size load factor drops contract multiplying size load factor drops potential function numt sizet amortized cost tabledelete strategy bounded constant problems bitrevers binary counter chapter examines algorithm called fast fourier transform fft step fft algorithm performs bitreversal permutation input array a0 length nonnegative integer permutation swaps elements indices binary representations reve rse express kbit sequence ak1 ak2 a0 define revkak1 ak2 a0 a0 ak1 equivalently revk3 bit representation reversed bit representation function revk runs time write algorithm perform bit reversal permutation array length onk time algorithm based amortized analysis improve running time bitreversal permutation maintain bitreversed counter procedure bitreversedincrement ven bitreversedcounter produces revkrev ka bitreversed counter starts successive calls bitreversedincrement produce sequence assume computer store kbit values unit time computer manipulate binary values operations shifting left arbitrary amounts bitwisea bitwiseor implementation bitreversedincre ment procedure bitreversal permutation nelement array performed total time suppose shift word left bit unit time implement ontime bitreversal permutation problems making binary search dynamic binary search sorted array takes logarithmic search time time insert element linear size array improve time insertion keeping sorted arrays suppose support search insert set elements lg binary representation nk1 nk2 n0 sorted arrays a0 ak1length array ai array pty depending total number elements held arrays individual array sorted relationship elements arrays perform search operation data structure analyze worstcase running time insert element data structure analyze worstcase amortized running times discuss implement delete problems amortized weightbalanced trees ordinary binary search tree augmented adding node field size number keys stor subtree rooted constant range node balanced sizeleft sizex sizerightx sizex tree balanced node tree balanced amortized approach maintaining weightb alanced trees suggested varghese balanced tree sense balanced node arbitrary binary search tree rebuild subtree rooted balanced algorithm time sizex osizex auxiliary storage performing search nnode balanced binary search tree takes olg worstcase time remainder probl assume constant strictly greater suppose insert delete implemented usual nnode binary search tree operation node tree longer balanced subtree rooted highest node tree rebuilt balanced analyze rebuilding scheme potential method node binary search tree define sizeleftx sizerightx define potential large constant depends argue binary search tree nonnegative potential balanced tree potential suppose units potential pay rebuilding mnode subtree large terms order o1 amortized time rebuild subtree balanced inserting node deleting node nnode balanced tree costs olg amortized time problems cost structuring redblack trees basic operations redblack trees perform structural modifications node insertions node deletions rotations color modifications rbinsert rbdelete o1 rotations node insertions node deletions maintain redblack properties color modifications legal redblack tree nodes calling rbinsert add node lg color modifications legal redblack tree nodes calling rbdelete node lg color modifications worstcase number color modifica tions operation logarithmic prove sequence rbinsert rbdelete operations initially redblack tree structural modifications worst case cases handled main oop code rbinsertfixup rbdeletefixup terminating encountered loop terminate constant number add itional operations cases rbinsertfixup rbdeletefixup terminating hint figuresanalyze structural modificat ions insertions performed redblack tree define number red nodes assume unit potential pay structural modifications performed cases rbinsertfixup result applying case rbinsertfixup argue node insertion redblack tree rbinsert broken parts list structural odifications potential lines œ16 rbinsert nonterminating cas rbinsertfixup terminating cases rbinsertfixup argue amortized num ber structural modifications performed rbinsert o1 prove structural modifications insertions deletions define node redefine potential redblack tree tree applying nonterminating case rbinsert fixup rbdeletefixup nonterminating cases rbinsertfixup argue amortized numb structural modifications performed rbinsertfixup o1 nonterminating cases rbdeletefixup argue amortized numb structural modifications performed rbdeletefixup o1 complete proof worst case sequence rbinsert rbdelete operations performs structural modifications situations openaddress hash table table load factor equals constant strictly exercise chapter notes aggregate analysis aho hopcroft ullman tarjan surveys accounting potential methods amortized anal ysis presents applications attributes accounting method author including brown tarjan huddleston mehlhorn attributes potential method sleator term amortized sleator tarjan potential functions proving lower bounds types problems configuration problem define potential function maps configuration real number determine potential init initial configuration potential final final configuration maximum change potential max step number steps final initmax examples potential functions proving lower bounds complexity works cormen floyd aggarwal vitter krumme cybenko venkataraman applied potential functions prove lower bounds gossiping communicating unique item vert graph vertex advanced data structures chapter list chapter btrees chapter binomial heaps chapter fibonacci heaps chapter data structures disjoint sets introduction returns examination data structures support operations dynamic sets advanced level iii chapters extensive amortized analysis techniques chapter chapter presents btrees balanced earch trees designed stored magnetic disks magnetic sks operate slowly random access memory measure performance btrees computing time dynamicset operations consume disk accesses performed btree operation number disk acce sses increases height btree low btree operations chapters implementations mergeable heaps support operations insert minimum extractmin union union operation unites merges heaps data structures chapters support operations delete decreasekey binomial heaps chapter support operations olg worstcase time total number elements input heap input heaps case union union operation supported binomial heaps superior binary heaps introduced chapter takes time unite binary heaps worst case fibonacci heaps chapter improve binomial heaps theoretical sense amortized time bounds measure performance fibonacci heaps operations insert minimum union o1 actual amortized time fibonacci heaps operati ons extractmin delete olg amortized time advantage fibon acci heaps decreasekey takes o1 amortized time low amortized time decreasekey operation fibonacci heaps key components asymptotically fastest algorithms graph problems finally chapter presents data structures disjoint sets universe elements grouped dynamic sets initially element belongs singleton set operation union unites sets query findset identifies set element moment representing set simple rooted tree surprisingly fast operations sequence operations runs time incredibly slowly growing functionšn onceivable application amortized analysis proves time bound complex data structure simple topics covered examples advanced data structures advanced data structures include dynamic trees introduced sleator tarjan discussed tarjan maintain forest disjoint rooted trees edge tree realvalued cost dynamic trees support queries parent roots edge costs minimum edge cost path node root trees manipulated cutting edges updating edge costs path node root linking root tree making node root tree appears implementation dynamic trees olg amortized time bound operation complicated implementation yields olg worstcase time bounds dynamic trees asymptotically fastest networkflow algorithms splay trees developed sleator tarjan discussed tarjan form binary search tree standard searchtre operations olg amortized time application splay trees simplifies dynamic trees persistent data structures queries updates versions data structure driscoll sarnak slea tor tarjan techniques making linked data structures persistent small time space cost problem simple persistent dynamic set data structures faster implementation dictionary operations insert delete search restricted universe keys advantage restrictions achieve worstcase asymptotic running times comparisonbased data structures data structure invented van emde boas supports operations minimum maximum insert delete search extractmin tractmax predecessor successor worstcase time olg lg subject restriction universe keys set fredman willard introduced fusion trees data structure allo faster dictionary operations universe restricted integers implement operations olg lg lg time subsequent data structures including exponential search trees improved bounds dictionary operations mentioned chapter notes book dynamic graph data structures support queries allowing structure graph change operations insert delete vertices edges examples queries upported include vertex connectivity edge connectivity minimum spanning trees biconnectivity transitive closure chapter notes book mention additional data structures problem defined mergeable heap support minimum extractmin refer mergeable minheap alternatively supported maximum extractmax mergeable maxheap mergeable heaps default mergeable minheaps chapter btrees overview btrees balanced search trees designed work magnetic disks directaccess secondary storage devices btrees redblack trees chapter minimizing disk operations database systems btrees variants btrees store btrees differ redblack trees btree nodes children handful thousands branching factor btree large determined characteristics disk unit btrees redblack trees nnode btree height olg height btree considerably redblack tree ecause branching factor larger btrees implement dynamicset operations time olg btrees generalize binary search trees natural manner figure simple btree internal btree node nx keys nx children keys node dividing points separating range keys handled nx subranges handled child searching key btree nx decision based comparisons nx keys stored node structure leaf nodes differs ternal nodes examine differences figure btree keys consonants english internal node nx keys nx children leaves depth tree lightly shaded nodes examined search letter precise definition btrees proves height btree grows logarithmically number nodes describes search key insert key btree discusses deletion proceeding data ructures designed work magnetic disk evaluated differently data structures designed work main randomaccess memory data structures secondary storage technologies providing memory capacity computer primary memory main memory computer consists silicon memory chips technology typi cally orders magnitude expensive bit stored magnetic storage technol ogy tapes disks computer systems secondary storage based magnetic disks secondary storage exceeds primary memory leas orders magnitude figure typical disk drive drive consists platters rotate constant speed common spindle surface pla tter covered magnetizable material pla tter read written head arm arms physically attached ganged toge therand heads spindle head stationary surface passes underneath called track readwrite heads vertically igned times set tracks underneath accessed simultaneously figure set tracks cylinder figure typical disk drive composed platters rotate spindle platter read written head arm arms ganged heads unison arms rotate common pivot axis track surface passes ben eath readwrite head stationary cylinder consists set covertical tracks disks cheaper higher capacity main memory slower moving parts components mechanical motion platter rotation arm movement writin commodity disks rotate speeds œ15000 revolutions minute rpm rpm common rpm fast rotation takes milliseconds orders magnitude longer nanosecond access times commonly silicon memory wait rotation item readwrite head access main memory times span average wait half rotation difference access times silicon memory disks enormous moving arms takes time writing average access times commodity disks range milliseconds order amortize time spent waiting mechanical movements disks access item time divided number equalsized bits consecutively cylinders disk read wr ite entire typical diskbytes length readwrite head positioned correctly disk rotated desired reading writing magnetic disk electronic rotation disk large amounts data read written takes time access inform ation read disk takes computer examine read eason chapter separately princi pal components running time number disk accesses cpu computing time number disk accesses measured term number read written disk note disk access time constantšit depends distance current track desired track initial rotational state disk number read written firstorder approximation tal time spent accessing disk typical btree application data handled large data fit main memory btree algor ithms copy selected disk main memory needed write disk changed btree algorithms designed constant number memory time size main memory limit size btrees handled model disk operations pseudocode pointer object object computers main memor refer fields object usual keyx object referred resides disk perform operation diskreadx read object main memory refer fields assume main memory diskread requires disk accesses noop operation diskwrite save fields object typical pattern working object pointer object diskreadx operations access andor modify fields diskwrite fields changed operations access modify fields limited number main memory time assume longer flushed main memory tree algorithms ignore issue systems running time btree algorithm determined number diskread disk write operations performs operations efficiently read write btree node large sk number children btree node limited size disk large btree stored disk branching factors depending size key relative size large branching factor dramatically reduces height tree numbe disk accesses required key figure btree branching factor height store billion keys root node permanently main memory disk accesses requir key tree figure btree height billion keys internal node leaf keys nodes pth leaves depth inside node nx number keys definition btrees things simple assume binary search trees redblack trees satellite stored node key practice store key pointer disk satellite key pseudoc ode chapter implicitly assumes satellite key pointer satellite travels key key moved node node common variant btree tree stores satellite leaves stores keys child pointers internal nodes maximizing bran ching factor internal nodes btree rooted tree root root properties node fields nx number keys stored node nx keys stored nondecreasing order key1x key2x keynxx leaf boolean true leaf false internal node internal node nx pointers c1x c2x cnx1x children leaf nodes children fields undefined keys keyix separate ranges keys stored subtree ki key stored subtree root k1 key1x k2 key2x keynxx knx1 leaves depth trees height lower upper bounds number keys node bounds expressed terms fixed integer called minimum degree btree node root keys internal node root children tree nonempty root key node keys internal node children node keys1 simplest btree occurs internal nodechildren tree practice larger values typically height btree number disk accesses required operations btree proportional height btree analyze worstcase height btree theorem nkey btree height minimum degree proof btree height root key nodes keys nodes depth nodes depth nodes depth depth th1 nodes figure illustrates tree number keys satisfies inequality figure btree height minimum number keys inside node nx simple algebra baset logarithms bot sides proves theorem power btrees compared redblack trees height tree grows olg cases recall constant btrees base logarithm times larger btrees save factor lg redblack trees number nodes examined tree operations examining arbitrary node tree requires disk access number disk accesses reduced exercises dont minimum degree exercises values tree figure legal btree exercises legal btrees minimum degree represent exercises function minimum degree maximum number keys stored btree height exercises data structure result black node redblack tree absorb red children incorporating children common variant btree btree requires internal node east half btree requires basic operations btrees operations btreesearch btreecreate btreeinsert procedures adop conventions root btree main memory diskread root required diskwrite root required root node changed nodes passed parameters diskread operation performed procedures onepass gorithms proceed downward root tree searching btree searching btree earching binary search tree making binary twoway branching decision node multiway branching decision number nodes children precisely internal node nx branching decision btreesearch straightforward generalization treesearch procedure defined binary search trees btreesearch takes input pointer root node subtree key searched subtree toplevel form btreesearch roott btree btreesearch returns ordered pair consisting node keyiy nil returned btreesearchxnx keyixnx keyix return leaf return nil diskreadcix return btreesearchcix linearsearch procedure lines smallest keyix set nx lines check discovered key returning lines terminate search unsuccessfully leaf recurse search appropr iate subtree performing diskread child figure illustrates operation btreese arch lightly shaded nodes examined search key treesearch procedure binary search trees nodes encountered recursion form path downw ard root tree number disk accessed btreesearch logt height btree number keys btree nx time loop lines node total cpu time oth logt creating btree build btree btreecreate create root node btreeinsert add keys procedures auxiliary procedure allocatenode allocates disk node o1 time assume node created allocatenode requires diskread informati stored disk node btreecreatet allocatenode leafx true nx diskwritex roott btreecreate requires o1 disk operations o1 cpu time inserting key btree inserting key btree complicated inserting key binary search tree binary search trees search leaf position insert key btree simply create leaf node insert tree fail valid btree insert key existing leaf node insert key leaf node introduce operation splits node keys median key keyty nodes keys median key moves parent identify dividing point trees parent split key inserted split nodes propagate tree binary search tree insert key btree single pass tree root leaf split node order insertion travel tree searching position key belongs split node including leaf wh enever split node assured parent splitting node btree procedure btreesplitchild takes input nonfull internal node assumed main memory node assumed main memory cix child procedure splits child adjusts additional child split root ill root child root node btreesplitchild tree grows height splitting tree grows figure illustrates process node split median key moved parent node keys greater median key node child figure splitting node node split nodes median key moved parent btreesplitchildx allocatenode leafz leafy nz keyjz keyjty leafcjz cjtynx downto cj1x ci1x nx downto keyj1x keyjx keyix keyty nx nx diskwritey diskwritez diskwritex btreesplitchild works straightforward cutting pasting ith child node split node originally children keys reduced children keys operation node adopts largest children keys child positioned table children median key moves key separates lines create node larger keys children adjusts key count finally lines insert child median key order separate adjust key count lines write modified disk cpu time btreesplitchild loops lines loops iterations procedure performs o1 disk operations inserting key btree single pass tree insert key btree height single pass tree requiring disk accesses cpu time required oth logt btreeinsert procedure btreesplitchild guarantee recursion descends node btreeinsertt roott allocatenode roott leafs falsec1s btreesplitchilds btreeinsertnonfulls btreeinsertnonfullr lines handle case root node root split node children root splitting root increase height btree figure illustrates case binary search tree btree increases height procedure finishes calling btreeinsertnonfull perform insertion key tree rooted nonfull root node btreeinsertnonfull recurses tree times guaranteeing node recurses calling btreesplitchild figure splitting root root node split root node created root median key halves children btree grows height root split auxiliary recursive procedure btreeinsertnonfull inserts key node assumed nonfull ocedure called operation btreeinsert recursive operation btreeinsertnonfull guarantee assumption true btreeinsertnonfullx nx leafx keyix keyi1x keyixkeyi1x nx nx diskwritex keyix diskreadcix ncix btreesplitchildx cix keyixbtreeinsertnonfullcix btreeinsertnonfull procedure works lines handle case leaf node inserting key leaf node insert leaf node subtree rooted internal node case lines determine child recursion descends detects recursion descend child case btreesplitchild split child nonfull children lin determine children correct descend note diskread increments recursion descend case child created btreesplitchild net lines guarantee procedure recurses node recurses insert subtree figure illustrates cases inserting btree figure inserting keys btree minimum degree btree node hold keys nodes modified inser tion process lightly shaded initial tree result inserting initial tree simple insertion leaf node result inserting previous tree node rstuv split nodes uv key moved root inserted leftmost halves node result inserting previous tree root split btree grows height inserted leaf jk result inserting previous tree node abcde split inserted rightmost halves node number disk accesses rformed btreeinsert btree height o1 diskread diskwrite operations performed calls btreeinsertnonfull total cpu time oth logt btreeinsertnonfull tailrecursive alternatively implemented loop demonstrating number main memory time o1 exercises inserting keys order btree minimum degree draw configurations tree node split draw final configuration exercises explain circumstances redundant diskread diskwrite operations performed executing btreeinsert redundant diskread diskread memory redundant diskwrite writes disk identical stored exercises explain minimum key stored btree predecessor key stored btree exercises suppose keys inserted btree minimum degree nodes final btree exercises leaf nodes require pointers children conceivably larger internal nodes sk size modify procedures creating inserting btree handle variation exercises suppose btreesearch implemented binary search linear search node change cpu time required olg independently chosen function exercises suppose disk hardware choose size disk arbitrarily time takes read disk constants minimum degree btree selected size choose minimize btree search time optimal case milliseconds microseconds deleting key btree deletion btree analogous insertion complicated key deleted nodenot leafand deletion internal node requires nodes children rearranged inserti guard deletion producing tree structure violates btree properties ensure node didnt big insertion ensure node doesnt small deletion root allowed fewer minimum number keys allowed maximum number keys simple insertion algorithm node path key inserted simple approach deleti node root path key deleted minimum number keys assume procedure btreed elete asked delete key subtree rooted procedure structured guarantee btreedelete called recursively node number keys minimum degree note condition requires key minimum required usual btree conditions key moved child node recursion descends child rengthened condition delete key tree downward pass exception explain specification deletion btree interpreted understanding root node internal node keys situation occur cases deleted child c1x root tree decreasing height tree preserving property root tree key tree sketch deletion works presenting pseudocode figure illustrates cases deleting keys btree figure deleting keys btree minimum degree btree node root fewer keys nodes modified lightly shaded btree figure deletion case simple deletion leaf deletion case predecessor moved position deletion case pushed node degjk deleted leaf case deletion case recursion descend node keys pushed merged form clptx deleted leaf case root deleted tree shrinks height deletion case moved position moved position key node leaf delete key key node internal node child precedes node keys predecessor subtree rooted recursively delete replace finding deleting performed single downward pass symmetrically child node keys successor subtree rooted recursively delete replace finding deleting performed single downward pass keys merge loses pointer keys free recursively delete key internal node determine root cix subtree tree cix keys execute step guarantee descend node keys finish recursing child cix keys immedi ate sibling keys cix extra key moving key cix moving key cixs left sibling moving child pointer sibling cix cix cixs siblings keys merge cix sibling involves moving key merged node median key node keys btree leaves expect practice deletion operations delete keys leaves btreedelete procedure acts downward pass tree deleting key internal node procedure ward pass tree return node key deleted replace key predecessor successor cases procedure complicated involves disk operations btree height o1 calls diskread diskwrite recursive invocations procedure cpu time required oth logt exercises deleting order tree figure exercises write pseudocode btreedelete problems stacks secondary storage implementing stack computer small fast primary memory large slower disk storage operations push pop supported singleword values stack support grow larger fit memory stored disk simple inefficient stack implementation entire stack disk maintain memory stack pointer disk ddress element stack pointer element mod mth word disk number implement push operation increment stack pointer read memory disk copy element pushed word write disk pop operation decrement stack pointer read disk retu stack write modified disk operations expensive count costs implementation total number disk accesses total cpu time disk access incurs charges disk access cpu time asymptotically worst case number disk accesses stack operations simple implementati cpu time stack operations express answer terms subsequent parts stack implementation stack memory maintain small memory track memory perform stack operation relevant disk resides memory memory written disk read disk memory relevant sk memory disk accesses required worstcase number disk accesses required push operations cpu time worstcase number disk accesses required stack operations cpu time suppose implement stack keeping memory addition small number bookkeeping manage stack amortized number disk accesses stack operation o1m amortized cpu time stack operation o1 problems joining splitting trees join operation takes dynamic sets element keyx keyx keyx returns set split operation inverse join dynamic set element creates set consisting elements keys keyx set consisting elements keys greater keyx problem investigate implement operations ees assume convenience elements consist keys key values distinct maintain node tree height subtree rooted field heightx impl ementation affect asymptotic running times sear ching insertion deletion implement join operation trees key join o1 time heights path root tree key set keys set keys greater breaks set trees set keys keys relationship heights breaks sets trees keys implement split operation join operation assemble keys single tree keys single tree running time split operation olg number keys hint costs joining telescope chapter notes knuth aho hopcroft ullman sedgewick discussions balancedtree schemes btrees comer comprehensive survey btrees guibas sedgewick discuss relationships kinds balancedtree schemes including redblack trees trees hopcroft invented trees precursor btrees trees internal node children btrees introduced bayer mccreight explain choice bender demaine farachcolton studied btrees perform presence memoryhierarchy effects cacheoblivious algorithms work efficiently explicitly knowing data transfer sizes memory hierarchy chapter binomial heaps overview chapter chapter data structures mergeable heaps support operations makeheap creates returns heap elements inserth inserts node key field filled heap minimumh returns pointer node heap key minimum extractmin deletes node heap key minimum returning pointer node unionh1 creates returns heap nodes heaps h1 heaps h1 destroyed operation addition data structures chapters support operations decreasekeyh assigns node heap key assumed great current key deleteh deletes node heap table figure dont union operation ordinary binary heaps heapsort chapter work operations union worstcase time olg binary heap union operation supported binary heaps perform concat enating arrays hold binary heaps merged running minheapify exercise union operation takes time worst case procedure binary heap worst case binomial heap worst case fibonacci heap amortized makeheapinsert lg olg minimum olg extractmin lg lg olg union olg decrease key lg lg delete lg lg olg figure running times operations implementations mergeable heaps number items heaps time operation denoted chapter examine binomial heaps worstcase time bounds figure union operation takes olg time merge binomial heaps total elements chapter explore fibonacci heaps wh ich time bounds operations note running times fibonacci heaps figure amortized time bounds worst case peroperation time bounds chapter ignores issues allocating nodes prior insertion freeing nodes deletion assume code calls heap procedures deals details binary heaps binomial heaps fibonacci heap inefficient support operation search node key reason operations decreasekey delete refer node require pointer node input discussion priority queues mergeable heap pplication store handle application object mergeableheap element handle mergeableheap element pplication object exact nature handles depends application implementation defines binomial heaps afte defining constituent binomial trees introduces representation binomial heaps implement operations binomial heaps time bounds figure mentioned introduction default mergeable heaps mergeable min heaps operations minimum extractmin decreasekey apply alternatively define mergeable maxheap operations maximum extractmax increasekey binomial trees binomial heaps binomial heap collection binomial trees sect ion starts defining binomial trees proving key properties define binomial heaps represented binomial trees binomial tree ordered tree b52 defined recursively figure binomial tree b0 consists single node binomial tree consists binomial trees bk1 linked root leftmost child root figure binomial trees b0 b4 figure recursive definition binomial tree triangles represent rooted subtrees binomial trees b0 b4 node depths b4 binomial tree properties binomial trees lemma lemma properties binomial trees binomial tree nodes height tree nodes depthroot degree greater node children root numbered leftchild root subtree proof proof induction property basis binomial tree b0 verifying property holds b0 trivial inductive step assume lemma holds bk1 binomial tree consists copies bk1 k1 k1 nodes copies bk1 linked form maximum depth node greater maximum depth bk1 inductive hypothesis maximum depthnumber nodes depth binomial tree composed copies bk1 linked node depth bk1 appears depth depth number nodes depth number nodes depth bk1 number nodes depth bk1 node greater degree bk1 root child bk1 root bk1 degree root degree inductive hypothesis figure left children root bk1 roots bk2 bk3 b0 bk1 linked bk1 children root roots bk1 bk2 b0 corollary maximum degree node nnode binomial tree lg proof properties lemma term binomial tree property lemma terms binomial coefficients exercise justification term binomial heaps binomial heap set binomial trees satisfies binomialheap properties binomial tree obeys minheap property key node greater equal key pa rent tree minheapordered nonnegative integer binomial tree root degree property tells root mi nheapordered tree smallest key tree property implies nnode binomial heap consists lgn binomial trees observe binary representation lg bits blg blg b0 property lemma binomial tree appears bit binomial heap lg binomial trees figure binomial heap nodes binary representation consists minheapo rdered binomial trees b0nodes total nodes figure binomial heap nodes heap consists binomial trees b0nodes totaling nodes binomial tree minheapordered key node key parent root list linked list roots order increasing degree detailed representation binomial heap binomial tree stored left child rightsibling representation node stores degree representing binomial heaps figure binomial tree binomi heap stored left child rightsibling representation node key field satellite required application addition node pointers px parent child leftmost child siblingx sibling node root px nil node children childx nil rightmost child parent sibling nil node field degreex number children figure roots binomi trees binomial heap organized linked list refer root list degrees roots strictly increase traverse root list binomialheap property nnode binomial heap degrees roots subset lg sibling field meaning roots nonroots root siblingx points root root list usual sibling nil root root list binomial heap accessed field headh simply pointer root root list binomial heap elements headh nil exercises suppose node binomial tree binomial heap assume sibling nil root degreesiblingx compare degreex root exercises nonroot node binomial binomial heap degreex compare degreepx exercises suppose label nodes binomial tree binary postorder walk figure node labeled depth binary representation binary kstrings degree equal number rightmost binary representation figure binomial tree b4 nodes labeled binary postorder walk operations binomial heaps perform operations nomial heaps time bounds figure upper bounds lower bounds left exercise creating binomial heap binomial heap makebinomialheap procedure simply allocates returns object headh nil running time finding minimum key procedure binomialheapminimum retu rns pointer node minimum key nnode binomial heap implementation assumes keys exercise binomialheapminimumh nil headh min nil keyx min min keyx siblingx return binomial heap minheapordered minimum key reside root node binomialheapminimum procedure chec ks roots number lg saving current minimum min pointer current minimum called binomial heap figure binomialheapminimum returns pointer node key lg roots check running time binomialheap minimum olg uniting binomial heaps operation uniting binomial heaps subroutine remaining operations binomialheapunion procedure repeatedly links binomial trees roots degree procedure links bk1 tree rooted node bk1 tree rooted node parent node root tree binomiallinky siblingy childz childz degreez degreez binomiallink procedure node head linked list node zs children o1 time works leftch ild rightsibling representation binomial tree matches orderi property tree tree leftmost child root root bk1 tree procedure unites binomial heaps h1 returning heap destroys representations h1 process binomiallink procedure auxiliary procedure binomialheapmerge merges root lists h1 single linked list sorted degree monotonically increasing order binomialheapmerge proce dure pseudocode leave exercise merge procedure binomialheapunionh1 makebinomialheap headh binomialheapmergeh1 free objects h1 lists point headh nil return prevx nil headh nextx siblingx nextx nil degreex degreenextx siblingnextx nil degreesiblingnextx degreex prevx casesnextx caseskeyx keynextx siblingx siblingnextx case binomiallinknextx case prevx nil case headh nextx case siblingprevx nextx case binomiallinkx nextx case nextx case nextx siblingx return figure binomialheapuni cases pseudocode occur figure execution binomialheapunion binomial heaps h1 binomial heap output binomialheapmergeh1 initially root root list nextx degree keyx keynextx case applies link occurs root degree case applies pointers position root list case applies roots equal degree link occurs case applies link case applies degree nextx degree iteration loop pointers position root list nextx nil binomialheapunion procedure phases phase performed binomialheapmerge merges root lists binomial heaps h1 single linked list sorted degree monotonically increasing order roots degree phase links roots equal degree root remains degree linked list sorted degree perform link operations procedure works lines start merging root lists binomial heaps h1 single root list root lists h1 sorted strictly increasing degree binomialhe apmerge returns root list sorted monotonically increasing degree root lists h1 roots altogether binomialheapmerge runs time repeatedly examining roots heads root lists appending root lower degree output root list removing input oot list process binomialheapunion procedure initia lizes pointers root list simply returns lines uniting binomial heaps root procedure maintain pointers root list points root examined prevx points root preceding root list sibling prevx initially predecessor start prev set nil nextx points root root list sibling nextx initially roots root list degree h1 binomial heaps root degree binomialheapmerge guarantees roots degree adjacent root list fact execution binomialheapunion roots degree appearing root list time moment situation occur iteration loop lines decide link nextx based degrees degree siblingnextx invariant loop time start body loop nextx nonnil exercise precise loop invariant case figure occurs degreex degreenextx root bktree nextx root bltree lines handle case dont link nextx simply march poi nters position farther list updating nextx point node node handled common case figure cases occur binomialheapunion labels serve identify roots involved degrees keys roots case root bktree case degreex degreenextx pointers position farther root list case degreex degreenextx degreesiblingnextx pointers position farther list iteration executes case case case degreex degreenextx degreesiblingnextx keyx keynextx remove nextx root list link creating bk1tree case degreex degreenextx degreesiblingnextx keynextx keyx remove root list link nextx creating bk1tree case figure occurs oots equal degree degreex degreenextx degreesiblingnextx handle case manner case march pointers position farther list iteration ecute case case combine equaldegree roots tests cases lines handle cases cases occur roots equal degree degreex degreenextx degreesiblingnextx cases occur iteration occurs case cases link nextx cases distinguished nextx smaller key determines node root linked case figure keyx keynextx nextx linked removes nextx root list nextx leftmost child case figure smaller key linked nextx lines remove root list cases depending root listleftmost child nextx updates iteration case case setup iteration loop linked bktrees form bk1tree points bk1trees root list binomialheap merge bk1trees root list enter case iteration degreex degreenextx enter case case iteration enter case iteration running time nomialheapunion olg total number nodes binomial heaps h1 h1 n1 nodes nodes n1 h1 lg n11 roots lg n21 roots lg n1lg n22 lg olg roots nomialheapmerge time perform binomialheapmerge olg iteration loop takes o1 time lg n1 lgn2 iterations iteration advances pointers position root list removes root root list total time olg inserting node procedure inserts node binomial heap assuming allocated keyx filled binomialheapinserth makebinomialheap px nil childx nil siblingx nil degreex headh binomialheapunionh procedure simply onenode binomial heap o1 time unites nnode binomial heap olg time binomialheapunion takes care freeing temporary binomial heap direct implementation binomialheapunion exercise extracting node minimum key procedure extracts node minimum key binomial heap returns pointer extracted node binomialheapextractminh root minimum key root list remove root list makebinomialheap reverse order linked list children set headh point head list binomialheapunionh return procedure works figure input binomial heap figure figure situation root minimum key removed root list root bktree property lemma children left roots bk1 bk2 b0trees figure reversing list children binomial heap node tree tree removed binomial heap uniting figure nodes originally finally returns figure action binomialheapextractmin binomial heap root minimum key removed root list linked list children reversed binomial heap result uniting lines takes olg time nodes binomialheapextractmin runs olg time decreasing key procedure decreases key node binomial heap signals error greater current key binomialheapdecreasekeyh keyx error key greater current key keyxnil keyy keyz exchange keyy keyz satellite fields exchange figure procedure decreases key manner binary minheap bubbling key heap ter ensuring key fact greater current key assigning key procedure tree initially pointing node iteration loop lines keyy checked key parent root keyy keyz binomial tree minheapordered node violates minheap ordering key exchanged key parent satellite procedure sets level tree continues iteration figure action binomialheapdecreasekey situation iteration loop node key decreased key parent keys nodes exchanged situation iteration pointers moved level tree min heap order violated exchange moving pointers level minheap order satisfied loop terminates binomialheapdecreas ekey procedure takes olg time property lemma maximum depth lg loop lines iterates lg times deleting key easy delete node key satellite binomial heap olg time implementation assumes node binomial heap key binomialheapdeleteh binomialheapdecreasekeyh binomialheapextractminh binomialheapdelete procedure node unique minimum key entire binomial heap key exercise deals situation key temporaril bubbles key satellite root calling binomialheapdecreasekey root removed binomialheapextractmin binomialheapdelete procedure takes olg time exercises write pseudocode binomialheapmerge exercises binomial heap node key inserted binomial heap figure exercises binomial heap node key deleted binomial heap figure exercises argue correctness binomialheapunion loop invariant start iteration loop lines points root root degree roots degree roots degree roots preceding predecessor root li unique degrees root list predecessor degree degree root list unique finally node degrees monotonically increase traverse root list exercises explain binomialheapminimum pro cedure work correctly keys rewrite pseudocode work correctly cases exercises suppose represent key rewrite binomialheapdelete procedure work correctly situation olg time exercises discuss relationship inserting binomial heap incrementing binary number relationship uniting binomial heaps adding binary numbers exercises light exercise rewrite binomialheapinsert insert node directly binomial heap cal ling binomialheapunion exercises root lists strictly decreasing order degree strictly increasing order binomial heap ope rations implemented changing asymptotic running time exercises inputs binomialheapextractmin binomialheapdecreasekey binomialheapdelete lg time explain worstcase running times binomial heapinsert binomialheapminimum binomialheapunion lg problem problems heaps chapter introduced tree internal node root children eaves depth problem implement heaps support mergeableheap operations heaps differ trees ways heaps leaves store keys leaf stores key field keyx ordering keys leaves left keys order internal node smallx equal smallest key stored leaf subtree rooted root field heightr height tree finally heaps intended main memory disk reads writes needed implement heap operations ach operations parts olg time heap elements union operation olg time number elements input heaps minimum returns pointer leaf smallest key decreasekey decreases key leaf keyx insert inserts leaf key delete deletes leaf extractmin extracts leaf smallest key union unites heaps retu rning single heap destroying input heaps problems minimumspanningtree algorithm binomial heaps chapter presents algorithms solve problem finding minimum spanning tree undirected graph binomial heaps devise minimumspanningtree algorithm connected undirected graph weight function wu weight edge minimum spanning tree acyclic subset connects vertices total weight minimized pseudocode proven correct techniques constructs minimum spanning tree maintains partition vi vertices set vi set vi vi edges incident vertices vi mstg ø vertex vi vg vi vi vi set vi choose set vi extract minimumweight edge assume loss generality vivi vi destroying implement algorithm ing binomial heaps manage vertex edge sets change represen tation binomial heap add operations mergeableheap operations figure running time implementation chapter notes binomial heaps introduced vuillemin brown studied properties chapter fibonacci heaps overview chapter binomial heaps support olg worstcase time mergeable heap operations insert minimum extractmin union operations decreasekey delete chapter examine fibonacci heaps support operations advant age operations involve deleting element o1 amortized time theoretical standpoint fibonacci heaps desirable number extractmin delete operations small lative number operations performed situatio arises applications algorithms graph problems decreasekey edge dense graphs edges o1 amortized time decreasekey adds big improvement lg worstcase time binary binomial heaps fast algorithms problems computing minimum spanning trees chapter finding singlesource shortest paths chapter essential fibonacci heaps practical point view constant factors programming complexity fibonacci heaps desirable ordinary binary kary heaps applications fibonacci heaps predomin antly theoretical simpler data structure ortized time bounds fibonacci heaps developed practical binomial heap fibonacci heap coll ection trees fibonacci heaps fact loosely based binomial heaps decreasekey delete invoked fibonacci heap tree heap binomial tree fibona cci heaps relaxed structure binomi heaps allowing improved asymptotic time bounds work maintains ructure delayed convenient perform dynamic tables fibonacci heaps offer good data structure designed amortized analysis mind intuition analyses fibonacci heap operations remai nder chapter rely heavily potential method exposition chapter assumes read chapter binomial heaps specifications operations chapter table figure summarizes time bounds operations nary heaps binomial heaps fibonacci heaps presentation structure fibonacci heaps relies binomialheap structure operations performed fibonacci heaps performed binomial heaps binomial heaps fibonacci heaps designed efficient support operation search operations refer ven node require pointer node input bonacci heap application store handle appl ication object fibonacciheap element handle fibonacciheap element application object defines fibonacci heaps discusses representation presents potential function amortized analysis implement mergeableheap operations achieve amortized time bounds figure remaining operations decrease key delete presented finally finishes key analysis explains curious data structure structure fibonacci heaps binomial heap fibonacci heap collection minheapordered trees trees fibonacci heap constraine binomial trees figure fibonacci heap figure fibonacci heap consisting minheapordered trees nodes dashed root list minimum node heap node key marked nodes blackened potential fibonacci heap complete repres entation showing pointers arrows child arrows left sideways arrows details remaining figures chapter determined appears trees binomial heaps ordered trees fibonacci heaps rooted unordered figure node pointer px parent pointer childx children children linked circular doubly linked list child list child child list pointers left righty point left siblin node child lefty righty order siblings child list arbitrary circular doubly linked lists advantages fibonacci heaps remove node circular doubly linked list o1 time lists concatenate splice circular doubly linked list o1 time descriptions fibonacci heap operations refer operations informally letting reader details implementations fields node number ildren child list node stored degreex booleanvalued field markx node lost child time child anothe node newly created nodes unmarked node unmarked child node decreasekey operation set mark fields false fibonacci heap accessed pointer minh root tree minimum key node called minimum node fibonacci heap fibonacci heap minh nil roots trees fibonacci heap linked left pointers circular doubly linked list called root list fibonacci heap pointer minh points node root list key minimum order trees root list arbitrary rely attribute fibonacci heap number nodes nh potential function mentioned potential method analyze performance fibonacci heap operations fibonacci heap number trees root list mh number marked nodes potential fibonacci heap defined gain intuition potential function potential fibonacci heap figure potential set fibonacci heaps sum potentials constituent fibonacci heaps assume unit potential pay onstant work constant large cover specific constanttime pieces work encounter assume fibonacci heap application heaps initial potential equation potential nonnegative subsequent times equation upper bound total amortized cost upper bound total actual cost sequence operations maximum degree amortized analyses perform maining sections chapter assume upper bound dn maximum degree node nnode fibonacci heap exercise mergeableheap operations supported dn lg support decreasekey delete dn olg mergeableheap operations analyze mergeableheap operations implemented fibonacci heaps operations makeheap insert minimum extractmin unionare supported fibonacci heap simply collection unordered binomial trees unordered binomial tree binomial tree defined recursively unordered binomial tree u0 consists single node unordered binomial tree consists unordered binomial trees uk1 root child root lemma properties binomial trees holds unordered binomial tree variation property exercise unordered binomial tree root degree greater node children root roots subtrees u0 u1 uk1 order nnode fibonacci heap collecti unordered binomial trees dn lg key idea mergeableheap operations fibonacci heaps delay work long performance tradeoff ong implementations operations number trees bonacci heap small extractmin operation determine maining nodes minimum node binomial heaps exercise pay price ensuring number trees small lg time insert node binomial heap unite binomial heaps shal attempt consolidate trees fibonacci heap insert node unite heaps save consolidation extractmin operation minimum node creating fibonacci heap fibonacci heap makef ibheap procedure allo cates returns fibonacci heap object nh minh nil trees mh potential fibonacci heap amortized cost makefibheap equal o1 actual cost inserting node procedure inserts node fibonacci heap assuming node allocated keyx filled fibheapinserth degreex px nil childx nil leftx rightx markx false concatenate root list root list minh nil keyx keyminh minh nh nh lines initialize structural fields node making circular doubly linked list adds root list o1 actual time node singlenode minheapordered tree unordered binomial tree fibonacci heap children unmarked lines update pointer minimum node fibonacci heap finally increments nh reflect addition node figure node key insert fibonacci heap figure figure inserting node fibonacci heap fibonacci heap fibonacci heap node key inserted node minheap ordered tree root list left sibling root binomialheapinsert procedure fibheapinsert attempt consolidate trees fibonacci heap consecutive fibheapinsert operations occur singlenode trees root list determine amortized cost fibheapinsert input fibonacci heap fibonacci heap th1 mh mh increase potential mh mh actual cost o1 amortized cost o1 o1 finding minimum node minimum node fibonacci heap pointer minh minimum node o1 actual time potential change amortized cost operation equal o1 actual cost uniting fibonacci heaps procedure unites fibonacci heaps h1 destroying h1 process simply concatenates root lists h1 determines minimum node fibheapunionh1 makefibheap minh minh1 concatenate root list root list minh1 nil minh2 nil minh2 minh1 minh minh2 nh nh1 nh2 free objects h1 return lines concatenate root lists h1 root list linesset minimum node sets nh total number nodes fibonacci heap objects h1 freed turns fibonacci heap fibheapinsert procedure consolidation trees occurs change potential h1 mh th1 mh1 th2 mh2 th1 th2 mh mh1 mh2 amortized cost fibheap union equal o1 actual cost extracting minimum node process extracting minimum node complicated operations presented delayed work consolidating trees root list finally occurs pseudocode tracts minimum node code assumes convenience node removed linked list pointers remaining list updated pointers extracted node left unchanged auxiliary procedure consolidate presented shortly fibheapextractminh minh nil child add root list px nil remove root list rightz minh nil minh rightz consolidateh nh nh return figure fibheapextractmin works making root minimum nodes children remo ving minimum node root list consolidates root list linking roots equal degree root remains degree figure action fibheapextractmin fibonacci heap situation minimum node removed root lis children root list array trees iterations loop lines procedure consolidate root list processed starting node pointed min pointers values iteration iteration loop values iteration loop lines situation time loop node key linked node key pointed node key linked node key pointed node key linked node key node pointed loop iteration set point root tree situation iterations loop fibonacci heap reconstruction root list array determination minh pointer start saving pointer minimum node pointer returned nil fibonacci heap binomialheapextractmin procedure delete node making zs children roots lines putting root list removing root list rightz node root list children remains bonacci heap returning set pointer minh root list point node case rightz minimum node fibheap extractmin figure fibonacci heap figure performed step reduce number trees fibonacci heap consolidating root list performed consolidate consolidating root list consists repeatedly executing steps root root list distinct degree roots root list degree keyx keyy link remove root list child operation performed fibheaplink procedure field degreex incremented mark cleared procedure consolidate auxiliary array a0 dnh ai root degreey consolidateh dnh ai nil node root list degreex nil node degree keyx keyy exchange fibheaplinkh nil minh nil dnh ai nil add ai root list minh nil keyai keyminh minh ai fibheaplinkh remove root list child incrementing degreex marky false consolidate procedure works lines initialize making entry nil loop lines processes root root list processing root ends tree rooted node identical processed roots degree set array entry adegreex point loop terminates root degree remain array point remaining root loop lines repeatedly links root tree node tree root degree root degree loop maintains invariant start iteration loop degreex loop invariant initialization ensures loop invariant holds time enter loop maintenance iteration loop points root degreex degreey link whichever smaller key parent othe result link operation lines exchange pointers link fibheaplink increments degreex leaves degreey node longer root pointer array removed bheaplink increments degreex restores invariant degreex termination repeat loop nil case root degree loop terminates set perform iteration loop figures array trees iterations loop lines iteration loop links occur figures fh figures result iterations loop remains clean loop lines completes empties root list lines reconstruct array fibonacci heap figure consolidating root list fibheapextractmin finishes decrementing nh returning pointer deleted node observe trees fibonacci heap unordered binomial trees fibheapextractmin executed unordered binomial trees afterward ways trees changed lines fibheapextractmin child root root exercise tree unordered binomial tree trees linked fib heaplink degree trees unordered binomial ees link occurs trees roots children structure tree structure uk1 ready amortized cost extracting minimum node nnode fibonacci heap odn denote fibonacci heap prior fibheapextractmin operation actual cost extracting minimum node accounted odn contribution dn children minimum node processed fibheapextractmin work lines consolidate remains analyze contribution loop lines size root list calling consolidate dn consists original rootlist nodes minus extracted root node children extracted node number dn time loop lines roots linked total work performed loop proportional dn total actual work extracting minimum node odn potential extracting minimum node mh potential afterward dn mh dn roots remain nodes marked operation amortized cost odn dn mh mh odn oth odn scale units potential dominate constant hidden oth intuitively cost performing link pa reduction potential links reducing number roots dn olg amortized cost extracting minimum node olg exercises fibonacci heap calling fibheapextractmin fibonacci heap figure exercises prove lemma holds unordered binomial trees property place property exercises mergeableheap ope rations supported maximum degree dn nnode fibonacci heap lg exercises professor mcgee devised data structure based fibonacci heaps mcgee heap structure fibonacci heap supports mergeableheap operations implementations operations fibonacci heaps insertion union perform consolidation worst case running times operations mcgee heaps professors data structure exercises argue operations keys comparing keys case implementations chapter mergeableheap operations o1 amortized time decreasing key deleting node decrease key node fibonacci heap o1 amortized time delete node nnode fibonacci heap odn amortized time operations preserve property trees fibonacci heap unordered binomial trees close bound maximum degree dn olg proving bound imply fibheapextractm fibheapdelete olg amortized time decreasing key pseudocode operation fibheapdecreasekey assume removing node linked list change structural fields removed node fibheapdecreasekeyh keyx error key greater current key keyx px nil keyx keyy cuth cascadingcuth keyx keyminh minh cuth remove child list decrementing degreey add root list px nil markx false cascadingcuth nil marky false marky true cuth cascadingcuth fibheapdecreasekey procedure works lines ensure key greater current key assign key root keyx keyy parent structural occur minheap order violated lines test condition minheap order violated occur start cutting cut procedure cuts link parent making root mark fields desired time bounds record piece history node suppose events happened node time root linked node children removed cuts child lost cut parent making root field markx true steps occurred child cut cut procedure clears markx performs step fibheaplink clears marky node linked node step performed time child cut marky set true child cut parent time linked node fibheapdecreasekey performs cascadingcut operation root test cascadingcut proc edure return unmarked procedure marks child ha cut returns marked lost child cut cascadingcut calls recursively parent cascadingcut pro cedure recurses tree root unmarked node cascading cuts occurred lines fibheapdecreasekey finish updating minh node key changed node key decreased mi nimum node iginal minimum node node figure execution calls fibheapdecreasekey starting fibonacci heap figure figure involves cascading cuts figures invokes cascading cuts figure calls fibheapdecreasekey initial fibonacci heap node key key decreased node root parent key unmarked marked node key key decreased node key root parent key marked cascading cut occurs node key cut parent unmarked root nother cascading cut occurs node key marked node cut parent unmarked root cascading cuts point node key root node root cascading cuts unmarke result fibheapdecreasekey operation minh pointing minimum node amortized cost fibheapdecreasekey o1 start determining actual cost fibheapdecreasekey procedure takes o1 time time perform cas cading cuts suppose cascadingcut recursively called times invocation fibheapdecreasekey cascadingcut takes o1 time exclusive recursive calls actual cost fibheapdecreasekey incl uding recursive calls compute change potential denote fibonacci heap prior fibheapdecreasekey operation recu rsive cascadingcut cuts marked node clears mark bit afterward thc trees original trees trees produced cascading cuts tree rooted mh marked nodes unmarked cascading cascadingcut marked node ange potential mh mh amortized cost fibheapdecreasekey o1 scale units potential dominate constant hidden potential function defined include term number marked nodes marked node cut cascading cut mark bit cleared potential reduced unit potential pays cut clearing mark bit othe unit compensates unit increase potential node root deleting node easy delete node nnode fibonacci heap odn amortized time pseudocode assume key fibonacci heap fibheapdeleteh fibheapdecreasekeyh fibheapextractminh fibheapdelete analogous binomialheapdelete minimum node fibonacci heap uniquely small key node removed fibonacci heap fibheapextractmin procedure amortized time fibheapdelete sum o1 amortized time fibheap decreasekey odn amortized time fibhe apextractmin dn olg amortized time fibheapdelete olg exercises suppose root fibonacci heap marked explain marked root argue doesnt matte analysis marked root linked node lost child exercises justify o1 amortized time fibheapdecreasekey average cost operation aggregate analysis bounding maximum degree prove amortized time bheapextractmin fibheapdelete olg upper bound dn degree node nnode fibonacci heap olg exercise trees fibonacci heap unordered binomial trees dn lg cuts occur fibheapdecrease key trees fibo nacci heap violate unordered binomial tree properties cut node parent loses children dn olg dn logn key analysis node fibonacci heap define sizex number nodes including subtree rooted note root listit node size exponential degreex bear mind degreex maintained accurate count degree lemma node fibonacci heap suppose degreex y1 yk denote children order linked earliest latest degreey1 degreeyiproof degreey1 note yi linked y1 yi1 children degreex node yi linked degreex degreeyi degreeyi time node yi lost child cut lost children conclude degreeyi finally analysis explains fibonacci heaps recall kth fibonacci number defined recurrence lemma express fk lemma integers proof proof induction assume inductive hypothesis lemma corollary complete analysis inequality proved exercise fk2 golden ratio defined equation lemma node fibonacci heap degreex sizex fk2 proof sk denote minimum ssible size nodes degreez trivially s0 s1 number sk size sk increases monotonically lemma y1 yk denote children order linked compute lower bound size count child y1 sizey1 lemma degreeyi monotonicity sk sdegree yi si2 induction sk fk2 nonnegative integer bases trivial induc tive step assume fi2sizex sk fk2 corollary maximum degree dn node nnode fibonacci heap olg proof node nnode fibonacci heap degreex lemma size base logarithms log fact integer log maximum degree dn node olg exercises professor pinocchio claims height nnode fibonacci heap olg professor mistaken exhibiting positive integer sequence fibonacci heap operations creates bonacci heap consisting tree linear chain nodes exercises suppose generalize cascadingcut rule cut node parent loses kth child integer constant rule values dn olg problems alternative implementation deletion professor pisano proposed variant fibheapdelete procedure claiming runs faster node deleted node pointed minh pisanodeleteh minh fibheapextractminh px nil cuth cascadingcuth add child list root list remove root list professors claim procedure uns faster based partly assumption performed o1 actual time wrong assumption good upper bound actual time pisanodelete minh bound terms degreex number calls cascadingcut procedure suppose pisanodelete fibonacci heap assuming node root bound potential terms degreex mh conclude amortized time pisanodelete asymptotically fibheapdelete minh problems fibonacciheap operations augment fibonacci heap support operations changing amortized running time fibonacciheap operations operation fibheapchangekey key node efficient implementation fibheapchangekey analyze amortized running time implementation cases greater equal keyx efficient implementation fibheapprune deletes min nh nodes nodes deleted arbitrary analyze amortized running time implementation hint modify data structure potential function chapter notes fibonacci heaps introduced fredman tarjan paper describes application fibonacci heaps problems singlesource shortest paths allpairs shortest paths weighted bipartite matc hing minimumspanningtree problem subsequently driscoll gabow shrairman tarjan developed relaxed heaps alternative fibonacci heaps rieties relaxed heaps amortized time bounds fibonacci heaps decreasekey o1 worstcase amortized time extractmin delete olg worstcase time relaxed heaps dvantages fibonacci heaps parallel algorithms chapter notes chapter data structures support fast decreasekey operations sequence values returned extractmin calls monotonically increasing time data integers specific range chapter data structures disjoint sets applications involve grouping distinct elements llection disjoint sets operations finding element belongs uniting sets chapter explores methods main taining data structure supports operations describes operations supported disjointset data structure presents simple application simple linkedlis implementation disjoint sets efficient representati rooted trees running time tree representation linear practical purposes theoretically superlinear defines discusses growing function slowly growing inverse appears running time operations treebased implementation amortized analysis prove upper bound running time barely superlinear disjointset operations disjointset data structure maintains collection disjoint dynamic sets set identified representative member set applications doesnt matter member representative care representative dynamic modifying set requests answer times applications prespecified rule choosing representative choosing smallest member set assuming elements ordered dynamicset implementations studied element set represented object letting denote object support operations makeset creates set memb representative sets disjoint require set unionx unites dynamic sets sx set union sets assumed disjoint prior operation representative set member sx implementations union choose representative sx representative require sets collection disjoint destroy sets sx removing collection findsetx returns pointer representative unique set chapter analyze running times disj ointset data structures terms parameters number makeset operations total number makeset union findset operations sets disjoint union operation reduces number sets union operations set remains number ion operations note makeset operations included total number operations assume makeset operations operations performed application disjointset data structures applications disjointset data structures arises determining connected components undirected graph b4 figure graph connected components figure graph connected components jb collection disjoint sets edge processed procedure connectedcomponents llows disjointset operations compute connected components graph connectedcomponents preprocessing step procedure samecomponent answers queries vertices connected component set vertices graph denoted set edges denoted connectedcomponentsg vertex vg makesetv edge findsetu findsetv unionu samecomponentu findsetu findsetv return true return false procedure connectedcomponents initially places vertex set edge unites sets exercise edges processed vertices connected component objects set connectedcomponents computes sets procedure samecomponent determine vertices connected component figure illustrates disjoint sets computed connectedcomponents actual implementation connect edcomponents algorithm representations graph disjointset data structure ould reference object representing vertex pointer disjointset object viceversa programming details pend implementation language address exercises suppose connectedcomponents undirected graph edges processed order list vertices connected component iteration lines exercises edges processed connectedcomponents vertices connected component set exercises execution connectedcomponents undirected graph connected components times findset called times union called express answers terms edges graph staticno changing timethe connected components computed faster depthfirst search exercise edges dynamically maintain connected components edge case implement ation efficient running depthfirst search edge linkedlist representation disjoint sets simple implement disjointset data structure represent set linked list object linked list serves sets representative object linked list set member pointer object set member pointer representative list maintains pointers head representative tail object list figure sets linked list objects order subject sumption object list representative figure linkedlist representations sets objects representative objects representative object list set member pointer object list pointer object list representative list pointers head tail objects result unione representative set linkedlist representation makeset findset easy requiring o1 time carry makeset create linked list object findsetx return pointer representative simple implementation union simplest implementation union opera tion linkedlist set representation takes time makeset findset figure perform union appending list list tail pointer list append list representative set element originally repres entative set update pointer representative object originally list takes time linear length list fact difficult sequence operations objects requires time suppose objects execute sequence makeset operations union operations figurespend time performing makeset operations ith union operation updates objects total number objects updated union operations operation number objects updated makeset makeset makeset unionx1 unionx2 unionx3 x4 unionxn1 figure sequence operations objects takes time time operation average linkedlist set representation simple implementation union total number operations operation average requires time amortized operation weightedunion heuristic worst case implementation union procedure requires average time appending longer list shorter list update pointer repres entative member longer list suppose list includes length list easily maintained append smaller list longer ith ties broken arbitrarily simple weightedunion heuristic single union operation time sets members theore sequence makeset union findset operations makeset operations takes lg time theorem linkedlist representation disjoint sets weightedunion heuristic sequence makeset union findset operations makeset operations takes lg time proof start computing object set size upper bound number times objects pointer presentative updated fixed object time representative pointer updated started smaller set time representative pointer updated set mbers time representative pointer updated set ha members ontinuing observe representative poi nter updated lg times set members largest set members objects representative pointer updated lg times union operations account updating head tail pointers list lengths time union operation total time updating objects lg time entire sequence operations easily makeset findset operation takes o1 time total time entire sequence lg exercises write pseudocode makeset finds union linkedlist representation weightedunion uristic assume object attribute repx pointing representative set set attributes heads tails sizes equals length list exercises data structure answers returned findset operations program linkedlist repres entation weightedunion heuristic makesetxi unionxi xi1 unionxi xi2 unionx1 x5 unionx11 x13 unionx1 x10 findsetx2 findsetx9 assume sets size operation union appends xjs list xis list exercises adapt aggregate proof theorem amortized time bounds o1 makeset findset olg union linkedlist representation weightedunion heuristic exercises tight asymptotic bound running time sequence operations figure assuming linkedlist representati weightedunion heuristic exercises simple change union procedure linkedlist representation removes tail pointer object list weightedunion heuristic change change asymptotic running time union procedure hint appending list splice disjointset forests faster implementation sjoint sets represent sets rooted trees node member tree representing set disjointset forest illustrated figure member points parent root tree representative parent straightforward algorithms representation faster linkedlist representation introducing heuristicsunion rank path comp ressionwe achieve asymptotically fastest disjoi ntset data structure figure disjointset forest trees representing sets figure tree left represents set representative tree represents set representative result unione perform disjoint set operations makeset operation simply creates tree node perf orm findset operation parent pointers root tree nodes visited path root constitute path union operation figure root tree point root heuristics improve running time improved li nkedlist implementation sequence union operations create tree linear chain nodes heuristics achieve running time lmost linear total number operations heuristic union rank weighteduni heuristic linkedlist representation idea root tree fewer nodes point root tree nodes explicitly keeping track size subtree rooted node approach eases analysis node maintain rank upper bound height node union rank root smaller rank point root larger rank union operation heuristic path compression simple effective figure findset operations node path point directly root path comp ression change ranks figure path compression opera tion findset arrows selfloops roots tree representing set prior executing findset triangles represent subtrees roots nodes node pointer parent set executing findset node path points directly root pseudocode disjointset forests implement disjointset forest ionbyrank heuristic track ranks node maintain integer rankx upper bound height number edges longest path descendant leaf singleton set created makeset initial rank single node tree findset operation leaves ranks unchanged applying union trees ere cases depending roots equal rank roots unequal rank root higher rank parent root lower rank ranks themse lves remain unchanged stead roots equal ranks arbitrarily choose roots parent increment rank method pseudocod designate parent node px link procedure subroutine called union takes pointers roots inputs makesetx px rankx unionx linkfindsetx findsety linkx rankx ranky px rankx ranky ranky ranky findset procedure path compression simple findsetx px px findsetpx return px findset procedure twopass method pass path root pass pa update node points directly root findset returns px root executed px returned case recursion bottoms executed recursive parameter px returns pointer root updates node point directly root pointer returned heuristics running time separately union rank path compression improves running time operations disjointset forests improvement greater heuristics union rank yields running time lg exercise bound tight exercise prove makeset operations union operations findset operations pathcompression heuristic worstcase running time log2 union rank path compression worstcase running time slowly growing function define conceivable application disjointset data structure view running time linear practical situations prove upper bound exercises exercise disjointset forest union rank path compression exercises write nonrecursive version findset path compression exercises sequence makeset union findset operations makeset operations takes lg time union rank exercises sequence makeset findset link operations link operations findset operations takes time path compression union rank situation pathcompression heuristic analysis union rank path compression running time combined unionbyrank path compression heuristic disjointset operations elements examine function slowly grows prove running time potential method amortized analysis growing function slowly growing inverse integers define function akj expression functionalitera tion notation refer parameter level function function akj strictly increases function grows closedform expressions a1j a2j lemma integer a1j proof induction base case inductive step assume finally note lemma integer a2j j1j proof induction base case inductive step assume finally note akj grows simply examining ak levels definition a0k lemmas a01a11 a21 a31 a2a21 a27 a41 a3a31 a32047 a22047 estimated number atoms observable universe define inverse function ak integer min ak1 lowest level ak1 values ak1 impractically large values greater a41 huge number practical purposes properties ranks remainder prove bound running time disjointset operations union rank path compression order prove bound prove simple properties ranks lemma nodes rankx rankpx strict inequality px rankx initially increases time px rankx change rankpx monotonically increases time proof proof straightforward induction number operations implementations makeset uni findset leave exercise corollary follow path node root node ranks strictly increase lemma node rank proof nodes rank starts incr eases link operations union operations link operations link operation leaves ranks increases nodes rank ranks lemma weak bound ranks fact node rank lg exercise looser bound lemma suffice purposes proving time bound potential met hod amortized analysis prove omn time bound performing amortized anal ysis convenient assume invoke link operation union operation parameters link procedure pointers roots assume findset operations performed separately followi lemma count extra findset operations induced union calls asymptotic running time remains unchanged lemma suppose convert sequence makeset union findset operations sequence makeset link findset operations turning union findset operations link sequence runs time sequence runs time proof union operation sequence converted operations time bound converted sequence implies time bound original sequence remainder sh assume initial sequence makeset union findset opera tions converted sequence makeset link findset operations prove time bound converted sequence appeal lemma prove running time original sequence operations potential function potential function assigns potential qx node disjointset forest operations sum node potentials potential entire forest denotes potential forest operations forest prior operation arbitrarily set potential negative qx depends tree root qth operation rankx qx rankx suppose qth operation root rankx define auxiliary functions define qx define levelx max rankpx ak rankx level greatest level ak applied rank greater parents rank claim rankpx rankx lemma a0rankx definition a0j implies level rankx akj strictly increasing definition rankpx lemma implies level note rankpx monotonically increases time level auxiliary function iter largest number tim iteratively apply alevelx applied initially rank greater parents rank claim implies iter implies iter rankx note rankpx monotonically increases time order iter decrease level increase long levelx remains unchanged iterx increase remain unchanged auxiliary functions place ready define potential node operations lemmas properties node potentials lemma node operation counts qx rankx proof root rank qx rankx definition suppose root rankx lower bound qx maximizing level iterx bound level bound iterx rankx qx rank rankx rankx rankx upper bound qx minimizing level iter bound level bound iterx qx rankx rankx rankx potential amortized costs operations ready examine disjoints operations affect node potentials understanding change potential operation determine operations amortized cost lemma node root suppose qth operation link findset qth operation qx q1x rank levelx iter qth operation qx q1x potential increase positive rank levelx iter potential drops proof root qth operation change rankx change initial makeset operations remains unchanged components formula potential remain qth operation rankx qx q1x assume rankx recall level monotonically increases time qth operation leaves level unchanged iterx increases rema ins unchanged levelx iter unchanged qx q1x level unchanged iterx increases increases qx q1x finally qth operation increases levelx increases term levelx rank drops rankx levelx increased iterx drop bound drop rankx increase potential change iterx decrease potential change levelx conclude qx q1x final lemmas amor tized cost makeset link set operation recall equation amortized cost operation actual cost increase potential operation lemma amortized cost makeset operation o1 proof suppose qth operation makeset operation creates node rank qx ranks potentials change q1 noting actual cost makeset operation o1 completes proof lemma amortized cost link operation proof suppose qth operation link actual cost link operation o1 loss generalit suppose link parent determine change potential link note nodes potentials change children prior operation node potential increase link increase lemma node child link potential increase link definition qx root qth operation q1x rankx rankx qx q1x qx levelx rankx iter rankx inequalities quantity q1x potential decreases root prior link q1y ranky link operation leaves root leaves rank increases rank qy q1y qy q1y increase potential link operation amortized cost link operation o1 lemma amortized cost findset operation proof suppose qth operation findset path nodes actual cost findset operation nodes potential increases findset max0 nodes path potential decrease nodes potential creases appeal lemma nodes root root potential rankx change max0 nodes potential decrease node path rankx path node root levely levelx findset operation node follow path nodes path satisfy constraints satisfy node path rank node path root node path levelw node potential decreases levelx level prior path compre ssion caused findset putting inequalities letting iterx path compression path compression parent path compression rankpx rankpy path compression decrease rankpy rankx change path compression path compression iter increase levelx increase occurs iterx increases rank case lemma qx q1x potential decreases amortized cost findset operation actual cost change potential actual cost total potential decreases max0 amortized cost scale units potential dominate constant hidden putting preceding lemmas yields theorem theorem sequence makeset union findset operations makeset operations performed disjoi ntset forest union rank path compression worstcase time proof lemmas exercises prove lemma exercises prove node rank lg exercises light exercise bits store rankx node exercises exercise simple proof operations disjointset forest union rank path compression lg time exercises professor dante reasons node ranks increase strictly path root node levels monotonically increase path rankx px root levelx levelpx professor correct exercises function min ak lg practical values exercise modify potentialfunction argument prove sequence makeset union findset operations makeset operations performed disjointset forest union rank path compression worstcase time problems offline minimum offline minimum problem asks maintain dynamic set elements domain operations insert extractmin sequence insert extractmin calls key inserted determin key returned extractmin array extractedextractedi key returned ith extractmin problem offline sense allowed process entire sequence determining returned keys instance offline minimum problem insert represented number extractmin represented letter correct values extracted array develop algorithm problem break sequence homogeneous subsequences represent i1 im1 represents single extractmin represents sequence insert calls subsequence initially place keys inserted operations set offlineminimummdetermineextractedj smallest greater set kl exists kl kl destroying return extracted argue array extracted returned offlineminimum correct implement offlineminimum efficiently disjointset data structure tight bound worstcase running time implementation problems depth determination depthdetermination problem maintain forest rooted trees operations maketree creates tree node finddepth returns depth node tree graft node assumed root tree child node assumed tree root suppose tree representation disjointset forest pv parent node pv root implement graft setting finddepth path root returning count nodes encountered worstcase running time sequence maketree finddepth graft operations unionbyrank pathcompressi heuristics reduce worstcase running time disjointset forest set tree corresponds tree forest tree structure set correspond fact implementation record exact parentchild relationships determine nodes depth key idea maintain node pseudodistance dv defined sum pseudodistances path root set equals depth path root v0 v1 vk v0 vk sis root depth implementation maketree modify findset impl ement finddepth implementation perform path compression runn ing time linear length path implementation updates pseudodistances correctly implement graft combines sets modifying union link procedures implementation updates pseudodistances correctly note root set root tree tight bound worstcase running time sequence maketree finddepth graft operations maketree operations problems tarjans offline eastcommonancestors algorithm common ancestor nodes rooted tree node ancestor greatest depth offline leastcommon ancestors problem rooted tree arbitrary set unordered pairs nodes determine common ancestor pair solve offline leastcommonancestors problem procedure performs tree walk initial lca roott node assumed colored white prior walk lcau makesetu ancestorfindsetu child lcav unionu ancestorfindsetu coloru black node colorv black print common ancestor ancestorfindsetv argue executed pair argue time lca number sets disjointset data structure equal depth prove lca correctly prints common ancestor pair analyze running time lca assuming implementation disjointset data structure chapter notes disjointset data structures tarjan aggregate analysis tarjan tight upper bound terms slowly growing inverse ackermanns function function akj ackermanns function function inverse conceivable values lg upper bound proven earlier hopcroft ullman treatment adapted analysis tarjan turn based analysis kozen harfst reingold potentialbased version tarjans earlier bound tarjan van leeuwen discuss variants pathcompression heuristic including onepass methods offer constant factors performance twopass methods tarjans earlier analyses basic pathcompression heuristic analyses tarjan van leeuwen aggregate harfst reingold change potential function adapt path compression analysis onepass variants gabow tarjan applications disjointset operations time tarjan lower bound time required operations disjointset data structure satisfying technical conditions lower bound generalized fredman saks worst case lg nbit memory accessed vi graph algorithms chapter list chapter elementary graph algorithms chapter minimum spanning trees chapter singlesource shortest paths chapter allpairs shortest paths chapter maximum flow introduction graphs pervasive data structure puter science algorithms working fundamental field hund reds interesting computational problems defined terms graphs touch chapter represent graph computer discusses algorithms based searching graph breadthfirst search depthfirst search applications depthfirst search topologically sorting directed acyclic graph decomposing directed graph connected components chapter describes compute minimumwe ight spanning tree graph tree defined leastweight conn ecting vertices edge weight algorith computing minimum spanning trees good examples greedy algorithms chapter chapters problem computing hortest paths vertices edge length weight chapter considers computation shortest paths source vertex vertices chapter considers computation shortest paths tween pair vertices finally chapter compute maximum flow material network directed graph source material sink capacities material traverse directed edge general problem arises forms good algor ithm computing ximum flows solve variety problems efficiently describing running time graph algorithm graph measure size input rms number vertices number edges graph relevant parameters describing size input adopt common notational conventi parameters inside asymptotic notation onotation notation inside notation symbol denotes symbol denotes algorithm runs time ov meaning algorithm runs time ove convention runningtime formulas easier ead risk ambiguity convention adopt appears pseudocode denote rtex set graph edge set pseudocode views vertex edge sets attributes graph chapter elementary graph algorithms chapter presents methods representing graph searching graph searching graph systematically edges graph visit vertices graph graphsearching algorithm discover structure graph algorithms searching input graph structural graph algorithms organized simple ela borations basic graphsearching algorithms techniques searching graph heart field graph algorithms discusses common computat ional representations graphs adjacency lists adjacency matrices presents simple graphsearching algorithm called breadthfirst search create breadthfirst tree presents depthfirst search proves andard order depthfirst search visits vertices real application depthfirst search topologically sorting directed acyclic graph application depthfirst search finding connected components directed graph representations graphs standard ways represent graph collection adjacency lists adjacency matrix eith applicable directed undirected graphs adjacencylist representation eferred compact represent sparse graphsthose v2 graph algorithms presented book assume input graph represented adjacencylist form adjacencymatrix representation preferred graph densee close v2or edge connecting vertices tw allpairs shortestpaths algorithms presented chapter assume input graphs represented adjacency matrices adjacencylist representation graph consists array lists vertex adjacency list vertices edge adju consists vertices adjacent alternatively pointers thes vertices vertices adjacency list typically stored arbitrary order figure adjacencylist representation undirected graph figure figure adjacencylist representation directed graph figure figure representations undirected graph undirected graph vertices edges adjacencylist representation adjacencymatrix representation figure representations directed graph directed graph vertices edges adjacencylist representation adjacencymatrix representation directed graph sum ngths adjacency lists edge form represented adju undirected graph sum lengths adjacency lists undirected edge appears adjacency list vice versa bo directed undirected graphs adjacencylist representation desirable property memory requires adjacency lists adapted represent weighted graphs graphs edge weight typically weight function weighted graph weight function weight wu edge simply stored vertex adjacency list adjacencylist representation robust modified support graph variants potential disadvantage adjacencylist representation quicker determine edge graph search adjacency list adju disadvantage remedied adjacencymatrix representation graph cost asymptotically memory exercise suggestions variations adjacency lists permit faster edge lookup adjacencymatrix representation graph assume vertices numbered arbitrary manner adjacencymatrix representation graph consists matrix aij figures adjacency matrices undirected directed graphs figures adjacency matrix graph requires v2 memory independent number edges graph observe symmetry main diagonal adjacency matrix figure define transpose matrix aij matrix undirected graph represent edge adjacency matrix undirected graph transpose applications pays store entries diagonal adjacency matrix cutti memory needed store graph half adjacencylist representation aph adjacencymatrix representation weighted graphs weighted graph edgeweight function weight wu edge simply stored entry row column adjacency matrix edge exist nil stored matrix entry problems convenient adjacencylist representation asymptotically efficient adjacencymatrix representation simplicity adjacency matrix preferable graphs small graph unweighted additional advantage storage adjacencymatrix representation word computer memory matrix entry jacency matrix bit entry exercises adjacencylist representation rected graph long compute outdegree vertex long compute indegrees exercises adjacencylist representation complete binary tree vertices equivalent adjacencymatrix representation assume vertices numbered binary heap exercises transpose directed graph graph gt gt edges reversed efficient algorithms computing gt adjacencylist adja cencymatrix representations analyze running times algorithms exercises adjacencylist representation multigraph ov etime algorithm compute adjacencylist repres entation equivalent undirected graph consists edges multiple edges vertices replaced single edge selfloops removed exercises square directed graph graph g2 g2 edge path edges efficient algo rithms computing g2 adjacencylist adjacencymatrix representations analyze running times algorithms exercises adjacencymatrix representation graph algorithms require time v2 exceptions determining directed graph universal sinka vertex indegree outdegree determined time ov adjacency matrix exercises incidence matrix directed graph matrix bij entries matrix product represent transpose exercises suppose linked list array entry adju hash table vertices edge lookups equally expected time determine edge graph disadvantages scheme alternate data structure edge list solves problems alternative disadvantages compared hash table breadthfirst search breadthfirst search simplest algorithms searching graph archetype graph algorithms prim minimumspanningtree algorithm dijkstras singlesource shortestpaths algorithm ideas breadthfirst search graph distinguished source vertex breadthfirst search systematically explores edges discover vertex reachable computes distance smallest number edges reachable vertex produces breadthfir tree root reachable vertices vertex reachable path breadthfirst tree corresponds shortest path path smallest number edges algorithm works directed undirected graphs breadthfirst search named expands frontier discovered undiscovered vertices uniformly breadth frontier algorithm discovers vertices distance discovering vertices distance track progress breadthfirst search colors vertex white gray black vertices start white ecome gray black vertex discovered time encountered search time nonwhite gray black vertices discovered breadthfirst search distinguishes ensure search pro ceeds breadthfirst manner vertex black vertex gray black vertices adjacen black vertices discovered gray vertices adjacent white vertices represent frontier discovered undiscovered vertices breadthfirst search constructs breadthfirst tree initially root source vertex white vertex discovered scanning adjacency list discovered vertex vertex edge tree predecessor parent breadthfirst tree vertex discovered parent ancestor descendant relationships breadthfirst tree defined relative root usual path tree root vertex ancestor descendant breadthfirstsearch procedure bfs assumes input graph represented adjacency lists maintains additi onal data structures vertex graph color vertex stored variable coloru predecessor stored variable predecessor discovered nil distance source vertex computed algorithm stored algorithm firstin firstout queue manage set gray vertices bfsg vertex coloru white nil colors graynil ø enqueueq ø dequeueq adju colorv white colorv gray dvenqueueq coloru black figure illustrates progress bfs sample graph figure operation bfs undirected graph tree edges shaded produced bfs vertex queue iteration loop lines vertex distances vertices queue procedure bfs works lines paint vertex white set infinity vertex set parent vertex nilline paints source vertex gray considered discovered procedure initializes sets predecessor source nil lines initialize queue vertex loop lines iterates long remain gray vertices discovered vertices adjacency lists fully examined loop maintains invariant test queue consists set gray vertices loop invariant prov correctness easy holds prior iteration iteration loop maintains invariant prior iteration gray vertex vertex source vertex determines gray vertex head queue removes loop lines considers vertex adjacency list white discovered algorithm disc overs executing lines grayed distance dv set du1 recorded parent finally tail queue vertices adjacency list examined blackened lines loop invariant maintained vertex painted gray enqueued vertex dequeued painted black breadthfirst search depe order neighbors vertex visited breadthfirst tree distances computed algorithm exercise analysis proving properties breadthfirst search easier job analyzing running time input graph aggregate analysis initialization vertex whitened test ensures vertex enqueued dequeued operations enqueuing dequeuing o1 time total time devoted queue operations ov adjacency list rtex scanned vertex dequeued adjacency list scanned sum lengths adjacency lists total time spent scanning adjacency lists oe overhead initialization ov total running time bfs ov breadthfirst search runs time linear size adjacency list representation shortest paths claimed breadthfirst search finds distance reachable vertex graph source vertex define shortestpath distance minimum number edges path vertex vertex path path length shortest path1 showing breadthfirst search computes shortestpath distan ces investigate importa property shortestpath distances lemma directed undirected graph arbitrary vertex edge proof reachable case shortest path longer shortest path edge inequality holds reachable inequality holds bfs properly computes dv vertex dv bounds lemma directed undirected graph suppose bfs source vertex termination vertex dv computed bfs satisfies dv proof induction number enqueu operations inductive hypothesis dv basis induction situation imme diately enqueued bfs inductive hypothesis holds dv inductive step onsider white vertex discovered search vertex inductive hypothesis implies assignment performed lemma dv vertex enqueued enqueued grayed clause lines executed white vertices dv inductive hypothesis maintained prove dv precisely queue operates bfs lemma times distinct values queue lemma suppose execution bfs graph queue vertices v1 v2 vr v1 head vr tail dvr dv1 dvi dvi1proof proof induction number queue operations initially queue lemma holds inductive step prove lemma holds dequeuing enqueuing vertex head v1 queue dequeued v2 head queue lemma holds vacuously inductive hypothesis dv1 dv2 dvr dv1 dv2 remain ing inequalities unaffected lemma v2 head enqueuing vertex requires closer examination code enqueue vertex bfs vr1 time removed vertex adjacency list scanned queue inductive hypothesis head v1 dv1 dvr1 dv dv1 inductive hypothesis dvr dvr dv dvr1 remaining inequalities una ffected lemma enqueued corollary values time vertices enqueued monotonically increasing time corollary suppose vertices vi enqueued execution bfs vi enqueued dvi dvj time enqueued proof lemma property vertex receives finite bfs prove breadthfirst search correctly finds shortestpath distances theorem correctness breadthfirst search directed undirected graph suppose bfs source vertex execution bfs discovers vertex reachable source termination dv vertex reachable shortest paths shortest path edge proof assume purpose contradi ction vertex receives equal shortest path distance vertex minimum receives incorrect lemma dv dv vertex reachable dv vertex preceding shortest path chose putting properties time bfs chooses dequeue vertex time vertex white gray black cases derive contradiction inequality white sets dv contradicting inequality black removed queue corollary dv contradicting inequality gray painted gray dequeuing vertex removed earlier dv dw corollary dw dv contradicting inequality conclude dv vertices reachable discovered infinite values conclude proof theorem observe dv shortest path shortest path traversing edge breadthfirst trees procedure bfs builds breadthfirst tree searches graph illustrated figure tree represented field vertex formally graph source define predecessor subgraph nil predecessor subgraph breadthfirst tree consists vertices reachable unique simple path shortest path breadthfirst tree fact tree connected theorem edges called tree edges bfs source graph lemma predecessor subgraph breadthfirst tree lemma applied directed undirected graph procedure bfs constructs predecessor subgraph breadthfirst tree proof bfs sets reachable sand consists vertices reachable forms tree theorem unique path vertex applying theorem inductively conclude path shortest path procedure prints vertices shortest path assuming bfs compute shortestpath tree printpathg print nil print path exists printpathg print procedure runs time linear numbe vertices path printed recursive pa vertex shorter exercises values result running breadth search directed graph figure vertex source exercises values result running bread thfirst search undirected graph figure vertex source exercises running time bfs input graph represented adjacency matrix algorithm modified handle form input exercises argue breadthfirst search assigned vertex independent order vertices adjacency list figure breadthfirst tree computed bfs depend ordering adjacency lists exercises directed graph source vertex set tree edges vertex unique path graph shortest path set edges produced running bfs matter vertices ordered adjacency list exercises types professional wrestlers good guys bad guys pair professional wrestlers rivalry suppose professional wrestlers list pairs wrestlers rivalries rtime algorithm determines ssible designate wrestlers good guys remainder bad guys rivalry good guy bad guy perform designation algorithm produce exercises diameter tree diameter largest shorte stpath distances tree efficient algorithm compute diameter tree analyze running time algorithm exercises connected undirected graph ov etime algorithm compute path traverses edge direction maze large supply pennies chapters generalize study shortest paths weighted graphs edge realvalue weight weight path sum weights constituent edges graphs considered chapter unweighted equivalently edges unit weight depthfirst search strategy depthfirst search implie search deeper graph depthfirst search edges explored discovered vertex unexplored edges leaving edges explored search backtracks explore edges leaving vertex discovered process continues discovered vertices reachable original source vertex undiscove red vertices remain selected source search repeat source entire process repeated vertices discovered breadthfirst search vertex discovered scan adjacency list discovered vertex depthfirst search records event setting predecessor field breadthfirst search predecessor subgraph forms tree predecessor subgraph produced depthfirst search composed trees search repeated multiple sources predecessor subgraph depthfirst search defined differently breadthfirst search nil predecessor subgraph depthfirst search forms depthfirst forest composed depthfirst trees edges called tree edges breadthfirst search vertices colored search state vertex initially white grayed discovered search blackened finished adjacency list examined completely technique guarantees vertex ends depthfirst tree trees disjoint creating depthfirst forest depthfirst search timestamps vertex vertex timestamps timestamp dv records discovered grayed timestamp records search finishes examining adjacency list blackens timestamps graph algorithms generally helpful reasoning behavior depthfirst search procedure dfs records discovers vertex variable finishes vertex variable timestamps integers discovery event finishing event vertices vertex vertex white time gray time time black pseudocode basic depthfirstsearch algorithm input graph undirected directed variable time global variable timestamping dfsg vertex coloru white nil time vertex coloru white dfsvisitu dfsvisitu coloru gray white vertex discovered time time time adju explore edgeu colorv white dfsvisitv coloru black blacken finished time time figure illustrates progress dfs graph figure figure progress depthfirstsearch algorithm dfs directed graph edges explored algorithm shaded tree edges dashed nontree edges labe led cross forward edges vertices timestamped discovery timefinishing time procedure dfs works lines pa int vertices white initialize fields nil resets global time counter lines check vertex turn white vertex visit dfsvisit time dfsvisit called vertex root tree depthfirst forest dfs returns vertex assigned discovery time finishing time dfsvisitu vertex initially white paints gray increments global variable time records time discovery time lines examine vertex adjacent recursively visit white vertex considered edge explored depthfirst search finally edge leaving explored lines paint black record finishing time note depthfirst search depend der vertices examined dfs order neighbors vertex visited dfsvisit visitation orders tend problems practice depthfirst search result effectively essentially equivalent running time dfs loops lines lines dfs time exclusive time execute calls dfsvisit breadthfirst search aggregate analysis procedure dfs visit called vertex dfsvisit invoked white vertices thing paint vertex gray execution dfsvisitv loop lines executed adjv times total cost executing lines dfsvisit running time dfs properties depthfirst search depthfirst search yields valuable structure graph basic property depthfirst search predecessor subgraph form forest trees structure depthfirst trees mi rrors structure recursive calls dfsvisit dfsvisitv called search adjacency list additionally vertex descendant vertex depthfirst forest discovered time gray property depthfirst search discovery finishing times parenthesis structure represent discovery vertex left parenthesis represent finishin parenthesis history discoveries finishings wellformed expression sense parentheses properly nested depthfirst search figure corresponds parenthesization figure stating condition parenthesis structure theorem figure properties depthfirst search result depthfirst search directed graph vertices timestamped edge types figure intervals discovery time finishing time vertex correspond parenthesization rectangle spans interval discovery finishing times vertex tree edges intervals overlap nested vertex smaller interval descendant vertex larger graph redrawn tree forward edges depthfirst tree edges descendant ancestor theorem parenthesis theorem depthfirst search directed undirected graph vertices conditions holds intervals dv fv disjoint descendant depthfirst forest interval contained interval dv fv descendant depthfirst tree interval dv fv contained interval descendant depthfirst tree proof case dv subcases dv subcase occurs dv discovered gray implies descendant discovered outgoing edges explored finished search returns finishes case theref ore interval dv fv contained interval subcase dv inequality implies intervals dv fv disjoint intervals disjoint vertex discovered gray vertex descendant case dv roles reversed argument corollary nesting descendants intervals vertex proper descendant vertex depthfirst forest directed undirected graph dv fv proof theorem theorem character ization vertex descendant depthfirst forest theorem whitepath theorem depthfirst forest directed undirected graph vertex descendant vertex time search discovers vertex reached path consisting white vertices proof assume descendant vertex path depthfirst tree descendant corollary dw white time suppose vertex reachable path white vertices time descendant depthfirst tree wit hout loss generality assume vertex path descendant closest vertex path doesnt descendant predecessor path descendant fact vertex corollary fw note discovered discovered finished dv fw theorem implies interval dv fv contained interval corollary descendant classification edges interesting property depthfirst search search classify edges input graph edge classification glean graph directed graph acyclic depthfirst search yields edges lemma define edge types terms depthfirst forest produced depthfirst search tree edges edges depthfirst forest edge tree edge discovered exploring edge edges edges connecting vertex ancestor depthfirst tree selfloops occur dire cted graphs considered edges forward edges nontree edges connecting vertex descendant depthfirst tree cross edges edges vertices depthfirst tree long vertex ancestor vertices depthfirst trees figures edges labeled type figure graph figure redrawn tree forward edges head downward depthfirst tree edges graph redrawn fashion dfs algorithm modified classify edges encounters key idea edge classified color vertex reached edge explored forward cross dges distinguished white tree edge gray edge black forward cross edge case specifi cation algorithm case observe gray vertices form linear chain descendants stack active dfsvisit invocations numbe gray vertices depth depthfirst forest vertex discovered exploration proceeds deepest gray vertex edge reaches gray vertex reaches ancestor case handles remaining possi bility edge forward edge dv cross edge dv exercise undirected graph biguity type classification edge case edge classified type classification list applies equivalently exercise edge classified whichever encountered dur ing execution algorithm forward cross edges occur depthfirst search undirected graph theorem depthfirst search undirected graph edge tree edge edge proof arbitrary edge suppose loss generality dv discovered nished finish gray adjacency list edge explored direction undiscovered white time explored edge direction tree edge explored direction edge gray time edge explored applications theorems sections exercises by3 chart row column bels white gray black cell point depthfirst search directed graph edge vertex color vertex color edge edge types chart depthfirst search undirected graph exercises depthfirst search works graph figure assume loop lines dfs procedure considers vertices alphabetical order assume adjacency list ordered alphabetically sh discovery finishing times vertex classification edge figure directed graph exercises exercises parenthesis structure depthfirst search figure exercises edge tree edge forward edge dv fv edge dv fv cross edge dv fv exercises undirected graph classifying edge tree edge edge encountered depthfirst search equivalent classifying iority types classification scheme exercises rewrite procedure dfs stack eliminate recursion exercises counterexample conjectur path directed graph dv depthfirst search descendant depthfirst forest produced exercises counterexample conjectur path directed graph depthfirst search result dv exercises modify pseudocode depthfirst search prints edge directed graph type difications undirected exercises explain vertex directed graph depthfirst tree incoming outgoing edges exercises depthfirst search undirected graph identify connected components depthfirst forest trees connected components precisely modi depthfirst search vertex assigned integer label ccv number connected components ccu ccv connected component exercises directed graph singly connected implies simple path vertices efficient algorithm determine directed graph singly connected arbitrary breadthfirst sear limited source depthfirst search search multiple sources conceptually breadthfirst search proceed multiple sour ces depthfirst search limited source approach reflects search typically breadthfirst search employed shortestpath distan ces predecessor subgraph source depthfirst search subroutine algorithm chapter topological sort depthfirst search perform topological sort directed acyclic graph dag called topological sort dag linear ordering vertices edge appears ordering graph acyclic linear ordering topological sort graph viewed ordering vertices horizontal directed edges left topol ogical sorting usual kind sorting studied directed acyclic graphs applications precedences events figure arises ofessor bumstead dressed morning professor garments socks shoes items order socks pants directed edge dag figure garment donned garment topological sort dag order dressed figure topologically sorted dag ordering vertices horizontal directed edges left figure professor bumstead topologically sort clothing dressed directed edge garment garment discovery finishing times depthfirst search vertex graph topologically sort vertices arranged left order decreasing finishing time note rected edges left simple algorithm topologically sorts dag topologicalsortg dfsg compute finishing times fv vertex vertex finished insert linked list return linked list vertices figure topologically sorted vertices reverse order finishing times perform topol ogical sort time depthfirst search takes time takes o1 time insert vertices linked list prove correctness algorithm key lemma characterizing directed acyclic graphs lemma directed graph acyclic depthfirst search yields edges proof suppose edge vertex ancestor vertex depthfirst forest ther path edge completes cycle suppose cycle depthfirst search yields edge vertex discovered preceding edge time dv vertices form path white vertices whitepath theorem vertex descendant depthfirst forest edge theorem topologicalsort produces topological sort directed acyclic graph proof suppose dfs dag determine finishing times vertices suffices pair distinct vertices edge fv edge explored dfsg edge explored gray ancestor edge contradicting lemma white black white descendant fv black finished fv set exploring assign timestamp fv edge dag fv proving theorem exercises ordering vertices produced topologicalsort dag figure assumption exercise figure dag topological sorting exercises lineartime algorithm input directed acyclic graph vertices returns number paths directed acyclic graph figure paths vertex vertex pov por yv posr yv psr yv algorithm ount paths list exercises algorithm determines wh ether undirected graph cycle algorithm ov time independent exercises prove disprove directed graph cycles topologicalsort produces vertex ordering minimizes number bad edges inconsistent ordering produced exercises perform topological sorting directed acyclic graph repeatedly vertex indegree output remove outgoing edges graph explain implement idea runs time ov algorithm cycles connected components classic application depthfirst search decomposi directed graph connected components decomposition depthfirst searches algorithms work directed graphs decomposition decomposition gorithm separately connected component solutions combined structure connections components recall appendix connected component directed graph maximal set vertices pair vertices vertices reachable figure figure directed graph connected components shaded regions vertex labeled discovery finishing times tree edges shaded graph gt transpose depthfirst forest computed stronglyconnectedcomponents hown tree edges shaded connected component corresponds depthfirst tree vertices heavily shaded roots depthfirst trees produced depthfirst search gt acyclic component graph gscc contracting edges connected component single vertex remains component algorithm finding connected components graph transpose defined exercise graph gt consists edges directions reversed adjacencylist representation time create gt ov interesting observe gt connected components reachable reachable gt figure transpose graph figure connected components shaded lineartime etime algorithm computes connected components directed graph depthfirst searches gt stronglyconnectedcomponents dfs compute finishing times vertex compute gt dfs gt main loop dfs vertices order decreasing computed output vertices tree depthfirst forest formed separate connected component idea algorithm mes key property component graph gscc vscc escc define suppose connected components ck vertex set vscc v1 v2 vk vertex vi connected component edge vi escc directed edge looked contracting edges incident vertices connected component graph gscc figure component graph graph figure key property component graph dag lemma implies lemma distinct connected components directed graph suppose path path proof path paths reachable ther eby contradicting assumption distinct connected components vertices depthfirst sear decreasing order finishing times computed depthfirst searc essence visiting vertices component gra corresponds connected component topologically sorted order stronglyconnectedcomponents performs depthfirst searches potential ambiguity discuss values refer discovery finishing times computed firs dfs extend notation discovery finishing times sets vertices define min max earliest discovery time latest finish ing time vertex lemma corollary key property relating connected components finishing times depthfirst search lemma distinct connected components directed graph suppose edge proof cases depending connected component discovered vertex depthfirst search vertex discovered time vertices white path vertex consisting white vertices vertex path time consisting white vertices whitepath theorem vertices descendants depthfirst tree corollary fx vertex discovered time vertices white path vertex consisting white vertices whitepath theorem vertices descendants depthfirst tree corollary time vertices white edge lemma implies path vertex reachable time vertices white vertex fw implies corollary tells edge gt connected components component earlier finishing time depthfirst search component finishing time corollary distinct connected components directed graph suppose edge proof connected components gt lemma implies corollary key understanding stronglyconnected components procedure works exam ine perform depthfirst search gt start connected component finishing time maximum search starts vertex visits vertices corollary edges gt connected component search visit vertices component tree rooted vertices completed visiting vertices search selects root vertex othe connected component finishing time maximum components search visit vertices corollary edges gt component visited general depthfirst search gt visits connected component edges component compone nts visited depthfirst tree connected component theorem formalizes argument theorem stronglyconnectedcomponents correctly computes connected components directed graph proof argue induction number dept hfirst trees depthfirst search gt vertices tree form connected component inductive hypothesis trees produced connected components basis induction trivial inductive step assume depthfirst trees produced connected component tree produced root tree vertex connected component choose roots depthfirst search connected component visited inductive hypothesis time search visits vertices white whitepath theorem vertices descendants depthfirst tree inductive hypothesis corollary edges gt leave connected components visited vertex connected component descendant depthfirst search gt vertices depthfirst tree gt rooted form connected component completes inductive step proof depthfirst search operates component graph gtscc gt map connect component visited depthfirst search vertex gtscc vertices gtscc visited reverse topologically sorted order reverse edges gtscc graph gtscct gtscct gscc exercise depthfirst search visits vertices gscc topologically sorted order exercises number connected ponents graph change edge exercises procedure stronglyconn ectedcomponents works graph figure finishing times computed forest produced assume loop lines dfs considers vertices alphabetical order adjacency lis alphabetical order exercises professor deaver claims algorith connected components simplified original transpose graph depthfirst search scanning vertices order increasing finishing times professor correct exercises prove directed graph gtscct gscc transpose component graph gt component graph exercises ov etime algorithm compute ponent graph directed graph edge vertices component graph algorithm produces exercises directed graph explain create graph connected components component graph small descri fast algorithm compute exercises directed graph semiconnected pairs vertices efficient algorithm determine semiconnected prove algorithm correct analyze running time problems classifying edge breadthfirst search depthfirst forest classifies edges graph tree forward cross edges breadthfirst tree classify edges reachable source search categories prove breadthfirst search undirected graph properties hold edges forward edges tree edge dv cross edge dv dv prove breadthfirst search rected graph properties hold forward edges tree edge dv cross edge dv edge dv problems articulation points idges biconnected components connected undirected graph articulation point vertex removal disconnects bridge edge removal disconnects biconnected component maximal set edges edges set lie common simple cycle figure illustrates definitions determine articulation points bridges biconnected components depthfirst search depthfirst tree figure articulation points bridges biconnected components connected undirected graph problem articulation points heavily shaded vertices bridges heavily shaded edges biconnected components edges shaded regions bcc numbering prove root articulation point children nonroot vertex prove articulation point child edge descendant proper ancestor compute lowv vertices oe time compute articulation points oe time prove edge bridge lie simple cycle compute bridges oe time prove biconnected components partition nonbridge edges oetime algorithm label edge positive integer bcce bcce bcce biconnected component problems euler tour euler tour connected directed graph cycle averses edge vi sit vertex euler tour indegree outdegree vertex oetime algorithm euler tour exists hint merge edgedisjoint cycles problems reachability directed graph vertex labeled unique integer lu set vertex set vertices reachable define min vertex label minimum min vertex lv min lw ov etime algorithm computes min vertices chapter notes tarjan excellent references graph algorithms breadthfirst search discovered moore context finding paths mazes lee independently discovered algor ithm context routing wires circuit boards hopcroft tarjan advocated adjacencylist representation adjacencymatrix representation sparse aphs recognize algorithmic depthfirst search dept hfirst search late artificial intelligence programs tarjan lineartime algorithm nding connected components algorithm connected components adapted aho hopcroft ullman credit kosaraju unpublished sharir gabow developed algorithm connected components based contracting cycles stacks linear time knuth lineartime algor ithm topological sorting chapter minimum spanning trees overview design electronic circuitry pins components electrically equiva lent wiring interconnect set pins arrangement wires connecting pins arrangements wire desirable model wiring problem connected undirected graph set pins set interconnections pairs pins edge weight wu cost ount wire needed connect acyclic subset connects vertices total weight minimized acyclic connects vertices form tree spanning tree spans graph problem determining tree minimumspanningtree problem figure connected graph minimum spanning tree figure minimum spanning tree nnected graph weights edges edges minimum spanning tree shaded total weight tree minimum spanning unique removing edge replacing edge yields spanning tree weight chapter examine gorithms solving minimumspanningtree problem kruskals algorithm prims algorithm easily time oe lg ordinary binary heaps fibonacci heaps prims algorithm sped time oe lg improvement smaller algorithms greedy algorithms chapter step algorithm choices greedy strategy advocates making choice mome strategy generally guaranteed globally optimal solutions probl ems minimumspanningtree problem prove greedy strategies yield spanning tree minimum weight chapter read independently chapter greedy methods presented classic applicati theoretical notions introduced introduces generic minimumspanni ngtree algorithm grows spanning tree adding edge time ways implement generic algorithm algorithm kruska connectedcomponents algorithm prim simila dijkstras shortestpaths algorithm phrase minimum spanning tree shor tened form phrase minimumweight spanning tree minimizing number edges spanning trees edges theorem growing minimum spanning tree assume onnected undirected graph weight function minimum spanning tree algorithms chapter greedy approach problem differ apply approach greedy strategy captured generic algorith grows minimum spanning tree edge time algorithm manages set edges maintaining loop invariant prior iteration subset minimum spanning tree step determine edge violating invariant sense subset minimum spanning tree edge safe edge safely maintaining invariant genericmstg ø form spanning tree edge safe return loop invariant initialization set trivially satisfies loop invariant maintenance loop lines intains invariant adding safe edges termination edges minimum spanni tree set returned minimum spanning tree tricky finding safe edge exist executed invariant dictates spanning tree loop body proper subset edge safe remainder provide rule theorem recognizing safe edges describes algorithms rule safe edges efficiently definitions cut undirected graph partition figure illustrates notion edge crosses cut endpoints cut respects set edges edge crosses cut edge light edge crossing cut weight minimum dge crossing cut note light edge crossing cut case ties generally edge light edge satisfying property weight minimum edge satisfying property figure ways viewing cut graph figure vertices set black white edges crossing cut connecting white vertices black vertices edge unique light edge crossing cut subset edges shaded note cut respects edge crosses cut graph vertices set left vertices set edge crosses cut connects vertex left vertex rule recognizing safe edges theorem theorem connected undirected graph realvalued weight function defined subset included minimum spanning tree cut respects light edge crossing edge safe proof minimum spanning tree includes assume light edge construct minimum spanning tree includes cutandpaste technique showing safe edge edge forms cycle edges path illustrated figure opposite sides cut edge path crosses cut edge edge cut respects unique path removing breaks components adding reconnects form spanning tree figure proof theorem vertices black vertices white edges minimum spanning tree edges graph edges shaded light edge crossing cut edge edge unique path minimum spanning tree formed removing edge adding edge minimum spanning tree light edge crossing crosses cut wu wx wt wt wx wu wt minimum spanning tree wt wt minimum spanning tree remains safe edge minimum spanning tree safe theorem understanding workings genericmst algorithm connected graph algorithm proceeds set acyclic minimum spanning tree including cycle contradiction point execution algorithm graph forest connected components tree trees vertex case exam ple algorithm forest trees vertex safe edge connects distinct components acyclic loop lines genericmst executed times edges minimum spanning tree successively determined initially ø trees iteration reduces number forest single tree algorithm terminates algorithms corollary theorem corollary connected undirected graph realvalued weight function defined subset included minimum spanning tree vc connected component tree forest light edge connecting component safe proof cut vc vc respects light edge cut safe exercises minimumweight edge graph belongs minimum spanning tree exercises professor sabatier conjectures converse theorem connected undirected graph realvalued weight function defined subset included minimum spanning tree cut respects safe edge crossing light edge cut professors onjecture incorrect counterexample exercises edge contained minimum spa nning tree light edge crossing cut graph exercises simple graph set edges exists cut light edge crossing form minimum spanning tree exercises maximumweight edge cycle prove minimum spanning tree minimum spanning tree minimum spanning tree include exercises graph unique minimum spanning tree cut graph unique light edge crossing cut converse true counterexample exercises argue edge weights graph positive subset edges connects vertices minimum total weight tree conclusion follow weights nonpositive exercises minimum spanning tree graph sorted list edge weights minimum spanning tree list sorted list edge weights exercises minimum spanning tree graph subset subgraph induced subgraph induced connected minimum spanning tree exercises graph minimum spanning tree suppose decrease weight edges minimum spanning tree formally minimum spanning tree edge weights weight function choose edge positive number define weight function minimum spanning tree edge weights exercises graph minimum spanning tree suppose decrease weight edges algorithm finding minimum spanning tree modified graph algorithms kruskal prim minimumspanningtree algorithms elaborations generic algorithm specific rule determine safe edge genericmst kruskals algorithm set forest safe edge leastweight edge graph connects distinct components prims algorithm set forms single tree safe edge leastweight edge connecting tree vertex tree kruskals algorithm kruskals algorithm based directly generic minimumspanningtree algorithm finds safe edge add growing forest finding edges connect trees forest edge weight denote trees connected light edge connecting tree corollary implies safe edge kruskals algorithm greedy algorithm step adds forest edge weight implementation kruskals algorithm algorithm compute connected components disjointset data structure maintain disjoint sets elements set vertices tree current forest operation findsetu returns representative elemen set determine vertices belong tree testing setu equals findsetv combining trees accomplished union procedure mstkruskalg ø vertex vg makesetv sort edges nondecreasing order weight edge nondecreasing order weight findsetu findsetv unionu return kruskals algorithm works figure lines initialize set set create trees vertex edges sorted nondecreasing order weight loop lines checks edge endpoints belong tree edge forest creating cycle edge discarded vertices belong trees case edge vertices trees merged figure execution kruskals algorithm graph figure shaded edges belong forest grown edges considered algorithm sorted order weight arrow points edge consideration step algorithm edge joins distinct trees forest forest merging trees running time kruskals algorithm graph depends implementation disjointset data struct ure assume disjointsetforest implementation unionbyrank pathcompression heuristics asymptotically fastest implementation initializing set takes o1 time time sort edges oe lg account cost makeset operations loop lines moment loop lines performs oe findset union operations disjointset forest makeset operations total ov time slowly growing function defined assumed connected disjointset operations oe time olg olg total running time kruskals algorithm oe lg observing v2 lg olg restate running time kruskals algorithm oe lg prims algorithm kruskals algorithm prims algorithm special case generic minimum spanningtree algorithm prims algorithm operates dijkstras algorithm finding shortest paths graph prims algorithm property edges set form single tree illustrated figure tree starts arbitrary root vertex grows tree spans vertices step light edge tree connects isolated vertex corollary rule adds edges safe algorithm terminates edges form minimum spanning tree strategy greedy tree augmen ted step edge contributes minimum trees weight figure execution prims algorithm graph figure root vertex shaded edges tree grown vertices tree black step algorithm vertices tree determine cut graph light edge crossing cut tree step algorithm choice adding edge edge tree light edges crossing cut key implementing prims algorithm efficien tly easy select edge tree formed edges pseudocode connected graph root minimum spanning tree grown inputs algorithm execution algorithm vertices tree reside minpriority queue based key field vertex keyv minimum weight edge connecting vertex tree convention keyv edge field names parent tree algorithm set generic mst implicitly algorithm terminates minpriority queue minimum spanning tree mstprimg keyu nil keyrø extractminq adju wu keyv keyv wu prims algorithm works figure lines set key vertex root key set vertex processed set parent vertex nil initialize minpriority queue vertices algorithm maintains threepart loop invariant prior iteration loop linesvertices minimum spanning tree vertices nil keyv key weight light edge connecting vertex minimum spanning tree identifies vertex incident light edge crossing cut exception iteration removing set adds set vertices tree adding loop lines update key fields vertex adjacent tree updating maintains loop invariant performance prims algorithm depends implement minpriority queue implemented binary minheap chapter buildmin heap procedure perform initialization lines ov time body loop executed times extractmin operation takes olg time total time calls extractmin ov lg loop lines executed oe times altogether sum lengths adjacency lists loop test membership implemented constant time keeping bit vertex tells updating bit vertex removed assignment nvolves implicit decreasekey operation minheap implemented binary minheap olg time total time prims algorithm ov lg lg oe lg asymptotically implementation kruskals algorithm asymptotic running time prims gorithm improved fibonacci heaps chapter elements organize fibonacci heap perform extractmin operation olg amortized time decrease key operation implement o1 amortized time fibonacci heap implement minpriority queue running time prims algorithm improves oe lg exercises kruskals algorithm return anning trees input graph depending ties broken edges sorted order minimum spanning tree sort edges kruskals algorithm algorithm returns exercises suppose graph represented acency matrix simple implementation prims algorith case runs ov2 time exercises fibonacciheap implementation prims algorithm asymptotically faster binaryheap implementation sparse graph dense graph v2 fibonacciheap implementation asymptotically fast binaryheap implementation exercises suppose edge weights graph integers range fast kruskals algorithm dge weights integers range constant exercises suppose edge weights graph integers range fast prims algorithm edge weights integers range constant exercises suppose edge weights graph uniformly distributed halfopen interval algorithm kruskals prims faster exercises suppose graph minimum spanning tree alread computed minimum spanning tree update vertex incident edges exercises professor toole proposes divide conquer algorithm computing minimum spanning trees graph partition set vertices sets v1 v2 v1 v2 differ e1 set edges incident vertices v1 set edges incident vertices v2 recursively solve minimumspanningtree problem subgraphs g1 v1 e1 g2 v2 finally select minimumweight edge crosses cut v1 v2 edge unite minimum spanning trees single spanning tree argue algo rithm correctly computes minimum spanning tree provide algorithm fails problems secondbest minimum spanning tree undirected connected graph weight function suppose edge weights distinct secondbest minimum spanning defined set spanning trees minimum spanning tree secondbest minimum spanning tree spanning tree minimum spanning tree unique secondbest minimum spanning tree unique minimum spanning tree prove exist edges secondbest minimum spanning tree spanning tree vertices maxu edge maximum weight unique path ov2time algorithm computes maxu efficient algorithm compute secondbest minimum spanning tree problems minimum spanni tree sparse graphs sparse connected graph improve oe lg running time prims algorithm ith fibonacci heaps preprocessing decrease number vertices running prims algorith choose vertex minimumweight edge incident minimum spanning tree construction contract chosen edges b4 contracting edges time firs identify sets vertices united vertex create gra contracting edges time ren aming edges sets endpoints edges original graph renamed case edge weight minimum weights original edges initially set minimum spanning tree constructed edge set origu wu orig attribute reference edge initi graph edge contracted graph attribute holds weight edge edges contracted updated scheme choosing edge weights procedure mstreduce takes inputs orig returns contracted graph updated attributes orig graph procedure accumulates edges minimum spanning tree mstreduceg orig vg markv false makesetv vg marku false choose adju minimized unionu origu marku markv true vg findsetv vg ø findsetx findsetyorig origxorig origx construct adjacency lists return orig set edges returned mstreduce minimum spanning tree graph formed mstprim vertex vg prove orig minimum spanning tree argue vg implement mstreduce runs oe time hint simple data structures suppose phases mstreduce outputs orig produced phase inputs orig phase accumulating edges argue running time phases suppose running phases mstreduce prims algorithm calling mstprim returned phase vertex pick running time oe lg lg argue choice minimizes asymptotic running time values terms prims algorithm preprocessing asymptotically beat prims algorithm preprocessing problems bottleneck spanning tree bottleneck spanning tree undirected graph spanning tree largest edge weight minimum spanning trees bottleneck spanning tree weight maximumweight edge argue minimum spanning tree bottleneck spanning tree finding bottleneck spanning tree harder finding minimum spanning tree remaining parts ill linear time lineartime algorithm graph integer determines bottlen eck spanning tree algorithm ubroutine lineartime algorithm bottleneckspanningtree problem hint subroutine contracts sets edges mstreduce procedure problem problems alternative minimumspanningtree algorithms problem pseudocode fferent algorithms takes graph input returns set edges algorithm prove minimum spanning tree prove minimum spanning tree efficient implementation algorith computes minimum spanning tree maybemstag sort edges nonincreasing order edge weights edge nonincreasing order weight connected graph return maybemstbg ø edge arbitrary order cycles return maybemstcg ø edge arbitrary order cycle maximumweight edge return chapter notes tarjan surveys minimumspanningtree probl excellent advanced material history minimumspa nningtree problem written graham hell tarjan attributes minimumspanni ngtree algorithm paper boruvka boruvkas algorithm consists running olg iterations procedure mstreduce problem kruskals algorithm reported kruskal algorithm commonly prims algorithm invented prim invented earlier jarník reason greedy algorithms effective finding minimum spanning trees set forests graph forms graphic matroid lg prims algorithm implemented fibonacci heaps runs oe time sparser graphs combination ideas prims algorithm kruskals algorithm boruvkas algorithm togeth advanced data structures fredman tarjan algorithm runs oe lg time gabow galil spencer tarjan improved algorithm oe lg lg time chazelle algorithm runs time functional inverse ackermanns function chapter notes chapter discussion ackermanns function inverse previous minimumspanningtr algorithms chazelles algorithm follow greedy method problem spanning tree verification graph tree determine minimum spanning tree king lineartime algorithm spanning verification building earlier work komlós dixon rauch tarjan algorithms deterministic fall comparisonbased model chapter karger klein tarjan randomized minimum spanningtree algorithm runs ov expected time algorithm recursion manner lineartime selection algorithm recursive auxiliary problem identifies subset edges minimum spanning tree recursive finds minimum anning tree algorithm ideas boruvkas algorithm kings algorithm spanning tree verification fredman willard minimum spanning tree ov time deterministic algorithm mparison based algor ithm assumes data bbit integers computer memory consists addressable bbit chapter singlesource shortest paths overview motorist wishes shortest possi ble route chicago boston road map united states distance tween pair adjacent intersections marked determine shortest route enumerate rout chicago boston add distances route select shortest eas disallow routes cycles millions possibilities simply worth route chicago houston boston poor choice houston miles chapter chapter solve problems efficiently shortestpaths problem weighted directed graph weight function mapping edges realvaluedweights weight path v0 v1 vk sum weights constituent edges define shortestpath weight shortest path vertex vertex defined path weight wp chicagotoboston model road map graph vertices represent intersections edges represent road segments intersections edge weights represent road distances goal shortest path intersection chicago clark addison ave intersection boston brookline ave yawkey edge weights interpreted metrics distances represent time cost penalties loss quantity accumulates linearly path wishes minimize breadthfirstsea rch algorithm shortestpaths algorithm works unweighted graphs graphs edge considered unit weight concepts breadth search study shortest paths weighted graphs reader encouraged review proceeding variants chapter focus singlesource shortestpaths problem graph shortest path source vertex vertex problems solved algorithm singlesource problem including variants singledestination shortestpaths problem shortest path destination vertex vertex reversing direction edge graph reduce problem singlesource problem singlepair shortestpath problem shortest path vertices solve singlesource problem source vertex solve problem algorithms problem asymptotically faster nglesource algorithms worst case allpairs shortestpaths problem shortest path pair vertices problem solved running singlesource algorithm vertex usua lly solved faster additionally structure intere chapter addresses allpairs problem optimal substructure shortest path shortestpaths algorithms typically rely property shortest path vertices shortest paths edm ondskarp maximumflow algorithm chapter relies property optimalsubstructure property hallmark applicability dynamic programming chapter greedy method chapter dijkstras algorithm greedy algorithm floydwarshall algorithm finds shortest paths pairs vertices chapter dynamicprogramming algorithm lemma states optimal substructure property shortest paths precisely lemma subpaths shortest paths shortest paths weighted directed graph weight function v1 v2 vk shortest path vertex v1 vertex vk pij vi vi1 subpath vertex vi vertex pij shortest path vi proof decompose path wp wp1i wpij wpjk assume path vi weight path v1 vk weight wp contradicts assumption shortest path v1 vk negativeweight edges instances singlesource shor testpaths problem edges weights negative graph negativeweight cycles reachable source shortestpath weight remains defined negative negativeweight cycle reachable shortestpath weights defined path vertex cycle shortest patha lesserweight path proposed shortest path traverses negativeweight cycle negativeweight cycle path define figure illustrates negative weights negativeweight cycles shortest path weights path path ws path wsinfinitely paths cycle weight shortest path weight shortest path weight ws wc analogously infinitely paths cycle weight shortest path traversing negativeweight cycle arbitrarily times paths arbitrarily large negative weights reachable paths arbitrarily large negative weights vertices form negativeweight cycl reachable figure negative edge weights directed graph vertex shortestpath weight source vertices form negativeweight cycle reachable shortestpath weights vertex reachable vertex shortestpath weight shortestpath weight vertices reachable shortestpath weights lie negativeweight cycle shortestpaths algorithms dijkstra algorithm assume edge weights input graph nonnegative roadmap exampl bellman ford algorithm negativeweight edges input graph produce correct answer long negativeweight cycles reachable source typically negativeweight cycle algorithm detect report existence cycles shortest path cycle negativeweight cycle positiveweight cycle removing cycle path produces path source destin ation vertices lower path weight v0 v1 vk path vi vi1 positiveweight cycle path vi wc path v0 v1 vi vj1 vk weight wp wp wc wp shortest path v0 vk leaves weight cycles rem ove weight cycle path produce path weight shortest path source vertex destination vertex weight cycle shortest path cycle long shortest path weight cycles repeatedly remove cycles path unt shortest path cyclefree loss generality assume finding shortest paths cycles acyclic path graph distinct vertices edges restrict attention shortest paths edges representing shortest paths compute shortestpath weights vertices shortest paths representation shortest paths breadth trees graph maintain vertex predecessor vertex nil shortestpaths algorithms chapter set attributes chain predecessors originating vertex runs backwards shortest path vertex nil procedure printpathg print shortest path execution shortestpaths algorithm values shortest paths breadthfirst search interested predecessor subgraph induced values define vertex set set vertices nonnil predecessors source nil directed edge set set edges induced values vertices prove values produced algorithms chapter property termination shortestpaths treeinformally rooted tree shortest path source vertex reachable shortestpaths tree breadthfirst tree shortest paths source defined terms edge weights num bers edges precise weighted directed graph weight function assume negativeweight cycles reachab source vertex shortest paths defined shortestpaths tree rooted directed subgraph set vertices reachable forms rooted tree root unique simple path shortest path shortest paths unique shortestpaths trees figure weighted directed graph shortestpaths trees root figure weighted directed graph shortestpath weights source shaded edges form shortestpat tree rooted source shortestpaths tree root relaxation algorithms chapter technique relaxation vertex maintain attribute dv upper bound weight shortest path source dv shortestpath estimate initialize shortestpath estimates predecessors vtime procedure initializesinglesourceg vertex vg dv nil initialization nil dv process relaxing1 edge consists testing improve shortest path updating dv relaxation step decrease shortestpath estimate dv update predecessor field code performs relaxation step edge relaxu dv wu dv wu figure examples relaxing edge shortestpath estimate decreases estimate figure relaxation edge weight wu shortestpath estimate vertex vertex dv wu prior relaxation dv decreases dv wu relaxation step dv unchanged relaxation algorithm chap ter calls initializesingles ource repeatedly relaxes edges relaxation shortestpath estimates predecessors change algorithms chap ter differ times relax edge order relax edges dijkstras algorithm shortestpaths algorithm directed acyclic graphs edge relaxed bellmanford algorithm edge relaxed times strange term relaxation operation tightens upper bound term historical outco relaxation step viewed relaxation constraint dv wu tria ngle inequality lemma satisfied dv dv wu pressure satisfy cons traint constraint relaxed properties shortest paths relaxation prove algorithms chapter correct appeal properties shortest paths relaxation state properties proves formally reference property stated includes lemma corollary number properties refer shortestpath estimates predecessor ubgraph implicitly assume graph initialized initializesinglesource shortestpath estimates predecessor subgraph change sequence relaxation steps triangle inequality lemma edge wu upperbound property lemma dv vertices dv achieves nopath property corollary path dv convergence property lemma shortest path time prior relaxing edge dv times afterward pathrelaxation property lemma v0 v1 vk shortest path v0 vk edges relaxed order v0 v1 v1 v2 vk1 vk dvk vk property holds relaxation steps occur intermixed relaxations edges predecessorsubgraph property lemma dv predecessor subgraph shortestpaths tree rooted chapter outline presents bellmanford algorithm wh ich solves singlesource shortestpaths problem general case edges negative weight bellman ford algorithm remarkable simplicit benefit detecting negativeweight cycle reachable source lineartime algorithm computing shortest paths single source directed acyclic graph covers dijkstras algorithm ha lower running time bellman ford algorithm requires edge weights nonnegative bellmanford algorithm solve special case linear programming finally proves properties shortest paths relaxation stated require conventions arithmetic infinities assume real number proofs hold presence negativeweight cycles assume real number algorithms chapter assume directed graph stored adjacencylist representation additionally stored edge weight traverse adjacency list determine edge weights o1 time edge bellmanford algorithm bellmanford algorithm solves singles ource shortestpaths problem general case edge weights nega tive weighted directed graph source weight function bellmanford algor ithm returns boolean indicating negativeweight cycle reachable source cycle algorithm ndicates solution exists cycle algorithm produces shortest paths weights algorithm relaxation progressively decreasing estimate dv weight shortest path source vertex achieves actual shortestpath weight algorithm returns true graph negativeweight cycles achable source bellmanfordg initializesinglesourceg vg edge relaxu edge dv wu return false return true figure execution bellmanford algorithm graph vertices initializing values vertices algorithm passes edges graph pass iteration loop lines consists relaxing edge graph figures state algorithm passes edges making passes lines check negativeweight cycle return boolean check works figure execution bellmanf algorithm source vertex values vertices shad edges predecessor values edge shaded pass relaxes edges order situation pass edges situation successive pass edges values final values bellmanford algorithm returns true bellmanford algorithm runs time ov initiali zation takes time passes edges lines takes time loop lines takes oe time prove correctness bellmanford algorithm start showing negativeweight cycles algorithm computes correct sh ortestpath weights vertices reachable source lemma weighted directed graph source weight function assume negativeweight cles reachable iterations loop lines bellmanford dv vertices reachable proof prove lemma appealing pa threlaxation property vertex reachable v0 v1 vk v0 vk acyclic shortest path path edges iterations loop lines relaxes edges edges relaxed ith iteration vi1 vi pathrelaxa tion property dv dvk vk corollary weighted directed graph source vertex weight function vertex path bellmanford terminates dv proof proof left exercise theorem correctness bellmanford algorithm bellmanford weighted directed graph source weight function negativeweight cycles reachable algorithm returns true dv vertices predecessor subgraph shortestpaths tree rooted negativeweight cycle reachable algorithm returns false proof suppose graph negativeweight cycles reachable source prove claim termination dv vertices vertex reachable lemma proves claim reachable claim nopath propert claim proven predecessor subgraph property claim implies shortestpaths tree claim bellmanford return true termination edges tests bellmanford return false returns true dv wu triangle inequality wu conversely suppose graph negativeweight cle reachable source cycle v0 v1 vk v0 vk assume purpose contradiction bellmanford algorithm returns true dvi dvi1 wvi1 vi summing inequalities cycle v0 vk vertex appears summations corollary dvi finite contradicts inequality conclude bellmanford algorithm returns true graph negativeweight cycles reachable source false exercises bellmanford algorithm directed graph figure vertex source pass relax edges order figure values pass change weight edge algorithm source exercise prove corollary exercise weighted directed graph negativeweight cycles maximum pairs vertices minimum number edges shortest path shortest path weight number edges simple change bellmanford algorithm terminate passes exercise modify bellmanford algorithm sets dv vertices negativeweight cycle path source exercise weighted directed graph weight function ov etime algorithm vertex min exercise suppose weighted directed graph negativeweight cycle efficient algorithm list vertices cycle prove algorithm correct singlesource shortest paths directed acyclic graphs relaxing edges weighted dag directed acyclic graph topological sort vertices compute shortest paths single source time shortest paths define dag negative weight edges negativeweight cycles exist algorithm starts topologically sorting dag impose linear ordering vertices path vertex vertex precedes topological sort pass vertices topologically sorted order process vertex relax edge leaves vertex dagshortestpathsg topologically sort vertices initializesinglesourceg vertex topologically sorted order vertex adju relaxu figure execution algorithm figure execution algorithm shor test paths directed acyclic graph vertices topologically sorted left source vertex values vertices shaded edges values situation iteration loop lines situation iteration loop lines newly blackened rtex iteration iteration values final values running time algorithm easy analyze topological sort performed time initialize singlesource takes time iteration vertex loop lines vertex edges leave vertex examined total iterations loop lines aggregate analysis iteration loop takes time total running time linear size adjacencylist representation graph theorem dagshortestpaths procedure correctly computes shortest paths theorem weighted directed graph source vertex cycles termination dagshortestpaths procedure dv vertices predecessor subgraph shortestpaths tree proof dv vertices termination reachable dv nopath property suppose reachable shortest path v0 v1 vk v0 vk process vertices opologically sorted order edges relaxed order v0 v1 v1 v2 vk1 vk pathrelaxation property implies dvi vi termination finally predecessorsubgraph property shortestpaths tree interesting application algorithm arises determining critical paths pert chart2 analysis edges represent jobs performed edge weights represent times required perform jobs edge enters vertex edge leaves job performed prior job path dag represents sequence jobs performed order critical path longest path dag longest time perf orm ordered sequence jobs weight critical path lowe bound total time perfor jobs critical path negating edge weights running dagshortestpaths running dagshortestpaths modification replace initializesingles ource relax procedure exercises dagshortestpaths directed graph figure vertex source exercise suppose change dagshortestpaths read vertices topologically sorted order procedure remain correct exercise pert chart formulation unnatural natural vertices represent jobs edges represent sequencing constraints edge job performed job weights assigned vertices edges modify dagshortestpaths procedure finds longest path directed acyclic graph weighted vertices linear time exercise efficient algorithm count total number paths directed acyclic graph analyze algorithm pert acronym program evaluation review technique dijkstras algorithm dijkstras algorithm solves singlesource hortestpaths problem weighted directed graph case edge weights nonnegative assume wu edge good implementation running time dijkstras algorithm lower bellman ford algorithm dijkstras algorithm maintains set vertices final shortestpath weights source determined gorithm repeatedly selects vertex minimum shortestpath estimate adds relaxes edges leaving implementation minpriority queue vertices keyed values dijkstrag initializesinglesourceg ø vg ø extractminq vertex adju relaxu dijkstras algorithm relaxes edges figure performs usual initialization values initializes set set algorithm maintains invariant start iteration loop lines initializes minpriority queue vertices ø time invariant true time loop lines vertex extracted set maintaining invariant time loop vertex smallest shortestpath estimate vertex lines relax edge leaving updating estimate dv predecessor shortest path improved observe vertices inserted vertex extracted loop lines iterates times figure execution dijkstras algorithm source leftmost vertex shortestpath estimates rtices shaded edges predecessor values black vertices set white vertices minpriority queue situation itera tion loop lines shaded vertex minimum chosen vertex bf situation successive iteration loop shaded vertex chosen vertex iteration values final values dijkstras algorithm chooses lightest closest vertex add set greedy strategy greedy strategies presented chapter read chapter understand dijkstras algorithm greedy strategies yield optimal general theorem corollary dijkstras algorithm ndeed compute shortest paths key time vertex set theorem correctness dijkstras algorithm dijkstras algorithm weighted directed graph nonnegative weight function source terminates vertices proof loop invariant start iteration loop lines dv vertex suffices vertex time set rely upperbound property equality holds times initialization initially ø invariant trivially true maintenance iteration vertex set purpose contradiction vertex set focus attent ion situation iteration loop derive contradiction time examining shortest path vertex set time ø path nopath property violate assumption path shortest path prior adding path connects vertex vertex vertex predecessor figure path decomposed paths edges figure proof theorem set nonempty vertex shortest path source vertex decomposed vertex path precedes vertices distinct path reenter set claim prove claim observe chosen vertex edge relaxed time claim convergence property contradiction prove occurs shortest path edge weights nonnegative notably path vertices chosen inequalities fact equalities contradicts choice conclude equality maintained times termination termination ø earlier invariant implies vertices corollary dijkstras algorithm weighted directed graph nonnegative weight function source termination predecessor subgraph shortestpaths tree rooted proof theorem predecessorsubgraph property analysis fast dijkstras algorithm maintains minpriority queue calling priorityqueue operations insert implicit extractmin decreasekey implicit relax called insert invoked vertex extractmin vertex set edge adjacency list adjv examined loop lines algorithm total number edges adjacency lists total iterations loop total decreasekey operations observe aggregate analysis running time dijkstras algorithm depends minpriority queue implemented case maintain minpriority queue advantage vertices numbered simply store dv vth entry array insert decreasekey operation takes o1 time extract min operation takes ov time search rough entire array total time ov2e ov2 graph sparsein ov2 lg vit practical implement minpriority queue bina minheap discussed implementation rtices heap elements maintain handles extractmin operation takes time olg operations time ild binary minheap ov decreasekey operation takes time olg operations total running time ov lg oe lg vertices reachable source running time improvement straightforward ov2time implementation ov2 lg fact achieve running time ov lg implementing minpriority queue fibonacci heap chapter amortized cost extractmin operations olg decreasekey takes o1 amortized time historically development fibonacci heaps motivated observation dijk stras algorithm typically decreasekey calls extractmin calls method reducing amortized time decreasekey operation olg increasing amortized time extractmin yield asym ptotically faster implementati binary heaps dijkstras algorithm bears similarity breadthfirst search prims algorithm computi minimum spanning trees breadthfirst search set corresponds set black vertices breadthfirst search vertices final shortestpath weights black vertices breadthfirst search correct breadthfirst distances dijkstras algorithm prims algorithm algorithms minpriority queue lightest vertex set set dijkstras algorithm tree grown prims algorithm add vertex set adjust weight remaining vertices set exercises dijkstras algorithm directed graph figure vertex source vertex source style figure values vertices set iteration loop exercises simple directed graph ith negativeweight edges dijkstras algorithm produces incorrect answer doesnt proof theorem negativeweight edges allowed exercises suppose change dijkstras algorithm change loop execute times times proposed algorithm correct exercises directed graph edge real number range represents reliability communication channel vertex vertex interpret probability channel fail assume probabilities independent efficient algorithm reliable path vertices exercises weighted directed graph weight function positive integer assume verti ces shortestpath weights source vertex suppose define unweighted directed graph replacing edge wu unitweight edges series vertices suppose breadthfirst search order vertices colored black breadthfirst search order vertices extracted prio rity queue dijkstra exercises weighted directed graph weight function nonnegative integer modify dijkstras algorithm compute shortest paths source vertex time exercises modify algorithm exercise ov lg time hint distinct shortestpath estimates point time exercises suppose weighted directed graph edges leave source vertex negative weights edge weights nonnegative negativeweight cycles argue dijkstras algorithm correctly finds shortest paths graph difference constraints shortest paths chapter studies general linearprogramming oblem optimize linear function subject set linear inequalities investigate special case linear programming reduced finding shortest paths single source singlesource shortestpaths problem sults solved bellman ford algorithm solv ing linearprogramming problem linear programming general linearprogramming problem matrix mvector nvector vector elements maximizes objective function subject constraints simplex algorithm focus chapter time polynomial size input linearprogrammi algorithms polynomial time reasons understand setup linearprogramming problems knowi problem cast polynomialsized linearprogramming problem imme diately polynomial time algorithm problem special cases linear programming faster algorithms exist singlesource shortestpaths problem special case linear programming problems cast linear programming include singlepair shortestpath problem exercise maximumflow problem exercise dont care obj ective function feasible solution vector satisfies determine feasible solution exists focus feasibility problem systems difference constraints difference constraints row linearprogramming matrix entries constraints set difference constraints involving unknowns constraint simple linear inequality form oblem finding vector satisfies problem equivalent finding unknowns difference constraints satisfied solution problem verified directly checking inequality fact solution problem solutions component larger component fact mere coincidence lemma solution difference constraints constant solution proof satisfies systems difference constraints occur applications unknowns times events ccur constraint viewed stating time time events events jobs performed assembly product apply adhesive takes hours set time wait sets install time constraint equivalently alternatively require stalled adhesive applied time adhesive set halfway case pair constraints equivalently constraint graphs beneficial interpret systems diffe rence constraints graphtheoretic point view idea difference constraints linear programming matrix viewed transpose incidence matrix exercise graph vertices edges vertex vi graph corresponds unknown variables directed edge graph corresponds inequalities involving unknowns formally difference constraints constraint graph weighted directed graph v0 v1 vn vi constraint v0 v1 v0 v2 v0 v3 v0 vn additional vertex v0 incorporated shortly guarantee vertex reachable vertex set consists vertex vi unknown additional vertex v0 edge set edge difference constraint edge v0 vi unknown difference constraint weight edge vi wvi weight edge leaving v0 figure constraint graph difference constraints figure constraint graph difference constraints v0 vi vertex vi feasible solution theorem lution difference constraints finding shortestpath weights constraint graph theorem difference constraints constraint graph negativeweight cycles feasible solution negativeweight cycle feasible solution proof constraint aph negativeweight cycles equation feasible solution edge vi triangle inequality v0 v0 vi wvi equivalently v0 v0 vi wvi letting v0 vi v0 satisfies difference constraint wvi corresponds edge vi constrai graph negativeweight cycle difference constraints feasible solution loss generality negative weight cycle v1 v2 vk v1 vk vertex v0 cycle entering edges cycle corresponds followi difference constraints wv1 v2 wv2 v3 xk1 wvk1 vk wvk v1 suppose solution satisfying inequalities solution satisfy inequality sum inequalities sum lefthand sides unknown subtracted lefthand sum righthand sums wc wc negativeweight cycle wc contradiction wc solving systems difference constraints theorem tells bellman ford algorithm solve difference constraints ther edges source vertex v0 vertices constraint graph negativeweight cycl constraint graph reachable v0 bellmanford algorithm returns true shortestpath weights feasible solution figure shortestpath weights provide feasible solution lemma feasible solution constant bellmanford gorithm returns false feasible solution difference constraints difference constraints constraints unknowns produces graph n1 vertices nm edges bellman ford algorithm solve on2 nm time exercise asks modify algorithm onm time exercises feasible solution determine feasible solution exists difference constraints x4 x5 x6 x6 x4 x5 x5 x4 x6 exercises feasible solution determine feasible solution exists difference constraints x5 x4 x4 x4 x4 x5 x5 x5 x4 exercises shortestpath weight vertex v0 constraint graph positive explain exercises express singlepair shortestpath problem linear program exercises modify bellmanford algorithm lightly solve difference constraints inequalities unknowns running time onm exercises suppose addition fference constraints handle equality constraints form bellmanford gorithm adapted solve variety constraint exercises difference constraints solved bellmanfordlike algorithm runs constraint graph extra vertex v0 exercises difference constraints unknowns bellman ford algorithm corre sponding constraint graph maximizes subject exercises bellmanford algorithm constraint graph difference constraints minimizes quantity max min subject explain fact handy algorithm schedule construction jobs exercises suppose row matrix linear program corresponds difference constraint singlevariable constraint form singlevariable constraint form adapt bellmanford algorithm solve variety constraint exercises efficient algorithm solve difference constraints elements realvalued unknowns integers exercises efficient algorithm solve difference constraints elements realvalued subset unknowns integers proofs shortestpaths properties chapter correctness arguments relied triangle inequality upperbound property nopath property convergence property pathrelaxation property predecessorsubgraph property stated properties proof chapter prove triangle inequality studying breadthfirst search proved lemma simple property shortest distances unweighted graphs triangle inequality generalizes property weighted graphs lemma triangle inequality weighted directed graph weight function source vertex edges wu proof suppose shortest path source vertex weight path path weight path takes shortest path source vertex takes edge exercise asks handle case shortest path effects relaxation shortestpath estimates group lemmas describes shor testpath estimates execute sequence relaxation steps edges weighted directed graph initialized itializesinglesource lemma upperbound property weighted directed graph weight function source vertex graph initialized initializesinglesource dv invariant maintained sequence relaxation steps edges dv achieves lower bound proof prove invariant dv vertices induction number relaxation steps basis dv true initialization note negativeweight cycle dv implies dv inductive step relaxation edge inductive hypothesis prior relaxation change dv invariant maintained dv wu wu vby inductive hypothesis triangle inequality dv dv note achieved lower bound dv decrease dv increase relaxation steps increase values corollary nopath property suppose weighted directed graph weight function path connects source vertex vertex graph initialized initializesinglesource dv equality maintained invariant sequence relaxation steps edges proof upperbound property dv dv lemma weighted directed graph weight function relaxing edge executing relax dv wu proof prior relaxing edge dv wu dv wu afterward dv wu relaxation dv dv wu afterward lemma convergence property weighted directed graph weight function source vertex shortest path vertices suppose initialized itializesinglesourceg sequence relaxation steps includes relax executed edges time prior dv times proof upperbound property point prior relaxing edge equality holds relaxing edge dv wu lemma wu lemma upperbound property dv conclude dv equality maintained lemma pathrelaxation property weighted directed graph weight function source vertex shortest path v0 v1 vk v0 vk initialized initializesinglesource sequence relaxation steps occurs includes der relaxations edges v0 v1 v1 v2 vk1 vk dvk vk relaxations times afterward property holds matter edge relaxations occur including relaxations intermixed relaxations edges proof induction ith edge path relaxed dvi vi basis edges relaxed initialization dv0 upperbound property initialization inductive step assume dvi1 vi1 examine relaxation edge vi1 vi convergence property relaxation dvi vi equality maintained times relaxation shortestpaths trees sequence relaxations caused shortestpath estimates converge shortestpath weights predecessor subgraph induced values shortestpaths tree start lemma predecessor subgraph forms root tree root source lemma weighted directed graph weight function source vertex assume negativeweight cycles reachable graph initialized initializesinglesourceg predecessor subgraph forms rooted tree root sequence relaxation steps edges maintains property invariant proof initially vertex source vertex lemma trivially true predecessor subgraph arises sequence relaxation steps prove acyclic suppose sake contradiction relaxation step creates cycle graph cycle v0 v1 vk vk v0 vi vi1 loss generality assume relaxation edge vk1 vk created cycle claim vertices cycle reachable source vertex nonnil predecessor vertex assigned finite shortestpath estimate assigned nonnil upperbound property vertex cycle finite shortestpath weight implies reachable examine shortestpath estimates prior relax vk1 vk negativeweight cycle contradicting assumption negativeweight cycles reachable source vi vi1 update dvi assignment dvi dvi1 wvi1 vi dvi1 changed decreased relax vk1 vk vk changed forehand strict inequality dvk dvk1 wvk1 vk summing strict inequality inequalities sum shortestpath estimates cycle vertex cycle appears summation equality implies sum weights cycle negative desired contradiction proven directed acyclic graph forms rooted tree root suffices exercise b52 prove vertex unique path path exists vertex vertices nonnil values idea prove induction path exists vertices details left exercise complete proof lemma vertex path graph suppose suppose simple paths vertex decomposed decomposed figure implies contradiction conclude exists unique simple path forms rooted tree root figure showing path source vertex unique paths contradiction performe sequence relaxation steps vertices assigned true shortestpath weights predecessor subgraph shortestpaths tree lemma predecessorsubgraph property weighted directed graph weight function source vertex assume negativeweight cycles reachable initializesinglesourceg execute sequence relaxation steps edges produces dv predecessor subgraph shortestpaths tree rooted proof prove ree properties shortestpat trees hold property set vertices reachable definition shortestpath weight finite reachable vertices reachable finite values vertex assigned finite dv nil vertices reachable property directly lemma remains prove prope rty shortestpaths trees vertex unique simple path shortest path v0 v1 vk v0 vk dvi vi dvi dvi1 wvi1 vi conclude wvi1 vi vi vi1 summing weights path yields wp vk vk lower bound weight path vk conclude wp vk shortest path vk exercises shortestpaths trees directed graph figure exercises weighted directed graph weight function source satisfies operty edge shortestpaths tree rooted shortestpaths tree rooted exercises embellish proof lemma handle cases shortestpath weights exercises weighted directed graph source vertex initialized initializesinglesourceg prove sequence relaxation steps sets nonnil negativeweight cycle exercises weighted directed graph negativeweight edges source vertex suppose predecessor shortest path source reachable nil graph assignment values produces cycle lemma assignment produced sequence relaxation steps exercises weighted directed graph weight function negativeweight cycles source vertex initialized initializesinglesourceg prove vertex exists path property maintained invariant sequence relaxations exercises weighted directed graph negativeweight cycles source vertex initialized initializesinglesourceg prove exists sequence relaxation steps produces dv exercises arbitrary weighted directed graph negativeweight cycle reachable source vertex infinite sequence relaxations edges constructed relaxation shortestpath estimate change problems yens improvement bellmanford suppose order edge relaxations pass bellmanford algorithm pass assign arbitrary linear order v1 v2 vv vertices input graph partition edge set eb vi eb vi assume selfloops edge eb define gf gb eb prove gf acyclic topological sort v1 v2 vv gb acyclic topological sort vv vv1v1 suppose implement pass bellmanford algorithm visit vertex order v1 v2 vv relaxing edges leave vertex visit vertex order vv vv1 v1 relaxing edges eb leave vertex prove scheme negativeweight cycles reachable source vertex passes edges dv vertices scheme improve asymptotic running time bellmanford algorithm problems nesting boxes ddimensional box dimensions xd nests box dimensions y1 yd exists permutation y1 xd yd argue nesting relation transitive efficient method determine ddimensional box nests inside suppose set ddimensional boxes efficient algorithm determine longest sequence boxes nestsexpress running time algorithm terms problems arbitrage arbitrage discrepancies currency exchange rates transform unit currency unit currency suppose dollar buys indian rupees indian rupee buys japanese yen japanese yen buys dollars converting currencies trader start dollar buy dollars turning profit percent suppose currencies table exchange rates unit currency buys units currency efficient algorithm determine exists sequence currencies ri1 ri2 rik1 ik rik i1 analyze running time algorithm efficient algorithm print sequence exists analyze running time algorithm problems gabows scaling algorith singlesource shortest paths scaling algorithm solves problem initially onsidering highestorder bit relevant input edge wei ght refines initial solution highestorder bits progressively highorder bits refining solution time bits considered correct solution computed problem examine algorithm computing shortest paths single source scaling edge weights directed graph nonnegative integer edge weights max wu goal develop algorithm runs oe lg time assume vertic reachable source algorithm uncovers bits binary representation edge weights time bit ast bit lgw number bits binary representation wu v2ki wiu scaled version wu bits wu wku wu wu binary representation w3uwu w3u define shortestpath weight vertex vertex weight function ku source vertex scaling algorithm computes shortestpath weights computes computes ks assume computing i1 takes oe time entire algorithm takes oe lg time suppose vertices compute oe time compute oe time focus computing i1 prove wiu wi1u wiu wi1u prove i1s i1s define prove reweighted edge nonnegative integer define shortestpath weight weight function prove compute i1s oe time conclude computed oe lg time problems karps minimum meanweight cycle algorithm directed graph weight function define weight cycle e1 ek edges µ min µc ranges directed cycles cycle µc µ called minimum meanweight cycle problem investigates efficient algorithm computing µ assume loss gene rality vertex reachable source vertex weight shortest path ks weight shortest path consisting edges path edges ks µ negativeweight cycles min kn1 ks vertices µ vertices hint properties weight cycle vertices suppose µ weight path cycle prove hint weight path cycle µ minimum meanweight cycle exists vertex hint shortest path rtex minimum meanweight cycle extended cycle shortest path vertex cycle µ add constant weight edge µ increased fact ov etime algorithm compute µ problems bitonic shortest paths sequence bitonic monotonically increases monotonically decreases circularly shifted monotonically increase monotonically decrease sequencesbitonic bitonic chapter discussion bitonic sorters problem bitonic euclidean travelingsalesman problem suppose directed graph weight function singlesource shortest paths source vertex additional piece vertex weights edges shortest path form bitonic sequence efficient algorit hm solve probl analyze running time chapter notes dijkstras algorithm appeared contained mention priority queue bellmanford algorithm based separate algorithms bellman ford bellman describes relation shorte paths difference constraints lawler describes lineartime algorithm shortest path dag considers folklore edge weights small nonnega tive integers efficient algorithms solve singlesource shortestpaths problem sequence values returned extractmin calls dijkstras algorithm monotonical ly increasing time discussed chapter notes chapter case data structures implement priority queue operations efficien tly binary heap fibonacci heap ahuja mehlhorn orlin tarjan algorithm runs time graphs nonnegative edge weights largest weight edge graph bounds thorup algorithm runs oe lg lg time raman algorithm runs min lg lg w14 time algorithms space depends word size underlying machine alt hough space unbounded size input reduced linear size input randomized hashing undirected graphs integer weights thorup ov etime algorithm singlesource shortest paths contrast algorithms menti oned previous paragraph algorithm implementa tion dijkstras algorithm sequence values returned extractmin calls monotonically increasing time graphs negative edge weights algorithm gabow tarjan runs time goldberg runs time max wu cherkassky goldberg radzik conducted extensive experiments comparing shortestpath algorithms chapter allpairs shortest paths overview chapter problem nding shortest paths pairs vertices graph problem making table distances pairs cities road atlas chapter weighted directed graph weight function maps edges realvalued weights pair vertices shortest leastweight path weight path sum weights constituent dges typically output tabular form entry row column weight shortest path solve allpairs shortestpaths problem running singlesource shortestpaths algorithm times vertex sour edge weights nonnegative dijkstras algorithm lineararray implementation minpriority queue running time ov3 ov3 binary minheap implementation minpriority queue yiel running time ov lg improvement graph sparse alternatively implement minpriority queue fibonacci heap yielding running time ov2 lg negativeweight edges allowed dijkstras algorithm longer slower bellmanford algorithm vertex running time ov2e dense graph ov4 chapter investigate relation allpairs shortestpaths problem matrix multiplication study algebraic structure singlesource algorithms assume adjacencylist representation graph algorithms chap ter adjacencymatrix representation johnsons algorithm sparse graphs adja cency lists convenience assume vertices numbered input matrix representing edge weights nvertex directed graph wij negativeweight edges allowed assume time input graph negativeweight cycles tabular output allpairs shortestpaths algorithms presented chapter matrix dij entry dij weight shortest path vertex vertex jdenote shortestpath weight vertex vertex chapter dij termination solve allpairs shortestpaths problem input adjacency matrix compute shortest path weights predecessor matrix nil path predecessor shortest path predecessor subgraph chapter shortest paths tree source vertex subgraph induced ith row matrix shortestpaths tree root vertex define predecessor subgraph vi vi nil vi shortestpaths tree ocedure modified version printpath procedure chapter prints shortest path vertex vertex printallpairsshortestpath print nil print path exists printallpairsshortestpath print order highlight essential features allpairs algorithms chapter cover creation properties predecessor matrices tensively dealt predecessor subgraphs chapter basics covered exercises chapter outline presents dynamicprogramming algorithm based matrix multiplication solve allpairs shortestpaths problem usin technique repeated squaring algorithm v3 lg time dynamicprogramming algorithm floydwarshall algorithm floydwarshall algorithm runs time v3 covers problem finding transitive closure directed graph allpairs shortestpaths problem finally presents johnsons algorithm algorithms chapter johnsons algorithm adjacencylist representation graph lves allpairs shortestpaths problem ov2 lg time good algorithm large sparse graphs proceeding establish conventions adjacencymatrix representations gene rally assume input graph vertices convention denoting matrices uppercase letters individual elements subs cripted lowercase letters wij lij dij matrices pare nthesized superscripts iterates finally matrix assume stored attribute rows shortest paths matrix multiplication presents dynamicprogrammi algorithm allpairs shortestpaths problem directed graph major loop dynamic program invoke operation sim ilar matrix multiplication algorithm repeated matrix multiplication start developing v4time algorithm allpairs shortestpaths problem improve running time v3 lg proceeding recap steps chapter developing dynamicprogramming algorithm characterize structure optimal solution recursively define optimal solution compute optimal solution bottomup fashion fourth step constructing optimal solution computed dealt exercises structure shortest path start characterizing structure optimal solution allpairs shortestpaths problem graph proven lemma subpaths shortest path shortest paths suppose graph represented adjacency matrix wij shortest path vertex vertex suppose edges assuming negativeweight cycles finite weight edges vertices distinct decompose path path edges lemma shortest path wkj recursive solution pairs shortestpaths problem minimum weight path vertex vertex edges shortest path edges compute minimum weight shortest path consisting edges minimum weight path consisting edges predecessors recursively define equality wjj actual shortestpath weights graph contai negativeweight cycles pair vertices shortest path simple hus edges path vertex vertex edges lower weight shortest path actual shortestpath weights computing shortestpath weights input matrix wij compute series matrices l1 ln1final matrix ln1 actual shortestpath weights observe vertices l1 heart algorithm follow ing procedure matrices lm1 returns matrix lm extends shortest paths computed edge extendshortestpathsl rowsl matrix return procedure computes matrix returns computing equation lm1 lm written superscripts input output matrices independent running time n3 nested loops relation matrix multipli cation suppose compute matrix product matrices compute observe substitutions lm1 lm min equation equation extend shortestpaths replace identity min identity straightforward n3time procedure matrix multiplication matrixmultiplya rowsa matrix cij cij cij aik bkj return returning allpairs shortestpaths problem compute shortestpath weights extending shortest paths edge edge letting denote matrix product returned extendshortestpaths compute sequence matrices l1 l0 l1 w2 l3 w3 ln1 ln2 wn1 argued matrix ln1 wn1 shortestpath weights procedure computes sequence n4 time slowallpairsshortestpathsw rowsw l1 lm extendshortestpathslm1 return ln1 figure graph matrices lm computed procedure slowall pairsshortestpaths figure directed graph sequence matrices lm computed slowall pairsshortestpaths reader verify l5 l4 equal l4 lm l4 improving running time goal compute lm matrices interested matrix ln1 recall absence negativeweight cycles equation implies lm ln1 integers traditional matrix multipli cation associative matrix multiplication defined extendshortestpaths procedure exercise compute ln1 lgn matrix products computing sequence l1 w2 l4 w4 w2 w2 l8 w8 w4 w4 lgn1 final product equal ln1 procedure computes seque nce matrices technique repeated squaring fasterallpairsshortestpathsw rowsw l1 l2m extendshortestpathslm lm return lm iteration loop lines compute l2m lm2 starting iteration double final iteration computes ln1 computing l2m equation l2m ln1 time test performed doubled test fails procedure returns matrix computed running time fastera llpairsshortestpaths n3 lg lgn matrix products takes n3 time observe ode tight elaborate data structures constant hidden notation small exercises slowallpairsshortestpaths weighted directed graph figure showing matrices result iteration loop fasterallpairsshortestpaths figure weighted directed graph exercisesexercises require wii exercises matrix shortestpaths algorithms corre spond regular matrix multiplication exercises matrix multiplication defined extendshortestpaths associative exercises express single source shortestpaths problem product matrices vector evaluating product corresponds bellmanfordlike algorithm exercises suppose compute vertices shortest paths algorithms compute predecessor matrix completed matrix shortestpath weights on3 time exercises vertices shortest paths computed time shortestpath weights define predecessor vertex minimumweight path edges modify extendshortestpaths slow allpairsshortestpaths compute matrices n1 matrices l1 ln1 computed exercises fasterallpairsshortestpaths proce dure written requires store lgn matrices elements total space requirement lg modify procedure require space matrices exercises modify fasterallpairsshortestpaths detect presence negativeweight cycle exercises efficient algorithm lengt number edges minimumlength negativeweight cycle graph floydwarshall algorithm dynamicprogramming formulation solve pairs shortestpaths problem directed graph algorithm floydwarshall algorithm runs v3 time nega tiveweight edges assume ther negativeweight cycles follow dynamicprogramming process develop algorithm studying algorithm simila method finding transitive closure directed graph structure shortest path floydwarshall algorithm diffe rent characterization structure shortest path matrixmultiplicationbased allpairs algorithms algorithm considers intermediate rtices shortest path intermediate vertex simple path v1 v2 vl vertex v1 vl vertex set v2 v3 vl1 floydwarshall algorithm based observation assumption vertices subset vertices pair vertices paths intermediate vertices drawn minimumweight path path simple floydwarshall algorith exploits relationship path shortest paths intermediate rtices setrelationship depends intermediate vertex path intermediate vertex path intermediate vertices path setshortest path vertex vertex intermediate vertices setshortest path intermediate vertices set intermediate vertex path break figure lemma shortest path intermediate vertices set vertex intermediate vertex path shortest path intermediate vertices setshortest path vertex vertex intermediate vertices setfigure path shortest path vertex vertex highestnumbered intermediate vertex path portion path vertex vertex intermediate rtices setholds path vertex vertex recursive solution pairs shortestpaths problem based observations define recursive formulation shortestpath estimates weight shortest path vertex vertex intermediate rtices setpath vertex vertex intermediate vertex numbered higher intermediate vertices path edge recursive definition discussion path intermedia vertices set matrix final answer computing shortestpath weights based recurrence bottomup procedure compute values order increasing values input matrix defined equation procedure returns matrix dn shortestpath weights floydwarshallw rowsw d0 return dn figure matrices computed floydwarshall algorithm graph figure figure sequence matrices computed floydwarshall algorithm graph figure running time floydwarshall algorith determined triply nested loops lines execution takes o1 time algorithm runs time n3 final algorithm code tight elaborate data structures constant hidden notation small floydwarshall algorithm practical moderatesized input graphs constructing shortest path variety methods onstructing shortest paths floydwarshall algorithm compute matrix shortestpath weights construct predecessor matrix matrix method implemented on3 time exercise predecessor matrix printallpairsshortestpath procedure print vertices shortest path compute predecessor matrix online floydwarshall algorithm computes matrices compute sequence matrices defined predecessor vertex shortest path vertex intermediate rtices set recurs ive formulation shortest path intermediate vertices path predecessor choose predecessor chose shortest path intermediate vertices set choose predecessor chose shortest path intermediate vertices setformally leave incorporation matrix computations floydwarshall procedure exercise figure sequence matrices algorithm computes graph figure exercise asks difficult task proving predecessor subgraph shortestpaths tree root reconstruct shortest paths exercise transitive closure directed graph directed graph vertex set path vertex pairs transitive closure defined graph path vertex vertex compute transitive closure graph n3 time assign weight edge floydwarshall algorithm path vertex vertex dij dij compute transitive closure n3 time save time space practice method nvolves substitution logical operations logical logical arit hmetic operations min floyd warshall algorithm define exists path graph vertex vertex intermediate vertices setconstruct transitive closure putting edge recursive definition analogous recurrencefloydwarshall algorithm compute matrices order increasing transitiveclosureg vgreturn figure matrices tk computed transitiveclosure procedure sample graph transitiveclosure pro cedure floydwarshall algorithm runs n3 time computers ogical operations singlebit values execute faster arithmetic operations integer data direct transitiveclosure algorithm boolean values integer values space requirement floydwarshall algorithms factor size word computer storage figure directed graph matrices tk computed transitiveclosure algorithm exercises floydwarshall algorithm weighted directed graph figure matrix ite ration outer loop exercises compute transitive closure technique exercises modify floydwarshall procedur include computation matrices equations prove rigorously predecessor subgraph shortestpaths tree root hint acyclic implies definition adapt proof lemma exercises appears floydwarshall algorithm requires n3 space compute procedure simply drops superscripts correct space required floydwarshall rowsw dij min dij dik dkj return exercises suppose modify whic equality handled equation alternative definition predecessor matrix correct exercises output floydwarshall algorithm detect presence negativeweight cycle exercises reconstruct shortest paths floydwarshall algorithm values highestnumbered intermediate vertex shortest path intermediate vertices set recursive formulation modify floydwarshall procedure compute values rewrite printallpairsshortestpath ocedure matrix input matrix table matrixchain multiplication problem exercises ov etime algorithm computing transi tive closure directed graph exercises suppose transitive closure directed acyclic graph computed fv time monotonically increasing function time compute transitive closure general directed graph fv ov johnsons algorithm sparse graphs johnsons algorithm finds shortest paths pairs ov2 lg time sparse graphs asymptotically tter repeated squa ring matrices floyd warshall algorithm algorithm returns matrix shortestpath weights pairs vertices reports input graph negativeweight cycle johnsons algorithm subroutines dijkstras algorithm bellmanford algorithm chapter johnsons algorithm technique reweighting works edge weights graph nonnegative shortest paths pairs vertices running dijkstras algorithm vertex fibonacciheap minpriority queue running time allpairs algorithm ov2 lg negativeweight edges negativeweight cycles simply compute set nonnegative edge weights method set edge weights satisfy properties pairs vertices path shortest path weight function shortest path weight function edges weight nonnegative moment preprocessing determine weight function performed ov time preserving shortest paths reweighting lemma easy reweighting edges satisfies property denote shortestpath weights derived weight function denote shortestpath weights derived weight function lemma reweighting change shortest paths weighted directed graph weight function function mapping vertices real numbers edge define v0 v1 vk path vertex v0 vertex vk shortest path v0 vk weight function shortest path weight function wp v0 vk negativeweight cycle weight function negativeweight cycle weight function proof start showing path v0 vk path v0 vk shorter weight function shorter wp v0 vk finally negativeweight cycle weight function negativeweight cycle weight function cycle v0 v1 vk v0 vk equation wc hv0 hvk wc negative weight negative weight producing nonnegative weights reweighting goal ensure property holds nonnegative edges weighted directed graph weight function graph vertex extend weight function ws note edges enter shortest paths source negativeweight cycles negativeweight cycles figure graph graph figure figure johnsons allpairs shortestpaths algorithm graph figure graph original weight function vertex black vertex hv edge reweighted weight function result running dijkstras algorithm vertex weight function source vertex black shaded edges shortestpaths tree computed algorithm vertex values separated slash duv equal suppose negativeweight cycles define hv triangle inequality lemma hv wu edges define weights equation property satisfied figure graph figure reweighted edges computing allpairs shortest paths johnsons algorithm compute allpairs shor test paths bellmanford algorithm dijkstras algorithm subroutines assumes edges stored adjacency list algorithm returns usual matrix dij dij reports input graph negativeweight cycle typical allpairs shortestpaths algorithm assume vertices numbered johnsong compute vg vg vg ws vg bellmanfordg false print input graph negativeweight cycle vertex vg set hv computed bellmanford algorithm edge vertex vg dijkstrag compute vg vertex vg return code simply performs actions earlier produces runs bellmanford algorithm weight function source vertex negativeweight cycle reports problem lines assume negativeweight cycles lines set hv shortestpath weight computed bellmanford algorithm lines compute weights pair vertices loop lines putes shortestpath weight calling dijkstras algorithm vertex stores matrix entry duv correct shortestpath weight calculated equation finally returns completed matrix figure execution johnsons algorithm minpriority queue dijkstras gorithm implemented fibonacci heap running time johnsons algorithm ov2 lg simpler binary minheap implementation yields running time ov lg asymptotically faster floydwarshall algorithm graph sparse exercises johnsons algorithm shortest paths tween pairs vertices graph figure values computed algorithm exercises purpose adding vertex yielding exercises suppose wu edges relationship weight functions exercises professor greenstreet claims simpler reweight edges method johnsons algorithm letting min wu define edges wrong professors method reweighting exercises suppose johnsons algorithm directed graph weight function weight cycle edge exercises professor michener claims create source vertex johnson claims vertex vg weighted directed graph incorporating professors idea johnson incorrect answers connected vertex reachable vertex returned johnson professors modification correct problems transitive closure dynamic graph suppose maintain ansitive closure directed graph insert edges edge inse rted update transitive closure edges inserted assume graph edges initially transitive closure represented boolean matrix transitive closure graph updated ov2 time edge graph edge v2 time required update transitive closure ter insertion efficient algorithm updating transitive osure edges inserted graph sequence insertions algorithm total time time update transitive closure ith edge inserted prove algorithm attains time bound problems shortest pa ths dense graphs graph dense v1 constant range dary minheaps problem shortestpaths algorithms dense graphs match running times fibonacciheapbased algorithms complicated data structure asymptotic running times insert extractmin decreasekey function number elements dary min heap running times choose constant compare running times ortized costs operations fibonacci heap compute shortest paths single source dense directed graph negativeweight edges oe time hint pick function solve allpair shortestpaths problem dense directed graph negativeweight edges ov time solve allpair shortestpaths problem ov time dense directed graph negativeweight edges negative weight cycles chapter notes lawler good discussion allpairs shortestpaths problem analyze solutions sparse graphs attributes matrixmultiplication algorithm folklore floydwarshall algorithm floyd based theorem warshall describes compute ansitive closure boolean matrices johnsons algorithm researchers improved algorith computing shortest paths matrix multiplication fredman allpairs shorte paths problem solved ov52 comparisons sums edge wei ghts obtains algorithm runs ov3lg lg lg v13 time running time floyd warshall algorithm monstrates algorithms fast matrix multiplication chapter notes chapter applied allpairs shortest paths problem onw running time fastest algorithm multiplying matrices galil margalit seidel designed algorithms solve allpairs shortest path problem undirected unweighted graphs vw pv time denotes function polylogarithmically bounded dense graphs algorithms faster ov time needed perform breadthfirst searches researchers extended algorithms solving allpairs shortest paths problem undirected graphs edge weights integers range asymptotically fastest algorithm shoshan zwick runs time vw pv karger koller phillips independently mcgeoch time bound depends set edges participate shortest path graph nonnegative edge weights algorithms ov ev2 lg time improvements running dijkstras algorithm times oe aho hopcroft ullman defined algebraic structure closed semiring serves general framework solving path problems directed graphs floydwarshall algorithm tran sitiveclosure algorithm instantiations allpairs gorithm based closed semirings maggs plotkin minimum spanning trees closed semiring chapter maximum flow overview model road map directed graph order shortest path point interpret directed graph flow network answer questions material flows imagine material oursing source material produced sink consumed source produces material steady rate sink consumes material rate flow material poi intuitively rate material moves flow networks mode liquids flowing pipes parts assembly lines current electrical networks communication networks directed edge flow network thought conduit material conduit stated capacity maximum rate material flow conduit gallons liquid hour pipe amperes electrical current wire vertices conduit junctions source sink material flows vertices coll ecting rate material enters vertex equal leaves vertex property flow conservation equivalent kirchhoffs current law material electrical current maximumflow problem comput greatest rate material shipped source sink violating capacity constraints simplest problems flow networks chapter problem solved efficient algorithms basic techniques maximumflow algorithms adapted solve networkflow problems chapter presents general methods solving maximumflow problem formalizes notions flow networks flows formally defining maximumflow problem describes classical method ford fulkerson finding maximum flows application method finding maximum matching undirected bipartite graph presents pushrelabel method underlies fastest algorithms networkflow problems covers relabeltofront algorithm implementation pushrelabel method runs time ov3 algorithm fastest algorithm illustrates techniques asymptotically fastest algorithms efficient practice flow networks graphtheoretic defin ition flow networks discuss properties define maximumflow problem precise ly introduce helpful notation flow networks flows flow network directed graph edge nonnegative capacity assume distinguish vertices flow network source sink convenience assume vertex lies path source sink vertex path graph connected figure flow network ready define flows formally flow network capacity function source network sink flow realvalued function satisfies properties figure flow network lucky puck companys trucking problem vancouver factory source winnipeg warehouse sink pucks shipped intermed iate cities crates day city city edge labeled capacity flow positive flows edge labeled vcu slash notation separate flow capacity indi cate division edge labeled capacity capacity constraint require skew symmetry require flow conservation require quantity positive negative called flow vertex vertex flow defined total flow source notation denotes flow absolute cardinality maximumflow problem flow network source sink flow maximum networkflow oblem explore flow properties capacity constraint simply flow vertex exceed capacity skew symmetry notational convenience flow vertex vertex negative flow reverse direction flowconservation property total flow vertex source sink skew symmetry rewrite flowconservation property total flow vertex flow fv exercise asks prove property formally observation flow properties deals flows positive total positive flow entering vertex defined total positive flow leaving vertex defined symmetrically define total net flow vertex total positive flow leavi vertex minus total positive flow entering vertex interpretation flowconservation property total positive flow entering vertex source sink equal total positive flow leaving vertex property total net flow vertex equal informally referred flow equals flow flow flow network model trucking problem figure lucky puck company factory source vancouver manufactures hockey pucks warehouse sink winnipeg stocks luc ky puck leases space trucks firm ship pucks factor warehouse trucks travel routes edges cities vertices ha limited capacity lucky puck ship crates day pair cities figure lucky puck control routes capacities alter flow network figure goal determine largest number crates day shipped produce sinc point producing pucks ship warehouse lucky puck concerned long takes puck factory warehouse care crates day leave factory crates day arrive warehouse surface model flow shipments flow network number crates shipped day city nother subject capacity constraint additionally flow conservation obeyed steady state rate pucks enter intermediate city equal rate leave crates accumula intermediate cities subtle difference shipme nts flows lucky puck ship pucks edmonton calgary ship pucks calgary edmonton suppose ship crates day edmonton v1 figure calgary v2 crates day calgary edmonton natural shipments directly flows sk ewsymmetry constraint requires v1 v2 v2 v1 case fv1 v2 fv2 v1 lucky puck realize pointless sh crates day edmonton calgary crates calgary edmonton achieve net shipping crates edmonton calgary crates calgary edmonton fewer resources process represent scenario flow v1 v2 fv2 v1crates day v1 v2 canceled crates day v2 v1 general cancellation represent shipments cities flow positive edge vertices situation pucks shipped directions cities transformed cancellation equivalent situation pucks shipped direction direction positive flow flow arose physical shipme nts reconstruct exact shipments flow units shipped units shipped units shipped typically care actual physical shipments set pair vertices care net travels care underlying shipments model retains shipments directions cancellation implicitly algorithms chapter suppose edge flow algorithm increase flow edge mathematically operation decrease conceptually units canceling units flow edge networks multiple sources sinks maximumflow problem sources sinks lucky puck company set factories s1 set warehouses figure fortunately problem harder ordinary maximum flow figure converting multiplesource multi plesink maximumflow problem problem single source single sink flow network sources s1 s3 s4 s5 sinks equivalent singlesource singlesink flow network add supersource edge infinite capacity multiple sources add supersink edge infin ite capacity multiple sinks reduce problem determining maximum flow network multiple sources multiple sinks ordinary maximumflow problem figure network converted dinary flow network single source single sink add supersource add directed edge capacity create supersink add directed edge capacity cti intuitively flow network corresponds flow network vice versa single source simply flow desired multiple sources single sink likewise consumes flow desired multiple sinks exercise asks prove formally problems equivalent working flows dealing functions arguments vertices flow network chapter implicit summation notation argument set vertices interpretation denoted sum ways replacing guments members sets vertices flowconservation constraint expressed condition convenience typically omit set braces implicit summati notation equation term set implicit set notation simplifies quations involving flows lemma proof left exercise captures commonly occurring identities involve flows implicit set notation lemma flow network flow equalities hold fx fx ø sums fx fx fz fz working implicit summation notation prove flow total flow sink intuitively expect property hold flow conservation vertices source sink equal amounts total pos itive flow entering leaving source definition total net flow greate positive flow leaves source enters symmetrically sink vertex total net flow positive flow enters sink leaves formal proof definition fv lemma fv lemma fv lemma fv fv lemma fv flow conservation chapter generalize result lemma exercises definition flow prove fv exercises prove vertex source sink total positive flow entering equal total positive flow leaving exercises extend flow properties definitions multiplesource multiplesink problem flow multiplesource multip lesink flow network corresponds flow identical singlesource single sink network adding supersource supersink vice versa exercises prove lemma exercises flow network flow figure pair subsets fx fv pair subsets fv exercises flow network f1 functions flow sum f1 function defined f1 flows flow properties flow sum f1 satisfy violate exercises flow network real number scalar flow product denoted function defined prove flows network form convex set f1 flows f1 range exercises state maximumflow problem linearprogramming problem exercises professor adam children unfortunate ly dislike problem severe refuse walk school fact refuses walk block child stepped day children problem paths crossing corner fortunately professors house school corners send children school professor map town formulate problem determining children school maximumflow problem fordfulkerson method presents fordfulkerson met hod solving maximumflow problem method algorithm encompasses implementations differing running times fordfulkers method depends ideas transcend method relevant flow algorithms problems residual networks augmenting paths cuts ideas essential maxflow mincut theorem theorem characterizes valu maximum flow terms cuts flow network sect ion presenting specific implementation fordfulkerson method analyzing running time fordfulkerson method iterative start initial flow iterati increase flow finding augmenting path simply path source sink send flow gmenting flow path repeat process augmenting path maxflow min cut theorem termination pro cess yields maximum flow fordfulkersonmethodg initialize flow exists augmenting path augment flow return residual networks intuitively flow network flow residual network consists edges admit flow formally suppose flow network source sink flow pair vertices additional flow push exceeding capacity residual capacityincrease units exceed capacity constraint edge flow negative residual capacity greater capacity residual capacity interpret situation flow units cancel pushing flow units push units violating capacity constraint edge pushed additional units flow starting flow reaching capacity constraint flow network flow residual network induced gf cfu promised edge residual network residual edge admit flow greater figure repeats flow network flow figure figure residual network gf figure flow network flow figure residual network gf augmenting path shaded residual capacity cv2 v3 flow augmenting path residual capacity residual network induced flow edges edges reversals edge cfu edge case cfv fv appears original network fv exercise cfu cfv conclude edge residual network appears origin network observe residual network gf flow network capacities lemma flow residual network relates flow original flow network lemma flow network source sink flow gf residual network induced flow gf flow sum defined equation flow proof verify skew symmetry capacity constraints flow conservation obeyed skew symmetry note fv fv fv fv capacity constraints note cfu equation flow conservation note finally augmenting paths flow network flow augmenting path simple path residual network gf definition residual network edge augmenting path admits additional positive flow violating capacity constraint edge shaded path figure augmenting path eating residual network gf figure flow network increase flow edge path units violating capacity constraint smallest residual capacity path cfv2 v3 maximum increase flow edge augmenting path residual capacity min cfu lemma proof left exercise argument precise lemma flow network flow augmenting path gf define function fp fp flow gf fp cfp corollary add fp flow closer maximum figure result adding fp figure figure corollary flow network flow augmenting path gf fp defined equation define function fp flow fp proof lemmas cuts flow networks fordfulkerson method repeatedly augmen flow augmenting paths maximum flow maxflow mincut theorem prove shortly tells flow maximum residual network augmenting path prove theorem explore notion cut flow network cut flow network partition definition defini tion cut minimum spanning trees chapter cutting directed graph undirected graph insist flow net flow cut defined capacity cut minimum cut network cut capacity minimum cuts network figure cut v1 v2 v3 v4 flow network figure net flow cut fv1 v3 fv2 v3 fv2 v4 capacity cv1 v3 cv2 v4figure cut flow network figure v1 v2 v3 v4 vertices black vertices white net flow capacity observe net flow cut incl ude negative flows vertices capacity cut composed nonnegative values net flow cut consists positive flows directions positive flow positive flow subtracted hand capacity cut computed edges edges included computation lemma net flow acr oss cut equals flow lemma flow flow network source sink cut net flow proof noting flow conservation lemma lemma lemmacorollary lemma result proved earlierequation flow total flow sink corollary lemma cut capacities bound flow corollary flow flow network bounded capacity cut proof cut flow lemma capacity constraints consequence corollary maximum flow network bounded capacity minimum cut network maxflow mincut theorem state prove maximum flow fact equal capacity minimum cut theorem maxflo mincut theorem flow flow network source sink conditions equivalent maximum flow residual network gf augmenting paths cut proof suppose sake contradiction maximum flow gf augmenting path corollary flow sum fp fp equation flow strictly greater contradicting assumption maximum flow suppose gf augmenting path gf path define exists path gf partition cut trivially path gf pair vertices place set lemmacorollary cuts condition implies maximum flow basic fordfulkerson algorithm iteration rdfulkerson method augmenting path increase flow edge residual capacity cfp implementation method computes maximum flow graph updating flow pair vertices connected edge connected edge direction assume implicitly capacities assumed graph residual capacity cfu computed formula expression cfp code temporary vari stores residual capacity path fordfulkersong edgefv exists path residual network gf cfp min cfu edge cfp fv fordfulkerson algorithm simply expands fordfulkersonmethod pseudocode earlier figure result iteration sample lines initialize flow loop lines repeatedly finds augmenting path gf augments flow residual capacity augmenting paths exist flow maximum flow figure execution basic fordfulkerson algorithm successive iterations loop left pa residual network gf shaded augmenting path flow adding fp residual network input network residual network loop test augmenting paths flow maximum flow analysis fordfulkerson running time fordfulkerson depends augmenting path determined chosen algorithm terminate flow increase successive augmentati ons converge maximum flow augmenting path chosen breadthfirst search algorithm runs polynomial time proving result simple bound case augmenting path chosen arbitrarily capacities integers practice maximumflow probl arises integral capacities capacities rational numbers scaling transformation integral assumption straightforward implementation ford fulkerson runs time oe maximum flow algorithm analysis lines time loop lines executed times flow increases unit iteration work loop efficient efficiently manage data structure implement network assume data structure directed graph edges network edges simple matter maintain capacities flows data structure flow edges residual network gf consist edges time path residual network ov oe depthfirst search breadthfirst earch iteration loop takes oe time making total running time fordfulkerson oe capacities integral optimal flow small running time fordfulkerson algorithm good figure happen simple flow network large maximum flow network units flow traverse path units traverse path augmenting path fordfulkerson figure flow iteration residual network figure iteration finds augmenting path figure flow figure residual network continue choosing augmenting path oddnumbered iterations augmenting path evennumbered iterations perform total augmentations increasing flow unit figure flow network fordfulkerson time maximum flow augmenting path residual capacity residual network augmenting path residual capacity residual network edmondskarp algorithm bound fordfulkerson improved implement computation augmenting path breadthfirst search augmenting path shortest path residual network edge unit distance weight fordfulkerson method implemented edmondskarp algorithm prove edmondskarp algorithm runs ov time analysis depends distances vertices residual network gf lemma notation shortestpath distance gf edge unit distance lemma edmondskarp algorithm flow network source sink vertices shortestpath distance residual network gf increases monotonically flow augmentation proof suppose vertex flow augmentation shortestpath distance decrease derive contradiction flow augmentation decreases shortest path distance flow afterward vertex minimum distance decreased augmentation shortest path gf chose distance label vertex decrease claim lemma triangle inequality inequality equation contradicts assumption augmentation increased flow edmondskarp algorithm ugments flow shortest paths shortest path gf edge inequality equation contradicts assumption conclude assumption vertex exists incorrect theorem bounds number iterations edmondskarp algorithm theorem edmondskarp algorithm flow network source sink total number flow augmentations performed algorithm ov proof edge residual network gf critical augmenting path residual capacity residual capacity cfp cfu augmented flow augmenting path critical edge path disappears residual network edge augmenting path critical edges critical v2 times vertices connected edge augmenting paths shortest paths critical time flow augmented edge disappears resi dual network reappear augmenti path flow decreased occurs appears augmenting path flow event occurs lemma time critical time critical distance source increases distance source initially intermediate vertices shortest path critical path implies unreachable source distance critical v22 v21 times oe pairs vertices edge residual graph total number critical edges entire execution edmondskarp algorithm ov augmenting path critical edge theorem iteration fordful kerson implemented oe time augmenting path bread thfirst search total running time edmondskarp algorithm ov pushrelabel gorithms yield bounds algorithm method achieving ov2 running time forms basis ov3time algorithm exercises figure flow cut v2 v4 v1 v3 capacity cut exercises execution edmondskar algorithm flow network figure exercises figure minimum cut maximum flow augmenting paths appearing cancel flow exercises prove pair vertices capacity flow functions cfu cfv exercises recall construction converts multisource multisink flow network singlesource singlesink network adds edges infinite capacity prove flow network finite edges original multisource multisink network finite capacity exercises suppose source multisource multisink problem produces units flow fsi suppose sink consumes units fv convert problem finding flow obeys additional constraints problem finding maximum flow singlesource singlesink flow network exercises prove lemma exercises maximum flow network sequence augmenting paths hint determine paths finding maximum flow exercises edge connectivity undirected graph minimum number edges removed disconnect graph edge connectivity tree edge connectivity cyclic chain vertices edge connectivity undirected graph determined running maximumflow algorithm flow networks ov vertices oe edges exercises suppose flow network symmetric edges edmondskarp algori thm terminates e4 iterations hint edge change times critical square brackets treat identifiersuch fas mutable field parentheses treat function fordfulkerson method fail termin ate edge capacities irrational numbers practice irrational num bers stored finiteprecision computers maximum bipartite matching combinatorial problems easily cast maximumflow problems multiple source multiplesink maximumflow problem combinatorial problems surface flow networks fact reduced maxi mumflow problems presents problem finding maximum tching bipartite graph b4 order solve problem advantage integrality property provided fordfulkerson method rdfulkerson method solve maximumbipartitematching problem graph ov time maximumbipartitematching problem undirected graph matching subset edges vertices edge incident vertex matched matching edge incident unmatched maximum matching matching maximum car dinality matching matching strict attention finding maximum matchings bipartite aphs assume vertex set partitioned disjoint edges assume vertex incident edge figure illustrates notion matching figure bibartite graph vertex partition matching cardinality maximum matching ith cardinality problem finding maximum matching bipartite graph practical applications matching set machines set tasks performed simultaneousl presence edge machine capable performing task maximum matching work machines finding maximum bipartite matching fordfulkerson method maximum matching undirected bipartite graph time polynomial trick construct flow network flows correspond matchings figure define flow network bipartite graph source sink vertices vertex partition directed edges edges directed edges figure flow network bipartite graph bipartite graph vertex partition figure maxi mum matching shaded edges flow network maximum flow edge unit capacity shaded edges flow edges carry flow shaded edges correspond maximum matching bipartite graph complete construction sign unit capacity edge vertex incident edge v2 lemma matching corresponds directly flow flow network flow flow network integer valued integer lemma bipartite graph vertex partition flow network matching integervalued flow conversely integervalued flow matching cardinality proof matching corresponds integervalued flow define fv fv edges define simple verify satisfies skew symmetry capacity constraints flow conservation intuitively edge corresponds unit flow traverses path paths induced edges vertexdisjoint net flow cut equal lemma flow prove converse integervalued flow vertex entering edge capacity unit positive flow ente ring unit positive flow enter flow conservation unit positiv flow leave integervalued unit flow enter edge leave edge unit positive flow enters vertex edge leaving carries positive flow symmetric argument set defined statement lemma matching observe matched vertex edge lemma simplify expression cons iderably flow conservation implies lemma implies skew symmetry implies edges edges definition based lemma conclude maximum matching bipartite graph corresponds maximum flow flow network compute maximum matching running maximumflow algorithm hitch reasoning maximumflow algor ithm return flow integer flow integer theorem fordfulkerson method difficulty theorem integrality theorem capacity function takes integral values maximum flow produced fordfulkerson method property integervalue vertices integer proof proof induction number iterations leave exercise prove corollary lemma corollary cardinality maximum matching bipartite graph maximum flow flow network proof nomenclature lemma suppose maximum matching flow maximum maximum flow capacities integervalued theorem assume integervalued corresponds matching cardinality contradicting assumption maximum matching manner maximum flow matching maximum matching bipartite undirected graph maximum matching creating flow network running fordfulkerson method directly obtaining maximum matching integervalued maximum flow matching bipartite graph cardinality min ov maximum flow ov maximum matc hing bipartite graph time ov ov exercises fordfulkerson algorithm flow network figure residual network flow augmentation number vertices iter ation pick augmenting path lexicographically smallest exercise prove theorem exercise bipartite graph vertex partition flow network good upper bound length augmenting path execution fordfulkerson exercise perfect matching matching ery vertex matched undirected bipartite graph vertex partition define neighborhood nx set vertices adjacent member prove halls theorem exists perfect matching subset exercise bipartite graph dregular vertex degree dregular bipartite graph prove dregular bipartite graph tching cardinality arguing minimum cut flow network capacity pushrelabel algorithms pushrelabel approach computing maximum flows asymptotically fastest maximumflow algorithms pushrelabel algorithms fastest actual implementati ons maximumflow algorithms based pushrelabel method flow problems su minimumcost flow problem solved efficiently pushrelabel methods introduces goldbergs generic maximumflow algorithm mple implementation runs ov2 time improving ov bound edmonds karp algorithm refines generic algorithm nother pushrelabel algorithm runs ov3 time pushrelabel algorithms work loca lized manner fordfulkerson method examine entire residual network augmenting path push relabel algorithms work vertex time vertexs neighbors residual network rdfulkerson method pushrelabel algorithms maintain flowconservation propert execution maintain preflow function satisfies skew symmetry capacity constraints relaxation flow conservation fv vertices total net flow vertex source nonnegative total net flow vertex excess flow vertex overflowing start describing intuition pushrelabel method investigate operations employed method pushing preflow relabeling vertex finally generic pushrelabel algorithm analyze correctness running time intuition intuition pushrelabel method understood terms fluid flows flow network interconnected pipes capacities applying analogy fordfulkerson method augmenting path network rise additional stream fluid branch points flowing source sink fordfulkerson method eratively adds streams flow generic pushrelabel algorithm intuition directed edges correspond pipes vertices pipe junctions interesting properties accommodate excess flow vertex tflow pipe leading arbitrarily large reservoir accumulate fluid vertex reservoir pipe connections platform height increases gorithm progresses vertex heights determine flow pushed push flow downhill higher vertex lower vertex flow lower vertex higher vertex positive operations push flow push downhill height source fixed height sink fixed vertex heights start increase time algorithm sends flow downhill source sink sends outgoing pipe source capacity sends capacity cut flow enters intermediate vertex collects vertexs servoir eventually pushed downhill eventually happen pipes leave vertex saturated flow connect vertices level uphill case rid overflowing vertex excess flow increase heightan operation called relabeling vertex height increased unit height lowest neighbors unsaturated pipe vertex relabeled outgoing pipe flow pushed eventually flow sink arrived arrive pipes obey capacity onstraints flow cut limited capacity cut preflow legal flow algorithm sends excess collected reservoirs overflowing vertices source continuing relabel vertices fixed height source reservoirs emptied preflow legal flow maximum flow basic operations preceding discussion ere basic operations performed pushrelabel algorithm pushing flow excess vertex neighbors relabeling vertex applicability operations depends heights vertices define precisely flow network source sink preflow function height function3 ht hv residual edge lemma lemma flow network preflow height function vertices hv edge residual graph push operation basic operation push applied overflowing vertex hv pseudocode updates preflow implied network assumes residual capacities computed constant time excess flow stored vertex maintained attribute height maintained attribute expression temporary variable stores flow pushed pushu applies overflowing cfu hv action push dfu mineu cfu units flow dfu mineu cfu dfu fv dfu dfu code push operates vertex assumed positive excess residual capacity positive increase flow dfu min causing negative capacity exceeded computes dfu update lines lines preflow push called remains preflow afterward observe code push depends heights prohibit invoked hv excess flow pushed downhill height differential lemma residual edges exist vertices heights differ long attribute height function gained allowing flow pushed downhill height differential operation push push push operation applies edge leaving vertex push operation applies saturating push edge saturated cfu afterward nonsaturating push edge saturated residual network simple lemma characterizes result nonsaturating push lemma nonsaturating push vertex longer overflowing proof push nonsaturating flow dfu pushed equal prior push reduced push relabel operation basic operation relabel applies overflowing hv edges relabel overflowing vertex vertex residual capacity flow pushed downhill recall definition source sink overflowing relabeled relabelu applies overflowing hv action increase height min hv operation relabelu vertex relabeled note relabeled edge leaves minimization code nonempty set property assumption overflowing fv vertex fv cfu fv implies operation relabelu greatest height allowed constraints height functions generic algorithm generic pushrelabel algorithm follow ing subroutine create initial preflow flow network initializepreflowg vertex vg edgefv vg vertex adjs initializepreflow creates initial preflow defined edge leaving source filled capacity edges carry flow vertex adjacent source initially initialized negative sum capacities generic algorithm initial height function height function edges hv edges saturated residual network initialization sequence push relabel operations executed order yields genericpushrelabel algorithm genericpushrelabelg initializepreflowg exists applicable push relabel operation select applicable push relabel operation perform lemma tells long overflowing vertex exists basic operations applies lemma overflowing vertex pushed relabeled flow network source sink preflow height function overflowing vertex push relabel operation applies proof residual edge hv1 height function push operation apply residual edges hv implies hv relabel operation applied correctness pushrelabel method generic pushrelabel algorithm solves maximumflow problem prove terminates preflow maximum flow prove terminates start obs ervations height function lemma vertex heights decrease execution genericpushrelabel flow network vertex height decreases relabel operation applied vertex height increases proof vertex heights change relabel operations suffices prove statement lemma vertex relabeled vertices hv min hv operation increase lemma flow network source sink execution genericpushrelabel attribute maintained height function proof proof induction number basic operations performed initially height function observed claim height function operation relabelu leaves height function residual edge leaves operation relabelu ensures hv afterward residual edge enters lemma hw operation relabelu implies hw afterward operation relabel leaves height function operation pushu operation add edge remove case hv remains height function casethe removal residual network removes constraint remains height function lemma property height functions lemma flow network source sink preflow height function path source sink residual network gf proof assume sake contra diction path v0 v1 vk gf v0 vk loss generality simple pathedge vi vi1 height function hvi hvi1 combining inequalities path yields ht ht contradicts requirement height function ready generic pushrelabel algorithm terminates preflow computes maximum flow theorem correctness generic pushrelabel algorithm algorithm genericpushrelabel rminates flow network source sink preflow computes maximum flow proof loop invariant time loop test genericpushrelabel executed preflow initialization initializepreflow preflow maintenance operations loop lines push relabel relabel operations affect height attributes flow values affect preflow argued preflow prior push operation remains preflow afterward termination termination vertex excess lemmas invariant preflow overflowing vertices flow height function lemma tells path residual network gf maxflow mincut theorem theorem maximum flow analysis pushrelabel method generic pushrelabel algorithm terminat bound number operations perf orms types operationsrelabels saturating pushes nonsaturating pushesis bounded separately knowledge bounds straightforward problem onstruct algorithm runs ov2e time analysis prove lemma lemma flow network source sink preflow overflowing vertex simple path residual network gf proof overflowing vertex exists simple path gf suppose sake contradiction claim pair vertices fw fw fv turn implies cfv fv exists edge simple path form gf contradicting choice term implicit summation nonpositive fv equation lemma lemmaexcesses nonnegative vertices assumed vertices contradicts assumption overflowing lemma bounds heights vertices corollary bounds number relabel operations performed total lemma flow network source sink time execution genericpushrelabel vertices proof heights source sink change vertices definition overflowing ht greater vertex initially v1 relabeling operation v1 relabeled overflowing lemma tells simple path gf v0 v1 vk v0 vk v1 simplevi vi1 lemma hvi hvi1 expanding inequalities path yields hv0 hvkcorollary bound relabel operations flow network source sink execution genericpushrelabel number relabel oper ations vertex v2 proof v2 vertices relabeled operation relabelu increases initially lemma grows vertex relabeled times total number relabel operations performed v2 lemma helps bound number saturating pushes lemma bound saturating pushes execution genericpushrelabel flow network number saturating proof pair vertices count saturating pushes calling saturating pushes pushes edge suppose saturating push occurred time hv order push occur algorith push flow happen hv decreases order hv hv increase likewise increase saturating pushes heights start lemma exceed implies number times vertex height increase hv increase saturating pushes fewer saturating pushes multiplying number edges bound total number saturating pushes lemma bounds number nonsa turating pushes generic pushrelabel algorithm lemma bound nonsaturating pushes execution genericpushrelabel flow network number nonsaturating pushes v2 proof define potential function vev0hv initially change relabeling saturating push nonsaturating push bound saturating pushes relabe lings contribute increase nonsaturating push decrease bounds derive upper bound number nonsaturating pushes examine ways increase relabeling vertex increases set sum relabeling increase height maximum height lemmasaturating push vertex vertex increases heights change vertex height overflowing nonsaturating push decreases nonsaturating push overflowing overflowing lemma longer overflowing push addition overflowing push source potential function decreased increased hv hv net potential function decreased algorithm total increase relabelings saturated pushes constrained corollary lemma v2 v2 v2 v2 total decrease total number nonsaturating pushes v2 bounded number relabelings saturating pushes nonsaturating push set stage analysis genericpushrelabel procedure algorithm based pushrelabel method theorem execution genericpushrelabel flow network number basic operations ov2e proof corollary lemmas algorithm terminates ov2 operations remains efficient method implementing operation choosing operation execute corollary implementation generi pushrelabel algorithm runs ov2 time flow network proof exercise asks implemen generic algorithm overhead ov relabel operation o1 push asks design data structure pick applicable operation o1 time corollary exercises implement gene ric pushrelabel algorithm ov time relabel operation o1 time push o1 time select appli cable operation total time ov2e exercises prove generic pushrelabel algorithm spends total ov time performing ov2 relabel operations exercises suppose maximum flow flow network pushrelabel algorithm fast algorithm minimum cut exercises efficient pushrelabel algorithm maximum matching bipartite graph analyze algorithm exercises suppose edge capacities flow network set analyze running time generic pushrelabel algorithm terms hint times edge support nonsaturating push saturated exercises initializepreflow changed vg correctness asymptotic performance generic pushrelabel algorithm exercises distance number edges residual network gf genericpushrelabel maintains properties implies implies exercises previous exercise distance residual network gf generic pushrelabe algorithm modified maintain property implies implies total time implementation dicates maintaining property ov exercise number nonsaturating pushes executed genericpushrelabel flow network v2e literature heig ht function typically called distance function height vertex called distance label term height suggestive intuition algorithm retain term relabel refer operation increases height vertex height vertex distance sink breadthfirst search transpose gt relabeltofront algorithm pushrelabel method apply basic operations order choosing order carefully managing twork data structure efficiently solve maximumflow problem faster ov2e bound corollary examine relabeltofront gorithm pushrelabel algorithm running time ov3 asymptotically good ov2e dense networks relabeltofront algorithm maintains list vertices network algorithm scans list repeat edly selecting overflowing vertex discharging performing push relabel operations longer positive excess vertex relabeled moved list relabeltofront algorithm scan anew correctness analysis relabel tofront algorithm pend notion admissible edges edge residual network flow pushed proving properties bout network admissible edges investigate discharge operation analyze relabe ltofront algorithm admissible edges networks flow network source sink preflow height function admissible edge cfu hv inadmissible admissible network gfh efh efh set admissible edges admissible network consists edges flow pushed lemma network directed acyclic graph dag lemma admissible network acyclic flow network preflow height function admissible network gfh efh acyclic proof proof contradiction suppose gfh cycle v0 v1 vk v0 vk edge admissible hvi1 hvisumming cycle vertex cycle appears summations derive contradiction lemmas push rela bel operations change admissible network lemma flow network preflow suppose attribute height function vertex overflowing admissible edge push applies operation create admissible edges inadmissible proof definition admissibl edge flow pushed overflowing operation pushu applies residual edge created pushing flow edge hv edge admissible opera tion asaturating push cfu afterward inadmissible lemma flow network preflow suppose attribute height function vertex overflowing admissible edges leaving relabelu applies relabel operation admissible edge leaving admissible edges entering proof overflowing lemma push relabel operation applies admissible edges leaving flow pushed relabelu applies relabel operation min hv vertex realizes minimum set edge admissible relabel admissible edge leaving admissible edges enter relabel operation suppose vertex admissible hv relabel hv relabel lemma residual edges exist vertices heights differ relabeling vertex change residual network residual network admissible network neighbor lists edges relabeltofront algorithm organized neighbor lists flow network neighbor list nu vertex singly linked list neighbors vertex appears list nu neighbor list nu vertices residual edge vertex nu pointed headnu vertex neighbor list pointed nextneighborv pointer nil vertex neighbor list relabeltofront algorithm cycles neighbor list arbitrary order fixed execution algorithm vertex field current points vertex consideration nu initially current set headnu discharging overflowing vertex overflowing vertex discharged pushing excess flow admissible edges neighboring vertices relabeling edges leaving admissible pseudocode dischargeucurrentu nil relabelu currentu headnu elseif cfu hv pushu currentu nextneighborv figure steps iterations loop lines executes long vertex positive excess iteration performs actions depending current vertex neighbor list nu nil nu relabels vertex resets current neighbor nu lemma states relabel operation applies situation nonnil admissible edge determi ned test pushes excess vertex nonnil inadmissible advances currentu position neighbor list nu figure discharging vertex takes iterations loop discharge push excess flow neighbors edges entering leaving number inside vertex excess iteration vertex height neighbor list iteration iteration number shaded neighbor current initially units excess push currenty iterationsadvance current admissible edges leaving iteration current nil shading neighbor list relabeled currenty reset head neighbor list relabeling vertex height iterations edges inadmissible units excess flow pushed iteration push current advanced iteration push iteration saturated edge inadmissible iteration iteration currenty nil vertex relabeled currenty reset iteration inadmissible units excess flow pushed iteration current advanced iteration iteration finds inadmissible iteration finds inadmissible iteration relabels vertex resets currenty iteration pushes units excess flow vertex excess flow discharge terminates dischar starts finishes current pointer head neighbor list general case observe discharge called overflowing vertex action performed discharge push procedure terminates relabel operation advancing pointer currentu push elabel called discharge operation applies lemma proves fact lemma discharge calls pushu push operation applies discharge calls relabelu rela bel operation applies proof tests lines ensure push operation occurs operation applies proves statement lemma prove statement acco rding test lemma edges leaving inadmissible observe discharge repeatedly called pointer currentu moves list nu pass head nu finishes currentu nil point relabeled pass current pointer advance vertex nu pass edge deemed inadmissible test time pass completes edge leaving determined inadmissibl time pass key observation pass edge leaving inadmissible lemma pushes create admissibl edges leaving admissible edge created relabel operation vertex relabeled pass lemma vertex relabele pass entering admissible edges relabeling pass edges leaving remain inadmissible lemma proved relabeltofront algorithm relabeltofront algorithm maintain linked list consisting vertices key property vertices topologically sorted admissible network loop invariant recall lemma admissible network dag pseudocode relabeltofront algorithm assume neighbor lists nu created vertex assumes nextu points vertex list usual nextu nil vertex list relabeltofrontg initializepreflowg vg order vertex vg currentu headnu headl nil oldheight dischargeu oldheight list nextu relabeltofront algorithm works initializes preflow heights values generic pushrela bel algorithm initializes list overflowing vertices order lines initialize current pointer vertex vertex neighbor list figure loop lines runs list discharging vertices start rtex list time loop vertex discharged relabeled discharge procedure moves list determination saving height variable oldheight discharge operation comparing saved height height afterward iteration loop vertex list moved lis vertex iteration position list figure action relabeltofront flow network iteration loop initially units flow leave source initial list initially vertex list neighbor list current neighbor shaded vertex discharged relabeled height units excess flow pushed remaining units excess pushed sink relabeled moved head case change structure vertex discharged figure detailed action discharging situation relabeled moved head vertex discharged pushing units excess flow vertex relabeled discharge operation remains place list vertex vertex discharged relabeled height units excess flow pushed relabeled moved vertex vertex discharged excess discharge returns remains place vertex discharged cess discharge returns remains place relabeltofront reached list terminates overflowing vertices preflow maximum flow relabeltofront computes maximum flow implementation generic push relabel algorithm observe performs push relabel operation apply lemma guarantees discharge performs apply rema ins relabeltofront terminates basic operations apply remai nder correctness argument relies loop invariant test relabeltofront list topological sort vertices admissible network gfh efh vertex list excess flow initialization initia lizepreflow hv edge admissible efh ø ordering topological sort gfh initially head list vertices excess flow maintenance topological sort maintained iteration loop start observing admissible network changed push relabel operations lemma push operations edges admissible admissible edges created relabel operations vertex relabeled lemma states admissible edges entering admissible edges leaving moving algorithm ensures admissible edges leaving satisfy topological sort ordering vertex preceding excess flow denote vertex iteration vertices precede iteration include current vertices relabeled vertices relabeled discharged excess flow afterward relabeled discharge vertices preceding excess flow relabeled discharge vertices list acquired excess flow discharge remained topologically sorted times discharge pointed admissible edges created labeling pushing push operation excess flow vertices list vertices preceding excess flow termination loop terminates loop invariant ensures excess rtex basic operations apply analysis relabeltofront runs ov3 time flow network algorithm implementation generic pushrelabel algorithm advantage corollary ov bound number relabel operations executed vertex ov2 bound total number relabel operations addition exercise ove bound total time spent performing relabel operations lemma ove bound total number saturating push operations theorem running time relabelto flow network ov3 proof phase relabeltofront algorithm time consecutive relabel operations ov2 phases ov2 relabel operations phase consists calls discharge discharge perform label operation discharge list length discharge perform relabel discharge belongs phase phase calls discha rge ov2 phases number times discharge called li relabeltofront ov3 total work performed loop relabeltofront excluding work performed discharge ov3 bound work performed discharge execution algorithm iteration loop discharge performs actions analyze total work involved performing actions start relabel operations lines exercise ove time bound ov2 relabels performed suppose action updates current pointer action occurs odegreeu times time vertex relabeled ov degreeu times vertex vertices total work advancing pointers neighbor lists ove handshaking lemma exercise b41 type action performed discharge push operation total number saturating push operations ove observe nonsaturating push executed discharge immedi ately returns push reduces excess nonsaturating push discharge observed discharge called ov3 times total time spent performing nonsaturating pushes ov3 running time relab eltofront ov3 ov3 exercises illustrate execution rela beltofront manner figure flow network figure assume initial ordering vertices v1 v2 v3 v4 neighbor lists nv1 v2 v3 nv2 v1 v3 v4 nv3 v1 v2 v4 nv4 v2 v3 exercises implement pushrelabel algorithm maintain firstin firstout queue overflowing vertices algorithm repeat edly discharges vertex head queue vertices overflowing discharge overflowing afterward queue vertex head queue discharged removed algorithm terminates algorithm implemented compute maximum flow ov3 time exercises generic algorithm works relabel updates simply computing change affect analysis relabeltofront exercises discharge highest overflowing vertex pushrelabel method ov3 time exercises suppose point execution pushrelabel algorithm ere exists integer vertex hv vertices hv source minimum cut exists gap heuristic updates vertex hv set hv max hv v1 attribute height functionthe gap heuristic crucial making implementations pushrelabel method perform practice problems escape problem grid undirected graph consisting rows columns vertices figure denote vertex ith row jth column vertices grid neighbors boundary vertices points figure grids escape problem starti points black grid vertices white grid escape shaded paths grid escape starting points y1 xm ym grid escape problem determine vertexdisjoint paths starting points points boundary grid figure escape grid figure flow network vertices edges capacities total positive flow entering vert subject capacity constraint determining maximum flow network edge vertex capacities reduced ordinary maximumflow problem flow network comparable size efficient algorithm solv escape problem analyze running time problems minimum path cover path cover directed graph set vertexdisjoint paths vertex included path paths start length including minimum path cover path cover fewest paths efficient algorithm minimu path cover directed acyclic graph hint assuming construct graph x0 y0 y1 yn x0 yi y0 maximumflow algorithm algorithm work directed aphs cycles explain problems space shuttle experiments professor spock consulting nasa planning series space shuttle flights decide commercial experiments perform instruments board flight light nasa considers set e1 experiments commercial sponsor experiment agreed pay nasa dollars experiment experiments set i1 instruments experiment requires instruments subset cost carrying instrument ik ck dollars professors job efficient algorithm determine experiments perform instruments carry flight order maximize net revenue total income experiments performed minus total cost instruments carried network network source vertex vertices i1 vertices e1 sink vertex edge ik capacity ck edge capacity ik edge ik infinite capacity finitecapacity cut ik ik determine maximum net revenue capacity minimum cut values efficient algorithm determin experiments perform instruments carry analyze runni time algorithm terms problem updating maximum flow flow network source sink integer capacities suppose maximum flow suppose capacity single edge increased ov etime algorithm update maximum flow suppose capacity single edge decreased ov etime algorithm update maximum flow problem maximum flow scaling flow network source sink integer capacity edge max vecu argue minimum cut capacity number augmenting path capacity oe time path exists modification fordfulkersonmethod compute maximum flow maxflowbyscaling maxuvecu initialize flow lgcexists augmenting path capacity augment flow k2 return argue maxflowbyscal ing returns maximum flow capacity mi nimum cut residual graph gf time executed argue loop lines executed oe times conclude maxflowbyscaling implemented runs oe2 lg time problem maximum flow negative capacities suppose flow network negative posi tive edge capacities network feasible flow exist edge flow network explain negative capacity terms flow flow network negative edge capac ities source sink construct ordinary flow network capacity function source sink assign capacities edges edge set u2 vertex set max0 v2 max0 u2 set prove feasible flow exists capacities nonnegative maximum flow exists edges sink saturated prove converse proof constructive flow saturates edges proof feasible flow algorithm finds maximum feasible flow denote mfv worstcase running tim ordinary maximum flow algorithm graph vertices edges analyze algorithm computing maximum flow flow network negative capacities terms mf problem hopcroftkarp bipartite matching algorithm problem faster algor ithm hopcroft karp finding maximum matching bipartite graph algorithm runs time undirected bipartite graph edges endpoint matching simple path augmenting path respect starts unmatched vertex ends unmatched vertex edges belong alternately definition augmenting path augmenting path flow network problem treat path sequence edges sequence vertices shortest augmenting path respect matching augmenting path minimum number edges sets symmetric difference defined elements sets matching augmenting path respect symmetric difference matching vertexdisjoint augmenting paths respect symmetric difference matching cardinality general structure algorithm hopcroftkarp ø repeat maximum set vertexdisjoint shortest augmenting paths respectreturn remainder problem asks anal yze number iterations algorithm number iterations repeat loop implementation matchings vertex graph degree conclude disjoint union simple paths cycles argue edges simp path cycle belong alternately prove vertexdisjoint augmenting paths respect length shortest augmenting path respect matching maximum set vertexdisjoint augmenting paths length respect suppose shortest augmenti path respect vertexdisjoint edges suppose vertexdisjoint set edges conclude edges prove shortest augmenting path length size maximum matching number repeat loop iterations algorithm hint grow iteration number algorithm runs oe time maximum set vertexdisjoint shortest augmenting paths matching conclude total running time hopcroftkarp chapter notes ahuja magnanti orlin lawler papadimitriou steiglitz tarjan good references network flow algorithms goldberg tardos tarjan provide nice survey gorithms networkflow problems schrijver written interesting review historical developments field network flows fordfulkerson method ford fulkerson originated formal study problems area network flow including maximumflow bipartitematching problems early impl ementations fordfulkerson method augmenting paths breadthfirst search edmonds karp independently dinic proved strategy yields polynomialtime algorithm idea blocki flows developed dinic karzanov developed idea preflows pushrelabel method goldberg goldberg tarjan goldberg tarjan ov3time algorithm queue maintain set overflowing vert ices algorithm dynamic trees achieve running time ove lgv2e researchers developed pushrelabel ximumflow algorithms ahuja orlin ahuja orlin tarjan algorithms scaling cheriyan maheshwari proposed pushing flow overflowi vertex maximum height cheriyan hagerup suggested randomly permuting nei ghbor lists researchersdeveloped clever derandomizati ons idea leading sequence faster algorithms algorithm king rao tarjan fastest algorithm runs ove logev lg time asymptotically fastest algorithm maximumflow problem goldberg rao runs time omin v23 e12 lg v2 lg max algorithm pus hrelabel method based finding blocking flows previous maximum flow algorithms including chapter notion distance pus hrelabel algorithms analogous notion height length assigned implicitly edge algorithm takes approach assigns length highcapacity edges length lowcapacity edges informally respect lengths shortest paths source sink tend high capacity fewer iterations performed practice pushrelabel algorithms dominate augmentingpath linear programming based algorithms maximumflow problem study cherkassky goldberg underscores tw heuristics implementing push relabel algorithm heuristic peri odically perform breadthfirst search residual graph order accurate height values heuristic gap heuristic exericse conclude choice pushrelabel variants chooses discharge overflowing vertex maximum height algorithm ximum bipartite tching discovered hopcroft karp runs time problem book lovász plummer excellent reference matching problems vii selected topics chapter list chapter sorting networks chapter matrix operations chapter linear programming chapter polynomials fft chapter numbertheoretic algorithms chapter string matching chapter computational geometry chapter npcompleteness chapter approximation algorithms introduction selection algorithmic topics extend complement earlier material book chapters intr oduce models computation combinational circuits para llel computers cover specialized domains computational geometry number theory chapters discuss limitations design ficient algorithms introduce techniques coping limitations chapter presents parallel model putation comparison networks roughly speaking comparison network algorithm comp arisons simultaneously chapter build comparison network sort numbers olg2 time chapter studies efficient algorithms operati matrices examining basic matrix properties explores strassens algorithm multiply matrices on281 time presents general methodslu decomposition lup decompositionfor solving linear equa tions gaussian elimination on3 time matrix inversion matrix multip lication performed equally fast chapter concludes showing leastsquares approximate solution computed set linear equati ons exact solution chapter studies linear programming maximize minimize objective limited resources competing constraints linear programming arises variety practical application areas chapter covers formulation solution linear programs solution method covered simplex algorithm oldest algorithm linear programming contrast algorit hms book simplex algorithm polynomial time worst case fairly efficient practice chapter studies operations polynomials wellknown signalprocessing techniquethe fast fourier transform fft multiply degree polynomials lg time investigates efficient implementations fft including parallel circuit chapter presents numbertheoretic algorithms review elementary number theory presents euclids algorithm comp uting greatest common divisors algorithms solving modular linear equations ising number power modulo number presented application numbertheoretic algorithms rsa publickey cryptosystem cryptosystem encrypt messages adversary read provide digital signatures chapter presents errabin randomized primality test large primes efficientlyan ssential requirement rsa finally chapter covers pollards rho heuristic factoring integers discusses state art integer factorization chapter studies problem finding occurre nces pattern string text string problem arises frequently textediting programs examining naive approach chapter presents elegan approach rabin karp showing efficient solution based finite automata chapter presents knuthmorris pratt algorithm achieves efficiency cleverly preprocessing pattern computational geometry topic chapter discussing basic primitives computational geometry chapter sweeping method efficiently determine set segments contai intersections clever algorithms finding convex hull set pointsgrahams scan jarviss marchalso illustrate power sweeping methods chapter closes effi cient algorithm finding closest pair set points plane chapter concerns npcomplete problems teresting computati onal problems npcomplete polynomial time algorithm lving chapter presents techniques determining wh problem npcomplete classic problems proved npcomplete determ ining graph hamiltonian cycle determining boolean formula satisfiable determining ven set numbers subset adds target chapter proves famous travelingsalesman problem npcomplete chapter approximation algorithms approximate solutions npcomplete problems efficiently np complete problems approximate solutions optimal easy produ approximation algorithms work progressively problem size increases problems invest incr easing amounts comput ation time return increasingly approximate solutions chapter illustrates possibilities vertexcover problem unweighted weighted versions optimization version cnf satisfiability travelingsalesman probl setcovering problem subset sum problem chapter sorting networks overview examined sorting algorithms serial computers randomaccess machines rams operatio executed time chapter investigate sorting algorithms based comparisonne twork model computation comparison operations performed simultaneously comparison networks differ rams respects perform comparisons algo rithm counting sort implemented comparison network ram model operations occur seriallythat anotheroperati ons comparison network occur time parallel characteristic construction comparison networks sort values sublinear time defining comparison networks sorting networks natural definition running time comparison network terms depth network proves zeroone principle greatly eases task analyzing correctness sorting networks efficient sorting network desi gn essentially parallel version mergesort algorithm construction steps presents design bitonic sorter basic building block modify bitonic sorter produce merging network merge sorted sequences sorted sequence finally assemble merging networks sorting network sort values olg time comparison networks sorting networks comparison networks sort inputs sense discussion comparison networ ks characteristics comparison network composed solely wires comparators comparator figure device inputs outputs performs function figure comparator inputs outputs comparator drawn single vertical inputs outputs min max pictorial represen tation comparator figure bulky purposes adopt convention draw ing comparators singl vertical lines figure inputs left outputs smaller input appearing output larger input appearing output comp arator sorting inputs assume comparator operates o1 time assume time appearance input values production output values constant wire transmits place place wires connect output comparator input network input wires network output wires chapter assume comparison network input wires a2an values sorted enter network output wires b2bn produce computed network speak input sequence a2an output sequence b2bn referring values input output wires wire carries intention clear context figure comparison network set comparators interconnected wires draw comparison network inputs collection horizontal lines comparators stretched verti cally note represent single wire sequence distinct wires connecting comparators figure represents wires input wire connects input comparator wire connecting output comparator input comparator output wire output comparator comparator nput connected wire networks input wires a2an connected output comparator comparator output connect wire networks output wires b2bn connected input comparator main requirement interc onnecting comparators graph interconnections acyclic trace path output comparator input output input path trace cycle comp arator figure draw comparison network network inputs left network outputs data network left figure input output comparison network fact sorting network time input values input wires time values outputs comparators depth time values outputs comparators depth output wires b4 final values output wires time values outputs comparator depth output wires final values comparator produces output values input values figure suppose seque nce appears input wires time time comparators input values assuming comparator requir time unit compute output values comparators produce outputs time values figure note comparators produce values time parallel time comparators input values time unit time oduce outputs figure comparators operate parallel output comparator output comparator connect output wires b4 comparison network network output wires carry final values time time comparator inputs figure produces output values time values carried network output wires output sequence complete assumption comparator unit time define running time comparison network time takes output wires receive values input wires receive formally time largest number comparators input element pass thro ugh travels input wire output wire formally define depth wire input wire comparison network depth mparator input wires depths output wires depth max cycles comparators comparison network depth wire defined define depth comparator depth output wires figure comparator depths depth comparison network maximum depth output wire equivalently maximum depth comparator comparison network figure depth comparator depth comparator takes time unit produce output netw ork inputs time comparator depth produces outputs time depth network equals time network produce values output wires sorting network comparison network output sequence monotonically increasing input sequence comparison network sorting network network figure observe time minimum input values produced output comparator output comparator time output comparator symmetrical argument time maximum input values produced output comparator remains comparator ensure middl values occupy correct output positions time comparison network procedure specifies comparisons occur procedure sizethe number comparators containsdepends number inputs outputs describing families comparison networks goal chapter develop family sorter efficient sorting networks network family family number inputs equals number outputs ninput noutput sorting network family sorter named sorter exercises values wires network figure input sequence exercises exact power construct ninput noutput comparison network depth lg output wire carries minimum input output wire carri maximum input exercises sorti network add comparator comparison network sorting network add mparator network figure network sort input permutation exercises prove sorting network inputs depth lg exercises prove number comparat ors sorting network lg exercises comparison network figure prove fact sorting network structure insertion sort figure sorting network based insertion sort exercise exercises represent ninput comparison network comparators list pairs integers range pairs integer common order comparators network determined der pairs list representation ctime serial algorithm determining depth comparison network exercises suppose addition standard kind comparator introduce upsidedown comparator produces minimum output wire maximum output wire convert sorting network total standard upsidedown comparators standard prove conversion method correct zeroone principle zeroone principle sorting network works correctly input drawn set works corr ectly arbitrary input numbers numbers integers reals general set values linea rly ordered set construct sorting networks comparis networks zeroone principle focus operation input sequences consisting solely constructed sorting network proved sort zeroone sequences appeal zeroone principle properly sorts sequences arbitrary values proof zeroone principle relies notion monotonically increasing function lemma comparison network transforms input sequence a2an output sequence b2bn monotonically increasing function network transforms input sequence fa1 fa2fan output sequence fb fb1 fb2fbn proof prove claim monotonically increasing function single comparator inputs fx produces outputs fmin fmax induction prove lemma prove claim mparator input values upper output comparator min lower output max suppose apply fx inputs comp arator figure operation comparator yields min fx upper output max fx lower output monotonically increasing implies fx identities min fx fmax max fx fmin figure operation comparator proof lemma function monotonically increasing comparator produces values fmin fmaxx fx inputs completes proof claim induction depth wire general comparison network prove stronger result statement lemma wire assumes ai input sequence applied network assumes fai input sequence applied output wires incl uded statement proving prove lemma basis wire depth input wire ai result trivially applied network input wire carries fai inductive step wire depth wire output comparator depth input wires comparator depth strictly inductive hypothesis input wires comparator carry values ai input sequence applied carry fai faj input sequence applied earlier claim output wires comparator carry fmin ai fmax ai carry min ai max ai input sequence lemma proved application lemma figure sorting network figure repeated figure monotonically increasing function fx applied inputs wire applied wire figure figure sorting network figure input sequence sorting network monotonically increasing function fx fx2 applied inputs wire network applied wire comparison network sorting network lemma prove remarkable result theorem zeroone principle comparison network inputs sorts sequences correctly sorts sequences arbitrary numbers correctly proof suppose purpose contradiction network sorts zeroone sequences exists sequence arbitrary numbers network correctly sort exists input sequence a2an elements ai ai network places ai output sequence define monotonically increasing function network places ai output sequence a2an input lemma places faj fai output sequence fa1 fa2fan input faj fai contradiction network fails sort zeroone sequence fa1 fa2fan correctly exercises prove applying monotonically increasi function sorted sequence produces sorted sequence exercises prove comparison network inputs correctly sorts input sequence correctly sorts zeroone sequencesexercises zeroone principle prove comparison network figure sorting network figure sorting network sorting numbers exercises state prove analog zeroone principle decisiontree model hint handle equality properly exercises prove ninput sorting network comparator ith lines bitonic sorting network step construction efficient sorting network construct comparison network sort bitonic sequence sequence monotonically increases monotonically decreases circularly shifted monotonically increasing monotonically decreasing sequences bitonic boundary condition sequence numbers itonic zeroone sequences bitonic simple structure form form note sequence monotonically increasing monotonically decreasing bitonic bitonic sorter construct comparison network sorts bitonic sequences exercise asks bitonic sorter sort bitonic sequences arbitrary numbers halfcleaner bitonic sorter composed seve ral stages called halfcleaner halfcleaner comparison networ depth input compared assume figure halfcleaner8 halfcleaner inputs outputs figure comparison network halfcle aner8 sample zeroone input output values input assumed itonic halfcleaner ensures output element half small output element half halves bit onic half clean bitonic sequence applie input halfcleaner halfcleaner produces output sequence smaller values half larger values half halves bitonic fact halves clean consisting sand property derive half cleaner note clean sequences bito nic lemma proves properties halfcleaners lemma input halfcleaner bitonic sequence output satisfies properties half half bitonic element half small element half half clean proof comparison network halfcleaner compares inputs loss generality suppose input form situation input form symmetric cases dependi block consecutive midpoint falls cases midpoint occurs block split cases cases figure case lemma holds figure comparisons halfcleaner input sequence assumed bitonic sequence loss generality assume form subsequences white subsequences gray inputs divided halves inputs compared cases division occurs middle subsequence cases division ccurs subsequence cases element half output small element half halves bitonic half clean bitonic sorter recursively combining halfcleaners figure build bitonic sorter network sorts bitonic sequences stage bitonic sorter consists halfcleanern lemma produces bitonic sequences half size elemen half small element half comple sort copies bitonic sorter sort halves recursively figure recursion explicitly figure recursion unrolled progressively smaller halfcleaners remainder bitonic sorter depth dn bitonicsorter recurrence solution dn lg figure comparison network bitonicsorter recursive construction halfcleaner copies bitonicsorter operate parallel network unrolling recursion halfcleaner shaded sample values wires zeroone bitonic sequence sorted bitonicsorter depth lg analog zeroone principle exercise bitonic sequence arbitrary numbers sorted network exercises zeroone bitoni sequences length exercises bitonicsortern exact power lg comparators exercises olg ndepth bitonic sorter constructed number inputs exact power exercises input halfcleaner bitonic sequence arbitrary numbers prove output satisfies properties half half bitonic element half small element half exercises sequences prove element sequence small element sequen sequences clean exercises prove analog zeroone principle bitonic sorting networks comparison network sort bitonic sequence sort bitonic sequence arbitrary numbers chapter notes ahuja magnanti orlin lawler papadimitriou steiglitz tarjan good references network flow algorithms goldberg tardos tarjan provide nice survey gorithms networkflow problems schrijver written interesting review historical developments field network flows fordfulkerson method ford fulkerson originated formal study problems area network flow including maximumflow bipartitematching problems early impl ementations fordfulkerson method augmenting paths breadthfirst search edmonds karp independently dinic proved strategy yields polynomialtime algorithm idea blocki flows developed dinic karzanov developed idea preflows pushrelabel method goldberg goldberg tarjan goldberg tarjan ov3time algorithm queue maintain set overflowing vert ices algorithm dynamic trees achieve running time ove lgv2e researchers developed pushrelabel ximumflow algorithms ahuja orlin ahuja orlin tarjan algorithms scaling cheriyan maheshwari proposed pushing flow overflowi vertex maximum height cheriyan hagerup suggested randomly permuting nei ghbor lists researchersdeveloped clever derandomizati ons idea leading sequence faster algorithms algorithm king rao tarjan fastest algorithm runs ove logev lg time asymptotically fastest algorithm maximumflow problem goldberg rao runs time omin v23 e12 lg v2 lg max algorithm pus hrelabel method based finding blocking flows previous maximum flow algorithms including chapter notion distance pus hrelabel algorithms analogous notion height length assigned implicitly edge algorithm takes approach assigns length highcapacity edges length lowcapacity edges informally respect lengths shortest paths source sink tend high capacity fewer iterations performed practice pushrelabel algorithms dominate augmentingpath linear programming based algorithms maximumflow problem study cherkassky goldberg underscores tw heuristics implementing push relabel algorithm heuristic peri odically perform breadthfirst search residual graph order accurate height values heuristic gap heuristic exericse conclude choice pushrelabel variants chooses discharge overflowing vertex maximum height algorithm ximum bipartite tching discovered hopcroft karp runs time problem book lovász plummer excellent reference matching problems vii selected topics chapter list chapter sorting networks chapter matrix operations chapter linear programming chapter polynomials fft chapter numbertheoretic algorithms chapter string matching chapter computational geometry chapter npcompleteness chapter approximation algorithms introduction selection algorithmic topics extend complement earlier material book chapters intr oduce models computation combinational circuits para llel computers cover specialized domains computational geometry number theory chapters discuss limitations design ficient algorithms introduce techniques coping limitations chapter presents parallel model putation comparison networks roughly speaking comparison network algorithm comp arisons simultaneously chapter build comparison network sort numbers olg2 time chapter studies efficient algorithms operati matrices examining basic matrix properties explores strassens algorithm multiply matrices on281 time presents general methodslu decomposition lup decompositionfor solving linear equa tions gaussian elimination on3 time matrix inversion matrix multip lication performed equally fast chapter concludes showing leastsquares approximate solution computed set linear equati ons exact solution chapter studies linear programming maximize minimize objective limited resources competing constraints linear programming arises variety practical application areas chapter covers formulation solution linear programs solution method covered simplex algorithm oldest algorithm linear programming contrast algorit hms book simplex algorithm polynomial time worst case fairly efficient practice chapter studies operations polynomials wellknown signalprocessing techniquethe fast fourier transform fft multiply degree polynomials lg time investigates efficient implementations fft including parallel circuit chapter presents numbertheoretic algorithms review elementary number theory presents euclids algorithm comp uting greatest common divisors algorithms solving modular linear equations ising number power modulo number presented application numbertheoretic algorithms rsa publickey cryptosystem cryptosystem encrypt messages adversary read provide digital signatures chapter presents errabin randomized primality test large primes efficientlyan ssential requirement rsa finally chapter covers pollards rho heuristic factoring integers discusses state art integer factorization chapter studies problem finding occurre nces pattern string text string problem arises frequently textediting programs examining naive approach chapter presents elegan approach rabin karp showing efficient solution based finite automata chapter presents knuthmorris pratt algorithm achieves efficiency cleverly preprocessing pattern computational geometry topic chapter discussing basic primitives computational geometry chapter sweeping method efficiently determine set segments contai intersections clever algorithms finding convex hull set pointsgrahams scan jarviss marchalso illustrate power sweeping methods chapter closes effi cient algorithm finding closest pair set points plane chapter concerns npcomplete problems teresting computati onal problems npcomplete polynomial time algorithm lving chapter presents techniques determining wh problem npcomplete classic problems proved npcomplete determ ining graph hamiltonian cycle determining boolean formula satisfiable determining ven set numbers subset adds target chapter proves famous travelingsalesman problem npcomplete chapter approximation algorithms approximate solutions npcomplete problems efficiently np complete problems approximate solutions optimal easy produ approximation algorithms work progressively problem size increases problems invest incr easing amounts comput ation time return increasingly approximate solutions chapter illustrates possibilities vertexcover problem unweighted weighted versions optimization version cnf satisfiability travelingsalesman probl setcovering problem subset sum problem chapter sorting networks overview examined sorting algorithms serial computers randomaccess machines rams operatio executed time chapter investigate sorting algorithms based comparisonne twork model computation comparison operations performed simultaneously comparison networks differ rams respects perform comparisons algo rithm counting sort implemented comparison network ram model operations occur seriallythat anotheroperati ons comparison network occur time parallel characteristic construction comparison networks sort values sublinear time defining comparison networks sorting networks natural definition running time comparison network terms depth network proves zeroone principle greatly eases task analyzing correctness sorting networks efficient sorting network desi gn essentially parallel version mergesort algorithm construction steps presents design bitonic sorter basic building block modify bitonic sorter produce merging network merge sorted sequences sorted sequence finally assemble merging networks sorting network sort values olg time comparison networks sorting networks comparison networks sort inputs sense discussion comparison networ ks characteristics comparison network composed solely wires comparators comparator figure device inputs outputs performs function figure comparator inputs outputs comparator drawn single vertical inputs outputs min max pictorial represen tation comparator figure bulky purposes adopt convention draw ing comparators singl vertical lines figure inputs left outputs smaller input appearing output larger input appearing output comp arator sorting inputs assume comparator operates o1 time assume time appearance input values production output values constant wire transmits place place wires connect output comparator input network input wires network output wires chapter assume comparison network input wires a2an values sorted enter network output wires b2bn produce computed network speak input sequence a2an output sequence b2bn referring values input output wires wire carries intention clear context figure comparison network set comparators interconnected wires draw comparison network inputs collection horizontal lines comparators stretched verti cally note represent single wire sequence distinct wires connecting comparators figure represents wires input wire connects input comparator wire connecting output comparator input comparator output wire output comparator comparator nput connected wire networks input wires a2an connected output comparator comparator output connect wire networks output wires b2bn connected input comparator main requirement interc onnecting comparators graph interconnections acyclic trace path output comparator input output input path trace cycle comp arator figure draw comparison network network inputs left network outputs data network left figure input output comparison network fact sorting network time input values input wires time values outputs comparators depth time values outputs comparators depth output wires b4 final values output wires time values outputs comparator depth output wires final values comparator produces output values input values figure suppose seque nce appears input wires time time comparators input values assuming comparator requir time unit compute output values comparators produce outputs time values figure note comparators produce values time parallel time comparators input values time unit time oduce outputs figure comparators operate parallel output comparator output comparator connect output wires b4 comparison network network output wires carry final values time time comparator inputs figure produces output values time values carried network output wires output sequence complete assumption comparator unit time define running time comparison network time takes output wires receive values input wires receive formally time largest number comparators input element pass thro ugh travels input wire output wire formally define depth wire input wire comparison network depth mparator input wires depths output wires depth max cycles comparators comparison network depth wire defined define depth comparator depth output wires figure comparator depths depth comparison network maximum depth output wire equivalently maximum depth comparator comparison network figure depth comparator depth comparator takes time unit produce output netw ork inputs time comparator depth produces outputs time depth network equals time network produce values output wires sorting network comparison network output sequence monotonically increasing input sequence comparison network sorting network network figure observe time minimum input values produced output comparator output comparator time output comparator symmetrical argument time maximum input values produced output comparator remains comparator ensure middl values occupy correct output positions time comparison network procedure specifies comparisons occur procedure sizethe number comparators containsdepends number inputs outputs describing families comparison networks goal chapter develop family sorter efficient sorting networks network family family number inputs equals number outputs ninput noutput sorting network family sorter named sorter exercises values wires network figure input sequence exercises exact power construct ninput noutput comparison network depth lg output wire carries minimum input output wire carri maximum input exercises sorti network add comparator comparison network sorting network add mparator network figure network sort input permutation exercises prove sorting network inputs depth lg exercises prove number comparat ors sorting network lg exercises comparison network figure prove fact sorting network structure insertion sort figure sorting network based insertion sort exercise exercises represent ninput comparison network comparators list pairs integers range pairs integer common order comparators network determined der pairs list representation ctime serial algorithm determining depth comparison network exercises suppose addition standard kind comparator introduce upsidedown comparator produces minimum output wire maximum output wire convert sorting network total standard upsidedown comparators standard prove conversion method correct zeroone principle zeroone principle sorting network works correctly input drawn set works corr ectly arbitrary input numbers numbers integers reals general set values linea rly ordered set construct sorting networks comparis networks zeroone principle focus operation input sequences consisting solely constructed sorting network proved sort zeroone sequences appeal zeroone principle properly sorts sequences arbitrary values proof zeroone principle relies notion monotonically increasing function lemma comparison network transforms input sequence a2an output sequence b2bn monotonically increasing function network transforms input sequence fa1 fa2fan output sequence fb fb1 fb2fbn proof prove claim monotonically increasing function single comparator inputs fx produces outputs fmin fmax induction prove lemma prove claim mparator input values upper output comparator min lower output max suppose apply fx inputs comp arator figure operation comparator yields min fx upper output max fx lower output monotonically increasing implies fx identities min fx fmax max fx fmin figure operation comparator proof lemma function monotonically increasing comparator produces values fmin fmaxx fx inputs completes proof claim induction depth wire general comparison network prove stronger result statement lemma wire assumes ai input sequence applied network assumes fai input sequence applied output wires incl uded statement proving prove lemma basis wire depth input wire ai result trivially applied network input wire carries fai inductive step wire depth wire output comparator depth input wires comparator depth strictly inductive hypothesis input wires comparator carry values ai input sequence applied carry fai faj input sequence applied earlier claim output wires comparator carry fmin ai fmax ai carry min ai max ai input sequence lemma proved application lemma figure sorting network figure repeated figure monotonically increasing function fx applied inputs wire applied wire figure figure sorting network figure input sequence sorting network monotonically increasing function fx fx2 applied inputs wire network applied wire comparison network sorting network lemma prove remarkable result theorem zeroone principle comparison network inputs sorts sequences correctly sorts sequences arbitrary numbers correctly proof suppose purpose contradiction network sorts zeroone sequences exists sequence arbitrary numbers network correctly sort exists input sequence a2an elements ai ai network places ai output sequence define monotonically increasing function network places ai output sequence a2an input lemma places faj fai output sequence fa1 fa2fan input faj fai contradiction network fails sort zeroone sequence fa1 fa2fan correctly exercises prove applying monotonically increasi function sorted sequence produces sorted sequence exercises prove comparison network inputs correctly sorts input sequence correctly sorts zeroone sequencesexercises zeroone principle prove comparison network figure sorting network figure sorting network sorting numbers exercises state prove analog zeroone principle decisiontree model hint handle equality properly exercises prove ninput sorting network comparator ith lines bitonic sorting network step construction efficient sorting network construct comparison network sort bitonic sequence sequence monotonically increases monotonically decreases circularly shifted monotonically increasing monotonically decreasing sequences bitonic boundary condition sequence numbers itonic zeroone sequences bitonic simple structure form form note sequence monotonically increasing monotonically decreasing bitonic bitonic sorter construct comparison network sorts bitonic sequences exercise asks bitonic sorter sort bitonic sequences arbitrary numbers halfcleaner bitonic sorter composed seve ral stages called halfcleaner halfcleaner comparison networ depth input compared assume figure halfcleaner8 halfcleaner inputs outputs figure comparison network halfcle aner8 sample zeroone input output values input assumed itonic halfcleaner ensures output element half small output element half halves bit onic half clean bitonic sequence applie input halfcleaner halfcleaner produces output sequence smaller values half larger values half halves bitonic fact halves clean consisting sand property derive half cleaner note clean sequences bito nic lemma proves properties halfcleaners lemma input halfcleaner bitonic sequence output satisfies properties half half bitonic element half small element half half clean proof comparison network halfcleaner compares inputs loss generality suppose input form situation input form symmetric cases dependi block consecutive midpoint falls cases midpoint occurs block split cases cases figure case lemma holds figure comparisons halfcleaner input sequence assumed bitonic sequence loss generality assume form subsequences white subsequences gray inputs divided halves inputs compared cases division occurs middle subsequence cases division ccurs subsequence cases element half output small element half halves bitonic half clean bitonic sorter recursively combining halfcleaners figure build bitonic sorter network sorts bitonic sequences stage bitonic sorter consists halfcleanern lemma produces bitonic sequences half size elemen half small element half comple sort copies bitonic sorter sort halves recursively figure recursion explicitly figure recursion unrolled progressively smaller halfcleaners remainder bitonic sorter depth dn bitonicsorter recurrence solution dn lg figure comparison network bitonicsorter recursive construction halfcleaner copies bitonicsorter operate parallel network unrolling recursion halfcleaner shaded sample values wires zeroone bitonic sequence sorted bitonicsorter depth lg analog zeroone principle exercise bitonic sequence arbitrary numbers sorted network exercises zeroone bitoni sequences length exercises bitonicsortern exact power lg comparators exercises olg ndepth bitonic sorter constructed number inputs exact power exercises input halfcleaner bitonic sequence arbitrary numbers prove output satisfies properties half half bitonic element half small element half exercises sequences prove element sequence small element sequen sequences clean exercises prove analog zeroone principle bitonic sorting networks comparison network sort bitonic sequence sort bitonic sequence arbitrary numbers merging network sorting network constructed merging networks networks merge sorted input sequences sorted output sequence modify bitonic sorter create merging network merger bitonic sorter prove correctness merging network inputs zeroone sequences exercise asks proof extended arbitrary input values merging network based tuition sorted sequences reverse order sequence concatenate sequences sequence bitonic exampl sorted zeroone sequences reverse concatenating yields bitonic merge input sequences suffices perform bitonic sort concatenated construct mergern modifying halfcleaner bitonic sortern key perform reversal ond half inputs imp licitly sorted sequences a2an2 an21 an22 merged bitonically sorting sequence an2 an1 an21 halfcleaner bitonicsorter compares inputs stage merging network compare inputs figure correspondence subtlety order outputs stage mergern reversed compared orde outputs ordinary halfcleaner reversal bitonic seque nce bitonic outputs stage merg ing network satisfy properties lemma tonically sorted parallel produce sorted output merging network figure comparing stage merger halfcleaner stage mergern transforms monotonic input sequences a2an2 an21 an22an bitonic sequences b2bn2 bn21 bn22bn equivalent operation halfcleanern bitonic input sequence a2an21 an2 an1an22 an21 transformed bitonic sequences b2bn2 bn1bn21 merging network figure stage mergern bitonicsorter depth merger lg bitonicsorter figure network merges sorted input sequences sorted output sequence network merger viewed bitonicsortern halfcleaner altered compare inputs network decomposed stage parallel copies bitonicsorter network recursi unrolled sample zer oone values wires stages shaded exercises prove analog zeroone principle merging networks comparison network merge notonically increasing sequences merge monotonically increa sing sequences arbitrary numbers exercises zeroone inpu sequences applied input comparison network verify merging network exercises network merge item sorted items produce sorted sequence length depth lg exercises merging network inputs exact power monotonic sequences merged an1 prove number comparators kind merging network lg interesting lower bound hint partition comparators sets exercises prove merging network regardle order inputs requires lg comparators sorting network tools construct network sort input sequence sorting network sortern merging network implement parallel version merge sort construction operation sorting network illustrated figure figure sorting network sortern constructed recursively combining merging networks recursive construction unrolling recursion replacing merger boxes actual merging tworks depth comparator sample zeroone valu wires figure recursive onstruction sortern input elements sorted copies sortern2 recursively sort parallel subsequences length sequences merged merger boundary case recursion case wire sort element sequence elem ent sequence sorted figure result unrolling recursion figure actual network replacing merger boxes figure actual merging networks data pass lg stages network sortern individual inputs network sorted element sequence stage sortern consists copies merger2 work parallel merge pairs element sequences produce sorted sequences length stage consists n4 copies merger4 merge pairs element sorted sequences produce sorted sequences length general lg stage consists n2k copies merger2 merge pairs k1element sorted sequences oduce sorted sequences length final stage sorted sequence consisting input values produced sorting network induction sort zeroone sequences zeroone principle theorem sort arbitrary values analyze depth rting network recursively depth dn sortern depth dn2 sortern2 copies sortern2 operate parallel depth lg mergern depth sorter recurrence solution dn lg2 version master method exercise sort numbers parallel olg2 time exercises comparators sorter exercises depth sortern lg nlg exercises suppose elements a2n partition smallest largest prove constant additional depth separately sorting an1 an2 a2n exercises sk depth sorting network inputs mk depth merging network inputs suppose sequence numbers sorted number positions correct position sorted order sort numbers depth sk mk exercises sort entries matrix repeating procedure times sort oddnumbered row monotonically increasing order sort evennumbered row monotonically decreasing order sort column monotonically increasing order iterations required procedure sort order read matrix entries iterations sorted output problems transpositi sorting networks comparison network transposition network comparator connects adjacent lines network figure transposition sorting network inputs comparators prove transposition network inputs sorting network sorts sequence hint induction argument analogous proof lemma oddeven sorting network inputs a1a2an transposition sorting network levels comparators connected bricklike pattern illustrated figure figure connected depthd comparator figure oddeven sorting network inputs prove oddeven sorting networks sort problems batchers oddeven merging network construct merging netw ork based bitonic sorting problem construct oddeven merging network assume exact power merge sorted sequence elements lines lines an1 an2 a2n comparator lines recursively construct oddeven merging networ ks operate parallel merges sequence lines an1 sequence lines an1 an3 a2n1 odd elements merges an2 an4 a2n elements combine sorted subsequences comparator a2i a2i draw ninput merging network professor corrigan suggests combine sorted subsequences produced recursive merging putting comparator a2i a2i1comparator a2i1 a2i draw ninput network counterexample professor mistaken thinking network produced merging network ninput merging network pa works properly zeroone principle prove ninput oddeven merging network merging network depth ninput oddeven merging netw ork size problems permutation networks permutation network inputs outputs switches connect inputs outputs permutations figure input output permutation network consists single switch set feed inputs straight rough outputs cross figure permutation networks permutation network consists single switch set ways recursive construction p8 switches p4s switches p4s set realize permutation argue replace comparator sorting network switch figure network permutation network permutation set switche network input connected output figure recursive construction input output permutation network p8 copies p4 switches switches set realize permutationrequires recursively p4 realize p4 realize realize permutation p8 drawing switch settings permut ations performed p4s exact power define recursively terms pn2s manner defined p8 ontime ordinary randomaccess mach ine algorithm sets switches connected inputs outputs specifies permutations realized pn2 order accomplish nelement permutation prove algorithm correct depth size long ordinary random access machine compute switch settings including pn2s argue permutation networknot pnmust realize permutation distinct comb inations switch settings chapter notes knuth discussion sorting networks charts history explored armstrong nelson oconnor early batcher discovere network capable merging sequences numbers olg time oddeven merging problem technique sort numbers olg2 time shortly afterward discovered olg ndepth bitonic sorter simila presented knuth attributes zeroone principle ouricius proved context decision trees long time question remained open sorting network depth olg exists answer unsatisfying aks sorting network named developers ajtai komlós szemerédi sort numbers depth olg lg comparators unfortunatel constants hidden onotation large thousands considered practical chapter matrix operations overview operations matrices heart scientific computing efficient algorithms working matrices practical chapter introduction matrix theory trix operations emphasizing problems multiplying matrices solving sets simultaneous linear equations introduces basic matrix concepts notations presents strassens surprising algorithm multiplying matrices nlg on281 time solve set linear equations lup decompositions explores close relationship problem multiplying matrices problem inverting matrix finally discusses class symmetric positivedefinite matrices leastsquares solution overdetermine set linear equations issue arises practice numerical stability limited precision floatingpoint representations actual computers roundoff errors numerical computations amplified ourse computation leading incorrect computations numerically unstable numerical stability occasion focus chapter refer reader excellent book golub van loan discussion stability issues properties matrices review basic concep matrix theory fundamental properties matrices focusing needed sections matrices vectors matrix rectangular array numbersmatrix aij element matrix row column aij uppercase letters denote matrices subscripted lowercase letters denote elements set matrices realvalued entries denoted rmn general set matrices entries drawn set denoted smn transpose matrix matrix exchanging rows columns matrix equation vector onedimensional array numbers vector size lowercase tters denote vectors denote ith element sizen vector standard form vector column vector equivalent matrix row vector transposeunit vector vector ith element elements size unit vector clear context matrix matrix entry su matrix denoted ambiguity number matrix easily resolved context matrix intended size matrix derived context square matrices frequently speci cases square matrices diagonal matrix aij offdiagonal elements matrix listing elements diagonal identity matrix diagonal matrix ith diagonal appears subscript size derived context ith column identity matrix unit vector tridiagonal matrix tij nonzero entries main diagonal main diagonal tii1main diagonal ti1 uppertriangular matrix uij entries diagonal uppertriangular matrix unit uppertriangular diagonal lowertriangular matrix lij entries diagonal lowertriangular matrix unit lowertriangular diagonal permutation matrix row column permutation matrix matrix called permutation matrix multiplying vector permutation matrix permuting rearranging elements symmetric matrix satisfies condition symmetric matrix operations matrices elements matrix vector numbers number real numbers complex numbers integers modulo prime number defines add multiply numbers extend definitions encompass addition multiplication matrices define matrix addition aij bij matrices matrix sum cij matrix defined cij aij bij matrix addition performed componentwise matrix identity matrix addition number aij matrix aij scalar multiple multiplying elements special case define negative matrix aij ijth entry aij definition define matrix subtraction addition negative matrix define matrix multiplication start matrices compatible sense number columns equals number rows general expression matrix product assumed imply matrices compatible aij matrix bjk matrix matrix product matrix cik procedure matrixmultiply implements matrix multiplication straightforward manner based equation assuming matrices square multiply matrices matrix multiply performs n3 multiplications n2n additions running time n3 matrices alge braic properties typical numbers identity matrices identities matrix multiplication matrix multiplying matrix matrix matrix multiplication associative compatible matrices matrix multiplication distributes addition multiplication matrices commutative matrixvector products vectorvector products defined vector equivalent matrix matrix case row vector matrix vector size vector size vectors size number matrix called product matrix xyt matrix called outer product zij euclidean norm vector size defined xtx12 norm length ndimensional euclidean space matrix inverses ranks determinants define inverse matrix matrix denoted exists aa1 nonzero matrices inverses trix inverse called noninvertible singular nonzero singular matrix matrix inverse called invertible nonsingular matrix inverses exist unique exercise nonsingular matrices inverse operation commutes transpose operation a1t at1 vectors linearly dependent exist coefficients c1x1 c2x2 row vectors linearly dependent vectors linearly dependent linearly independent columns identity matrix linearly independent column rank nonzero matrix size largest set linearly independent columns row rank size largest set linearly independent rows fundamental prope rty matrix row rank equals column rank simply refer rank rank matrix integer min inclusive rank matrix rank identity matrix alternate equivalent definition rank nonzero matrix smallest number exist matrices respective sizes square matrix rank rank matrix column rank rank fundamental property ranks theorem theorem square matrix rank nonsingular null vector matrix nonzero vector theorem proof left exercise corollary relate notions column rank singularity null vectors theorem matrix column rank null vector corollary square matrix singular null vector ijth minor matrix n1 n1 matrix aij deleting ith row jth column determinant matrix defined recursively terms minors term detaij cofactor element aij theorems proofs express fundamental properties determinant theorem determinant properties determinant square matrix properties row column deta determinant multiplied entries row column multiplied determinant unchanged entries row column row column determinant equals determinant determinant multiplied rows columns exchanged square matrices detab det det theorem matrix singular deta positivedefinite matrices positivedefinite matrices play portant role applications matrix positivedefinite size vectors identity matrix positivedefinite nonzero vector xnt matrices app lications positivedefinite theorem theorem matrix column rank matrix positivedefinite proof xtatax nonzero vector vector xtatax axtax exercise ax2 note ax2 sum squares elements vector ax2 ax2 element column rank implies theorem positivedefinite properties positivedefinite matrices explored exercises symmetric matrices exercises prove abt symmetric matrix exercises prove matrix inverses unique inverses exercises prove product lowertriangular matrices lowe rtriangular prove determinant lowertriangular uppertriangular matrix equal product diagonal elements prove inverse lowertriangular matrix exists lower triangular exercises prove permutation matrix matrix permuting rows permuting columns prove product permuta tion matrices permutation matrix prove permutation matrix invertible inverse permutation matrix exercises matrices prove adding row row inverse subtracting column column exercises nonsingular matrix complex entries entry real entry real exercises nonsingular symmetric matrix symmetric arbitrary matrix matrix product abt symmetric exercises prove theorem matrix column rank implies hint express linear dependence column matrix vector equation exercises prove compatible matrices rankab minrank rankb equality holds nonsingular square matrix hint alternate definition rank matrix exercises numbers x0 xn1 prove determinant vandermonde matrix hint multiply column x0 add column induction strassens algorithm matrix multiplication presents strassens remarkable recursive algorithm multiplying matrices runs nlg on281 time large values outperforms naive n3 matrixmultiplication algor ithm matrixmultiply overview algorithm strassens algorithm viewed appli cation familiar sign technique divide conquer suppose compute product matrices assuming exact power divide matrices rewriting equation exercise deals situation exact power equation corresponds equations equations specifies multiplications matrices addition products equations define straightforward divide conquer strategy derive recurrence time multiply matrices recurrence solution n3 method faster ordinary strassen discovered recursive approach requires recursive multiplications matrices scalar additions subtractions yielding recurrence strassens method steps divide input matrices submatrices equation scalar additions subtractions compute matrices a7 b7 recursively compute matrix products ai compute desired submatrices result matrix adding andor subtracting combinations matrices scalar additions subtractions procedure satisfies recurrence missing details determining submatrix products clear strassen discovered submatrix products key making algorithm work rec onstruct plausible discovery method guess matrix product written form coefficients drawn setguess product computed adding subtra cting submatrices adding subtracting submatrices multiplying general strategies simple turns work form products manner method recursively assuming commutativity multiplicati product submatrices left submatrices prope rty essential recursive application method matr multiplication commutative convenience matrices represent linear combinations products submatrices product combines submatrix submatrix equation rewrite equation expression abbr eviated notation represents represents represents omit row column labels notation equations submatrices result matrix search faster matrixmultiplication algorithm observing submatrix computed computed matrix multiplication matrix computed manner p4 define essential term terms appearing righthand equations œ2812 ha products compute submatrices essential terms bh dg note computes essential term computes essential term bh computes essential term p4 computes essential term dg remains compute remaining submatrices essential terms bg dh additional products innovation p5 order compute essential terms p5 a5b5 dh addition computing essential terms dh p5 computes inessential terms canceled p4 cancel inessential terms adding additional product manner p5 inessential terms p5 direction subtracting additional product submatrix products p7 compute product completes descrip tion strassens method discussion practical point view strassens algorithm method choice matrix multiplication reasons constant factor hidden running time strassens algorithm larger constant factor naive n3 method matrices sparse methods ta ilored sparse matrices faster strassens algorithm nu merically stable naive method submatrices formed vels recursion consume space reasons mitigated higham demonstrated difference numerical stability overemphasized strassens algorithm numerically unstable applications acceptable limits bailey discuss techniques reducing memory requirements strassens algorithm practice fast matrixmultiplication implem entations dense matrices strassens algorithm matrix sizes crossover point switch naive method subproblem size reduces crossover point exact crossover point highly dependent anal yses count operations ignore effects caches pipelining produced crossover points low higham husslederman empirical measurements typically yield higher crossover points low straightforward determine crossover point experimentation advanced techniques scope text fact multiply matrices nlg time current upper bound on2376 lower bound obvious bound obvious elements product matrix hard matrix multiplication exercises strassens algorithm compute matrix product work exercises modify strassens algorithm multiply matrices exact power algorithm runs time nlg exercises largest multiply matrices multiplications assuming commutativity multiplic ation multiply matrices time onlg running tim algorithm exercises pan discovered multiplying matrices multiplications multiplying matrices multiplications multiplying matrices multiplications method yields asymptotic running time divide conquer matrixmultiplication algorithm compare strassens algorithm exercises multiply kn matrix kn matrix strassens algorithm subroutine answer question order input matrices reversed exercises multiply complex numbers real multiplications algorithm input produce real component imaginary component separately solving systems linear equations solving set simultaneous linear equations fundamental oblem occurs diverse applications linear expressed matrix equation matrix vector element belongs field typically real numbers discusses solve linear equations method called lup decomposition start set linear equations unknowns set values satisfy equations simultaneously solution equations treat case equations unknowns conveniently rewrite equations matrixvector equation equivalently letting aij nonsingular possesses inverse solution vector prove unique solution equation solutions a1ax a1ax a1ax a1ax concerned case nonsingular equivalently theorem rank equal number unknowns possibilities merit discussion number equations number unknownsšor gene rally rank nšthen underdetermined underdetermined stem typically infinitely solutions solutions equations inconsistent number equations exceeds number unknowns overdetermined exist solutions finding good approximate solutions overdetermined systems linear equations problem addressed return problem solving equations unknowns approach compute multiply sides yielding a1b a1b approach suffers practice numerical instability fortunately approachšlup decompositionšthat numerically stable advantage faster practice overview lup decomposition idea lup decomposition matrices unit lowertriangular matrix uppertriangular matrix permutation matrix matrices satisfying equation lup decomposition matrix nonsingular matrix possesses decomposition advantage computing lup decomposition matrix linear systems solved triangular case matrices lup decomposition solve equation solving triangular linear systems multiplying sides yields equivalent equation pb exercise amounts permuting equations decomposition lu pb solve equation solving triangular linear systems define desired solution vector solve lowertriangular unknown vector method called forward substitution solved solve uppertriangular unknown method called substitution vector solution permutation matrix invertible exercise p1lu p1ly p1pb step forward substitution work attack problem computing lup decomposition forward substitution forward substitution solve lowertriangular time convenience represent permutation compactly arrayentry pij ai row column pb ith element unit lowertriangular equation rewritten y1 l21y1 l31y1 l32y2 y3 ln1y1 ln2y2 ln3y3 yn bnwe solve y1 directly equation tells y1 solved y1 substitute equation yielding l21y1 substitute y1 equation obtaining y3 l31y1 l32y2 general substitute y1 yi1 forward ith equation solve yi substitution forward substitution solve nth equation work backward equation forward substitution process runs time uppertriangular rewrite u11x1 u12x2 u1 n2xn2 u1 n1xn1 u1nxny1 u22x2 u2 n2xn2 u2 n1xn1 u2nxny2 un2 n2xn2 un2 n1xn1 un2 nxnyn2un1 n1xn1 un1 nxnyn1unn xnyn solve xn1 successively ynunn xn1 yn1 un1 nxnun1 n1 xn2 yn2 un2 n1xn1 un2 nxnun2 general procedure lupsolve solves combining forward substitution pseudocode assumes dimension appears attribute rowsl permutation matrix represented array lupsolvel rowsl downtoreturn procedure lupsolve solves forward substitution lines œ3 solves backward substitution lines œ5 implicit loop summations loops running time methods linear equations defined solve unknown lup decomposition reader verify lu forward substitution solve ly pb obtaining computing y1 finally y3 substitution solve obtaining desired answer computing finally computing lu decomposition lup decompos ition computed nonsingular matrix forward substitution solve linear equations remains lup decomposition efficiently start case nonsingular matrix absent equivalently case factorization lu matrices lu decomposition process perform lu decomposition called gaussian elimination start subtracting multiples equation equations variable removed equations subtract multiples equation subsequent equations variables removed continue proce left upper triangular formšin fact matrix matrix row multipliers variables eliminated algorithm implement strategy recursive construct lu decomposition nonsingular matrix choose i1 break parts size column vector wt size row vector matrix matrix algebra ver ify equations simply multiplying factor matrices factorization row column vectors size term vwta11 formed outer product dividing element result a11 matrix conforms size matrix subtracted matrix called schur complement respect a11 claim nonsingular schur complement nonsingular suppose schur complement singular theorem row rank strictly entries column matrix rows matrix row rank strictly row rank entire matrix strictly applying exercise equation rank strictly theorem derive contradiction singular schur complement nonsingular recursively lu decomposition vwta11 lu unit lowertriangular uppertriangular matrix algebra providing lu deco mposition note unit lowertriangular uppertriangular a11 method doesnt work divides doesnt work upper leftmost entry schur complement vwta11 divide step recursion elements divide lu decomposition called pivots occupy diagonal elements matrix reason include permutation matrix lup decomposition llows avoid dividing elements permutations avoid divi sion small numbers called pivoting class matrices lu decomposition works correctly class symmetric positivedefi nite matrices matrices require pivoting recursive strategy outlined employ fear dividing prove result code lu decomposition matrix recursive strategy iteration loop replaces recursion transformation standard optimization tailrecursive procedurešone operation recursive assumes dimension attribute rows output matrix diagonal lupso lve entries code bother likewise output matrix diagonal diagonal entries filled code computes entries ludecompositiona rowsaukk akklik aikukk lik holds vi uki aki uki holds aij aij likukj return outer loop iterates recursive step loop pivot determined ukk akk loop lines œ6 execute wt vectors update elements vector determined vi stored lik elements wt vector determined stored uki finally elements schur complement computed lines œ9 stored matrix dont divide akk computed lik triply nested ludecomposition runs time n3 figure illustrates operation ludec omposition standard optimization procedure elements stored place matrix set correspondence element aij lij uij update matrix holds procedure terminates pseudocode optimization pseudocode replacing reference difficult verify transformation preserves correctness figure operation ludecomposition matrix element a11 black circle pivot shaded column va11 shaded row wt elements computed rizontal elements left vertical schur complement matrix vwta11 occupies lower operate schur complement matrix produced element a22 black circle pivot shaded column row va22 wt partitioning schur complement respectivel lines divide matrix elements computed elements computed left schur complement lower step completes fact orization element schur complement recursion terminates factorization lu computing lup decomposition generally solving linear equations pivot offdiagonal elements avoid dividing division undesirable division small nonsingular numerical instabilities result computation pivot large mathematics lup decomposition milar lu decomposition recall nonsingular matrix permutation matrix unit lowertriangular matrix uppertriangular matrix lu partition matrix lu decomposition nonzero element ak1 column position matrix column singular determinant theorems order preserve set equations exchange row row equivalent multiplying permutation matrix left exercise write a21 a31 an1t a11 replaces ak1 wt ak2 ak3 akn matrix ak1 perform linear algebra lu decomposition guaranteeing divide lu decomposition nonsingular schur complement vwtak1 nonsingular inductive ly lup decomposition unit lowertriangular matrix uppertriangular matrix permutation matrix pa vwtak1 lu define permutation matrix product permutation matrices exercise yielding lup decomposition unit lowertriangular uppertriangular notice derivation lu decomposition column vector vak1 schur complement vwtak1 multiplied permutation matrix ludecomposition pseudocode lup decomposition replaces recursion iteration loop improvement direct implementation recursion dynamically maintain permutation matrix array ith row column implement code compute place matrix procedure terminates lupdecompositiona rowsa aik aik error singular matrix exchangeexchange aki akiaik aikakkaij aij aikakj figure illustrates lupdecompositi factors matrix array initialized lines œ3 represent identity permutation outer loop implements recursion time rough outer loop lines œ9 determine element akk largest absolute current column column matrix lu decomposition elements current column lines œ11 report matrix singular pivot exchange exchange kth kth rows lines œ14 making pivot element akk entire rows swapped derivation method vwtak1 multiplied vak1 finally schur complement computed lines œ18 computed lines œ9 ludecomposition operation written work place figure operation lupdecomposition input matrix identity permutation rows left step algorithm determines element black circle thir row pivot column rows swapped permutation updated shaded column row represent wt vector replaced v5 lower matrix updated schur complement lines divide matr regions elements elements left elements hur complement lower œf step gœi step occur fourth final step lup decomposition pa lu triply nested loop structur lupdecomposition running time n3 ludecomposition pivoting costs constant factor time exercises solve equation forward substitution exercises lu decomposition matrix exercises solve equation lup decomposition exercises lup decomposition diagonal matrix exercises lup decomposition permutation matrix prove unique exercises exists singular matrix lu decomposition exercises ludecomposition perform outermost loop iteration lupdecomposition inverting matrices practice generally trix inverses solve systems linear equations preferring numerically stable techniques lup decomposition comput matrix inverse lup decomposition pute matrix inverse prove matrix multiplication computing inverse matrix equivalently hard problems subject technical conditions algorithm solve asymptotic running time strassens algorithm matrix multiplication invert matrix stra ssens original paper motivated problem showing set linear equa tions solved usual method computing matrix inverse lup decomposition suppose lup decomposition matrix form matrices pa lu lupsolve solve equation form time lup decomposition depends lupsolve set equations form additional time general lup decomposition solve time kn2 versions equation differ equation viewed set distinct equations form equations define matrix inverse precise denote ith column recall unit vector ith column equation solved lup decomposition solve equation axi separately columns time computation lup decomposition takes time n3 lup decomposition computed time n3 inverse matrix determined time n3 matrix multiplication matrix inversion theoretical speedups obt ained matrix multiplication translate speedups matrix inversion fact ove stronger matrix inversion equivalent matrix multiplicat ion sense denotes time multiply matrices invert matrix time denotes time invert nonsingular matrix multiply matrices time prove separate theorems theorem multiplication harder inversion invert matrix time satisfies regularity condition multiply matrices time proof matrices matrix product compute define matrix inverse compute product upper submatrix d1 construct matrix time invert time regularity condition note satisfies regularity condition lgd constants proof matrix inversion harder matrix multiplication relies properties symmetric positivedefinite matrices proved theorem inversion ha rder multiplication suppose multiply real matrices time satisfies regularity conditions omn range mn2 cmn constant compute inverse real nonsingular matrix time omn proof assume exact power choosing power enlarge matrix size power desired answer answer enlarged problem rst regularity condition ensures enlargement running time increase constant factor moment assume matrix symmetric positivedefinite partition submatrices schur complement respect form schur complement aa1 verified performing matrix multiplication matrices s1 exist symmetric positivedefinite lemmas symmetric positivedefinite exercise b1ct b1t b1cts1 s1c b1t equations recursive algorithm involving multiplications matrices s1 b1t s1c invert symmetric positivedefinite matrix inverting matrices performing multiplications matrices algorithm matrices additional cost on2 extracting submatrices performing constant number additions subtractions matrices recurrence in2 on2 in2 omn holds regularity condition statemen theorem apply case master theorem theorem remains prove asymptotic runni time matrix multiplication matrix inversion invertible symmetric positivedefinite basic idea nonsingular matrix matrix symmetric exercise positivedefinite theorem trick duce problem inverting problem inverting reduction based observation nonsingular matrix ata a1at matrix inverse unique compute multiplying inverting symmetric positivedefinite matrix divide conquer algorithm finally multiplying result steps takes omn time nonsingular matrix real entries inverted omn time proof theorem suggests solving equation lu decomposition pivoting long nonsingular multiply sides equation yielding atb transformation doesnt affect solution invertible factor symmetric positivedefinite matrix computing lu decomposition forward substitution solve righthand atb method theoretical ly correct practice procedure lupdecomposition works lup decomposition requires fewer arithmetic operations consta factor numerical properties exercises time multiply matrices denote time required square matrix multiplying squaring matrices essentially difficulty mntime matrixmultiplication algorithm implies omntime squaring algorithm sntime squaring algorithm implies osntime matrix multiplication algorithm exercises time multiply matrices time compute lup decomposition matrix multiplying matrices computing lup decompositions matrices sentially difficulty mntime matrix multiplication algorithm implies omntime lupdecomposition algorithm lntime lupdecomposition algorithm implies olntime matrixmultiplication algorithm exercises time multiply matrices dn denote time required determinant matrix multiplying matrices computing determinant essentially difficulty mntime matrixmultiplication algorithm implies omntime determinant algorithm dntime determinant algorithm implies odntime matrixmultiplication algorithm exercises time multiply boolean matrices time transitive closure boolean matrices mntime boolean matrixmultiplication algorithm implies omn lg ntime transitiveclosure algorithm ntime transitiveclosure algorithm implies ntime boolean matrixmultiplication algorithm exercises matrixinvers ion algorithm based theorem work matrix elements drawn field integers modulo explain exercises generalize matrixinversion algorithm theorem handle matrices complex numbers prove neralization works correctly hint transpose conjugate transpose transpose replacing entry complex conjugate symmetric matrices hermitian matrices matrices symmetric positivedefinite matrices leastsquares approximation symmetric positivedefinite matrices interesting desirable properties nonsingular lu decompos ition performed worry dividing ction prove properties symmetric positivedefinite matrices interesting application curve fitting leastsquares approximation property prove basic lemma positivedefinite matrix nonsingular proof suppose matrix singular corollary exists nonzero vector positivedefinite proof perform lu decompos ition symmetric positivedefinite matrix dividing involved proving properties submatrices define kth leading submatrix matrix ak consisting intersection rows columns lemma symmetric positivedefinite matr leading submatrix symmetric positivedefinite proof leading submatrix ak symmetric obvious prove ak positive definite assume derive contradiction ak positivedefinite exists size vector letting define sizen vector contradicts positivedefinite turn essential prop erties schur complement symmetric positivedefinite matrix ak leading submatrix partition generalize definition define schur complement respect ak lemma ak symmetric positivedefinite exists lemma defined note earlier definition schur complement consistent definition letting lemma schurcomplemen matrices symmetric positivedefinite matrices symmetric positivedefinite result theorem corollary needed prove correctness lu decomposition symmetric positivedefinite matrices lemma schur complement lemma symmetric positivedefinite matrix ak leading submatrix schur complement respect ak symmetric positivedefinite proof symmetric submatrix exercise product symmetric exercise symmetric remains positivedefinite onsider partition equation nonzero vector assumption positivedefinite break subvectors compatible ak exists matrix magic verify multiplying equation amounts completing square quadratic form exercise holds nonzero pick nonzero choose term equation vanish leaving expression ztsz xtax positivedefinite corollary lu decomposition symmetric positivedefi nite matrix division proof symmetric positivedefinite matrix prove stronger statement corollary pivot strictly positive pivot a11 e1 unit vector step lu decomposition produces schur complement respect a11 lemma implies pivots positive induction leastsquares approximation fitting curves sets data points application symmetric positive definite matrices suppose set data points y1 xm ym yi subject measuremen errors determine function fxapproximation errors small form function depends problem hand assume form linearly weighted sum number summands specific basis functions chosen based knowledge problem hand common choice fjx xj1 c2x c3x2 cnxn1 polynomial degree choosing calculate yi equation highdegree fits noise data generally poor predict unseen values choose smaller hope choosing coefficients function finds patterns data points paying undue attention noise theoretical prin ciples exist choosing scope text case chosen ove rdetermined set equations solution approximate denote matrix values basis functions points aij fjxi ck denote desired sizen vector coefficients size vector predicted values size vector approximation errors minimize approximation errors choose minimize norm error vector leastsquares solution minimize differentiating respect ck setting result equationsequivalent single matrix equation equivalently exercise atac implies statistics called normal equation matrix symmetric exercise column rank theorem positivedefinite exists solution equation matrix called pseudoinverse matrix pseudoinverse natural generalization notion matrix inverse case nonsquare compare equation approximate solution solution a1b exact solution producing leastsquares fit suppose data points y1 y3 x4 y4 x5 y5 black dots figure fit points quadratic polynomial figure leastsquares fit quadratic polynomial data points black dots data points white dots estimated values pred icted polynomial fx quadratic polynomial minimizes sum square errors error data point shaded c2x c3x2 start matrix basisfunction values pseudoinverse multiplying coefficient vector corresponds quadratic polynomial fx closestfitting quadratic data leastsquares sense practical matter solve normal equation multiplying finding lu decomposition rank matrix guaranteed nonsingular symmetr positivedefinite exercise theorem exercises prove diagonal element symm etric positivedefinite matrix positive exercisessymmetric positivedefinite matrix prove determinant positive completing square nner proof lemma exercises prove maximum element symmetric positivedefinite matrix lies diagonal exercises prove determinant leading subm atrix symmetric positivedefinite matrix positive exercises ak denote kth leading submatrix symm etric positivedefinite matrix prove det ak detak1 kth pivot lu decomposition convention deta0 exercises function form c2x lg c3ex leastsquares fit data points exercises pseudoinverse satisfies follo wing equations aa aa aat aa aa problems tridiagonal stems linear equations tridiagonal matrix lu decomposition solve equation forward substitution inverse symmetric positivedefinite tridiagonal matrix nvector equation solved time performing lu decomposition argue method based forming asymptotically expensive worst case nonsingular tridiagonal matrix nvector equation solved time performing lup decomposition problems splines practical method interpolating points curve cubic splines set yipointvalue pairs x0 fit piecewisecubic curve spline fx points curve fx cubic polynomials ai bix cix2 dix3falls range xi1 curve fx points cubic polynomials pasted called knots simplicity assume ensure continuity fx require fxi fi0 yi fxi1 fi1 yi1ensure fx smooth insist continuity derivative knotsuppose pointvalue pairs yi derivatives fxi knot express coefficient ai terms values yi yi1 di1 remember coefficients computed pointvalue pairs derivatives question remains choose derivatives fx knots method require derivatives continuous knotsknots assume assumptions fx natural cubic spline continuity constraints derivative rewrite equations trix equation involving vector d0 d1 dn unknowns attributes matrix equation argue set pointvalue pairs interpolated natural cubic spline time problem determine natural cubic spline interpolates set points yi satisfying x0 equal matrix equation solved algorithm chapter notes excellent texts desc ribe numerical scientific computation greater room readable george liu golub van loan press flannery teukolsky vetterling strang golub van loan discuss numerical stabil ity deta good indicator stability matrix proposing address question compute computing publication strassens algorithm caused excitement hard imagine naive algorithm improved asymptotic upper bound difficulty matrix multiplication considerably improved asymptotically efficient algorithm multiplying matrices coppersmith winograd running time on2376 graphical presentation strassens algorithm paterson gaussian elimination lu lup decompositions based systematic method solving linear systems equations earliest numerical algorithms earlier discovery commonly attributed gauss œ1855 famous paper strassen matrix inverted onlg time winograd originally proved matrix multiplication harder matrix inversion converse aho hopcroft ullman matrix decomposition singular decomposition svd svd matrix factored matrix nonzero values diagonal q1 mutually orthonormal columns q2 mutually orthonorma columns vectors orthonormal product vector norm books strang golub van loan good treatments svd strang excellent presentation symmet ric positivedefinite matrices linear algebra general chapter linear programming problems formulated maximizing minimizing objective limited resources competing constraints objective linear function variables constraints resources equalities inequalities variables linearprogramming problem linear programs variety practical appli cations studying application electoral politics political problem suppose politician win election district types areasurban suburban rural areasregistered voters govern effectively win majority votes regions honorable supporting policies realize issues effective winning votes rtain places primary issues building roads gun control farm subsidies gasoline tax dedicated improved public transit campaign staffs estimate votes win lose population segment spending advertis ing issue appears table figure table entry describes number thousands urban suburban rural voters spending advertising support issue negative entries denote votes lost task figure minimum money spend order win urban votes suburban votes rural votes policy urbansuburban rura lbuild roads gun control farm subsidies gasoline tax figure effects policies voters entry describes number thousands urban suburban rural voters spending advertising support policy issue negative entries denote votes lost trial error ith strategy win required number votes strategy expensive devote advertising building roads gun control farm subsidies gasoline tax case win urban votes suburban votes rural votes win exact number votes desired urban suburban areas votes rural area fact rural area votes ther voters order garner votes paid dollars advertising naturally strategy achieved goals spending advertising additional trial error answer question systematic method answering questions order formulate question mathematically introduce variables number thousands dollars spent advertising building roads number thousands dollars spent advertising gun control number thousands dollars spent advertising farm subsidies x4 number thousands dollars spent advertising gasoline tax write requirement win urban votes write requirements win suburban votes rural votes setting variables x4 inequalities satisfied strategy win sufficient number ype vote order costs small minimize spent advertising minimize expression negative advertising common occurrence political campaigns thing negativecost advertising require combining inequalities objective minimizing linear program format problem subject solution linear program yield optimal strategy politician general linear programs general linearprogramming problem sh optimize linear function subject set linear inequalities set real numbers set variables linear function variables defined real number linear function equation fx1 linear equality inequalities fx1 fx1 linear inequalities term linear constraints denote linear equalities linear equalities linear programming strict inequalities formally linearprogramming problem problem mi nimizing maximizing linear function subject finite set linear constraints minimize linear program minimization linear program maximize linear program maximization linear program remainder chapter cover formulation solution linear programs polynomialtime algorith linear prog ramming study chapter udy simplex algorithm oldest linearprogramming algorithm simplex algor ithm polynomial time worst case fairly effici ent practice overview linear programming order properties algorithms linear prog rams convenient canonical forms expres forms standard slack chapter defined precisely informally linear program standard form maximization linear function subject linear inequalities linear program slack form maximiza tion linear function subject linear equalities typically standard form expressing linear programs convenient slack form details simplex algorithm restrict attention maximizing linear function variables subject set linear inequalities li program variables subject setting variables satisfies constraints feasible solution linear program graph constraints x2cartesian coordinate figure set feas ible solutions shaded figure forms convex region1 twodimensional space convex region feasible region function maximize called objective function conceptually evaluate objective function point feasible region objectiv function point objective identify point maxi mum objective optimal solution linear programs easible region infinite number points determine effi cient point achieves maximum objective explicitly evaluating obj ective function point feasible region figure linear program constraint represented direction intersection constraints feasible region shaded dotted lines points objectiveoptimal solution linear program objective dimensions optimize gra phical procedure set points slope plot slope origin figure intersection feasible region set feasible lutions objective case intersection feasible regi point generally intersection feasible region set feasible solutions objective figure linesfeasible region figure bounded maximum intersection feasible region nonempty point occurs optimal lution linear program case point objective accident optimal solution linear program occurred vertex feasible region maximum intersects feasible region boundary feasible region intersection boundary feasible region vertex segment intersection vertex optimal solution vertex intersection segment point segment objective endpoints segment optimal solutions endpoint segment vertex optimal solution vertex case easily graph linear programs variables intuition holds thre variables constraint halfspace threedimensional space intersection halfspaces forms feasible region set points objective function obtains plane coefficients objective function nonnegative origin feasible solution linear program ane origin points increasing objective origin fe asible coefficients objective function negative intuitive picture complicated dimensions feasible region conve set points achieve optimal objective include vertex feasible region variables constraint defines halfspace ndimensional space feas ible region formed intersection halfspaces called simplex objective function hyperplane convexity optimal solution occur vertex simplex simplex algorithm takes input linear program returns optimal solution starts vertex simplex perf orms sequence iterati ons iteration moves edge simplex rrent vertex neighboring vertex objective smaller current vertex larger simplex algorithm terminates reaches local maximum vertex neighboring vertices smaller objective feasible region convex objective function linear local optimum global optimum concept called duality solution returned simplex algorithm optimal geometric view good intuitiv view operations simplex algorithm explicitly refer developing details simplex algorithm algebraic vi ew write linear program slack form set linear equalities linear equalities express variables called basic variables terms variables called nonbasic variables moving vertex accomplished making basic variable nonbasic making nonbasic riable basic operation called pivot viewed algebraically rewriting linear program equivalent slack form twovariable descri bed simple address details chapter issues include identifying linear programs solutions linear programs finite optimal solution linear programs origin feasible solution intuitive definition convex region fulfills requirement points region points segment region applications linear programming linear programming large number applications textbook operations filled examples lin ear programming andard tool taught students business schools election scenario typical examples linear programming airline wishes schedule flight crews federal aviation administration imposes constraints limiting number consecutive hours crew member work insisting crew work model aircraft month airline schedule crews flights crew members oil company decide ill oil siting drill location cost based geological surveys expected payoff number barrels oil company limited budget locating drills maximize oil expects budget linear programs modeling solving graph combinatorial problems textbook special case linear programming solve systems difference constraints study formulate graph networkflow problems linear programs linear programming approximate solution graph problem standard slack forms describes formats standard slack form working linear programs standard form constraints inequalities slack form constraints equalities standard form standard form real numbers real numbers bm real numbers aij real numbers subject generalizing terminology introduced twovariable linear program expression objective function inequalities lines constraints constraints called nonnegativity constraints arbitrary linear program ha nonnegativity constraints standard form requires conveni ent express linear program compact form create matrix aij mdimensional vector ndimensional vector ndimensional vector rewrite linear program defined œ2918 subjectctx product vectors matrixvector product entry vector nonnegative linear ogram standard form tuple adopt convention dimensions introduce terminology solu tions linear programs terminology earlier twovariable linear program setting variables satisfies constraints feasible solution setting variables fails satisfy constraint called infeasible solution solution objective feasible solution objective maximum feasible solutions optimal solution objective optimal objective linear program feasib solutions linear program infeasible feasible linear program feasible solutions finite optimal objec tive linear program unbounded exercise asks linear program finite optimal objective feasible region bounded converting linear programs standard form convert linear program minimization maximization linear function subject linear constraints standard form linear program standard form reasons objective function minimi zation maximization variables nonnegativity constraints equality constraints equal sign lessthan orequalto sign inequality constraints lessthanorequalto sign greaterthanorequalto sign converting linear program linear program property optimal solution yield optimal solution capture idea maximization linear programs equivalent feasible solution objective feasible solution objective feasible solution objective feasible solution objective definition imply onetoone correspondence feasible lutions minimization linear program maximization linear program equivalent feasible solution objective correspo nding feasible solution objective feasible solution objective feasible solution objective remove problems list removing argue linear program equivalent convert minimization linear program equivalent maximization linear program simply negate coefficients objectiv function identical sets feasible solutions feasible solution objective negative objective linear programs equi valent linear program minimize subject negate coefficients objective function minimize subject convert linear program variables nonnegativity constraints variable nonne gativity constraint suppose variable nonnegativity constraint replace occurrence add nonnegativity constraints objective function term cjxj replaced constraint term aijxj replaced feasible solution linear program corresponds feasible solution original linear program objective solutions equivalent apply conversion scheme variable nonnegativity constraint yield equivalent linear program variables nonnegativity constraints continuing ensu variable nonnegativity constraint variable constraint variable replace variables modify linear program subject convert equality constraints inequality constraints suppose linear program equality constraint replace equality constraint pair inequality constraints repeating conversion equality constraint yields linear program nstraints inequalities finally convert greaterthanorequalto constraints lessthanorequalconstraints multiplying constraints throu gh inequality form equivalent replacing coefficient aij aij equivalent lessthanorequalto constraint finishing replac equality constraint inequalities obtaining subject finally negate constraint consistency variable names rename obtaining standard form subject converting linear programs slack form efficiently solve linear program mplex algorithm prefer express form constraints quality constraints precisely convert form nonnega tivity constraints inequality constraints remaining constraints equalities inequality constraint introduce variable rewrite inequality constraints slack variable measures slack difference lefthand righthand sides equation inequality true equation inequality true apply conversion inequality constraint linear program obtaining equivale linear program inequality constraints nonnegativity constraints converting standard slack form xni denote slack variable ith inequality ith constraint nonnegativity constraint xni applying conversion constraint linear program standard form linear program form exampl linear program œ introduce slack variables x4 x5 x6 obtaining maximize subject linear program constraint nonnegativ ity constraints equalities variable subject nonnegativity constraint write equality constraint variables left hand equality righthand equation set variables righthand variables objective function variables lefthand equalities called basic variables righthand called nonbasic variables linear programs satisfy condi tions omit maximize subject explicit nonnegativity constraints variable denote objective function format slack form write linear program œ2937 slack form standard form convenient concise notation describing slack form sets basic nonbasic variables change simplex algorithm runs denote set indices nonbasic variables denote set indices basic variables equations indexed entries variables righthand indexed entries standard form aij denote constant terms coefficients denote optional constant term objective function concisely define slack form tuple denoting slack form variables constrained nonnegativ subtract sum values aij negatives coefficients slack form slack form note indices sets contiguous integers depend sets entries negatives coefficients slack form observe equation includes term x36 coefficient a13 exercises express linear program œ2928 compact notation œ2921 exercises feasible solutions linear program œ2928 objective exercises slack form œ2941 exercises convert linear program standard form minimize subject exercises convert linear program slack form maximize subjectbasic nonbasic variables exercises linear program infeasible maximize subject exercises linear program unbounded maximize subject exercises suppose general linear program variables constraints suppose convert standard upper bound number variables constraints linear program exercises linear program feasible region bounded optimal objective finite formulating problems linear programs focus simplex algorithm chapter recognize problem formul ated linear program problem formulated polynomialsized linear program solved polynomial time ellipsoid interiorpoint algorithms seve ral linearprogramming software packages solve problems efficiently oblem expressed linear program solved practice package concrete examples linearprogramming probl ems start problems studied singlesource shortestpaths problem chapter maximumflow problem chapter minimumcostflow problem polynomialtime algorithm based linear programming minimumcostflow problem examine finally multicommodityflow problem polynomialtime algorithm based linear programming shortest paths singlesource shortestpaths problem chapter formulated linear program focus formulation singlepair shortestpath problem leaving extension general singlesource shortestpaths problem exercise singlepair shortestpath problem weighted directed graph weight function mapping edges realvalue weights source vertex destination vertex compute weight shortest path express problem linear ogram determine set variables constraints define shortest path fortunately bellmanford algorithm bellmanford algorithm terminates computed vertex dv edge dv wu source vertex initi ally receives changed linear program compute shorte stpath weight subject linear program variables dv vertex constraints edge additional constraint source vertex maximum flow maximumflow problem expres sed linear program recall directed graph edge nonnegative capacity distinguished vertices sink source defined flow realvalued function satisfies properties capacity constraints skew symmetry flow conservation maximum flow satisfies constraints maximizes flow total coming source flow satisfies linear constraints flow linear function recalling assume express maximumflow problem linear program subjectlinear program v2 variables flow pair vertices v2 constraints efficient solve sma llersized linear program linear program œ2950 ease notation flow capacity pair vertices efficient rewr ite linear program ov constraints exercise asks minimumcost flow linear programming solve oblems knew efficient algorithms fact efficien algorithm designed problem dijkstras algorithm singlesource shortestpat problem pushrelabel method maximum flow efficient linear programming theory practice real power linear programming ability solve problems recall problem faced politician beginni chapter problem obtaining sufficient number votes spendi money solved algorithms studied book solved linear programming books abound realworld problems linear programming solve linear programming solving variants problems efficient algorithm genera lization maximumflow problem suppose edge addition capacity realvalued cost send units flow edge incur cost flow target send units flow total cost incurred flow vfu minimized problem minimumcostflow problem figure minimumcostf low problem send units flow incurring minimum total cost legal flow function satisfying constraints œ2950 incurs total cost unit flow minimizes cost optimal solution figure total cost figure minimumcostflow problem denote capacities costs vertex source vertex sink send units flow solution minimumcost flow problem units flow edge flow capacity written flowcapacity polynomialtime algorithms specifi cally designed minimumcostflow problem scope book express minimum costflow problem linear program lin ear program maximumflow problem additional constr aint flow units objective function minimizing cost subject multicommodity flow final flow problem suppose lucky puck company decides diversify product ship hockey pucks hockey sticks hockey helmet piece equipment manufactured factory warehouse shipped day factory warehouse sticks manufactured ncouver shipped saskatoon helmets manufactured edmonton shipped regina capacity shipping network change items commodities share network instance multicommodityflow problem problem directed graph edge nonnegative capacity maximumflow problem implicitly assume addition commodities k1 k2 kk commodity triple ki source commodity sink commodity demand sired flow commodity define flow commodity denoted fiu flow commodity vertex vertex realvalued function satisfies flowconservation skewsymmetry capacity constraints define aggregate flow sum commodity flows aggregate flow edge capacity edge constraint subsumes capacity constraints individual commodities problem minimize determin flow write linear program ith null objective function polynomialtime algorithm problem express linear program solve ith polynomialtime linearprogramming algorithm exercises singlepair shortestpath linear program œ2946 standard form exercises write explicitly linear program finding shortest path node node figure exercises singlesource shortestpaths problem shortestpath weights source vertex vertices graph write linear program solution property dv shortestpath weight vertex exercises write explicitly linear program rresponding finding maximum flow figure exercises rewrite linear program maximum flow œ29 ov constraints exercises write linear program bipartite graph solves maximumbipartite matching problem exercises minimumcost multicommodityflow problem directed graph edge nonnegative capacity cost multicommodityflow problem commodities k1 k2 kk commodity triple ki define flow commodity aggregate flow edge multicommodityflow problem feasible flow aggregate flow edge capacity edge cost flow vv goal feasible flow minimum cost xpress problem linear program simplex algorithm simplex algorithm classi cal method solving linear ograms contrast algorithms book running time polynomial worst case yield insight linear programs remarkably fast practice addition geometric interpretation scribed earlier chapter simplex algorithm bears similarity gaussian elimination discussed gaussian elimination linear equalities solution unknown iteration rewrite equivalent form additional structure number iterations rewritten solution simple simplex algorithm proceeds simila manner view gaussian elimination inequalities main idea iterati simplex algorithm iteration basic solution easily slack form linear program set nonbasic variable compute values basic variables equality constraints basic soluti correspond vertex simplex algebraically iterati converts slack form equivalent slack form objective basic feas ible solution previous iteration greater achieve increase objective choose nonbasic variable increase variables objective increase increase variable limited constraints raise basic variable rewrite slack form exchanging roles basic variable chosen nonbasic variable setting variables guide algorithm proofs algorithm explicitly maintain solution simply rewrites linear program optimal solution obvious simplex algorithm extended linear program standard form subject order simplex algorithm convert linear program slack form addition algebraic manipulation slack algorithmic concept recalling variable nonnegativity constraint equality constraint tight setting nonbasic variables constraints basic variable setting nonbasic riables basic variable negative violates constraint slack variables explicitly maintain constraint tight determine increase values nonbasic values violating constraints associating slack variables x4 x5 x6 inequalities œ2959 putting linear program slack form constraints œ2964 equations variable setting variables defines values x4 x5 x6 infinite number solutions equations solution feasible x6 nonnegative infinite number feasible solutions infinite number solutions proofs focus basic solution set nonbasic variables righthand compute values basic variables lefth basic solution objectiveobserve basic solution sets iteration simplex algorithm rewrite set equations objective function set variables righthand ther basic solution rewritten problem emphasize rewrite change underlying linearprogramming problem proble iteration identical set feasible solutions problem previous iteration problem basic solution previous iteration basic solution feasible basic feasible solution running simplex algorithm basic solution lmost basic feasible solution iterations simplex algorithm basic solution feasible goal iteration reformulate linear program basic solution greater objective select nonbasic variable xe coefficient objective function positive increase xe violating constraints variable xe basic variable nonbasic values basic variables objective function change continue ink increasing increase values x4 x5 x6 decrease nonnegativity constraint variable negative increases x4 negative x5 x6 negative increases constraint tightest constraint limits increase switch roles x6 solve equation rewrite equations x6 righthand substitute equation equation combine equation constraint objective function rewrite linear program form operation pivot demonstrated pivot chooses nonbasic variable xe called entering variable basic variable called leaving variable exchanges roles linear program œ2970 equivalent linear program equations œ2964 operations perform simplex algorithm rewriting equations variables leftha righthand substituting equation operation trivially creates equivalent problem elementary linear gebra creates equivalent problem demonstrate equivalence observe original basic solution satisfies equations œ2970 objective basic solution lin ear program sets nonbasic valuesobjective simple arithmetic verifies solution satisfies equations œ2964 plugged objective function objectivecontinuing riable increase increase x6 increases objective decreases attempt increase choose increase violating constraints constraint limits constraint limits constraint limits constr aint tightest rewrite constraint lefthand x5 righthand ubstitute equation equations œ2969 equivalent basic soluti objective increase objective increase constraints upper bounds upper bound constraint increase basic variable x4 increases constraint places restriction increased increase nonbasic solve equation substitute equations point coefficients objectiv function negative chapter situation occurs rewritten linear program basic solution optimal solution problem solution objective optimal return original linear program œ2960 variables original linear program solutionobjectivenote values slack variables nal solution measure slack inequality slack variable x4 inequality lefthand righthand slack variables x5 x6 inequalities lefthand righthand sides equal observe coefficients original slack form tegral coefficients linear programs ecessarily integral intermediate solutions integral final solutio linear program integral purely coincidental integral solution pivoting formalize procedure pivoting procedure pivot takes input slack form tuple leaving variable entering variable xe returns tuple describing slack form recall matrices negative coefficients slack form pivotn compute coefficients equation basic variable xe compute coefficients remaining constraints compute objective function compute sets basic nonbasic variablesreturn pivot works lines œ5 compute coefficients equation xe rewriting equation lefthand xe lefthand lines œ11 update remaining equations subs tituting righthand equation occurrence xe lines œ16 substitution objective function lines update sets nonbasic basic variables returns slack form ale pivot error dividing proofs lemmas pivot called ale summarize pivot values variables basic solution lemma pivot ale values returned denote basic solutionproof statement true sic solution sets nonbasic variables set nonbasic riable constraint pivot proves statement proves statement formal simplex algorithm ready formalize simplex gorithm demonstrated nice issues address determine linear program feasible linear program feasible initial basic solution feasible determine linear program unbounded choose entering leaving variables determine problem feasible slack form initial basic solution feasible assume procedure initializesimplex takes input linear program standard form matrix aij mdimensional vector ndimensional vector problem infeasible returns message program infeasible terminates returns slack form initial basic solution feasible procedure simplex takes input linear program standard form returns nvector optimal solution linear program œ2921 simplexa initializesimplexachooseaie biaie choose minimizes return unbounded pivotn return simplex procedure works calls procedure initializesimplexa determines linear program infeasible returns slack form basic solution feasible main algorithm loop lines œ11 coefficients objective function negative loop terminates select variable xe coefficient objective functi positive entering variable freedom choose variable entering variable assume prespecified deterministic lines œ8 check constraint pick severely limits increase xe violating nonnegativity constraints basic variable constraint freedom hoose variables leaving variable assume prespecified deterministic rule constraints limits entering variable increase algorithm returns unbounded exchanges roles entering leaving variables calling subroutine pivot lines œ15 compute solution iginal linearprogramming variables setting nonbasic variables basic variable theorem solution optimal solu tion linear program finally returns computed values original linearprogramming variables simplex correct simplex initial feasible solution eventually terminates returns feasible solution determines linear program unbounded simplex terminates finally solution returned optimal lemma linear program suppose initializesimplex simplex returns slack form sic solution feasible simplex returns solution solution feasible solution linear program simplex returns unbounded linear program unbounded proof threepart loop invariant start iteration loop lines œ11 slack form equivalent slack form returned initializesimplexbasic solution slack form feasible initialization equivalence slack forms trivial iteration assume statement lemma initia lizesimplex simplex returns slack form whic basic solution feasible invariant true basic variable set basic solution feasibility basic solu tion implies basic variable nonnegative invariant holds maintenance loop invari ant maintained assuming return statement executed handle case executes discuss termination iteration loop exchanges role basic nonbasic variable operations performed involve lving equations substituting equation slack form equivalent previous iteration loop invariant equivalent initial slack form demonstrate pa loop invariant assume start iteration loop inequalities remain true pivot variables set basic variables occur assignment suffices maintains invariant aij refer values pivot refer values returned pivot observe loop invariant ale simplex pivot remaining indices cases depending aie aie aie chose aieblale equation aiebiaie inequality aie ale nonnegative equation implies nonnegative argue basic solution feasible variables nonnegative values nonbasic variables set nonnegative basic variable defined equation basic solution sets loop invariant conclude basic variable nonnegative termination loop terminate ways terminates condition current basic solution feasible solution returned terminate return unbounded case iteration loop lines œ7 executed aie basic solution slack form iteration returned unbounded solution defined solution feasible variables nonnegative nonbasic variables positive nonbasic variables nonnegative basic variable loop invariant implies aie objective solution unbounded objective objective linear program unbounded iteration simplex maintains addition sets explicitly maintaining essential efficient implementation simplex algorithm strictly slack form uniquely determined sets basic nonbasic riables proving fact prove algebraic lemma lemma set indices real numbers realvalued variable real number suppose settings proof equation holds values values draw conclusions conclude pick arbitrary set picked conclude slack form linear program unique ly determined set basic variables lemma linear program standard form set basic variables slack form uniquely determined proof assume purpose contradiction ere slack forms set basic variables slack form identical sets nonbasic variables write slack form equations formed subtracting equation equation equivalently apply lemma aij slack forms identical argument exercise case slack forms identical remains simplex terminates terminate solution returned optimal address optimality discuss termination termination iteration simplex algorithm increased objective basic solution exercise asks iteration simplex decrease objective basic solution iteration leaves objective unchanged phenomenon called degeneracy study greater objective changed assignment pivot simplex calls pivot objective remain unchanged assigned pivot pivot ale equal objective unchanged situation occur linear program x4 x5 suppose choose entering variable x4 leaving variable pivoting x4 x4 x5 point choice pivot entering x5 leaving b5 objective remains unchanged pivoting x4 x5 x4 x5 objective cha nged representation fortunately pivot entering leaving objective increase simplex algorithm continue degeneracy thing simplex algorithm terminating recall assumption simplex chooses indices lines deterministic rule simplex cycles slack forms iterations identical case simplex deterministic algorithm cycle series slack forms forever lemma simplex fails terminate iterations cycles proof lemma set basic variables uniquely determines slack form variables ways choose unique slack forms simplex runs iterations cycle cycling theoretically extremel rare avoidable choosing entering leaving variables carefully option perturb input impossible tw solutions objectiv break ties lexicographically break ties choosing variable smallest strategy blands rule omit proof strategies avoid cycling lemma lines simplex ties broken choosing variable smallest simplex terminate conclude lemma lemma assuming initializesimplex returns slack form basic solution feasible simplex reports linear program unbounded terminates feasible solution iterations proof lemmas initializesimplex returns slack form basic solution feasible simplex reports linear program unbounded terminates feasible solution contrapositive lemma simplex terminates feasible solution terminates iterations exercises complete proof lemma showing case exercises pivot simplex decrease exercises suppose convert linear program standard form slack form basic solution feas ibleexercises solve linear program simplex maximize subject exercises solve linear program simplex maximize subject exercises solve linear program simplex minimize subject x3x3duality proven assumptions simplex terminate finds optimal soluti linear program order introduce powerful concept called linearprogramming duality duality property opt imization problem identification dual problem coupled scovery polynomialtime algorithm duality powerful ability provide proof solution optimal suppose instance maximumflow problem flow maximum flow maxflow mincut theorem theorem cut verified maximum flow duality maximization problem define minimization problem problems optimal objective values linear program objective maximize formulate dual linear program objectiv minimize optimal identical original li program referring dual linear programs orig inal linear program primal primal linear program standard œ2918 define dual linear program minimize subject form dual change maximization minimization exchange roles righthand sides objectivefunction coeffi cients replace lessthanorequalto greaterthanorequalto constraints primal variable yi dual constraints dual variable primal linea program œ2960 dual linear program minimize subject theorem optimal dual linear program equal optimal primal lin ear program simplex algorithm implicitly solves primal dual linear programs simultaneously providing proof optimality demonstrating weak duality states feasible solution primal linear program grea ter feasible solution dual linear program lemma weak linearprogramming duality feasible solution primal linear program œ2918 feasible solution dual linear program œ2988 proof corollary feasible solution primal linear program feasible solution dual linear program optimal solutions primal dual linear programs proof lemma objective feasible solution primal exceed feasible solution dual primal linear program maximization problem dual minimization probl feas ible solutions objective improved proving dual solution equal optimal primal solution solution simplex algorithm linear program œ2960 nal iteration yielded slack form œbasic solution final slack form timal solution linear program optimal solution linear program œ2960 objectiveread optimal dual solution negatives coefficients primal objective function values dual variables precisely suppose slack form primal optimal dual solution set optimal solution dual lin ear program defined œ2993 evaluating dual objective function objectiveconfirms objective primal equal objective dual combining calculations lemma proof optimal objective primal linear program general optimal solution dual proof optimality solution primal manner theorem linearprogramming duality suppose simplex returns values primal linear program denote nonbasic basic variables final slack form denote coefficients final slack form defined equation optimal solution primal linear program optimal solution dual linear program proof corollary feasible solutions satisfy equation optimal primal dual solutions solutions statement theorem satisfy equation suppose simplex primal linea program lines œ2918 algorithm proceeds series slack forms terminates final slack form objective function simplex terminated solution condition define rewrite equation basic solution final slack form slack forms equivalent evaluate origin objective function objective defined equation feasible dual linear program objective equals equation slack forms evaluated equal generally equivalence slack forms implies set values set values applying lemma equationequation objective dual equal primal remains solution feasible dual problemimplies satisfies constraints dual finally set equation nonnegativity constraints satisfied feasible linear program initializesimplex returns feasible solution simplex terminates turning unbounded solution returned optimal solution construct optimal solution dual linear program exercises formulate dual linear program exercise exercises suppose linear program standard form produce dual converting standard form dual convenient produce dual directly explain arbitrary linear program directly dual linear program exercises write dual maximumflow linear program lines œ2950 explain interpret form ulation minimumcut problem exercises write dual minimumcostflow li program lines œ2955 explain interpret problem terms graphs flows exercises dual dual linear program primal linear program exercises result chapter interpreted weak duality maximumflow problem initial basic feasible solution test linear program feasib produce slack form basic soluti feasible conclude proving fundamental theorem linear programming simplex procedure produces correct result finding initial solution assumed procedure initializesimplex determines linear program feasible solutions slack form basic solution feasible procedure linear program feasible initial basic solution feasible linear program subjectconvert linear program slack form basic solution set solution violates constraint feasible solution initializesimplex return obvious slack form inspection clear linear program feasible solutions order determine formulate auxiliary linear program auxiliary linear program work slack form basic solution feasible solution auxiliary linear program determine initial linear program feasible provide feasible solution initialize simplex lemma linear program standard form œ2918 laux linear program variables subject feasible optimal objective laux proof suppose feasible solution solution combined feasible solution laux objective x0 constraint laux objective function maximize x0 solution optimal laux conversely suppose optimal objective laux values remaining variables satisfy constraints strategy ini tial basic feasible solution linear program standard form initializesimplexa minimum initial basic solution feasible return form laux adding x0 lefthand equation setting objective function x0 slack form laux laux nonbasic variables basic variables pivotn basic solution feasible laux iterate loop lines œ11 simplex optimal solution laux basic solution sets return final slack form x0 removed original objective function restored return infeasible initializesimplex works lines œ3 implicitly test basic solution initial slack form creating slack form requires explicit effort values slack standa forms basic solution feasiblešthat bšthen slack form returned form auxiliary linear program laux lemma initial basic solution feasible initial basic solution slack form laux feasible perfor pivot x0 entering leaving chosen negative shortly basic solution pivot feasible slack form basic solution feasible repeatedly pivot fully solve auxiliar linear program test demonstrates optimal solution laux objective create slack form basic solution feasible delete x0 terms constraints restore original objective function original objective function basic nonbasic variables objective function replace basic variable righthand constraint hand discover original linear program infeasible return demonstrate ope ration initializesimp lex linear program œ29108 linear program feasible nonnegative values satisfy inequalities lemma formulate auxiliary linear program subject lemma optimal objective auxiliary linear program original linear program easible solution optimal obj ective auxiliary linear program positive original li program feasible solution write linear program slack form obtaining x0x3 x0x4 x0we woods basic solution set x4 feasible auxiliary linear program ith pivot convert slack form basic lution feasible choose x0 entering variable choose leaving variable x4 basic variable basic solution negative pivoting slack form x4x0 x4x3 x4 basic solution x0 x4 feasible repeatedly pivot optimal solution laux case pivot entering x0 leaving yields slack form final solution auxiliary problem solution x0 initial problem feasible x0 remove set constraints original objective function substitutions include nonbasic variables objective function setting x0 simplifying objective function slack form slack form feasible basic soluti return procedure simplex formally corr ectness initializesimplex lemma linear program feasible solution initializesimplex returns infeasible returns valid slack form basic solution feasible proof suppose linear program feasible solution lemma optimal objective laux defined œ29111 nonzero nonnegativity constraint x0 optimal solution negative objective objective finite settingfeasible solution objective initializesimplex solution negative objective basic solution final slack form laux objective contradicting fact objective negative test infeasible returned suppose linear program feasible solution exercise basic solution initial slack form feasible case lines œ3 ill return slack form input convert standard form slack form remainder proof handle cas linear program feasible return argue case lines œ9 feasible solution laux objective lines œ2perform pivot opera tion leaving variable lefthand equation minimum entering variable x0 extra variable pivot entries nonnegative basic solution laux feasible letting basic solution pivot letting values returned pivot lemma implies pivot note ai0 coefficient x0 appears negation coefficient laux standard slack form ale blale remaining basic variables equation aieblale pivot equation ale inequality implies basic variable nonnegative basic solution pivot feasible execute solves laux assumed feasible solution lemma implies laux optimal solution objective slack forms equivalent final basic solution laux removing x0 linear program slack form feasible slack form returned fundamental theorem linear programming conclude chapter showing simplex procedure works linear program inf easible unbounded optimal solution finite objective case simplex appropriately theorem fundamental theo rem linear programming linear program standard form optimal solution finite objective infeasible unbounded infeasible simplex returns infeasible unbounded simplex returns unbounded simplex returns optimal solution finite objective proof lemma linear program infeasible simplex returns infeasible suppose linear program feasible lemma initializesimplex returns slack form basic solution feasible lemma simplex returns unbounded terminates feasible solution terminates finite solution theorem tells solution optimal hand simplex returns unbounded lemma tells linear program unbounded simplex terminates ways proof complete exercises detailed pseudocode implement lines initializesimplex exercises initializesimplex runs main loop simplex unbounded returned exercises suppose linear program standard form suppose dual basic solutions initial slack forms feasible optimal objective exercises suppose strict inequalities linear program case fundamental theorem linea programming hold exercises solve linear program simplex maximize subject exercises solve linear program œ2910 exercises variable linear program maximize subject arbitrary real numbers dual state values assert optimal solutions finite objective values feasible infeasible feasible infeasible feasible problems linearinequality feasibility set linear inequalities variables linearinequality feasibility problem asks setting variable simultaneously satisfies inequalities algorithm lin ear programming solve linearinequality feasibility problem number variables constraints linearprogramming problem polynomial algorithm linearinequality feasibility problem solve linearpr ogramming problem number variables linear inequalities linearinequality feasibility problem polynomial number variables cons traints linear program problems complementary slackness complementary slackness describes relationship values primal variables dual constraints values dual variables primal constraints optimal solution primal linear program œ2918 optimal solution dual linear program œ2988 compleme ntary slackness states conditions sufficient optimal verify complementary slackness holds linear program lines œ prove complementary slackness holds primal linear program dual prove feasible solution primal linear program lines œ optimal values feasible solution dual linear program œ2988 exercises intege linear programming integer linearprogramming problem linearprogra mming problem additional constraint variables integral values exercise determining integer linear program feasible solution nphard polynomialtime algorithm problem weak duality lemma holds integer linear program duality theorem hold integer linear program primal linear program standard form define optimal objective primal linear program optimal objective dual optimal objective integer version primal primal constraint variables integer values optimal objective integer version dual exercises farkass lemma matrix mvector farkass lemma states systems ya solvable nvector mvector prove farkass lemma chapter notes chapter study wide field linear programmi number books devoted exclusively linear programming including chvtal gass karloff schrijver vanderbei books good coverage linear programming including papadimitriou steiglitz ahuja magnanti orlin coverage chapter draws approach chvátal simplex algorithm linear programming invented dantzig shortly discovered number problems variety fields formulated linear programs solved simplex algor ithm realization led flourishing linear programming algorithms variants simplex algorithm remain popular methods solving linearprogramming problems history number places including notes ellipsoid algorithm polynom ialtime algorithm linear programming khachian based earlier work shor judin nemirovskii ellipsoid algorithm solve variety problems combinatorial optimization work grötschel lovsz schrijver ellipsoid algorithm competitive simplex algorithm practice karmarkars paper includes description interiorpoint algorithm subsequent researchers designed interiorpoint algorithms ood surveys article goldfarb todd book ye analysis simplex algorithm active area klee minty constructed simplex algorithm runs iterations simplex algorithm performs practice researchers trie theoretical justification empirical observation begun borgwardt carried cer tain probabilistic assumptions input simplex algorithm converges expected lynomial time progress area spielman teng introduce smoothed analysis algorithms apply simplex algorithm simplex algorithm effici ently special cases noteworthy networksimplex algorithm wh ich simplex algorithm specialized networkflow problems network problems cluding shortestpaths maximumflow minimumcostflow problems variants networksimplex algorithm polynomial time article orlin citations chapter polynomials fft straightforward method dding polynomials degree takes time straightforward method multiplying takes time chapter fast fourier transform fft reduce time multiply polynomials lg common fourier transforms fft signal processing signal time domain function mapping time amplitude fourier analysis express signal weighted sum phaseshifted sinusoids varying frequencies weights phases frequencies characterize signal frequency domain signal processing rich area fine books chapter notes reference polynomials polynomial variable algebraic field representation function formal sum values a0 an1 coefficients polynomial coefficients drawn field typically set complex numbers polynomial degree highest nonzero coefficient ak integer strictly greater degree polynomial degreebound polynomial degree polynomial degreebound integer inclusive variety operations mi ght define polynomials polynomial addition polynomials degreebound sum polynomial degreebound underlying fieldpolynomials polynomial multiplication polynomials degreebound product polynomial degreebound underlying field multiplied polynomials multiplying term term combining terms equal powers multiply express product note degree degreea degreeb implying degreeboundc degreebounda degreeboundb degreebound degreeboundb speak degreebound sum degreebounds polynomial degreebound degreebound chapter outline presents ways represent polynomi als coefficient representation pointvalue representation straight forward methods multiplying polynomials š equations štake time polynomials represented coefficient form time represented pointvalue form multiply polynomials coefficient representation lg time converting representations works study complex roots unity fft inverse perform conversions implement fft serial parallel models chapter complex numbers extensively symbol exclusively denote representation polynomials coefficient pointvalue representations polynomials sense equivalent polynomial pointvalue form unique counterpart coefficient form introduce representations combined multiplication degreebound polynomials lg time coefficient representation coefficient representation polynomial degreebound vector coefficients a0 an1 matrix equations chapter generally treat vectors column vectors coefficient representation convenient operations polynomials operation evaluating polynomial point x0 consists computing ax0 evaluation takes time horners rule ax0 a0 x0a1 x0a2 x0an2 x0an1 adding polynomials repres ented coefficient vectors a0 an1 b0 bn1 takes time produce coefficient vector c0 cn1multiplication degreebound polynomials represented coefficient form method equations polynomial multiplication takes time coefficient vector multiplied coefficient vector operation multiplying polynomials coefficient form considerably difficult evaluating polynomial adding polynomials sulting coefficient vector equation called convolution input vectors denoted multiplying polynomials computing convolutions fundamental computational problems considerable practical chapter concentrates efficient algorithms pointvalue representation pointvalue representation polynomial degreebound set pointvalue pairs x0 y0 y1 xn1 yn1 distinct polynomial pointvalue representations set distinct points x0 xn1 basis representation computing pointvalue representation pol ynomial coefficient form principle straightforward select distinct points x0 xn1 evaluate axkhorners method npoint evaluation takes time choose cleverly computation accelerated time lg inverse evaluation šdetermining coefficient form polynomial point representation šis called interpolation theorem hows interpolation defined assuming degreebound interpolating polynomial equals number pointvalue pairs theorem uniqueness interpolating polynomial set x0 y0 y1 xn1 yn1 pointvalue pairs values distinct unique polynomial degreebound yk axkproof proof based existence inverse matrix equation equivalent matrix equation matrix left denoted x0 xn1 vandermonde matrix exercise matrix determinant theorem invertible nonsingular distinct coefficients solved uniquely pointvalue representation x0 xn11 proof theorem describes algorithm interp olation based solving set linear equations lu decomposition algorithms chapter solve equations time on3 faster algorithm npoint interpolation based lagranges formula verify righthand equation polynomial degree bound satisfies axi yi exercise asks compute coefficients lagranges formula time npoint evaluation interpolation welldefined inverse operations transform coefficient representation polynomial point representation1 algorithms problems time pointvalue representation convenient operations polynomials addition cxk axk bxk point precisely pointvalue representation x0 y0 y1 xn1 yn1 note evaluated points pointvalue representation time add polynomials degreebound pointvalue form pointvalue representation convenient multiplying polynomials cxk axkbxk point pointwise multiply point representation pointvalue representation pointvalue representation face problem degreebound sum degreebounds standard pointvalue representation consists pointvalue pairs polynomial multiplying pointvalue pairs degreebound pointvalue pairs pointvalue representation exercise extended pointvalue representations consisting pointvalue pairs extended pointvalue representation x0y0x1y1x2n1y2n1 extended pointvalue representation pointvalue representation input polynomials extended pointvalue form time multiply pointvalue form result time required multiply polynomials coefficient form finally evaluate polynomial pointvalue form point problem pproach simpler converting polynomial coefficient form evaluating point fast multiplication polynomials coefficient form lineartime multiplication met hod polynomials pointvalue form expedite polynomial multiplicati coefficient form swer hinges ability convert polynomial coefficient form pointvalue form evaluate vice versa interpolate points evaluation points choosing evaluation points carefully convert betw een representations lg time choose complex roots unity evaluation points produce pointvalue representation discrete fourier transform dft coefficient vector inverse operation interpolation performed inverse dft pointvalue pairs yielding coefficient vector fft performs dft inverse dft operations lg time figure strategy graphically minor concerns degreebounds product polynomials degreebound polynomial degreebound evaluating input polynomials double degreebounds adding highorder coefficients vectors elements complex nth roots unity denoted w2n terms figure figure graphical outline effi cient polynomialmultiplication process representations coefficient form point form arrows left correspond multiplication operation w2n terms complex nth roots unity fft lg ntime procedure multiplying polynomials degreebound input output representations coefficient form assume power requirement met adding highorder coefficients double degreebound create coefficient representations degreebound polynomials adding highorder coefficients evaluate compute pointvalue representations length applications fft order representations values polynomials nth roots unity pointwise multiply compute pointvalue representation polynomial axbx multiplying values poi ntwise representation nth root unity interpolate create coefficient representation polynomial single application fft pointvalue pairs compute inverse dft steps time steps time lg fft proven theorem product polynomials degreebound computed time lg input output representations coefficient form exercises multiply polynomials equations exercises evaluating polynomial degreebound point x0 dividing polynomial x0 quotient polynomial qx degreebound remainder qxx x0 ax0 compute remainder coefficients qx time x0 coefficients exercises derive pointvalue representation pointvalue representation assuming points exercises prove distinct pointvalue pairs uniquely polynomial degreebound fewer distinct pointvalue pairs fail unique polynomial degreebound hint theorem set pointvalue pairs add arbitrarilychosen pointvalue pair exercises equation interpolate time hint compute coefficient representation polynomial jx divide numerator term exercise denominators computed time exercises explain wrong obvious appr oach polynomial division point representation dividing values discuss separately case division case doesnt exercises sets integers range compute cartesian sum defined note integers range elements number times element realized sum elements problem solved lg time hint represent polynomials degree interpolation notoriously tricky problem point view numerical stability approaches math ematically correct small differences inputs roundoff errors computation larg differences result efficient fft implementations practical applications dft signal processing demand utmost speed examines efficient fft implementations examine iterative version fft algorithm runs lg time lower constant hidden notation recursive implementation insights led iterative plementation design efficient parallel fft circuit iterative fft implementation note loop lines œ13 recursivefft involves computing compiler terminol ogy common subexpression change loop compute storing temporary variable wn wn operation loop multiplying twiddle factor storing product adding subtracting butterfly operation schematically figure figure butterfly operation input values enter left twiddle factor multiplied sum difference output simplified drawing butterfly operation repr esentation parallel fft circuit fft algorithm iterati recursive structure figure arranged input vectors recursive calls invocation recursivefft tree structure initial tree node procedure labeled input vector recursive fft invocation recursive calls received element vector left child child figure tree input vectors recursive calls recursivefft procedure initial invocation tree observe arrange elements initial vector order leaves mimic execution recursivefft procedure elements pairs compute dft pair butte rfly operation replace pa dft vector holds element dfts dfts pairs compute dft vector elements executing butterfly operations replacing element dfts elem ent dft vector holds n4 element dfts wecontinue manner vector holds n2element dfts combine butterfly operations final nelement dft turn observation code array a0 initially holds elements input vector order leaves tree figure determine order bitreversal permutation combining ha level tree introduce variable count levels ranging combining pairs form element dfts lg combining n2element dfts produce final result algorithm structure lgs combine s1element dfts ak s1 ak s1 selement dft ak express body loop ecise pseudocode copy loop recursivefft procedure identifying y0 ak s1 y1 ak s1 twiddle factor butterfly operation depends power wm introduce variable solely sake readability intr oduce temp orary variable perform butterfly operation place replace structure loop body pseudocode forms basis parallel implementation code calls auxiliary procedur bitreversecopy copy vector array initial order values iterativefft bitreversecopy lengtha powerlg e2im ak ak ak ak bitreversecopy elements input vector desired order array order leaves figure bitreversal permutation revk lg nbit integer formed reve rsing bits binary representation place vector element ak array position arevk figure leaves order sequence binary reverse bits sequence bit reversal permutation general note level tree indices loworder bit left subtree indices loworder bit subtree stripping loworder level continue process tree order bitreversal permutation leaves function revk easily computed bitreversecopy procedure written bitreversecopya lengtha arevk ak iterative fft implementation runs time lg bitreverse copya runs lg time iterate times reverse integer lg bits olg time practice initial advance code table mapping rev making bitreversecopy time low hidden constant alternatively clever amortized reverse nary counter scheme problem complete proof iterativefft runs time lg number times body innerm ost loop lines œ13 executed lg loop lines œ13 iterates nm n2s times innermost loop lines œ13 iterates s1 times parallel fft circuit exploit propert ies allowed implem ent efficient iterative fft algorithm produce efficient parallel algorithm fft express parallel fft algorithm circuit comparison networks chapter comparators fft circuit butterfly operations drawn figure notion depth developed chapter applies circuit parallelfft computes fft inputs figure bitreverse permuta tion inputs lg stages stage consisting butterflies executed parallel depth circuit lg figure circuit parallelfft computes fft inputs butterfly operation takes input values wires twiddle factor produces outputs values wires stages butterflies labeled correspond iterations outermost loop iterativefft procedure wires passing butterfly interact wires pass middle butterfly affect butterfly values chan ged butterfly butterfly stage hing wire wire output labeled y1 inputs outputs wires labeled y0 fft inputs computed lg depth lg butterfly operations leftmost circuit parallelfft performs bitreve rse permutation remainder mimics iterative iterative fft procedure iteration outermost loop performs independent butterfly operations circuit performs parallel iteration iterativ efft corresponds stage butterflies figure stage lg n2s groups butterflies correspondin iterativefft s1 butterflies group iterativefft butterflies figure correspond butterfly operations innermost loop lines œ12 iterative fft note twiddle factors butterflies correspond iterativefft stage exercises iterativefft computes dft input vector exercises implement fft algorithm bitreversal permutation occurring computation hint inverse dft exercises times iterativefft compute tw iddle factors stage rewrite iterativefft compute twiddle factors s1 times stage exercises suppose adders butterfly operations fft circuit fail manner produce ze output independent inputs suppose adder failed dont identify failed adder supplying inputs fft circuit observing outputs efficient method problems divide conquer multiplication multiply linear polynomials multiplications hint multiplications divide conquer algorithms multiplying polynomials degree bound time nlg algorithm hould divide input polynomial coefficients high half low half algorithm divide odd nbit integers multiplied onlg steps step operates constant number bit values problems toeplitz matrices toeplitz matrix matrix aij aij ai1 j1 sum toeplitz matrices nece ssarily toeplitz product represent toeplitz matrix toeplitz matrices time lg ntime algorithm multiplying toeplitz matrix vector length representation efficient algorithm multiplying toeplitz matrices analyze running time problems multidimensiona fast fourier transform generalize dimensional discre fourier transform defined equation dimensions input ddimensional array dimensions n1 n1n2 define ddimensional discrete ourier transform equation k1 n1 k2 kd compute ddimensional dft computing dimensional dfts dimension turn compute nn1 separate dimensional dfts dimension result dfts dimension input compute nn2 separate dimensional dfts mension result input compute nn3 separate dimensional dft dimension dimension ordering dimensions doe matter compute ddimensional dft computing dime nsional dfts order dimensions compute dimens ional dft computing fast fourier transform total time compute ddimensional dft lg independent problems evaluating derivativ polynomial point polynomial degreebound tth derivative defined coefficient representation a0 an1 point x0 determine atx0coefficients b0 bn1 compute x0time explain b0 bn1 lg timeprove explain evaluatelg time conclude nontrivial derivatives evaluated x0 lg time problems polynomial evaluation multiple points observed problem evaluating polynomial degreebound single point solved time horners rule ha discovered polynomial evaluated complex roots unity lg time fft evaluate polynomial degreebound arbitrary points lg2 time fact mpute polynomial remainder polynomial divided lg time result assume proof remainder divided modcoefficient representation polynomial points x0 xn1 compute values ax0 ax1axn1 define polynomials qij mod pijx note qij degree prove mod point prove qkkx axk q0n1x prove qik qij mod pikx qkjx qij mod pkjx lg2 ntime algorithm evaluate ax0 ax1 axn1 problems fft modular arithmetic defined discrete fourier transform quires complex numbers result loss precision roundoff errors problems answer integers desirable utilize variant fft based modular arithmetic order guarantee answ calculated problem multiplying polynomials integer coefficients exercise approach modulus length bits handle dft points problem approach modulus reasonable length olg requires understand material chapter power suppose search smallest kn prime simple heuristic argument expect lg larger smaller expect examine olg candidate values average expected length compare length generator gk mod argue dft inverse dft welldefined inverse operations modulo principal nth root unity argue fft inverse work modulo time lg operations olg bits unit time assume algorithm compute dft modulo vector note generator chapter notes vanloans book outstanding treatment fast fourier transform press flannery teukolsky vetterling good description fast fourier transform applications excellent introduction signal processing popular fft application area texts oppenheim schafer oppenheim willsky oppenheim schafer book handle cases integer power fourier analysis limited dimensional ta image processing analyze data dimensions books gonzalez woods pratt discuss multdimensional fourier transfor image processing books tolimieri lu van loan discuss mathematics multidimensional fast fourier transforms cooley tukey credited devising fft fft fact discovered times previousl fully realized advent modern digitial puters press flannery teukolsky vetterling attribute origins method runge könig article heideman johnson burrus traces history fft gauss chapter numbertheoretic algorithms number theory viewed beau tiful useless subject pure mathematics today numbertheoretic algorithms cryptographic schemes based large prime numbers feasibility schemes rests ability large primes easily security rests inability factor product large primes chap ter presents number theory algorithms underlie applications introduces basic concepts number theory divisibility modular equivalence unique factorization studies worlds oldest algorithms euclids algorithm computing greatest common divisor integers reviews concepts modular arithmetic studies set multiples number modulo solutions equation mod euclids algorithm chinese remainder theorem presented considers powers number modulo presents repeatedsquaring algorithm efficiently computing mod operation heart efficient prima lity testing modern cryptography describes rsa publickey cryptosystem examines randomized primality test large primes efficientl essential task creating keys rsa cryptosystem finally reviews simple effective heuristic factoring small inte gers curious fact factoring problem people intractable security rsa depends difficulty factoring large integers size inputs cost arithmetic computations working large integers adjust size input cost elementary arithmetic operations chapter large input typically input large integers input integers sor ting measure size input terms number bits required represent input number integers input algorithm integer inputs ak polynomialtime algorithm runs time polynomial lg lg lg ak polynomial lengths binaryencoded inputs book convenien elementary arithmetic operations multiplications divisions computing remainders primitive operations unit time counting number arithmetic operations algorithm performs basis making reasonab estimate algor ithms actual running time computer elementary operations timeconsuming inputs large convenient measure bit operations number theoretic algorithm requires model multiplication bit integers ordinary method bit operations operation dividing bit integer shorter integer operation remainder bit integer divided shorter integer performed time simple algorithms exercise faster methods simple divide conquer method multiplying bit integers running time fastest method running time lg lg lg practical purposes algorithm bound basis analyses chapter algorithms generally analyz terms number arithmetic operations number bit operations require elementary numbertheoretic notions review notions elementary number theory set integers setnatural numbers divisibility divisors notion integer divisible central theory numbers notation read divides kd integer integer divides multiple divide write divisor note generality lost defining divisors nonnegative understanding negative divisor divides divisor integer greater divisors integer divisible trivial divisors nontrivial divisors called factors factors prime composite numbers integer divisors trivial divisors prime number simply prime primes special properties play critical role number theory primes order exercise asks prove infinitely primes integer prime composite number simply composite composite integer unit prime composite integer negati integers prime composite division theorem remaind ers modular equivalence integer integers partitioned multiples multiples number theory based refinement partition classifying nonmultiples remainders divided theorem basis refinement proof theorem niven zuckerman theorem division theorem integer positive integer uni integers qn quotient division mod remainder residue division mod integers divided equivalence classes remainders modulo equivalence class modulo integer kndenotations set notation defined writing writing mod set equivalence classes sees definition read equivalent equation understanding represents represents class represented nonnegative element underlying equivalence classes mind reference member zn reference mod common divisors greatest common divisors divisor divisor common divisor divisors common divisors note common divisor integers property common divisors generally integers implies greatest common divisor integers largest common divisors denoted gcd gcd24 gcd5 gcd0gcda integer min define gcd0 definition standard properties gcd function equation universally valid elementary properties gcd function theorem alternat ive characterization gcda theorem integers gcda smallest positive element set linear combinations proof smallest positive linear combination equation implies mod qs qax qx bqy mod linear combination mod mod smallest positive linear combination analogous reasoning common divisor gcda equation implies gcd gcda divides linear combination gcda imply gcd combining gcd gcda yields gcda conclude greatest common divisor corollary integers gcda proof corollary equation gcd linear combination theorem corollary integers nonnegative integer gcdan gcda proof corollary trivial gcdan smallest positive element set anx bny times smallest positive element set corollary positive integers gcda proof proof left exercise prime integers integers prime common divisor gcdaprime divisors divisors theorem states integers prime integer product prime theorem integers gcda gcdb gcdab proof theorem exist integers multiplying equations rearranging abx pybx yax pyy positive linear combination appeal theorem completes proof integers n1 nk pairwise prime gcdni unique factorization elementary fact divisibility primes theorem primes integers proof assume purpose contradiction gcda gcdb divisors assumption divides theorem implies gcd contradicting assumption implies gcdab contradiction completes proof consequence theorem integer unique factorization primes theorem unique factorization composite integer written product form prime positive integers proof proof left exercise number uniquely factored exercises prove infinitely primes hint primes divide exercises prove exercises prove prime gcdk exercises prove corollary exercises prove prime conclude integers primes mod exercises prove integers mod mod mod prove assumptions mod implies mod integers exercises integer integer kth power exists integer ak nontrivial power kth power integer determine bit integer nontrivial power time polynomial exercises prove equations œ3110 exercises gcd operator associative prove integers gcda gcdb gcdgcd exercises prove theorem exercises efficient algorithms operations dividing bit integer shorter integer remainder bit integer divided shorter integer algorithms time o2 exercises efficient algorithm convert bit binary integer representation argue multiplication vision integers length takes time binarytodecimal conversion performed time lg hint divide conquer approach obtaining halves result separate recursions greatest common divisor euclids algorithm computing greatest common divisor integers efficiently analysis running time brings surprising connection fibonacci numbers yield wors tcase input euclids algorithm restrict nonnegative integers restriction justified equation states gcda gcda principle compute gcda positive integers prime factorizations exponents set primes exercise asks algorithms factoring polynomial time approach computing greatest common divisors yield efficient algorithm euclids algorithm computing greatest common divisors based theorem theorem gcd recursion theorem nonnegative integer positive integer gcda gcdb mod proof gcd gcdb mod divide equation equal nonnegative gcda gcd mod gcda equation mod qb mod linear combination equation implies mod mod corollary implies gcdb mod equivalently showing gcdb mod gcd gcdb mod mod qb mod linear combination mod equation conclude gcda corollary equivalently equation combine equations completes proof euclids algorithm elements euclid circa describes gcd algorithm earlier origin euclids algorithm expressed recursive program based directly theorem inputs arbitrary nonnegative integers euclidareturn return euclidb mod running euclid computation gcd30 euclid30 euclid219 euclid93 euclid30 computation thr recursive invocations euclid correctness euclid theorem fact algorithm returns equation implies gcd gcda algorithm recurse indefini tely argument strictly decreases recursive nonnegative euclid terminates correct answer running time euclids algorithm analyze worstcase running time euclid function size assume loss generality assumption justified observation euclida recursive euclidb argument argument euclid spends recursive swapping guments proceeds procedure terminates recursive mod running time euclid proportional number recursive calls analysis fibonacci numbers fk defined recurrence lemma invocation euclida performs recursive calls fk2 fk1 proof proof induction basis inductionf3 mod recursive argument strictly larger assumption holds recursive assume inductively lemma true recursive calls prove true recursive calls euclida calls euclidb mod recursively turn recursive calls inductive hypothesis implies fk1 proving lemma mod fk mod implies mod fk1 fk fk2 theorem corollary lemma theorem lamés theorem integer fk1 euclid fewer recursive calls upper bound theorem consecutive fibonacci numbers worstcase input euclid euclid f3 recursive fk1 mod fk fk1 gcdfk1 fk gcdfk fk1 mod fk gcd fk fk1 euclidfk1 fk recurses times meeting upper bound theorem fk golden ratio defined equation number recursive calls euclid olg exercise tighter bound euclid applied bit numbers perform arithmetic operations o3 bit operations assuming multiplication division bit numbers o2 bit operations problem asks o2 bound number bit operations extended form euclids algorithm rewrite euclids algorithm compute dditional extend algorithm compute integer coefficients note negative coefficients computation modular multiplicative invers procedure extendedeuclid takes input pair nonnegative integers returns triple form satisfies equation extendedeuclidareturnextendedeuclidb mod return figure illustrates execution extended euclid computation gcd99 šfigure operation extendedeuclid inputs level recursion values inputs computed values returned triple returned triple computation higher level recursion extended euclid99 returnsgcd99 gcd99 extendedeuclid procedure variation euclid procedure equivalent test euclid extendedeuclid returns coefficientsextendedeuclid computes gcd mod euclid case gcda gcdb mod start rewriting equation equation equation choosing satisfies equation proving correctness extendedeuclid number recursive calls clid equal number recursive calls extendedeuclid running mes euclid extendedeuclid onstant factor number recursive calls olg exercises prove equations imply equation exercises compute values extendedeuclid899 returns exercises prove integers gcda gcda kn exercises rewrite euclid iterative form constant memory stores constant number integer values exercises invocation euclida log recursive calls improve bound log gcda exercises extendedeuclid fk1 fk return prove answer correct exercises define gcd function tw arguments recursive equation gcd a0 gcd a0 gcda1 gcd function returns answer independent order arguments integers x0 gcda0 a0x0 a1x1 anxn number divisions performed algorithm lgmax a0 exercises define lcm common multiple integers nonnegative integer multiple ai compute lcm efficiently twoargumen gcd operation subroutine exercises prove n1 n3 n4 pairwise relativel prime gcdn1n2 n3n4 gcd n1n3 n2n4 generally n1 nk pairwise prime set lg pairs numbers derived prime modular arithmetic informally modular arithmetic arithmetic usual integers working modulo result replaced elementequivalent modulo replaced mod informal model sufficient stick operations ddition subtraction multiplication formal model modular arithmetic framework group theory finite groups group set binary operation defined properties hold closure identity element called identity group associativity inverses exists unique element called inverse familiar group integers operation addition identity inverse group satisfies commutative law abelian group group satisfies finite group groups defined modular addition multiplication form finite abelian groups addition multiplication modulo positive integer groups based equivalence classes integers modulo defined define group zn suitable binary operations redefining ordinary operations addition multiplication easy define addition multiplication operations zn equivalence cla integers uniquely determines equivalence class sum product mod mod mod mod define addition multiplication modulo denoted subtraction defined zn abn division complicated facts stify common convenient practice nonnegative element equi valence class representative performing computations zn addition subtraction ltiplication performed usual representatives result replaced represen tative class mod definiti addition modulo define additive group modulo zn size additive group modulo zn figure operation table group z6 figure finite groups equivalence classes denoted representative elements group z6 group theorem zn finite abelian group proof equation zn closed associativity commutativity follow associativity commutativity nbn ncn identity element zn additive inverse element element definition multiplication modulo define multiplicative group modulo elements group set elements zn prime defined note kn mod integers exercise gcda implies gcd kn integers kn set defined group group operation multiplication modulo denote element a15 denotefigure group mod working identity group theorem finite abelian group proof theorem implies closed associativity commutativity proved proof theorem identity element existence inverses element output extendedeuclida equivalently mod multiplicative inverse modulo proof inverses uniquely defined deferred corollary computing ltiplicative inverses suppose extendedeuclida returns mod multipli cative inverse modulo working groups zn remainder chapter follow convenient practice denoting equivalence classes representative elements denoting operations usual arithmetic notations juxtaposition equivalences modulo interpreted equations zn statements equivalent mod convenience refer group operation understood context refer groups zn zn multiplicative inverse element denoted mod division defined equation ab1 mod mod mod mod size denoted function eulers phi function satisfies equation runs primes dividing including prime prove formula intuitivel list remaindersprime divides cross multiple list prime divisorsprime composite subgroups group group subgroup integers form subgroup integers operation addition theorem tool recognizing subgroups theorem nonempty closed subs finite group subgroup finite group nonempty subset subgroup proof proof left exercise set forms subgroup z8 nonempty closed operation closed theorem extremely usef ul constraint size subgroup omit proof theorem lagranges theorem finite group subgroup divisor subgroup group proper subgroup corollary analysis mi llerrabin primality test procedure corollary proper subgroup finite group subgroups generated element theorem interesting produce subgroup finite group choose element elements generated group operation define ak group z6 sequence group zn ak ka mod group ak ak mod subgroup generated denoted defined ak generates subgroup generator finite finite subset including associativity implies ai ai closed theorem subgroup z6 order group denoted orda defined smallest positive integer theorem finite group order element equal size subgroup generates orda proof orda atk ak ak ai elements suppose purpose contradiction ai satisfying aik ajk implies ait ajt contradiction positiv element sequence distinct conclude orda corollary sequence periodic period orda ai mod consistent corollary define a0 ai ai mod orda integers corollary finite group identity proof lagranges theorem implies mod orda a0 exercises draw group operation tables groups z4 groups isomorphic exhibiting onetoone correspondence elements mod mod exercises prove theorem exercises prime positive integer pe1 exercises function defined fax mod permutation exercises list subgroups z9 solving modular linear equations problem finding solutions equationapplications problem procedure finding keys rsa publickey cryptosystem assume values modulo satisfy equation solution denote subgroup zn generated mod equation solution lagranges theorem theorem tells divisor theorem precise characterization theorem positive integers gcda zn proof showing recall extendedeuclid produces integers mod multiple belongs multiple multiple multiple element mod integer integer equation combining observe multiples inclusive corollary equation mod solvable unknown gcda corollary equation mod distinct solutions modulo gcda solutions proof mod solution theorem orda corollary theorem imply sequence ai mod periodic period appears times sequence ai modlengthnd block values repeated times increases indices positions mod solutions equation mod theorem gcda suppose integers computed extendedeuclid equation mod solutions x0 x0 xbd mod proof ax0 axbd mod dbd mod nbecause mod mod x0 solution mod theorem suppose equation mod solvable gcda x0 solution equation equation distinct solutions modulo x0 indproof indvalues x0 xd1 distinct modulo x0 solution mod ax0 modaxi mod ax0 ind mod ax0 mod ax0 mod solution corollary solutions x0 xd1 developed mathema tics needed solve equation mod algorithm prints solutio equation inputs arbitrary positive integers arbitrary integer modularlinearequationsolvera extendedeuclida x0 xbd mod print x0 ind mod print solutions operation procedure equation mod calling extendedeuclid lines œ5 executed compute x0 mod loop lines œ5 prints solutions procedure modularlinearequation solver works computes gcda values axny demonstrating solution equation mod divide equation mod solution corollary checks reports solutions othe rwise computes solution x0 mod theorem solution theorem states solutions adding multiples modulo loop lines œ5 prints solutions x0 spaced modulo modularlinearequationsolver performs olg gcda arithmetic operations extendedeuclid performs olg arithmetic operations iteration loop lines œ5 performs consta number arithmetic operations corollaries theorem specializations corollary gcda equation mod unique solution modulo common case considerable multiplicative inverse modulo corollary gcda equation mod unique solution modulo solution corollary notation mod refer multiplicative inverse modulo prime gcda solution equation mod integer returned extendedeuclid equation gcda implies mod compute mod efficiently extendedeuclid exercises solutions equation mod exercises prove equation mod implies mod gcda condition gcd supplying counterexample gcda exercises change procedure modularlinearequation solver x0 xbd mod work explain exercises fx f0 f1x mod polynomial degree coefficients drawn zp prime zp mod prove fx agx mod polynomial gx degree prove induction polynomial fx degree distinct zeros modulo prime chinese remainder theorem chinese mathematician sun tsu solved problem finding integers leave remaindersdividedsolution solutions form arbitrary integers chinese remainder theorem rrespondence equations modulo set pairwise prime modu liequation modulo product chinese remainder theorem major integer factored n1n2 nk factors pairwise prime chinese remainder theorem descriptive structure theorem describes structure zn identical cartesian product componentwise additi multiplication modulo ith component description yield efficient algorithms working systems efficient terms bit operations working modulo theorem chinese remainder theorem n1n2 nk pairwise prime correspondence zn ai mod mapping onetoone correspondence bijection zn cartesian product operations performed elements zn equivalently performed ktuples performing operations independently coordinate position akproof transforming representations fairly straightforward ak easy requires divisions computing inputs ak bit complicated accomplished defining mi nni mi product njs mi n1n2 ni1ni1 nk defineequation defined mi prime theorem corollary guarantees exists finally compute function ak equation ensures ai mod note mj mod implies mj mod note mod equation appea ling correspondence vector ith coordinate form basis representation sense aici mod aimi mod ai mod wished method computing ais produces result satisfies constraints ai mod correspondence onetoone transform direc tions finally equations œ3126 follow directly exercise mod mod mod corollaries chapter corollary n1 nk pairwise prime n1n2 nk integers ak set simultaneous equations ai mod unique solution modulo unknown corollary n1 nk pairwise prime n1n2 nk integers mod mod application chines remainder theorem suppose equations mod mod n1 m1 compute mod mod mod modmod modmod mod figure illustration chinese remainder theorem modulo figure illustration chinese remainder theorem n1 row column modulo mod mod note row column row column equivalent moving row increases moving ght column increases increasing corresponds moving diagonally downward wrapping left work modulo working modulo directly working transformed representation separate modulo computations convenient computations equivalent exercises solutions equations mod mod exercises integers leave remainderswh dividedexercises argue definitions theorem gcda exercises definitions theorem prove polynomial number roots equation fx mod equal product number oots equations fx mod n1 fx mod fx mod nk powers element natural multiples element modulo natural sequence powers modulo modulo indexing sequence a0 mod ith ai mod powers modulo mod powers modulo mod denote subgroup generated repeated multiplication order modulo denote order ord72 definition euler phi function size translate corollary notation eulers theorem specialize prime fermats theorem theorem eulers theorem integer theorem fermats theorem prime proof equation prime corollary applies element zp zp mod prime element power modulo primitive root generator primitive root modulo primitive root modulo possesses primitive root group cyclic omit proof theorem proven niven zuckerman theorem values cyclic primes positive integers primitive root element exists gz mod called discrete logarithm modulo base denote ind nga theorem discrete logarithm theorem primitive root equation gx mod holds equation mod holds proof suppose mod kn integer gx gykn mod gnk mod mod nby eulers theorem mod conversely suppose gx mod sequence powers generates element corollary implies sequence powers periodic period gx mod mod discrete logarithms simp lify reasoning modular equation illustrated proof theorem theorem odd prime equation solutions proof theorem implies primitive root equation written noting ind ng1 observe theorem implies equation equivalent solve equation unknown indngx apply methods equation pe1 pe1 letting gcd2 gcd2 pe1 noting theorem equation solutions equation solutions inspection number nontrivial square root modulo satisfies equation mod equivalent trivial square roots modulo nontrivial square root modulo llowing corollary theorem correctness proof millerrabin primalitytesting procedure corollary exists nontrivial square root modulo composite proof contrapositive theorem exists nontrivial square root modulo odd prime power odd prime mod mod square roots modulo trivial prime finally nontrivial square root exist composite raising powers repeated squaring frequently occurring operation numbertheoretic computati ons raising number power modulo number modular exponentiation precisely efficient compute mod nonnegative integers positive integer modular exponentiati essential operation primality testing routines rsa publickey cryptosystem method repeated squaring solves problem efficiently ing binary representation bk1 b0 binary representation binary representation bits long bit b0 bit procedure computes mod increased doublings incrementations modularexponentiationa bk1 b0 binary representation downto mod mod return essential squaring iteration explains repeated squaringalgorithm computes sequence values modulo figure sequence exponents row table labeled figure modularexponentiation computing mod values execution loop final result variable needed algorithm included explanatory purposes algorithm maintains follo wing twopart loop invariant prior iteration loop lines œ9 prefix bk1 bi1 binary representation mod loop invariant initialization initially prefix bk1 bi1 corresponds a0 mod maintenance denote values iteration loop values prior iteration iteration updates correct prior iteration mod ac2 mod a2c mod mod mod ac2a mod a2c1 mod mod case mod prior iteration termination termination prefix bk1 b0 binary representation mod mod inputs bit numbers total numbe arithmetic operations required total number bit operations required o3 exercises draw table showing order element pick smallest primitive root compute table ind gx exercises modular exponentiation algor ithm examines bits left left exercises assuming explain compute mod procedure modularexponentiation rsa publickey cryptosystem publickey cryptosystem crypt messages communicating parties eavesdropper overhears encrypted messages decode publickey cryptosystem enables party append unforgeable digital signature electronic message signature electronic version handwritten signature paper document easily checked forged loses validity bit message altered authentication identity signer contents signed message perfect tool electronical ly signed business contracts electronic checks electronic purchase orders electronic communications authenticated rsa publickey cryptosystem based dramatic difference ease finding large prime numbers difficulty factoring product large prime numbers describes efficient procedure finding large prime numbers discusses problem factoring large integers publickey cryptosystems publickey cryptosystem participant public key secret key key piece rsa cryptosystemeach key consists pair integers participants alice bob trad itionally cryptography examples denote publ secret keys pa alice pb sb bob participant creates public secret keys secret key secret reveal public key publish fact convenient assume everyones public key public directory participant easily public key participant public secret keys functions applied message denote set permissible messages set finitelength bit sequences simplest original form ulation publickey cryptography require public secret keys onetoone functions function alices public key pa denoted pa function secret key denoted functions pa permutations assume functions pa efficiently computable key pa public secret keys participant matched pair functions inverses message transforming keys pa successively order yields message publickey cryptosystem essential alice compute function practical time privac mail encrypted alice authenticity alices digital gnatures rely assumption alice compute requirement alice secret loses uniqueness cryptosystem provide ith unique capabilities assumption alice compute hold pa compute pa inverse function efficiently major difficulty designing workable publickey cryptosystem figuri create reveal transformation pa revealing compute inverse transformation publickey cryptosystem encryption works figure suppose bob wishes send alice message encrypted lik unintelligible gibberish eavesdropper scenario sending message figure encryption public key bob encrypts message alices public key pa transmits ciphertext pam alice eavesdropper captures transmitted ciphertext gains alice receives decrypts secret key original message sac bob obtains alices public key pa public directory directly alice bob computes ciphertext pam message sends alice alice receives ciphertext applies secret key retrieve original message sac pa inverse functions alice compute alice compute alice compute encryption pa protected disclosure alice digital signatures easy impl ement formulation publickey cryptosystem note ther ways approaching problem constructing digital signatures suppose alice wishes send bob digitally signed response digitalsignature scenario proceeds figure figure digital signatures publickey alice signs message appending digital signature sam transmits messagesignature pair bob verifies checking equation pa equation holds accepts message signed alice alice computes digital signature message secret key equation sam alice sends messagesignature pair bob bob receives verify originated alice alices public key verify equation pa alices bob public key equation holds bob concludes message signed alice equation doesnt hold bob concludes message digital signature corrupted transmission errors pair attempted forgery digital signature authentication signers identity authentication contents signed ssage analogous handwritten signature written document property digital signature verifiable access signers public key signed message verified party passed parties verify signature message electronic check alice bob bob verifies alices signature check check bank verify signature funds transfer note signed message encrypted message clear protected disclosure composing protocols encryption signatures create messages signed encrypted signer appends digital signature message encrypts messagesignature pair public key intended recipient recipient decrypts received message secret key original message digital signature verify signature public key signer combined process paperbased systems sign paper document seal document inside paper envelope opened intended recipient rsa cryptosystem rsa publickey cryptosystem participant creates public secret keys procedure select random large prime numbers primes bits compute equation select small odd integer prime equation equals compute multiplicative inverse modulo corollary guarantees exists uniquely defined technique compute publish pair rsa public key secret pair rsa secret key scheme domain set zn transformation message public key transformation ciphertext secret key equations apply encryption signatures create signature signer applies secret key message sign ciphertext verify signature public key signer applied message encrypted publickey secretkey operations implemented procedure modularexponentiation analyze running time operations assume public key secret key satisfy lg o1 lg lg applying public key requires o1 modular multiplications o2 bit operations applying secret key requires modular multiplications o3 bit operations theorem correctness rsa rsa equations define inverse transformations zn satisfying equations proof equations zn psm spm med mod multiplicative inverses modulokp integer mod med mp1kq1 mod m1k q1 mod theorem mod med mod mod med mod med mod corollary chinese remainder theorem med mod security rsa cryptos ystem rests large difficulty factoring large integers adversary factor modulus public key derive secret key public key ing knowledge factors creator public key factoring large integers easy breaking rsa cryptosystem easy onverse statement factoring large integers hard breaking rsa hard unproven decades easier method break rsa publickey cryptosystem factor modulus factoring large integers surprisingly difficult randomly selecting multiplying bit primes create public key broken feasible time current technology absence fundamental eakthrough design numbertheoretic algorithms implemented car recommended standards rsa cryptosystem capable providing high degree security applications order achieve security rsa cryptosystem advisable work integers bits long resist advances art factoring time writi rsa moduli commonly range bits create moduli sizes large primes efficiently addresses problem efficiency rsa hybrid keymanagement mode fast publickey cryptosystems syst encryption decryption keys identical alice wishes send long message bob privately selects random key fast nonpublickey cryptosystem encrypts obtaining ciphertext long short encrypts bobs public rsa key short computing pbk fast faster computing pbm transmits pbk bob decrypts pbk decrypt obtaining hybrid approach digital signatures efficiently approach rsa combined public oneway hash function hša function easy compute computat ionally infeasible messages hm hm hm short bit fingerprint message alice wishes sign message applies fingerprint hm encrypts secret key sends sahm bob signed version bob verify signature computing hm verifying pa applied sahm received equals hm create messages fingerprint computationally infeasible alter signed message preserve validity signature finally note certificates distributing public keys easier assume trusted authority public key alice signed message certificate stating alices public key pa certificate selfauthenticating alice include certificate signed message recipient alices public key order verify gnature key signed recipient alices key alices exercises rsa key set secret key encryption message exercises prove alices public exponent adversary obtains alices secret exponent adversary factor alices modulus time polynomial number bits asked prove interested result remains true condition removed miller exercises prove rsa multiplicative sense pam1 pam2 pam1 mod fact prove adversary procedure efficiently decrypt percent messages zn encrypted pa employ probabilistic algorithm decrypt message encrypted pa high probability primality testing problem finding large primes discussion density primes proceed examin plausible incomplete approach primality testing effectiv randomized primality test miller rabin density prime numbers applications cryptography large random primes fortunately large primes rare timec onsuming test random integers size prime prime distribution function specifies number primes equalprime numbers equal prime number theorem approximation theorem prime number theorem approximation accurate estimates small number theorist small number prime number theorem estim ate probability randomly chosen integer turn prime examine integers chosen randomly order prime length bit prime require testingrandomly chosen bit numbers primality figure cut half choosing odd integers remainder problem determining large odd integer prime notational onvenience assume prime factorization prime factors e1 positive integers prime e1 simple approach problem testing primality trial division dividing integer integers greater skipped easy prime trial divisors divides assuming trial division takes constant time worstcase running time exponential length recall encoded binary bits lgn trial division works small small prime factor works trial division advantage determines prime composite determines prime factors composite interested onl finding number prime composite concerned finding prime factorization computing prime factorization nu mber computationally expensive surprising easier number prime determine prime factorization number prime pseudoprimality testing method primality testing works fact good practical applications refinement method removes small defect presented denote nonzero elements zn prime basea pseudoprime composite fermats theorem theorem implies prime satisfies equation satisfy equation composite surprisingly converse holds criterion forms perfect test primality test satisfies equation declare composite otherwis output guess prime fact prime base2 pseudoprime procedure pretends manner checking primality procedure modularexponentiation input assumed odd integer greater pseudoprimen modularexponentiation2 mod return composite return prime hope procedure errors type composite correct prime error base2 pseudoprime procedure err surpri singly rarely values errs values probability program error randomly chosen bit number precise estimates pomerance number base2 pseudoprimes ze estimate randomly chosen bit number called prime procedure chance base2 pseudoprime randomly chos bit number called prime chance base2 pseudoprime large prime application practical purposes wrong choosing large numbers random pseudoprime output prime numbers tested primality randomly chosen approach testing primality sh cleverness randomization yield primalitytesting routine works inputs elimin ate errors simply checking equation base number composite integers satisfy equation integers carmichael numbers carmichael numberscarmichael numbers extremely rare exercise helps explain rare improve primality test fooled carmichael numbers millerrabin randomized primality test millerrabin primality test overcomes problems simple test pseudoprime modifications randomly chosen base values base computing modular exponentiation notices nontrivial square root modulo discovered final set squarings stops outputs composite corollary justifies detecting composites manner pseudocode millerrabin primality test input odd number tested primality number randomly chosen base values code randomnumb generator random random1 returns randomly chosen integer satisfying code auxiliary procedure witness witness true witness compositeness nšthat prove manner composite test witness extension effective test an1 mod formed basis pseudoprime justify construction witness millerrabin primality test tu odd binary representation binary representation odd integer zeros mod compute an1 mod computing mod squaring result times successively witnessa tu odd x0 modularexponentiationamod xi1 xi1 return truereturn true return false pseudocode witness computes an1 mod computing x0 mod squaring result times row loop lines œ6 induction sequence x0 values computed satisfies equation mod an1 mod squaring step performed loop rminate early lines œ6 detect nontrivial square root discovered algorithm stops returns true lines œ8 return true computed an1 mod equal pseudoprime procedure returns composite case returns false havent returned true lines argue witness returns true proof composite constructed witness returns true lin discovered an1 mod prime fermats theorem theorem an1 mod prime equation an1 mod proof fact witness returns true lin discovered xi1 nontrivial square root modulo xi1 mod mod corollary states composite nontri vial square root modulo demonstration xi1 nontrivial square root modulo proof composite completes proof correctne witness invocation witness outputs true surely composite proof composite easily determined point alternativ description behavior witness function sequence x0 analyze efficiency miller rabin primality test note witness compute rest sequence xi1 xi2 positions sequence cases sequence return true witness compositeness fermats theorem sequence return false witness compositeness sequence ends non1 equal return false witness compositeness sequence ends non1 return true witness compositeness nontrivial square root examine millerrabin primality based witness assume odd integer greater millerrabinnrandom1 witnessa return composite return prime surely procedure millerrabin probabilistic search proof composite main loop picks random values picked witness compositeness millerrabin outputs composite output correct correctness witne witness trials millerrabin assumes witnesses assumed prime output correct large small chance procedure unlucky choice witnesses exis illustrate operation millerrabin carmichael number supposing chosen base figure witness computes x0 a35 mod computes sequence nontrivial square root discovered squaring step a280 mod a560 mod witness compositeness witness7 returns true millerrabin returns composite bit number millerrabin requires arithmetic operations os3 bit operations requires asymptotically work modular exponentiations error rate miller rabin primality test millerrabin outputs prime small chance error pseudoprime chance error depend bad inputs procedure depends size luck draw choosing base values test ringent simple check equation expect general principles error rate small randomly chosen integers theorem presents precise argument theorem odd composite number num ber witnesses compositeness proof proof numbe nonwitnesses implies theorem start claiming nonwitness member nonwitness satisfy an1 mod equivalently an2 mod solution equation mod an2 corollary gcda turn implies gcd member nonwitnesses belong complete proof nonwitnesses contained contained proper subgroup recall proper subgroup subgroup equal corollary number nonwitnesses number witnesses proper subgroup nonwitnesses break proof cases case exists xn1 mod carmichael number earlier carmichael numbers extremely rare case case arises practice chosen randomly tested primality nonempty closed multiplication modulo subgroup theorem note nonwitness belongs nonwitness satisfies an1 mod proper subgroup case carmichael number case extremely rare practice millerrabin test pseudoprimality test efficiently determine compositeness carmichael numbers case prime power suppose contrary prime derive contradiction assumed odd odd theorem implies cyclic group generator equation gn1 mod discrete logarithm theorem theorem implies mod pe1 contradiction pe1 divisible prime prime power odd composite number prime power decompose product n1n2 n1 odd numbers greater prime ways doesnt matter choose choose recall define tu odd input procedure witness computes sequence computations performed modulo pair integers acceptable mod acceptable pairs exist odd choose acceptable pair pick largest exists acceptable pair acceptable pair closed multiplication modulo subgroup corollary divides nonwitness member sequence produced nonwitness jth position maximality acceptable nonwitness chose existence demonstrate exists mod mod n1 corollary chinese remainder theorem corollary simultaneously satisfying equations mod n1 mod mod n1 mod corollary mod n1 implies mod mod implies mod mod remains working separately modulo n1 modulo working modulo n1 observe gcdv gcdv n1 doesnt common divisors doesnt common divisors n1 mod n1 gcdw n1 working modulo observe mod implies gcdw combine theorem implies gcd n1n2 gcdw finish case conclusion proper subgroup case numbe witnesses compositeness theorem odd integer positive integer probability millerrabinn errs proof theorem composite execution loop lines œ4 probability discovering witness compositeness millerrabin error ly unlucky discovering witness compositeness iterations main loop probability string misses choosing suffice imag inable application large primes applying millerrabin randomly chosen large integers argued choosing small lead erroneous randomly chosen odd composite integer expected number nonwitn esses compositeness smaller integer chosen randomly proven number nonwitnesses improved version theorem exist integers number nonwitnesses exercises prove odd integer prime prim power exists nontrivial square root modulo exercises strengthen eulers theorem form mod defined prove composite number carmichael number smallest carmichael number lcm2divides prove carmich ael numbers square free divisible square prime product primes reason common exercises prove nontrivial square root modulo gcdx gcdx nontrivial divisors integer factorization suppose integer factor decompose product primes primality test preceding composite doesnt prime factors factoring large integer difficult simply determining prime composite infeasible todays supercomputers algorithms factor arbitrary bit number pollards rho heuristic trial division integers guaranteed factor completely number work procedure factor number b4 unlucky procedure heuristic running time success guaranteed procedure effective practice advantage pollardrho procedure constant number memory locations easily implement pollardrho progr ammable pocket calculator factors small numbers pollardrhonrandom0 truemod gcdyprintk procedure works lines œ2 initialize randomly chosen zn loop iterates forever searching factors iteration loop recurrence produce infinite sequence correspondingly incremen ted code written subscripted variables clarity program works subscripts dropped maintained modification procedure constant number memory locations program saves generated variable values saved subscripts powers x4 x8 x16 saves saves equal variable initialized doubled updated sequence subscript saved lines œ10 factor saved current computes greatest common divisor gcdy nontrivial divisor checked prints procedure finding factor mewhat mysterious note pollardrho prints incorrect answer number prints nontrivial divisor pollardrho print guarantee produce good reason expect pollardrho print factor iterations loop composite expect procedure discover divisors factor completely n14 updates prime factor largest analysis behavior procedure studying long takes random sequence modulo repeat zn finite sequence depends previous sequence eventually repeats reach cycle xi1 xj1 xi2 xj2 reason rho heuristic figure sequence xj1 drawn tail rho cycle xj1 body rho figure pollards rho heuristic values produced recurrence mod starting prime factorizationheavy arrows iteration steps executed fore factor discovered light arrows point unreached values iteration illustrate rho shape shaded values values stored pollardrho factor discovered reaching x7 gcd63computed repeated factor discovered repeated values produced recurrence modulo equivalent modulo x4 x7 equivalent modulo values produced recurrence modulo equivalent modulo chinese remainder theorem node corresponds pair nodes question long takes sequence repeat modify argument purpose estimation assume function fnx mod behaves random function random assumption yields consistent observed behavior pollardrho independently drawn zn uniform distribution zn birthdayparadox analysis expected number steps sequence cycles required modification nontrivial factor gcdp np factorization e1 smallest prime factor good mind sequence induces sequence modulo mod defined arithmetic ope rations squaring subtraction modulo compute modulo view sequence smaller version wh happening modulo xi1 mod fnxi mod mod mod mod exercise mod mod mod explicitly computing sequence sequence defined obeys recurrence sequence reasoning expected number steps sequence repeats small compared sequence repeat sequence sequence repeats elements sequence equivalent modulo equivalent modulo figure parts illustration denote repeated sequence denote length cycle produced smallest values arguments expected values note xtui xti gcdxtui xti pollardrho saved mod cycle modulo saved cycle modulo eventually set greater procedure entire loop cycle modulo changing factor discovered runs stored modulo mod factor factor occasionally happen multiple discovered expected values expected number steps required produce factor reasons algorithm perform expected heuristic analysis running time rigorous ssible cycle values modulo larger case algorithm performs correctly slowly desired practice issue moot divisors produced algorithm trivial factors suppose prime happen values identical values factor revealed gcd operation reveals factor factors revealed time trivial factor revealed useless problem insignificant practice nece ssary heuristic restarted recurrence form mod values avoided reasons values fine analysis heuristic rigorous recurrence random procedure performs practice efficient heuristic analysis method choice finding small prime factors large number factor bit composite number completely prime factors n12 expect pollardrho require n14 arithmetic operations n142 bit operations pollardrhos ability small factor expected number arithmetic operations appealing feature exercises referring executio history figure pollardrho print factor exercises suppose function zn zn initial x0 zn define xi1smallest values xti xtui terminology pollards rho algorithm length tail length cycle rho efficient algorithm determine analyze running time exercises steps expect pollardrho require discover factor form prime exercises disadvantage pollardrho written requires gcd computation step recurrence batch gcd computations accumulating product values row product gcd computation carefully implement idea works batch size pick effective working bit number problems binary gcd algorithm computers operations subtraction testing parity odd binary integer halving performed computing remainders problem investigates binary gcd algorithm avoids remainder computations euclids algorithm prove gcda gcda2 prove odd gcda gcda prove odd gcda gcda design efficient binary gcd algorithm input integers runs olg time assume subtractio parity test halving performed unit time problems analysis bit ope rations euclids algorithm ordinary paper pencil algorithm long division dividing yields quotient remainder method requires o1 lg lg bit operations define µa lg lg number bit operations performed euclid reducing problem computing gcd computing gcdb mod cµa µb mod large constant euclida requires oµa bit operations general o2 bit operations applied bit inputs exercises algorithms fibonacci numbers problem compares efficiency methods computing nth fibonacci number assume cost adding subtracting multiplying numbers o1 independent size numbers running time straightforward recursive method computing based recurrence exponential compute time memoization compute olg time integer addition multiplication hint matrix powers assume adding bit numbers takes time multiplying bit numbers takes time running tim methods reasonable cost measure elementary arithmetic operations problems quadratic residues odd prime number quadratic residue equation mod solution unknown quadratic residues modulo prime define legendre symbol quadratic residue modulo prove efficient algorithm dete rmining number quadratic residue modulo analyze efficiency algorithm prove prime form quadratic residue ak1 mod square root modulo time required square root quadratic residue modulo efficient randomized algo rithm finding nonquadratic residue modulo arbitrary prime member quadratic residue arithmetic operations algorithm require average chapter notes niven zuckerman provide excellent introduction elementary number theory knuth good discussion algorithms finding greatest common divisor basic numbertheoretic algorithms bach riesel provide surveys computational number theory dixon overview factorization primality testing conference proceedings edited pomerance excellent survey articles bach shallit provided exceptional overview basics computational number theory knuth discusses origin euclids algor ithm appears book propositions greek mathematician euclids elements written euclids description derive algorithm eudoxus euclids algorithm hold honor ing oldest nontrivial algorithm rivaled algorithm multiplication ancient egyptians shallit chronicles history analysis euclids algorithm knuth attributes special case chinese remainder theorem theorem chinese mathematician sunts lived uncertain special case greek mathematician nichomachus generalized chhin chiushao chinese remainder theorem finally stated prove generality euler randomized primalitytesting algo rithm presented miller rabin fastest randomized primalityt esting algorithm constant factors proof theorem slight adaptation suggested bach proof stronger result millerrabin monier randomization appears polynomialtime primalitytesting algorithm fastest deterministic primalitytesting algorithm cohenlenstra version primality test adleman pomerance rumely testing number length lgn primality runs lg nolg lg lg time superpolynomial problem finding large random primes nicely discussed article beauchemin brassard crépeau goutier pomerance concept publickey cryptosystem diffie hellman rsa cryptosystem proposed rivest shamir adleman field cryptography blossomed understanding rsa cryptosystem deepened modern implementations sign ificant refinements basic techniques presented addition tec hniques developed proving cryptosystems secure goldwasser micali randomization effectiv tool design secure publickey encryption schemes signature schemes goldwasser micali rivest digitalsignature scheme conceiva ble type forgery provably difficult factoring menezes provide overview applied cryptography rho heuristic integer factorization invented pollard version presented variant proposed brent algorithms factoring large num bers running time grows roughly exponentially cube root length number factored general numberfield seive factori algorithm developed buhler extension ideas numberfield sieve factoring algorithm pollard lenstra refined coppersmith efficient algorithm general large input difficult rigorous analysis algorithm reasonable assumptions derive runningtime estimate l13 n1902 o1 ellipticcurve method lenstra effective inputs number field sieve method pollards rho method small prime factor method time estimated chapter string matching overview finding occurrences pattern text problem arises equently textediting programs typically text document ing edited pattern searched word supplied user efficient algorithms problem greatly aid responsiveness textediting program stringmatching algorithms search patterns dna sequences formalize stringmatching problem assume text array length pattern array length assume elements characters drawn finite alphabet character arrays called strings characters pattern occurs shift text equivalently pattern occurs position textoccurs shift valid shift invalid shift stringmatching problem problem finding valid shifts pattern occurs text figure illustrates definitions figure stringmatching problem goal occurrences pattern abaa text abcabaabcabac pattern occurs text shift shift valid shift character pattern connected vertical matching character text matched characters shaded naive bruteforce algorithm review string matching algorithm chapter performs preprocessing based pattern finds valid shifts phase matching figure preprocessing matching times algorithms chapter total running time algorithm sum preprocessing matching times presents interesting stringmatching gorithm rabin karp worstcase running time algorithm naive method works average practice generalizes nicely patternmatching problems describes stringmatc hing algorithm constructing finite automaton desi gned search occurrences pattern text algorithm takes preprocessing time matching time cleverer knuthmorr ispratt kmp algorithm presented kmp algorithm matching time reduces preprocessing time algorithm preprocessing timematching time naive rabinkarp finite automaton knuthmorrispratt figure stringmatching algorithms chapter preprocessing matching times notation terminology read sigmastar denote set finitelength strings formed characters alphabet chapter finitelength strings zerolength string denoted belongs length string denoted concatenation strings denoted xy length consists characters characters string prefix string denoted wy string note string suffix string denoted yw string suffix prefix string abcca cca abcca note strings character xa ya note transitive relations lemma lemma overlappingsuffix lemma suppose strings proof figure graphical proof figure graphical proof lemma suppose parts figure illustrate cases lemma vertical lines connect matching regions shaded strings brevity notation denote kcharacter prefix pattern p0 denote kcharacter prefix text tk notation state stringmatching problem finding shifts range nm tsm pseudocode equallength strings compared equality primitive operation strings compared left comparison stops mismatch discovered assume time test linear function number matc hing characters discovered precise test assumed time length longest string write handle case characters compared match takes positive time perform comparison naive stringmatching algorithm naive algorithm finds valid shifts loop checks condition values naivestringmatchert lengtht lengthp print pattern occurs shift naive stringmatching procedure inte rpreted graphically sliding template pattern text noting shifts characters template equal corres ponding characters text illustrated figure loop considers shift explicitly test determines current shift valid test involves implicit loop check character positions positi ons match mismatch prints valid shift figure operation naive string matcher pattern aab text acaabc imagine pattern template slide text successive alignments naive string matcher vertical lines connect regions match hown shaded jagged connects mismatched character occurrence pattern shift procedure naivestringmatcher takes time bound tight worst case text string string pattern values shift implicit loop compare characters execute times validate shift worstcase running time running time naive stringmatcher equal matchi time preprocessing naivestringmatcher optimal procedure problem chapter sh algorithm worstcase preprocessing time worstcase matching time naive stringmatcher inefficient gained text values valuable aaab valid shiftsvalid sections examine ways effective sort exercises comparisons naive string matcher pattern text exercises suppose characters pattern accelerate naive stringmatcher time ncharacter text exercises suppose pattern text randomly chosen strings length dary alphabet expected number charactertocharacter comparisons implicit loop naive algorithm executions loop assume naive algorithm stops comparing characters shift mismatch entire pattern matched randomly chosen strings naive algorithm efficient exercises suppose pattern occurrences gap character match arbitrary string characters length pattern bac occurs text cabccbacbacab note gap character occur arbi trary number times pattern assumed occur text polynomialtime algorithm determine pattern occurs text analyze running time algorithm rabinkarp algorithm rabin karp proposed stringmatchi algorithm performs practice generalizes algorithms problems twodimensional pattern matching rabinkarp algorithm preprocessing time worstcase running time based assumptions averagecase running time algorithm elementary numbert heoretic notions equivalence numbers modulo number refer relevant definitions expository purposes assume character digit general case ssume character digit radix notation view string consecutive characters representing lengthk number character stri corresponds number dual inte rpretation input characters graphical symbols digits convenient denote digits standard text font pattern denote manner text denote length substring valid shift compute time values total time determine valid shifts time comparing tss moment worry possibility tss large numbers compute time horners rulepm t0 computed time compute remaining values tnm time suffices observe ts1 computed constant timeremove highorder digit bring loworder digit supposets1 subtracting m1 removes highorder digit multiplying result shifts number left position adding brings loworder digit constant m1 precomputed time olg techniques application straightforward omtime method adequate execution equation takes constant number arithmetic operations compute time compute t0 tnm time occurrences pattern text preprocessing time matching time difficulty procedure large work conveniently characters assuming arithmetic operation digits long takes constant time unreasonable fortunately simple cure problem figure compute tss modulo suitable modulus computation t0 recurrence performed modulo compute modulo time tss modulo time modulus typically chosen prime fits computer word necessa computations performed single precision arithmetic general dary alphabetchoose dq fits computer word adjust recurrence equation work modulo dm1 mod digit highorder position mdigit text window figure rabinkarp algorithm char acter git compute values modulo text string window length shaded numerical shaded number comput modulo yielding text string values computed modulo position length5 window assuming pattern windows modulo mod windows shaded figure text position occurrence pattern text position spurious hit computing window constant time prev ious window window dropping highorder digit shifting left ltiplying adding low order digit computations performed modulo window computed window solution working modulo perfect mod imply hand mod shift invalid test mod fast heuristic test rule invalid shifts shift mod tested valid spurious hit testing explicitly checking condition large hope spurious hits occur infrequently cost extra checking low procedure ideas precise inputs procedure text pattern radix typically prime rabinkarpmatchert lengtht lengthp dm1 modt0preprocessing mod t0 dt0 mod matching print pattern occurs shift ts1 dts mod procedure rabinkarpmatcher works llows characters interpreted radixd digits subscripts provided clarity program works correctly subscripts dropped initializes highorder digit position mdigit window lines compute mod t0 mod loop lines iterates shifts maintaining invariant executed mod hit check rule possibility spurious hit valid shifts printed checked loop executed time executed ensure loop invariant holds reached computes ts1 mod mod constant time equation directly rabinkarpmatcher takes preprocessing time matching time worst case naive stringmatching algorithm rabinkarp algorithm explicitly verifies valid shift verifications time shifts valid applications expect lid shifts constant applications expected matching time algorithm onm time required process spurious hits base heuristic analysis assumption ducing values modulo acts random mapping zq discussion division hashing difficult formalize prove assumption viable approach assume chosen randomly integers size pursue formalization expect number spurious hits onq chance arbitrary equivalent modulo estimated positions test fails spend time hit expected matching time rabinkarp algorithm omv nq number valid sh ifts running time o1 choose expected number valid shifts small o1 prime chosen larger length pattern expect rabinkarp procedure matching time expected matching time exercises working modulo spurious hits rabinkarp matcher encounter text pattern exercises extend rabinkarp method problem searching text string occurrence set patterns start assuming patterns length generalize soluti patterns lengths exercises extend rabinkarp method handle problem pattern array characters patter shifted vertically horizontally rotated exercises alice copy long nbit file an1 an2 a0 bob nbit file bn1 bn2 b0 alice bob files identical avoid transmitting fast probabilistic check select prime randomly select integeralice evaluates bob evaluates prove chance files hint exercise write values takes asymptotic sense computing lone takes time time string matching finite automata stringmatching algorithms build fini automaton scans text string occurrences pattern presents method building automaton stringmatching automata fficient examine text character constant time text character matching time usedafter preprocessing pattern build automatonis time build automaton large large describes clever problem definition finite automaton examine special stringmatching automaton occurrences pattern text discussion includes details simulate behavior stringmatching automaton text finally construct stringmatching automaton input pattern finite automata finite automaton tuple q0 finite set states q0 start state distinguished set accepting states finite input alphabet function called transition function finite automaton state q0 reads characters input string time automaton state reads input character moves transition state state current state member machine accepted string read input accepted rejected figure illustrates definitions simple twostate automaton figure simple twostate nite automaton state set start state q0 input alphabet tabular representation transition function equivalent statetransition diagram state accepting state blackened directed edges represent transitions edge state state labeled automaton accepts strings odd number precisely string accepted yz ends ak odd sequence ates automaton enters input abaaa including start state accepts input input abbaa sequence states rejects input finite automaton induces function called finalstate function state ends scanning string accepts string function defined recursive relation q0 stringmatching automata stringmatching tomaton pattern automaton constructed pattern preprocessing step search text string figure illustrates construction pattern ababaca assume fixed patternstring brevit dependence notation figure statetransition diagram stri ngmatching automaton accepts strings string ababaca state start state state blackened accepting state directed edge state state labeled represents rightgoing edges forming spine automaton heavy figure correspond successful matches pattern input characters leftgoing edges correspond failing matches edges failing matches convention state outgoing edge labeled transition function pattern string ababaca entries successful matches pa ttern input characters shaded operation automaton text abababacaba text character state automaton processing prefix occurrence pattern position order stringmatching tomaton pattern define auxiliary function called suffix function function mapping length longest prefix suffix max suffix function defined nce string p0 suffix string examples pattern ccaca ccab pattern length definition suffix function define stringmatching automat corresponds pattern state set start state q0 state state accepting state transition function defined equation state character intuitive rationale defining pqa machine maintains invariant operation result proved theorem scanning characters text string machine state length longest suffix prefix pattern character scanned machine transition state ti1 tia proof theorem tia pqa compute length longest suffix tia prefix compute longest suffix pqa prefix state machine length longest prefix suffix read setting pqa maintains desired invariant informal argument rigorous shortly stringmatching automaton figuretransition automaton reads state ababab longest prefix suffix ababab p4 abab clarify operation stringmatching automaton simple efficient program simulating behavior automaton represented transition function finding occurrences pattern length input text stringmatching automat pattern length state set start state ly accepting state state finiteautomatonmatchert lengthtprint pattern occurs shift simple loop structure finiteaut omatonmatcher implies matching time text string length matching time include preprocessing time required mpute transition function address problem proving procedure finiteautomatonmatcher operates correctly operation automaton input text prove automaton state scanning character machine accepting state pattern scanned prove result lemmas suffix function lemma suffixfunction inequality string character xa proof referring figure xa conclusion xa trivially satisfied nonnegativity assume xa definition pr1 dropping xa largest xa figure illustration proof lemma figure xa lemma suffixfunction recursion lemma string character xa pqa proof definition figure pqa xa xa lemma pqa xa xa pqa lemma implies pqa pqa xa pqa pqa xa pqa xa xa pqa figure illustration proof lemma figure pqa xa ready prove main theorem aracterizing behavior stringmatching automaton input text theorem automaton keeping track step longest prefix pa ttern suffix read automaton maintains invariant theorem finalstate function stringmatching automaton pattern input text automaton proof proof induction theorem trivially true t0 t0 t0 assume prove ti1 ti1 denote denote ti1 tia definitions ti1 definition definition pqa definition tia lemma induction ti1 definition ti1 theorem machine enters state largest occurrence pattern scanned conclude fini teautomatonmatcher operates correctly computing transition function procedure computes transition function pattern computetransitionfunctionp lengthpcharacter minmrepeat pqa return procedure computes straightforward manner definition nested loops lines states characters lines set largest pqa code starts largest conceivable min decreases pqa running time compu tetransitionfunction om3 outer loops contribute factor repeat loop times test pqa require comparing characters faster procedures exist time required compute improved utilizing cleverly computed pattern exercise improved procedure computing occurrences lengthm pattern lengthn text alphabet preprocessing time matching time exercises construct stringmatching automaton pattern aabab illustrate operation text string aaababaabaababaab exercises draw statetransition diagram stringmatching automaton pattern ababbabbababbababbabb alphabet exercises pattern nonoverlappable implies state transition diagram stringmatchi automaton nonoverlappable pattern exercises patterns construct finite automaton determines occurrences pattern minimize numbe states automaton exercises pattern gap characters exercise build finite automaton occurrence text matching time knuthmorrispratt algorithm lineartime stringmatching algorithm knuth morris pratt algorithm avoids comput ation transition function altogether matching time auxiliary function precomputed pattern time array transition function computed efficiently amortized sense fly needed roughly speaking state character independent needed compute remark clar ified shortly array entries entries save factor preprocessing time computing prefix function pattern prefix function pattern encapsulates knowledge pattern matches shifts avoid testing useless shifts naive patternmatching algorithm avoid precomputation stringmatching automaton operation naive string matcher figure shift template pattern ababaca text characters matched pattern character fails match text character characters matched determines characters knowing text characters determine shifts invalid gure shift invalid pattern character aligned text character tch pattern character shift figure aligns pattern characters text characters necessa rily match general eful answer question figure prefix function pattern ababaca aligned text characters match matching charac ters shaded connected vertical lines knowledge matc characters deduce shift invalid shift consistent text valid deductions precomputed comparing pattern longest prefix proper suffix p5 precomputed represented array characters matched shift valid shift pattern characters match text characters shift shift shift greater invalid knowledge case shiftsruled case shift dont compare characters characters guaranteed match equation precomputed comparing pattern illustrated figure portion text suffix string equation interp reted largest valid shift turns convenient store number matching characters shift storing speed naive string matching algorithm finiteautomaton matcher formalize precomputation requi red pattern prefix function pattern function max length longest prefix proper suffix figure complete prefix function pattern ababababca figure illustration lemma pattern ababababca function pattern iterating slide template pattern note prefix matches proper suffix p8 figure row dotted vertical drawn p8 successive rows shifts prefix match suffix p8 matched characters shaded vertical lines connect aligned matching characterslemma claims knuthmorrispratt matching algorithm ven pseudocode procedure kmpmatcher modeled finiteautomatonmatcher kmpmatcher calls auxili ary procedure computeprefixfunction compute kmpmatchert lengtht lengthp computeprefixfunctionp number characters matched scan text left character match character matches matched print pattern occurs shift match computeprefixfunctionp lengthp return analysis running times procedures proving procedures correct complicated runningtime analysis running time computeprefixfunction potential method amortized analysis associate potential current state algorithm potential initidecreases executed negative increases execution loop body entering loop incremented iteration loop body holds justifies claim pay execution loop body decrease potential function increases potential function amortized cost loop body lines o1 number outerloop iterations final potential function great initial potential function total actual worstcase running time computeprefixfunction amortized analysis potential function matching time kmpmatcher compared finiteautom atonmatcher reduced time preprocessing pattern keeping actual matching time bounded correctness prefixfunction computation start essential lemma showi iterating prefix function enumerate prefixes proper suffixes prefix defined terms unctional iteration i1q understood sequence stops reached lemma characterizes figure illustrates lemma prefixfunction iteration lemma pattern length prefix function proof prove uq prove equation induction claim relations transitivity establishes claim prove contradiction suppose contrary integer set largest largest denote smallest integer greater choose number greater lemma largest property contradiction proves lemma algorithm computeprefixfunction computes order computationcomputeprefixfunction correct lemma corollary prove computeprefixfunction computes correctly lemma pattern length prefix function proofpr1 pq1 dropping character lemma define subset eq1 eq1pq1 lemma pk1 set eq1 consists values pq1 pk1 eq1 consists values extend pk1 proper suffix corollary pattern length prefix function proof eq1 including extend pk1 proper suffix eq1 nonempty eq1 pk1 definition note lemma eq1 max eq1 equivalently combining equations completes proof finish proof computeprefixfunction computes correctly procedure computeprefixfunction start iteration loop lines condition enforced lines loop entered remains true su ccessive iteration lines adjust correct loop lines searches values point largest set eq1 corollary setset leave set lines set correctly case completes proof corre ctness computeprefixfunction correctness kmp algorithm procedure kmpmatcher viewed reimplementation procedure finiteautomatonmatcher prove code lines kmpmatcher equivalent finiteautomatonmatcher sets stored recomputed argued kmpmatcher simulates behavior finiteautomatonmatcher correctness kmpmatcher correctness finiteautomatonmatcher moment pmatcher correctness kmpmatcher claim check claim pqti definitions pk1 dropping character pqti caseproving claim claim denote entered equivalence lemma justify iteration enumerates elements lines determine examining elements decreasing order code claim ti1 ti1 perform iteration case case maximum element corollary kmpmatcher avoid reference occurrence argument ti1 execution remains valid hint exercise equivalently pa pma remaining argument correctness knuthmorrispratt algorithm correctness finiteautomaton matcher kmpma tcher simulates behavior finite automatonmatcher exercises compute prefix function pattern ababbabbabbababbabb alphabet exercises upper bound size function bound tight exercises explain determine occurrences pattern text examining function string string length concatenation exercises improve kmpmatche replacing occurrence defined recursively equation explain modified algorithm correct explain sense modification constitutes improvement exercises lineartime algorithm determine text cyclic rotation string arc car cyclic rotations exercises efficient algorithm computing transition function stringmatching automaton pattern algorithm time hint prove problems string matching based repetition factors yi denote concatenation string times ababab string repetition factor string denote largest repetition factor efficient algorithm takes input pattern computes running tim algorithm pattern defined max prove pattern chosen randomly binary strings length expected o1 argue stringmatching gorithm correctly finds occurrences pattern text time opn repetitionmatcherp lengthp lengtht print pattern occurs shift max1 qk algorithm galil seiferas extending ideas greatly lineartime stringmatch ing algorithm o1 storage required chapter notes relation string matching theo finite automata discussed aho hopcroft ullman knuthmorrispratt algorithm invented independently knuth pratt morris published work jointly rabinkarp algorithm proposed rabin karp galil seiferas interesting deterministic lineartime stringmat ching algorithm o1 space required store pattern text chapter computational geometry overview computational geometry branch comput science studies algorithms solving geometric problems modern engineering mathematics computational geometry applications elds computer graphics robo tics vlsi design computer aided design statistics input computationalgeometry problem typically description set geometric objects set points set segments vertices polygon counterclockwise order output response query objects lines intersect geometric object convex hull smallest closing convex polygon set points chapter computationalgeometry algorithms dimensions plane input object represented set points yi yi nvertex polygon represented sequence p0 pn1 vertices order appearance boundary computational geometry performe dimensions higher dimensional spaces problems lutions difficult visualize dimensions good sample computationalgeometry techniques answer basic questions segments efficiently accurately segment clockwise counterclockwise shares endpoint turn traversing tw adjoining segments segments intersect presents technique called sweeping develop lg ntime algorithm determining intersections set segments rotationalsweep algorithms compute convex hull smallest encl osing convex polygon set points grahams scan runs time lg jarviss march takes onh time number vertices convex hull finally lg ntime divide andconquer algorithm finding clos pair points set points plane linesegment properties computationalgeometry algorithms chapter require answers questions properties segments convex combination distinct points y1 point y3 rangey3 y1 write intuitively point passing distinct points segment set convex combinations endpoints segment ordering matters speak directed segment origin treat directed segment vector xplore questions directed segments clockwise respect common endpoint p0 segments traverse left turn point segments intersect restrictions points answer question o1 time surprise input size question o1 methods additions subtractions multiplications comparisons division trigonometric functions computationally expensive prone problems roundoff error straightforward method termining segments intersectcompute equation form mx segment slope yintercept point intersection lines check point segmentsuses division point intersection segments parallel method sensitive precision division operation real computers method whic avoids division accurate cross products computing cross products heart linesegment met hods vectors figure cross product interpreted signed area parallelogram formed points y1 equivalent definition cross product determinant matrix figure cross product vectors signed area parallelogram lightly shaded region vectors clockwise darkly shaded region vectors counterclockwise positive clockwise respect origin cross product negative counterclockwise exercise figure clockwise counterclockwise regions relative vector boundary condition arises cross product case vectors collinear pointing opposite directions determine directed segment clockwise directed segment respect common endpoint p0 simply translate p0 origin p0 denote vector define p0 compute cross product p0 p0 x0y2 y0 x0y1 y0 cross product positive clockwise negative counterclockwise determining consecutive segments turn left question consecutive segments turn left point equivalently method determine angle p0p1p2 turns cross products answer question computi angle figure simply check directed segment clockwise counterclockwise relative directed segment compute cross product p0 p0 sign cross product negative counterclockwise respect left turn positive cross product clockwise orientation turn cross product points p0 collinear figure cross product determine consecutive segments turn point check directed segment clockwise counterclockwise relative directed segment counterclockwise points left turn clockwise turn determining segments intersect determine segments inters ect check segment straddles segment straddles point lies point lies boundary case arises lies directly segments intersec conditions holds segment straddles endpoint segment lies segment condition boundary case procedures implement segmentsintersect returns true segments intersect false calls subroutines direction computes relative orientations crossproduct method onsegment determines poi collinear segment lies segment segmentsintersectp1 p4 d1 directionp3 p4 directionp3 p4 d3 directionp1 d4 directionp1 p4 d1 d1 d3 d4 d3 d4 return true elseif d1 onsegmentp3 p4 return true elseif onsegmentp3 p4 return true elseif d3 onsegmentp1 return true elseif d4 onsegmentp1 p4 return true return false directionpi return onsegmentpi minxi maxxi minyi yk maxyi return true return false segmentsintersect works lines compute relative orientation endpoint respect segment relative orientations nonzero easily determine segments intersect segment straddles segment directed segments opposite orientations relative case signs d1 differ straddles signs d3 d4 differ test true segments straddle segmentsintersect returns true figure case segments straddle lines boundary case apply relative orientations nonzero boundary case applies tests lines fail segmentsintersect returns false figure case figure cases procedure segmentsintersect segments straddle lines straddles signs cross products p4 differ straddles signs cross products p4 p4 differ segment straddles straddle signs cross products p4 p4 point collinear point collinear segments intersect boundary case occurs relative orientation collinear segment directly segment onl endpoints segment procedure onsegment returns endpoints segment segment called lines procedure assumes collinear segment figures cases collinear points figure segmentsintersect returns true endpoints segments figure segmentsintersect returns false applications cross products sections chapter introdu additional cross products sort set points polar angles respect origin exercise asks cross products perform comparisons rting procedure redblack trees maintain vertical ordering set segments keeping explicit key values replace key comparison redbl ack tree code crossproduct calculation determine segments intersect vertical exercises prove positive vector clockwise vector respect origin cross product negative counterclockwise exercises professor powell proposes xdimension tested segment professor wrong exercises polar angle point respect origin point p0 angle vector p0 usual polar coordinate polar angle respect angle vectordegrees radians polar angle respect angle vectordegrees radians write pseudocode sort sequence points polar angles respect origin point p0 procedure lg time cross products compare angles exercises determine on2 lg time points set points collinear exercises polygon piecewiselinear clos curve plane curve formed sequence straightline segments called sides polygon point joining consecutive sides called vertex polygon polygon simple generally assume cross set points plane enclosed simple polygon forms interior polygon set points polygon forms boundary set points surrounding polygon forms exterior simple polygon convex points boundary interior points segment drawn contained polygons boundary interior professor amundsen proposes method determine sequence p0 pn1 points forms consecutive vertices convex polygon output set pi1 pi2subscript addition performed modulo left turns turns output method runs linear time produce correct answer modify professors method produ ces correct answer linear time exercises point p0 x0 y0 horizontal ray p0 set points yi x0 yi y0 set points p0 p0 determine horizontal ray p0 intersects segment o1 time reducing problem determining segments intersect exercises determine point p0 interior simple convex polygon ray p0 check ray intersects boundary odd number times p0 boundary compute time point p0 interior nvertex polygon hint exercise algorithm correct ray intersects polygon boundary vertex ray overlaps polygon exercises compute area nvertex simple convex polygon time exercise definitions pertaining polygons cross product threedimens ional concept vector perpendicular righthand magnitude y1 chapter prove convenient treat cross product simply y1 determining pair segments intersects presents algorithm determining segments set segments intersect algorithm echnique sweeping common computationalgeometry algorithms exercises algorithm simple vari ations solve computationalgeometry problems algorithm runs lg time number segments determines intersection exists print intersections exercise takes time worst case intersections set segments sweeping imaginary vertical sweep passes set geometric objects left spatial dimension sweep moves case xdimension treated dimension time sweeping method ordering geometric objects usua lly placing dynamic data structure advantage relationships linesegmentintersection algorithm considers linesegment endpoint lefttoright order checks intersection time encounters endpoint prove correct algorithm determining segments intersect simplifying assumptions assume input segment vertical assume input segments intersect single point exercises algorithm robust slight modification work assumptions hold removing simplifying assumptions dealing boundary conditions difficult programming computa tionalgeometry algorithms proving correctness ordering segments assume vertical segm ents input segment intersects vertical sweep intersects single point order segments intersect vertical swee ycoordinates points intersection precise segments s1 segments comparable vertical sweep xcoordinate intersects s1 written s1 s1 comparable intersection s1 sweep higher intersection sweep figure relationships segment comparable segment figure ordering segments vertical sweep lines segment comparable segment segments intersect orders reversed sweep passes shaded region consecutive total order relation total order segments intersect sweep order differ differing values segments enter leave ordering segment enters orde ring left endpoint encountered sweep leaves ordering endpoint encountered sweep passes intersection segments figure positions total order reversed sweep lines left point intersection segments note assume segments intersect point vertical sweep intersecting segments consecutive total order sweep passes shaded region figure consecutive total order moving sweep sweeping algorithms typically manage sets data sweepline status relationships objects intersected sweep eventpoint schedule sequence xcoordinates ordered left defines halting positions sw eep halting position event point sweepline stat occur event points algorithms algorithm asked exercise eventpoint schedule determined dynamically algorithm progresses algorithm hand determines event points statically based solely simple properties input data segment endpoint event point sort segment endpoints increasing xcoordinate proceed left endpoints covertical xcoordinate break tie putting covertical left endpoints covertical endpoints set covertical left endpoints lower ycoordinates set covertical endpoints insert segment sw eepline status left endpoint encountered delete sw eepline status endpoint encountered segments beco consecutive total order check intersect sweepline status total order require operations insertt insert segment deletet delete segment abovet return segment segment belowt return segment segment segments input perf orm operations olg time redblack trees recall redblacktree operations chapter involve comparing keys replace key compar isons comparisons cross products determine relative dering segments exercise segmentintersection pseudocode algorithm takes input set segments returning boolean true pair segments intersects false total order implemented redblack tree anysegmentsintersects ø sort endpoints segments left breaking ties putting left endpoints endpoints breaking ties putting points lower ycoordinates point sorted list endpoints left endpoint segment insertt abovet exists intersects belowt exists intersects return true endpoint segment abovet belowt exist abovet intersects belowt return true deletet return false figure illustrates execution algorithm li initializes total order determines tpoint schedule sorting segment endpoints left breaking ties note performed lexicographically sorting endpoints usual coordinates left endpoint endpoint figure execution anysegmentsintersect dashed sweep event point ordering segment names sweep total order loop event point processed intersection segments segment deleted iteration loop lines processes event point left endpoint segment adds total order lines return true intersects segments consecuti total der defined sweep passing boundary condition occurs lies segment case require consecutively endpoint segment deleted total order lines return true intersection segments surrounding total order fined sweep passing segments consecutive total order deleted segments intersect deletes segment total order finally intersections processing event points returns false correctness anysegmentsintersect correct prove anysegmentsintersects returns true ere intersection segments easy anysegmentsinters ect returns true lines finds intersection input segments returns true intersection converse intersection anysegments intersect returns true suppose intersection leftmost intersection point breaking ties choosing lowest ycoordinate segments intersect intersections occur left order correct points left segments intersect point exists sweep consecutive total order left exists segment endpoint sweep event point consecutive total order sweep sweep left case order correct encountered lexicographic order algorithm processes event points lowest leftmost intersection points sweep intersection point event point processed intersection interfere total order left endpoint segment endpoint segment left endpoint events occur endpoint events segment segment encountered event point processed anysegmentsinter sect processed processed anysegmentsintersect possibilities action inserted segment total order lines detect case segments segment total order deleted making consecutive lines detect case case intersection anysegmentsintersect returns true event point processed anysegments intersect procedure returned processing event points situation occurred anysegmentsintersect intersection returned true intersection anysegmentsintersect returns true anysegmentsintersect turns true intersection anysegmentsintersect ways returns correct answer running time segments set anysegmentsintersect runs time lg takes o1 time takes lg time merge sort heapsort event points loop lines iterates times iteration takes olg time red blacktree operation takes olg time method intersection test takes o1 time total time lg exercises intersections set segments exercises segments comparable determine o1 time holds assume neithe segment vertical hint intersect cross products intersectwhich determine cross productsyou addition subtraction multiplication avoiding division cour application relation intersect declare intersection exercises professor maginot suggests modify anysegmentsintersect returning finding intersection prints segments intersect continues iteration loop professor calls procedure print intersectingsegments claims prints intersections left occur set segments professor wrong counts set segments rst intersection printintersectingsegments leftmost set segments print intersectingsegments fails intersections exercises lg ntime algorithm determine nvertex polygon simple exercises lg ntime algorithm determine simple polygons total vertices intersect exercises disk consists circle interior represented center point radius disks intersect point common lg ntime algorithm determine disks set intersect exercises set segments total intersections output intersections lg time exercises argue anysegmentsintersect works corre ctly segments intersect point exercises anysegmentsintersect works rrectly presence vertical segments endpoint vertical segm ent processed left endpoint endpoint processed endpoint answer exercise change vertical segments allowed segments intersect point intervening segment intersects point sweep lines left exercise asks anysegmentsintersect correct segments intersect point finding convex hull convex hull set points smallest convex polygon point boundary interior exercise precise definition convex polygon denote convex hull chq intuitively point nail sticking boa convex hull shape formed tight rubber band surrounds nails figure set points convex hull figure set points p0 p12 convex hull gray algorithms comput convex hull set points algorithms output vertices convex hull counterclockwise order grahams scan runs lg time called jarviss march runs onh time number vertices convex hull figure vertex chq point algorithms exploit property deciding vertices vertices convex hull vertices throw fact met hods compute convex hulls lg time grahams scan jarviss march echnique called rotati onal sweep processing vertices order polar angles form reference vertex methods include incremental method points sorted yielding sequence ith stage convex hull leftmost points pi1 updated ith point left forming exercise asks method implemented total lg time divide conquer method time set points divided subsets leftmost points rightmost points convex hulls subsets computed recursively clever method combine hulls time running time familiar recurrence tn2 divide conquer method runs lg time pruneandsearch method worstcase lineartime median algorithm finds upper portion upper chain convex hull repeatedly throwing constant fraction remaining points upper chain convex hull remains lower chain method asymptotically fastest convex hull vertices runs lg time computing convex hull set points interesting problem algorithms computa tionalgeometry problems start computing convex hull twodimensional farthestpair problem set points plane points distance maximum exercise asks prove points vertices convex hull prove farthest pair vertices nvertex convex polygon time computing convex hull input points lg time finding farthest pair convexpolygon vertices farthest pair points set points lg time grahams scan grahams scan solves convexhull problem maintaining stack candidate points point input set pushed stack points vertices chq eventually popped stack algorithm terminates stack vertices chq counterclockwise order appearance boundary procedure grahamscan takes input set points calls functions returns point stack changing nexttotops returns point entry stack changing prove moment stack returned grahamscan vertices counterclockwise order grahamscanq p0 point minimum ycoordinate leftmost point case tie remaining points sorted polar angle counterclockwise order p0 point angle remove farthest p0 pushp0 pushp1 pushp2angle formed points nexttotops tops nonleft turn pops pushpi return figure illustrates progress grah amscan chooses point p0 point lowest ycoordinate picking leftmost poi case tie point p0 points ycoordinate p0 vertex chq sorts remaining points polar angle relative p0 methodcomparing cross productsas exercise points polar angle relative p0 farthest point convex combinations p0 farthest point remove consideration denote number points p0 remain polar angle measured radians point relative p0 halfopen interval points sorted polar angles sorted counterclockwise order relative p0 designate sorted sequence points note points vertices chq exercise figure points figure sequentially numbered order increasing polar angle relative p0 figure execution grahamscan set figure current convex hull contained stack gray step sequence p12 points numbered order increasing polar angle relative p0 initial stack p0 stack iteration loop lines dashed lines nonleft turns points popped stack turn angle p7p8p9 p8 popped turn angle p6p7p9 p7 popped convex hull returned procedure matches figure remainder procedure stack lines initialize stack points p0 figure initial stack loop lines iterates point subsequence p4 intent ter processing point stack vertices p0 counterclockwise order loop lines removes points stack vert ices convex hull traverse convex hull counterclockwise turn vertex time loop finds vertex nonleft turn vertex popped stack checking nonleft turn turn test precludes possibility straight angle vertex convex hull straight angles vertex convex polygon convex combination vertices polygon pop vertices nonleft turns heading point push stack figures state stack iteration loop finally grahamscan returns stack figure convex hull theorem formally prove correctness grahamscan theorem correctness grahams scan grahamscan set points termination stack consists vertices chq counterclockwise order proof sequence points define subset points qi p0 points qm removed polar angle relative p0 point qm points chq chqm chq suffices grahamscan terminates stack consists vertices chqm counterclockwise order botto note p0 vertices chq points p0 vertices chqi proof loop invariant start iteration loop lines stack consists vertices qi1 counterclockwise order initialization invariant holds time execute time stack consists vertices q2 qi1 set vertices forms convex hull countercloc kwise order maintenance entering iteration loop point stack pi1 pushed previous iteration iteration point loop lines executed pushes point moment point pushed stack points contained iteration loop loop invariant vertices chqj moment counterclockwise order continue focus moment pushed referring figure pis polar angle relative p0 greater pjs polar angle angle pkpjpi left turn wise popped vertices chqj push stack vertices chqj counterclockwise order figure proof correctness grahamscan pis polar angle relative p0 greater pjs polar angle angle pkpj left turn adding chqj vertices chqj angle prptpi nonleft turn interior triangle formed p0 triangle vertex chqi chqj set points qi point popped iteration loop point stack time popped angle prptpi nonleft turn polar angle relative p0 greater polar angle figure interior triangle formed p0 triangle vertex triangle triangle formed points qi vertex chqi vertex chqi set points popped iteration loop equality applies points apply repeatedly chqi chqi qi conclude chqj chqi chqi push stack vertices chqi counterclockwise order incrementing loop invariant hold iteration termination loop terminates loop invariant implies stack consists vertices chqm chq counterclockwise order completes proof running time grahamscan lg takes time takes lg time merge sort heapsort sort polar angles crossproduct method compare angles removing farthest point polar angle total time lines o1 time loop lines executed times push takes o1 time iteration takes o1 time exclusive time spent loop lines loop takes time exclusive nested loop aggregate analysis loop takes time point pushed stack analysis multipop procedure observe pop operation push operation pointsp0 pmare popped stack fact pop operations performed total iteration loop performs pop iterations loop altogether test takes o1 time pop takes o1 time total time loop running time grahamscan lg jarviss march jarviss march computes convex hull set points technique package wrapping gift wrapping algorithm runs time onh number vertices olg jarviss march asymptotically faster grahams scan intuitively jarviss march simulates wra pping taut piece paper set start taping paper lowest point set point p0 start grahams scan point vertex convex hull pull paper taut pull higher touches point point vertex convex hull keeping paper taut continue set vertices original point p0 formally jarviss march builds sequence p0 ph1 vertices chq start p0 figure convex hull vertex smallest polar angle respect p0 case ties choose point farthest p0 smallest polar angle respect reach highest vertex breaking ties choosing farthest vertex constructed figure chain chq construct left chain start choose pk1 point smallest polar angle respect negative xaxis continue forming left chain polar angles negative xaxis original vertex p0 figure operation jarviss march vertex chosen lowest point p0 vertex smallest polar angle point respect p0 smallest polar angle respect chain high highest point left chain constructed finding smallest polar angles respect negative xaxis implement jarviss march onceptual sweep convex hull separately constructing left chains implementations typically track angle convexhull chosen require sequence angles hull sides strictly incr easing range radians advantage constructing separate chains explicitly mpute angles techniques suffice compare angles implemented properly jarviss march running time onh vertices chq vertex minimum polar angle comparison polar angles takes o1 time techniques compute minimum values time comparison takes o1 time jarviss march takes onh time exercises prove procedure grahamscan points vertices exercise model computation suppor addition comparison multiplication lower bound lg sort numbers prove lg lower bound computing order rtices convex hull set points model exercise set points prove pair points farthest vertices chq exercise polygon point boundary shadow set points segment boundary interior polygon starshaped exists point interior shadow point boundary set points called kernel figure nvertex starshaped polygon vertices counterclockwise order compute time figure definition starshaped polygon exercise star shaped polygon segment point point boundary intersects boundary nonstarshaped polygon shaded region left shadow shaded region shadow regions disjoint kernel exercise online convexhull problem set points point time receiving point compute convex hull points grahams scan point total running time on2 lg solve online convexhull problem total on2 time exercise implement incremental method computing convex hull points runs lg time finding closest pair points problem findi closest pair points set points closest refers usual euclidea distance distance points y1 points set coincident case distance problem applications trafficcontrol systems controlling air sea traffic closest vehicles order detect potential collisions bruteforce closestpair algorithm simply pairs points divide conquer algorithm problem running time familiar recurrence tn2 algorithm lg time divide conquer algorithm recursive invocation algorithm takes input subset arrays points input subset points array sorted xcoordinates monotonically increasing array sorted monotonically increasing ycoordinate note order attain lg time bound afford sort recursive recurrence running time tn2 lg solution lg2 version master method exercise ter presorting maintain sorted property withou sorting recursive recursive invocation inputs checks invocation simply performs brute force method pairs points return osest pair recursive invocation carries divide conquer paradigm divide finds vertical bisects point set sets points left points array divided arrays xr points sorted monotonically increasing xcoordinate array divided arrays points sorted monotonically increasing ycoordinate conquer divided recursive calls closest pair points closest pair points inputs subset arrays receives inputs xr closestpair distances returned min combine closest pair eith pair distance recursive calls pa points point algorithm determines pair distance observe pair points distance points pair units figure reside wide vertical strip centered pair exists algorithm figure key concepts proof closestpair algorithm check points point array units reside rectangle centered points pairwise units reside square left points points points rectangle points pairs coincident points point creates array array points wide vertical strip removed array sorted ycoordinate point array algorithm points units shortly points follow considered algorithm computes distance points track osestpair distance pairs points vertical strip closer pair recursive calls pair distance returned closest pair distance recursive calls returned description omits implementation details achieve lg running time proving correctness algorithm implement algorithm achieve desired time bound correctness correctness closestpair algorithm obvious aspects bottoming recursion ensure solve subproblem consisting point aspect check points point array prove property suppose level recu rsion closest pair points distance strictly point left units units units vertically figure rectangle centered points rectangle points reside rectangle square forming left half rectangle points units points reside square figure points reside square forming half rectangle points reside rectangle note points points limit achieved pairs coincident points pair consists point point pair intersection rectangle pair intersects rectangle points reside recta ngle easy check points point array ystill assuming closest pair assume loss generality precedes array occurs early occurs late positions correctness closestpair algorithm implementation running time goal recurrence running time tn2 running time set points main difficulty ensuring arrays xr passed recursive calls sorted proper coordinate array sorted ycoordinate note array received recursive alread sorted division set easily accomplished linear time key observation form sorted subset sorted array invocation subset array sorted ycoordinate partitioned form arrays sorted ycoordinate arrays formed linear time method viewed opposite merge procedure merge sort splitting sorted array sorted arrays pseudocode idea lengthyl lengthyrlengthy yi lengthyl lengthyl yllengthyl yi lengthyr lengthyr yrlengthyr yi simply examine points array order point yi append array append array pseudocode works forming arrays xr remaining question ints sorted place simply presorting sort recursive sorted arrays passed ecursive whittled recursive calls necessa presorting adds additional lg running time step ecursion takes linear time exclusive recursive calls running time recursive step running time entire algorithm lg lg lg exercises professor smothers scheme closestpair algorithm check points point array idea place points set pairs coincident points point points reside rectangle flaw professors scheme exercise increasing asymptotic running time algorithm ensure set points passed recursive coincident points prove suffices check points arra positions point array exercise distance points defined ways euclidean plane lmdistance points expression x2m y1 y2m1m euclidean distance l2distance modify closestpair algorithm l1distance manhattan distance exercise points plane lýdistance max x2y1 modify closestpair algorithm ldistance exercise change closestpair algorithm avoids presorting array leaves running time lg hint merge sorted arrays form sorted array problems convex layers set points plane define convex layers inductively convex layer consists points vertices define qi consist points points convex layersremoved ith convex layer chqi qi ø undefined on2time algorithm onvex layers set points prove lg time required compute convex layers set points model computation requires lg time sort real numbers problems maximal layers set points plane point dominates point point dominated points maximal note maximal points organized maximal layers maximal layer l1 set maximal points ith maximal layer li set maximal points suppose nonempty maximal layers yi ycoordinate leftmost point li assume points ycoordinate y1 yk point point distinct ycoordinate point minimum yk case maximal layers maximal layers maximal layers includes leftmost point maximal layers addition nonempty maximal layer lk1 lg ntime algorithm compute maximal layers set points hint sweep left difficulties llow input points ycoordinate resolve problems problems ghostbusters ghosts group ghostbusters battling ghosts ghostbuster armed proton pack shoots stream ghost eradicating stream straight terminates hits ghost ghostbusters decide strategy pair ghosts forming ghostbusterghost pairs simultaneously ghostbuster shoot stream chosen ghost dangerous streams cross ghostbusters choose pairings streams cross assume position ghostbuster ghost fixed point plane positions collinear argue exists passing ghostbuster ghost number ghostbusters equals number ghosts lg time on2 lg ntime algorithm pair ghostbusters ghosts streams cross problems picking sticks professor charon set sticks lying configuration stick endpoints endpoint ordered triple coordinates stick vertical wishes pick sticks time subject condition pick stick stick procedure takes sticks reports unrelated efficient algorithm determin pick sticks legal sequence stick pickups problems sparsehulled distributions problem computing convex set points plane drawn random stribution number points size convex hull points drawn distribution expectation on1 constant distribution sparsehulled sparsehulled distributions include points drawn uniformly unitradius disk convex hull n13 expected size points drawn uniformly interior convex polygon sides constant convex hull lg expected size points drawn twodimensiona normal distribution convex hull expected size convex polygons n1 vertices compute convex hull n1 points on1 time polygons overlap convex hull set points drawn independently sparsehulled distribution computed expected time hint recursively convex hulls points points combine chapter notes chapter barely scratches surface computationalgeometry algorithms techniques books computational geometry include preparata shamos edelsbrunner orourke geometry studied tiquity development algorithms geometric problems preparata shamos note earliest notion complexity problem lemoine studying euclidean constructionsthose compass rulerand devised set primitives placing leg compass point acing leg compass drawing circle passing rulers edge point drawing lemoine interested number primitives needed construction called simplicity construction algorithm determines segments intersect shamos hoey original version grahams scan graham packagewrapping algorithm jarvis decisiontree model computation yao proved lower bound lg running time convexhull algorithm number vertices convex hull account pruneandsearch algorithm kirkpatrick seidel takes lg time asymptotically optimal lg ntime divide conquer gorithm finding closest pair points shamos appears preparata shamos preparata shamos algorithm asymptotically optimal decisiontree model chapter npcompleteness overview algorithms studied polynomialtime algorithms inputs size worstcase running time onk constant natural problems solved polynomial time answer problems turing famous halting problem solved computer matter time provided ere problems solved time onk constant generally problems solvable polynomialtime algorithms ing tractable easy problems require superpolynomial time intractable hard subject chapter interesting class problems called np complete problems status unknown polynomialtime algorithm discovered npcomplete problem prove polynomialtime algorithm exist socalled np question deepest perplexing open problems theoretical computer science posed tantalizing aspect npcompl ete problems surface problems ha polynomialtime algorithms pairs problems solvable polynomial time npcomplete difference problems appears slight shortest longest simple paths chapter negative edge weights shortest paths single source directed graph ov time finding longest simple path vertices npcomplete fact npcomplete edge weights euler tour hamiltonian cycle euler tour connected directed graph cycle traverses edge visit vertex problem determine graph euler tour oe time fact edges euler tour oe time hamiltonian cycle directed graph simple cycle vertex determining directed graph hamiltonian cycle npcomplete chapte prove determining undirected graph hamiltonian cycle npcomplete cnf satisfiability cnf satisfiability boolean formula variables values boolean connectives parentheses boolean formula satisfiable assignment values variables evaluate define terms formally chapte informally boolean formula kconjunctive normal form kcnf auses ors variables negations boolean formula cnf satisfying assignmentpolynomialtime algorithm determine cnf formula satisfiable chapter determining cnf formula satisfiable npcomplete npcompleteness classes np chapter refer classes problems np npc class npcomplete problems informally define formally class consists problems solvable polynomial time problems solved time onk constant size input problem problems examined previous chapters class np consists problems verifiable polynomial time certificate solution verify certificate correct time polynomia size input problem hamiltoniancycle problem directed graph certificate sequence v1 v2 v3 vv vertices easy check polynomial time vi vi1 vv v1 cnf satisfiability certific ate assignment values variables easily check polynomial time assignment satisfies boolean formula problem np problem solve polynomial time certificate ill formalize notion chapter np open question proper subset np informally problem cla npcand refer npcompleteif np hard problem np formally define hard problem np chapte state proof npcomplete problem solved polynomial time npcomplete problem polynomialtime algorithm theo retical computer scie ntists npcomplete problems intractable nce wide range npcomplete problems studied datew ithout discovered polynomialtime solution themit ast ounding solved polynomial time effort devoted proving npcomplete problems intractablewithout conclusive outcomewe rule possibility npcomplete problems fact solvable polynomial time good algorithm designer understand rudiments theory npcompleteness establish oblem npcomplete provide good evidence intractability engineer spending time developing approximation algorithm chapter solving tractable ecial case searching fast algorithm solves problem natural interesting problems surface harder sorting graph searching network flow fact npcomplete familiar remarkable class problems overview showing problems npcomplete techniques problem npcomplete differ techniques book design analyze algorithms fundamental reason difference howing problem npcomplete making statement hard east hard easy prove existence efficient algorithm efficient algorithm exist npcompleteness oofs proof lg ntime lower bound comparison sort algorithm specific techniques showing npcompleteness differ decisiontree method rely key concepts showing problem npcomplete decision problems optimization problems problems optimization problems feasible legal solution feasible solution problem shor testpath undirected graph vertices path fewest edges shortestpath singlepair shortestpath problem unweighted undirected graph npcompleteness applies dire ctly optimization problems decision problems answer simply formally showing problem npcomplet confines realm decision problems convenient relationshi optimization problems decision problems cast optimiza tion problem decision problem imposing bound optimize shortestpath decision problem path directed graph vertices integer path exists consisting edges relationship optimization problem decision problem works favor optimi zation problem hard decision problem sense easier harder specific solve path solving shortestpath comparing number edges shortest path decisionproblem parameter optimization problem easy decision oblem easy stated relevance npcompleteness provide evidence decision problem hard provide evidence optimization problem hard restricts attention decision problems theory npcompleteness implications optimization problems reductions notion showing problem harder easier applies problems decision problems advantage idea npcompleteness proof decision problem solve polynomial time input problem instance problem path instance graph vertices integer suppose decision problem solve polynomial time finally suppose procedure transforms instance instance characteristics transformation takes polynomial time answers answer answer procedure polynomialtime reduction algorithm figure solve problem polynomial time instance problem polynomialtime reduction algorithm transform instance problem polynomialtime decision algorithm instance answer answer figure polynomialtime reducti algorithm solve decision problem polynomial time polynomialtime decision algorithm problem polynomial time transform instance instance solve polynomial time answer answer long steps takes polynomia time decide polynomial time word reducing solving problem solving problem easiness prove easiness recalling npcompleteness showing hard problem easy polynomialtime reductions pposite problem np complete idea step furthe polynomialtime reductions polynomialtime gorithm exist problem suppose decision problem polynomialtime algorithm exist concern ourselv problem suppose polynomia ltime reduction transf orming instances instances simple proof contradiction polynomial time algorithm exist suppose suppose polynomialtime algorithm method figure solve problem polynomial time contradicts assumption polynomial time algorithm npcompleteness assume absolutely polynomialtime algorithm problem proof methodology prove problem npcomplete assumption problem npcomplete npcomplete problem technique reduction relies ha ving problem np complete order prove problem npcomplete npcomplete problem problem circui tsatisfiability problem boolean combinational circuit composed gates set boolean inputs circuit output prove problem npcomplete chapter outline chapter studies aspects npcompletene bear directly analysis algorithms formalize notion oblem define complexity class polynomialtime solvable decision prob lems notions fit framework formallanguage theory defines class np decision problems solutions verified lynomial time formally poses np question relationships problems studied polynomialtime reductions defines npcompleteness sketches proof problem called circuit satisfiability npcomplete npcomplete problem problems proven npcomplete simply methodology reductions methodology illustrated showing formula satisfiability problems npcomplete vari ety problems np complete polynomial time study npcompleteness rmalizing notion polynomialtime solvable problems problems generally regarded tractable philosophical mathematical reasons offer supporting arguments reasonable gard problem requires time n100 intractable practical problems require time order highdegree polynomial polynomialtime computable oblems encountered practice typically require time experience polynomialtime algorithm problem discovered efficient algorithms follow current algorithm problem running time n100 algorithm running time discovered reasonable models comput ation problem solved polynomial time model solved polynomial time class problems solvable polynomial time serial randomaccess machine book class problems solvable polynomial time abstract turing machines class problems solvable polynomial time parallel computer number processo grows polynomially input size class polynomialtime solvable problems nice closure properties polynomials closed addition multipli cation composition output polynomialtime algorithm fed input composite algorithm polynomial polynom ialtime algorithm constant number calls polynomialtime subroutines running time composite algorithm polynomial abstract problems understand class polynomi altime solvable problems formal notion problem define abstract problem binary relation set problem instances set problem solutions instance shortestpath triple consisting graph vertices solution sequence vertices graph sequence denoting path exists problem shortestpath relation associates instance graph vertices shortest path graph connects vertices shortest paths unique problem instance solution formulation abstract problem general required purposes theory npcompleteness restricts attention decision problems yesno solution case view abstract decision problem function maps instance set solution set decision problem shortestpath problem path earlier instance decision problem path path shortest path edges pathi abstract problems decision problems optimization problems minimized maximized simple matter recast optimization problem decision problem harder encodings computer program lve abstract problem problem instances represented program understands encoding set abstract objects mapping set binary strings2 familiar encoding natural numbers strings encoding e17 looked computer representations keyboard characters familiar asc ebcdic codes ascii code encoding compound object encoded binary string combining representations constituen parts polygons graphs functions ordered pairs programsall coded binary strings computer algorithm solves abstract decision problem takes encoding problem instance input problem instance set set binary strings concrete problem algorithm solves concrete problem time provided problem instance length algorithm produce solution time3 concrete problem polynomialtime solvable exists algorithm solve time onk constant formally define complexity class set concrete decision problems polynomialtime solvable encodings map abstract problem concrete problems abstract decision problem mapping instance set encoding induce concrete decision problem denote eq4 solution abstractproblem instance qi solution concreteproblem instance qi technicality binary strings represent meani ngful abstractproblem instance convenience assume string mapped arbitrar ily concrete problem produces solutions abstract problem binarystring instances represent encodings abstractproblem instances extend definition pol ynomialtime solvability concrete problems abstract problems encodings idge definition independent encoding efficiency solving problem depend problem encoded unfo rtunately depends heavily encoding suppose integer provided sole input algorithm suppose running time algorithm integer provided unarya string sthen running time algorithm lengthn inputs polynomial time natural binary representation integer input length lg case running time algorithm exponential size input depending encoding algorithm runs ither polynomial superpolynomial time encoding abstract problem ther efore understanding polynomial time talk solving abstract problem encoding practice rule expensive encodings unary actual encoding problem difference problem solved polynomial time representing integers base binary problem solvable polynomial time integer represented base converted integer represented base polynomial time functionpolynomialtime computable exists polynomialtime algorithm input produces output set problem instances encodings e1 polynomially exist polynomialtime computable functions f12 f21 f12e1i e2i f21e2i e1i5 encoding e2i computed encoding e1i polynomialtime algorithm vice versa encodings e1 abstract problem polynomially rela ted problem polynomialtime solvable independent encoding lemma lemma abstract decision problem instance set e1 polynomially encodings e1q e2q proof prove forward direction backward direction symmetric suppose e1q solved time onk constant suppose problem instance encoding e1i computed encoding e2i time onc constant e2i solve problem e2q input e2i compute e1i algorithm e1q e1i long conversion encodings takes time onc e1i onc output serial computer longe running time solving problem e1i takes time oe1ik onck polynomial constants abstract problem inst ances encoded binary base affect complexity polynomialtime solvable instances encoded unary complexity change order converse encodingindependent fashion generall assume problem instances encoded reasonable concise fashion precise assume encoding inte ger polynomially binary representation encoding finite set polynomially rela ted encoding list elements enclosed braces separated commas ascii encoding scheme standard encoding hand derive reasonable encodings mathematical objects tuples aphs formulas denote standard encoding object enclose object angle braces denotes standard encoding graph long implicitly encoding polynomially standard encoding talk directly abstract problems reference encoding knowing choice encoding abstract problem polynomialtime solvable henceforth generally assume problem instances binary strings encoded standard encoding explicitly contrary typically neglect distinction abstract concrete problems reader watch problem practice standard encoding obvious encoding difference formallanguage framework convenient aspects focusing decision problems easy machinery formallanguage theory worthwhile point review definitions theory alphabet finite set symbols language set strings symbols setlanguage binary representations prime numbers denote string language ø language strings denoted set binary strings language subset variety operations languages settheoretic operations union intersection follow directly settheoretic definitions define complement concatenation languages l1 language x1x2 l1 closure kleene star language language l3 lk language concatenating times point view language theory set instances decision problem simply set characterized problem instances produce answer view language qx decision problem path language path undirected graph integer exists path consisting edges convenient namepath case refer decision problem language formallanguage framework express relation decision problems algorithms solve conc isely algorithm accepts string input algorithms output language accepted algorithm set stringsset strings algorithm accepts algorithm rejects string language accepted algorithm algorithm reject string provided input algorithm loop forever language decided algorithm binary string accepted binary string rejected language accepted polynomial time algorithm accepted addition constant lengthn string algorithm accepts time onk language decided polynomial time algorithm constant lengthn string algorithm correctly decides time onk accept language algorithm worry strings decide language correctly accept reject string language path accepted polynomial time polynomial time accepting algorithm verifies encodes undirected graph verifies vertices breadthfirst search compute shortest path compares number edges shortest path encodes undirected graph path edges algorithm outputs halts algorithm runs forever algorithm decide path explicitly output instances shortest path edges decision algorithm pa explicitly reject nary strings belong path decision problem path decision algorithm easy design running forever path edges outputs halts problems tu rings halting problem exists accepting algorithm decision algorithm exists informally define complexity class set languages membership determined complexity measure running time algorithm determines string belongs language actual definition complexity class technicalthe interested eader referred seminal paper hartmanis stearns languagetheoretic framework provide alternat ive definition complexity class exists algorithm decides polynomial time fact class language accepted polynomial time theorem accepted polynomialtime algorithm proof class languages decided polynomialtime algorithms subset class languages accepted polynomialtime algorithms accepted polynomialtime algorithm cided polynomialtime algorithm language accepted polynomialtime algorithm classic simulation argument construc polynomialtime algorithm decides accepts time onk constant exists constant accepts cnk steps input string algorithm simulates action time time algorithm inspects behavior accepted accepts outputting accepted rejects outputting overhead simulating increase running time polynomial factor polynomialtime algorithm decides note proof theorem nonconstructive language bound running time algorithm accepts bound exists algorithm exists check bound algorithm easily exercises define optimization problem longestpat hlength relation associates instance undirected graph vert ices number edges longest simple path vertices defi decision problem longestpath undirected graph integer exists simple path consisting edges optimization problem longestpathlength solv polynomial time longestpath exercises formal definition problem nding longest simple cycle undirected graph decision problem language decision problem exercises formal encoding directed graphs binary strings adjacencymatrix representation adjacen cylist representation argue representations polynomially exercises dynamicprogramming algorithm knapsack problem asked exercise polynomialtime algorithm explain answer exercises polynomialtime algorithm constant number calls polynomialtime subroutines runs polynomial time polynomial number calls polynomialtime subroutines result exponentialtime algorithm exercises class viewed set languages closed union intersection concatenation complement kleene star l1 l1 hopcroft ullman lewis papadimitriou treatment turingmachine model codomain binary strings set strings finite alphabet symbols assume algorithms output separate input takes time step produce bit output time steps size output shortly denotes set strings composed symbols set technically require functions f12 f21 map noninstances noninstances noninstance encoding string instance require f12x noninstance encoding e1 noninstance f21x noninstance noninstance e1 polynomialtime verification algorithms verify membership languages suppose instance decision problem path path easily check length view certificate instance belongs path decision problem path certificate doesnt buy afte path belongs fact path solved linear timeand verifying member ship certificate takes long solving problem scratch examine problem polynomialtime decision algorithm ven certificate verification easy hamiltonian cycles problem finding hamiltonian cycle undirected graph studied years formally hamiltonian cycle undirected graph simple cycle vertex graph ham iltonian cycle hamiltonian nonhamiltonian bondy murty cite letter hamilton describing mathematical game dodecahedron figure player sticks pins consecutive vertices player complete path form cycle rtices dodecahedron hamiltonian figure hamiltonian cycle gra phs hamiltonian figure bipartite graph odd number vertices exercise asks graphs nonhamiltonian figure graph representing vertices edge faces dodecahedron hamiltonian cycle shaded edges bipartite graph odd number vertices graph nonhamiltonian define hamiltoniancycle problem graph hamiltonian cycle formal language hamcycle hamiltonian graph algorithm decide language hamcycle problem instance decision algorithm lists permutations vertices checks permutation hamiltonian path running time algorithm reasonable encoding graph adjacenc matrix number vertices graph length encoding permutations verti ces running time onk constant naive algorithm polynomial time fact hamilt oniancycle problem npcomplete prove verification algorithms easier problem suppose friend tells graph hamiltonian offers prove vertices order hamiltonian cycle certa inly easy verify proof simply verify provided cycle hamiltoni checking rmutation vertices consecutive edges cycle exists graph verification algorithm implemented on2 time length encoding proof hamiltonian cycl exists graph verified polynomial time define verification algorithm twoargument algorithm argument ordinary input string binary string called certificate twoargument algorithm verifies input string exists certificate language verified verification algorithm existsintuitively algorithm verifies language string certificate prove string certificate proving hamiltoniancycle problem certificate list vertices hamiltonian cycl graph hamiltonian hamiltonian cycle offers verify fact conversel graph hamiltonian list vertices fool verification algorithm believing graph hamiltonian verificati algorithm carefully checks proposed cycle complexity class np complexity class np class languages verified polynomialtime algorithm precisely language belongs np exist twoinput polynomialtime algorithm constant exists certificate oxc algorithm verifies language polynomial time earlier discussion hamiltonian cycle problem hamcycle np nice set nonempty np polynomialtime algorithm decide algorithm easily converted twoargument verification algor ithm simply ignores certificate accepts input strings determines np unknown np ers np class intuitively class onsists problems solved class np consists problems solution verified learned experience difficult solve problem scratch verify presented solution working time constraints theoretical computer scientists generally analogy extends classes np np includes languages compelling evidence npthe existence languages npcomplete study class fundamental questions np question remain unresolved work researchers class np closed complement np imply define complexity class conp set languages question np closed complement rephrased np conp closed complement exercise np conp np conp language np conp figure scenarios figure possibilities relationships complexity classes diagram region enclosing propersubset relation np conp researchers regard possibility np closed complement np conp case np np conp np closed complement np conp np conp researchers regard possibility understanding precise relationship np woefully incomplete exploring theory npcompleteness disadvantage proving problems intractab practical point view great suppose exercises language graphisomorphism g1 g2 g1 g2 isomorphic graphs prove graphisomorphism np describing polynomialtime algorithm verify language exercises prove undirected bipartite graph odd number vertices nonhamiltonian exercises hamcycle proble listing vertices hamiltonian cycle order polynomialtime solvable exercises prove class np languages closed union intersection concatenation kleene star discuss closure np complement exercises language np decided algorithm running time constant exercises hamiltonian path graph simple path visits vertex language hampath hamiltonian path graph belongs np exercises hamiltonianpath problem solved polynomial time directed acyclic graphs efficient algorithm problem exercises boolean formula constructed boolean input variables negations ands ors parentheses formula tautology evaluates assignment input variablesdefine tautology language boolean formulas ta utologies tautology conp exercises prove conp exercises prove np conp np exercises connected undirected graph vertices g3 graph connecting pairs vertices connected path length prove g3 hamiltonian hint construct spanning tree inductive argument np stands nondeterministic pol ynomial time class np originally studied context nondeterminism book simpler equivalent notion verification hopcroft ullman good presentation npcompleteness terms nondeterministic models computation npcompleteness reducibility compelling reason theore tical computer scientists np existence class npcomplete oblems class surprising property npcomplete problem solved polynomial time problem np polynomialtime solution np years study polynomialtime algorithm scovered npcomplete problem language hamcycle npcomplete problem decide hamcycle polynomial time solve oblem np polynomial time fact np turn nonempty ould certainty hamcycle np npcomplete languages sense hardest languages np compare relative hardne languages precise notion called polynomialtime reducibility formally define npcomplete languages finish sketching proof language called circuitsat npcomplete sections notion reducibility problems npcomplete reducibility intuitively problem reduced problem instance easily rephrased instance solution solution instance problem solving linear equations indeterminate reduces problem solving qua dratic equations instance transform solution solution problem reduces problem sense harder solve returning formallanguage framework decision proble language l1 polynomialtime reducible language written l1 exists polynomial time computable function function reduction function polynomialtime algorithm computes called reduction algorithm figure illustrates idea polynomialtime reduction language l1 language language subset reduction function polynomialtime mapping l1 fx l1 reduction function maps instance decision problem represented language l1 instance problem represented providing answer fx directly answer l1 figure illustration polynomialtime reduction language l1 language reduction function input question l1 answer question fx polynomialtime reductions powerful tool proving languages belong lemma l1 languages l1 implies l1 proof polynomialtime algorithm decides polynomialtime reduction algorithm computes reduction function construct polynomial time algorithm decides l1 figure illustrates construction input algorithm transform test fx output provided output figure proof lemma algorithm reduction algorithm computes reduction function l1 polynomial time polynomial time algorithm decides illustrated algorithm decides l1 transform input decide fx correctness condition algorithm runs polynomial time polynomial time exercise npcompleteness polynomialtime reductions provide formal showing problem hard polynomialtime factor l1 l1 polynomial factor harder equal notation reduction mnemonic define set npcomplete languages hardest problems np language npcomplete np np language satisfies property property nphard define npc class npcomplete languages theorem npcompleteness crux deciding fact equal np theorem npcomplete problem polynomialtime solvable np equivalently problem np polynomialtime solvable npcomplete problem polynomial time solvable proof suppose npc np property definition npcompleteness lemma proves statement theorem prove statement note contrapositive statement reason np question centers npcomplete problems theoretical comput scientists np leads relationships np npc figure polynomialtime algorithm npcomplete problem proving np polynomia ltime algorithm npcomplete problem discovered proof problem npcompl ete excellent evidence intractability figure theoretica computer scientists view relationships np npc npc wholly contained np npc ø circuit satisfiability defined notion npcomplete problem point proved problem npcomplete prove problem npcomplete polynomialtime reducibil ity tool prove npcompleteness problems focus demo nstrating existence npcomplete problem circuitsatisfiability problem formal proof circui tsatisfiability problem npcomplete requires technical scope text informally proof relies basic understanding boolean combinational circuits boolean combinational circuits built boolean combinational elements interconnected wires boolean combinational element circuit element constant number boolean inputs outputs performs welldefined function boolean values drawn setrepresents false represents true boolean combinational elements circuitsatisfiability problem compute simple boolean function logic gates figure basic logic gates circuitsatisfiability problem gate inverter gate gate gate takes single binary input produces binary output opposite input gates takes binary inputs produces single binary output figure basic logic gates binary inputs outputs gate truth table describes gates operation gate gate gate operation gate boolean combinational element truth table gate figure truth table outputs combinational element setting inputs truth table gate tells inputs output symbols denote function denote function denote function generalize gates inputs gates output inputs output gates output inputs output boolean combinational circuit consists bo olean combinational elements interconnected wires wire connect output element input providing output element input figure boolean combinational circuits differ gate figure values individual wires inputsingle wire combinationalelement output connected feed element nputs number element inputs fed wire called fanout wire element output connected wire wire circuit input accepting input values external source element input connected wire wire circuit output providing circuits computation internal wire fan circuit output purpose defining circuitsatisfiability problem limit number circuit outputs actual hardware design boolean combin ational circuit multiple outputs figure instances circuitsatisfiability problem assignmentinputs circuit output circuit circuit satisfiable assignment inputs circuit output circuit circuit unsatisfiable boolean combinational circuits cycles suppose create directed graph vertex combinational element directed edges wire fanout directed edge wire connects output element input element acyclic truth assignment boolean combinational circuit set boolean input values oneoutput boolean combinational circuit satisfiable satisfying assignment truth assignment caus output circuit circuit figure satisfying assignmentsatisfiable exercise asks assignment values circuit figure produce output produces unsatisfiable circuitsatisfiability problem boolean combin ational circuit composed gates satisfiable order pose question formally agree standard encoding circuits size boolean combinational circuit number boolean combinational elements number wires circuit devise graphlike encoding maps circuit binary string length polynomial size circuit formal language define circuitsat satisfiable boolean combinational circuit circuitsatisfiability problem arises area comput eraided hardware optimization subcircuit produces subcircuit replaced simpler subcircuit omits logic gates constant output helpful polynomialtime algorithm problem circuit attempt determine satisfiable simply checking assignments nputs inputs assignments size polynomial checking takes time superpolynomial size circuit fact claimed strong evidence polynomialtime algorithm exis solves circuitsatisfiability problem circuit satisfiabil ity npcomplete break proof fact parts based parts definition npcompleteness lemma circuitsatisfiability problem belongs class np proof provide twoi nput polynomialtime algorithm verify circuitsat inputs standard encoding boolean combinational circuit input certificate assignment boolean values wires exercise smaller certificate algorithm constructed logic gate circuit checks provided certificate output wire correctly computed function values input wires output entire circuit algorithm outputs values assigned inputs provide satisfying assignment outputs satisfiable circuit input algorithm certificate length polynomial size output unsatisfiable circuit input certificate fool believing circuit satisfiable algorithm runs polynomial time good implementation linear time suffices circuitsat verified polynomial time circuitsat np proving circuitsat npcomplete language nphard language np polynomialtime reducible circuitsat actual proof fact technical intricacies settle sketch proof based understanding workings computer hardware computer program stored computer memory sequence instructions typical instruction encodes operation performed addresses operands memory address result stored special memory location called program counter track instruction executed program counter automatically incremented instruction fetched causing computer execute instructions sequentiall execution instruction written program counter normal sequential execution altered allowing computer loop perform conditional branches point execution program entire state computation represented computers memory memory include program program counter working storage bits state computer maintains bookkeeping state computer memory configuration execution instruction viewed mapping configuration importantly computer hard ware accomplishes mapping implemented boolean combinational circuit denote proof lemma lemma circuitsatisfiability problem nphard proof language np polynomialtime algorithm computing reduction function maps binary string circuit circuitsat np exist algorithm verifies polynomial time algorithm construct twoinput algorithm compute reduction function denote worstcase running time algorithm lengthn input strings constant onk length certificate onk running time polynomial total input size includes input string certificate length certificate polynomial length input string running time polynomial basic idea proof represent computation sequence configurations figure configuration broken parts consisting program program counter auxili ary machine state input certificate working storage starting initial configuration c0 configuration mapped subsequent configuration ci1 combinational circuit implementing computer hardwa output algorithm a0 written designated location working storage finishes executing assume halts algorithm runs steps output appears bits figure sequence configurations produced algorithm running input certificate configuration represents state computer step computation includes program counter auxiliary machine state working storage certificate initial configuration c0 constant configuration mapped onfiguration boolean combinational circuit output distinguished bit working storage reduction algorithm constructs single combinational circuit computes configurations produced initial configuration idea paste copies circuit output ith circuit produces configuration fed directly input circuit configurations state register simply reside lues wires connecting copies recall polynomialtime reduction algorithm input compute circuit fx satisfiable exists certificate obtains input computes constructs combinational circuit consisting copies input initial configuration computation output configuration ctn circuit fx computes modifying inputs program initial program counter input initial state memory wired direct ly values remaining inputs circuit correspond certificate outputs circuit bit ctn output circuit constructed computes input length onk reduction algorithm provided input string computes circuit outputs properties remain proved correctly computes reduction function satisfiable exists certificate runs polynomial time correctly computes reduction functi suppose exists certificate length onk apply bits inputs output certificate exists satisfiable direction suppose satisfiable exists input conclude correctly computes reduction function complete proof sketch runs time polynomial observation number bits required represent configuration polynomial program constant size independent length input length input length certificate onk algorithm runs onk steps working storage required polynomial assume memory contiguous exercise asks extend argument situa tion locations accessed scattered larger region memory pattern scattering differ input combinational circuit implementing computer hard ware size polynomial length configuration polynomial onk polynomial circuitry implements logic memory circuit consists onk copies size polynomial construction accomplished polynomial time reduction algorithm step construction takes polynomial time language circuitsat hard language np belongs np npcomplete theorem circuitsatisfiability problem npcomplete proof lemmas definition npcompleteness exercises verify circuit figure unsatisfiable exercises relation transitive relation languages l1 l3 l1 l3 exercises prove exercises satisfying assignment certificate alternative proof lemma certificate easier proof exercises proof lemma assumes working storage algorithm occupies contiguous region polynomial ze proof assumption exploited argue assumption involve loss generality exercises language complete language class respect polynomialtime reductions ø languages complete respect polynomialtime reductions exercises complete np complete conp exercises reduction algorithm proof lemma constructs circuit fx based knowledge professor sartre observes string input existence constant factor implicit onk running time language belongs np actual values professor concludes construct circuit language circuitsat nphard explain flaw professors reasoning hand size circuit algorithm running time o2k running time polynomia circuit size np situation contradict fact problem npcomplete existence polynomial time algorithm special case impl polynomialtime algorithm cases npcompleteness proofs npcompleteness circuitsatisfiabi lity problem relies direct proof circuitsat language np prove languages npcomplete ithout directly reducing language np language illustrate methodology proving formulasatisfiability problems npcomplete examples methodology lemma basis method showing language npcomplete lemma language npc nphard np npc proof npcomplete np lp supposition transitivity exercise nphard np npc reducing npcomplete language implicitly reduce language np lemma method proving language npcomplete prove np select npcomplete language algorithm computes function mapping instance instance fx prove function satisfiesprove algorithm computing runs polynomial time steps nphard methodology reducing single np complete language simpler complicated process showing directly reduce language np proving circuitsat npc foot door knowing circ uitsatisfiability problem np complete prove easily problems npcomplete develop catalog npcomplete problems choices languages reduce formula satisfiability illustrate reduction methodology npcompleteness proof problem determining boolean formula rcuit satisfiable problem historical honor problem npcomplete formulate formula satisfiability problem terms language sat instance sat boolean formula composed boolean variables boolean connectives boolean function inputs output implication parentheses loss generality assume redundant parentheses pa parentheses boolean connective easy encode boolean formula length polynomial boolean combinational circuits truth assignment boolean formula set values variables satisfying assignment truth assignment evaluate formula satisfying assignment satisfiable formula satisfiability problem asks boolean formula satisfiable formallanguage terms sat satisfiable boolean formula formula x4 satisfying assignmentx4 formula belongs sat naive algorithm determine arbi trary boolean formula satisfiable polynomial time assignments formula variables length polynomial checking assignment requires time superpolynomial length theorem polynomialtime algorithm exist theorem satisfiability boolean formulas npcomplete proof start arguing sat np prove circuitsat nphard showing circuitsat sat lemma prove theorem sat belongs np certificate consisting satisfying assignment input formula verified polynomia time verifying algorithm simply replaces variable formula evaluates expression equation task easily polynomial time expression evaluates formula satisfiable condition lemma npcompleteness holds prove sat nphard circuitsat sat instance circuit satisfiability reduced polynomia time instance formula satisfiability induction express boolean combinational circuit boolean formula simply gate oduces circuit output inductively express gates inputs formulas formul circuit writing expression applies gates function inputs formulas straightforward method constitute polynomialtime reduction exercise asks shared subformu laswhich gates output wires fanout morecan size generated formula grow exponentially reduction algorithm clever figure illustrates basic idea redu ction circuitsat sat circuit figure wire circuit formula variable proper operation gate expressed formula involving variables incident wires operation output gate x10 x7 x8 x9 figure reducing circuit satisfiability formula satisfiability formula produced reduction algorithm variable wire circuit formula produced reduction algorithm circuitoutput variable conjunction clauses describing operation gate circuit figure formula x10 x4 x5 x6 x4 x7 x4 x8 x5 x6 x9 x6 x7 x10 x7 x8 x9 circuit straightforward produce formula polynomial time circuit satisfiable formula satisfiable satisfying assignment wire circuit welldef ined output circuit assignment wire values variables clause evaluate conjunction evaluates conversely assignment evaluate circuit satisfiable analogous argument circuitsat sat completes proof cnf satisfiability problems proved npcomplete reduction formula satisfiability reduction algorithm handle input formula requirement lead huge number cases considered desirable reduce restricted language boolean formulas fewer cases considered restrict langua polynomialtime solvable convenient language cnf satisfiability cnfsat define cnf satisfiability terms literal boolean formula occurrence variable negation boolean formula conjunctive normal form cnf expressed clauses literals boolean formula conjunctive normal form cnf clause distinct literals boolean formula x4 x4 cnf clauses literals cnfsat asked boolean formula cnf satisfiable theorem polynomialtime algorithm determine satisfiability boolean formulas exist expressed simple normal form theorem satisfiability boolean formulas conjunctive normal form npcomplete proof argument proof theorem sat np applies equally cnfsat np lemma sat cnfsat reduction algorithm broken ree basic steps step progressively transforms input formula closer desired conjunctive normal form step prove circuitsat sat theorem construct binary parse tree input formula literals leaves connectives internal nodes figure parse tree formula figure tree formula x2x1 x4x2 input formula clause literals associativity parenthesize expression fully internal node tree children binary parse tree viewed circuit computing function mimicking reduction proof theorem introduce variable yi output internal node rewrite original formula root variable conjunction clauses descri bing operation node formula expression y1 y1 y3 y4 y3 y4 y5 y5 y6 x4 y6 observe formula conjunction clauses literals additional requirement clause literals step reduction converts clause conjunctive normal form construct truth table evaluating assignments variables row truth table consists assignment variable clause clause assignment ing truthtable entries evaluate build formula disjunctive normal form dnfan andsthat equivalent convert formula cnf formula demorgans laws equations complement literals ange ors ands ands ors convert clause cnf truth table figure dnf formula equivalent y1 y1 y1 y1 y1 y1 figure truth table clause y1 applying demorgans laws cnf formula equivalent original clause clause formula converted cnf formula equivalent cnf formula consisting conjunction clause literals final step reduction transforms rmula clause distinct literals final cnf formula constructed clauses cnf formula auxiliary variables clause include clauses distinct literals simply include clause distinct literals l1 l1 literals include l1 l1 clauses literals fulfill syntactic requirement distinct literals clause l1 l1 equivalent l1distinct literal include clauses note setting conjunction clauses evaluate cnf formula satisfiable satisfiable inspecting steps reduction circuitsat sat construction step preserves satisf iability step produces cnf formula algebraically equivalent step produces cnf formula effectively equivalent assignment variables produces formula algebraically equivalent reduction computed polynomial time constructing introduces variable clause connective constructing introduce clauses clause clause variables truth table clauserows construction introduces clauses clause size formula polynomial length original formula constructions easily accomplished polynomial time exercises straightforward nonpolynomialtime reduction proof theorem circuit size converted formul method yields formula size exponential exercises cnf formula resu lts method theorem formula exercises professor jagger proposes sat cnfsat truthtable technique proof theorem steps professor proposes boolean formula form truth table variables derive truth table formula dnf equivalent negate apply demorgans laws produce cnf formula equivalent strategy yield polynomialtime reduction exercises problem determining boolean formula tautology complete conp hint exercise exercises problem determining tisfiability boolean formulas disjunctive normal form polynomialtime solvable exercises suppose polynomialtime algorithm decide formula satisfiability algorithm satisfying assignments polynomial time exercises cnfsat set satisfiable boolean formulas cnf literals clause cnfsat algorithm effici ent hint observe equivalent reduce cnfsat problem directed graph efficiently solvable npcomplete problems npcomplete problems diverse domains boolean logic graphs arithmetic network design sets partitions storage retrieval sequencing scheduling mathematical programming algebra number theory game puzzles automata language theory program optimization biology chemistry physics reduction methodology provide npcompletene proofs variety problems drawn graph theory set partitioning figure outlines structure npcompleteness proofs language figure proved npcomplete reduction language points root circuitsat proved npcomplete theorem figure structure npcompleteness proofs sections proofs ultimately follow reduction npcompleteness circuitsat clique problem clique undirected graph subset vertices pair connected edge clique complete subgraph size clique number vertices clique problem optimization problem finding clique maximum size graph decision problem simply clique size exists graph formal definition clique graph clique size naive algorithm determining graph vertices clique size list ksubsets check forms clique running time algorithm polynomial constant general case algorithm uns superpolynomial time suspect efficient algorithm clique problem exist theorem clique problem npcomplete proof clique np graph set vertices clique certificate checking clique accomplished polynomial time checking pair edge belongs prove cnfsat clique clique problem np hard prove sult surpri sing surface logical formulas graphs reduction algorithm instance cnfsat ck boolean formula cnf clauses clause distinct literals construct graph satisfiable clique size graph constructed clause place triple vertices edge vertices hold triples literals consistent negation graph easily computed polynomial time construction graph figure figure graph derived cnf formula reducing cnfsat clique satisfying assignment formula assignment satisfies satisfies clique lightly shaded vertices transformation reduction suppose satisfying assignment clause literal assigned literal corr esponds vertex picking true literal clause yields set vertices claim clique vertices literals mapped satisfying assignment literals compleme nts construction edge belongs conversely suppose clique size edges connect vertices triple vertex trip assign literal fear assigning literal complement edges inconsistent literals clause satisfied satisfied variables correspond vertex clique set arbitrarily figure satisfying assignment clique size consists vertices clause clause clause clique vertices set satisfying assignment observe proof theorem reduced arbitrary instance cnfsat instance clique structure clique nphard graphs vertices restricted occur triples edges vertices triple clique nphard restricted case proof suffices clique nphard general graphs polynomialtime algorithm solved clique general graphs solve clique restricted graphs sufficient reduce instances cnfsat special structure general instances clique case instances cnfsat chose reduce easy reduced nphard problem clique observe reduction instance cnfsat solution mistake polynomialtim reduction based knowing formula satisfiable determine polynomial time vertexcover problem vertex cover undirected graph subset vertex covers incident edges vertex cover set vertices covers edges size vertex cover number vertices graph figure vertex cover size figure reducing clique vertexcover undirected graph clique graph produced reduction algorithm vertex cover vertexcover problem vertex cover minimum size graph restating optimization problem decisi problem determine graph vertex cover size language define vertexcover graph vertex cover size theorem problem npcomplete theorem vertexcover problem npcomplete proof vertexcover np suppose graph integer certificate choose vertex cover verification algorithm affirms checks edge verification performed straightforwardly polynomial time prove vertexcover problem nphard showing clique vertexcover reduction based notion complem ent graph undirected graph define complement graph edges figure graph complement illustrates reduction clique vertexcover reduction algorithm takes input instance clique problem computes complement easily polynomia time output reduction algorithm instance vertexcover problem complete proof transformation reduction graph clique size graph vertex cover size suppose clique claim vertex cover edge implies belong pair vertices connected edge equivalently edge covered chosen arbitrarily edge covered vertex set size forms vertex cover conversely suppose vertex cover contrapositive implication clique size vertexcover npcomplete dont expect polynomialtime algorithm finding minimumsize vertex cover presents polynomialtime approximation algorithm produ ces approximate solutions vertex cover problem size vertex cover produced algorithm minimum size vertex cover shouldnt hope problem npcomplete polynomialtime approximation algorithm obtai nearoptimal lutions finding optimal solution npcomplete chapter approximation algorithms npcomplete problems hamiltoniancycle problem return hamiltoni ancycle problem defined theorem hamiltonian cycle problem npcomplete proof hamcycle belongs np graph certificate sequence vertices ham iltonian cycle verification algorithm checks seque nce vertex vertex repeated forms cycle checks edge pair consecutive vertices vertices verification performed polynomial time prove vertexcover hamcycle hamcycle npcomplete undirected graph integer construct undirected graph hamiltonian cycle vertex cover size construction based widget piece gra enforces properties figure widget edge graph construct widgetwhich denote wuv denote vertex wuv widget wuv vertices widget wuv edges figure figure widget reducing vertexcover problem hamiltoniancycle problem edge graph corresponds widget wuv graph created reduction widget individual vertices labeled shaded paths widget include vertices assuming connections widget remainder vertices internal structure widget enforce properties limiting connections widget remainder graph construct vertices edges incident wuv hamiltonian cycle traverse edges wuv ways figures cycle enters vertex exit vertex visits widgets vertices figure vertices figure case cycle reenter widget visit vertices cycle enters vertex exit vertex visits widgets vertices figure vertices figure paths widget visit vertices impossible construct rtexdisjoint paths connects connects union paths widgets vertices vertices widgets selector vertices s1 sk edges incident selector vertices select vertices cover addition edges widgets types edges figure vertex add edges join pairs widgets order form path widgets edges incident arbitrarily order vertices adjacent vertex u1 u2 udegreeu degree number vertices adjacent create path widgets edges incident adding edges ui1 degreeu figure order vertices adjacent graph figure includes edges vertex edges path widgets edges incident figure reduction instance vertexcover problem instance hamiltoniancycle problem undirected graph vertex cover size consisting lightly shaded vertices undirected graph produced reduction hamiltonian path correspondi vertex cover shaded vertex cover corresponds edges s1 appearing hamiltonian cycle intuition edges choose vertex vertex cover construct path u1 udegree covers widgets edges incident widgets path includes vertices vertex cover verticesvertex cover final type edge joins vertex u1 vertex udegreeu paths select vertices include edges u1 udegreeu size polynomial size construct time polynomial size vertices widgets selector vertices widget ntains vertices selector vertices total vertices edges widgets widgets connecting selector vertices widgets edges widget widgets vertex degree edges widgets summed vertices edges widgets finally edges pair consisting selector vertex vertex edges total number edgeskv vtransformation graph reduction vertex cover size hamiltonian cycle suppose vertex cover size u1 u2 figure form hamiltonian cycle including edges8 vertex include edges degreeuj connect widgets edges incident include edges widgets figures depending edge covered vertices hamiltonian cycle includes edges inspecting figure reader verify thes edges form cycle cycle starts s1 visits widgets correspo nding edges incident u1 visits visits widgets edges incident u2 returns s1 widget visited depending vertices cover edge vertex cover edge incident vertex cycle visits vertex widget cycle visits selector vertex hamiltonian conversely suppose hamiltonian cycle claim set vertex cover partition maximal paths start selector vertex traverse edge u1 selector vertex passing selector vertex path cover path constructed cover path start edge u1 vertex pass widgets edges incident selector vertex refer cover path equation widget visited wuv wvu widget visited vertices visited cover paths visited cover path edge covered vertex cover paths visit widget cover path pv implies edge covered vertex widget visited cover path edge covered vertex travelingsalesman problem travelingsalesman problem closely hamiltoniancycle problem salesman visit cities modeling problem complete graph vertices salesman wishes tour hamiltonian cycle visiting city finishing city starts integer cost travel city city salesman wishes tour total cost minimum total cost sum individual cost edges tour figure minimumcost tour cost formal language decision problem tsp complete graph function travelingsalesman tour cost figure instance travelingsalesman problem shaded edges represent minimumcost tour cost theorem fast algorithm travelingsalesman problem exist theorem travelingsalesman oblem npcomplete proof tsp belongs np instance problem certificate sequence vertices tour verification algorithm checks sequence vertex su edge costs checks sum process polynomial time prove tsp nphard hamcycle tsp instance hamcycle construct stance tsp form complete graph define cost function note undirected selfloops vertices instance tsp easily formed polynomial time graph hamiltonian cycle graph tour cost suppose graph hamiltonian cycle edge belongs cost tour cost conversely suppose graph tour cost costs edges cost tour edge tour cost edges conclude hamiltonian cycle graph subsetsum problem npcomplete problem cons ider arithmetic subsetsum problem finite set target subset elements sumsubset solution usual define problem language subsetsum exists subset arithmetic problem recall andard encoding assumes input integers coded binary ith assumption mind subsetsum problem unlik ely fast algorithm theorem subsetsum problem npcomplete proof subsetsum np instance problem subset certificat checking accomplished verification algorithm polynomial time cnfsat subsetsum cnf formula variables clauses ck distinct literals reduction algorithm constructs instance subsetsum problem satisfiable subset sum loss generality simplifyi assumptions formula clause variable negation clause automatically satisfied assignment values variables variable appears clause matter lue assigned variable reduction creates numbers set variable numbers clause create numbers base number digits digit corresponds variable clause base bases property preventing carries lower gits higher digits figure construct set target label digit position variable ause digits labeled clauses digits labeled variables target digit labeled vari digit labeled clause variable integers vi digit labeled vari digits literal appears clause digit labeled vi literal appears clause digit labeled digits labeled clauses vi vi values set unique vl values equal vi digits simplifying assumptions vi equal digits vi equal set clauses assume clause appears clause clause vi differ clause integers digits labeled digit digit integers slack variables whic clauselabeled digit position add target simple inspection figure demonstrates values unique set figure reduction cnfsat subsetsum formula cnf satisfying assignmentset produced reduction consists base10 numbers reading target subset lightly shaded satisfying assignment slack variables achieve target digits labeled note greatest sum gits digit position occurs digits labeled clauses vi values values interpreting numbers base carries occur lower digits higher digits9 reduction performed polynomial time set values digits time produce digit polynomial target digits reduction oduces constant time cnf formula satisfiable subset sum suppose satisfying assignmentassignment include vi include include vi values correspond literals satisfying assignment included vi digits labeled variables variablelabeled digit sum values matches digits target clause satisfied literal clause digit labeled clause contributed sum vi factliterals clause clauselabeled digit sumvi values figure literals satisfying assignment clauses literals v3 contribute sum digits clause literals v3 contribute sum digit clause literals v3 contribute sum digit achieve target digit labeled clause including nonempty subset slack variables figure includes matched target digits sum carries occur values sum suppose subset sums subset include vi digits labeled variables sum vi set set claim clause satisfied assignment prove claim note achieve sum digit labeled subset include vi digit labeled contributions slack variables sum includes vi position literal appears clause set vi clause satisfied includes position literal appears set clause satisfied clauses satisfied completes proof exercises subgraphisomorphism problem takes graphs g1 g2 asks g1 isomorphic subgraph g2 subgraphisomorphism problem np complete exercises integer mbyn matrix integer mvector integerprogramming problem asks integer nvector elements set prove integer programming npcomplete hint reduce cnf sat exercises integer linearprogramming problem intege rprogramming problem exercise values vector integers assuming integerprogramming problem nphard integer linearprogramming problem npcomplete exercises subsetsum problem solv polynomial time target expressed unary exercises setpartition problem takes input set numbers question numbers partitioned sets setpartition problem npcomplete exercises hamiltonianpat problem npcomplete exercises longestsimplecycle problem problem determini simple cycle repeated vertices maximum length graph problem npcomplete exercises half cnf satisfiability problem cnf formula variables clauses determine exists truth assignment variables half clauses evaluate half clauses evaluate prove half cnf satisfiability probl npcomplete problems independent set independent set graph subset vertices edge incident vertex independentset problem maximum size independent set formulate decision problem independentset problem prove npcomplete hint reduce clique problem suppose blackbox subroutine solve decision problem defined algorithm independent set maximum size running time algorith polynomial queries black box counted single step independentset decision problem npcomplete special cases polynomialtime solvable efficient algorithm solve ndependentset problem vertex degree analyze running time prove algorithm works correctly efficient algorithm solv independentset problem bipartite analyze running time prove algorithm works correctly hint problems bonnie clyde bonnie clyde robbed bank bag money divide scenarios polynomialtime algorithm prove problem npcomplete input case list items bag coins denominations coins worth dollars worth dollars divide money evenly coins arbitrary number denominations denomination nonnegative integer power denominations dollar dollars dollars divide money evenly checks amazing incidence bonnie clyde divide checks exact money checks accept split difference larger dollars problems graph coloring kcoloring undirected graph function edge numbers represent colors adjacent vertices colors graphcoloring problem determine minimum number colo needed color graph efficient algorithm determin coloring graph exists cast graphcoloring problem ecision problem decision problem solvable polynomial time graphcoloring problem solvable polynomial time language color set graphs colored color npcomplete decision problem npcomplete prove color npcomplete reduction cnfsat formula clauses variables construct graph set consists vertex variable vertex negation variable vertices clause special vertices true false red edges graph types literal edges independent clauses clause edges depend clauses literal edges form triangle special vertices form triangle red argue coloring graph literal edges variable negation colored ctrue colored cfalse argue truth assignment coloring graph literal edges widget figure enforce condition clause clause requires unique copy vertices heavily shaded figure connect literals clause special vertex true argue colored ctrue cfalse widget colorable colored ctrue complete proof color npcomplete figure widget clause problem problems scheduling profits deadlines suppose machine set tasks task processing time profit deadline machine process task time task uninterruptedly consecutive time units complete task deadline receive profit complete deadline receive profit optimization problem processing times profits deadlines set tasks schedule completes tasks returns greatest profit state problem decision problem decision problem npcomplete polynomialtime algorithm decision problem assuming processing times integers hint dynamic programming polyomialtime algorithm optimization problem assuming processing times integers technically define cycle terms vertices edges b4 clarity abuse notation define hamiltonian cycle terms edges fact base work instance subsection set target figure interpreted base listed sorted order chapter notes book garey johnson wonderful guide npcompleteness discussing theory length providing catalogue problems npcomplete proof theorem adapted book list npcomplete problem mains drawn table contents johnson wrote series columns journal algorithms reporting developments npcompleteness hopcroft motwani ullman lewis papadimitriou papadimitiou sipser good treatments npcompleteness context complexity theory aho hopcroft ullman cover npcompleteness seve ral reductions including reduction vertexcover problem hamiltoniancycle problem class introduced cobham independently edmonds introduced class np conjectured np notion np completeness proposed cook npcompleteness proofs formula satisfiability cnf satisfiability levin independently discovered notion npcompleteness proof tiling problem karp introduced methodology reductions demonstr ated rich variety npcomplete problems karps paper included original npcompleteness proofs clique vertex cover hamiltoniancycle problems sin hundreds problems proven npcomplete researchers talk meeting celebrating karps birthday papadimitriou remarked bout papers year term np complete title abstract list keywords terms compiler database expert neu ral network operating work complexity theory lig ht complexity computing approximate solutions work definition np probabilistically checkable proofs definition implies problems clique vertex cover travelingsalesman problem triangle inequality computing good approximate solutions nphard easier computing timal solutions introduction area aroras thesis chapter arora lund survey article arora book edited mayr promel steger survey article johnson chapter approximation algorithms problems practical significance np complete abandon obtaining optimal solution intractable problem npcomplete polynomialt ime algorithm solving actly hope approaches npcompleteness actual inputs small algorithm exponential running time perfectly satisfactory isolate special cases solvable polynomial time nearoptimal solutions polynomial time worst case average practice nearoptimality good algorithm returns nea roptimal solutions called approximation algorithm chapter presents polynomialtime approximation algorithms np complete problems performance ratios approximation algorithms suppose working optimization problem potential solution positive cost nearoptimal solution depending problem optimal solution defined maximum cost minimum cost problem eith maximization minimization problem algorithm problem approximation ratio input size cost solution produced algorithm factor cost optimal solution algorithm achieves approximation ratio approximation algorithm definitions approximation ratio napproximation algorithm apply minimization maximization oblems maximization problem ratio factor cost optimal solution larger cost approximate solution minimization problem ratio factor cost approximate solution larger cost optimal solution solutions assumed positive cost ratios defined approximation tio approximation algorithm implies approximation algorithm produces optimal solution approxi mation algorithm large approximation ratio return solution worse optimal problems polynomialtime approxi mation algorithms small constant approximation ratios developed problems polynomialtime approximation algorithms appr oximation ratios grow functions input size problem setcover problem presented npcomplete problems polynomia ltime approximation algorithms achieve increasingly smaller approximation ratio computation time tradeoff comput ation time quality approximation subsetsum problem studied situation deserve approximation scheme optimization problem approximation algorithm takes input instance problem fixed scheme approximation algorithm approximation scheme polynomialtime approximation scheme fixed scheme runs time polynomial size input instance running time polynomialtime approxima tion scheme increase rapidly decreases running time polynomialtime approximation scheme on2 ideally decreases constant factor running time achieve desired approximation increase constant factor running time pol ynomial approximation scheme fully polynomialtime approximation scheme approximation scheme running time polynomial size input instance scheme running time o12n3 scheme constantfactor decr ease achieved constantfactor increase running time approximation ratio independent terms approximation ratio approximation algorithm indicating dependence chapter outline sections chapter examples polynomialtime approximation algorithms npcomplete proble presents fully polynomialtime approximation scheme study vertexcover problem npcomplete minimization problem approximation algorithm approximation ratio presents approximation algorithm approximation ratio case avelingsalesman problem cost function satisfies triangle inequality triangle inequality constant approximation algorithm exist np greedy method effective approximation algorithm setcovering problem obtaining covering worst logarithmic factor larger optimal cost presents approximation algorithms study optimization version cnf satis fiability simple randomized algorithm produces solution pected approximation ratio examine weighted variant vertex cover problem linear programming develop appr oximatation algorithm finally presents fully polynomialtime approximation scheme subsetsum problem vertexcover problem vertexcover problem defined proven npcomplete vertex cover undirected graph subset edge size vertex cove number vertices vertexcover problem vertex cover minimum size undirected graph vertex cover optimal vertex cover problem optimization version npcomplete decision problem difficult optimal vertex cover graph hard vertex cover nearoptimal approximation algorithm takes input undirected graph returns vertex cover size guaranteed size optimal vertex cover approxvertexcoverg ø ø arbitrary edge remove edge incident return figure illustrates operation appr oxvertexcover variable vertex cover constructed initializes set sets copy edge set graph loop lines repeatedly picks edge adds endpoints deletes edges covered running time algorithm ov adjacency lists represent figure operation approxvertexcover input graph vertices edges edge heavy edge chosen approxvertexcover vertices lightly shaded set vertex cover created edges dashed removed covered vertex edge chosen vertices edge chosen vertices set vertex cover produced approxvertexcover vertices optimal vertex cover oblem vertices theorem approxvertexcover polynomial time approximation algorithm proof approx vertexcover runs polynomial time set vertices returned approxvertexcover vertex cover algorithm loops edge covered vertex approxvertexcover returns vert cover size optimal cover denote set edges picked approxvertexcover order cover edges vertex coverin optimal cover cmust include endpoint edge edges share endpoint edge picked edges incident endpoints deleted edges covered vertex lower bound size optimal vertex cover execution picks edge endpoints yielding upper bound exact upper bound fact size vertex cover returned combining equations proving theorem reflect proof prove size vertex cover returned approxvertexcover size optimal vertex cover size optimal vertex cover answer utilize lower bound optimal vertex cover exercise asks set edges picked approxvertexcover maximal matching graph maximal matching matching proper subset matching size maximal matching argued proof theorem lower bound size timal vertex cover algorithm returns vertex cover size size maximal matching relating size solution returned lower bound approximation ratio methodology sections exercises graph approxvertexcover yields suboptimal solution exercises denote set edges picked approxvertexcover prove set maximal matching graph exercises professor nixon proposes heuristic solve vertexcover problem repeatedly select vertex highest degree remove incident edges professors heuristic approximation ratio hint bipartite graph vertices uniform degree left vertices varying degree exercises efficient greedy algorithm finds timal vertex cover tree linear time exercises proof theorem vertexcover problem npcomplete clique problem complementary sense optimal vertex cover complement maximumsize clique mplement graph relationship imply polynomialtime approximation gorithm constant approximation ratio clique problem justify answer travelingsalesman problem travelingsalesman problem introduced complete undirected graph nonnegative integer cost edge hamilt onian cycle tour minimum cost extension notation denote total cost edges subset practical situations cheapest directly place place intermediate expensive putting cutting intermediate increase cost formalize notion cost function satisfies triangle inequality vertices triangle inequality natu ral applications automatically satisfied vertices graph points plane cost traveling vertices ordinary euclidean distance triangle inequality satisfied cost functions euclidean distance satisfy triangle inequality exercise travelingsalesman problem npcomplete require cost function satisfy triangle ineq uality polynomialtime algorithm solving prob lem good approximation algorithms examine approximation algor ithm travelingsalesman problem triangle inequality triangle inequality polynomialtime approximation algo rithm constant approximation ratio exist np travelingsalesman prob lem triangle inequality applying methodology previous compute structurea minimum spanning treewhose weight lowe bound length optimal traveling salesman tour minimum anning tree create tour cost minimum spanni trees weight long cost function satisfies triangle inequality gorithm implements approach calling minimumspanningtree algorithm mstprim subroutine approxtsptourg select vertex root vertex compute minimum spanning tree root mstprimg list vertices visited preorder tree walk return hamiltonian cycle visits vertices order recall preorder tree walk recursivel visits vertex tree listing vertex encountered children visited figure illustrates operation approxtspt figure set vertices minimum spanning tree grown root vertex mstprim vertices visited preorder walk displays tour tour returned approxtsptour displays optimal shorter figure operation approxtsptour set points lie vertices integer grid unit units ordinary euclidean distance cost function points minimum spanning tree points computed mstprim vertex root vertex vertices happen labeled main tree mst prim alphabetical order walk starting walk tree visits vertices order preorder walk lists vertex encountered indicat dot vertex yielding ordering tour vertices visiting vertices order preorder walk tour returned approxtsptour total cost optimal tour set vertices total cost exercise simple implementati mstprim running time approxtsptour v2 cost function instance travelingsalesman problem satisfies triangle inequality approxtsptour returns tour cost cost optimal tour theorem approxtsptour polynomialtime pproximation algorithm traveling salesman problem triangle inequality proof approx tsptour runs polynomial time denote optimal tour set vertices spanning tree deleting edge tour weight minimum spanning tree lower bound cost optimal tour walk lists vertices visited returned visit subtree walk walk order walk traverses edge extending definition cost natural manner handle multisets edges equations imply cost factor cost optimal tour generally tour visits vertices triangle inequality delete visit vertex cost increase vertex deleted visits ordering specifies directly repeatedly applying operation remove visit vertex leaves ordering ordering preorder walk tree cycle preorder lk hamiltonian cycle vertex visited fact cle computed approxtsptour deleting vertices walk combining inequalities completes proof spite nice approximation ratio provided theorem approxtsptour practical choice problem approximation algorithms typically perform practice references chapter general travelingsalesman problem drop assumption cost function satisfies tria ngle inequality good approximate tours polynomial time np theorem np constant polynomialti approximation algorithm approximation ratio general trave lingsalesman problem proof proof contradiction suppose contrary number polynomialtime approximation algorithm approximation ratio loss generality assume integer rounding solve instances hamilt oniancycle problem defined polynomial time hamiltoni ancycle problem npcomplete theorem solving polynomial time implies np theorem instance hamiltonianc ycle problem determine efficiently hamiltonian cycle making hypothesized approximation algorithm turn instance travelingsalesman problem complete graph assign integer cost edge representations created representation time polynomial travelingsalesman problem original graph hamiltonian cycle cost function assigns edge cost tour cost hand hamiltonian cycle tour edge tour edge cost edges costly gap cost tour hamiltonian cycle cost cost tour cost apply approximation algorithm travelingsalesman problem guaranteed return tour cost times cost optimal tour hamiltonian cycle return hamiltonian cycle returns tour cost solve hamiltoniancycle problem polynomial time proof theorem general technique proving problem approximated suppose nphard problem produce minimization problem instances correspond instances instances correspond instances greater np approximation algorithm problem exercises suppose complete undirected graph vertices cost function satisfies triangl inequality prove exercises polynomial time transform instance travelingsalesman problem instance hose cost function satisfies triangle inequality instances set optimal tours explai polynomialtime transformation contradict theorem assuming np exercises closestpoint heuristic building approximate travelingsalesman tour trivial cycle consisting single arbitrarily chosen vertex step identify vertex cycle distance vertex cycle minimum suppose vertex cycle nearest vertex extend cycle include inserting repeat vertices cycle prove heuristic returns tour total cost cost optimal tour exercises bottleneck travelingsalesman problem problem findi hamiltonian cycle cost costly edge cycle minimized assuming cost function satisfies triangle inequality exists polynomialtime approximation algorithm approxima tion ratio problem hint recursively visit nodes bottleneck spanning tree discussed problem walk tree skipping nodes skipping consecutive intermediate nodes costliest edge bottleneck spanning tree cost cost costliest edge bottleneck hamiltonian cycle exercises suppose vertices instance travelingsalesman problem points plane cost euclidean distance points optimal tour crosses setcovering problem setcovering problem optimization problem models resourceselection problems ecision problem generalizes npcomplete vertexcover problem nphard appr oximation algorithm developed handle vertexcover problem doesnt apply approaches examine simple greedy heuristic logarithmic approximation ratio size instance larger size approximate solution grow relative size optimal solution loga rithm function grows slowly approximation algorithm netheless instance setcovering problem consists finite set family subsets element belongs subset subset covers elements problem minimumsize subset members cover satisfying equation covers figure illustrates setcovering problem size defined number sets number individual elements sets figure minimum set cover size figure instance setcovering problem consists black points minimumsize set cover greedy algorithm produces cover size selecting sets s1 s4 s5 s3 order setcovering problem abstracti commonly arising combinatorial problems simple suppose represents set skills needed solve problem set people work problem form committee ople requisite skill member committee skill decision version setcovering problem covering exists size additional parameter oblem instance cision version problem npcomplete exercise asks greedy approximation algorithm greedy method works picking stage set covers greatest number remaining elements uncovered greedysetcoverxø select maximizesreturn figure greedysetcover adds sets s1 s4 s5 s3 order algorithm works set stage set remaining uncovered elements set cover constructed greedy decisionmaking step subset chosen covers uncovered elements ties broken arbitrarily selected elements removed algorithm terminates set subfamily covers algorithm greedysetcover easily implemented time polynomial number iterations loop lines bounded min loop body implemented time implementation runs time min exercise asks linear time algorithm analysis greedy algorithm returns cover larger optimal set cover convenience chapter denote dth harmonic number boundary condition define theorem greedysetcover polynomialtime napproximation algorithm proof greedy setcover runs polynomial time greedysetcover napproximation algorithm assign cost set selected algorithm distribute cost elements covered time costs derive desired relationship size optimal set cover size set cover returned algorithm denote ith subset selected greedysetcover algorithm incurs cost adds spread cost selecting evenly elements covered time denote cost allocated element element assigned cost covered time covered time step algorithm unit cost assigned cost assigned optimal cover set combining previous equalities remainder proof rests follo wing key inequality prove shortly set belonging family inequalities proving theorem remains prove inequality set s1 number elements remaining uncovered s1 selected algorithm define u0 number elements initially uncovered element covered sets s1 sk ui1 ui1 elements covered time observe s1 si1 s1 si1 ui1 greedy choice guarantees cover elements chosen bound quantity completes proof inequality corollary greedysetcover polynomialtime approximation algorithm proof inequality a14 theorem applications small constant solution returned greedysetcover small consta times larger optimal application occurs heuristic approxima vertex cover graph vertices degree case solution greedysetcover times large optimal solution performance guarantee tter approxvertexcover exercises set letters arid dash drain heard lost nose shun slate snare thread cover greedysetcover produces ties broken favor word appears dictionary exercises decision version setcovering problem npcomplete reduction vertexcover problem exercises implement greedysetcover runs time exercises followi weaker form theorem trivially true exercises greedysetcover return number solutions depending break ties procedure badsetcoverinstance returns nelement instance setcovering problem depending ties broken greedysetcover return number fferent solutions exponential randomization linear programming study techniques designing approximation algorithms randomization linear programming simple randomized algorithm optimization version cnf satisfiability linear programming design approximation gorithm weighted version vertex cover problem scratches surface powerful techniques chapter notes references study areas randomized approximation algorith max3cnf satisfiability randomized algorithms compute exact solutions randomized algorithms compute approximate solutions randomized algorithm problem approximation ratio input size expected cost solution produced randomized algorithm factor cost optimal solution randomized algorithm achieves approximation ratio randomized napproximation algorithm randomized approximation algorithm deterministic approximation algorithm approximation ratio expected instance cnf satisfiability defined satisfiable order satisfiable assignment variables clause evaluates instance satisfiable compute close satisfiable sh assignment variables satisfies clauses maximization problem max3cnf satisfiability input max3cnf satisfiability cnf satisfiability goal return ssignment variables maximizes number clauses evaluating randomly setting eac variable probability probability randomized approximation algorithm definition cnf satisfiability require clause consist distinct literals assume clause variable negation exercise asks remove assumption theorem instance max3cnf satisfiability variables clauses randomized algorithm independently sets variable probability probability randomized approximation algorithm proof suppose independently set variable probability probabilitydefine indicator random variable yi iclause satisfied yi long literals ith clause set literal appears clau assumed variable negation clause ttings litera clause independent clause satisfied literals set clause satisfied prclause satisfiedlemma yi number satisfied clauses y1 ym upper bound number satisfi clauses approximation ratio m7m8 approximating weighted vertex cover linear programming minimumweight vertexcover problem undirected graph vertex positive weight wv vertex cover define weight vertex cover wv vv wv goal vertex cover minimum weight apply algorithm unweight vertex cover random solution methods solutions optimal compute lower bound weight mini mumweight vertex cover linear program round soluti vertex cover suppose associate variable vertex require interpret vertex cover interpret vertex cover write constraint edge vertex cover xu view rise integer program finding minimumwe ight vertex cover minimize subject exercise finding values satisfy nphard formulation suppose remove constraint replace linear program linearprogramming relaxation minimize subjectfeasible solution integer program lines feasible solution linear program lines optimal solution linear program lower bound optimal lution integer program lower bound optimal solution minimumweight vertexcover problem procedure solution linear program construct approximate solution minimumweight vertexcover problem approxminweightvcg ø compute optimal solution linear program lines return approxminweightvc procedure works initializes vertex cover formulates li program lines solves linear program optimal solution vertex guide choice vertices add vertex cover lines add rounding fractional variable solution linear program order solution integer program lines finally returns vertex cover theorem algorithm approxminweightvc pol ynomialtime approximation algorithm minimumweight vertexcover problem proof polynomialtime algorithm solve linear program loop lines runs polynomial time approxminweightvc polynomialtime algorithm approxminweightv approximation algorithm optimal solution minimumweight vertexcover problem optimal solution lin ear program lines optimal vertex cover feasible solution linear program lower bound wc claim rounding actional values variables produce set vertex cover satisfies wc vertex cover edge constraint xu implies included vertex cover edge covered weight cover combining inequalities wc wc approxminweightvc approximation algorithm exercises clause variable negation randomly setting variable probabilityprobability randomized approximation algorithm exercises maxcnf satisfiability problem max3cnf satisfiability problem restrict clause literals randomized approximation algorithm maxcnf satisfiability problem exercises maxcut problem ven unweighted undirected graph define cut chapter weight cut number edges crossing cut goal cut maximum weight suppose vertex randomly independently place probability probability algorithm randomized approximation algorithm exercises constraints redundant sense remove linear program lines optimal solution linear program satisfy subsetsum problem instance subsetsum problem pair set positive integers positive integer decision problem asks exists subset adds target problem npcomplete optimization problem decision problem arises practical applications optimization proble subset sum large larger truck carry pounds boxes ship ith weighs pounds truck heavy load exceeding weight limit exponentialtime algorithm optimization problem modify algorithm fully polynomialtime approximation scheme recall fully pol ynomialtime approximation scheme running time polynomial size input exponentialtime exact algorithm suppose computed subset sum elements selected subsets sum exceed sum closest algorithm return optimal solution exponential time implement algorithm iterative procedure iteration computes sums subsets starting point sums subsets xi1 realize subset sum exceeding reason intain superset optimal solution implementation strategy procedure exactsubsetsum takes input set target pseudocode moment procedure iteratively computes li list sums subsets exceed returns maximum list positive integers positive integer denote list integers derived increasing elementnotation sets auxiliary procedure mergelistsl returns rted list merge sorted input lists duplicate values removed merge procedure merge sort mergelists runs time omit pseudocode mergelists exactsubsetsums l0 li mergelistsli1 li1 remove li element greater return largest element exactsubsetsum works denote set values selecting subset summing members identity prove induction exercise list li sorted list element length li exactsubsetsum exponentialtime algorithm general polynomialtime algorithm special cases polynomial numbers bounded polynomial fully polynomialtime approximation scheme derive fully polynomialtime approxi mation scheme subsetsum problem trimming list li created idea values close purpose finding approximate solution reason maintain explicitly precisely trimming parameter trim list remove elements result trimming element removed element approximates representing list represented satisfying inequality trim deleted represented deleted values represented deleted represented element trimmed version list element original version list trimming dramatically decrease number elements keeping close smaller representative list deleted element procedure trims list y1 ym time assuming sorted monotonically increasing order output procedure trimmed sorted list triml y1 y1yi yi sorted append yi yi return elements scanned monotonically increasing order number returned list element represented number procedure trim construct approximation scheme procedure takes input set integers arbitr ary order target integer approximation parameter returns factor optimal solution approxsubsetsums l0 li mergelistsli1 li1 li trimli remove li element greater largest return initializes list l0 list element loop lines computing li sorted list suitably trimmed version set elements larger removed li created li1 ensure repeated trimming doesnt introduce inaccuracy moment approxsubsetsum returns rrect approximation exists suppose instance trimming parameter approxsubsetsum computes values lines l0 l1l1l1 l3l3 l3 l4line l4 l4 algorithm returns answer optimal answer fact theorem approxsubsetsum fully polynomialtim approximation scheme subset sum problem proof operations trimming li removing li element greater maintain property element li member returned sum subset denote optimal solution subsetsum problem inequality yz running tim algorithm polynomial size input induction element li exercise inequality hold fulfilling inequality inequality hold largest remains yz showing equation limn1 function increases approaches limit combining inequalities completes analysis approximation ratio approxsubsetsum fully polynomialtime approximation scheme derive bound length li trimming successive elements li relationship differ factor list lue log12n additional values number elements list li bound polynomial size inputwhich number bits lg needed represent number bits eeded represent set turn polynomial nand running time approx subsetsum polynomial lengths li approxsubsetsum fully polynomialtime approximation scheme exercises prove equation execu ting exactsubsetsum li sorted list element exercises prove inequality exercises prove inequality exercises modify approx imation scheme presented good approximation smalle sum subset input list problems bin packing suppose set objects size ith object satisfies pack obj ects minimum number unitsize bins bin hold subset objects total size exceed prove problem determining minimum number bins required np hard hint reduce subsetsum problem firstfit heuristic takes object turn places bin accommodate argue optimal number bins required argue firstfit heuristic leaves bin half prove number bins firstfit heuristic prove approximation ratio firstfit heuristic efficient implementation firs tfit heuristic analyze running time problems approximating size maximum clique undirected graph define gk undirected graph vk ek vk set ordered ktuples vertices ek defined v1 v2 vk adjacent w1 w2 wk vertex vi adjacent vi prove size maximum clique gk equal kth power size maximum clique argue approximation gorithm constant approximation ratio finding maximumsize clique fully polynomialtime approximation scheme problem problems weighted setcovering problem suppose generalize setcovering problem set family weight weight cover determine minimum weight cover handles case greedy setcovering heuristic generalized natural manner provide approximate solution instance weighted setcovering problem heuristic approximation ratio hd maximum size set problems maximum matching recall undirected graph matching set edge edges set incident vertex maximum matching bipartite graph problem matchings undirected graphs general graphs required bipartite maximal matching matching oper subset matching maximal matching maximum matching exhibiting undirected graph maximal matching maximum matching graph vertices undirected graph oetime greedy algorithm maximal matching problem concentrate polynomialtime approximation algorithm maximum matching fastest algorithm maximum matching takes superlinear polynomial time approxima tion algorithm linear time lineartime greedy algor ithm maximal matching approximation algorithm maximum matching size maximum matching lower bound size vertex cover maximal matching edge incident subgraph induced vertices conclude size vertex cover parts prove greedy algorithm approximation algorithm maximum matching problems parallel machine scheduling parallelmachinescheduling problem jobs j1 j2 jn job jk nonnegative processing time identical machines m1 mm schedule specifies job jk machine runs time period runs job jk machine mi consecutive time units time period job mi ck denote completion time job jk time job jk completes processing schedule define cmax max jn ck makespan schedule goal schedule makespan minimum suppose machines m1 jobs j1 j2 j3 j4p4 schedule runs machine m1 job j1 job j2 machine runs job j4 job j3 schedule cmax optimal schedule runs j2 machine m1 runs jobs j1 j3 j4 machine schedule cmax parallelmachinescheduling problem denote makespan optimal schedule optimal makespan leas large greatest processing time optimal makespan large average machine load suppose greedy algorithm parallel machine scheduling machine idle schedule job scheduled write pseudocode implement greedy algorithm running time algorithm schedule returned greedy algorithm conclude algorithm polynomialtime approximation algorithm chapter notes methods mpute exact solutions thousands years thods approximate notion approximation algorithm hochbaum credits garey graham ullman johnson formalizing concept polynomialtime approximation algorithm algorithm credited graham subject problem early work thousands approxima tion algorithms designed wide range problems wealth literature field texts ausiello hochbaum vazirani deal exclusively approximation algorithms surveys shmoys klein young texts garey johnson papadimitriou steiglitz coverage approximation algorithms lawler lenstra rinnooy kan shmoys provide extensive treatment approxi mation algorithms travelingsalesman problem papadimitriou steiglitz attribute algorithm approxvertexcover gavril yannakakis vertexcover problem studied extensively hochbaum lists approximation algorithms problem approximation ratios o1 algorithm approxtsptour appears paper rosenkrantz stearns lewis christofedes improved algorithm approximation algorithm travelingsalesman problem triangle inequality arora mitchell points euclidean plan polynomialtime approximation scheme theorem sahni gonzalez analysis greedy heuristic setcove ring problem mode led proof published chvátal general result basic result presented johnson lovász algorithm approxsubsetsum anal ysis loosely odeled approximation algorithms kna psack subsetsum problems ibarra kim randomized algorithm max3cnf tisfiability implicit work johnson weighted vertexcover algorithm hochbaum touches power randomization linear programming design approximation algorithms combination ideas yields technique called randomized rounding problem formulat integer linear program linear programming relaxation solved variables solution interpreted probabilities probabilities guide solution original problem technique raghavan thompson subsequent motwani naor raghavan survey notable ideas field approximation algorithms include primal dual method survey finding sparse cuts divide conquer algorithms semidefinite programming mentioned chapter notes chapter probabilistically checkable proofs led lower bounds approxima bility problems including chapter addition references chapter arora lund good description relationship probabilistically checkable proofs hardness approximating problems viii appendix mathematical background chapter list appendix summations appendix sets appendix counting probability introduction analysis algorithms requires draw body mathematical tools tools simple highschool algebra manipulate asymptotic notations solve recurrences appendix compendium concepts met hods analyze algorithms introduction terial appendix read book specific notational conventions occasionally differ books henc treat appendix reference material rest book included exercises problems order improve skills areas appendix offers methods evaluating ounding summations occur frequently analysis algorithms formulas chapter calculus text convenient methods compiled place appendix basic definitions notations sets relations functions graphs trees chapter basic properties mathematical objects appendix elementary principles counting permutations combinations remainder chapter definitions properties basic probability algorithms book require obability analysis easily omit sections chapter reading skimming encounter probabilistic analysis understand appendix organized reference purposes appendix summations overview algorithm iterative control construct loop running time expressed sum times spent execution body loop jth iteration insertion sort time proportional worst case adding spent iteration summation series evaluating summation yielded bound worstcase running time algorithm general understand ing manipulate bound summations lists basic formulas involving summations offers techniques bounding summations formulas proof proofs presented illustrate methods proofs calculus text summation formulas properties sequence numbers finite sum nonnegative integer written summation defined finite series defined terms order sequence numbers infinite sum written interpreted limit exist series diverges converges terms convergent series order rearrange terms absolutely convergent series series series converges linearity real number finite sequences linearity property obeyed infinite convergent series linearity property exploited nipulate summations inco rporating asymptotic notation equation notation lefthand applies variable righthand applies manipulations plied infinite convergent series arithmetic series summation arithmetic series sums squares cubes summati ons squares cubes geometric series real summation geometric exponential series a5 summation infinite infinite decreasing geometric series a6 harmonic series positive integers nth harmonic number a7 prove bound integrating differentiating series additional formulas integrat ing differentiating formulas differentiating sides infinite geometric series a6 multiplying a8 telescoping series sequence a0 a9 terms an1 subtracted sum telescopes telescoping sum series rewrite term products finite product written product defined convert formula product formula summation identity exercises a11 simple formula exercises a12 manipulating harmonic series exercises a13 exercises a14 exercises a15 evaluate sum exercises a16 prove linearity property summations exercises a17 evaluate product exercises a18 evaluate product bounding summations techniques bounding summations running times algorithms frequently methods mathematical induction basic evaluate series mathematical inducti prove arithmetic series evaluates easily verify inductive assumption holds prove holds guess exact summa tion order mathematical induction induction bound prove geometric series o3n prove constant initial condition long assuming bound holds prove holds long equivalently wished careful asym ptotic notation prove bounds induction fallacious proof assuming bound prove bug argument cons tant hidden bigoh grows constant constant works bounding terms good upper bound series bounding term series suffices largest term bound quick upper bound arithmetic series general series amax max knak technique bounding term series largest term weak method series fact bounded geometric series series suppose ak1akconstant sum bounded infinite decreasing geometric series ak a0rk apply method bound summation order start summation rewrite term a0 ratio consecutive terms common bug applying method ratio consecutive terms assume summa tion bounded geometric series infinite harmonic ries diverges ratio kth terms series kk series bounded decreasing geometric series bo und series geometric series constant ratio pairs consecutive terms exceeds harmonic series exists ratio arbitrarily close splitting summations bounds difficult summation express series sum series partitioning range bound series suppose lower bound arithmetic series upper bound attempt bound term summation smallest term term lower bound summation upper bound lower bound splitting summation assume convenience asymptotically tight bound summation arising analysis algorithm split summation ignore constant number initial terms generally technique applies term ak summation independent constant k0 write initial terms summation constant constant number methods bound technique applies infinite summations asymptotic upper bound observe ratio consecutive terms summation split summation constant num ber terms summation decreasing geometric series technique splitting summations determine asymptotic bounds difficult situations bound olg harmonic series a7 idea split range lg pieces upperbound contribution piece piece consists terms starting including i1 a10 approximation integrals summation expressed monotonically increasing function approximate integrals a11 justification approximation figure summation represented area rectangles figure integral shaded region curve fk monotonically decreasing functi method provide bounds a12 figure approximation integrals area rectangle rectangle total rectangle area represents summation integral represented shaded area curve comparing areas shifting rectangles unit integral approximation a12 tight estimate nth harmonic number lower bound a13 upper bound derive inequality yields bound a14 exercises a21 bounded constant exercises a22 asymptotic upper bound summation exercises a23 nth harmonic number lg splitting summation exercises a24 approximate integral exercises a25 didnt integral approximation a12 directly upper bound nth harmonic number problems bounding summations asymptotically tight bounds summations assume constants chapter notes knuth excellent reference material presented chapter basic properties series good calculus book apostol thomas finney appendix sets chapters book touch elemen discrete mathem atics chapter reviews completely notations defini tions elementary properties sets relations functions graphs trees readers versed material skim chapter sets set collection distinguishable objects called members elements object member set write read member member write set explicitly listing members list inside braces define set precisely numberswriting member set write member set object once1 elements ordered sets equal written elements adopt special notations frequently encountered sets ø denotes set set members denotes set integers set denotes set real numbers denotes set natural numbers setelements set contained set implies write subset set proper subset written authors symbol denote ordinary subset relation propersubset relation set sets sets set ø define sets rms sets set define set stating property distinguishes elements define set integers integer colon notation read authors vertic bar place colon sets define sets applying set operations intersection sets set union sets set difference sets set set operations obey laws set laws ø ø ø idempotency laws commutative laws associative laws distributive laws absorption laws demorgans laws demorgans laws illustrated figure venn diagram graphical picture sets repres ented regions plane figure venn diagram illustrating demorgans laws sets represented circle sets consideration subsets larger set called universe sets integersthe set integers universe universe define complement set set laws demorgans laws rewritten complements sets sets disjoint elements common ø collection nonempty sets forms partition set sets pairwise disjoint imply ø union forms partition element appears number elements set called cardinality size set denoted sets cardinality elemen onetoone correspondence cardinality set ø cardinality set natural number set finite infinite infinite set onetoone correspondence natural numbers countably infinite uncountable integers countable reals uncountable finite sets identity conclude disjoint finite set elements called nset set called singleton subset elements set called ksubset set subsets set including set denoted called power set øa power set finite set cardinality care setlike structures elements ordered ordered pair elements denoted defined formally set ordered pair ordered pair cartesian product sets denoted set ordered pairs element pair element element formally finite sets cardinality cartesian product b4 cartesian product sets set ntuples ai ai cardinality sets finite denote nfold cartesian product single set set cardinality finite ntuple viewed finite sequence length exercises b11 draw venn diagrams illustrate distributive laws exercises b12 prove generalization demorgans ws finite collection sets exercises b13 prove generalization equation called principle inclusion exclusion pairs triples n1 exercises b14 set odd natural numbers countable exercises b15 finite set power set elements distinct subsets exercises b16 inductive definition ntuple extending settheoretic definition ordered pair variation set object called multiset authors start natural num bers modern trend start relations binary relation sets subset cartesian product write binary relation set subset relation natural numbers set nary relation sets subset binary relation reflexive reflexive relations relation symmetric implies symmetric relation transitive imply relations transi tive relation imply relation reflexive symmetric transitive equivalence relation equivalence relation natural numbers equivalence relation set equivalence class set set elements equivalent define number equivalence relation reflexive implies symmetric imply transitive equivalence class equivalence class basic theorem equiva lence classes theorem equivalence relati partition equivalence classes equivalence relation set form partition partition determines equivalence relation sets partition equivalence classes proof proof equivalence classes nonempty pairwisedisjoint sets union reflexive equivalence classes nonempty element belongs equivalence class union equivalence classes remains equivalence classes pairwise disjoint equivalence classes element common fact set symmetry transitivity imply arbitrary element implies proof partition define exists ai ai claim equivalence relation reflexivity holds ai implies symmetry holds set ai elements set transitivity holds sets partition equivalence classes observe ai implies ai ai implies binary relation set antisymmetric imply relation natural numbers antisymmetric imply relation reflexive tisymmetric transitive partial order set partial order defined partially ordered set relation descendant partial order people view individuals descendants partially ordered set single maximum element maximal elements case collection differentsized boxes maximal boxes dont fit inside box single maximum box box fit3 partial order set total linear order pairing elements relation total order natural numbers descendant relation total order set people individuals descended exercises b21 prove subset relation subsets partial order total order exercises b22 positive integer relation equivalent modulo equivalence relation integers mod exists integer qn equivalence classes relation partition integers exercises b23 examples relations reflexive symmetric transitive reflexive transiti symmetric symmetric transitive reflexive exercises b24 finite set equivalence relation addition antisymmetric equivalence classes respect singletons exercises b25 professor narcissus claims relation symmetric transi tive reflexive offers proof symmetry implies transitivity implies professor correct precise order fit inside relation partial order view box fitting inside functions sets function binary relation exists precisely set called domain set called codomain write write uniquely determined choice intuitively function assigns element element element assigned elements element assigned elements binary relation mod function natural number mod f0 f1 contrast binary relation function choice precisely function argument define function stating element domain define functions equal domain codomain domain finite sequence length function domain set integersdenote finite quence listing values f0 f1 infinite sequence function domain set natural numbers fibonacci sequence defined recurrence infinite sequence domain function cartesian product omit extra parentheses surrounding argument function write ai argument function technically single argument ntuple function image image set defined range image domain range function defined function surjection range codomain function surjective function element appears argument contrast function surjective function argument produce function surjective function natural numb ers numbers surjection mapping surjective function injection distinct arguments produce distinct values implies function injective function number image element domain function injective produced arguments injection called onetoone function function bijection injective surjective function bijection function injectiv element image element surjective element appears image element function bijective bijection called onetoone correspondence pairs elements domain codomain bijection set called permutation function bijective inverse f1 defined f1b inve rse function exercises b31 finite sets function injective surjective exercises b32 function fx bijective domain codomain bijective domain codomain exercises b33 natural definition inverse binary relation relation fact bijective function relational inverse functional inverse exercises b34 bijection b4 graphs presents kinds graphs dir ected undirected definitions literature differ fferences slight graphs represented computer memory directed graph digraph pair finite set binary relation set called vertex set elements called vertices singular vertex set called edge set elements called edges figure b2a pictorial representation directed graph vertex set vertices represented circles figure edges represented arrows note selfloopsedges vertex itselfare figure directed undirected graphs directed graph edge selfloop undirected graph vertex isolated subgraph graph induced vertex set undirected graph edge set consists unordered pairs vertices ordered pairs edge set convention notation edge set notation considered edge undirected graph selfloops forbidden edge consists distinct vertices figure b2b pictorial representation undirected graph vertex set definitions directed undirected graphs terms meanings contexts edge directed graph incident leaves vertex incident enters vertex edges leaving vertex figure b2a edges entering vertex edge undirected graph saythat incident vertices figure b2b edges incident vertex edge graph vertex adjacent vertex graph undirected adjacency relation symmetric graph directed adjacency relation ecessarily symmetric adjacent directed graph write parts figure vertex adjacent vertex edge belongs graphs vertex adjacent vertex figure b2a edge belong graph degree vertex undirected graph number edges incident vertex figure b2b degree vertex degree vertex figure b2b isolated directed graph outdegree vertex number edges leaving indegree vertex number edges entering degree vertex directed graph indegree outdegree vertex figure b2a indegree outdegree degree path length vertex vertex graph sequence v0 v1 v2 vk vertices v0 vk vi1 vi length path number ofedges path path vertices v0 v1 vk edges v0 v1 v1 v2 vk1 vk length path path reachable write directed path simple vertices path distinct figure b2a path simple path ngth path simple subpath path v0 v1 vk contiguous subsequence vertices subsequence vertices vi vi1 subpath directed graph path v0 v1 vk forms cycle v0 vk path edge cycle simple addition v1 v2 vk distinct selfloop cycle length paths v0 v1 v2 vk1 v0 form cycle exists integerfigure b2a path forms cycle paths cycle simple cycle cycle formed edge selfloop directed graph selfloops simple undirected graph path v0 v1 vk forms simple cycle v0 vk v1 v2 vk distinct figure b2b path cycle graph cycles acyclic undirected graph connected pair vertices connected path connected components graph equivalence asses vertices reachable relation graph figure b2b connected components vertexreachable vertexundirected graph connected connected component vertex reachable vertex directed graph connected vertices reachable connected components directed graph equivalence classes vertices mutually reachable relation directed graph connected connected component graph figure b2a connected components pairs vertices mutually reachable vertices form connected component vertex reached vertex graphs isomorphic exists bijection fv relabel vertices vertices maintaining edges figure b3a pair isomorphic graphs gwith respective vertex sets mapping f1 f3 f5 f6 required bijective function graphs figure b3b isomorphic graphs vertices edges graph vertex degree graph figure pair isomorphic graphs verti ces graph mapped vertices graph f4 f5 f6 graphs isomorphic graph vertex degree graph graph subgraph set subgraph induced graph subgraph induced vertex set figure b2a appears figure b2c edge set undirected graph directed version directed graph undirected edge replaced directed vers ion directed edges directed graph undirected version undirected graph undirected version edges directions removed selfloops eliminated edge undirected graph undirected version directed graph directed graph edges directed graph neighbor vertex vertex adjacent undirected version neighbor undirected graph neighbors adjacent kinds graphs special names complete graph undirected graph pair vertices adjacent bipartite graph undirected graph partitioned sets v1 v2 implies v1 v2 v2 v1 edges sets v1 v2 acyclic undirected graph forest connected acyclic undirected graph free tree b5we letters irected acyclic graph graph dag variants graphs occasionally encounter multigraph undirected graph multip edges vertices selfloops hypergraph undirected graph hyperedge connecting vertices connects arbitrary subset vertices algorithms written ordinary directed undirected graphs adapted graphlike structures contraction undirected graph edge graph vertex set edges formed deleting edge vertex incident deleting whichever adding edge exercises b41 attendees faculty party shake hands greet professor remembers times shook hands party department head adds number times professor shook ha nds result proving handshaking lemma undirected graph exercises b42 directed undirected graph path vertices simple path directed graph cycle simple cycle exercises b43 connected undirected graph satisfies exercises b44 verify undirected aph reachable rela tion equivalence relation vertices graph whic properties equivalence relation hold general reachable relati vertices directed graph exercises b45 undirected version directed graph figure b2a directed version undirected graph figure b2b exercises b46 hypergraph represented bipartite graph incidence hypergraph correspond adjacency bipartite graph hint set vertices bipartite graph correspond vertices hypergraph set vertices bipartite graph correspond hyperedges b5 trees graphs slig htly notions trees presents definitions mathematical properties kinds trees sections trees represented computer memory b51 free trees defined b4 free tree connected acyclic undirected graph omit adjective free graph tree undirect graph acyclic disconnected forest algorithms work trees work forests figure b4a free tree figure b4b forest forest figure b4b tree connected graph figure b4c tree forest cycle figure b4 free tree forest graph cycle tree forest theorem captures facts free trees theorem propert ies free trees undirected graph statements equivalent free tree vertices connected unique simple path connected edge removed graph disconnected connected acyclic acyclic edge graph cycle proof tree connected vertices connected simple path vertices connected distinct simple paths figure b5 vertex paths diverge vertex successor successor vertex paths reconverge vertex subpath subpath paths share vertices endpoints path concatenating reverse cycle contradicts assumption tree tree simple path vertices figure b5 step proof theorem free tree vertices connected unique simple path assu sake contradiction vertices connected distinct simple paths paths diverge vertex reconverge vertex path concatenated reverse path forms cycle yields contradiction vertices connected unique simple path connected edge edge path unique path remove path removal disconnects assumption graph connected exercise b43 prove induction connected graph vertices edges suppose vertices graphs satisfying fewer vertices satisfy removing arbitrary edge separates graph connected components component tisfies satisfy induction number edges components combined adding removed edge yieldssuppose connected acyclic suppose cycle vertices v1 v2 vk loss generality assume cycle simple gk vk ek subgraph consisting cycle note vk ek vertex vk1 vk adjacent vertex vi vk connected define gk1 vk1 ek1 subgraph vk1 vk vk1 ek1 ek vi vk1 note vk1 ek1 continue defining gk2 manner gn vn vn vn gn subgraph contradicts assumption acyclic suppose acyclic v1 number connected components connected component free definition implies sum edges connected components fact tree plies vertices connected unique simple path adding edge creates cycle suppose acyclic edge cycle created connected arbitrary vertices adjacent adding edge creates cycle edges belong path chosen arbitrarily connected b52 rooted ordered trees rooted tree free tree vertices distinguished distinguished vertex called root tree refer vertex rooted tree node4 tree figure b6a rooted tree set nodes root figure b6 rooted ordered trees rooted tree height tree drawn standard root node children nodes depth beneath children nodes depth beneath tree ordered relative lefttoright order children node matters doesnt rooted tree rooted tree identical tree ordered tree children node order node rooted tree root node unique path called ancestor ancestor descendant node ancestor descendant ancestor proper ancestor proper descendant subtree rooted tree induced descendants rooted subtree rooted node figure b6a nodes edge path root tree node parent child root node parent nodes parent siblings node children external node leaf nonleaf node internal node number children node rooted tree called degree x5 length path root node depth height node tree number edges longest simple downward path node leaf height tree height root height tree equal largest depth node tree ordered tree rooted tree children node ordered node children child child kth child trees figure b6 considered ordered trees considered rooted trees b53 binary positional trees binary trees defined recursively binary tree structure defined finite set nodes nodes composed disjoint sets nodes root node binary tree called left subtree binary tree called subtree binary tree nodes called tree null tree denoted nil left subtree nonempty root called left child root entire tree likewise root nonnull subtree child root entire tree subtree null tree nil child absent missing figure b7a binary tree figure b7 binary trees binary tree drawn standard left child node drawn beneath node left child drawn beneath binary tree left child node child absent left child node absent child ordered trees trees binary trees distinct binary tree represented internal nodes binary tree ordered tree internal node degree leaves tree squares binary tree simply ordered tree node degree binary tree node child position childwhether left child child matters ordered tree ere distinguishing sole child left figure b7b binary tree differs tree figure b7a position node considered ordered trees trees identical positioning binary tree represented internal nodes ordered tree figure b7c idea replace missing child binary tree node children leaf nodes drawn squares figure tree binary tree node leaf degree degree1 nodes orde children node preserves position positioning distinguishes nary trees ordered trees extended trees children node positional tree children node labeled distinct positive integers ith child node absent child labeled integer kary tree positional tree node children labels greater missing binary tree kary tree complete kary tree kary tree leaves depth internal nodes degree figure b8 complete binary tree height leaves complete kary tree height root children depth children depth number leaves depth kh height complete kary tree leaves log number internal nodes complete kary tree height equation a5 complete binary tree internal nodes figure b8 complete binary tree height leaves internal nodes exercises b51 draw free trees posed vertices draw rooted trees nodes root draw ordered trees nodes root draw binary trees nodes root exercises b52 directed acyclic graph vertex v0 exists unique path v0 vertex prove undirected version forms tree exercises b53 induction number degree2 odes nonempty binary tree number leaves exercises b54 induction nonempty binary tree nodes height lg exercises b55 internal path length binary tree sum internal nodes tree depth node likewise external path length sum leaves tree depth leaf binary tree internal nodes internal path length external path length prove exercises b56 associate weight wx leaf depth binary tree prove wx sum leaves kraft inequality exercises b57 binary tree leaves subtree l3 l3 leaves inclusive problems graph coloring undirected graph kcoloring function edge numbersrepresent colors adjacent vertices colors tree colorable equivalent bipartite colorable cycles odd length maximum degree vertex graph prove colored colors ov edges colored colors problems friendly graphs reword statements theorem undirected graphs prove assume friendship symmetric reflexive group people people number friends group group people mutual friends mutual strangers group people partitioned subgroups half friends person belong subgroup person member group friend half people group group seated table seated friends problems bisecting trees divide conquer algorithms operate graphs require graph bisected equalsized subgraphs induced partition vertices problem investigates bisections trees rmed removing small number edges require vertices subtree edges removed partition removing single edge partition vertices nvertex binary tree sets n4 n4 constant optimal worst case simple binary tree evenly balanced partition removal single edge n4 removing olg edges partition vertices nvertex binary tree sets term node graph eory literature synonym vertex reserve term node ean vertex rooted tree notice degree node depends considered rooted tree free tree degree vertex free tree undirected graph number adjacent vertices rooted tree degree number childrenthe parent node count degree chapter notes boole pioneered development symbolic logic introduced basic set notations book published modern set theory created cantor period cantor focused sets infinite cardinality term function attributed leibniz refe kinds mathematical formulas limited definition genera lized times graph theory originated euler proved impossible cross bridges city königsberg return starting point compendium definitions graph theory book harary appendix counting probability chapter reviews elementary combinator ics probability theory good background areas skim chapter lightly concentrate sections chapters require probability chapters essential reviews elementary counting theory including standard formulas counting permutations combinations axioms probability basic facts probability distributions presented random variables introduced properties expectation variance investigates geometric binomial distributions studying bernoulli trials study binomial dist ribution continued advanced discussion tails distribution counting counting theory answer question ithout enumerating nbit numbers orderings distinct elements review elements counting theory material sumes basic understanding sets reader advised start reviewing material rules sum product set items count expressed union disjoint sets cartesian product sets rule sum number ways choose element disjoint sets sum cardinalities sets finite sets members common equation position cars license plate letter digit number possibilities positionere choices letter choices digit rule product number ways choose ordered pair number ways choose element times numbe ways choose element finite sets simply equation b4 icecream parlor offers fla vors ice cream toppings number sundaes scoop ice cream toppingstrings string finite set sequence elements binary strings length string length kstring substring string ordered sequence consecutive elements ksubstring string substring length substring substring position substring kstring set viewed element cartesian product sk ktuples sk strings length number binary kstrings intuitively construct kstring nset ways pick element choices ways pick element times construction leads kfold product nk number kstrings permutations permutation finite set ordered sequence elements element appearing permutations abc acb bac bca cab cba permutations set elements element sequence chosen ways ways ways kpermutation ordered sequence elements element appearing sequence ordinary permutation npermutation nset permutations set cb db number kpermutations nset ways choosing element ways choosing element elements selected selection elements combinations kcombination nset simply ksubset combinations set shortha denoting set construct kcombination nset choosing distinct elements nset number kcombinations nset expressed terms number kpermutations nset kcombination permutations elements distinct kpermutation nset number kcombinations nset number kpermutations divided equation quantity formula tells number ways choose elements nset binomial coefficients notation read choose denote number kcombinations nset equation formula symmetric numbers binomial coefficients appearance binomial expansion special case binomial expansion occurs formula corresponds counting binary nstrings number binary nstrings ways choose positions place identities involving binomial coefficien exercises kend opportunity prove binomial bounds bound size binomial coefficient lower bound advantage inequality kek derived stirlings approximation upper bounds induction exercise c112 prove bound convenience assume bound rewritten binary entropy function convenience assume lg h0 h1 exercises c11 ksubstrings nstring cons ider identical ksubstrings positions substrings nstring total exercises c12 ninput moutput boolean function function true false true falsem ninput output boolean functions ninput moutput boolean functions exercises c13 ways professors sit circular conference table seatings rotated form exercises c14 ways choose setdistinct numbers sum exercises c15 prove identity exercises c16 prove identity exercises c17 choose objects objects distinguished distinguished object chosen approach prove exercises c18 result exercise c17 table binomial coefficients table binomial coefficients called pascals triangle exercises c19 prove exercises c110 maximum achieved exercises c111 arguec9 provide algebraic proof argument based method choosing items equality hold exercises c112 induction prove inequality equation extend exercises c113 stirlings approximation prove c10 exercises c114 differentiating entropy function achieves maximum h12 exercises c115 integer c11 probability probability essential tool design analysis probabilistic randomized algorithms review basic probability theory define probability terms sample space set elements called elementary events elementary event viewed outcome experiment experiment flipping stinguishable coins view sample space consisting set strings ht event subset1 sample space xperiment flipping coins event obtaining head tail ht event called event event ø called null event events mutually exclusive treat elementary event event definition elementary ents mutually exclusive axioms probability probability distribution sample space mapping events real numbers probability axioms satisfied pra event prs pra pra prb mutually exclusive events generally finite countably infinite sequence events pairwise mutually exclusive probability event note axiom normalization requirement fundamental choosing probability event natural convenient follow axioms basic set theory null event ø probability pra prb denote event complement pra events c12 c13 coinflipping suppose elementary events probability probability head prhh ht prhh prht prth alternatively probability strict ly head prtt probability headdiscrete probability distributions probability distribution discrete defined finite countably infinite sample space sample space event elementary events mutually exclusive finite elementary event probability prs uniform probability distribution case experiment picking element random process flipping fair coin probability obtaining head probability obtaining tail flip coin times uniform probability distribution defined sample space set size elementary event represented string length occurs probability event heads tails occur subset size strings length probability event continuous uniform probability distribution continuous uniform probability distribution probability distribution subsets sample space nsidered events continuous uniform probability distribution defined closed interval reals intuitively point interval equally uncountable number points points finite positive probability simultaneously satisfy axioms reason associate probability subsets axioms satisfied events closed interval continuous uniform probability distribution defines probability event note point probability remove endpoints interval open interval axiom prc generally set events continuous uniform probability distribution subset sample space finite countable union open closed intervals conditional probability independence prior partial knowledg outcome experiment suppose friend flipped fair coins told coins head probability coins heads eliminates possibility tails remaining elementary events equally infer occurs probability elementary events heads answer question conditional probability formalizes notion prior partial knowledge outcome experiment conditional probability event event occurs defined c14 prb read probability intuitively event occurs event occurs set outcomes occur outcome elementary events normalize prob abilities ementary events dividing prb sum conditional probability ratio probability event probability event event coins heads event leas coin head pra events independent c15 equivalent prb condition pra pra suppose fair coins flipped outcomes independent probability heads suppose event coin heads event coins differently events occurs proba bility probability events occur definition independence events independenteven events depend rst coin finally suppose coins welded fall heads fall tails possibilities equally probability coin heads probability heads event heads event heads independent collection events pairwise independent prai praipraj events collection mutually independent ksubset collection i1 ik satisfies suppose flip fair coins event coin heads event coin heads event coins pra1 pra2 pra3 pra1 pra1 pra2 pra1prai prai praj events pairwise independent events mutually independent pra1 pra2 pra3 bayess theorem definition conditional probability c14 commutative law events nonzero probability c16 solving pra c17 bayess theorem denominator normalizing constant reexpress mutually exclusive events prb prb prb prprb substituting equation c17 equivalent form bayess theorem bayess theorem simplify computing conditional probabilities suppose fair coin biased coin heads experiment consisting independent events coins chosen random coin flipped flipped suppose chosen coin heads times obability biased solve problem bayess theorem event biased coin chosen event coin heads times determine pra pra prb prb exercises c21 prove booles inequality finite countably infinite sequence events c18 exercises c22 professor rosencrantz flips fair coin ofessor guildenstern flips fair coin probability professor rose ncrantz obtains heads professor guildenstern exercises c23 deck cards bearing distinct number shuffled mix cards cards removed time deck wh probability cards selected sorted increasing order exercises c24 procedure takes input integers fair coin flips produces output heads probability tails probability bound expected number coin flips o1 hint represent binary exercises c25 prove pra exercises c26 prove collection events pra1 pra1 pra2 pra3 pran an1 exercises c27 construct set events pairwise indepe ndent subset mutually independent exercises c28 events conditionally independent pra pra prb simple nontrivial tw events independent conditionally independent event exercises c29 contestant game prize hidden curtains win prize select correct curtain picked curtain curtain lifted emcee lifts curtains knowing reveal stage asks switch current selection remaining curtain chances change switch exercises c210 prison warden randomly picked prisoner free executed guard free forbidden prisoner stat prisoners prisoner asks guard privately executedarguing nce die guard revealing formation status guard tells executed prisoner feels happier figures prisoner free probability free chances explain general probability distribution subsets sample space considered events situa tion arises sample space uncountably infinite main requirement set events sample space closed operations comple ment event forming union finite countable number events taki intersection finite countable number events probability stributions finite countable sample spaces generally subsets sample space events notable exception continuous uniform probability distribution presented shortly discrete random variables discrete random variable function finite countably infinite sample space real numbers associates eal number outcome experiment work probability distribution induced set numbers random variables defined uncountably infinite sample spaces raise technical issues unneces sary address purposes henceforth assume random variables discrete random variable real number define event function prx probability density function random variable probability axioms prx andx prx experiment rolling pair ordinary sideddice elementary events sample space assume probability distribution uniform elementary event equally define random variable maximum values showing dice prx assignselementary events common random variables defined sample space random variables function prx joint probability density function fixed fixed definition c14 conditional probability define random variables independent events independent equivalently prx prx pry set random variables defined sample space define random variables sums products functions original variables expected random variable simplest summary distribution random variable average values takes expected synonymously expectation discrete random variable c19 defined sum finite converges absolutely expectation denoted µx random variable apparent context simply µ game flip fair ins earn head lose tail expected random variable representing earnings pr2 pr1 pr2 expectation sum random variable sum expectations c20 defined property linearity expectation holds independent extends finite absolutely convergent summations expectations linearity expectation key property enables perform probabilistic analyses ing indicator random variables random variable function gx defines random variable gx expectation gx defined letting gx constant c21 expectations linear random variables constant c22 random variables independent defined expectation general random variables mutually independent c23 random variable takes values set natural numbersnice formula expectation c24 term times subtracted times times subtracted apply convex function fx random variable jensens inequality c25 provided expectations exist finite function fx convex fx1 fx1fy variance standard deviation expected random variable spread variables values random variables prx prx pry pryactual values farther actual values notion variance mathematically expresse random variables values variance random variable c26 justification equalities e2x exex e2x random variable simply real number equation c21 applies equation c26 rewritten xpression expectation square random variable c27 variance random variable variance exercise c310 var a2varx independent random variables varx var var general random variables pairwise independent c28 standard deviation random variable positive square root variance standard deviation random variable denoted simply random variable understood context notation variance denoted exercises c31 ordinary sided dice rolled expectation sum values showing expectation maximum values showing exercises c32 array distinct numbers randomly ordered permutation numbers equally expectation maximum element array xpectation minimum element array exercises c33 carnival game consists dice cage player bet dollar numbers cage shaken pa yoff players number doesnt dice loses dollar number appears dicedollar wins dollars expected gain playing carnival game exercises c34 argue nonnegative random variables max exercises c35 independent random variables prove fx independent choice functions exercises c36 nonnegative random variable suppose defined prove markovs inequality c29 exercises c37 sample space random variables prove real constant exercises c38 larger expectation square random riable square expectation exercises c39 random variable takes values var exercises c310 prove var a2var definition c26 variance geometric binomial distributions coin flip instance bernoulli trial defined experiment outcomes success occurs probability failure occurs probability speak bernoulli trials collectively trials mutually independent probability success distributi ons bernoulli trials geometric distribution binomial distribution geometric distribution suppose sequence bernoulli trials probability success probability failure trials occur success random variable number trials success values rangec30 failures success probability distribution satisfying equation c30 geometric distribution figure illustrates distribution figure geometric distri bution probability success probability failure expectation distribution assuming expectation geometric distribution calculated identity a8 c31 average takes trials success intuitive result variance calc ulated exercise a13 c32 suppose repeatedly roll dice outcomes yield yield probability success rolltimes average binomial distribution successes occur bernoulli trials su ccess occurs probability failure probability define random variable number successes trials values range c33 ways pick trials successes probability occurs pkqnk probability distribution satisfying equation c33 binomial distribution convenience define fam ily binomial distributions notation c34 figure illustrates binomial distribution binomial fact c33 kth term expansion qn figure binomial distribu tionbernoulli trials probability success xpectation distribution np c35 required axiom probability axioms compute expectation random variable binomial distribution equations c35 random variable llows binomial distribution definition expectation c36 linearity expectation result algebra random variable describing number successes ith trial exi linearity expectation equation c20 expected number successes trials c37 approach calculate variance distribution equation c26 takes values c38 compute variance advantage independence trials equation c28 c39 figure binomial distribution increases runs reaches np decreases prove distribution behaves manner ratio successive terms0 ratio greater precisely positive distribution increases distribution decreases integer distribution maxima np attains maximum unique integer lies range np lemma upper bound binomial distribution lemma proof equation exercises1 verify axiom probability ioms geometric distribution exercises2 times average flip fair coins heads tails exercises3 exercises4 maximu binomial distribution exercises5 probability successes bernoulli trials probability probability success exercises6 professor rosencrantz flips fair coin times professor guildenstern probability number heads hint professor rosencrantz head success profe ssor guildenstern tail success argument verify identity exercises7 hknn hx entropy function exercises8 bernoulli trials ith trial probability success random variable denoting total number successes prove exercises9 random variable total number successes set bernoulli trials ith trial probability success random variable total number successes set bernoulli trials ith trial probability success prove prx hint bernoulli trials experiment invo lving trials result exercise c37 tails binomial distribution probability successes bernoulli trials probability success probability successes investigate tails binomial distri bution regions distribution np prove bounds sum terms tail provide bound tail distribution bounds left tail determined inverting roles successes failures theorem sequence bernoulli trials success occurs probability random variable denoting total number successes probability successes proof denote event ith trial success inequality booles inequality c18 corollary restates theorem left tail binomial distribution general leave reader adapt proofs tail corollary sequence bernoulli trials success occurs probability random variable denoting total number successes probability successes bound concerns left tail binomial distribution rollary left tail diminishes exponentially theorem sequence bernoulli trials success occurs probability failure probability random variable noting total number successes np probability fewer successes proof bound series geometric series techniqueequation0 xbi iteratively applying inequality times xki corollary sequence bernoulli trials success occurs probability failure probability np2 probability fewer successes half probability fewer successes proof np2 letting random variable denoting number successes theorem implies probability fewer successes bounds tail determined proofs left exercise2 corollary sequence bernoulli trials success occurs probability random variable denoting total number successes np probability successes corollary sequence bernoulli trials success occurs probability failure probability np probability successes half probability successes theorem considers bernoulli trials probability success subsequent corollary theorem provide bound tail binomia distribution setting trial theorem sequence bernoulli trials ith trial success occurs probability failure occurs probability qi random variable describing total number successes µ µ proof function strictly increasing1 determined markovs inequality c292 bulk proof consists bounding eex µ substituting suitable inequality2 evaluate µ notation ith bernoulli trial success random variable ith bernoulli trial success failure linearity expectation implies evaluate µ substitute µ obtaining c23 mutual independe nce random variables implies mutual independence random variables exercise c35 definition expectation3 expx denotes exponential function expx inequality3 inequalities qi eqi inequality equation1 inequalities245 choosing lnrµ exercise7 applied bernoulli trials trial probability success theorem yields corollary bounding tail binomial distribution corollary c9 sequence bernoulli trials trial success occurs probability failure occurs probability np proof equation c36 µ np exercises1 obtaining heads flip fair coin times obtaining fewer heads flip coin times exercises2 prove corollaries exercises3 exercises4 prove npexercises5 conditions theorem imply conditions corollary c9 imply exercises6 sequence bernoulli trials ith trial success occurs probability failure occurs probability qi random variable describing total number successes µ hint prove follow outline proof theorem inequality place inequality3 exercises7 righthand inequality5 minimized choosing lnrµ problems balls bins problem investigate assumptions number ways placing balls distinct bins suppose balls distinct order bin matter argue number ways placing balls bins suppose balls distin balls bin ordered prove ways place balls bins hint number ways arranging distinct balls indistinguishable sticks row suppose balls identical order bin matter number ways placing balls bins hint arrangements repeated balls identical suppose balls identical bin ball number placing balls suppose balls identical bin left number ways placing balls chapter notes general methods solving probability problems discussed famous correspondence pascal fermat began book huygens rigorous probability theory began work bernoulli moivre developments theory provided laplace poisson gauss sums random variables originally studied chebyshev markov probability theory axiomatized kolmogorov bounds tails distributions provided chernoff hoeffding seminal work random combinatorial structures erdös knuth liu good references elementary combinatorics counting standard textbooks billingsley chung drake feller rozanov offer comprehensive introductions probability