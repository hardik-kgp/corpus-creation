o1 algorithms o1 algorithms algorithms question theoretically completely mathematical definition big notation easily substitute obvious definition holds purpose estimating asymptotic time growth viable meaningful algorithm faster input grows construct arbitrary algorithm fulfill function spends time input size grows limit enforced hardware precision numbers minimum time wait time process arguments limit constant lower bound fact function runtime fact real algorithms runtime decrease partially input size increases note algorithms exhibit runtime behaviour interesting simple text search algorithm horspool expected runtime decrease length search pattern increases increasing length haystack increase runtime precisely algorithm runtime algorithm algorithm executes asymptotically steps algorithm consisting single instruction executes steps step n0 consist precisely instruction checking n0 costs instruction consist instruction summing algorithm algorithm consisting instruction definition big greater inequality fact maximum decreases increases estimation change sharptooth correct performance imply fast solution fixed time solution interesting variant suggested problems easier population grows albeit contrived tongue cheek answer people set birthday exceeds return true great answer problem slowly easierprevious learning big notation step checking variable assignment noteconstant matter n step program step minimum algorithm minimum choose zen tao question realm programming minimum programmer boss time boss bankrupt morning programmer infinity eventually achieve inf effectively big class problem massive closer constant time low thing faster constant time arguable execute command big class running function noop fixed count probabilities smaller inputs larger probability fair coin tails log2 flipssimply constant time add early exit loop big notation turning algorithm making faster trick general constant time algorithm linear exponential small amounts exponential algorith faster assuming static list length quantum algorithms multiple computations superposition doubt answer reading question understand conversation people correct answer prove order function function return answer takes constant time rest processing time larger inputs printing answer assume single bit takes constant time solution exists prepared accessed constant time instance lifo data structure sorting query reverse order data sorted model lifo chosen problems easier population grows answer thing bittorrent download speed inverse function number nodes contrary car slows load file sharing network bittorrent speeds nodes connected called sublinear time algorithms problems sublinear time algorithm approximate solutions problem approximate solutions fine dataset large computationally expensive compute size list grows expected runtime program decreasesbasically data faster algorithm arrayelements bad big notation negative values pointed exception null function functions time approach algorithms defined konrad sense investigate algorithms define asymptotic measurement notion time algorithm number free operations set times algorithm define excluding time sleepexamples asymptotic behavior trivial fact senses trivial rest answers interpret big exclusively running time algorithm question mention thought worth mentioning application big numerical analysis error algorithms depending talking step size number divisions euler method estimate derivative estimate accurate closer order arbitrary takes interval splits pieces runs euler method point x euler method algorithm typically interpreted step size interpreted number times divide interval real numerical analysis applications floating point rounding errors smaller interval cancellation occurs implementation algorithms loss digits error propagated algorithm euler method floating points small step cancellation adding small number big number leaving big number unchanged algorithms calculate derivative subtracting numbers function evaluated close positions approximating smooth functions close large cancellation estimate derivative fewer figures turn propagate algorithm require derivative boundary problem bit thinking exists algorithm follow general form compute traveling salesman problem node graph list nodes visit list unvisitable nodes grows larger problem easier solve algorithm admittedly upper bound large series inputs changing external routine reflect hardware core processor select random valid changing simply list items pick randomly time dynamic nature data precludes making list simply probe randomly test validity probe note inherently guarantee answer valid returned ai unit game shoot target dropped sight pulling trigger worst case performance infinity average case performance data space fills numerical analysis approximation algorithms constant asymptotic complexity approximation tolerance guess time algo termedfunction variants presented solution guess flaws major explain concept sake argument increases function time ensured input function forever return argue bounded precision machine sinc eit upper bound bypass inputs string addition comparison string idea reduce arbitrarily small upper limit function bounded ignore time construct algorithm loop iterates multiple times function guaranteed greater limit approaches infinity calculation constant hand application algorithm opinion function exist algorithm purpose prove possibility algorithm algorithms complexities randomized algorithmskind complexity appears randomized algorithms probability event order denote high probabilitydenoteanswer input data algorithm answer input data submitted function optimised big notation represents worst case scenario algorithm thing typical time simple prove algorithm algorithm definition big notation ignores constants matter smaller big notation implies largest order complexity algorithm algorithm runtime lower powers dont matter inf irrelevant compared likewise inf irrelevant compared making smallest computational complexity simple algorithm interesting describes output function increasing size input function number instructions function executes requirement function instructions input size input size threshold number instructions required bounded positive constant multiplied actual number constant positive reason function constrained fewer instructions