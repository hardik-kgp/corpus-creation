count number set bits bit integer count number set bits bit integer bits representing number bits set algorithms determine number set bits bit integer hamming weight popcount sideways addition algorithm depends cpu usage pattern cpus single built instruction parallel instructions bit vectors parallel instructions x86 cpus supported fastest architectures slow instruction implemented microcoded loop tests bit cycle citation needed pre populated table lookup method fast cpu large cache lots instructions tight loop suffer expense cache cpu fetch table main memory bytes efficient algorithms scenarios good general purpose algorithm parallel variable precision swar algorithm expressed pseudo language adjust work language uint32_t worst case behaviour algorithms discussed efficiently deal usage pattern values throw bitwise swar algorithm parallelize multiple vector elements single integer register speedup cpus simd usable popcount instruction x86 code cpu nehalem vector instructions popcount variable shuffle table lookup bits time byte parallel bits entry table held vector register intel cpus hardware bit popcnt instruction outperform ssse3 bit parallel implementation factor compiler sse ahead newer compiler versions aware popcnt false dependency problem intel references graphics stanford seander bithacks html wikipedia org wiki hamming_weight gurmeet net puzzles fast bit counting routines aggregate engr uky magic population count count built functions compilers gnu compiler worst case compiler generate function case compiler emit cpu instruction job faster gcc intrinsics work multiple platforms popcount mainstream x86 architecture sense start intrinsic architectures popcount years x86 compiler assume support instruction enable vector instructions generation gcc x86 options cpu code assume tune good choice running binary older cpu result illegal instruction fault binaries optimized machine build gcc clang icc msvc intrinsic x86 instruction gcc intrinsic hardware instruction requires hardware support built theory compiler popcount efficiently target cpu expose functionality iso practice bit hack shift add cases target cpus target architectures hardware popcount optional extension x86 compilers takes advantage msvc enable support compile time table lookup implies sse4 technically separate feature bit portable works gcc clang target options hardware popcount architectures support asm gcc clang icc msvc godbolt compiler explorer x86 emits powerpc64 emits arg version source x86 specific gnu specific compiles x86 gcc clang icc note gcc fallback architectures single instruction popcount byte time table lookup wonderful arm opinion solution read programmer original programmer years copious comments fastest cleverest solution provided prefer readability cleverness time speed assuming document successors table lookup rely specific data type sizes portable performance optimisations portable issue portability stick readable solution hacker delight figure executes ish instructions arch dependent branching hacker delight delightful highly recommended fastest lookup tables popcount counts set bits operations works count total number set bits dividing halves counting number set bits halves adding paradigm number bits bits work bits required column count set bits bit pair bit number produces produces statement easy understand operation count set bits bits sum count bits sum result total count set bits bits statement tricky break statement counting set bits groups previous operations nibble count set bits suppose byte nibble bits set bits set add nibbles count set bits byte nibble mask bytes bytes number discarding byte count set bits add trick multiply result interesting property number bytes result number bytes byte number maximum bits set represented byte sum set bits bytes algorithm designed easily modified bored timed billion iterations approaches compiler gcc o3 cpu st gen macbook pro fastest seconds place code bytes halfwords seconds place bit twiddling sideways addition approach seconds fourth place gcc __builtin_popcount shameful seconds counting bit time approach waaaay slower bored waiting complete care performance approach care spend kb ram approach readable slow bit time approach hard situation bit twiddling approach edit happen built method explain algorithm algorithm based divide conquer algorithm suppose bit integer binary algorithm works time merge neighbor blocks questions helps micro architecture timed variants gcc compiled o3 inlines eliminate function overhead billion iterations keeping running sum counts ensure compiler remove rdtsc timing clock cycle precise inline int pop2 unsigned unsigned return unmodified hacker delight gigacycles parallel version counting bits runs gigacycles s total elapsed ghz core duo gigacycles seconds clock frequency confident timings instruction dependency chains bad algorithm double speed pair bit registers fact clever sooner shave shifts bit version small tweaks count bits bit simd registers factor sse instruction sets clever short cuts reason code transparent interface simple algorithm referenced places amenable comprehensive unit test programmer stumbles learn bit operations extremely natural machine level decided bench tweaked bit version sizeof unsigned long inline int pop2 unsigned long unsigned long return xff testing carefully timings gigacycles gigacycles number summed billion bits corresponds s elapsed machine parallel version speeds tiny bit running bit mode likes bit registers bit registers bit ooo pipelining bit involved tested bit term sums combined sum inline int pop4 unsigned long unsigned long unsigned long unsigned long enum return excited moment turns gcc playing inline tricks o3 inline keyword tests gcc play tricks billion calls pop4 takes gigacycles determined folding arguments constant expressions realistic number appears gc speed test loop making argument gcc playing tricks hitime b4 rdtsc unsigned long ll sum pop4 hitime rdtsc billion bits summed s elapsed works s bits benchmarked bit table lookup compare directly bench clock speed slapped snot kb table edition tragic l1 cache place update decided obvious create pop6 adding duplicated lines gc billion bits summed s elapsed ms billion bits iteratively divide count count agree fastest ambiguous argue element clarity hacker delight bit twiddling clearer write bit patterns step adds bits odd bits producing sum bits steps add high order chunks low order chunks doubling chunk size final count entire int happy medium lookup table iterating bit individually ctips pbwiki countbits number bits set fastest solution question started finally realized problem mathematical draw graph function periodic realize difference periods function called sideways sum population count binary number knuth discusses pre fascicle a pp11 reference volume locus classicus peter wegner article technique counting binary computer communications acm volume number algorithms optimized numbers expected sparse small number opposite case open questions number negative number iteratively divide method iterate times modify algo support negative number overcome problem write algo complete reference goursaha freeoda miscellaneous integerbitcount html brian kernighan method iterations set bits bit word high bit set loop published programming language nd brian kernighan dennis ritchie mentions exercise april knuth pointed method published peter wegner cacm discovered independently derrick lehmer published book edited beckenbach code intuitive logic resets set bit solution albeit interesting solution algorithm shorted code fasted code code elegant constant execution time code short speed major factor code size follow faster faster bit bit faster wrote fast bitcount macro risc machines advanced arithmetic multiplication division memory fetches slow branches slow assume cpu bit barrel shifter cycles assumes small constants cost load registers stored temporaries reused assumptions counts bits cycles instructions risc machines note instructions cycles close lower bound number cycles instructions instructions mask shift operator cut number addends half log_2 instructions quasi lowerbound secret complex step st column shift bit subtract output extension bits check row boolean table gillies option template metaprogramming usage expand template types auto detecting bit size simple clarity edit forgot mention good work compiler basically unrolls loop constant bit count pretty fastest general method fond fortune file define bitcount bx_ bx_ define bx_ x77777777 x33333333 x11111111 pretty jdk1 integer bitcount number counted check implementation bit counting array simd instruction ssse3 avx2 times performance __popcnt64 intrinsic function ssse3 version avx2 version competitive programming easy write efficient algorithm count set bits faster detailed bit twiddling hacks counting bits set bit bit instructions method requires bit cpu fast modulus division efficient option takes operations option takes option takes fast solution pre calculated table byte bit counts branching input size portable module ansi benchmark algorithms architecture cpu bit bytes problem moment implements algorithms algorithm byte wise lookup table lookup table average times faster algorithm figure hacker delight algorithm portable feel free add bit method reading cracking coding interview th edition exercice chap bit manipulation bit increment shift integer intuitive solutions constant x33333333 matter fast depends definition algorithm