implement classic sorting algorithms modern implement classic sorting algorithms modern algorithm cousins standard library implementations complicated hybrid amalgamation elementary sorting algorithms selection sort insertion sort quick sort merge sort heap sort questions sister sites codereview stackexchange bugs complexity aspects implementations classic sorting algorithms offered implementations consist raw loops manipulation concrete types generally trivial analyse terms correctness efficiency question mentioned classic sorting algorithms implemented modern raw loops combining standard library algorithmic building blocks iterator interface templates manipulation concrete types style including standard library syntactic noise reducers template aliases transparent comparators polymorphic lambdas references implementations sorting algorithms wikipedia rosetta code sorting algorithms sean parent conventions slide raw loop loop longer composition functions operator raw loops loops follow scott meyers terminology denote current y denote flame suggested comments mehrdad provide implementations live answer boost answer presented terms relevant denote syntactic library differences language versions differ algorithmic building blocks assembling algorithmic building blocks standard library iterator tools member write substitutes boost range boost utility algorithm implemented terms hand written function object boost algorithm substitute algorithm syntactical goodies transparent comparators form polymorphically arguments avoids provide iterator type combination default function template arguments create single overload sorting algorithms comparison user defined comparison function object define reusable template alias extract iterator type adds minor clutter sort algorithms signatures write overloads verbose syntax syntactical nicety facilitates wrapping user defined comparators polymorphic lambdas parameters deduced function template arguments monomorphic lambdas require template alias write standalone function object verbose type syntax boost bind improves placeholder syntax function object style generally acceptable style worse closely follow scott meyers draft effective modern herb sutter revamped gotw style recommendations herb sutter auto scott meyers prefer auto specific type declarations recommendation brevity unsurpassed clarity disputed scott meyers distinguish creating objects consistently choose braced initialization good parenthesized initialization order step vexing parse issues generic code scott meyers prefer alias declarations typedefs templates saves time adds consistency pattern places order loop invariant checking sorted ranges production code inside loop selection sort selection sort adapt data runtime selection sort property minimizing number swaps applications cost swapping items high selection sort algorithm choice implement standard library repeatedly remaining minimum element swap place note processed range sorted loop invariant minimal requirements forward iterators compared random access iterators details selection sort optimized early test forward bidirectional iterators bidirectional iterators test combined loop interval element guaranteed minimal remaining element require swap insertion sort elementary sorting algorithms worst case time insertion sort algorithm choice data sorted adaptive problem size small low overhead reasons stable insertion sort recursive base case problem size small higher overhead divide conquer sorting algorithms merge sort quick sort implement standard library repeatedly location current element shift remaining elements upward input range note processed range sorted loop invariant insertion sort works forward iterators details insertion sort optimized early test forward bidirectional iterators loop interval element guaranteed place require rotate bidirectional iterators binary search insertion point replaced reverse linear search standard library algorithm live examples boost fragment random inputs comparisons improves comparisons sorted inputs binary search comparisons small input ranges memory locality cache prefetching linear search dominate binary search test quick sort carefully implemented quick sort robust expected complexity worst case complexity triggered adversarially chosen input data stable sort needed quick sort excellent general purpose sort simplest versions quick sort bit complicated implement standard library classic sorting algorithms approach iterator utilities locate middle element input range pivot calls partition input range segments elements smaller equal larger selected pivot finally outer segments elements smaller larger pivot recursively sorted quick sort tricky correct efficient steps carefully checked optimized production level code complexity pivot result balanced partition input data guaranteed general pivot guaranteed sets pivot median input range details implementation vulnerable special inputs complexity organ pipe input middle larger elements median pivot selection randomly chosen elements input range guards sorted inputs complexity deteriorate partitioning separating elements smaller equal larger pivot calls efficient algorithm achieve result random access iterators guaranteed complexity achieved median pivot selection recursive calls guarantee cost constant factor complexity expensive complexity median pivot cache friendly single forward pass data merge sort extra space concern merge sort excellent choice stable sorting algorithm simple implement standard algorithms iterator utilities locate middle input range combine recursively sorted segments merge sort requires bidirectional iterators bottleneck note sorting linked lists merge sort requires extra space recursion algorithm implemented standard library heap sort heap sort simple implement performs place sort stable loop heapify phase puts array heap order loop sortdown phase repeatedly extracts maximum restores heap order standard library extremely straightforward case cheating level deeper write functions terms standard library specifies complexity note outer loop range complexity complexity complexity matter details implementation testing live examples boost testing algorithms variety inputs meant exhaustive rigorous note huge differences loc loc boost small elegant originally code review thought worth sharing counting sort specialized counting sort simple integer sorting algorithm fast provided values integers sort ideal sort collection integers implement simple counting sort works signed unsigned integers smallest greatest elements collection sort difference size array counts allocate pass collection count number occurrences element finally write required number integer original collection range integers sort small generally larger size collection sort making counting sort generic slower cases range small algorithm radix sort ska_sort spreadsort details passed bounds range values accepted algorithm parameters totally rid pass collection algorithm faster small range limit exact passing constant extra pass elements true bounds worth extra elements written read growing fly avoid separate pass doubling size time grow amortized time sorted element hash table insertion cost analysis proof exponential grown key growing easy add zeroed elements changing fly inserting zeroed elements growing vector elements increment loop histogram data highly repetitive number bins small worth unrolling multiple arrays reduce serializing data dependency bottleneck store reload bin counts start loop worth cpus millions numbers input partially sorted long runs number algorithm check return early element case collection sorted fully check collection sorted finding extreme values collection additional time wasted pass memory bottlenecked extra work updating min max algorithm exist standard library writing tedious writing rest counting sort left exercise reader algorithm works integer values static assertions prevent users making obvious type mistakes contexts substitution failure preferred modern cool future cooler structured bindings parts ranges algorithm cleaner