plain english explanation big notation https stackoverflow questions  plain english explanation big notation  prefer formal definition simple mathematics quick note confusing big notation upper bound theta notation θ bound experience typical discussions academic settings apologies confusion caused big complexity visualized graph simplest definition big notation big notation relative representation complexity algorithm deliberately chosen sentence relative compare apples apples compare algorithm arithmetic multiplication algorithm sorts list integers comparison algorithms arithmetic operations multiplication addition meaningful representation big simplest form reduces comparison algorithms single variable variable chosen based observations assumptions sorting algorithms typically compared based comparison operations comparing nodes determine relative ordering assumes comparison expensive comparison cheap swapping expensive comparison complexity takes sort   elements long sort complexity instance relative measure reread read rest big arithmetic numbers   basic arithmetic operations learnt school addition subtraction multiplication division operation problem method solving called algorithm addition simplest numbers add digits column writing number addition result tens number carried column assume addition numbers expensive operation algorithm stands reason add numbers add  digits carry th add  digit numbers  additions add   digit numbers   additions pattern complexity number operations directly proportional number digits larger number linear complexity subtraction borrow carry multiplication numbers digit number multiply turn digit number digit multiply  digit numbers  multiplications   column adds result  digit numbers   multiplications  adds digit numbers trillion   multiplications adds algorithm scales squared  quadratic complexity good time introduce concept care portion complexity astute realized express number operations  n numbers digits apiece term n insignificant accounting   total operations stage notice assumed worst case scenario multiplying  digit numbers  digits  digits  multiplications calculate worst case scenario  digit numbers big notation worst case scenario algorithm telephone book telephone book called white varies country country talking lists people surname initials address telephone numbers instructing computer phone number john smith telephone book    names ignoring fact guess started assume typical implementation open middle   compare smith smith john real lucky john smith divide half phone book half repeat divide half phone book half repeat called binary search day programming realize phone book names  times comparing search algorithms decide comparison phone book  names takes  comparisons  takes   takes     takes  staggeringly good big terms log logarithmic complexity logarithm question base log  log  base matter log n  n   worthwhile point explain big determine cases algorithm case telephone book search case comparison  constant complexity expected case discussed log worst case log care case interested expected worst case telephone book phone number police reverse phone book denied general public technically reverse number ordinary phone book start compare number match great phone book unordered phone number phone number reverse lookup case  expected case   worst case    traveling salesman famous problem computer science deserves mention problem towns towns linked  towns road distance traveling salesman problem shortest tour visits town sounds simple  towns roads pairs equivalent equivalent roads reverse actuality  possibilities  towns iirc  possibilities     function mathematical operation called factorial basically                                                big traveling salesman problem factorial combinatorial complexity time  towns time left universe solve problem traditional computers polynomial time point wanted quick mention algorithm complexity polynomial complexity solvable polynomial time  polynomial time problems solved polynomial time things public key cryptography prime computationally hard prime factors large number public key systems plain english explanation big revised algorithm scales based input size  quadratic complexity  item   items  seconds  items  seconds notice number items increases factor  time increases factor   basically   scaling factor    linear complexity  item   items  seconds  items  seconds time number items increases factor  time  scaling factor   constant complexity  item   items   items  number items increasing factor  scaling factor   log logarithmic complexity  item   items  seconds  items  seconds  items  seconds  items  seconds number computations increased log input case assuming computation takes  log input time required gist reduce maths  dominating factor scaling big notation called asymptotic growth notation functions ignore constant factors stuff origin talk thing scale basics large inputs grows faster grows grows slower big notation care constant factors function grow big asymptotic notation care asymptotic stuff stuff origin problem size small function grow ignore smaller parts equation completely dwarfed big parts equation larger larger scales contribution dwarfed irrelevant ratio infinity divide actual time takes constant factor limit large inputs intuitively sense functions scale multiply large problem sizes ignore stuff origin exists constant   completely choices constant choice constant factor algorithm ignore ignore largest terms constant factors matter equation bound worst case scenario time takes worse roughly factor   constant factor care general care worst case behavior represents bad processor memory usage worst case scenario processor memory usage applications purely mathematical construct big notation limited talking processing time memory discuss asymptotics scaling meaningful number handshakes people party matters scales probabilistic expected number people viral marketing function time website latency scales number processing units cpu gpu computer cluster heat output scales cpu dies function transistor count voltage time algorithm function input size space algorithm function input size handshake room shakes hand bit number handshakes choose  people shakes hands  people double counts handshakes divide  large numbers people linear term dwarfed effectively contributes  ratio chart fraction boxes diagonal total boxes smaller number participants larger scaling behavior number handshakes grows n² boxes diagonal chart   checkmarks  checkmarks asymptotically temporary digression plain english wanted prove perform simple algebra ratio split multiple terms considered limit ignore notation big number handshakes x² large values write ratio handshakes x² fact x² handshakes arbitrarily large million ratio handshakes x²   building intuition statements large inputsize matter constant factor double input size double time linear time algorithm takes n  double squared quadruple time n² quadratic time algorithm takes problem x big takes ² x long unsustainable n² n ²  n² double cubed octuple time n³ cubic time algorithm takes problem x big takes ³ x long unsustainable cn³ n ³  cn³ add fixed time log logarithmic time algorithm takes cheap log log n log  log fixed log change time  constant time algorithm takes cheapest   basically double time log algorithm takes fairly common   basically linear ridiculously increase time  exponential time algorithm takes double triple time increasing problem single unit   n          mathematically inclined mouse spoilers minor sidenotes credit https stackoverflow   technically constant factor matter esoteric examples phrased things log bread butter orders growth programmers applied computer scientists reference points time technically doubling input algorithm   times slower worse logarithmic linear constant factors care specific constant factors affect function grows algorithms time complete slow care factor large optimizing tricky business optimisation premature mere picking algorithm big improve performance orders magnitude asymptotically superior algorithms comparison sort large constant factor overhead large hidden rarely worth big data datastructures algorithms sense algorithms read data reading bunch data operation loading memory faster hardware support time read data touch piece data piece data algorithm time perform matter long actual algorithm takes spent time data writing algorithms print things time output long printing permutations ways rearrange set playing cards factorial motivates data structures data structure requires reading data time arbitrary preprocessing small modifying data structure insertions deletions making queries data time proceed large number queries general work ahead time work latitude longitude coordinates millions road segments wanted street intersections naive method coordinates street intersection wanted examine nearby streets millions segments time check adjacency needed problem naive method work times case times segment work ²  operations good modern computer perform billion operations simple structure called hash table instant speed lookup table hashmap dictionary pay small cost preprocessing time takes constant time average key case key latitude longitude coordinates rounded grid search adjacent gridspaces  constant task infeasible manageable pay minor cost hash table analogy analogy case jigsaw puzzle created data structure exploits property data road segments puzzle pieces group matching color pattern exploit avoid extra work comparing puzzle pieces color single puzzle piece moral story data structure speed operations advanced data structures combine delay ignore operations incredibly clever ways problems analogies involve organizing data exploits structure care artificially imposed bookkeeping work ahead time basically planning organizing repeated tasks easier practical visualizing orders growth coding asymptotic notation core separate programming asymptotic notation mathematical framework thinking things scale fields apply asymptotic notation coding basics interact element collection size array set keys map perform iterations loop multiplicative factor size multiplicative factor loops functions definition multiplicative running time number iterations times work loop functions number times function times work function holds fancy skip loops exit loop early change control flow function based arguments common examples visualization techniques accompanying pseudocode represent constant time units work processor instructions interpreter opcodes   complicated imagine visually smallest recognizable outline draw matters triangle dimensional shape    square dimensional shape  constant factor remains asymptotic ratio ignore factors unfortunate nuances technique mislead loops functions bad contrary building blocks modern programming languages love weave loops functions conditionals data control flow mimics time space usage program time space usage issue cleverness easy algorithm data structure considered reduce order growth visualization techniques work naive guess worst case running time thing recognize visually rearrange log passes data log total time unrelatedly worth mentioning perform hash dictionary hashtable lookup factor  pretty fast complicated recursive function divide conquer algorithm master theorem works ridiculous cases akra bazzi theorem works running time algorithm wikipedia programmers eventually algorithm intuition nature start code inefficient grossly inefficient answer foresee mattering step tricks things faster answer hashtable rarely tree rarely bit complicated amortized average case complexity concept amortized average case note average case big notation expected function function usual case inputs equally average case average running time quicksort worst case bad inputs average case usual bad inputs small number notice average case amortized worst case data structures worst case complexity large guarantee operations average work worst case data structure takes constant time occasionally hiccup time random operation bookkeeping garbage collection promises hiccup hiccup operations worst case cost operation amortized cost runs operation big operations rare massive occasional work considered blend rest work constant factor work amortized large number calls disappears asymptotically analogy amortized analysis drive car occasionally spend  minutes gas station spend  minute refilling tank gas time car spend  minutes driving gas station spend seconds filling fraction gallon inefficient tank days  minutes spent driving gas station amortized large number trips ignore pretend trips  longer comparison average case amortized worst case average case assumptions inputs inputs probabilities outputs runtimes probabilities average assume inputs equally uniform probability real inputs fit assumptions average input average output runtime calculations meaningless anticipate uniformly random inputs amortized worst case amortized worst case data structure performance guaranteed amortized worst case eventually inputs chosen evil demon screw analyze algorithms choppy performance unexpected large hiccups time perform algorithms data structure upper limits outstanding work procrastinate evil attacker force catch maximum procrastinated work worried attacker algorithmic attack vectors worry amortization average case average case amortization incredibly tools thinking designing scaling mind difference average case amortized analysis interested subtopic multidimensional big time people realize variable work string search algorithm algorithm time linear variables naive algorithms ignoring multiple variables common oversights algorithm analysis handicap designing algorithm story mind big story drastically speed algorithms caching making cache oblivious avoiding bottlenecks working ram disk parallelization work ahead time techniques independent order growth big notation number cores big notation parallel algorithms mind hidden constraints program care asymptotic behavior working bounded number values sorting  elements speedy quicksort insertion sort perform small inputs situations divide conquer algorithms split problem smaller smaller subproblems recursive sorting fast fourier transforms matrix multiplication values effectively bounded hidden fact average human softly bounded  letters human age softly bounded  impose bounds input effectively terms constant practice algorithms asymptotic performance relative merit driven things performance factors quicksort mergesort quicksort takes advantage cpu caches performance considerations ease implementation library reputable maintained library programs slower mhz computer ghz computer resource bounds scaling terms machine resources clock cycle real things secretly affect performance running emulation compiler optimized code basic operations longer relative speed slow operations asymptotically relative small large implementation environment switch languages machines eke extra work depends reasons necessity skills coworkers programmer productivity monetary time familiarity workarounds assembly gpu performance issues choice programming language considered constant factor aware rarely affect things cpython native priority queue implementation asymptotically optimal choice insertion min implementation implementation faster issues tradeoffs matter edit plain english explanation ends math addenda completeness precise definition big notation asymptotically upper bounded const ignoring finite exists constant symbols lowercase variants upper lower bounded exists constants lie band strongest asymptotic statement roughly equivalent elected delay mention absolute symbols clarity sake negative values computer science context people correct comp sci notation legitimate read order xxx bounded thought expression asymptotics taught rigorous element read case elements infinitely large set ω symmetric n² n² ɵ symmetric relations transitive reflexive ɵ symmetric transitive reflexive partitions set functions equivalence classes equivalence class set things function canonical unique asymptotic representative class generally limit group integers odds evens group functions ɵ ish log  ish basically ignoring smaller terms stuck complicated functions separate classes notation common papers renowned computer scientists additionally case casual setting people technically true set things subset easier type edit quick note confusing big notation upper bound theta notation upper lower bound experience typical discussions academic settings apologies confusion caused sentence size job longer complete size input time output idea applies talk memory usage shirts dry assume incredibly quick drying position human interaction negligible case real life washing assuming infinitely large yard washing dries  time sun fresh air size affect drying time tumble dryer  shirts load hour ignore actual numbers irrelevant drying  shirts takes  times long drying  shirts putting airing cupboard big pile general warmth long time middle shirts dry guess suspect  increase wash load drying time increases faster aspect big notation algorithm faster size hashtable string key integer array pairs string integer faster key hashtable element array based string array element string matches key hashtables generally amortised average  set time entry  entry table    entry table finding element array based content linear average half entries hashtable faster array lookups small collection entries array faster check strings time takes calculate hashcode data set grows larger hashtable eventually beat array big describes upper limit growth behaviour function runtime program inputs large examples double input size runtime doubles  input size doubles runtime quadruples log input size doubles runtime increases  input size increases runtime doubles input size space bits needed represent input big notation commonly programmers approximate measure long computation algorithm complete expressed function size input set big compare algorithms scale number inputs increased precisely big notation express asymptotic behavior function function behaves approaches infinity cases algorithm fall cases  time complete size input set accessing array element log time complete increases roughly log2  items takes roughly long  items log2   log2   finding item binary search tree bst time complete scales linearly size input set double number items input set algorithm takes roughly long counting number items linked list log time complete increases number items times result log2 heap sort quick sort  time complete roughly equal square number items bubble sort time complete factorial input set traveling salesman problem brute force solution big ignores factors contribute meaningful growth curve function input size increases infinity constants multiplied function simply big express common time space code  nlogn ways algorithm change big elements imaging search item array element correct element item worst case item time items list generic hey fair values understand  specific play thought simple simpliest sorting algorithms bubblesort algorithm list item list    flow compare   biggest  position moving forward compare    list changed start begining  items list items item items comparing item times meaning  hope simple remember big experss manner time space big describes fundamental scaling nature algorithm lot big algorithm cuts bone scaling nature algorithm resource time memory algorithm scales response input size difference steam engine rocket varieties thing prius engine lamborghini engine dramatically kinds propulsion systems core steam engine faster toy rocket steam piston engine achieve speeds orbital launch vehicle systems scaling characteristics relation fuel required resource usage reach speed input size software deals problems differ size factors trillion moment ratio speed travel moon human walking speed    absolutely tiny compared range input sizes software face software face astronomical range input sizes potential big complexity algorithm fundamental scaling nature trump implementation details canonical sorting bubble sort  merge sort log sorting applications application bubble sort application merge sort input sizes  elements application  x faster application sorting sort  elements obvious prefer application faster input sizes sort items expect application ends thousands times faster application case algorithm scales plain english bestiary tend explaining common varieties big cases prefer algorithms higher list lower list cost moving expensive complexity class varies  growth big problem solve time analogous broadcasting takes energy broadcast distance number people lie broadcast range log complexity  bit worse practical purposes large constant scaling difference work processing   billion items factor cost solving problem proportional size problem problem doubles size cost solution doubles problems scanned computer data entry disk reads network traffic generally affordable scaling factor log complexity practical purposes equivalent level complexity generally considered scalable tweaking assumptions log algorithms transformed algorithms bounding size keys reduces sorting log  grows square length square growth rate network network network growth expensive scalable solutions algorithms level complexity gymnastics generally applies polynomial complexities  scale hope solving trivially sized problem knowing avoid experts approximate algorithms big measure time space algorithm relative size input algorithm time space increase rate input algorithm  time space increase rate input squared difficult measure speed software programs answers complex filled exceptions special cases big problem exceptions special cases distracting unhelpful compare programs fastest result unhelpful complexity people speed software programs smallest complex mathematical expressions expressions crude approximations bit luck capture essence piece software fast slow approximations letter big expression convention signal reader making gross oversimplification mistakenly thinks expression accurate read meaning order wrong choice big attempt humour thing big expressions software slows increase data software process double data processed software long finish work times long practice limited number big expressions encounter worry good constant program takes time matter big input logarithmic program time increases slowly big increases size input bad linear program time increases proportionally size input polynomial processing time grows faster faster polynomial function size input increases ugly exponential program time increases moderate increases size problem practical process small data sets exponential algorithms factorial program time longer afford wait smallest trivial datasets plain english explanation big formal definition simple mathematics plain english explanation big notation program solve problem code called algorithm big notation compare worse case performance algorithms standardized hardware specs vary time improvements hardware reduce time takes algorithms replacing hardware algorithm improved time algorithm order compare algorithms determine big notation plain english explanation big notation algorithms time vary based number items input based worse case analysis upper bound time larger larger aware big notations reference simple straightforward answer big represents worst time space algorithm algorithm space time limit big represents time space complexity extreme case cents big rate increase resource consumed program problem instance size resource total cpu time maximum ram space default refers cpu time problem sum problem instance    problem instance size  iterations loop  problem instance      problem instance size  iterations loop  input size program growing speed iterations array big expressed problem combination problem instance    problem instance size  total iterations    problem instance      problem instance size  total iterations    input size program growing speed iterations array big  expressed  big notation describing upper bound algorithm terms space running time number elements problem size array number nodes tree interested describing running time big algorithm running time space required algorithm lower constant times binary search running time logn exists constant multiply log larger running time binary search case constant factor log comparisons running time algorithm constants plain english explanation big formal definition simple mathematics beautifully simple short question deserve equally short answer student receive tutoring big notation simply tells time algorithm terms input data wonderful unit free sense time matters people live today tomorrow wonderful big notation practically speaking big analysis big puts focus squarely algorithm complexity completely ignores proportionality constant engine speed cpu internet connection things laughably outdated model big focuses performance matters equally people living future big notation shines spotlight directly principle computer programming engineering fact inspires good programmers thinking dreaming achieve slow forward march technology invent algorithm algorithm algorithm description algorithm search list item item key iterating item list key return true loop finished finding key return false big notation represent upper bound complexity time space big time complexity calculate time input size worst case takes worst case key exist list time worst case n  time n  big constants neglected linear big omega represent complexity case case key item time case  time ω   instant constant big function bounded neighborhood numbers plain english neighborhood decomposes product bounded function small comparison definition small function  examples sin  sin      attention notation equal sign fake equality true false write formula sense examples   equality fake        wikipedia article https wikipedia org wiki big_o_notation big notation describing algorithm arbitrary number input parameters computer science machines operate speeds simply algorithm takes  seconds running   ghz octo core processor running  year  mhz longer algorithm fast algorithm runs terms time fast runs terms number input parameters describing algorithms compare speeds algorithms account speed computer contributing subject thought share blog post helpful basic explanations examples big examples helped bare basics tortoiseshell skull pretty descent  minute read headed direction big talk big beat sound word small quick sound small talk work time work work case work spend time work play fun things feel times work sad true work rule work work play big news big work play time big work play big helps work list add things list wow hate work lost hard head care kind work work hard work add numbers add add add count adds adds solve big hard math big adds solve add thing small bits work bit work add work add hard adds work sheesh kind stuff add add add hard hard work steps guess adds thing work add add hard add hope play add work add work big friend big helps work plan friends big choose work hard work work thing work add things wait add told work whew work guess hard knew add things big hard work add things add things add times  big tells hard type work big big slow boss man thinks work work quick work slow hard work work tells time care lots big work likes work love big tells fast work helps hard work uh work work plan step step deck cards mixed straight job sort ergh sounds lot work sort deck plan pair cards pair pair deck card pair big card pair small swap pair deck deck swap cards pass point time swaps sort deck work work sort cards rules cards time lots luck deck times card swaps time deck big big deck cards sort squared time squared squared times cards checked times deck loops steps squared work lot work big squared work squared adds nose small bit case worst case squared steps work sort deck big friend big points big sort cards job hard add things job real big care add squared big squared large big tells sort things hard add things squared big real big sort mixed deck things time add mixed things big solve work big tells hard work deck cards sort helped fast sort cards big fast takes time learn works works fast time step lose place sort deck check pairs cards ago rules sort deck choose card deck work choose time deck work deck splay deck card chose splay splay start card card high splay card card card low splay card cards swap cards swap step splay card chose point loop ends halves search meet splay card splayed deck card chose step cards start low splay card cards high splay card cool trick fun small decks low splay card high step small deck start step small deck work start step small deck break deck parts sort small small time work slow rules trust slow work sort things sort called called quick sort sort man called hoare called quick sort quick sort time quick sort breaks big decks small breaks big tasks small hmmm rule big tasks small break sort quick quick big tells sort log work case fast sort big sort squared quick sort log log squared big quick sort fast sort deck choose quick sort choose quick sort work work quick sort work log squared small quick sort work friend big helps work big work learned smart work play  cheat add things time kid named gauss smart simpler understand time complexity common metric calculating time complexity big notation removes constant factors running time estimated relation approaches infinity general constant running time statement change relation linear running time loop directly proportional doubles running time quadratic running time loops proportional square doubles running time increases logarithmic running time algorithm proportional number times divided  algorithm divides working area half iteration log running time consists loops iterative recursive logarithmic algorithm combination linear logarithmic general item dimension linear item dimensions quadratic dividing working area half logarithmic big measures cubic exponential square root common big notation measure quicksort algorithm log note account average worst case measures big notation note simplistic explanation big common complex notations big omega big theta encounter algorithm analysis order harry potter complete  film collection blu ray amazon download film collection online time test method faster delivery takes day arrive download completed  minutes earlier great tight race order blu ray movies lord rings twilight dark knight trilogy download movies online time time delivery day complete online download takes  days finish online shopping number purchased item input affect delivery time output constant  online downloading download time directly proportional movie file sizes input experiments online shopping scales online downloading understand big notation helps analyze scalability efficiency algorithms note big notation represents worst case scenario algorithm assume  worst case scenarios reference carlcheo compsci assume talking algorithm dataset size simple english unlucky executing operations complete functions implementations tend occur easily compared examples comparing talking algorithms easy rank algorithms number operations worst case require complete general goal structure algorithm function returns low number suitable notion infinity head description big notation tells cost solving infinitely large problem constant factors negligible upgrade computer algorithm fast big notation notice constant factor improvements small noticed scale big notation works note intentional design big notation larger constant factor detected interested computations size large considered infinity big notation cost solving problem sense compatible intuitive notion infinity head disregard ideas rigorous explain intuitively teach big notation understand big notation future worthwhile revisit ideas plain english explanation big notation quick note big refers order precisely order idea literally order compare big things estimates steps method computer applies accomplish task facilitate process compare order determine good big achieves standardized notations  computer task step excellent ordered  logn computer complete task steps good ordered  finish task steps fair order  nlogn ends task steps good order   task steps bad order   task steps horrible order  task steps terrible order  suppose notation clear method takes steps accomplish task good ranking note order understanding  notations possibilities considered set steps accomplish task called algorithms terminology big notation performance complexity algorithm addition big establishes worst case measure upper bound steps refer big ω big omega case big ω big omega notation article khan academy summary big describes algorithm performance evaluates address formally big classifies algorithms standardize comparison process simplest plain english number input parameters running time algorithm running time application proportional number input parameters big statement good start completely true accurate explanation mathematical suppose number input parameters actual function expresses running time algorithm function constant approximate function expresses running time algorithm function big concerned approximation considered good long condition true equation read approaches infinity equal times big notation written read big english based mathematical definition algorithm big function number input parameters faster algorithm big automatically big square big algorithm runs fast big notation algorithm slow fast check video tutorial big uc berkley simple concept hear professor shewchuck aka god level teacher explaining great explanation big notation mathematics https rob bell net   beginners guide big notation big notation computer science performance complexity algorithm big describes worst case scenario execution time required space memory disk algorithm read programming pearls computer science books grounding mathematics hit wall reached chapters mention log seemingly crazy syntax article gain understanding basics big logarithms programmer mathematician fourth understand big produce examples code common orders growth descriptions examples   describes algorithm execute time space size input data set describes algorithm performance grow linearly direct proportion size input data set demonstrates big favours worst case performance scenario matching string iteration loop function return early big notation assume upper limit algorithm perform maximum number iterations   represents algorithm performance directly proportional square size input data set common algorithms involve nested iterations data set deeper nested iterations result     denotes algorithm growth doubles additon input data set growth curve  function exponential starting shallow rising meteorically  function recursive calculation fibonacci numbers logarithms logarithms trickier explain common binary search technique search sorted data sets works selecting middle element data set essentially median compares target values match return success target higher probe element upper half data set perform operation likewise target lower probe element perform operation lower half continue halve data set iteration longer split data set type algorithm log iterative halving data sets binary search produces growth curve peaks slowly flattens size data sets increase input data set  items takes complete data set  items takes seconds data set  items seconds doubling size input data set growth single iteration algorithm data set halved input data set half size algorithms binary search extremely efficient dealing large data sets simplified explanation hope covers details algorithm dealing problem depends factors depending algorithm require operations worst case operations big care constant factor aka  big algorithm basically translates operations algorithm worst case scales preface algorithm procedure formula solving problem analyze algorithms compare algorithms friend asked create function sum numbers  friend functions result algorithm order objectively compare efficiency algorithms big notation big notation describes runtime grow relative input input arbitrarily large  key takeaways compare runtime grows compare exact runtimes depends hardware concerned runtime grow relative input arbitrarily large focus terms grow fastest large infinity aka asymptotic analysis space complexity time complexity care space complexity memory space algorithm checking time operations check size allocation memory