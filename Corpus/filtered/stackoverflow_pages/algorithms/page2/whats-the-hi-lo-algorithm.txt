algorithm questions algorithm algorithm nhibernate documentation method generate unique keys good explanation works nhibernate handles inside curious basic idea numbers primary key high number low number client basically increment high sequence knowing safely generate keys entire range previous high variety low values instance supposing high sequence current low number range client increment sequence clients generate keys keys orms set primary keys client inserting values primary keys fetching client easily parent child relationships keys place inserts batching simpler addition jon answer work disconnected client server number create objects increasing number contact server range algorithms splits sequences domain groups assigned synchronously group maximum number entries assigned worrying concurrent duplicate entries token assigned database concurrent calls guaranteed unique consecutive values token retrieved incrementsize number entries identifiers range formula range applied start values fetched cycle continues detailed explanation article visual presentation easy follow optimizer fine optimizing identifier generation play systems inserting rows database knowing identifier strategy hibernate offers pooled optimizer combines generator strategy interoperability sequence allocation mechanism optimizer efficient interoperable systems candidate previous legacy identifier strategy cached allocator splits keyspace large chunks typically based machine word size meaningfully sized ranges obtaining keys time human sensibly choose usage waste large numbers keys server restart generate large human unfriendly key values allocator linear chunk allocator table based principle allocates small conveniently sized chunks generates nice human friendly values allocate keys held range server needed providing commit transaction retries handle contention allocated keys dispense needed chunk size scheme x faster allocating oracle sequence portable databases allocation performance equivalent ambler idea treats keyspace contiguous linear numberline avoids impetus composite keys good idea avoids wasting entire server restarts generates friendly human scale key values ambler idea comparison allocates high bits generates large human unfriendly key values increment comparison allocated keys design wise solution fundamentally complex number composite keys large hi_word products linear_chunk achieving comparative benefit design arose early mapping persistence days persistence frameworks hibernate offer simpler allocators default algorithm perfect multiple databases replication scenarios based experience imagine server york alias server angeles alias person table york person create secuential por jason david theo angeles rupert oswald mario database replication matter brand primary keys data combine easily naturally worry duplicate primary keys collissions scenario