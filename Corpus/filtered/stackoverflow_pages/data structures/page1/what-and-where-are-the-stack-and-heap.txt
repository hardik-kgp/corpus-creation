stack heap https stackoverflow questions  stack heap  programming language books explain types created stack reference types created heap explaining things read clear explanation understand stack physically real computer memory extent controlled language time scope determines size faster stack memory set scratch space thread execution function called block reserved stack local variables bookkeeping data function returns block unused time function called stack reserved lifo order reserved block block freed simple track stack freeing block stack adjusting pointer heap memory set dynamic allocation stack enforced pattern allocation deallocation blocks heap allocate block time free time complex track parts heap allocated free time custom heap allocators tune heap performance usage patterns thread stack typically heap application uncommon multiple heaps types allocation answer questions directly extent controlled language runtime allocates stack level thread thread created typically called language runtime allocate heap application scope stack attached thread thread exits stack reclaimed heap typically allocated application startup runtime reclaimed application technically process exits determines size size stack set thread created size heap set application startup grow space needed allocator requests memory operating faster stack faster access pattern trivial allocate deallocate memory pointer integer simply incremented decremented heap complex bookkeeping involved allocation deallocation byte stack reused frequently mapped processor cache making fast performance hit heap heap global resource typically multi threading safe allocation deallocation typically synchronized heap accesses program clear demonstration image source vikashazrati wordpress stack stored computer ram heap variables created stack scope automatically deallocated faster allocate comparison variables heap implemented actual stack data structure stores local data return addresses parameter passing stack overflow stack infinite deep recursion large allocations data created stack pointers stack data allocate compile time big maximum size determined program starts heap stored computer ram stack variables heap destroyed manually fall scope data freed slower allocate comparison variables stack demand allocate block data program fragmentation lot allocations deallocations data created heap pointed pointers allocated allocation failures big buffer requested allocated heap data time allocate lot data responsible memory leaks point heap stack generic terms ways memory allocated implemented ways terms apply basic concepts stack items items sit order remove toppling thing simplicity stack maintain table record allocated memory state single pointer stack allocate allocate increment decrement single pointer note stack implemented start memory extend growing upwards heap order items reach remove items order clear item heap allocation requires maintaining record memory allocated overhead maintenance reduce fragmentation contiguous memory segments big fit requested size memory deallocated time leaving free space memory allocator perform maintenance tasks defragmenting memory moving allocated memory garbage collecting identifying runtime memory longer scope deallocating images fairly good job describing ways allocating freeing memory stack heap yum extent controlled language runtime mentioned heap stack general terms implemented ways computer programs typically stack called stack stores relevant current function pointer whichever function called local variables functions functions return stack grows shrinks hold functions stack program runtime control determined programming language architecture heap general term memory allocated dynamically randomly order memory typically allocated application calling api functions allocation fair bit overhead required managing dynamically allocated memory handled scope stack low level concept relate scope sense programming disassemble code relative pointer style references portions stack higher level language concerned language imposes rules scope aspect stack function returns local function freed stack works expect work programming languages work heap difficult define scope exposed programming language adds rules scope application processor architecture virtual addressing processor translates physical addresses faults track belong applications worry method programming language allocate free memory check errors allocation freeing fails reason determines size depends language compiler operating architecture stack pre allocated definition contiguous memory paragraph language compiler determine size store huge chunks data stack big fully cases unwanted endless recursion stack overflow unusual programming decisions heap general term dynamically allocated depending constantly changing size modern processors operating systems exact works abstracted worry works deep languages memory allocated memory freed faster stack faster free memory contiguous list maintained segments free memory single pointer current stack compilers store pointer special fast register purpose subsequent operations stack concentrated nearby areas memory low level good optimization processor die caches moved answer question dupe answer question implementation specific vary compilers processor architectures simplified explanation stack heap memory areas allocated underlying operating virtual memory mapped physical memory demand multi threaded environment thread completely independent stack share heap concurrent access controlled heap stack heap heap linked list free blocks allocations heap satisfied creating suitable block free blocks requires updating list blocks heap meta blocks heap stored heap small area block heap grows blocks allocated lower addresses higher addresses heap heap memory blocks grows size memory allocated heap small allocation size increased acquiring memory underlying operating allocating deallocating small blocks leave heap state lot small free blocks interspersed blocks request allocate large block fail free blocks large satisfy allocation request combined size free blocks large called heap fragmentation block adjacent free block deallocated free block merged adjacent free block create larger free block effectively reducing fragmentation heap stack stack works close tandem special register cpu named stack pointer initially stack pointer points stack highest address stack cpu special instructions pushing values stack popping stack push stores current location stack pointer decreases stack pointer pop retrieves pointed stack pointer increases stack pointer confused fact adding stack decreases stack pointer removing increases remember stack grows values stored retrieved values cpu registers function called cpu special instructions push current instruction pointer address code executing stack cpu jumps function setting instruction pointer address function called function returns instruction pointer popped stack execution resumes code function function entered stack pointer decreased allocate space stack local automatic variables function local  bit variable bytes set stack function returns stack pointer moved free allocated area function parameters pushed stack function code function navigate stack current stack pointer locate values nesting function calls work charm allocate function parameters return address space local variables activation records stacked nested calls unwind correct functions return stack limited block memory stack overflow calling nested functions allocating space local variables memory area stack set writing lowest address stack trigger trap exception cpu exceptional condition caught runtime converted kind stack overflow exception function allocated heap stack activation records functions local automatic variables allocated stack store variables track nested function calls heap managed runtime environment languages garbage collection stack low level feature closely tied processor architecture growing heap space hard implemented library handles heap growing stack impossible stack overflow discovered late shutting thread execution viable option code memory managed long function invocation stack heap variables lifetime expect languages critical compile time large variable store stack objects vary size update heap creation time long languages heap garbage collected objects cls1 object longer references objects directly heap languages structs classes remain stack dealing pointers difference stack heap memory allocation timmurphy org creating objects stack heap article source picture net concepts stack heap types reference types boxing unboxing codeproject aware inaccuracies stack function arguments function overhead stack info return stored declare variable inside function variable allocated stack deallocating stack pretty simple deallocate reverse order allocate stack stuff enter functions data removed exit tend stay small region stack lots functions lots functions create recursive solution heap heap generic data create fly spaceships program create malloc equivalent operator create spaceship allocation stick free things order created heap complex regions memory unused interleaved chunks memory fragmented finding free memory size difficult problem heap avoided implementation implementation stack heap runtime games applications performance critical create memory solutions grab large chunk memory heap dish internally avoid relying memory practical memory usage norm games load level huge operation chuck lot huge operation physical location memory relevant technology called virtual memory program access address physical data hard disc addresses stack increasing order tree deeper addresses heap predictable implimentation specific frankly clarify answer incorrect thomas fixed answer comments cool answers avoid explaining static allocation explain main forms allocation relate heap stack data segment examples python people understand static aka statically allocated variables allocated stack assume people static sounds lot stack exist stack heap called data segment generally scope lifetime stack heap scope refers parts code access variable generally local scope accessed current function versus global scope accessed scope complex lifetime refers variable allocated deallocated program execution static allocation variable persist entire duration program making storing function calls versus automatic allocation variable persists single function making storing function discarded versus dynamic allocation variables duration defined runtime compile time static automatic compilers interpreters implement behavior terms stacks heaps compiler break conventions long behavior correct instance optimization local variable exist register removed local variables exist stack pointed comments free implement compiler stack heap storage mechanisms rarely stacks heaps great provide simple annotated code illustrate learn program debugger watch behavior prefer read python skip answer poignant distinguish lifetime scope variable local scope static lifetime instance somelocalstaticvariable code sample variables common informal naming habits confusing instance local locally scoped automatically allocated variable global globally scoped statically allocated variable things file scoped statically allocated variables people huh syntax choices exacerbate problem instance people global variables static syntax note putting keyword static declaration prevents var2 global scope global var1 static allocation intuitive reason word static describing scope file file limited scope people phrase static static scope variable accessed code file context lifetime static variable allocated program start deallocated program exits people concepts specific instance python sample illustrates types allocation subtle differences interpreted languages answered broad strokes pretty throw details stack heap singular common situation stack thread process case thread stack heap dll configurations result dlls allocating heaps generally bad idea release memory allocated library benefit variable length allocation alloca allocates stack opposed alloc allocates heap memory survive return statement scratch buffer making huge temporary buffer windows free compiler generate stack probe loop called time function entered stack exists windows single guard stack detect grow stack access memory stack crash directly answered question understand stack heap helpful memory layout traditional unix process threads based allocators memory management glossary web diagram memory layout stack heap traditionally located opposite ends process virtual address space stack grows automatically accessed size set kernel adjusted heap grows memory allocator invokes mapping physical memory process virtual address space systems virtual memory embedded systems basic layout applies stack heap fixed size embedded systems based microchip pic microcontrollers program stack separate block memory addressable data movement instructions modified read indirectly program flow instructions return architectures intel itanium processors multiple stacks sense stack element cpu architecture stack portion memory manipulated key assembly language instructions pop remove return stack push push stack subroutine pushes address return stack return return subroutine pops address stack jumps region memory stack pointer register set needed stack passing arguments subroutines preserving values registers calling subroutines heap portion memory application operating typically syscall malloc modern oses memory set calling process access size stack determined runtime generally grow program launches program stack large hold variable declared function heap grow dynamically needed ultimately making grow heap requested malloc future mallocs kernel memory behavior customizable allocated stack launching program malloc stack slight advantage practice hard predict fast slow modern operating systems virtual memory subsystems implemented stored implementation people correct answers matter missed heap fact called free store reason distinction original free store implemented data structure binomial heap reason allocating early implementations malloc free allocation heap modern day free stores implemented elaborate data structures binomial heaps stack stack pile objects typically neatly arranged stacks computing architectures regions memory data removed manner multi threaded application thread stack heap heap untidy collection things piled haphazardly computing architectures heap area dynamically allocated memory managed automatically operating memory manager library memory heap allocated deallocated resized regularly program execution lead problem called fragmentation fragmentation occurs memory objects allocated small spaces small hold additional memory objects net result percentage heap space usable memory allocations multi threaded application thread stack threads share heap threads share heap multi threaded application coordination threads access manipulate piece memory heap time faster stack heap stack faster heap memory allocated stack allocating memory stack simple moving stack pointer people programming good idea stack easier stack small memory data size data small heap lot memory data memory dynamic array memory model stack area memory local variables including method parameters stored object variables references pointers actual objects heap time object instantiated chunk heap memory set hold data state object objects objects data fact hold references nested objects interesting things stack instance functions alloca assuming copious warnings form malloc stack heap memory stack based memory errors worst experienced heap memory overstep bounds allocated block decent chance triggering segment fault  block incidentally contiguous allocated variables created stack contiguous writing bounds change variable learned feel program stopped obeying laws logic buffer overflow simply stack local variables created time subroutine program counter pointer machine instruction registers parameters pushed stack local variables inside subroutine pushed stack subroutine finishes stuff popped stack register data popped program merry heap area memory dynamic memory allocations explicit allocate calls special data structure track blocks memory varying sizes allocation status classic systems ram laid stack pointer started memory heap pointer started grew overlap ram work modern multi threaded oses thread stack created dynamicly wikianwser stack function method calls function turns calls function execution functions remains suspended function returns chain suspended function calls stack elements stack function calls depend stack exception handling thread executions heap heap simply memory programs store variables element heap variables dependencies accessed randomly time stack fast access explicitly allocate variables space managed efficiently cpu memory fragmented local variables limit stack size dependent variables resized heap variables accessed globally limit memory size slower access guaranteed efficient space memory fragmented time blocks memory allocated freed manage memory charge allocating freeing variables variables resized realloc short stack static memory allocation heap dynamic memory allocation stored computer ram stack stack lifo data structure managed optimized cpu closely time function declares variable pushed stack time function exits variables pushed stack function freed deleted stack variable freed region memory stack variables advantage stack store variables memory managed allocate memory hand free cpu organizes stack memory efficiently reading writing stack variables fast heap heap region computer memory managed automatically tightly managed cpu free floating region memory larger allocate memory heap malloc calloc built functions allocated memory heap responsible free deallocate memory fail program memory leak memory heap set processes debugging tool called valgrind detect memory leaks stack heap size restrictions variable size obvious physical limitations computer heap memory slower read written pointers access memory heap talk pointers shortly stack variables created heap accessible function program heap variables essentially global scope variables allocated stack stored directly memory access memory fast allocation dealt program compiled function method calls function turns calls function execution functions remains suspended function returns stack reserved lifo order reserved block block freed simple track stack freeing block stack adjusting pointer variables allocated heap memory allocated time accessing memory bit slower heap size limited size virtual memory elements heap dependencies accessed randomly time allocate block time free time complex track parts heap allocated free time stack data allocate compile time big heap data runtime allocate lot data multi threaded situation thread completely independent stack share heap stack thread specific heap application specific stack exception handling thread executions thread stack typically heap application uncommon multiple heaps types allocation time application heap allocate memory free memory stack memory allocate memory free memory allocated memory application question answers extent controlled language runtime allocates stack level thread thread created typically called language runtime allocate heap application scope stack data allocate compile time big heap data runtime allocate lot data determines size size stack set thread created size heap set application startup grow space needed allocator requests memory operating faster stack allocation faster stack pointer memory pools comparable performance heap allocation slight complexity headaches stack heap performance consideration tells lot expected lifetime objects details simply short ordered ordered stack stack items things gon faster efficient processed point specific item processing gon faster relationship items heap order processing gon slower values messed specific order random relationship execution usage time vary create image s unix propagated bunnies big companies rolling exxon dozens brand names lost history memory laid discretion implementors typical program laid flat memory opportunity increase changing brk typically heap brk increasing brk increased heap single stack typically area heap tract memory fixed block memory block code overwritten stack data famous hacks era typical memory block bss block values accidentally zeroed manufacturer offering data initialized values including strings numbers code crt runtime main functions libraries advent virtual memory unix constraints objective reason blocks contiguous fixed size ordered unix multics suffer constraints schematic showing memory layouts era stack heap data process virtual memory couple cents good draw memory graphical simple arrows grow stack heap process stack size limit defined thread stack size limits parameters thread create api heap limiting process maximum virtual memory size  bit   gb simple process heap general process threads inside memory allocation common case malloc stack quick memory store common case function return pointers variables processed parameters function local function variables answers nitpicking contribute mite surprisingly mentioned multiple number running level threads stacks exotic languages postscript platforms intel itanium fibers green threads implementations coroutines fibers green threads coroutines ways leads confusion difference fibers green threads cooperative multitasking feature cooperative preemptive distinction fibers coroutines case purpose fibers green threads coroutines multiple functions executing concurrently parallel question distinction single level thread transferring control organized fashion fibers green threads coroutines separate stack function technically stack context execution function importantly cpu registers thread stacks concurrently running functions thread switching executing function logic program function runs stack destroyed number lifetimes stacks dynamic determined number level threads note separate stack function stackful stackless implementations couroutines notable stackful implementations boost coroutine microsoft ppl resumable functions proposed  stackless coroutines fibers proposal standard library forthcoming party libraries green threads extremely popular languages python ruby share major points covered stack fast access stored ram function calls loaded local variables function parameters passed space freed automatically program scope stored sequential memory heap slow access comparatively stack stored ram dynamically created variables stored requires freeing allocated memory stored memory allocation accessed pointer interesting note function calls stored heap  messy points sequential storage stack execution faster storage heap huge time consumption making program execute slower functions stored heap messy storage pointed pointer return caller address stack sequential storage memory wow answers  physically real computer memory stack memory highest memory address allocated program image decrease reserved called function parameters temporary variables functions heaps public private private heap  byte boundary  bit programs  byte boundary  bit programs byte code program increases called default heap private heap large overlap stack area stack overlap heap big stack starts higher address works lower address proper hacking stack large overrun private heap area overlap code area trick overlap code area hook code tricky risk program crash easy effective public heap resides memory space program image space memory siphoned hard disk memory resources scarce  extent controlled language runtime stack controlled programmer private heap managed public heap controlled service requests granted denied b scope global program contents private public global c determines size size stack private heap determined compiler runtime options public heap initialized runtime size parameter d faster designed fast designed programmer utilizes determines fast slow https norasandler    write compiler  html https docs microsoft windows desktop api heapapi nf heapapi getprocessheap https docs microsoft windows desktop api heapapi nf heapapi heapcreate lot answers correct concepts note stack needed hardware microprocessor calling subroutines assembly language oop guys methods stack save return addresses push ret pop managed directly hardware stack pass parameters slower registers microprocessor guru good s bios book stack microprocessor work imagine program assembly language subroutines functions heap assembly language program work heap concept malloc lib stack usage faster hardware push pop efficient malloc requires entering kernel mode lock semaphore synchronization primitives executing code manage structures needed track allocation