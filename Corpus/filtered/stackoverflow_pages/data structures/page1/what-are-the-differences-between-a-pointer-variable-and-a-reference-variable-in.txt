differences pointer variable reference variable questions differences pointer variable reference variable references syntactic sugar code easier read write differences summary answers links pointer assigned number times reference assigned binding pointers point reference refers object address reference pointers reference arithmetic address object pointed reference pointer arithmetic clarify misconception standard careful avoid dictating compiler implement references compiler implements references pointers declaration optimized allocates storage pointer places address storage pointer reference memory general rule references function parameters return types provide documenting interfaces pointers implementing algorithms data structures interesting read time favorite faq lite references pointers introduction references references const pointer assigned reference assigned initialization pointer memory address size stack bytes x86 reference shares memory address original variable takes space stack reference address original variable safe reference variable note pointer points stack heap ditto reference claim statement pointer point stack pointer variable holds memory address variable stack reference space stack address variable references stack heap implies real address reference compiler pointers pointers pointers offering extra levels indirection references offer level indirection pointer assigned directly reference hard address reference likewise hard reference pointer reference pointers iterate array item pointer pointing th element matter size object pointer points pointer dereferenced access memory location points reference directly pointer class struct access members reference pointer variable holds memory address reference implemented reference memory address item references references stuffed array pointers mentioned user litb const references bound temporaries pointers indirection safer argument lists reference programmers reference thought constant pointer confused pointer constant automatic indirection compiler apply operator references initialized null compilation fail address reference address operator return address referenced arithmetics references programmers dislike references longer obvious indirection argument passed pointer function signatures programmers dislike pointers considered unsafe references safer constant pointers trivial cases lack convenience automatic indirection carry semantic connotation statement faq reference implemented address underlying assembly language reference funny pointer object reference object pointer object copy object object reference object dangling references unmanaged languages impossible references safer pointers generally reliably alias values scope boundaries references coming background references silly concept pointers automatic indirection convenient references dealing raii perceived safety advantage writing idiomatic code awkward raii central concepts interacts trivially copying semantics passing objects reference avoids issues copying involved references language pointers cumbersome violating language design principle practice solution easier alternatives pedantic thing reference pointer extend lifetime temporary object bind const reference temporary object lifetime object lifetime reference s3_copy copies temporary object result concatenation s3_reference essence temporary object reference temporary object lifetime reference fail compile bind const reference temporary object address matter contrary popular opinion reference null granted harder reference manage tear hair references inherently safe technically invalid reference null reference support null references concept languages kinds invalid references invalid reference raises spectre undefined behavior invalid pointer actual error dereferencing null pointer prior assignment reference aware compilers generate errors condition error propagates point code problem insidious time dereference null pointer crash spot debugging figure short contrived real reiterate null reference malformed code undefined behavior sense check null reference compiler optimize statement existence valid reference null compiler view comparison false free eliminate clause dead code essence undefined behavior proper stay trouble avoid dereferencing null pointer create reference automated accomplish older problem writing skills null references jim hyslop herb sutter dangers dereferencing null pointer exposing undefined behavior port code platform raymond chen syntactic sugar reference pointer pointer establish refers declare reference variable change update difference const pointer target replaced address const cast reference target replaced short ub permit compiler optimization reference forgot member access pointers member access references superior vi superior emacs references pointers crafted helpful optimizing compilers references designed easier compiler trace reference aliases variables major features reference arithmetic reassigning references compiler figure references alias variables compile time references allowed refer variables memory addresses compiler chooses registers address local variable hard compiler register optimizing compiler realize accessing bunch love optimize algorithm optimization prove change array easy array refer array maybemodify a0 reference aliasing array reference arithmetic compiler prove maybemodify address proven array prove ways future read write temporary register copy a0 trivial prove cases obvious reference stored permanent structure class instance thing pointers behavior harder prove maybemodify modify array pointer cat bag difficult proof static analysis maybemodify prove writes prove saves pointer refer array tricky modern compilers static analysis nice references barring clever optimizations compilers turn references pointers needed edit years posting answer actual technical difference references addressing concept references modify lifespan temporary objects pointers temporary objects created destroyed expression binding object reference extend lifespan temporary object scope reference pointer compiler references variables associating memory address job translate variable memory address compiling create reference compiler assign pointer variable references point null variable pointers variables address variable null thing pointer reference variable referencing explanation real code creating variable points adding memory content holding memory names addressed calling function compiler generates memory spaces arguments copied function signature defines spaces created spaces declaring parameter reference tells compiler input variable memory space allocating memory space method strange function directly manipulating variable declared calling scope remember executing compiled code scope plain flat memory function code manipulate variables cases compiler reference compiling extern variable reference implemented pointer underlying code examples implemented pointer reference references pointers indirectly access differences references pointers reference refers object error define reference initializing behavior assignment difference assigning reference object reference bound rebind reference object initialized reference refers underlying object program fragments assign pointer assignment ival object addressed remains unchanged assignment making point object program assigns references assignment ival referenced reference assignment references refer original objects objects semantic difference esoteric familiar studying computer languages abstract academic fashion highest level idea references transparent aliases computer address work supposed worry supposed existing object syntax reflects stricter pointers compiler reliably warn create dangling reference create dangling pointer practical differences pointers references syntax seat references references nothingness pointers references reference alias variable pointer holds memory address variable references generally function parameters passed object copy object matter space takes executing code space hand major difference references pointers temporaries assigned const references live const reference scope print language mechanism scopeguard work based tutorial written clear simply remember refer pointer tutorial pointer object supported pointer arithmetic pointer array statement understood forget terminology statement create reference reference memory immutable pointer automatically referenced usage basically boils internally reference pointer reverse pointer reference reference pointer cleaner syntax modify pointer version program pointer pointer multiple indirection leads confusion program complicated visit reference pointer reference pointer pointer pointer reference pointer pointer reference program references null pointers sentinel cheap avoid function overloading bool arithmetic pointer direct answer reference specific instance type object type pointer specific instance type object type iso definition object type object type qualified type function type reference type void object type level category type universe reference level category pointer pointers references mentioned context compound type basically nature declarator syntax inherited extended references kind declarator references pointers unityped drafting language specific extension style context reasonable argue syntax declarators wastes syntactic expressiveness lot human users implementations frustrating qualified built language design totally topic design insignificant pointers qualified specific sorts types references simply share common properties syntax similarity cases note statements mentions pointers references types interested questions instances variables misconceptions differences level categories reveal concrete differences tied pointers directly object types level qualifiers references variable object types occupy storage abstract machine semantics reference occupy storage misconceptions details special rules references compound declarators restrictive references references collapse special rules parameters forwarding references based reference collapsing template parameter deduction perfect forwarding parameters references special rules initialization lifetime variable declared reference type ordinary objects extension btw contexts initialization involving rules reference lifetime extension worms misconceptions syntactic sugar references syntactic sugar code easier read write technically plain wrong references syntactic sugar features replaced features semantic differences lambda expression syntactic sugar features precisely simulated unspecified properties declaration order captured variables initialization order variables kinds syntactic sugars strict sense instance inherited built overloaded operator defined semantic properties specific forms combination built operator unary binary storage pointer reference memory statement simply wrong avoid misconceptions iso rules intro object object occupies region storage period construction lifetime period destruction dcl unspecified reference requires storage note semantic properties pragmatics pointers qualified references sense language design arguments making debatable choice contexts making choices parameter types story things pointers references stick specific choices cases answer short necessity pointers pointers bad imply things expect rely implicit assumptions undermining maintainability portability code unnecessarily relying pointers bad style avoided sense modern reconsider purpose finally pointer feature sorts cases language rules explicitly require specific types features obey rules copy constructors require specific types reference type st parameter type qualified constructors require specific types reference type st parameter type qualifiers specific overloads operators require reference reference types overloaded special member functions requires reference types st parameter copy constructors postfix requires dummy pass reference types sufficient directly implementation supporting mandated copy elision warning exhaustively reason necessity complicated operate handles ownership smart pointers homebrew require opaque raw pointers iterations range iterators ranges provided standard library raw pointers convinced raw pointers header dependencies specific cases pass sufficient explicit nullable semantics wrapper raw pointers pass ideal reasons nullable semantics lvalue rvalue forwarding references semantics traditional pointer library fundamental exceptions worked current language implementing smart pointers deal raw pointers specific language interoperation routines require pointers safer compared ordinary object pointers rules unexpected pointer arithmetics relying conforming extension gnu function pointers converted lambda expressions captures function references function pointers generic code cases deliberately nullable values practice answer obvious doubt avoid pointers pointers explicit reasons exceptional cases mentioned choices purely specific language implementation specific instances serve style apis meet abi requirements specific implementations interoperate runtime language implementations including assemblies language runtime ffi high level client languages based assumptions specific implementations improve efficiency translation compilation linking extreme cases avoid symbol bloat extreme cases language neutrality caveats question google search result specific wrong place references odd essentially class treated objects functions referred chance support class operations left operand member access operator independently type referred object languages restrictions references references preserve meaning languages references general imply nonnull properties values assumptions work languages counterexamples easily common properties references programming languages general leave questions note question earlier languages involved algol fundamental difference pointers references mentioned references enable pass reference semantics function arguments pointers visible provide pass semantics nicely article rzej risk adding confusion throw input depends compiler implements references case gcc idea reference point variable stack correct outputs notice memory addresses meaning reference pointing variable heap freaky works outputs reference pointer hood storing memory address address pointing irrelevant happen called std cout str_ref calling delete str_ref compiles fine segmentation fault runtime longer pointing valid variable essentially broken reference exists falls scope useless reference pointer pointer mechanics abstracted making safer easier accidental pointer math mixing assuming nonsense examples compiler handles references kind pointer hood reference refer specific variable specific memory address work expected term reference major rule remember references defined time declaration exception reference header case defined constructor object contained constructed late define remember examples examples demonstrating reference reference ways proper usage reference plenty answers hit nail head difference pointers void type pointer references void forbidden happy difference prefer allowed meaning reference address behavior references define equivalents library functions memcpy references reference parameter function inlined handled differently pointer compilers inlining pointer version force write memory address explicitly leave reference register optimal functions inlined pointer reference generate code pass intrinsics reference modified returned function interesting references supply default argument user defined type default flavor bind const reference temporary aspect references program comprehending answer question simple program reference pointer ptr pointing variable program output understand spare minutes watch video youtube watch rljrrgv0iog feel point covered pointers references syntactically equivalent object refer operation applied object works reference exact syntax exception initialization superficial property crucial number features templates template parameters duck typed syntactic properties type matters template relies implicit cast templates cover common lvalues statement references work strings returning character reference user defined classes notation copy constructors syntactically sense pass objects copy constructors pointers objects copy constructor object result recursive copy constructor leaves references option operator overloads references introduce indirection operator retaining infix notation works regular overloaded functions points empower considerable standard library major property references technical difference pointers references argument passed function pointer visible argument passed function const reference passed modify modify argument pass pointer argument preceded knew modified converse modified true pass large read structures pointer argue feature reading code pointer parameters modifiable parameters references function expects people argue function signatures allowed google style guidelines metaphors context desktop screenspace reference requires actual window pointer requires location piece space screen assure instances window type difference pointer reference pointer initialized reference fact reference refer object pointer null pointer fact properly declared defined object reference object correct implementation previous code point declaration pointer initialization thing case reference reference variable object pointer risky generally check pointer pointing case reference check referencing object declaration mandatory difference pointer point object reference referencing object point template stl template kind class template return reference pointer easy reading assigning operator difference constant pointer variable confused pointer constant changed time program execution requires pointer semantics operators references set initialization set constructor initializer list ordinary accessing semantics basically references introduced support operators overloading read book stated thread pointer set null nullptr pointer initialized error dereference null pointer pointer point correct memory location references turn user initialize reference referenced fact provide rvalue correct type lot ways reference variable initialized wrong memory location dig deep details machine level pointer reference work uniformly pointers essential references syntactic sugar rvalue references naturally stack heap objects decide rule core guidelines prefer argument valid option