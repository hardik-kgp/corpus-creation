advanced data structures practice  years programming count number data structures hand arrays linked lists lumping stacks queues dictionaries surprising applications written fall forms data crud category needed red black tree skip list double ended queue circularly linked list priority queue heaps graphs dozens exotic data structures researched  years feel missing open ended question exotic data structures practice real experience data structures solve problem examples vague work employers heap google style search starting candidates linearly sifting min heap max size image search prototype bloom filters cut size data millions users fit existing servers ram speed original design needed servers database triangular array representation halved size dense symmetrical array recommendation engine ram reason users grouped associations union easy quick exact slow hacky approximate app choosing retail sites drive time people neighborhood dijkstra shortest path priority queues gis work advantage quadtrees morton indexes knowing data structures land handy weeks lab save hours library bloom filter case worthwhile scale problem startup yahoo plain hashtable examples reasonable nowadays code trees databases trees geographic searches  shapes bounding box scattered  plane shapes intersect arbitrary bounding box deques form stl growable vectors memory efficient linked lists constant time peek arbitrary elements middle remember deque extent insert delete ends general stack insert delete queue insert delete high performance access view arbitrary elements middle finished reading generics collections generics hurts head collections point differences skip lists trees implement maps sets skip lists built constant time iteration element trees log simpler implementing lock free algorithms multithreaded situations priority queues scheduling things webpage discusses application heaps implement heapsort easiest log sorts understand implement scenes libraries ordered dictionary data structure associative array alows sorted traversal keys implemented red black tree data structures splay trees mind interesting optimal behaviour circumstances temporal locality reference case splay trees relevant cases circumstances real benefit working knowledge data structures employ circumstances reasonable understanding behaviour sorting circumstances quicksort modified quicksort drops method individual segments small typically fastest sorting algorithm purposes quicksort suboptimal behaviour sorted data main advantage heap sort situ minimal intermediate storage good memory constrained systems slower average log suffer poor worst case performance quicksort merge sort sequentially making choice sorting data sets larger main memory external sort meaning sort external storage disk tape intermediate depends level abstraction work experience current level abstraction software development dictionary list main data structures lower level code exotic data structures ring buffers circular queues constantly embedded work service interrupts serial ports tree structures heavily computer graphics stl map set data structures red black tree knowing fancy data structures higher level algorithms main mind graph priority queue implemented heap finance tree calculate instrument depends dynamic values spreadsheets tree dependencies compilers create abstract syntax tree translating machine code fibonacci heaps efficient implementations dijkstra algorithm problem number people apply people revert arrays linked lists job cases advanced data structure kick place efficient people tend easier fault lot advanced concepts programming graphs question stackoverflow circular linked lists implement queues iterate forever network connection queue higher level languages bothering implement queues manner dynamically grow shrink list worrying performance price control memory allocation occurring prices pay flexible lists tend complicated data structures dictated code dealing complex code lower levels core operating writing fundamental parts class library implementing string array write extermely performant multi threaded code place play role implementing specific algorithms searching sampling statistical analysis optimization algorithms written data structures mind sets sorted collections elements sorted order support fast element insertion lazy lists balanced trees red black typically implementation abstract data type small number abstract data types list map ordered map multi map ordered multi map priority queue lot ordered multi map likewise set lot map values keys time time priority queue data structure applications sorts algorithms scheduling path finding dictionary meant map ordered map maps unordered typically implemented hash subset ordered map circular list caching class template interface objects instatinations return types screens views graphical interface scenes requested screen created expensive operation pushed head ring buffer pushing oldest unloading textures compromise achieved reading bunch image files hard disk loading images ram keeping forever compromise controlled length buffers